{"pr_number": 5842, "pr_title": "AI add buying zero move units", "pr_createdAt": "2020-01-12T18:12:52Z", "pr_url": "https://github.com/triplea-game/triplea/pull/5842", "timeline": [{"oid": "2433ee86ca67a58344da6bd0be2b2c14542ebe65", "url": "https://github.com/triplea-game/triplea/commit/2433ee86ca67a58344da6bd0be2b2c14542ebe65", "message": "AI add buying zero move units", "committedDate": "2020-01-12T18:08:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTYwMDg4Mw==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r365600883", "bodyText": "Method hasReachedMaxUnitBuiltPerPlayer has 5 arguments (exceeds 4 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-12T18:14:44Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseUtils.java", "diffHunk": "@@ -135,45 +136,149 @@ public static void removeInvalidPurchaseOptions(\n       final int remainingUnitProduction,\n       final List<Unit> unitsToPlace,\n       final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n \n     for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n       final ProPurchaseOption purchaseOption = it.next();\n-\n-      // Check PU cost and production\n-      if (!resourceTracker.hasEnough(purchaseOption)\n-          || purchaseOption.getQuantity() > remainingUnitProduction) {\n+      if (!hasEnoughResourcesAndProduction(\n+          purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)) {\n         it.remove();\n         continue;\n       }\n-\n-      // Check max unit limits (-1 is unlimited)\n-      final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n-      final UnitType type = purchaseOption.getUnitType();\n-      if (maxBuilt == 0) {\n+      if (hasReachedMaxUnitBuiltPerPlayer(\n+          purchaseOption, player, data, unitsToPlace, purchaseTerritories)) {\n         it.remove();\n-      } else if (maxBuilt > 0) {\n-\n-        // Find number of unit type that are already built and about to be placed\n-        int currentlyBuilt = 0;\n-        final Predicate<Unit> unitTypeOwnedBy =\n-            Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n-        final List<Territory> allTerritories = data.getMap().getTerritories();\n-        for (final Territory t : allTerritories) {\n-          currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+        continue;\n+      }\n+      if (hasReachedConstructionLimits(\n+          purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n+        it.remove();\n+      }\n+    }\n+  }\n+\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(\n+      final ProPurchaseOption purchaseOption,", "originalCommit": "2433ee86ca67a58344da6bd0be2b2c14542ebe65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTYwMDg4NA==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r365600884", "bodyText": "Method hasReachedConstructionLimits has 5 arguments (exceeds 4 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-12T18:14:44Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseUtils.java", "diffHunk": "@@ -135,45 +136,149 @@ public static void removeInvalidPurchaseOptions(\n       final int remainingUnitProduction,\n       final List<Unit> unitsToPlace,\n       final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n \n     for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n       final ProPurchaseOption purchaseOption = it.next();\n-\n-      // Check PU cost and production\n-      if (!resourceTracker.hasEnough(purchaseOption)\n-          || purchaseOption.getQuantity() > remainingUnitProduction) {\n+      if (!hasEnoughResourcesAndProduction(\n+          purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)) {\n         it.remove();\n         continue;\n       }\n-\n-      // Check max unit limits (-1 is unlimited)\n-      final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n-      final UnitType type = purchaseOption.getUnitType();\n-      if (maxBuilt == 0) {\n+      if (hasReachedMaxUnitBuiltPerPlayer(\n+          purchaseOption, player, data, unitsToPlace, purchaseTerritories)) {\n         it.remove();\n-      } else if (maxBuilt > 0) {\n-\n-        // Find number of unit type that are already built and about to be placed\n-        int currentlyBuilt = 0;\n-        final Predicate<Unit> unitTypeOwnedBy =\n-            Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n-        final List<Territory> allTerritories = data.getMap().getTerritories();\n-        for (final Territory t : allTerritories) {\n-          currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+        continue;\n+      }\n+      if (hasReachedConstructionLimits(\n+          purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n+        it.remove();\n+      }\n+    }\n+  }\n+\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(\n+      final ProPurchaseOption purchaseOption,\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+\n+    // Check max unit limits (-1 is unlimited)\n+    final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n+    final UnitType type = purchaseOption.getUnitType();\n+    if (maxBuilt == 0) {\n+      return true;\n+    } else if (maxBuilt > 0) {\n+\n+      // Find number of unit type that are already built and about to be placed\n+      int currentlyBuilt = 0;\n+      final Predicate<Unit> unitTypeOwnedBy =\n+          Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n+      final List<Territory> allTerritories = data.getMap().getTerritories();\n+      for (final Territory t : allTerritories) {\n+        currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+      }\n+      currentlyBuilt += CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n+      for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n+        for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n+          currentlyBuilt +=\n+              CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n         }\n-        currentlyBuilt += CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n-        for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n-          for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n-            currentlyBuilt +=\n-                CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n+      }\n+      final int allowedBuild = maxBuilt - currentlyBuilt;\n+      if (allowedBuild - purchaseOption.getQuantity() < 0) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static boolean hasReachedConstructionLimits(\n+      final ProPurchaseOption purchaseOption,", "originalCommit": "2433ee86ca67a58344da6bd0be2b2c14542ebe65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTYwMDg4NQ==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r365600885", "bodyText": "Method hasReachedMaxUnitBuiltPerPlayer has a Cognitive Complexity of 11 (exceeds 5 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-12T18:14:44Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseUtils.java", "diffHunk": "@@ -135,45 +136,149 @@ public static void removeInvalidPurchaseOptions(\n       final int remainingUnitProduction,\n       final List<Unit> unitsToPlace,\n       final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n \n     for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n       final ProPurchaseOption purchaseOption = it.next();\n-\n-      // Check PU cost and production\n-      if (!resourceTracker.hasEnough(purchaseOption)\n-          || purchaseOption.getQuantity() > remainingUnitProduction) {\n+      if (!hasEnoughResourcesAndProduction(\n+          purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)) {\n         it.remove();\n         continue;\n       }\n-\n-      // Check max unit limits (-1 is unlimited)\n-      final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n-      final UnitType type = purchaseOption.getUnitType();\n-      if (maxBuilt == 0) {\n+      if (hasReachedMaxUnitBuiltPerPlayer(\n+          purchaseOption, player, data, unitsToPlace, purchaseTerritories)) {\n         it.remove();\n-      } else if (maxBuilt > 0) {\n-\n-        // Find number of unit type that are already built and about to be placed\n-        int currentlyBuilt = 0;\n-        final Predicate<Unit> unitTypeOwnedBy =\n-            Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n-        final List<Territory> allTerritories = data.getMap().getTerritories();\n-        for (final Territory t : allTerritories) {\n-          currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+        continue;\n+      }\n+      if (hasReachedConstructionLimits(\n+          purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n+        it.remove();\n+      }\n+    }\n+  }\n+\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(", "originalCommit": "2433ee86ca67a58344da6bd0be2b2c14542ebe65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTYwMDg4Ng==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r365600886", "bodyText": "Method hasReachedConstructionLimits has a Cognitive Complexity of 26 (exceeds 5 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-12T18:14:44Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseUtils.java", "diffHunk": "@@ -135,45 +136,149 @@ public static void removeInvalidPurchaseOptions(\n       final int remainingUnitProduction,\n       final List<Unit> unitsToPlace,\n       final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n \n     for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n       final ProPurchaseOption purchaseOption = it.next();\n-\n-      // Check PU cost and production\n-      if (!resourceTracker.hasEnough(purchaseOption)\n-          || purchaseOption.getQuantity() > remainingUnitProduction) {\n+      if (!hasEnoughResourcesAndProduction(\n+          purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)) {\n         it.remove();\n         continue;\n       }\n-\n-      // Check max unit limits (-1 is unlimited)\n-      final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n-      final UnitType type = purchaseOption.getUnitType();\n-      if (maxBuilt == 0) {\n+      if (hasReachedMaxUnitBuiltPerPlayer(\n+          purchaseOption, player, data, unitsToPlace, purchaseTerritories)) {\n         it.remove();\n-      } else if (maxBuilt > 0) {\n-\n-        // Find number of unit type that are already built and about to be placed\n-        int currentlyBuilt = 0;\n-        final Predicate<Unit> unitTypeOwnedBy =\n-            Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n-        final List<Territory> allTerritories = data.getMap().getTerritories();\n-        for (final Territory t : allTerritories) {\n-          currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+        continue;\n+      }\n+      if (hasReachedConstructionLimits(\n+          purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n+        it.remove();\n+      }\n+    }\n+  }\n+\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(\n+      final ProPurchaseOption purchaseOption,\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+\n+    // Check max unit limits (-1 is unlimited)\n+    final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n+    final UnitType type = purchaseOption.getUnitType();\n+    if (maxBuilt == 0) {\n+      return true;\n+    } else if (maxBuilt > 0) {\n+\n+      // Find number of unit type that are already built and about to be placed\n+      int currentlyBuilt = 0;\n+      final Predicate<Unit> unitTypeOwnedBy =\n+          Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n+      final List<Territory> allTerritories = data.getMap().getTerritories();\n+      for (final Territory t : allTerritories) {\n+        currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+      }\n+      currentlyBuilt += CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n+      for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n+        for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n+          currentlyBuilt +=\n+              CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n         }\n-        currentlyBuilt += CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n-        for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n-          for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n-            currentlyBuilt +=\n-                CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n+      }\n+      final int allowedBuild = maxBuilt - currentlyBuilt;\n+      if (allowedBuild - purchaseOption.getQuantity() < 0) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static boolean hasReachedConstructionLimits(", "originalCommit": "2433ee86ca67a58344da6bd0be2b2c14542ebe65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTYwMDg4Nw==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r365600887", "bodyText": "Method hasReachedConstructionLimits has 41 lines of code (exceeds 25 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-12T18:14:45Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseUtils.java", "diffHunk": "@@ -135,45 +136,149 @@ public static void removeInvalidPurchaseOptions(\n       final int remainingUnitProduction,\n       final List<Unit> unitsToPlace,\n       final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n \n     for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n       final ProPurchaseOption purchaseOption = it.next();\n-\n-      // Check PU cost and production\n-      if (!resourceTracker.hasEnough(purchaseOption)\n-          || purchaseOption.getQuantity() > remainingUnitProduction) {\n+      if (!hasEnoughResourcesAndProduction(\n+          purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)) {\n         it.remove();\n         continue;\n       }\n-\n-      // Check max unit limits (-1 is unlimited)\n-      final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n-      final UnitType type = purchaseOption.getUnitType();\n-      if (maxBuilt == 0) {\n+      if (hasReachedMaxUnitBuiltPerPlayer(\n+          purchaseOption, player, data, unitsToPlace, purchaseTerritories)) {\n         it.remove();\n-      } else if (maxBuilt > 0) {\n-\n-        // Find number of unit type that are already built and about to be placed\n-        int currentlyBuilt = 0;\n-        final Predicate<Unit> unitTypeOwnedBy =\n-            Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n-        final List<Territory> allTerritories = data.getMap().getTerritories();\n-        for (final Territory t : allTerritories) {\n-          currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+        continue;\n+      }\n+      if (hasReachedConstructionLimits(\n+          purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n+        it.remove();\n+      }\n+    }\n+  }\n+\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(\n+      final ProPurchaseOption purchaseOption,\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+\n+    // Check max unit limits (-1 is unlimited)\n+    final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n+    final UnitType type = purchaseOption.getUnitType();\n+    if (maxBuilt == 0) {\n+      return true;\n+    } else if (maxBuilt > 0) {\n+\n+      // Find number of unit type that are already built and about to be placed\n+      int currentlyBuilt = 0;\n+      final Predicate<Unit> unitTypeOwnedBy =\n+          Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n+      final List<Territory> allTerritories = data.getMap().getTerritories();\n+      for (final Territory t : allTerritories) {\n+        currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+      }\n+      currentlyBuilt += CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n+      for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n+        for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n+          currentlyBuilt +=\n+              CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n         }\n-        currentlyBuilt += CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n-        for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n-          for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n-            currentlyBuilt +=\n-                CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n+      }\n+      final int allowedBuild = maxBuilt - currentlyBuilt;\n+      if (allowedBuild - purchaseOption.getQuantity() < 0) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static boolean hasReachedConstructionLimits(", "originalCommit": "2433ee86ca67a58344da6bd0be2b2c14542ebe65", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a8343b083834308779677ad0322e3c4f187cc1b7", "url": "https://github.com/triplea-game/triplea/commit/a8343b083834308779677ad0322e3c4f187cc1b7", "message": "Remove commented code", "committedDate": "2020-01-12T18:22:46Z", "type": "commit"}, {"oid": "5935be0b01663b9f6fc7bd6bb0f7607ecc9997f8", "url": "https://github.com/triplea-game/triplea/commit/5935be0b01663b9f6fc7bd6bb0f7607ecc9997f8", "message": "Refactor method", "committedDate": "2020-01-12T18:25:30Z", "type": "commit"}, {"oid": "e02c00e6d23d47fb280169299ea7012ff2c1e429", "url": "https://github.com/triplea-game/triplea/commit/e02c00e6d23d47fb280169299ea7012ff2c1e429", "message": "Improve suicide unit check and have fast AI consider 0 strength", "committedDate": "2020-01-13T06:27:50Z", "type": "commit"}, {"oid": "2cb19ea3c77c9b58b7b53ee3c9b7fedbc4b138a4", "url": "https://github.com/triplea-game/triplea/commit/2cb19ea3c77c9b58b7b53ee3c9b7fedbc4b138a4", "message": "Refactor construction validation methods", "committedDate": "2020-01-15T23:07:12Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1NTM0NQ==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367155345", "bodyText": "Method hasReachedConstructionLimits has a Cognitive Complexity of 6 (exceeds 5 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-15T23:08:58Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseUtils.java", "diffHunk": "@@ -135,45 +135,158 @@ public static void removeInvalidPurchaseOptions(\n       final int remainingUnitProduction,\n       final List<Unit> unitsToPlace,\n       final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n \n     for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n       final ProPurchaseOption purchaseOption = it.next();\n-\n-      // Check PU cost and production\n-      if (!resourceTracker.hasEnough(purchaseOption)\n-          || purchaseOption.getQuantity() > remainingUnitProduction) {\n+      if (!hasEnoughResourcesAndProduction(\n+              purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)\n+          || hasReachedMaxUnitBuiltPerPlayer(\n+              purchaseOption, player, data, unitsToPlace, purchaseTerritories)\n+          || hasReachedConstructionLimits(\n+              purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n         it.remove();\n-        continue;\n       }\n+    }\n+  }\n \n-      // Check max unit limits (-1 is unlimited)\n-      final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n-      final UnitType type = purchaseOption.getUnitType();\n-      if (maxBuilt == 0) {\n-        it.remove();\n-      } else if (maxBuilt > 0) {\n-\n-        // Find number of unit type that are already built and about to be placed\n-        int currentlyBuilt = 0;\n-        final Predicate<Unit> unitTypeOwnedBy =\n-            Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n-        final List<Territory> allTerritories = data.getMap().getTerritories();\n-        for (final Territory t : allTerritories) {\n-          currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(\n+      final ProPurchaseOption purchaseOption,\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+\n+    // Check max unit limits (-1 is unlimited)\n+    final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n+    final UnitType type = purchaseOption.getUnitType();\n+    if (maxBuilt == 0) {\n+      return true;\n+    } else if (maxBuilt > 0) {\n+\n+      // Find number of unit type that are already built and about to be placed\n+      final Predicate<Unit> unitTypeOwnedBy =\n+          Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n+      int currentlyBuilt = CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n+      final List<Territory> allTerritories = data.getMap().getTerritories();\n+      for (final Territory t : allTerritories) {\n+        currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+      }\n+      for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n+        for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n+          currentlyBuilt +=\n+              CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n         }\n-        currentlyBuilt += CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n-        for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n-          for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n-            currentlyBuilt +=\n-                CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n-          }\n+      }\n+      final int allowedBuild = maxBuilt - currentlyBuilt;\n+      if (allowedBuild - purchaseOption.getQuantity() < 0) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static boolean hasReachedConstructionLimits(", "originalCommit": "2cb19ea3c77c9b58b7b53ee3c9b7fedbc4b138a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1NTM1MA==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367155350", "bodyText": "Method findNumberOfConstructionTypeToPlace has a Cognitive Complexity of 6 (exceeds 5 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-15T23:08:58Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseUtils.java", "diffHunk": "@@ -135,45 +135,158 @@ public static void removeInvalidPurchaseOptions(\n       final int remainingUnitProduction,\n       final List<Unit> unitsToPlace,\n       final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n \n     for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n       final ProPurchaseOption purchaseOption = it.next();\n-\n-      // Check PU cost and production\n-      if (!resourceTracker.hasEnough(purchaseOption)\n-          || purchaseOption.getQuantity() > remainingUnitProduction) {\n+      if (!hasEnoughResourcesAndProduction(\n+              purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)\n+          || hasReachedMaxUnitBuiltPerPlayer(\n+              purchaseOption, player, data, unitsToPlace, purchaseTerritories)\n+          || hasReachedConstructionLimits(\n+              purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n         it.remove();\n-        continue;\n       }\n+    }\n+  }\n \n-      // Check max unit limits (-1 is unlimited)\n-      final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n-      final UnitType type = purchaseOption.getUnitType();\n-      if (maxBuilt == 0) {\n-        it.remove();\n-      } else if (maxBuilt > 0) {\n-\n-        // Find number of unit type that are already built and about to be placed\n-        int currentlyBuilt = 0;\n-        final Predicate<Unit> unitTypeOwnedBy =\n-            Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n-        final List<Territory> allTerritories = data.getMap().getTerritories();\n-        for (final Territory t : allTerritories) {\n-          currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(\n+      final ProPurchaseOption purchaseOption,\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+\n+    // Check max unit limits (-1 is unlimited)\n+    final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n+    final UnitType type = purchaseOption.getUnitType();\n+    if (maxBuilt == 0) {\n+      return true;\n+    } else if (maxBuilt > 0) {\n+\n+      // Find number of unit type that are already built and about to be placed\n+      final Predicate<Unit> unitTypeOwnedBy =\n+          Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n+      int currentlyBuilt = CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n+      final List<Territory> allTerritories = data.getMap().getTerritories();\n+      for (final Territory t : allTerritories) {\n+        currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+      }\n+      for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n+        for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n+          currentlyBuilt +=\n+              CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n         }\n-        currentlyBuilt += CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n-        for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n-          for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n-            currentlyBuilt +=\n-                CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n-          }\n+      }\n+      final int allowedBuild = maxBuilt - currentlyBuilt;\n+      if (allowedBuild - purchaseOption.getQuantity() < 0) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static boolean hasReachedConstructionLimits(\n+      final ProPurchaseOption purchaseOption,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final Territory territory) {\n+\n+    if (purchaseOption.isConstruction() && territory != null) {\n+\n+      final int numConstructionTypeToPlace =\n+          findNumberOfConstructionTypeToPlace(\n+              purchaseOption, unitsToPlace, purchaseTerritories, territory);\n+      if (numConstructionTypeToPlace >= purchaseOption.getConstructionTypePerTurn()) {\n+        return true;\n+      }\n+\n+      final int maxConstructionType =\n+          findMaxConstructionTypeAllowed(purchaseOption, data, territory);\n+      final int numExistingConstructionType =\n+          CollectionUtils.countMatches(\n+              territory.getUnits(), Matches.unitIsOfType(purchaseOption.getUnitType()));\n+      if ((numConstructionTypeToPlace + numExistingConstructionType) >= maxConstructionType) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static int findNumberOfConstructionTypeToPlace(", "originalCommit": "2cb19ea3c77c9b58b7b53ee3c9b7fedbc4b138a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE1NTM1Mg==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367155352", "bodyText": "Method findMaxConstructionTypeAllowed has a Cognitive Complexity of 8 (exceeds 5 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-15T23:08:58Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseUtils.java", "diffHunk": "@@ -135,45 +135,158 @@ public static void removeInvalidPurchaseOptions(\n       final int remainingUnitProduction,\n       final List<Unit> unitsToPlace,\n       final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n \n     for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n       final ProPurchaseOption purchaseOption = it.next();\n-\n-      // Check PU cost and production\n-      if (!resourceTracker.hasEnough(purchaseOption)\n-          || purchaseOption.getQuantity() > remainingUnitProduction) {\n+      if (!hasEnoughResourcesAndProduction(\n+              purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)\n+          || hasReachedMaxUnitBuiltPerPlayer(\n+              purchaseOption, player, data, unitsToPlace, purchaseTerritories)\n+          || hasReachedConstructionLimits(\n+              purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n         it.remove();\n-        continue;\n       }\n+    }\n+  }\n \n-      // Check max unit limits (-1 is unlimited)\n-      final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n-      final UnitType type = purchaseOption.getUnitType();\n-      if (maxBuilt == 0) {\n-        it.remove();\n-      } else if (maxBuilt > 0) {\n-\n-        // Find number of unit type that are already built and about to be placed\n-        int currentlyBuilt = 0;\n-        final Predicate<Unit> unitTypeOwnedBy =\n-            Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n-        final List<Territory> allTerritories = data.getMap().getTerritories();\n-        for (final Territory t : allTerritories) {\n-          currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(\n+      final ProPurchaseOption purchaseOption,\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+\n+    // Check max unit limits (-1 is unlimited)\n+    final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n+    final UnitType type = purchaseOption.getUnitType();\n+    if (maxBuilt == 0) {\n+      return true;\n+    } else if (maxBuilt > 0) {\n+\n+      // Find number of unit type that are already built and about to be placed\n+      final Predicate<Unit> unitTypeOwnedBy =\n+          Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n+      int currentlyBuilt = CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n+      final List<Territory> allTerritories = data.getMap().getTerritories();\n+      for (final Territory t : allTerritories) {\n+        currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+      }\n+      for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n+        for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n+          currentlyBuilt +=\n+              CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n         }\n-        currentlyBuilt += CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n-        for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n-          for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n-            currentlyBuilt +=\n-                CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n-          }\n+      }\n+      final int allowedBuild = maxBuilt - currentlyBuilt;\n+      if (allowedBuild - purchaseOption.getQuantity() < 0) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static boolean hasReachedConstructionLimits(\n+      final ProPurchaseOption purchaseOption,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final Territory territory) {\n+\n+    if (purchaseOption.isConstruction() && territory != null) {\n+\n+      final int numConstructionTypeToPlace =\n+          findNumberOfConstructionTypeToPlace(\n+              purchaseOption, unitsToPlace, purchaseTerritories, territory);\n+      if (numConstructionTypeToPlace >= purchaseOption.getConstructionTypePerTurn()) {\n+        return true;\n+      }\n+\n+      final int maxConstructionType =\n+          findMaxConstructionTypeAllowed(purchaseOption, data, territory);\n+      final int numExistingConstructionType =\n+          CollectionUtils.countMatches(\n+              territory.getUnits(), Matches.unitIsOfType(purchaseOption.getUnitType()));\n+      if ((numConstructionTypeToPlace + numExistingConstructionType) >= maxConstructionType) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static int findNumberOfConstructionTypeToPlace(\n+      final ProPurchaseOption purchaseOption,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final Territory territory) {\n+\n+    int numConstructionTypeToPlace =\n+        CollectionUtils.countMatches(\n+            unitsToPlace, Matches.unitIsOfType(purchaseOption.getUnitType()));\n+    for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n+      for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n+        if (placeTerritory.getTerritory().equals(territory)) {\n+          numConstructionTypeToPlace +=\n+              CollectionUtils.countMatches(\n+                  placeTerritory.getPlaceUnits(),\n+                  Matches.unitIsOfType(purchaseOption.getUnitType()));\n         }\n-        final int allowedBuild = maxBuilt - currentlyBuilt;\n-        if (allowedBuild - purchaseOption.getQuantity() < 0) {\n-          it.remove();\n+      }\n+    }\n+    return numConstructionTypeToPlace;\n+  }\n+\n+  private static int findMaxConstructionTypeAllowed(", "originalCommit": "2cb19ea3c77c9b58b7b53ee3c9b7fedbc4b138a4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2", "url": "https://github.com/triplea-game/triplea/commit/f380db7d598f5a8573b2144f9bfa74a19c42b5b2", "message": "Separate utils class into 2", "committedDate": "2020-01-15T23:31:55Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQzMA==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162430", "bodyText": "Method removeInvalidPurchaseOptions has 7 arguments (exceeds 4 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-15T23:33:29Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.findPurchaseOptionsForTerritory(\n+        proData, player, purchaseOptions, t, t, isBid);\n+  }\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final List<ProPurchaseOption> result = new ArrayList<>();\n+    for (final ProPurchaseOption ppo : purchaseOptions) {\n+      if (ProPurchaseValidationUtils.canTerritoryUsePurchaseOption(\n+          proData, player, ppo, t, factoryTerritory, isBid)) {\n+        result.add(ppo);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static boolean canTerritoryUsePurchaseOption(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final ProPurchaseOption ppo,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    if (ppo == null) {\n+      return false;\n+    }\n+    final List<Unit> units = ppo.getUnitType().create(ppo.getQuantity(), player, true);\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(\n+        proData, units, player, t, factoryTerritory, isBid);\n+  }\n+\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(proData, units, player, t, t, isBid);\n+  }\n+\n+  /** Check if units can be placed in given territory by specified factory. */\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final GameData data = player.getData();\n+    AbstractPlaceDelegate placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"place\");\n+    if (isBid) {\n+      placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"placeBid\");\n+    } else if (!t.equals(factoryTerritory)\n+        && !units.stream()\n+            .allMatch(\n+                Matches.unitWhichRequiresUnitsHasRequiredUnitsInList(\n+                    placeDelegate.unitsAtStartOfStepInTerritory(factoryTerritory)))) {\n+      return false;\n+    }\n+    final IDelegateBridge bridge = new ProDummyDelegateBridge(proData.getProAi(), player, data);\n+    placeDelegate.setDelegateBridgeAndPlayer(bridge);\n+    return isPlacingFightersOnNewCarriers(t, units)\n+        ? placeDelegate.canUnitsBePlaced(\n+                t, CollectionUtils.getMatches(units, Matches.unitIsNotAir()), player)\n+            == null\n+        : placeDelegate.canUnitsBePlaced(t, units, player) == null;\n+  }\n+\n+  private static boolean isPlacingFightersOnNewCarriers(final Territory t, final List<Unit> units) {\n+    return t.isWater()\n+        && Properties.getProduceFightersOnCarriers(t.getData())\n+        && units.stream().anyMatch(Matches.unitIsAir())\n+        && units.stream().anyMatch(Matches.unitIsCarrier());\n+  }\n+\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,", "originalCommit": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQzMQ==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162431", "bodyText": "Method removeInvalidPurchaseOptions has 9 arguments (exceeds 4 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-15T23:33:29Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.findPurchaseOptionsForTerritory(\n+        proData, player, purchaseOptions, t, t, isBid);\n+  }\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final List<ProPurchaseOption> result = new ArrayList<>();\n+    for (final ProPurchaseOption ppo : purchaseOptions) {\n+      if (ProPurchaseValidationUtils.canTerritoryUsePurchaseOption(\n+          proData, player, ppo, t, factoryTerritory, isBid)) {\n+        result.add(ppo);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static boolean canTerritoryUsePurchaseOption(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final ProPurchaseOption ppo,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    if (ppo == null) {\n+      return false;\n+    }\n+    final List<Unit> units = ppo.getUnitType().create(ppo.getQuantity(), player, true);\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(\n+        proData, units, player, t, factoryTerritory, isBid);\n+  }\n+\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(proData, units, player, t, t, isBid);\n+  }\n+\n+  /** Check if units can be placed in given territory by specified factory. */\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final GameData data = player.getData();\n+    AbstractPlaceDelegate placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"place\");\n+    if (isBid) {\n+      placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"placeBid\");\n+    } else if (!t.equals(factoryTerritory)\n+        && !units.stream()\n+            .allMatch(\n+                Matches.unitWhichRequiresUnitsHasRequiredUnitsInList(\n+                    placeDelegate.unitsAtStartOfStepInTerritory(factoryTerritory)))) {\n+      return false;\n+    }\n+    final IDelegateBridge bridge = new ProDummyDelegateBridge(proData.getProAi(), player, data);\n+    placeDelegate.setDelegateBridgeAndPlayer(bridge);\n+    return isPlacingFightersOnNewCarriers(t, units)\n+        ? placeDelegate.canUnitsBePlaced(\n+                t, CollectionUtils.getMatches(units, Matches.unitIsNotAir()), player)\n+            == null\n+        : placeDelegate.canUnitsBePlaced(t, units, player) == null;\n+  }\n+\n+  private static boolean isPlacingFightersOnNewCarriers(final Territory t, final List<Unit> units) {\n+    return t.isWater()\n+        && Properties.getProduceFightersOnCarriers(t.getData())\n+        && units.stream().anyMatch(Matches.unitIsAir())\n+        && units.stream().anyMatch(Matches.unitIsCarrier());\n+  }\n+\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseValidationUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,", "originalCommit": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQzMw==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162433", "bodyText": "Method hasReachedMaxUnitBuiltPerPlayer has 5 arguments (exceeds 4 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-15T23:33:29Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.findPurchaseOptionsForTerritory(\n+        proData, player, purchaseOptions, t, t, isBid);\n+  }\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final List<ProPurchaseOption> result = new ArrayList<>();\n+    for (final ProPurchaseOption ppo : purchaseOptions) {\n+      if (ProPurchaseValidationUtils.canTerritoryUsePurchaseOption(\n+          proData, player, ppo, t, factoryTerritory, isBid)) {\n+        result.add(ppo);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static boolean canTerritoryUsePurchaseOption(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final ProPurchaseOption ppo,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    if (ppo == null) {\n+      return false;\n+    }\n+    final List<Unit> units = ppo.getUnitType().create(ppo.getQuantity(), player, true);\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(\n+        proData, units, player, t, factoryTerritory, isBid);\n+  }\n+\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(proData, units, player, t, t, isBid);\n+  }\n+\n+  /** Check if units can be placed in given territory by specified factory. */\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final GameData data = player.getData();\n+    AbstractPlaceDelegate placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"place\");\n+    if (isBid) {\n+      placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"placeBid\");\n+    } else if (!t.equals(factoryTerritory)\n+        && !units.stream()\n+            .allMatch(\n+                Matches.unitWhichRequiresUnitsHasRequiredUnitsInList(\n+                    placeDelegate.unitsAtStartOfStepInTerritory(factoryTerritory)))) {\n+      return false;\n+    }\n+    final IDelegateBridge bridge = new ProDummyDelegateBridge(proData.getProAi(), player, data);\n+    placeDelegate.setDelegateBridgeAndPlayer(bridge);\n+    return isPlacingFightersOnNewCarriers(t, units)\n+        ? placeDelegate.canUnitsBePlaced(\n+                t, CollectionUtils.getMatches(units, Matches.unitIsNotAir()), player)\n+            == null\n+        : placeDelegate.canUnitsBePlaced(t, units, player) == null;\n+  }\n+\n+  private static boolean isPlacingFightersOnNewCarriers(final Territory t, final List<Unit> units) {\n+    return t.isWater()\n+        && Properties.getProduceFightersOnCarriers(t.getData())\n+        && units.stream().anyMatch(Matches.unitIsAir())\n+        && units.stream().anyMatch(Matches.unitIsCarrier());\n+  }\n+\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseValidationUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n+\n+    for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n+      final ProPurchaseOption purchaseOption = it.next();\n+      if (!hasEnoughResourcesAndProduction(\n+              purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)\n+          || hasReachedMaxUnitBuiltPerPlayer(\n+              purchaseOption, player, data, unitsToPlace, purchaseTerritories)\n+          || hasReachedConstructionLimits(\n+              purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n+        it.remove();\n+      }\n+    }\n+  }\n+\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(\n+      final ProPurchaseOption purchaseOption,", "originalCommit": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQzNQ==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162435", "bodyText": "Method canUnitsBePlaced has 5 arguments (exceeds 4 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-15T23:33:30Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.findPurchaseOptionsForTerritory(\n+        proData, player, purchaseOptions, t, t, isBid);\n+  }\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final List<ProPurchaseOption> result = new ArrayList<>();\n+    for (final ProPurchaseOption ppo : purchaseOptions) {\n+      if (ProPurchaseValidationUtils.canTerritoryUsePurchaseOption(\n+          proData, player, ppo, t, factoryTerritory, isBid)) {\n+        result.add(ppo);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static boolean canTerritoryUsePurchaseOption(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final ProPurchaseOption ppo,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    if (ppo == null) {\n+      return false;\n+    }\n+    final List<Unit> units = ppo.getUnitType().create(ppo.getQuantity(), player, true);\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(\n+        proData, units, player, t, factoryTerritory, isBid);\n+  }\n+\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,", "originalCommit": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQzNw==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162437", "bodyText": "Method canUnitsBePlaced has 6 arguments (exceeds 4 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-15T23:33:30Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.findPurchaseOptionsForTerritory(\n+        proData, player, purchaseOptions, t, t, isBid);\n+  }\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final List<ProPurchaseOption> result = new ArrayList<>();\n+    for (final ProPurchaseOption ppo : purchaseOptions) {\n+      if (ProPurchaseValidationUtils.canTerritoryUsePurchaseOption(\n+          proData, player, ppo, t, factoryTerritory, isBid)) {\n+        result.add(ppo);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static boolean canTerritoryUsePurchaseOption(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final ProPurchaseOption ppo,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    if (ppo == null) {\n+      return false;\n+    }\n+    final List<Unit> units = ppo.getUnitType().create(ppo.getQuantity(), player, true);\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(\n+        proData, units, player, t, factoryTerritory, isBid);\n+  }\n+\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(proData, units, player, t, t, isBid);\n+  }\n+\n+  /** Check if units can be placed in given territory by specified factory. */\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,", "originalCommit": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQzOQ==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162439", "bodyText": "Method findPurchaseOptionsForTerritory has 5 arguments (exceeds 4 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-15T23:33:30Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,", "originalCommit": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQ0MQ==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162441", "bodyText": "Method findPurchaseOptionsForTerritory has 6 arguments (exceeds 4 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-15T23:33:30Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.findPurchaseOptionsForTerritory(\n+        proData, player, purchaseOptions, t, t, isBid);\n+  }\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,", "originalCommit": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQ0Mg==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162442", "bodyText": "Method canTerritoryUsePurchaseOption has 6 arguments (exceeds 4 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-15T23:33:30Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.findPurchaseOptionsForTerritory(\n+        proData, player, purchaseOptions, t, t, isBid);\n+  }\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final List<ProPurchaseOption> result = new ArrayList<>();\n+    for (final ProPurchaseOption ppo : purchaseOptions) {\n+      if (ProPurchaseValidationUtils.canTerritoryUsePurchaseOption(\n+          proData, player, ppo, t, factoryTerritory, isBid)) {\n+        result.add(ppo);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static boolean canTerritoryUsePurchaseOption(\n+      final ProData proData,", "originalCommit": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQ0NA==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162444", "bodyText": "Method hasReachedConstructionLimits has 5 arguments (exceeds 4 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-15T23:33:30Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.findPurchaseOptionsForTerritory(\n+        proData, player, purchaseOptions, t, t, isBid);\n+  }\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final List<ProPurchaseOption> result = new ArrayList<>();\n+    for (final ProPurchaseOption ppo : purchaseOptions) {\n+      if (ProPurchaseValidationUtils.canTerritoryUsePurchaseOption(\n+          proData, player, ppo, t, factoryTerritory, isBid)) {\n+        result.add(ppo);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static boolean canTerritoryUsePurchaseOption(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final ProPurchaseOption ppo,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    if (ppo == null) {\n+      return false;\n+    }\n+    final List<Unit> units = ppo.getUnitType().create(ppo.getQuantity(), player, true);\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(\n+        proData, units, player, t, factoryTerritory, isBid);\n+  }\n+\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(proData, units, player, t, t, isBid);\n+  }\n+\n+  /** Check if units can be placed in given territory by specified factory. */\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final GameData data = player.getData();\n+    AbstractPlaceDelegate placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"place\");\n+    if (isBid) {\n+      placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"placeBid\");\n+    } else if (!t.equals(factoryTerritory)\n+        && !units.stream()\n+            .allMatch(\n+                Matches.unitWhichRequiresUnitsHasRequiredUnitsInList(\n+                    placeDelegate.unitsAtStartOfStepInTerritory(factoryTerritory)))) {\n+      return false;\n+    }\n+    final IDelegateBridge bridge = new ProDummyDelegateBridge(proData.getProAi(), player, data);\n+    placeDelegate.setDelegateBridgeAndPlayer(bridge);\n+    return isPlacingFightersOnNewCarriers(t, units)\n+        ? placeDelegate.canUnitsBePlaced(\n+                t, CollectionUtils.getMatches(units, Matches.unitIsNotAir()), player)\n+            == null\n+        : placeDelegate.canUnitsBePlaced(t, units, player) == null;\n+  }\n+\n+  private static boolean isPlacingFightersOnNewCarriers(final Territory t, final List<Unit> units) {\n+    return t.isWater()\n+        && Properties.getProduceFightersOnCarriers(t.getData())\n+        && units.stream().anyMatch(Matches.unitIsAir())\n+        && units.stream().anyMatch(Matches.unitIsCarrier());\n+  }\n+\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseValidationUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n+\n+    for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n+      final ProPurchaseOption purchaseOption = it.next();\n+      if (!hasEnoughResourcesAndProduction(\n+              purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)\n+          || hasReachedMaxUnitBuiltPerPlayer(\n+              purchaseOption, player, data, unitsToPlace, purchaseTerritories)\n+          || hasReachedConstructionLimits(\n+              purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n+        it.remove();\n+      }\n+    }\n+  }\n+\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(\n+      final ProPurchaseOption purchaseOption,\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+\n+    // Check max unit limits (-1 is unlimited)\n+    final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n+    final UnitType type = purchaseOption.getUnitType();\n+    if (maxBuilt == 0) {\n+      return true;\n+    } else if (maxBuilt > 0) {\n+\n+      // Find number of unit type that are already built and about to be placed\n+      final Predicate<Unit> unitTypeOwnedBy =\n+          Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n+      int currentlyBuilt = CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n+      final List<Territory> allTerritories = data.getMap().getTerritories();\n+      for (final Territory t : allTerritories) {\n+        currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+      }\n+      for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n+        for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n+          currentlyBuilt +=\n+              CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n+        }\n+      }\n+      final int allowedBuild = maxBuilt - currentlyBuilt;\n+      if (allowedBuild - purchaseOption.getQuantity() < 0) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static boolean hasReachedConstructionLimits(\n+      final ProPurchaseOption purchaseOption,", "originalCommit": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQ0NQ==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162445", "bodyText": "File ProPurchaseValidationUtils.java has 251 lines of code (exceeds 250 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-15T23:33:31Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;", "originalCommit": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQ0OA==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162448", "bodyText": "Method hasReachedMaxUnitBuiltPerPlayer has a Cognitive Complexity of 11 (exceeds 5 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-15T23:33:31Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.findPurchaseOptionsForTerritory(\n+        proData, player, purchaseOptions, t, t, isBid);\n+  }\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final List<ProPurchaseOption> result = new ArrayList<>();\n+    for (final ProPurchaseOption ppo : purchaseOptions) {\n+      if (ProPurchaseValidationUtils.canTerritoryUsePurchaseOption(\n+          proData, player, ppo, t, factoryTerritory, isBid)) {\n+        result.add(ppo);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static boolean canTerritoryUsePurchaseOption(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final ProPurchaseOption ppo,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    if (ppo == null) {\n+      return false;\n+    }\n+    final List<Unit> units = ppo.getUnitType().create(ppo.getQuantity(), player, true);\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(\n+        proData, units, player, t, factoryTerritory, isBid);\n+  }\n+\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(proData, units, player, t, t, isBid);\n+  }\n+\n+  /** Check if units can be placed in given territory by specified factory. */\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final GameData data = player.getData();\n+    AbstractPlaceDelegate placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"place\");\n+    if (isBid) {\n+      placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"placeBid\");\n+    } else if (!t.equals(factoryTerritory)\n+        && !units.stream()\n+            .allMatch(\n+                Matches.unitWhichRequiresUnitsHasRequiredUnitsInList(\n+                    placeDelegate.unitsAtStartOfStepInTerritory(factoryTerritory)))) {\n+      return false;\n+    }\n+    final IDelegateBridge bridge = new ProDummyDelegateBridge(proData.getProAi(), player, data);\n+    placeDelegate.setDelegateBridgeAndPlayer(bridge);\n+    return isPlacingFightersOnNewCarriers(t, units)\n+        ? placeDelegate.canUnitsBePlaced(\n+                t, CollectionUtils.getMatches(units, Matches.unitIsNotAir()), player)\n+            == null\n+        : placeDelegate.canUnitsBePlaced(t, units, player) == null;\n+  }\n+\n+  private static boolean isPlacingFightersOnNewCarriers(final Territory t, final List<Unit> units) {\n+    return t.isWater()\n+        && Properties.getProduceFightersOnCarriers(t.getData())\n+        && units.stream().anyMatch(Matches.unitIsAir())\n+        && units.stream().anyMatch(Matches.unitIsCarrier());\n+  }\n+\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseValidationUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n+\n+    for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n+      final ProPurchaseOption purchaseOption = it.next();\n+      if (!hasEnoughResourcesAndProduction(\n+              purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)\n+          || hasReachedMaxUnitBuiltPerPlayer(\n+              purchaseOption, player, data, unitsToPlace, purchaseTerritories)\n+          || hasReachedConstructionLimits(\n+              purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n+        it.remove();\n+      }\n+    }\n+  }\n+\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(", "originalCommit": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQ1MQ==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162451", "bodyText": "Method hasReachedConstructionLimits has a Cognitive Complexity of 6 (exceeds 5 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-15T23:33:31Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.findPurchaseOptionsForTerritory(\n+        proData, player, purchaseOptions, t, t, isBid);\n+  }\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final List<ProPurchaseOption> result = new ArrayList<>();\n+    for (final ProPurchaseOption ppo : purchaseOptions) {\n+      if (ProPurchaseValidationUtils.canTerritoryUsePurchaseOption(\n+          proData, player, ppo, t, factoryTerritory, isBid)) {\n+        result.add(ppo);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static boolean canTerritoryUsePurchaseOption(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final ProPurchaseOption ppo,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    if (ppo == null) {\n+      return false;\n+    }\n+    final List<Unit> units = ppo.getUnitType().create(ppo.getQuantity(), player, true);\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(\n+        proData, units, player, t, factoryTerritory, isBid);\n+  }\n+\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(proData, units, player, t, t, isBid);\n+  }\n+\n+  /** Check if units can be placed in given territory by specified factory. */\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final GameData data = player.getData();\n+    AbstractPlaceDelegate placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"place\");\n+    if (isBid) {\n+      placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"placeBid\");\n+    } else if (!t.equals(factoryTerritory)\n+        && !units.stream()\n+            .allMatch(\n+                Matches.unitWhichRequiresUnitsHasRequiredUnitsInList(\n+                    placeDelegate.unitsAtStartOfStepInTerritory(factoryTerritory)))) {\n+      return false;\n+    }\n+    final IDelegateBridge bridge = new ProDummyDelegateBridge(proData.getProAi(), player, data);\n+    placeDelegate.setDelegateBridgeAndPlayer(bridge);\n+    return isPlacingFightersOnNewCarriers(t, units)\n+        ? placeDelegate.canUnitsBePlaced(\n+                t, CollectionUtils.getMatches(units, Matches.unitIsNotAir()), player)\n+            == null\n+        : placeDelegate.canUnitsBePlaced(t, units, player) == null;\n+  }\n+\n+  private static boolean isPlacingFightersOnNewCarriers(final Territory t, final List<Unit> units) {\n+    return t.isWater()\n+        && Properties.getProduceFightersOnCarriers(t.getData())\n+        && units.stream().anyMatch(Matches.unitIsAir())\n+        && units.stream().anyMatch(Matches.unitIsCarrier());\n+  }\n+\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseValidationUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n+\n+    for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n+      final ProPurchaseOption purchaseOption = it.next();\n+      if (!hasEnoughResourcesAndProduction(\n+              purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)\n+          || hasReachedMaxUnitBuiltPerPlayer(\n+              purchaseOption, player, data, unitsToPlace, purchaseTerritories)\n+          || hasReachedConstructionLimits(\n+              purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n+        it.remove();\n+      }\n+    }\n+  }\n+\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(\n+      final ProPurchaseOption purchaseOption,\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+\n+    // Check max unit limits (-1 is unlimited)\n+    final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n+    final UnitType type = purchaseOption.getUnitType();\n+    if (maxBuilt == 0) {\n+      return true;\n+    } else if (maxBuilt > 0) {\n+\n+      // Find number of unit type that are already built and about to be placed\n+      final Predicate<Unit> unitTypeOwnedBy =\n+          Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n+      int currentlyBuilt = CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n+      final List<Territory> allTerritories = data.getMap().getTerritories();\n+      for (final Territory t : allTerritories) {\n+        currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+      }\n+      for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n+        for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n+          currentlyBuilt +=\n+              CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n+        }\n+      }\n+      final int allowedBuild = maxBuilt - currentlyBuilt;\n+      if (allowedBuild - purchaseOption.getQuantity() < 0) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static boolean hasReachedConstructionLimits(", "originalCommit": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQ1Mw==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162453", "bodyText": "Method findNumberOfConstructionTypeToPlace has a Cognitive Complexity of 6 (exceeds 5 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-15T23:33:31Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.findPurchaseOptionsForTerritory(\n+        proData, player, purchaseOptions, t, t, isBid);\n+  }\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final List<ProPurchaseOption> result = new ArrayList<>();\n+    for (final ProPurchaseOption ppo : purchaseOptions) {\n+      if (ProPurchaseValidationUtils.canTerritoryUsePurchaseOption(\n+          proData, player, ppo, t, factoryTerritory, isBid)) {\n+        result.add(ppo);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static boolean canTerritoryUsePurchaseOption(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final ProPurchaseOption ppo,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    if (ppo == null) {\n+      return false;\n+    }\n+    final List<Unit> units = ppo.getUnitType().create(ppo.getQuantity(), player, true);\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(\n+        proData, units, player, t, factoryTerritory, isBid);\n+  }\n+\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(proData, units, player, t, t, isBid);\n+  }\n+\n+  /** Check if units can be placed in given territory by specified factory. */\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final GameData data = player.getData();\n+    AbstractPlaceDelegate placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"place\");\n+    if (isBid) {\n+      placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"placeBid\");\n+    } else if (!t.equals(factoryTerritory)\n+        && !units.stream()\n+            .allMatch(\n+                Matches.unitWhichRequiresUnitsHasRequiredUnitsInList(\n+                    placeDelegate.unitsAtStartOfStepInTerritory(factoryTerritory)))) {\n+      return false;\n+    }\n+    final IDelegateBridge bridge = new ProDummyDelegateBridge(proData.getProAi(), player, data);\n+    placeDelegate.setDelegateBridgeAndPlayer(bridge);\n+    return isPlacingFightersOnNewCarriers(t, units)\n+        ? placeDelegate.canUnitsBePlaced(\n+                t, CollectionUtils.getMatches(units, Matches.unitIsNotAir()), player)\n+            == null\n+        : placeDelegate.canUnitsBePlaced(t, units, player) == null;\n+  }\n+\n+  private static boolean isPlacingFightersOnNewCarriers(final Territory t, final List<Unit> units) {\n+    return t.isWater()\n+        && Properties.getProduceFightersOnCarriers(t.getData())\n+        && units.stream().anyMatch(Matches.unitIsAir())\n+        && units.stream().anyMatch(Matches.unitIsCarrier());\n+  }\n+\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseValidationUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n+\n+    for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n+      final ProPurchaseOption purchaseOption = it.next();\n+      if (!hasEnoughResourcesAndProduction(\n+              purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)\n+          || hasReachedMaxUnitBuiltPerPlayer(\n+              purchaseOption, player, data, unitsToPlace, purchaseTerritories)\n+          || hasReachedConstructionLimits(\n+              purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n+        it.remove();\n+      }\n+    }\n+  }\n+\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(\n+      final ProPurchaseOption purchaseOption,\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+\n+    // Check max unit limits (-1 is unlimited)\n+    final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n+    final UnitType type = purchaseOption.getUnitType();\n+    if (maxBuilt == 0) {\n+      return true;\n+    } else if (maxBuilt > 0) {\n+\n+      // Find number of unit type that are already built and about to be placed\n+      final Predicate<Unit> unitTypeOwnedBy =\n+          Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n+      int currentlyBuilt = CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n+      final List<Territory> allTerritories = data.getMap().getTerritories();\n+      for (final Territory t : allTerritories) {\n+        currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+      }\n+      for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n+        for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n+          currentlyBuilt +=\n+              CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n+        }\n+      }\n+      final int allowedBuild = maxBuilt - currentlyBuilt;\n+      if (allowedBuild - purchaseOption.getQuantity() < 0) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static boolean hasReachedConstructionLimits(\n+      final ProPurchaseOption purchaseOption,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final Territory territory) {\n+\n+    if (purchaseOption.isConstruction() && territory != null) {\n+\n+      final int numConstructionTypeToPlace =\n+          ProPurchaseValidationUtils.findNumberOfConstructionTypeToPlace(\n+              purchaseOption, unitsToPlace, purchaseTerritories, territory);\n+      if (numConstructionTypeToPlace >= purchaseOption.getConstructionTypePerTurn()) {\n+        return true;\n+      }\n+\n+      final int maxConstructionType =\n+          ProPurchaseValidationUtils.findMaxConstructionTypeAllowed(\n+              purchaseOption, data, territory);\n+      final int numExistingConstructionType =\n+          CollectionUtils.countMatches(\n+              territory.getUnits(), Matches.unitIsOfType(purchaseOption.getUnitType()));\n+      if ((numConstructionTypeToPlace + numExistingConstructionType) >= maxConstructionType) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static int findNumberOfConstructionTypeToPlace(", "originalCommit": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzE2MjQ1NA==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r367162454", "bodyText": "Method findMaxConstructionTypeAllowed has a Cognitive Complexity of 8 (exceeds 5 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-15T23:33:31Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */\n+public final class ProPurchaseValidationUtils {\n+  private ProPurchaseValidationUtils() {}\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.findPurchaseOptionsForTerritory(\n+        proData, player, purchaseOptions, t, t, isBid);\n+  }\n+\n+  public static List<ProPurchaseOption> findPurchaseOptionsForTerritory(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final List<ProPurchaseOption> result = new ArrayList<>();\n+    for (final ProPurchaseOption ppo : purchaseOptions) {\n+      if (ProPurchaseValidationUtils.canTerritoryUsePurchaseOption(\n+          proData, player, ppo, t, factoryTerritory, isBid)) {\n+        result.add(ppo);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private static boolean canTerritoryUsePurchaseOption(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final ProPurchaseOption ppo,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    if (ppo == null) {\n+      return false;\n+    }\n+    final List<Unit> units = ppo.getUnitType().create(ppo.getQuantity(), player, true);\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(\n+        proData, units, player, t, factoryTerritory, isBid);\n+  }\n+\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final boolean isBid) {\n+    return ProPurchaseValidationUtils.canUnitsBePlaced(proData, units, player, t, t, isBid);\n+  }\n+\n+  /** Check if units can be placed in given territory by specified factory. */\n+  public static boolean canUnitsBePlaced(\n+      final ProData proData,\n+      final List<Unit> units,\n+      final GamePlayer player,\n+      final Territory t,\n+      final Territory factoryTerritory,\n+      final boolean isBid) {\n+    final GameData data = player.getData();\n+    AbstractPlaceDelegate placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"place\");\n+    if (isBid) {\n+      placeDelegate = (AbstractPlaceDelegate) data.getDelegate(\"placeBid\");\n+    } else if (!t.equals(factoryTerritory)\n+        && !units.stream()\n+            .allMatch(\n+                Matches.unitWhichRequiresUnitsHasRequiredUnitsInList(\n+                    placeDelegate.unitsAtStartOfStepInTerritory(factoryTerritory)))) {\n+      return false;\n+    }\n+    final IDelegateBridge bridge = new ProDummyDelegateBridge(proData.getProAi(), player, data);\n+    placeDelegate.setDelegateBridgeAndPlayer(bridge);\n+    return isPlacingFightersOnNewCarriers(t, units)\n+        ? placeDelegate.canUnitsBePlaced(\n+                t, CollectionUtils.getMatches(units, Matches.unitIsNotAir()), player)\n+            == null\n+        : placeDelegate.canUnitsBePlaced(t, units, player) == null;\n+  }\n+\n+  private static boolean isPlacingFightersOnNewCarriers(final Territory t, final List<Unit> units) {\n+    return t.isWater()\n+        && Properties.getProduceFightersOnCarriers(t.getData())\n+        && units.stream().anyMatch(Matches.unitIsAir())\n+        && units.stream().anyMatch(Matches.unitIsCarrier());\n+  }\n+\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+    ProPurchaseValidationUtils.removeInvalidPurchaseOptions(\n+        player,\n+        data,\n+        purchaseOptions,\n+        resourceTracker,\n+        remainingUnitProduction,\n+        unitsToPlace,\n+        purchaseTerritories,\n+        0,\n+        null);\n+  }\n+\n+  /** Removes any invalid purchase options from {@code purchaseOptions}. */\n+  public static void removeInvalidPurchaseOptions(\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<ProPurchaseOption> purchaseOptions,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final int remainingConstructions,\n+      final Territory territory) {\n+\n+    for (final Iterator<ProPurchaseOption> it = purchaseOptions.iterator(); it.hasNext(); ) {\n+      final ProPurchaseOption purchaseOption = it.next();\n+      if (!hasEnoughResourcesAndProduction(\n+              purchaseOption, resourceTracker, remainingUnitProduction, remainingConstructions)\n+          || hasReachedMaxUnitBuiltPerPlayer(\n+              purchaseOption, player, data, unitsToPlace, purchaseTerritories)\n+          || hasReachedConstructionLimits(\n+              purchaseOption, data, unitsToPlace, purchaseTerritories, territory)) {\n+        it.remove();\n+      }\n+    }\n+  }\n+\n+  private static boolean hasEnoughResourcesAndProduction(\n+      final ProPurchaseOption purchaseOption,\n+      final ProResourceTracker resourceTracker,\n+      final int remainingUnitProduction,\n+      final int remainingConstructions) {\n+    return resourceTracker.hasEnough(purchaseOption)\n+        && purchaseOption.getQuantity()\n+            <= (purchaseOption.isConstruction() ? remainingConstructions : remainingUnitProduction);\n+  }\n+\n+  private static boolean hasReachedMaxUnitBuiltPerPlayer(\n+      final ProPurchaseOption purchaseOption,\n+      final GamePlayer player,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories) {\n+\n+    // Check max unit limits (-1 is unlimited)\n+    final int maxBuilt = purchaseOption.getMaxBuiltPerPlayer();\n+    final UnitType type = purchaseOption.getUnitType();\n+    if (maxBuilt == 0) {\n+      return true;\n+    } else if (maxBuilt > 0) {\n+\n+      // Find number of unit type that are already built and about to be placed\n+      final Predicate<Unit> unitTypeOwnedBy =\n+          Matches.unitIsOfType(type).and(Matches.unitIsOwnedBy(player));\n+      int currentlyBuilt = CollectionUtils.countMatches(unitsToPlace, unitTypeOwnedBy);\n+      final List<Territory> allTerritories = data.getMap().getTerritories();\n+      for (final Territory t : allTerritories) {\n+        currentlyBuilt += t.getUnitCollection().countMatches(unitTypeOwnedBy);\n+      }\n+      for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n+        for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n+          currentlyBuilt +=\n+              CollectionUtils.countMatches(placeTerritory.getPlaceUnits(), unitTypeOwnedBy);\n+        }\n+      }\n+      final int allowedBuild = maxBuilt - currentlyBuilt;\n+      if (allowedBuild - purchaseOption.getQuantity() < 0) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static boolean hasReachedConstructionLimits(\n+      final ProPurchaseOption purchaseOption,\n+      final GameData data,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final Territory territory) {\n+\n+    if (purchaseOption.isConstruction() && territory != null) {\n+\n+      final int numConstructionTypeToPlace =\n+          ProPurchaseValidationUtils.findNumberOfConstructionTypeToPlace(\n+              purchaseOption, unitsToPlace, purchaseTerritories, territory);\n+      if (numConstructionTypeToPlace >= purchaseOption.getConstructionTypePerTurn()) {\n+        return true;\n+      }\n+\n+      final int maxConstructionType =\n+          ProPurchaseValidationUtils.findMaxConstructionTypeAllowed(\n+              purchaseOption, data, territory);\n+      final int numExistingConstructionType =\n+          CollectionUtils.countMatches(\n+              territory.getUnits(), Matches.unitIsOfType(purchaseOption.getUnitType()));\n+      if ((numConstructionTypeToPlace + numExistingConstructionType) >= maxConstructionType) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static int findNumberOfConstructionTypeToPlace(\n+      final ProPurchaseOption purchaseOption,\n+      final List<Unit> unitsToPlace,\n+      final Map<Territory, ProPurchaseTerritory> purchaseTerritories,\n+      final Territory territory) {\n+\n+    int numConstructionTypeToPlace =\n+        CollectionUtils.countMatches(\n+            unitsToPlace, Matches.unitIsOfType(purchaseOption.getUnitType()));\n+    for (final ProPurchaseTerritory t : purchaseTerritories.values()) {\n+      for (final ProPlaceTerritory placeTerritory : t.getCanPlaceTerritories()) {\n+        if (placeTerritory.getTerritory().equals(territory)) {\n+          numConstructionTypeToPlace +=\n+              CollectionUtils.countMatches(\n+                  placeTerritory.getPlaceUnits(),\n+                  Matches.unitIsOfType(purchaseOption.getUnitType()));\n+        }\n+      }\n+    }\n+    return numConstructionTypeToPlace;\n+  }\n+\n+  private static int findMaxConstructionTypeAllowed(", "originalCommit": "f380db7d598f5a8573b2144f9bfa74a19c42b5b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "85c00551f738f3040b8cb02d704670f6f53e7d27", "url": "https://github.com/triplea-game/triplea/commit/85c00551f738f3040b8cb02d704670f6f53e7d27", "message": "Auto-Formatting", "committedDate": "2020-01-15T23:34:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI1NDc3MQ==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368254771", "bodyText": "Is this comment now misplaced? It's hard to see how it relates to the next couple lines, seems like it relates to lines below it.\nThe comment block also seems to be blocking off a logical step, would be a good candidate for an extract method refactor.", "author": "DanVanAtta", "createdAt": "2020-01-18T23:37:46Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/ProPurchaseAi.java", "diffHunk": "@@ -2551,6 +2571,10 @@ private void addUnitsToPlaceTerritory(\n                 isBid)) {\n \n           // Place max number of units", "originalCommit": "85c00551f738f3040b8cb02d704670f6f53e7d27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI2OTc1NA==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368269754", "bodyText": "Yeah, removed this comment.", "author": "ron-murhammer", "createdAt": "2020-01-19T06:39:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI1NDc3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI1NDgwOQ==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368254809", "bodyText": "Why are constructions being removed from unitsToPlace and added to ppt.\nSecond, would ppt provide better encapsulation if it provided a method to add constructions rather than exposing a mutable datastructure?\nEG:\n ppt.getPlaceUnits().addAll(constructions);\n\nto:\n ppt.addConstructions(constructions); // this method could assert that all units match 'unitIsconstruction'", "author": "DanVanAtta", "createdAt": "2020-01-18T23:38:50Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/ProPurchaseAi.java", "diffHunk": "@@ -2551,6 +2571,10 @@ private void addUnitsToPlaceTerritory(\n                 isBid)) {\n \n           // Place max number of units\n+          final List<Unit> constructions =\n+              CollectionUtils.getMatches(unitsToPlace, Matches.unitIsConstruction());\n+          unitsToPlace.removeAll(constructions);", "originalCommit": "85c00551f738f3040b8cb02d704670f6f53e7d27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3MDAyNA==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368270024", "bodyText": "Essentially the method removes units from unitsToPlace and adds them into the ProPurchaseTerritory structure. The reason for this is that the AI decides how many units to build in a territory but then needs to map them to which factory is actually placing the (mostly only matters for sea territories).\nEventually, I do agree that trying to push this and a few other methods into ProPurchaseTerritory would be best just didn't want to tackle that in this PR. If you look at ProPurchaseTerritory its mostly just a data structure currently and was created to begin grouping some of the data fields together to avoid passing around lots of lists but hasn't really gotten much functionality added into it yet.", "author": "ron-murhammer", "createdAt": "2020-01-19T06:45:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI1NDgwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI1NDkwMA==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368254900", "bodyText": "These 4 data members seem very related. Have you considered creating a type around it?", "author": "DanVanAtta", "createdAt": "2020-01-18T23:41:03Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/data/ProPurchaseOption.java", "diffHunk": "@@ -71,6 +72,10 @@\n     final Resource pus = data.getResourceList().getResource(Constants.PUS);\n     cost = productionRule.getCosts().getInt(pus);\n     costs = productionRule.getCosts();\n+    isConstruction = unitAttachment.getIsConstruction();", "originalCommit": "85c00551f738f3040b8cb02d704670f6f53e7d27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3MDE5OA==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368270198", "bodyText": "Not really. I'd have to think more about this class in general to see if/how it would be best to start breaking it up a bit. Compared to most AI classes though this is probably one of the better ones.", "author": "ron-murhammer", "createdAt": "2020-01-19T06:49:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI1NDkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI1NDkwNA==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368254904", "bodyText": "What's the rationale for 0.1?", "author": "DanVanAtta", "createdAt": "2020-01-18T23:41:17Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/data/ProPurchaseOption.java", "diffHunk": "@@ -252,6 +257,9 @@ public double getAmphibEfficiency(\n   }\n \n   private double calculateLandDistanceFactor(final int enemyDistance) {\n+    if (movement <= 0) {\n+      return 0.1;", "originalCommit": "85c00551f738f3040b8cb02d704670f6f53e7d27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3MDIzOQ==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368270239", "bodyText": "Want it to be essentially an order of magnitude worse than 1 move units. Don't want to return 0 as this is used to multiply with other values to get a kind of purchase value score for units.", "author": "ron-murhammer", "createdAt": "2020-01-19T06:50:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI1NDkwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3MzY0Ng==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368273646", "bodyText": "Would you mind adding a comment in code? That is actually a bit more involved than I had expected.", "author": "DanVanAtta", "createdAt": "2020-01-19T07:58:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI1NDkwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMwNjU2NA==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368306564", "bodyText": "Added.", "author": "ron-murhammer", "createdAt": "2020-01-19T16:37:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI1NDkwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI1NTAwMQ==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368255001", "bodyText": "It's a bit difficult to follow this line. An intermediate variable maybe would help, or adding a Matches for 'notConstruction' to avoid the negate. Have you considered unit testing this method to help document and verify it?", "author": "DanVanAtta", "createdAt": "2020-01-18T23:44:28Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/data/ProPurchaseTerritory.java", "diffHunk": "@@ -64,7 +65,8 @@ public ProPurchaseTerritory(\n   public int getRemainingUnitProduction() {\n     int remainingUnitProduction = unitProduction;\n     for (final ProPlaceTerritory ppt : canPlaceTerritories) {\n-      remainingUnitProduction -= ppt.getPlaceUnits().size();\n+      remainingUnitProduction -=\n+          CollectionUtils.countMatches(ppt.getPlaceUnits(), Matches.unitIsConstruction().negate());", "originalCommit": "85c00551f738f3040b8cb02d704670f6f53e7d27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3MDM2OQ==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368270369", "bodyText": "Updated.", "author": "ron-murhammer", "createdAt": "2020-01-19T06:52:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI1NTAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI1NTA1Mg==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368255052", "bodyText": "Is this comment here because it has to be? I wonder as ValidationUtils seems to be more specific than the comment implies. Second, have you considered using @UtilityClass to avoid the private constructor?", "author": "DanVanAtta", "createdAt": "2020-01-18T23:46:26Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,279 @@\n+package games.strategy.triplea.ai.pro.util;\n+\n+import games.strategy.engine.data.GameData;\n+import games.strategy.engine.data.GamePlayer;\n+import games.strategy.engine.data.Territory;\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.Constants;\n+import games.strategy.triplea.Properties;\n+import games.strategy.triplea.ai.pro.ProData;\n+import games.strategy.triplea.ai.pro.data.ProPlaceTerritory;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseOption;\n+import games.strategy.triplea.ai.pro.data.ProPurchaseTerritory;\n+import games.strategy.triplea.ai.pro.data.ProResourceTracker;\n+import games.strategy.triplea.ai.pro.simulate.ProDummyDelegateBridge;\n+import games.strategy.triplea.attachments.TerritoryAttachment;\n+import games.strategy.triplea.delegate.AbstractPlaceDelegate;\n+import games.strategy.triplea.delegate.Matches;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Pro AI purchase utilities. */", "originalCommit": "85c00551f738f3040b8cb02d704670f6f53e7d27", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3MDUxOQ==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368270519", "bodyText": "Updated comment. Added that annotation to this class and ProPurchaseUtils.", "author": "ron-murhammer", "createdAt": "2020-01-19T06:55:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI1NTA1Mg=="}], "type": "inlineReview"}, {"oid": "7f9eb955db7a1408e41159d845ac1378087ae938", "url": "https://github.com/triplea-game/triplea/commit/7f9eb955db7a1408e41159d845ac1378087ae938", "message": "Various minor refactoring improvements", "committedDate": "2020-01-19T06:56:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODI3MDYyMA==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368270620", "bodyText": "File ProPurchaseValidationUtils.java has 252 lines of code (exceeds 250 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-19T06:58:03Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,283 @@\n+package games.strategy.triplea.ai.pro.util;", "originalCommit": "7f9eb955db7a1408e41159d845ac1378087ae938", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c444ffe8568c6fd5217ae7ae02709a83d5a0dd8c", "url": "https://github.com/triplea-game/triplea/commit/c444ffe8568c6fd5217ae7ae02709a83d5a0dd8c", "message": "Add comment", "committedDate": "2020-01-19T16:37:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODMwNjY0Nw==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368306647", "bodyText": "File ProPurchaseValidationUtils.java has 252 lines of code (exceeds 250 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-19T16:39:21Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,283 @@\n+package games.strategy.triplea.ai.pro.util;", "originalCommit": "c444ffe8568c6fd5217ae7ae02709a83d5a0dd8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "98031c78fbafe47a991d401ca0b933dce513d444", "url": "https://github.com/triplea-game/triplea/commit/98031c78fbafe47a991d401ca0b933dce513d444", "message": "Add new constant", "committedDate": "2020-01-20T01:28:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2ODM0MjM1Ng==", "url": "https://github.com/triplea-game/triplea/pull/5842#discussion_r368342356", "bodyText": "File ProPurchaseValidationUtils.java has 252 lines of code (exceeds 250 allowed). Consider refactoring.", "author": "codeclimate", "createdAt": "2020-01-20T01:29:48Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProPurchaseValidationUtils.java", "diffHunk": "@@ -0,0 +1,283 @@\n+package games.strategy.triplea.ai.pro.util;", "originalCommit": "98031c78fbafe47a991d401ca0b933dce513d444", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}