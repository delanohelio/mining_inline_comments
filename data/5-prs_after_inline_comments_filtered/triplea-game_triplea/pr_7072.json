{"pr_number": 7072, "pr_title": "Clean up messy AI unit sorting code.", "pr_createdAt": "2020-07-08T03:45:31Z", "pr_url": "https://github.com/triplea-game/triplea/pull/7072", "timeline": [{"oid": "b2dc5d752d257d6dc8c40c035c7c19b54b9aaaa7", "url": "https://github.com/triplea-game/triplea/commit/b2dc5d752d257d6dc8c40c035c7c19b54b9aaaa7", "message": "Clean up messy AI unit sorting code.\n\nThis PR refactors the code to simplify the logic and remove\nduplication related to AI unit comparison.\n\nNo logic changes.", "committedDate": "2020-07-08T03:43:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MDYzNg==", "url": "https://github.com/triplea-game/triplea/pull/7072#discussion_r451270636", "bodyText": "This line is failing the custom code-convention check:\nAvoid using size() to check for empty or not empty\n\nEx: size() == 0 -> isEmpty(), size() > 0 -> !isEmpty()\n\n./game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProSortMoveOptionsUtils.java:127:          if (territories1.size() == 0) {\n\n[FIX]", "author": "DanVanAtta", "createdAt": "2020-07-08T04:07:24Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProSortMoveOptionsUtils.java", "diffHunk": "@@ -125,195 +115,126 @@ private ProSortMoveOptionsUtils() {}\n         new ArrayList<>(unitAttackOptions.entrySet());\n     list.sort(\n         (o1, o2) -> {\n+          final Collection<Territory> territories1 =\n+              filterOutWinningTerritories(o1.getValue(), player, attackMap, calc);\n+          final Collection<Territory> territories2 =\n+              filterOutWinningTerritories(o2.getValue(), player, attackMap, calc);\n \n           // Sort by number of territories that still need units\n-          int numOptions1 = 0;\n-          for (final Territory t : o1.getValue()) {\n-            final ProTerritory patd = attackMap.get(t);\n-            if (patd.getBattleResult() == null) {\n-              patd.estimateBattleResult(calc, player);\n-            }\n-            if (!patd.isCurrentlyWins()) {\n-              numOptions1++;\n-            }\n-          }\n-          int numOptions2 = 0;\n-          for (final Territory t : o2.getValue()) {\n-            final ProTerritory patd = attackMap.get(t);\n-            if (patd.getBattleResult() == null) {\n-              patd.estimateBattleResult(calc, player);\n-            }\n-            if (!patd.isCurrentlyWins()) {\n-              numOptions2++;\n-            }\n+          if (territories1.size() != territories2.size()) {\n+            return territories1.size() - territories2.size();\n           }\n-          if (numOptions1 != numOptions2) {\n-            return (numOptions1 - numOptions2);\n-          }\n-          if (numOptions1 == 0) {\n+          if (territories1.size() == 0) {", "originalCommit": "b2dc5d752d257d6dc8c40c035c7c19b54b9aaaa7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwNjcwNA==", "url": "https://github.com/triplea-game/triplea/pull/7072#discussion_r451906704", "bodyText": "Done", "author": "asvitkine", "createdAt": "2020-07-09T01:07:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MDYzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MTE4NQ==", "url": "https://github.com/triplea-game/triplea/pull/7072#discussion_r451271185", "bodyText": "Any thoughts if filterNonWinningTerritories is a better name for this method?", "author": "DanVanAtta", "createdAt": "2020-07-08T04:09:56Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProSortMoveOptionsUtils.java", "diffHunk": "@@ -125,195 +115,126 @@ private ProSortMoveOptionsUtils() {}\n         new ArrayList<>(unitAttackOptions.entrySet());\n     list.sort(\n         (o1, o2) -> {\n+          final Collection<Territory> territories1 =\n+              filterOutWinningTerritories(o1.getValue(), player, attackMap, calc);\n+          final Collection<Territory> territories2 =\n+              filterOutWinningTerritories(o2.getValue(), player, attackMap, calc);\n \n           // Sort by number of territories that still need units\n-          int numOptions1 = 0;\n-          for (final Territory t : o1.getValue()) {\n-            final ProTerritory patd = attackMap.get(t);\n-            if (patd.getBattleResult() == null) {\n-              patd.estimateBattleResult(calc, player);\n-            }\n-            if (!patd.isCurrentlyWins()) {\n-              numOptions1++;\n-            }\n-          }\n-          int numOptions2 = 0;\n-          for (final Territory t : o2.getValue()) {\n-            final ProTerritory patd = attackMap.get(t);\n-            if (patd.getBattleResult() == null) {\n-              patd.estimateBattleResult(calc, player);\n-            }\n-            if (!patd.isCurrentlyWins()) {\n-              numOptions2++;\n-            }\n+          if (territories1.size() != territories2.size()) {\n+            return territories1.size() - territories2.size();\n           }\n-          if (numOptions1 != numOptions2) {\n-            return (numOptions1 - numOptions2);\n-          }\n-          if (numOptions1 == 0) {\n+          if (territories1.size() == 0) {\n             return 0;\n           }\n \n+          final Unit unit1 = o1.getKey();\n+          final Unit unit2 = o2.getKey();\n+\n           // Sort by attack efficiency\n-          int minPower1 = Integer.MAX_VALUE;\n-          for (final Territory t : o1.getValue()) {\n-            if (!attackMap.get(t).isCurrentlyWins()) {\n-              final List<Unit> defendingUnits =\n-                  t.getUnitCollection().getMatches(Matches.enemyUnit(player, data));\n-              final List<Unit> sortedUnitsList = new ArrayList<>(attackMap.get(t).getUnits());\n-              sortedUnitsList.sort(\n-                  new UnitBattleComparator(\n-                          false,\n-                          proData.getUnitValueMap(),\n-                          TerritoryEffectHelper.getEffects(t),\n-                          data)\n-                      .reversed());\n-              final int powerWithout =\n-                  DiceRoll.getTotalPower(\n-                      DiceRoll.getUnitPowerAndRollsForNormalBattles(\n-                          sortedUnitsList,\n-                          defendingUnits,\n-                          sortedUnitsList,\n-                          false,\n-                          data,\n-                          t,\n-                          TerritoryEffectHelper.getEffects(t),\n-                          false,\n-                          null),\n-                      data);\n-              sortedUnitsList.add(o1.getKey());\n-              sortedUnitsList.sort(\n-                  new UnitBattleComparator(\n-                          false,\n-                          proData.getUnitValueMap(),\n-                          TerritoryEffectHelper.getEffects(t),\n-                          data)\n-                      .reversed());\n-              final int powerWith =\n-                  DiceRoll.getTotalPower(\n-                      DiceRoll.getUnitPowerAndRollsForNormalBattles(\n-                          sortedUnitsList,\n-                          defendingUnits,\n-                          sortedUnitsList,\n-                          false,\n-                          data,\n-                          t,\n-                          TerritoryEffectHelper.getEffects(t),\n-                          false,\n-                          null),\n-                      data);\n-              final int power = powerWith - powerWithout;\n-              if (power < minPower1) {\n-                minPower1 = power;\n-              }\n-            }\n-          }\n-          final UnitAttachment ua1 = UnitAttachment.get(o1.getKey().getType());\n-          if (ua1.getIsAir()) {\n-            minPower1 *= 10;\n-          }\n           final double attackEfficiency1 =\n-              (double) minPower1 / proData.getUnitValue(o1.getKey().getType());\n-          int minPower2 = Integer.MAX_VALUE;\n-          for (final Territory t : o2.getValue()) {\n-            if (!attackMap.get(t).isCurrentlyWins()) {\n-              final List<Unit> defendingUnits =\n-                  t.getUnitCollection().getMatches(Matches.enemyUnit(player, data));\n-              final List<Unit> sortedUnitsList = new ArrayList<>(attackMap.get(t).getUnits());\n-              sortedUnitsList.sort(\n-                  new UnitBattleComparator(\n-                          false,\n-                          proData.getUnitValueMap(),\n-                          TerritoryEffectHelper.getEffects(t),\n-                          data)\n-                      .reversed());\n-              final int powerWithout =\n-                  DiceRoll.getTotalPower(\n-                      DiceRoll.getUnitPowerAndRollsForNormalBattles(\n-                          sortedUnitsList,\n-                          defendingUnits,\n-                          sortedUnitsList,\n-                          false,\n-                          data,\n-                          t,\n-                          TerritoryEffectHelper.getEffects(t),\n-                          false,\n-                          null),\n-                      data);\n-              sortedUnitsList.add(o2.getKey());\n-              sortedUnitsList.sort(\n-                  new UnitBattleComparator(\n-                          false,\n-                          proData.getUnitValueMap(),\n-                          TerritoryEffectHelper.getEffects(t),\n-                          data)\n-                      .reversed());\n-              final int powerWith =\n-                  DiceRoll.getTotalPower(\n-                      DiceRoll.getUnitPowerAndRollsForNormalBattles(\n-                          sortedUnitsList,\n-                          defendingUnits,\n-                          sortedUnitsList,\n-                          false,\n-                          data,\n-                          t,\n-                          TerritoryEffectHelper.getEffects(t),\n-                          false,\n-                          null),\n-                      data);\n-              final int power = powerWith - powerWithout;\n-              if (power < minPower2) {\n-                minPower2 = power;\n-              }\n-            }\n-          }\n-          final UnitAttachment ua2 = UnitAttachment.get(o2.getKey().getType());\n-          if (ua2.getIsAir()) {\n-            minPower2 *= 10;\n-          }\n+              calculateAttackEfficiency(proData, player, attackMap, territories1, unit1);\n           final double attackEfficiency2 =\n-              (double) minPower2 / proData.getUnitValue(o2.getKey().getType());\n+              calculateAttackEfficiency(proData, player, attackMap, territories2, unit2);\n           if (attackEfficiency1 != attackEfficiency2) {\n             return (attackEfficiency1 < attackEfficiency2) ? 1 : -1;\n           }\n \n-          // Check if unit types are equal and is air then sort by average distance\n-          if (o1.getKey().getType().equals(o2.getKey().getType())) {\n-            final boolean isAirUnit = UnitAttachment.get(o1.getKey().getType()).getIsAir();\n-            if (isAirUnit) {\n-              int distance1 = 0;\n-              for (final Territory t : o1.getValue()) {\n-                if (!attackMap.get(t).isCurrentlyWins()) {\n-                  distance1 +=\n-                      data.getMap()\n-                          .getDistanceIgnoreEndForCondition(\n-                              unitTerritoryMap.get(o1.getKey()),\n-                              t,\n-                              ProMatches.territoryCanMoveAirUnitsAndNoAa(player, data, true));\n-                }\n-              }\n-              int distance2 = 0;\n-              for (final Territory t : o2.getValue()) {\n-                if (!attackMap.get(t).isCurrentlyWins()) {\n-                  distance2 +=\n-                      data.getMap()\n-                          .getDistanceIgnoreEndForCondition(\n-                              unitTerritoryMap.get(o2.getKey()),\n-                              t,\n-                              ProMatches.territoryCanMoveAirUnitsAndNoAa(player, data, true));\n-                }\n-              }\n-              if (distance1 != distance2) {\n-                return distance1 - distance2;\n-              }\n+          final UnitType unitType1 = unit1.getType();\n+          final UnitType unitType2 = unit2.getType();\n+\n+          // If unit types are equal and are air, then sort by average distance.\n+          if (unitType1.equals(unitType2) && UnitAttachment.get(unitType1).getIsAir()) {\n+            final Predicate<Territory> predicate =\n+                ProMatches.territoryCanMoveAirUnitsAndNoAa(player, data, true);\n+            final Territory territory1 = unitTerritoryMap.get(unit1);\n+            final Territory territory2 = unitTerritoryMap.get(unit2);\n+            int distance1 = 0;\n+            for (final Territory t : territories1) {\n+              distance1 += data.getMap().getDistanceIgnoreEndForCondition(territory1, t, predicate);\n+            }\n+            int distance2 = 0;\n+            for (final Territory t : territories2) {\n+              distance2 += data.getMap().getDistanceIgnoreEndForCondition(territory2, t, predicate);\n+            }\n+            if (distance1 != distance2) {\n+              return distance1 - distance2;\n             }\n           }\n-          return o1.getKey().getType().getName().compareTo(o2.getKey().getType().getName());\n+\n+          return unitType1.getName().compareTo(unitType2.getName());\n         });\n     final Map<Unit, Set<Territory>> sortedUnitAttackOptions = new LinkedHashMap<>();\n     for (final Map.Entry<Unit, Set<Territory>> entry : list) {\n       sortedUnitAttackOptions.put(entry.getKey(), entry.getValue());\n     }\n     return sortedUnitAttackOptions;\n   }\n+\n+  private static Collection<Territory> filterOutWinningTerritories(", "originalCommit": "b2dc5d752d257d6dc8c40c035c7c19b54b9aaaa7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwNzg1NQ==", "url": "https://github.com/triplea-game/triplea/pull/7072#discussion_r451907855", "bodyText": "I actually prefer my version. Your version sounds a bit ambiguous to me (i.e. my first read of it is to mean that the input is non-winning territories and they're being filtered by some other unknown criteria, as opposed to the input being all territories and non-winning are kept). I think \"filter out\" wording in the current name doesn't have this ambiguity, so keeping it.", "author": "asvitkine", "createdAt": "2020-07-09T01:11:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MTE4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU3NDYwOA==", "url": "https://github.com/triplea-game/triplea/pull/7072#discussion_r452574608", "bodyText": "How about removeWinningTerritories?\nFilterOut could mean to \"filter out\" the winning territories from the rest and return those.\nOr it could mean \"filter out\" as-in remove them.\nIt could be slightly confusing as to which one is meant.", "author": "DanVanAtta", "createdAt": "2020-07-10T01:27:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MTE4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjU4NDQxOA==", "url": "https://github.com/triplea-game/triplea/pull/7072#discussion_r452584418", "bodyText": "removeWinningTerritories works for me. Done!", "author": "asvitkine", "createdAt": "2020-07-10T02:09:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MTE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MTc5Nw==", "url": "https://github.com/triplea-game/triplea/pull/7072#discussion_r451271797", "bodyText": "Wow, this is quite the method \ud83d\udc4d\nLooks to be a very good use of priority queue, I like particularly how the data structure can just \"take care of itself\" and does the right thing.", "author": "DanVanAtta", "createdAt": "2020-07-08T04:12:20Z", "path": "java-extras/src/main/java/org/triplea/java/collections/CollectionUtils.java", "diffHunk": "@@ -113,4 +115,15 @@\n     return Iterables.elementsEqual(c1, c2)\n         || (c1.size() == c2.size() && c2.containsAll(c1) && c1.containsAll(c2));\n   }\n+\n+  /**\n+   * Creates a sorted, mutable collection containing the specified elements that will maintain its", "originalCommit": "b2dc5d752d257d6dc8c40c035c7c19b54b9aaaa7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQyNTExOQ==", "url": "https://github.com/triplea-game/triplea/pull/7072#discussion_r451425119", "bodyText": "I want to point out that calling a PriorityQueue \"sorted\" is misleading.\nWhen using it like this:\nfinal var queue = new PriorityQueue<>(elements.size(), comparator);\nsortedCollection.addAll(elements);\nwhile (!sortedCollection.isEmpty()) {\n  final var element = sortedCollection.remove();\n// Elements are returned in correct order\n}\nit works as expected, but the JavaDocs explicitly state that:\n\nThe Iterator provided in method iterator() and the Spliterator provided in method spliterator() are not guaranteed to traverse the elements of the priority queue in any particular order.\n\nWith that being said, a TreeSet might be the better data structure here, but only if the keys are unique so far (it doesn't permit multiple elements that the comparator considers \"equal\", even if equals returns false)", "author": "RoiEXLab", "createdAt": "2020-07-08T09:56:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MTc5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQzNzExOQ==", "url": "https://github.com/triplea-game/triplea/pull/7072#discussion_r451437119", "bodyText": "Apparently there's a TreeMultiset in guava, that should work too if the default TreeSet fails", "author": "RoiEXLab", "createdAt": "2020-07-08T10:18:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MTc5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwNjkyNw==", "url": "https://github.com/triplea-game/triplea/pull/7072#discussion_r451906927", "bodyText": "Thanks! Indeed I missed that PriorityQueue iteration order doesn't do what we want. Switched to TreeMultiset and added some unit tests. :)", "author": "asvitkine", "createdAt": "2020-07-09T01:08:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MTc5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgzMDc5MQ==", "url": "https://github.com/triplea-game/triplea/pull/7072#discussion_r452830791", "bodyText": "Yeah, I ran into this problem as well when I tried messing around with it for Tile rendering code, that's why I immediately noticed ^^", "author": "RoiEXLab", "createdAt": "2020-07-10T13:06:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI3MTc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQyNjg5Mw==", "url": "https://github.com/triplea-game/triplea/pull/7072#discussion_r451426893", "bodyText": "Haven't checked if this works nicely in every case, but have you considered using the Comparator builder methods like\nComparator#comparing?\nWe have several examples in the code where Comparator#thenComparing is used to chain several conditions together.\nDepending on the complexity it will either make the code half the size because you only have to provide the key function once instead of twice, or make it close to unreadable because the pattern doesn't match the needs", "author": "RoiEXLab", "createdAt": "2020-07-08T09:59:45Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProSortMoveOptionsUtils.java", "diffHunk": "@@ -65,39 +71,23 @@ private ProSortMoveOptionsUtils() {}\n         new ArrayList<>(unitAttackOptions.entrySet());\n     list.sort(\n         (o1, o2) -> {\n+          final Collection<Territory> territories1 =\n+              filterOutWinningTerritories(o1.getValue(), player, attackMap, calc);\n+          final Collection<Territory> territories2 =\n+              filterOutWinningTerritories(o2.getValue(), player, attackMap, calc);", "originalCommit": "b2dc5d752d257d6dc8c40c035c7c19b54b9aaaa7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTkwNzM1Mg==", "url": "https://github.com/triplea-game/triplea/pull/7072#discussion_r451907352", "bodyText": "Yeah that might be even nicer. Can look at that as a follow up PR potentially.", "author": "asvitkine", "createdAt": "2020-07-09T01:09:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQyNjg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgzNTg5Ng==", "url": "https://github.com/triplea-game/triplea/pull/7072#discussion_r452835896", "bodyText": "\ud83d\udc4d", "author": "RoiEXLab", "createdAt": "2020-07-10T13:16:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTQyNjg5Mw=="}], "type": "inlineReview"}, {"oid": "ee0709e66596719901a96f49b7bee92df45929b5", "url": "https://github.com/triplea-game/triplea/commit/ee0709e66596719901a96f49b7bee92df45929b5", "message": "Address feedback:\n  -> isEmpty()\n  -> Use TreeMultiset\n  -> Add unit tests", "committedDate": "2020-07-09T01:05:15Z", "type": "commit"}, {"oid": "8195b272afc414bc6ad9a3c708d907580863c0e3", "url": "https://github.com/triplea-game/triplea/commit/8195b272afc414bc6ad9a3c708d907580863c0e3", "message": "fix test", "committedDate": "2020-07-09T01:23:20Z", "type": "commit"}, {"oid": "c2e955d34f0293600edc9c8219e9fc92f554e41d", "url": "https://github.com/triplea-game/triplea/commit/c2e955d34f0293600edc9c8219e9fc92f554e41d", "message": "Rename function", "committedDate": "2020-07-10T02:08:59Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MjgzNTI5Mw==", "url": "https://github.com/triplea-game/triplea/pull/7072#discussion_r452835293", "bodyText": "Unrelated to this PR, just a general thought.\nI think writing this weird loop differently would make it more readable:\nfinal int powerWithout = DiceRoll.getTotalPower(\n              DiceRoll.getUnitPowerAndRollsForNormalBattles(\n                  sortedUnits,\n                  defendingUnits,\n                   sortedUnits,\n                   false,\n                   data,\n                   t,\n                   effects,\n                   false,\n                   null),\n                 data);\nsortedUnits.add(unit);\nfinal int powerWith = DiceRoll.getTotalPower(\n              DiceRoll.getUnitPowerAndRollsForNormalBattles(\n                  sortedUnits,\n                  defendingUnits,\n                   sortedUnits,\n                   false,\n                   data,\n                   t,\n                   effects,\n                   false,\n                   null),\n                 data);\n\nminPower = Math.min(powerWith - powerWithout, minPower);", "author": "RoiEXLab", "createdAt": "2020-07-10T13:15:00Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/ProSortMoveOptionsUtils.java", "diffHunk": "@@ -125,195 +115,126 @@ private ProSortMoveOptionsUtils() {}\n         new ArrayList<>(unitAttackOptions.entrySet());\n     list.sort(\n         (o1, o2) -> {\n+          final Collection<Territory> territories1 =\n+              removeWinningTerritories(o1.getValue(), player, attackMap, calc);\n+          final Collection<Territory> territories2 =\n+              removeWinningTerritories(o2.getValue(), player, attackMap, calc);\n \n           // Sort by number of territories that still need units\n-          int numOptions1 = 0;\n-          for (final Territory t : o1.getValue()) {\n-            final ProTerritory patd = attackMap.get(t);\n-            if (patd.getBattleResult() == null) {\n-              patd.estimateBattleResult(calc, player);\n-            }\n-            if (!patd.isCurrentlyWins()) {\n-              numOptions1++;\n-            }\n-          }\n-          int numOptions2 = 0;\n-          for (final Territory t : o2.getValue()) {\n-            final ProTerritory patd = attackMap.get(t);\n-            if (patd.getBattleResult() == null) {\n-              patd.estimateBattleResult(calc, player);\n-            }\n-            if (!patd.isCurrentlyWins()) {\n-              numOptions2++;\n-            }\n+          if (territories1.size() != territories2.size()) {\n+            return territories1.size() - territories2.size();\n           }\n-          if (numOptions1 != numOptions2) {\n-            return (numOptions1 - numOptions2);\n-          }\n-          if (numOptions1 == 0) {\n+          if (territories1.isEmpty()) {\n             return 0;\n           }\n \n+          final Unit unit1 = o1.getKey();\n+          final Unit unit2 = o2.getKey();\n+\n           // Sort by attack efficiency\n-          int minPower1 = Integer.MAX_VALUE;\n-          for (final Territory t : o1.getValue()) {\n-            if (!attackMap.get(t).isCurrentlyWins()) {\n-              final List<Unit> defendingUnits =\n-                  t.getUnitCollection().getMatches(Matches.enemyUnit(player, data));\n-              final List<Unit> sortedUnitsList = new ArrayList<>(attackMap.get(t).getUnits());\n-              sortedUnitsList.sort(\n-                  new UnitBattleComparator(\n-                          false,\n-                          proData.getUnitValueMap(),\n-                          TerritoryEffectHelper.getEffects(t),\n-                          data)\n-                      .reversed());\n-              final int powerWithout =\n-                  DiceRoll.getTotalPower(\n-                      DiceRoll.getUnitPowerAndRollsForNormalBattles(\n-                          sortedUnitsList,\n-                          defendingUnits,\n-                          sortedUnitsList,\n-                          false,\n-                          data,\n-                          t,\n-                          TerritoryEffectHelper.getEffects(t),\n-                          false,\n-                          null),\n-                      data);\n-              sortedUnitsList.add(o1.getKey());\n-              sortedUnitsList.sort(\n-                  new UnitBattleComparator(\n-                          false,\n-                          proData.getUnitValueMap(),\n-                          TerritoryEffectHelper.getEffects(t),\n-                          data)\n-                      .reversed());\n-              final int powerWith =\n-                  DiceRoll.getTotalPower(\n-                      DiceRoll.getUnitPowerAndRollsForNormalBattles(\n-                          sortedUnitsList,\n-                          defendingUnits,\n-                          sortedUnitsList,\n-                          false,\n-                          data,\n-                          t,\n-                          TerritoryEffectHelper.getEffects(t),\n-                          false,\n-                          null),\n-                      data);\n-              final int power = powerWith - powerWithout;\n-              if (power < minPower1) {\n-                minPower1 = power;\n-              }\n-            }\n-          }\n-          final UnitAttachment ua1 = UnitAttachment.get(o1.getKey().getType());\n-          if (ua1.getIsAir()) {\n-            minPower1 *= 10;\n-          }\n           final double attackEfficiency1 =\n-              (double) minPower1 / proData.getUnitValue(o1.getKey().getType());\n-          int minPower2 = Integer.MAX_VALUE;\n-          for (final Territory t : o2.getValue()) {\n-            if (!attackMap.get(t).isCurrentlyWins()) {\n-              final List<Unit> defendingUnits =\n-                  t.getUnitCollection().getMatches(Matches.enemyUnit(player, data));\n-              final List<Unit> sortedUnitsList = new ArrayList<>(attackMap.get(t).getUnits());\n-              sortedUnitsList.sort(\n-                  new UnitBattleComparator(\n-                          false,\n-                          proData.getUnitValueMap(),\n-                          TerritoryEffectHelper.getEffects(t),\n-                          data)\n-                      .reversed());\n-              final int powerWithout =\n-                  DiceRoll.getTotalPower(\n-                      DiceRoll.getUnitPowerAndRollsForNormalBattles(\n-                          sortedUnitsList,\n-                          defendingUnits,\n-                          sortedUnitsList,\n-                          false,\n-                          data,\n-                          t,\n-                          TerritoryEffectHelper.getEffects(t),\n-                          false,\n-                          null),\n-                      data);\n-              sortedUnitsList.add(o2.getKey());\n-              sortedUnitsList.sort(\n-                  new UnitBattleComparator(\n-                          false,\n-                          proData.getUnitValueMap(),\n-                          TerritoryEffectHelper.getEffects(t),\n-                          data)\n-                      .reversed());\n-              final int powerWith =\n-                  DiceRoll.getTotalPower(\n-                      DiceRoll.getUnitPowerAndRollsForNormalBattles(\n-                          sortedUnitsList,\n-                          defendingUnits,\n-                          sortedUnitsList,\n-                          false,\n-                          data,\n-                          t,\n-                          TerritoryEffectHelper.getEffects(t),\n-                          false,\n-                          null),\n-                      data);\n-              final int power = powerWith - powerWithout;\n-              if (power < minPower2) {\n-                minPower2 = power;\n-              }\n-            }\n-          }\n-          final UnitAttachment ua2 = UnitAttachment.get(o2.getKey().getType());\n-          if (ua2.getIsAir()) {\n-            minPower2 *= 10;\n-          }\n+              calculateAttackEfficiency(proData, player, attackMap, territories1, unit1);\n           final double attackEfficiency2 =\n-              (double) minPower2 / proData.getUnitValue(o2.getKey().getType());\n+              calculateAttackEfficiency(proData, player, attackMap, territories2, unit2);\n           if (attackEfficiency1 != attackEfficiency2) {\n             return (attackEfficiency1 < attackEfficiency2) ? 1 : -1;\n           }\n \n-          // Check if unit types are equal and is air then sort by average distance\n-          if (o1.getKey().getType().equals(o2.getKey().getType())) {\n-            final boolean isAirUnit = UnitAttachment.get(o1.getKey().getType()).getIsAir();\n-            if (isAirUnit) {\n-              int distance1 = 0;\n-              for (final Territory t : o1.getValue()) {\n-                if (!attackMap.get(t).isCurrentlyWins()) {\n-                  distance1 +=\n-                      data.getMap()\n-                          .getDistanceIgnoreEndForCondition(\n-                              unitTerritoryMap.get(o1.getKey()),\n-                              t,\n-                              ProMatches.territoryCanMoveAirUnitsAndNoAa(player, data, true));\n-                }\n-              }\n-              int distance2 = 0;\n-              for (final Territory t : o2.getValue()) {\n-                if (!attackMap.get(t).isCurrentlyWins()) {\n-                  distance2 +=\n-                      data.getMap()\n-                          .getDistanceIgnoreEndForCondition(\n-                              unitTerritoryMap.get(o2.getKey()),\n-                              t,\n-                              ProMatches.territoryCanMoveAirUnitsAndNoAa(player, data, true));\n-                }\n-              }\n-              if (distance1 != distance2) {\n-                return distance1 - distance2;\n-              }\n+          final UnitType unitType1 = unit1.getType();\n+          final UnitType unitType2 = unit2.getType();\n+\n+          // If unit types are equal and are air, then sort by average distance.\n+          if (unitType1.equals(unitType2) && UnitAttachment.get(unitType1).getIsAir()) {\n+            final Predicate<Territory> predicate =\n+                ProMatches.territoryCanMoveAirUnitsAndNoAa(player, data, true);\n+            final Territory territory1 = unitTerritoryMap.get(unit1);\n+            final Territory territory2 = unitTerritoryMap.get(unit2);\n+            int distance1 = 0;\n+            for (final Territory t : territories1) {\n+              distance1 += data.getMap().getDistanceIgnoreEndForCondition(territory1, t, predicate);\n+            }\n+            int distance2 = 0;\n+            for (final Territory t : territories2) {\n+              distance2 += data.getMap().getDistanceIgnoreEndForCondition(territory2, t, predicate);\n+            }\n+            if (distance1 != distance2) {\n+              return distance1 - distance2;\n             }\n           }\n-          return o1.getKey().getType().getName().compareTo(o2.getKey().getType().getName());\n+\n+          return unitType1.getName().compareTo(unitType2.getName());\n         });\n     final Map<Unit, Set<Territory>> sortedUnitAttackOptions = new LinkedHashMap<>();\n     for (final Map.Entry<Unit, Set<Territory>> entry : list) {\n       sortedUnitAttackOptions.put(entry.getKey(), entry.getValue());\n     }\n     return sortedUnitAttackOptions;\n   }\n+\n+  private static Collection<Territory> removeWinningTerritories(\n+      final Collection<Territory> territories,\n+      final GamePlayer player,\n+      final Map<Territory, ProTerritory> attackMap,\n+      final ProOddsCalculator calc) {\n+    return territories.stream()\n+        .filter(\n+            t -> {\n+              final ProTerritory patd = attackMap.get(t);\n+              if (patd.getBattleResult() == null) {\n+                patd.estimateBattleResult(calc, player);\n+              }\n+              return !patd.isCurrentlyWins();\n+            })\n+        .collect(Collectors.toList());\n+  }\n+\n+  private static double calculateAttackEfficiency(\n+      final ProData proData,\n+      final GamePlayer player,\n+      final Map<Territory, ProTerritory> attackMap,\n+      final Collection<Territory> territories,\n+      final Unit unit) {\n+    final GameData data = proData.getData();\n+\n+    int minPower = Integer.MAX_VALUE;\n+    for (final Territory t : territories) {\n+      final Collection<TerritoryEffect> effects = TerritoryEffectHelper.getEffects(t);\n+      final UnitBattleComparator comparator =\n+          new UnitBattleComparator(false, proData.getUnitValueMap(), effects, data);\n+\n+      final List<Unit> defendingUnits =\n+          t.getUnitCollection().getMatches(Matches.enemyUnit(player, data));\n+      final Collection<Unit> sortedUnits =\n+          CollectionUtils.createSortedCollection(attackMap.get(t).getUnits(), comparator);\n+      // Compare the difference in total power when including the unit or not.\n+      int powerDifference = 0;\n+      for (final boolean includeUnit : new boolean[] {false, true}) {\n+        if (includeUnit) {\n+          sortedUnits.add(unit);\n+        }\n+        powerDifference +=\n+            (includeUnit ? 1 : -1)\n+                * DiceRoll.getTotalPower(\n+                    DiceRoll.getUnitPowerAndRollsForNormalBattles(\n+                        sortedUnits,\n+                        defendingUnits,\n+                        sortedUnits,\n+                        false,\n+                        data,\n+                        t,\n+                        effects,\n+                        false,\n+                        null),\n+                    data);\n+      }\n+      if (powerDifference < minPower) {\n+        minPower = powerDifference;\n+      }", "originalCommit": "c2e955d34f0293600edc9c8219e9fc92f554e41d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}