{"pr_number": 6593, "pr_title": "Move SubmergeVsAir and AirVsNonSubs steps to individual BattleStep classes", "pr_createdAt": "2020-06-04T21:36:36Z", "pr_url": "https://github.com/triplea-game/triplea/pull/6593", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2NzUyNg==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r435567526", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "author": "codeclimate", "createdAt": "2020-06-04T21:38:08Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/AirAttackVsNonSubsStep.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package games.strategy.triplea.delegate.battle.steps;", "originalCommit": "f7a20bde28db85f24059b73e6c3a262630d916d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2NzUyOQ==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r435567529", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "author": "codeclimate", "createdAt": "2020-06-04T21:38:09Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/AirDefendVsNonSubsStep.java", "diffHunk": "@@ -0,0 +1,31 @@\n+package games.strategy.triplea.delegate.battle.steps;", "originalCommit": "f7a20bde28db85f24059b73e6c3a262630d916d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTU2NzUzMQ==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r435567531", "bodyText": "TODO found", "author": "codeclimate", "createdAt": "2020-06-04T21:38:09Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/MustFightBattle.java", "diffHunk": "@@ -1127,6 +1383,8 @@ private void fireNavalBombardment(final IDelegateBridge bridge) {\n                 attacker, battleSite, gameData));\n     // bombarding units can't move after bombarding\n     if (!headless) {\n+      // TODO: StepRefactor: Why is a change always added even if there are no units?", "originalCommit": "f7a20bde28db85f24059b73e6c3a262630d916d6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI0MDgyOA==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436240828", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "author": "codeclimate", "createdAt": "2020-06-06T05:39:25Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/air/AirAttackVsNonSubsStep.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.air;", "originalCommit": "546c4a2f638fddbac3a4335eb1a955bc3c843385", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjI0MDgzMA==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436240830", "bodyText": "Similar blocks of code found in 2 locations. Consider refactoring.", "author": "codeclimate", "createdAt": "2020-06-06T05:39:25Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/air/AirDefendVsNonSubsStep.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.air;", "originalCommit": "546c4a2f638fddbac3a4335eb1a955bc3c843385", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b340780a3bea0fd95d439000b1624762c41089da", "url": "https://github.com/triplea-game/triplea/commit/b340780a3bea0fd95d439000b1624762c41089da", "message": "Move logic for SubmergeSubsVsAir to a BattleStep", "committedDate": "2020-06-06T23:27:18Z", "type": "commit"}, {"oid": "72a091ff50b9786dea287a1e8a5751e40ae53fa2", "url": "https://github.com/triplea-game/triplea/commit/72a091ff50b9786dea287a1e8a5751e40ae53fa2", "message": "Move logic for AirVsNonSubs to a BattleStep", "committedDate": "2020-06-06T23:27:18Z", "type": "commit"}, {"oid": "0b1231f589c1590eb15fa3799a3a60373f4a5e51", "url": "https://github.com/triplea-game/triplea/commit/0b1231f589c1590eb15fa3799a3a60373f4a5e51", "message": "A single BattleStep will only have at most one name and one executable", "committedDate": "2020-06-06T23:27:18Z", "type": "commit"}, {"oid": "e0cde49386954cffe13ec8ffd15415f64db82806", "url": "https://github.com/triplea-game/triplea/commit/e0cde49386954cffe13ec8ffd15415f64db82806", "message": "Firing steps have two step names: fire and remove casualties", "committedDate": "2020-06-06T23:27:18Z", "type": "commit"}, {"oid": "2fe48325eee8f44fa0fbd86146f47fc2465e745c", "url": "https://github.com/triplea-game/triplea/commit/2fe48325eee8f44fa0fbd86146f47fc2465e745c", "message": "Add comments and improve the names of things", "committedDate": "2020-06-06T23:27:18Z", "type": "commit"}, {"oid": "921b008f58c4b8cc063d6f99c388d667f5e1aebc", "url": "https://github.com/triplea-game/triplea/commit/921b008f58c4b8cc063d6f99c388d667f5e1aebc", "message": "Group classes into packages and simplify some duplicate test code", "committedDate": "2020-06-06T23:27:18Z", "type": "commit"}, {"oid": "df501a88d471e12df483e0f7c8a997fba3dcd4bb", "url": "https://github.com/triplea-game/triplea/commit/df501a88d471e12df483e0f7c8a997fba3dcd4bb", "message": "Run spotlessApply", "committedDate": "2020-06-06T23:27:18Z", "type": "commit"}, {"oid": "df501a88d471e12df483e0f7c8a997fba3dcd4bb", "url": "https://github.com/triplea-game/triplea/commit/df501a88d471e12df483e0f7c8a997fba3dcd4bb", "message": "Run spotlessApply", "committedDate": "2020-06-06T23:27:18Z", "type": "forcePushed"}, {"oid": "d3d9cdf98b807457f64a004a77536e73a77152f7", "url": "https://github.com/triplea-game/triplea/commit/d3d9cdf98b807457f64a004a77536e73a77152f7", "message": "Remove unused IExecutable named subclass", "committedDate": "2020-06-07T01:05:17Z", "type": "commit"}, {"oid": "f0e1884f50c127c1dc6403dbdc52074a26e2eab8", "url": "https://github.com/triplea-game/triplea/commit/f0e1884f50c127c1dc6403dbdc52074a26e2eab8", "message": "Create a 'battle state' contract between the battle steps and MustFightBattle", "committedDate": "2020-06-07T03:25:06Z", "type": "commit"}, {"oid": "d1aa9ca7512274acb907d7ffacd1a3045452f641", "url": "https://github.com/triplea-game/triplea/commit/d1aa9ca7512274acb907d7ffacd1a3045452f641", "message": "Import the enum directly", "committedDate": "2020-06-07T03:35:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyMTQxMQ==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436321411", "bodyText": "I copied this comment from MustFightBattle#getBattleExecutables but I think the comment might be outdated.  I think it should reference IDelegateBridge instead of IDisplay, IPlayer, or IRandomSource.  The only way I see steps can talk to IDisplay, IPlayer, or IRandomSource is by going through IDelegateBridge.", "author": "trevan", "createdAt": "2020-06-07T03:41:13Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleStep.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import static games.strategy.triplea.delegate.battle.steps.BattleStep.Request.EXEC;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.IExecutable;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * A step in a battle.\n+ *\n+ * <ol>\n+ *   <ul>\n+ *     Each step can have 0 or more names. These names are shown in the {@link\n+ *     games.strategy.triplea.ui.BattlePanel}\n+ *   </ul>\n+ *   <ul>\n+ *     Each step can also have an executable. See {@link BattleAtomic} on what an executable is\n+ *     comprised of.\n+ *   </ul>\n+ * </ol>\n+ */\n+@AllArgsConstructor\n+public abstract class BattleStep {\n+\n+  /**\n+   * The current state of the battle\n+   *\n+   * <p>Note: This is current mutable so the underlying data can change.\n+   */\n+  protected final BattleState battleState;\n+\n+  /** Actions that can occur in a battle that require interaction with {@link IDelegateBridge} */\n+  protected final BattleActions battleActions;\n+\n+  /** Indicates when {@link #valid} is being called */\n+  public enum Request {\n+    // Occurs at the start of the battle round\n+    NAME,\n+    // Occurs right before the step executes\n+    EXEC,\n+  }\n+\n+  public abstract BattleAtomic getExecutable();\n+\n+  public abstract List<String> getNames();\n+\n+  /**\n+   * Determine if this step should run based on the request\n+   *\n+   * @param request Indicates when valid is being called\n+   * @return true if valid\n+   */\n+  public abstract boolean valid(Request request);\n+\n+  /**\n+   * Executes the step\n+   *\n+   * <p>This is called by the BattleAtomic and {@link #valid} has already been checked\n+   *\n+   * @param stack The current stack of steps\n+   * @param bridge DelegateBridge for interacting with the rest of the program\n+   */\n+  protected abstract void execute(ExecutionStack stack, IDelegateBridge bridge);\n+\n+  /**\n+   * This is used to break up the battle into separate atomic pieces. If there is a network error,\n+   * or some other unfortunate event, then we need to keep track of what pieces we have executed,\n+   * and what is left to do. Each atomic step is in its own BattleAtomic with the definition of\n+   * atomic is that either:\n+   *\n+   * <ol>\n+   *   <li>The code does not call to an IDisplay, IPlayer, or IRandomSource", "originalCommit": "d1aa9ca7512274acb907d7ffacd1a3045452f641", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMjk5MA==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436402990", "bodyText": "Probably might as well update it so it makes sense. Won't make any more sense to anyone else at this point, and you've about as much context into this as anyone would have after the work you've done here. So if it does not make sense to you now, it probably won't make sense to anyone else (in which case the documentation is not very useful).", "author": "DanVanAtta", "createdAt": "2020-06-07T21:20:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyMTQxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyMTQ3Mw==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436321473", "bodyText": "As I mentioned in the first comment, these manual instantiations of the steps will be moved into a step factory that builds the required steps and puts them in the correct order.  But I can't build that factory until I have a few more steps converted.", "author": "trevan", "createdAt": "2020-06-07T03:42:45Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -44,9 +55,14 @@\n   final @NonNull Supplier<Collection<Territory>> getAttackerRetreatTerritories;\n   final @NonNull BiFunction<GamePlayer, Collection<Unit>, Collection<Territory>>\n       getEmptyOrFriendlySeaNeighbors;\n+  final @NonNull BattleActions battleActions;\n \n   public List<String> get() {\n \n+    final BattleStep submergeSubsVsOnlyAir = new SubmergeSubsVsOnlyAirStep(this, battleActions);\n+    final BattleStep airAttackVsNonSubs = new AirAttackVsNonSubsStep(this, battleActions);\n+    final BattleStep airDefendVsNonSubs = new AirDefendVsNonSubsStep(this, battleActions);", "originalCommit": "d1aa9ca7512274acb907d7ffacd1a3045452f641", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fd427a17f914835aa07396e84af56a3721954ad5", "url": "https://github.com/triplea-game/triplea/commit/fd427a17f914835aa07396e84af56a3721954ad5", "message": "Remove the Request enum since it doesn't appear to be needed", "committedDate": "2020-06-07T03:49:11Z", "type": "commit"}, {"oid": "5e1c1f0d7f16573ae0821d5e4f17cf79275a86cb", "url": "https://github.com/triplea-game/triplea/commit/5e1c1f0d7f16573ae0821d5e4f17cf79275a86cb", "message": "Parameterize SubmergeSubsVsOnlyAirStepTest", "committedDate": "2020-06-07T05:39:39Z", "type": "commit"}, {"oid": "548e792477ecfc003d17abf0b40705bd952e83e7", "url": "https://github.com/triplea-game/triplea/commit/548e792477ecfc003d17abf0b40705bd952e83e7", "message": "Add Builder to the MockBattleState inner class to indicate that it is for building", "committedDate": "2020-06-07T05:40:08Z", "type": "commit"}, {"oid": "2ca3523bd43a48fb8c3f241f2b602b5f1be0b32a", "url": "https://github.com/triplea-game/triplea/commit/2ca3523bd43a48fb8c3f241f2b602b5f1be0b32a", "message": "Merge remote-tracking branch 'upstream/master' into submerge-vs-air-moved-to-step", "committedDate": "2020-06-07T05:52:44Z", "type": "commit"}, {"oid": "904502d32148455eeae9ca127969582ef2ebbe4e", "url": "https://github.com/triplea-game/triplea/commit/904502d32148455eeae9ca127969582ef2ebbe4e", "message": "Remove duplicate tests now that the step is in its own class", "committedDate": "2020-06-07T05:58:24Z", "type": "commit"}, {"oid": "89563828abc9b93bac68138091b487168b727412", "url": "https://github.com/triplea-game/triplea/commit/89563828abc9b93bac68138091b487168b727412", "message": "Run spotlessJavaApply", "committedDate": "2020-06-07T06:00:01Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjMyODUwNQ==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436328505", "bodyText": "These two tests (attackingCanNotBeTargetedByAllCanSubmergeWithAllAir and defendingCanNotBeTargetedByAllCanSubmergeWithAllAir) are now being tested in SubmergeSubsVsOnlyAirStepTest#testSubmerging.  I considered leaving these tests in till after this is merged just to show that the logic is still correct.  Should I put them back in or is it ok to delete them now?", "author": "trevan", "createdAt": "2020-06-07T06:02:06Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/MustFightBattleExecutablesTest.java", "diffHunk": "@@ -1603,68 +1602,4 @@ void firstStrikeDefenderReturnFireAttNoDestroyerDefNoDestroyerWW2v2FalseSneakAtt\n         MustFightBattle.ReturnFire.ALL,\n         false);\n   }\n-\n-  @Test\n-  @DisplayName(\"Verify attacking canNotBeTargetedByAll can submerge if all is air\")", "originalCommit": "89563828abc9b93bac68138091b487168b727412", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d785386323545db6c2a105cfe572e452922640b5", "url": "https://github.com/triplea-game/triplea/commit/d785386323545db6c2a105cfe572e452922640b5", "message": "Make the MockBattleState a builder instead of having it wrap a builder", "committedDate": "2020-06-07T14:17:25Z", "type": "commit"}, {"oid": "a09b2e3cad7e262e5c3ce04e19f1f6dd86511119", "url": "https://github.com/triplea-game/triplea/commit/a09b2e3cad7e262e5c3ce04e19f1f6dd86511119", "message": "Auto-Formatting", "committedDate": "2020-06-07T14:19:38Z", "type": "commit"}, {"oid": "54b79f7066cbb6b1e1df822e65956eecc49c9889", "url": "https://github.com/triplea-game/triplea/commit/54b79f7066cbb6b1e1df822e65956eecc49c9889", "message": "Fix ordering of variables", "committedDate": "2020-06-07T15:05:01Z", "type": "commit"}, {"oid": "fe64e1ca01ceb7122f91f632e1cf88acdc148108", "url": "https://github.com/triplea-game/triplea/commit/fe64e1ca01ceb7122f91f632e1cf88acdc148108", "message": "Handle save game compatibility", "committedDate": "2020-06-07T17:19:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMDkxMA==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436400910", "bodyText": "My presumption is that changes to the battle state are implementation dependent, IE: we assume that the underlying collection is returned and any modifications to it will modify the underlying collection.\nWhat are your thoughts to provide mutator methods?\nIE:\nvoid removeAttackerUnits(Unit... units);\nvoid removeDefendingUnits(Unit... units);", "author": "DanVanAtta", "createdAt": "2020-06-07T20:54:49Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/BattleState.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import games.strategy.engine.data.Unit;\n+import java.util.Collection;\n+\n+/** Exposes the battle state and allows updates to it */", "originalCommit": "fe64e1ca01ceb7122f91f632e1cf88acdc148108", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNjQ2OA==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436406468", "bodyText": "I plan to add those.  My plan is to add the existing methods from MustFightBattle that are needed in the steps.  As I convert each step, I'll be adding more and more methods to the two interfaces.  Some of these methods will be mutator methods.  I don't plan on renaming them at that point, though.\nThen, I plan on splitting up methods that have functionality that should be in BattleActions (IDelegateBridge interaction) and BattleState.  An example of this is MustFightBattle#queryRetreat.\nOnce I have the methods split between the two interfaces, I'll look into refactoring them so that they have a targeted focus.", "author": "trevan", "createdAt": "2020-06-07T22:09:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMDkxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMTI0NA==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436401244", "bodyText": "Nit, I don't think we typically document when something is mutable or immutable. There are annotations to do that. Presume for example that BattleState were used in 10 places, that's 10 places to have the mutable comment. If we were then to make BattleState immutable, it is either a lot of commentary that is out of date, or best case a lot of comments to update. Either way we add maintenance work. I think it's just easier then to omit mutable/immutable documentation (and if immutable, then perhaps that is okay to document via @Immutable as we probably should not make making an immutable object mutable)", "author": "DanVanAtta", "createdAt": "2020-06-07T20:59:06Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleStep.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.IExecutable;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * A step in a battle.\n+ *\n+ * <ol>\n+ *   <ul>\n+ *     Each step can have 0 or more names. These names are shown in the {@link\n+ *     games.strategy.triplea.ui.BattlePanel}\n+ *   </ul>\n+ *   <ul>\n+ *     Each step can also have an executable. See {@link BattleAtomic} on what an executable is\n+ *     comprised of.\n+ *   </ul>\n+ * </ol>\n+ */\n+@AllArgsConstructor\n+public abstract class BattleStep {\n+\n+  /**\n+   * The current state of the battle\n+   *\n+   * <p>Note: This is current mutable so the underlying data can change.", "originalCommit": "fe64e1ca01ceb7122f91f632e1cf88acdc148108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMTYxOQ==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436401619", "bodyText": "Inheritance is a very strong form of coupling, using protected variables is also potentially very painful as well when considering inheritance hierarchies. In some cases as well some implementations may not need all of the protected variables.\nWhat are your thoughts to convert this class to an interface? In such a case, it seems like we only need to move these two variables to the child classes. The level of code duplication is pretty negligable since they already have the all arg constructors and in turn each of the child classes would be much more strongly encapsulated. WDYT, any concerns with that suggestion?", "author": "DanVanAtta", "createdAt": "2020-06-07T21:03:15Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleStep.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.IExecutable;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * A step in a battle.\n+ *\n+ * <ol>\n+ *   <ul>\n+ *     Each step can have 0 or more names. These names are shown in the {@link\n+ *     games.strategy.triplea.ui.BattlePanel}\n+ *   </ul>\n+ *   <ul>\n+ *     Each step can also have an executable. See {@link BattleAtomic} on what an executable is\n+ *     comprised of.\n+ *   </ul>\n+ * </ol>\n+ */\n+@AllArgsConstructor\n+public abstract class BattleStep {\n+\n+  /**\n+   * The current state of the battle\n+   *\n+   * <p>Note: This is current mutable so the underlying data can change.\n+   */\n+  protected final BattleState battleState;\n+\n+  /** Actions that can occur in a battle that require interaction with {@link IDelegateBridge} */\n+  protected final BattleActions battleActions;", "originalCommit": "fe64e1ca01ceb7122f91f632e1cf88acdc148108", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwODY2Ng==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436408666", "bodyText": "Before the conversion to use MustFightBattle as the BattleState there was more of a reason.  I can't think of a good reason to keep it inherited so I'll change it to an interface..", "author": "trevan", "createdAt": "2020-06-07T22:39:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMTYxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMTY1MQ==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436401651", "bodyText": "A javadoc on this method could be of some use. It's a bit odd to think that a step would have multiple names. It'd be nice to know what it means to have multiple names for a step and secondarily if this is for display purposes only.", "author": "DanVanAtta", "createdAt": "2020-06-07T21:03:50Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleStep.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.IExecutable;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * A step in a battle.\n+ *\n+ * <ol>\n+ *   <ul>\n+ *     Each step can have 0 or more names. These names are shown in the {@link\n+ *     games.strategy.triplea.ui.BattlePanel}\n+ *   </ul>\n+ *   <ul>\n+ *     Each step can also have an executable. See {@link BattleAtomic} on what an executable is\n+ *     comprised of.\n+ *   </ul>\n+ * </ol>\n+ */\n+@AllArgsConstructor\n+public abstract class BattleStep {\n+\n+  /**\n+   * The current state of the battle\n+   *\n+   * <p>Note: This is current mutable so the underlying data can change.\n+   */\n+  protected final BattleState battleState;\n+\n+  /** Actions that can occur in a battle that require interaction with {@link IDelegateBridge} */\n+  protected final BattleActions battleActions;\n+\n+  public abstract BattleAtomic getExecutable();\n+\n+  public abstract List<String> getNames();", "originalCommit": "fe64e1ca01ceb7122f91f632e1cf88acdc148108", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNzc0NQ==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436407745", "bodyText": "The explanation about name is on the class.  I'll move it down to here.", "author": "trevan", "createdAt": "2020-06-07T22:27:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMTY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMjgwNA==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436402804", "bodyText": "Typically methods should not be aware of who is calling them. It's also a design smell when we require one method to have been called before another (and furthermore when that method is determining state that dictates whether you can and should call another method).\nThat could potentially be fixed by returning an object to then be executed. EG:\nprotected Optional<BiConsumer<ExecutionStack, IDelegateBridge>> getBattleStepExecutable();\n\nThen usage below of:\n public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n      final BattleStep executingStep = BattleStep.this;\n      if (executingStep.valid()) {\n        executingStep.execute(stack, bridge);\n      }\n\nwould be transformed into:\n public void execute(final ExecutionStack stack, final IDelegateBridge bridge) {\n       getBattleStepExecutable().ifPresent(stepExecutable -> stepExecutable.accept(stack, bridge));\n  }\n\nIt also appears that getName() has a dependency on isValid() as well. In those cases if isValid() is false then presumably getNames() could return an empty collection.\nWDYT?", "author": "DanVanAtta", "createdAt": "2020-06-07T21:18:28Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleStep.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.IExecutable;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * A step in a battle.\n+ *\n+ * <ol>\n+ *   <ul>\n+ *     Each step can have 0 or more names. These names are shown in the {@link\n+ *     games.strategy.triplea.ui.BattlePanel}\n+ *   </ul>\n+ *   <ul>\n+ *     Each step can also have an executable. See {@link BattleAtomic} on what an executable is\n+ *     comprised of.\n+ *   </ul>\n+ * </ol>\n+ */\n+@AllArgsConstructor\n+public abstract class BattleStep {\n+\n+  /**\n+   * The current state of the battle\n+   *\n+   * <p>Note: This is current mutable so the underlying data can change.\n+   */\n+  protected final BattleState battleState;\n+\n+  /** Actions that can occur in a battle that require interaction with {@link IDelegateBridge} */\n+  protected final BattleActions battleActions;\n+\n+  public abstract BattleAtomic getExecutable();\n+\n+  public abstract List<String> getNames();\n+\n+  /**\n+   * Determine if this step should run based on the request\n+   *\n+   * @return true if valid\n+   */\n+  public abstract boolean valid();\n+\n+  /**\n+   * Executes the step\n+   *\n+   * <p>This is called by the BattleAtomic and {@link #valid} has already been checked", "originalCommit": "fe64e1ca01ceb7122f91f632e1cf88acdc148108", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQxMjAyMg==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436412022", "bodyText": "getBattleStepExecutable actually returns the BattleAtomic.  So calling getBattleStepExecutable inside of the BattleAtomic will not work since it will just go into an infinite loop.\nI see what you are trying to do but I don't see how that helps.  You are just moving the valid() call to another method which is still making execute() be dependent on valid().  I had made execute() a protected method so that the dependency on valid() was controlled by the class and callers wouldn't have to worry about it.  It was an internal implementation.  Though, with your idea of turning this class into an interface, that internal implementation becomes public, so it complicates it.  I guess implementations of BattleStep will just have to ensure that execute() checks isValid() beforehand.\nAs for getNames(), I can see why you say it has a dependency.  The only caller of it is always checking isValid().  I can envision other callers not caring if it is valid or not but I currently don't envision creating those callers so I can move isValid() inside of each of the getNames().", "author": "trevan", "createdAt": "2020-06-07T23:29:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMjgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMjkwNQ==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436402905", "bodyText": "Is this an inner class only because of IExecutable?", "author": "DanVanAtta", "createdAt": "2020-06-07T21:19:57Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleStep.java", "diffHunk": "@@ -0,0 +1,88 @@\n+package games.strategy.triplea.delegate.battle.steps;\n+\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.IExecutable;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import lombok.AllArgsConstructor;\n+\n+/**\n+ * A step in a battle.\n+ *\n+ * <ol>\n+ *   <ul>\n+ *     Each step can have 0 or more names. These names are shown in the {@link\n+ *     games.strategy.triplea.ui.BattlePanel}\n+ *   </ul>\n+ *   <ul>\n+ *     Each step can also have an executable. See {@link BattleAtomic} on what an executable is\n+ *     comprised of.\n+ *   </ul>\n+ * </ol>\n+ */\n+@AllArgsConstructor\n+public abstract class BattleStep {\n+\n+  /**\n+   * The current state of the battle\n+   *\n+   * <p>Note: This is current mutable so the underlying data can change.\n+   */\n+  protected final BattleState battleState;\n+\n+  /** Actions that can occur in a battle that require interaction with {@link IDelegateBridge} */\n+  protected final BattleActions battleActions;\n+\n+  public abstract BattleAtomic getExecutable();\n+\n+  public abstract List<String> getNames();\n+\n+  /**\n+   * Determine if this step should run based on the request\n+   *\n+   * @return true if valid\n+   */\n+  public abstract boolean valid();\n+\n+  /**\n+   * Executes the step\n+   *\n+   * <p>This is called by the BattleAtomic and {@link #valid} has already been checked\n+   *\n+   * @param stack The current stack of steps\n+   * @param bridge DelegateBridge for interacting with the rest of the program\n+   */\n+  protected abstract void execute(ExecutionStack stack, IDelegateBridge bridge);\n+\n+  /**\n+   * This is used to break up the battle into separate atomic pieces. If there is a network error,\n+   * or some other unfortunate event, then we need to keep track of what pieces we have executed,\n+   * and what is left to do. Each atomic step is in its own BattleAtomic with the definition of\n+   * atomic is that either:\n+   *\n+   * <ol>\n+   *   <li>The code does not call to an IDisplay, IPlayer, or IRandomSource\n+   *   <li>If the code calls to an IDisplay, IPlayer, IRandomSource, and an exception is called from\n+   *       one of those methods, the exception will be propagated out of execute() and the execute\n+   *       method can be called again.\n+   * </ol>\n+   */\n+  public abstract class BattleAtomic implements IExecutable {", "originalCommit": "fe64e1ca01ceb7122f91f632e1cf88acdc148108", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNzY4OQ==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436407689", "bodyText": "No, it needs a reference to the BattleStep that is enclosing it so that it can then call valid on it and execute.\nI could change it to have a instance variable that is the BattleStep and each step has to construct it and pass in itself.  The execute method on BattleStep will need to made public as well.", "author": "trevan", "createdAt": "2020-06-07T22:26:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMjkwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMzE5OA==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436403198", "bodyText": "nit, if the return value is nullable, at the very least the method should be marked as @Nullable. Perhaps better though if this returns Optional<BattleAtomic> so that any caller won't mistakenly think the return value is non-nullable and run into a NPE.", "author": "DanVanAtta", "createdAt": "2020-06-07T21:23:33Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/air/AirVsNonSubsStep.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.air;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import java.util.Collection;\n+\n+/** Air can not attack subs unless a destroyer is present */\n+public abstract class AirVsNonSubsStep extends BattleStep {\n+\n+  public AirVsNonSubsStep(final BattleState battleState, final BattleActions battleActions) {\n+    super(battleState, battleActions);\n+  }\n+\n+  @Override\n+  public BattleAtomic getExecutable() {\n+    return null;", "originalCommit": "fe64e1ca01ceb7122f91f632e1cf88acdc148108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMzIzNA==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436403234", "bodyText": "If we always return 0 or 1 element, would Optional<String> be a better return API? In that case there would not be any confusion that we can have more than one element and it'd be clear we'd have either zero or one.", "author": "DanVanAtta", "createdAt": "2020-06-07T21:24:20Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/retreat/sub/SubmergeSubsVsOnlyAirStep.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package games.strategy.triplea.delegate.battle.steps.retreat.sub;\n+\n+import static games.strategy.triplea.delegate.battle.BattleStepStrings.SUBMERGE_SUBS_VS_AIR_ONLY;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.delegate.IDelegateBridge;\n+import games.strategy.triplea.delegate.ExecutionStack;\n+import games.strategy.triplea.delegate.Matches;\n+import games.strategy.triplea.delegate.battle.BattleActions;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import games.strategy.triplea.delegate.battle.steps.BattleStep;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.function.Predicate;\n+import org.triplea.java.collections.CollectionUtils;\n+\n+/** Units that canNotBeTargetedByAll can submerge if there are only Air units in the battle */\n+public class SubmergeSubsVsOnlyAirStep extends BattleStep {\n+\n+  private static final Predicate<Unit> canNotBeTargetedByAllMatch =\n+      Matches.unitCanEvade().and(Matches.unitCanNotBeTargetedByAll());\n+\n+  public SubmergeSubsVsOnlyAirStep(\n+      final BattleState battleState, final BattleActions battleActions) {\n+    super(battleState, battleActions);\n+  }\n+\n+  @Override\n+  public BattleAtomic getExecutable() {\n+    return new BattleAtomic() {\n+      private static final long serialVersionUID = 99990L;\n+    };\n+  }\n+\n+  @Override\n+  public List<String> getNames() {\n+    return List.of(SUBMERGE_SUBS_VS_AIR_ONLY);", "originalCommit": "fe64e1ca01ceb7122f91f632e1cf88acdc148108", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNjkzMw==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436406933", "bodyText": "No, there are steps that will have more than 1.  An example is the step that fires aa guns.  The step will return \"attacker fires guns\", \"defender selects casualties\", and \"defender removes casualties\".\nNow, it is possible after further refactoring, that step could be split up into three separate steps.  But I'm not sure at this point.", "author": "trevan", "createdAt": "2020-06-07T22:16:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMzIzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMzI3Nw==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436403277", "bodyText": "Minor: I noticed you used lombok getters on another class, why not here too?", "author": "DanVanAtta", "createdAt": "2020-06-07T21:24:54Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/MockBattleState.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import games.strategy.engine.data.Unit;\n+import java.util.Collection;\n+import java.util.List;\n+import lombok.Builder;\n+import lombok.NonNull;\n+\n+/**\n+ * Simple implementation of BattleState for tests to use\n+ *\n+ * <p>{@link #givenBattleState()} will return a builder with everything defaulted and the test can\n+ * override the specific items needed.\n+ */\n+@Builder\n+public class MockBattleState implements BattleState {\n+\n+  final @NonNull Collection<Unit> attackingUnits;\n+  final @NonNull Collection<Unit> defendingUnits;\n+\n+  public static MockBattleState.MockBattleStateBuilder givenBattleState() {\n+    return MockBattleState.builder().attackingUnits(List.of()).defendingUnits(List.of());\n+  }\n+\n+  @Override\n+  public Collection<Unit> getAttackingUnits() {", "originalCommit": "fe64e1ca01ceb7122f91f632e1cf88acdc148108", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQxMTcwOA==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436411708", "bodyText": "It's because I'm not accustomed to using lombok.  So, I'll remember to use it sometimes but then revert to my usual ways of not using it.", "author": "trevan", "createdAt": "2020-06-07T23:23:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMzI3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMzU5Ng==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436403596", "bodyText": "It looks like all usages of this method always define attacking unit and defending units, why not just use the builder directly?\nIE: instead of: MockBattleState.givenBattleState(), use instead: MockBattleState.builder()", "author": "DanVanAtta", "createdAt": "2020-06-07T21:28:53Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/MockBattleState.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import games.strategy.engine.data.Unit;\n+import java.util.Collection;\n+import java.util.List;\n+import lombok.Builder;\n+import lombok.NonNull;\n+\n+/**\n+ * Simple implementation of BattleState for tests to use\n+ *\n+ * <p>{@link #givenBattleState()} will return a builder with everything defaulted and the test can\n+ * override the specific items needed.\n+ */\n+@Builder\n+public class MockBattleState implements BattleState {\n+\n+  final @NonNull Collection<Unit> attackingUnits;\n+  final @NonNull Collection<Unit> defendingUnits;\n+\n+  public static MockBattleState.MockBattleStateBuilder givenBattleState() {", "originalCommit": "fe64e1ca01ceb7122f91f632e1cf88acdc148108", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNzEzMA==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436407130", "bodyText": "Because some of the steps will require more items added.  An example is the aa guns.  They don't care about offensive/defensiveUnits but use the offensive/defensive aa.\nI'm actually thinking that all the parameters for BattleState is going to end up looking like the parameters to BattleSteps.", "author": "trevan", "createdAt": "2020-06-07T22:19:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMzU5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMTQ0MQ==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436421441", "bodyText": "My point is that you don't need to use a builder to init the values to empty lists and then return that builder to overwrite the values. You can use builder directly I would think. Look into using @Singular on those: https://projectlombok.org/features/Builder#singular", "author": "DanVanAtta", "createdAt": "2020-06-08T01:16:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwMzU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNDA2MA==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436404060", "bodyText": "Attacking and defending units being together pretty much always looks like the data clump code smell. It appears that BattleState could instead become a first class object and be a relatively simple value object.\nIt might make sense to rename BattleState to UnitsInBattle or BattleUnits, or BattleParticipants as we are not capturing the full battle state but just the units in battle.\nIf serialization were not a concern, then we could replace both attacking and defending units with a BattleState. To fix the data clump code smell we could:\n\nadd a transient BattleState object. Whenever we assign a battle state object then we write the corresponding values to attacking and defending units. This way we would get serialization and any usages of the data would be through battle state. It might be possible as well to override the serialization write-object method and to serialize attacking units and defending units through a battle state. Serialization proxy might be a way to do that, though the proxy itself could break compatibility alone.\n\nFundamentally BattleState is not really an interface, it's more data that can be present in an object and I suspect it makes sense to simply have a reference to it.\nWDYT?", "author": "DanVanAtta", "createdAt": "2020-06-07T21:35:32Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/BattleSteps.java", "diffHunk": "@@ -31,8 +37,13 @@\n   final @NonNull GamePlayer defender;\n   final @NonNull Collection<Unit> offensiveAa;\n   final @NonNull Collection<Unit> defendingAa;\n+\n+  @Getter(onMethod = @__({@Override}))\n   final @NonNull Collection<Unit> attackingUnits;", "originalCommit": "fe64e1ca01ceb7122f91f632e1cf88acdc148108", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNzQ5Nw==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436407497", "bodyText": "I agree.  It's what I'd like to get to.  Once the BattleState interface has been fully built, I'll then know what is all the parts of MustFightBattle that is part of the state and I'd like to make a value object that holds that data.  I'd also like to convert the attacking/defending units into FiringGroups (from my older PR that I closed).  Then it doesn't need separate attacking/defending units, attacking/defending aa, and bombarding units.", "author": "trevan", "createdAt": "2020-06-07T22:24:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQwNDA2MA=="}], "type": "inlineReview"}, {"oid": "7f0ea3c8ebe9665c4638c19a6cc14229418ce125", "url": "https://github.com/triplea-game/triplea/commit/7f0ea3c8ebe9665c4638c19a6cc14229418ce125", "message": "Fix documentation and use of lombok", "committedDate": "2020-06-07T23:34:37Z", "type": "commit"}, {"oid": "7af45f1509a1d27a22d2348ec0150023af2500d1", "url": "https://github.com/triplea-game/triplea/commit/7af45f1509a1d27a22d2348ec0150023af2500d1", "message": "Refactor BattleStep to be an interface and remove BattleAtomic", "committedDate": "2020-06-08T00:02:30Z", "type": "commit"}, {"oid": "44e85a335799ac4a61dfbcd1dd640bbc69e895a0", "url": "https://github.com/triplea-game/triplea/commit/44e85a335799ac4a61dfbcd1dd640bbc69e895a0", "message": "Fix code style issues and clean up comments", "committedDate": "2020-06-08T00:33:40Z", "type": "commit"}, {"oid": "5b9d5dc50a130745ca9a064a75686efafb903de9", "url": "https://github.com/triplea-game/triplea/commit/5b9d5dc50a130745ca9a064a75686efafb903de9", "message": "Assume getNames will do isValid inside of it and so always call it", "committedDate": "2020-06-08T00:50:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQxOTg4Mw==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436419883", "bodyText": "nit, can use a ternary here to be a bit more concise. It's generally a bit easier (lower cognitive load) for if statements to lead with the 'true' value.\nIE:\nreturn valid()\n   ? List.of(AIR_ATTACK_NON_SUBS)\n   : List.of();", "author": "DanVanAtta", "createdAt": "2020-06-08T01:03:11Z", "path": "game-core/src/main/java/games/strategy/triplea/delegate/battle/steps/fire/air/AirAttackVsNonSubsStep.java", "diffHunk": "@@ -2,18 +2,20 @@\n \n import static games.strategy.triplea.delegate.battle.BattleStepStrings.AIR_ATTACK_NON_SUBS;\n \n-import games.strategy.triplea.delegate.battle.BattleActions;\n import games.strategy.triplea.delegate.battle.BattleState;\n import java.util.List;\n \n /** Air can not attack subs unless a destroyer is present */\n public class AirAttackVsNonSubsStep extends AirVsNonSubsStep {\n-  public AirAttackVsNonSubsStep(final BattleState battleState, final BattleActions battleActions) {\n-    super(battleState, battleActions);\n+  public AirAttackVsNonSubsStep(final BattleState battleState) {\n+    super(battleState);\n   }\n \n   @Override\n   public List<String> getNames() {\n+    if (!valid()) {", "originalCommit": "7af45f1509a1d27a22d2348ec0150023af2500d1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMDk4MQ==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436420981", "bodyText": "The givenBattleState is still odd, it probably should at least return a builder().\nYou can make list values non-file and use @Builder.Default to initialize them to empty lists.\nAlso consider using @Singular which I think will default the value to an empty list if not specified. Using @Singular on the attacking and defending units properties, you could instead write:\nMockBattleState.builder()\n   .attackingUnit(givenUnitCanNotBeTargetedBy(mock(UnitType.class)))\n   .defendingUnit(givenUnit())\n   .defendingUnit(givenUnitIsAir())\n   .build();", "author": "DanVanAtta", "createdAt": "2020-06-08T01:12:42Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/air/AirDefendVsNonSubsStepTest.java", "diffHunk": "@@ -6,67 +6,59 @@\n import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitIsAir;\n import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n import static org.hamcrest.Matchers.is;\n import static org.mockito.Mockito.mock;\n \n import games.strategy.engine.data.Unit;\n import games.strategy.engine.data.UnitType;\n import games.strategy.triplea.delegate.battle.BattleState;\n import java.util.List;\n-import org.junit.jupiter.api.DisplayName;\n-import org.junit.jupiter.api.Test;\n import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n import org.mockito.junit.jupiter.MockitoExtension;\n \n @ExtendWith(MockitoExtension.class)\n class AirDefendVsNonSubsStepTest {\n \n-  @Test\n-  @DisplayName(\"valid() is true if defender has air and no destroyer and attacker has sub\")\n-  void airVsSub() {\n-    final Unit defender1 = givenUnit();\n-    final Unit defender2 = givenUnitIsAir();\n-    final Unit attacker = givenUnitCanNotBeTargetedBy(mock(UnitType.class));\n-\n-    final BattleState battleState =\n-        givenBattleState()\n-            .attackingUnits(List.of(defender1, defender2))\n-            .defendingUnits(List.of(attacker))\n-            .build();\n-    final AirAttackVsNonSubsStep underTest = new AirAttackVsNonSubsStep(battleState);\n-    assertThat(underTest.valid(), is(true));\n+  @ParameterizedTest(name = \"[{index}] {0} is {2}\")\n+  @MethodSource\n+  void testWhatIsValid(\n+      final String displayName, final BattleState battleState, final boolean expected) {\n+    final AirDefendVsNonSubsStep underTest = new AirDefendVsNonSubsStep(battleState);\n+    assertThat(underTest.valid(), is(expected));\n+    if (expected) {\n+      assertThat(underTest.getNames(), hasSize(1));\n+    } else {\n+      assertThat(underTest.getNames(), hasSize(0));\n+    }\n   }\n \n-  @Test\n-  @DisplayName(\"valid() is false if defender has air and destroyer\")\n-  void airDestroyerVsAnything() {\n-    final Unit defender1 = givenUnitDestroyer();\n-    final Unit defender2 = givenUnitIsAir();\n-    // once a destroyer is around, it doesn't care about the attacker units\n-    final Unit attacker = mock(Unit.class);\n-\n-    final BattleState battleState =\n-        givenBattleState()\n-            .attackingUnits(List.of(defender1, defender2))\n-            .defendingUnits(List.of(attacker))\n-            .build();\n-    final AirAttackVsNonSubsStep underTest = new AirAttackVsNonSubsStep(battleState);\n-    assertThat(underTest.valid(), is(false));\n-  }\n-\n-  @Test\n-  @DisplayName(\"valid() is false if defender has air and no destroyer and attacker has no sub\")\n-  void airVsOther() {\n-    final Unit defender1 = givenUnit();\n-    final Unit defender2 = givenUnitIsAir();\n-    final Unit attacker = givenUnit();\n-\n-    final BattleState battleState =\n-        givenBattleState()\n-            .attackingUnits(List.of(defender1, defender2))\n-            .defendingUnits(List.of(attacker))\n-            .build();\n-    final AirAttackVsNonSubsStep underTest = new AirAttackVsNonSubsStep(battleState);\n-    assertThat(underTest.valid(), is(false));\n+  static List<Arguments> testWhatIsValid() {\n+    return List.of(\n+        Arguments.of(\n+            \"Defender has air units and no destroyers vs Attacker subs\",\n+            givenBattleState()", "originalCommit": "5b9d5dc50a130745ca9a064a75686efafb903de9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzMzE1Nw==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436433157", "bodyText": "Thanks for the pointer to @Singular", "author": "trevan", "createdAt": "2020-06-08T02:38:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMDk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzNjE1Ng==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436436156", "bodyText": "@Singular is causing the Error Prone static analysis plugin to throw an exception.  All you need to do is put @Singular on one of the fields in MockBattleState and then run it.", "author": "trevan", "createdAt": "2020-06-08T02:56:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMDk4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ1NTMzMw==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436455333", "bodyText": "Ah yeah, error prone and singular do not play well.  I think the error prone analysis that fails needs to be suppressed for classes that use singular. Perhaps turning the rule off is a better move. IMO @Singular can be really useful, error prone is arguably getting in our way with it.", "author": "DanVanAtta", "createdAt": "2020-06-08T04:49:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMDk4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMTg0NQ==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436421845", "bodyText": "Nit, this is not really a Mock. A stub is something that returns the same value (the stub controls the return value), a mock is something that returns the value you tell it to (test controls the return value), and a 'fake' is a simplified implementation (aka, a test double).\nIn this case it looks like we basically have a real implementation. It's tempting to call this a test-fake, but given the API is so simple it looks to be full-blown.\nThis makes me wonder if we should have a DefaultBattleState on the BattleState interface itself.  Essentially in BattleState declaring a public static class DefaultBattleState that would be this class. You've mentioned though you expect this class to grow and perhaps then we'll want to use a true-mock.\nIn the meantime the naming is a bit misleading and I think would be useful to fix. Perhaps we could call this a DefaultBattleState, or a SimpleBattleState.", "author": "DanVanAtta", "createdAt": "2020-06-08T01:20:10Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/MockBattleState.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package games.strategy.triplea.delegate.battle;\n+\n+import games.strategy.engine.data.Unit;\n+import java.util.Collection;\n+import java.util.List;\n+import lombok.Builder;\n+import lombok.Getter;\n+import lombok.NonNull;\n+\n+/**\n+ * Simple implementation of BattleState for tests to use\n+ *\n+ * <p>{@link #givenBattleState()} will return a builder with everything defaulted and the test can\n+ * override the specific items needed.\n+ */\n+@Builder\n+public class MockBattleState implements BattleState {", "originalCommit": "5b9d5dc50a130745ca9a064a75686efafb903de9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzMjA3Nw==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436432077", "bodyText": "I'm trying to build a faked BattleState in a fluent manner where the test methods can easily modify the object to get it to the state they need.\nWith this mechanism, I could have one test that does\ngivenBattleState().attackingUnits(units).defendingUnits(units2).build();\n\nwhile another test could do\ngivenBattleState().bombardingUnits(units).build();\n\nand another could do\ngivenBattleState().bombardingUnits(units).battleSite(territory).build();\n\nThat's why I'm returning the MockBattleStateBuilder class instead of the BattleStateBuilder class.  I could add @Builder(toBuilder = true) and then do\ngivenBattleState().toBuilder().bombardingUnits(units).battleSite(territory).build();\n\nbut that felt like extra work that I could skip.\nI'd like to use mock() but I don't see how I can do that in a fluent manner.  Instead, I'd have to do\nBattleState battleState = givenBattleState();\nwhen(battleState.attackingUnits()).thenReturn(units);\nwhen(battleState.defendingUnits()).thenReturn(units2);\n\nI could call it a fake because it will not be a full blown implementation.  Once I start adding in the updater methods, I'll not be implementing them.  The tests will just spy on the BattleState and check that the methods were called correctly.  And if I ever come across a step that updates the state and then reads from the updated state, I'll have rethink this :)  I haven't yet seen one but I haven't fully investigated every single step yet.", "author": "trevan", "createdAt": "2020-06-08T02:31:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMTg0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ0MDEwNA==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436440104", "bodyText": "I've renamed the class to FakeBattleState and the given method to givenBattleStateBuilder().", "author": "trevan", "createdAt": "2020-06-08T03:21:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMTg0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ1NDc3Mg==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436454772", "bodyText": "Understood on the fluent API, that is cool \ud83d\udc4d\nOne word of caution/note, spying on state changes is generally a test code smell. It's generally better if one module computes the state change and returns the new state value. Then have another module that uses the first one to do the state mutation.\nIE:\n\nBiFunction<GameData, BattleState, Integer> computationStrategy;\nBattleState battleState;\n\nvoid foo(GameData gameData) {\n  int newValue = computationStrategy.apply(gameData, battleState);\n  battleState.setSomeValue(newValue);\n}\n\nIn this case the test for the above is quite trivial as the computation function can be injected. In TripleA so far the cleanest way I know to do that is to use a static build function, ie:\n@Builder\nclass ImperativeShell {\n  @Nonnull private final BattleState battleState;\n  @Nonnull private final GameData gameData;\n  @Nonnull private final BiFunction<BattleState, GAmeDAta, Integer> computationFunction;\n\n   public static ImperativeShell build(GameData gameData, BattleState battleState) {\n         return builder()\n                      .battleState(battleState)\n                      .gameData(gameData)\n                      .computationFunction(new RealComputationFunction())\n                      .build();\n   }\n}\n\nThen in test you can use the builder() directly to inject mocks. IE:\nclass ImperativeShellTest {\n  @Mock private BattleState battleState;\n  @Mock private GameData gameData;\n  @Mock private BiFunction<BattleState, GAmeDAta, Integer> computationFunction;\n   \n   private ImperativeShell imperativeShell;\n  \n   @BeforeEach\n   void setUp() {\n         imperativeShell = ImperativeShell builder()\n                      .battleState(battleState)\n                      .gameData(gameData)\n                      .computationFunction(computationFunction)\n                      .build();\n   }\n}\n\nAt the end of this you can then test the 'RealComputationFunction' directly and assert it returns the expected values without having to spy for side-effects. It turns assertions that look like this:\ncomputation.apply(battleState);\n\nverify(battleState).unitRemoved(unit);\n\nInto:\nUnit result = computation.apply(battleState);\n\nassertThat(result, is(someExpectedUnit));", "author": "DanVanAtta", "createdAt": "2020-06-08T04:46:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMTg0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQ1NjExNA==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436456114", "bodyText": "Nota bene, if the objects to inject are all unique minus the generic types (recall that in java generic types are dropped during compilation time), then @InjectMocks can make a test even easier and automatically link mocks to an @RequiredsArgsConstructor (which is created automatically when using @Builder), ie:\nclass ImperativeShellTest {\n  @Mock private BattleState battleState;\n  @Mock private GameData gameData;\n  @Mock private BiFunction<BattleState, GAmeDAta, Integer> computationFunction;\n   \n   @InjectMocks\n   private ImperativeShell imperativeShell;", "author": "DanVanAtta", "createdAt": "2020-06-08T04:53:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMTg0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMjA5MA==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436422090", "bodyText": "Nit, most given methods should take a parameter. Something like:\ngivenUnitWithAttackPower(2)\n\nIf there is no parameter, and the return value is very generic, then something like the following would be typical (note the 'any' word):\ngivenAnyUnit()\n\nOtherwise the given should probably spell out what is special about the thing that is being returned, you've done that in the example of: givenUnitIsAir()", "author": "DanVanAtta", "createdAt": "2020-06-08T01:21:53Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/air/AirAttackVsNonSubsStepTest.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.air;\n+\n+import static games.strategy.triplea.delegate.battle.MockBattleState.givenBattleState;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanNotBeTargetedBy;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitIsAir;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class AirAttackVsNonSubsStepTest {\n+\n+  @ParameterizedTest(name = \"[{index}] {0} is {2}\")\n+  @MethodSource\n+  void testWhatIsValid(\n+      final String displayName, final BattleState battleState, final boolean expected) {\n+    final AirAttackVsNonSubsStep underTest = new AirAttackVsNonSubsStep(battleState);\n+    assertThat(underTest.valid(), is(expected));\n+    if (expected) {\n+      assertThat(underTest.getNames(), hasSize(1));\n+    } else {\n+      assertThat(underTest.getNames(), hasSize(0));\n+    }\n+  }\n+\n+  static List<Arguments> testWhatIsValid() {\n+    return List.of(\n+        Arguments.of(\n+            \"Attacker has air units and no destroyers vs Defender subs\",\n+            givenBattleState()\n+                .attackingUnits(List.of(givenUnit(), givenUnitIsAir()))", "originalCommit": "5b9d5dc50a130745ca9a064a75686efafb903de9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMjI4OQ==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436422289", "bodyText": "Side note, if you could follow-up and remove the Tuple return value from newUnitAndAttachment, it would be appreciated. We really do want to delete that class outright in favor of value objects.", "author": "DanVanAtta", "createdAt": "2020-06-08T01:23:43Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/BattleStepsTest.java", "diffHunk": "@@ -139,6 +145,19 @@ public static Unit givenUnitAttackerFirstStrikeCanNotBeTargetedBy(final UnitType\n     return unitAndAttachment.getFirst();\n   }\n \n+  public static Unit givenUnitCanEvadeAndCanNotBeTargetedBy(final UnitType otherType) {\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    when(unitAndAttachment.getSecond().getCanEvade()).thenReturn(true);\n+    when(unitAndAttachment.getSecond().getCanNotBeTargetedBy()).thenReturn(Set.of(otherType));\n+    return unitAndAttachment.getFirst();\n+  }\n+\n+  public static Unit givenUnitCanNotBeTargetedBy(final UnitType otherType) {\n+    final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();\n+    when(unitAndAttachment.getSecond().getCanNotBeTargetedBy()).thenReturn(Set.of(otherType));\n+    return unitAndAttachment.getFirst();\n+  }\n+\n   public static Unit givenUnitDefenderFirstStrike() {\n     final UnitType canNotTargetType = mock(UnitType.class);\n     final Tuple<Unit, UnitAttachment> unitAndAttachment = newUnitAndAttachment();", "originalCommit": "5b9d5dc50a130745ca9a064a75686efafb903de9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMjMzNg==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436422336", "bodyText": "Any thoughts to simplify this helper method from:\ngivenUnitCanNotBeTargetedBy(mock(UnitType.class))\n\nTo:\ngivenUnitCanNotBeTargetedByAnyUnit();\n\nOr am I misunder", "author": "DanVanAtta", "createdAt": "2020-06-08T01:24:09Z", "path": "game-core/src/test/java/games/strategy/triplea/delegate/battle/steps/fire/air/AirAttackVsNonSubsStepTest.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package games.strategy.triplea.delegate.battle.steps.fire.air;\n+\n+import static games.strategy.triplea.delegate.battle.MockBattleState.givenBattleState;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnit;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitCanNotBeTargetedBy;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitDestroyer;\n+import static games.strategy.triplea.delegate.battle.steps.BattleStepsTest.givenUnitIsAir;\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.hasSize;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+\n+import games.strategy.engine.data.Unit;\n+import games.strategy.engine.data.UnitType;\n+import games.strategy.triplea.delegate.battle.BattleState;\n+import java.util.List;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.MethodSource;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+@ExtendWith(MockitoExtension.class)\n+class AirAttackVsNonSubsStepTest {\n+\n+  @ParameterizedTest(name = \"[{index}] {0} is {2}\")\n+  @MethodSource\n+  void testWhatIsValid(\n+      final String displayName, final BattleState battleState, final boolean expected) {\n+    final AirAttackVsNonSubsStep underTest = new AirAttackVsNonSubsStep(battleState);\n+    assertThat(underTest.valid(), is(expected));\n+    if (expected) {\n+      assertThat(underTest.getNames(), hasSize(1));\n+    } else {\n+      assertThat(underTest.getNames(), hasSize(0));\n+    }\n+  }\n+\n+  static List<Arguments> testWhatIsValid() {\n+    return List.of(\n+        Arguments.of(\n+            \"Attacker has air units and no destroyers vs Defender subs\",\n+            givenBattleState()\n+                .attackingUnits(List.of(givenUnit(), givenUnitIsAir()))\n+                .defendingUnits(List.of(givenUnitCanNotBeTargetedBy(mock(UnitType.class))))", "originalCommit": "5b9d5dc50a130745ca9a064a75686efafb903de9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQzMzUxOQ==", "url": "https://github.com/triplea-game/triplea/pull/6593#discussion_r436433519", "bodyText": "I'm renaming it to givenUnitCanNotBeTargetedByRandomUnit().", "author": "trevan", "createdAt": "2020-06-08T02:40:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjQyMjMzNg=="}], "type": "inlineReview"}, {"oid": "1486ccbc8b5e6ef19853e0a71bc18b9bd640e029", "url": "https://github.com/triplea-game/triplea/commit/1486ccbc8b5e6ef19853e0a71bc18b9bd640e029", "message": "Rename and minor tweaks per review requests", "committedDate": "2020-06-08T03:10:37Z", "type": "commit"}, {"oid": "a100ea14808b490a68cc38bca12fe74dc8f5ee2e", "url": "https://github.com/triplea-game/triplea/commit/a100ea14808b490a68cc38bca12fe74dc8f5ee2e", "message": "Move the comment of the empty method into the method to calm Codacy", "committedDate": "2020-06-08T03:20:45Z", "type": "commit"}]}