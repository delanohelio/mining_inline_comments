{"pr_number": 6671, "pr_title": "Cleanup: Use interface type instead of concrete type", "pr_createdAt": "2020-06-10T05:34:30Z", "pr_url": "https://github.com/triplea-game/triplea/pull/6671", "timeline": [{"oid": "6cc7c09d81f96a189a8182ca1d21ebfc80869f1f", "url": "https://github.com/triplea-game/triplea/commit/6cc7c09d81f96a189a8182ca1d21ebfc80869f1f", "message": "Cleanup: Use interface type instead of concrete type\n\nResolves codacy code style warning:\n> Avoid using implementation types like 'LinkedHashMap'; use the interface instead\n\nSecond, minor simplificaton in MoveBatcherTest to unnecessary list wrapping.", "committedDate": "2020-06-10T05:32:43Z", "type": "commit"}, {"oid": "56e4d7a51e6326d28bf843bee6713b7b7e8e65c9", "url": "https://github.com/triplea-game/triplea/commit/56e4d7a51e6326d28bf843bee6713b7b7e8e65c9", "message": "Fix missing update", "committedDate": "2020-06-11T00:14:05Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczNjM1Ng==", "url": "https://github.com/triplea-game/triplea/pull/6671#discussion_r439736356", "bodyText": "Note: One of the reasons for choosing ArrayList as params when I wrote this method is because it relies on the List being efficient at random access (i.e. passing a LinkedList would make this highly inefficient).\nIf we don't want to express such concepts in function signatures, should we make a project rule that LinkedList or more generally lists that don't implement RandomAccess should never be used? Otherwise, loosening signatures loses the extra type checking at compile time that a mistake isn't made.\nWe could add a runtime check for instanceof RandomAccess, but that's strictly worse than a compile check (extra overhead, error has to be found at runtime, etc).\nThere's not much reason to use LinkedList so I am OK if we want to take the stance that it just shouldn't be used.", "author": "asvitkine", "createdAt": "2020-06-13T12:41:08Z", "path": "game-core/src/main/java/games/strategy/triplea/ai/pro/util/MoveBatcher.java", "diffHunk": "@@ -82,7 +82,7 @@ private void addMove(final MoveDescription newMove) {\n    * @param sequences The sequences to try to merge into the sequence.\n    */\n   private static void mergeSequences(\n-      final ArrayList<MoveDescription> sequence, final List<ArrayList<MoveDescription>> sequences) {\n+      final List<MoveDescription> sequence, final List<List<MoveDescription>> sequences) {\n     for (final var otherSequence : sequences) {\n       boolean merge = (otherSequence.size() == sequence.size());\n       for (int i = 0; merge && i < sequence.size(); i++) {", "originalCommit": "56e4d7a51e6326d28bf843bee6713b7b7e8e65c9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDU2NDM4OQ==", "url": "https://github.com/triplea-game/triplea/pull/6671#discussion_r440564389", "bodyText": "The conventional style in Java for better or worse is to use interface types for collections and to strongly avoid implementation types. This is even a default rule in Codacy:\n\nAvoid using implementation types like 'LinkedHashMap'; use the interface instead\n\nI suspect such a static check exists in other static analysis tools and that Codacy is not alone.\nIn practice, if you use a more generic interface type, you can avoid needless collection copies. For example, if someone specifies a list all the time, even when not needed and a collection would do, then if you have a set, then you in a position where you needless need to copy the set elements into a list. From a practical perspective, this is the most significant, overly specific implementation types can cause headaches for the API clients and even result in unnecessary data copying.\nFor example, if someone specified a linked list, and you needed to convert from an array list. The performance gain of a linked list will probably be mooted if every time you have to create a data copy to get the right data type. In general, if you need random access, then use a List, otherwise a Collection. It's up to the data type that is being stored to then define uniqueness whether you use a Set or a List (or if the implementation will be wrong if there are duplicate elements, then a Set interface is appropriate).\nIf a method truly needs a specific implementation type, then it probably should be that method that does the data copy to the more efficient data type rather than leaving it to the caller. The name of the game is to provide flexible and easy to use APIs and to avoid others from having to read implementation code. IE: they can \"just use\" the method and not worry about surprising side-effects or other implementation details.\nTo another extent, and in practice, keeping types loose allows for different data structures to more easily be used. If everything is a collection, then the specific data type is only defined when you instantiate it. In which case you have freedom to choose whatever type you want, a change from a List to a Set is a change of a single word. Sometimes that avoids having to touch code in dozens or hundreds of places to reduce unnecessary typing.\nFrom a theoretical perspective, one should code to an API, not an implementation.\nFrom yet another perspsective, performance changes should only be done on clean and tested code that is then measured before and after any performance tweak. It should also be done in context of the overall performance so you avoid optimizing something that is only responsible for 10% of the total performance (instead focus on the 90%). For example, if the list only ever 100 elements large, iterating over it 1000 times with O(n) access vs O(1) will likely be a difference of nano-seconds. One should choose appropriate data structures, but focus on simple code that for examples avoids calling a method an extra 10 times because it is simple and you can see that the 10 subsequent calls are not needed.\nIn TripleA, we have a call to get default casualty selection, which does a call to get unit power stats (the heavy part to compute supports), but we actually only cache results for one of those calls. If we could simplify that code so that the results were re-used instead of recomputed a second time with caching, we'd have faster code with less memory and would correct cases where we fail to invalidate the cache.\nLast point, it's conventional to use HashMap, HashSet, and ArrayList. Using any other implementation generally needs a special case. And again, if it's really important for a method, that method should measure performance and convert to the needed data structure.\nThe above is admittedly not a direct answer, but in the end using concrete types is not conventional and generally unnecesssary, and can cause harm either from an API usage point of view or from requiring excessive burden on the clients of API.", "author": "DanVanAtta", "createdAt": "2020-06-16T03:27:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTczNjM1Ng=="}], "type": "inlineReview"}, {"oid": "2529ba1f332a1aad0f16c9fa7665d6a1cf60808e", "url": "https://github.com/triplea-game/triplea/commit/2529ba1f332a1aad0f16c9fa7665d6a1cf60808e", "message": "Merge remote-tracking branch 'origin/master' into generics", "committedDate": "2020-06-16T03:30:17Z", "type": "commit"}]}