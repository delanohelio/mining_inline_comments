{"pr_number": 773, "pr_title": "Split nodes plugin enhancement - Split nodes into same level", "pr_createdAt": "2020-08-11T07:24:59Z", "pr_url": "https://github.com/constellation-app/constellation/pull/773", "timeline": [{"oid": "efa00638c7ed7e4510fd6d58f5b63a641f99749d", "url": "https://github.com/constellation-app/constellation/commit/efa00638c7ed7e4510fd6d58f5b63a641f99749d", "message": "Split node plugin split into same level\n\n(cherry picked from commit a5143e217e2be06300506f4a33b2d40add021c3b)", "committedDate": "2020-08-11T06:35:21Z", "type": "commit"}, {"oid": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4", "url": "https://github.com/constellation-app/constellation/commit/5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4", "message": "Fix code smells", "committedDate": "2020-08-11T07:56:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDMwMzAyMw==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470303023", "bodyText": "A minor spelling typo, should be \"Copying\"", "author": "arcturus2", "createdAt": "2020-08-13T23:29:39Z", "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);\n+\n+            if (vertexAttributeName.equals(VisualConcept.VertexAttribute.IDENTIFIER.getName())) {\n+                graph.setStringValue(vertexIdentifierAttributeId, newVertexId, newNodeIdentifier);\n+            } else if ((VisualConcept.VertexAttribute.X.getName()).equals(vertexAttributeName)) {\n+                //The X coordinate is skipped so that the second node is not created in the exact same location\n+                //as the first node. Copiying the Y & Z for a better arrangement as it looks less cluttered.", "originalCommit": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5NzU2Ng==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470397566", "bodyText": "I'm wondering if there is a better name and description for this? I'm not sure whether this makes sense to a user without already knowing what it does. I can't think of anything off the top of my head though", "author": "antares1470", "createdAt": "2020-08-14T04:02:12Z", "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -94,6 +95,12 @@ public PluginParameters createParameters() {\n         split.setStringValue(null);\n         params.addParameter(split);\n \n+        final PluginParameter<BooleanParameterValue> splitIntoSameLevelParameter = BooleanParameterType.build(SPLIT_INTO_SAME_LEVEL_PARAMETER_ID);\n+        splitIntoSameLevelParameter.setName(\"Split Nodes into same level\");\n+        splitIntoSameLevelParameter.setDescription(\"Choose to split Nodes hanging off from the same parent node rather than from one of the new nodes\");", "originalCommit": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQxNTExOQ==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470415119", "bodyText": "Agree, but I couldn't think of anything better either.", "author": "Auriga2", "createdAt": "2020-08-14T05:18:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5NzU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg3MjI2NQ==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r471872265", "bodyText": "I've looked over the code and still can't understand what this is supposed to be doing - could you explain it?", "author": "cygnus-x-1", "createdAt": "2020-08-18T02:09:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5NzU2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjIyOTc4Mw==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r472229783", "bodyText": "@cygnus-x-1 have you looked at the actual ticket #743. There are images too!", "author": "arcturus2", "createdAt": "2020-08-18T14:14:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5NzU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5ODEyOA==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470398128", "bodyText": "these 3 can be made final", "author": "antares1470", "createdAt": "2020-08-14T04:04:37Z", "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);", "originalCommit": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5ODI4Mw==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470398283", "bodyText": "final", "author": "antares1470", "createdAt": "2020-08-14T04:05:16Z", "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();", "originalCommit": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5ODYzMg==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470398632", "bodyText": "these 2 can be final", "author": "antares1470", "createdAt": "2020-08-14T04:06:40Z", "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);", "originalCommit": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5OTE3OQ==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470399179", "bodyText": "if directed can't ever be true, it's probably better to remove this variable and just simply add false into the relevant function calls. That's just my personal opinion though", "author": "antares1470", "createdAt": "2020-08-14T04:08:54Z", "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);\n+\n+            if (vertexAttributeName.equals(VisualConcept.VertexAttribute.IDENTIFIER.getName())) {\n+                graph.setStringValue(vertexIdentifierAttributeId, newVertexId, newNodeIdentifier);\n+            } else if ((VisualConcept.VertexAttribute.X.getName()).equals(vertexAttributeName)) {\n+                //The X coordinate is skipped so that the second node is not created in the exact same location\n+                //as the first node. Copiying the Y & Z for a better arrangement as it looks less cluttered.\n             } else {\n-                result.set(GraphRecordStoreUtilities.DESTINATION + key.replace(GraphRecordStoreUtilities.SOURCE, \"\"), query.get(key));\n+                graph.getNativeAttributeType(vertexAttributeId).copyAttributeValue(graph, vertexAttributeId, selectedNode, newVertexId);\n             }\n         }\n \n-        if (ordered_types.size() > 1 && rightVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.DESTINATION + AnalyticConcept.VertexAttribute.TYPE, rightVertexTypesMatches.get(0));\n+        // Transactions\n+        final boolean directed = false;", "originalCommit": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQyNDkyOQ==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470424929", "bodyText": "Whatever the value added here will be overwritten when copying the attributes. Just wanted a default value here. I vaguely remember Sanarqube throwing a code smell  when I added \"false\" like value in few lines without using a variable.", "author": "Auriga2", "createdAt": "2020-08-14T05:55:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5OTE3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE3NDAzMQ==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r471174031", "bodyText": "@Auriga2 Ok I think I understand what you are doing here.\nSo what you have done works, but it's not optimal. The directed parameter of addTransaction() is actually the direction under the hood (e.g. Graph.UPHILL, Graph.UNDIRECTED) and not the value of the directed transaction attribute. Copying the value of the transaction parameter works because when you complete schema, the function checks for a mismatch in transaction attribute value vs under the hood value (e.g. transaction attribute is true but the under the hood value is Graph.UNDIRECTED) and creates a copy of the transaction with the correct under the hood value (removing the old one) if a mismatch exists. This means that with what you currently have, any directed transactions you are copying are effectively being created twice (once by your function and once on complete schema).\nI would suggest then grabbing the value of the directed attribute beforehand and passing that value in to addTransaction() to ensure the transaction only gets added once", "author": "antares1470", "createdAt": "2020-08-16T23:39:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5OTE3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc2MDY2Ng==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r472760666", "bodyText": "@antares1470  I don't quite get it. If it's Graph.UPHILL, Graph.UNDIRECTED etc, and not true or false, then it's still the same thing when I grab and use the directed attribute (which is true or false) when creating transaction.", "author": "Auriga2", "createdAt": "2020-08-19T06:35:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5OTE3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3Mjc2NDM3MA==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r472764370", "bodyText": "I don't get the relation of this boolean to the GraphConstants.", "author": "Auriga2", "createdAt": "2020-08-19T06:39:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5OTE3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzU0NTQwNg==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r473545406", "bodyText": "@Auriga2 so when you add a transaction, the directed parameter determines the under-the-hood direction. The value of the directed transaction attribute is then determined from this under-the-hood value. The main issue is that this under-the-hood value can't actually be changed on a transaction (and so changing the value of the directed transaction attribute after the fact doesn't actually change this value). Consequently when you do change the directed transaction value, a new transaction needs to created with the correct under-the-hood value. This is the relevant code in completeTransaction() in AnalyticSchema that does that:\nfinal Boolean directed = graph.getBooleanValue(transactionDirectedAttribute, transactionId);\nfinal boolean transactionIsDirected = graph.getTransactionDirection(transactionId) != Graph.FLAT;\nif (directed != transactionIsDirected) {\n   <code to create clone of transaction>\n}\n\nWhat this means is that when adding a transaction, it's better to pass through the right value for the directed parameter rather than leaving it to completeSchema to fix it after the fact.\nDoes that make sense?", "author": "antares1470", "createdAt": "2020-08-20T02:22:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5OTE3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzY3MDMzMA==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r473670330", "bodyText": "It makes sense to provide the correct value beforehand, and verified that it does no longer attempt to remove and add the transactions again by the above code.", "author": "Auriga2", "createdAt": "2020-08-20T07:00:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5OTE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5OTMyMg==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470399322", "bodyText": "final", "author": "antares1470", "createdAt": "2020-08-14T04:09:29Z", "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);\n+\n+            if (vertexAttributeName.equals(VisualConcept.VertexAttribute.IDENTIFIER.getName())) {\n+                graph.setStringValue(vertexIdentifierAttributeId, newVertexId, newNodeIdentifier);\n+            } else if ((VisualConcept.VertexAttribute.X.getName()).equals(vertexAttributeName)) {\n+                //The X coordinate is skipped so that the second node is not created in the exact same location\n+                //as the first node. Copiying the Y & Z for a better arrangement as it looks less cluttered.\n             } else {\n-                result.set(GraphRecordStoreUtilities.DESTINATION + key.replace(GraphRecordStoreUtilities.SOURCE, \"\"), query.get(key));\n+                graph.getNativeAttributeType(vertexAttributeId).copyAttributeValue(graph, vertexAttributeId, selectedNode, newVertexId);\n             }\n         }\n \n-        if (ordered_types.size() > 1 && rightVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.DESTINATION + AnalyticConcept.VertexAttribute.TYPE, rightVertexTypesMatches.get(0));\n+        // Transactions\n+        final boolean directed = false;\n+        if (splitIntoSameLevel) {\n+            int transactionCount = graph.getVertexTransactionCount(selectedNode);", "originalCommit": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5OTQ0Nw==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470399447", "bodyText": "these 3 can be final", "author": "antares1470", "createdAt": "2020-08-14T04:10:03Z", "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);\n+\n+            if (vertexAttributeName.equals(VisualConcept.VertexAttribute.IDENTIFIER.getName())) {\n+                graph.setStringValue(vertexIdentifierAttributeId, newVertexId, newNodeIdentifier);\n+            } else if ((VisualConcept.VertexAttribute.X.getName()).equals(vertexAttributeName)) {\n+                //The X coordinate is skipped so that the second node is not created in the exact same location\n+                //as the first node. Copiying the Y & Z for a better arrangement as it looks less cluttered.\n             } else {\n-                result.set(GraphRecordStoreUtilities.DESTINATION + key.replace(GraphRecordStoreUtilities.SOURCE, \"\"), query.get(key));\n+                graph.getNativeAttributeType(vertexAttributeId).copyAttributeValue(graph, vertexAttributeId, selectedNode, newVertexId);\n             }\n         }\n \n-        if (ordered_types.size() > 1 && rightVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.DESTINATION + AnalyticConcept.VertexAttribute.TYPE, rightVertexTypesMatches.get(0));\n+        // Transactions\n+        final boolean directed = false;\n+        if (splitIntoSameLevel) {\n+            int transactionCount = graph.getVertexTransactionCount(selectedNode);\n+            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n+                int originalTransactionId = graph.getVertexTransaction(selectedNode, transactionPosition);\n+\n+                int sourceVertex = graph.getTransactionSourceVertex(originalTransactionId);\n+                int destinationVertex = graph.getTransactionDestinationVertex(originalTransactionId);", "originalCommit": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5OTU4NQ==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470399585", "bodyText": "final", "author": "antares1470", "createdAt": "2020-08-14T04:10:36Z", "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);\n+\n+            if (vertexAttributeName.equals(VisualConcept.VertexAttribute.IDENTIFIER.getName())) {\n+                graph.setStringValue(vertexIdentifierAttributeId, newVertexId, newNodeIdentifier);\n+            } else if ((VisualConcept.VertexAttribute.X.getName()).equals(vertexAttributeName)) {\n+                //The X coordinate is skipped so that the second node is not created in the exact same location\n+                //as the first node. Copiying the Y & Z for a better arrangement as it looks less cluttered.\n             } else {\n-                result.set(GraphRecordStoreUtilities.DESTINATION + key.replace(GraphRecordStoreUtilities.SOURCE, \"\"), query.get(key));\n+                graph.getNativeAttributeType(vertexAttributeId).copyAttributeValue(graph, vertexAttributeId, selectedNode, newVertexId);\n             }\n         }\n \n-        if (ordered_types.size() > 1 && rightVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.DESTINATION + AnalyticConcept.VertexAttribute.TYPE, rightVertexTypesMatches.get(0));\n+        // Transactions\n+        final boolean directed = false;\n+        if (splitIntoSameLevel) {\n+            int transactionCount = graph.getVertexTransactionCount(selectedNode);\n+            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n+                int originalTransactionId = graph.getVertexTransaction(selectedNode, transactionPosition);\n+\n+                int sourceVertex = graph.getTransactionSourceVertex(originalTransactionId);\n+                int destinationVertex = graph.getTransactionDestinationVertex(originalTransactionId);\n+                int newTransactionId = 0;\n+                if (sourceVertex == selectedNode && destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, newVertexId, directed);\n+                } else if (sourceVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, destinationVertex, directed);\n+                } else if (destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(sourceVertex, newVertexId, directed);\n+                }\n+\n+                //Loops through all the transaction attributes and copies them to the new transaction\n+                int transactionAttributeCount = graph.getAttributeCount(GraphElementType.TRANSACTION);", "originalCommit": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5OTYyNw==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470399627", "bodyText": "these 2 can be final", "author": "antares1470", "createdAt": "2020-08-14T04:10:48Z", "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);\n+\n+            if (vertexAttributeName.equals(VisualConcept.VertexAttribute.IDENTIFIER.getName())) {\n+                graph.setStringValue(vertexIdentifierAttributeId, newVertexId, newNodeIdentifier);\n+            } else if ((VisualConcept.VertexAttribute.X.getName()).equals(vertexAttributeName)) {\n+                //The X coordinate is skipped so that the second node is not created in the exact same location\n+                //as the first node. Copiying the Y & Z for a better arrangement as it looks less cluttered.\n             } else {\n-                result.set(GraphRecordStoreUtilities.DESTINATION + key.replace(GraphRecordStoreUtilities.SOURCE, \"\"), query.get(key));\n+                graph.getNativeAttributeType(vertexAttributeId).copyAttributeValue(graph, vertexAttributeId, selectedNode, newVertexId);\n             }\n         }\n \n-        if (ordered_types.size() > 1 && rightVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.DESTINATION + AnalyticConcept.VertexAttribute.TYPE, rightVertexTypesMatches.get(0));\n+        // Transactions\n+        final boolean directed = false;\n+        if (splitIntoSameLevel) {\n+            int transactionCount = graph.getVertexTransactionCount(selectedNode);\n+            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n+                int originalTransactionId = graph.getVertexTransaction(selectedNode, transactionPosition);\n+\n+                int sourceVertex = graph.getTransactionSourceVertex(originalTransactionId);\n+                int destinationVertex = graph.getTransactionDestinationVertex(originalTransactionId);\n+                int newTransactionId = 0;\n+                if (sourceVertex == selectedNode && destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, newVertexId, directed);\n+                } else if (sourceVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, destinationVertex, directed);\n+                } else if (destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(sourceVertex, newVertexId, directed);\n+                }\n+\n+                //Loops through all the transaction attributes and copies them to the new transaction\n+                int transactionAttributeCount = graph.getAttributeCount(GraphElementType.TRANSACTION);\n+                for (int transactionAttributePosition = 0; transactionAttributePosition < transactionAttributeCount; transactionAttributePosition++) {\n+                    int transactionAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, transactionAttributePosition);\n+                    String transactionAttributeName = graph.getAttributeName(transactionAttributeId);", "originalCommit": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5OTY3Mw==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470399673", "bodyText": "final", "author": "antares1470", "createdAt": "2020-08-14T04:10:59Z", "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);\n+\n+            if (vertexAttributeName.equals(VisualConcept.VertexAttribute.IDENTIFIER.getName())) {\n+                graph.setStringValue(vertexIdentifierAttributeId, newVertexId, newNodeIdentifier);\n+            } else if ((VisualConcept.VertexAttribute.X.getName()).equals(vertexAttributeName)) {\n+                //The X coordinate is skipped so that the second node is not created in the exact same location\n+                //as the first node. Copiying the Y & Z for a better arrangement as it looks less cluttered.\n             } else {\n-                result.set(GraphRecordStoreUtilities.DESTINATION + key.replace(GraphRecordStoreUtilities.SOURCE, \"\"), query.get(key));\n+                graph.getNativeAttributeType(vertexAttributeId).copyAttributeValue(graph, vertexAttributeId, selectedNode, newVertexId);\n             }\n         }\n \n-        if (ordered_types.size() > 1 && rightVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.DESTINATION + AnalyticConcept.VertexAttribute.TYPE, rightVertexTypesMatches.get(0));\n+        // Transactions\n+        final boolean directed = false;\n+        if (splitIntoSameLevel) {\n+            int transactionCount = graph.getVertexTransactionCount(selectedNode);\n+            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n+                int originalTransactionId = graph.getVertexTransaction(selectedNode, transactionPosition);\n+\n+                int sourceVertex = graph.getTransactionSourceVertex(originalTransactionId);\n+                int destinationVertex = graph.getTransactionDestinationVertex(originalTransactionId);\n+                int newTransactionId = 0;\n+                if (sourceVertex == selectedNode && destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, newVertexId, directed);\n+                } else if (sourceVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, destinationVertex, directed);\n+                } else if (destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(sourceVertex, newVertexId, directed);\n+                }\n+\n+                //Loops through all the transaction attributes and copies them to the new transaction\n+                int transactionAttributeCount = graph.getAttributeCount(GraphElementType.TRANSACTION);\n+                for (int transactionAttributePosition = 0; transactionAttributePosition < transactionAttributeCount; transactionAttributePosition++) {\n+                    int transactionAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, transactionAttributePosition);\n+                    String transactionAttributeName = graph.getAttributeName(transactionAttributeId);\n+                    if (transactionAttributeName.equals(VisualConcept.TransactionAttribute.IDENTIFIER.getName())) {\n+                        graph.setStringValue(transactionAttributeId, newTransactionId, Integer.toString(newTransactionId));\n+                    } else {\n+                        graph.getNativeAttributeType(transactionAttributeId).copyAttributeValue(graph, transactionAttributeId, originalTransactionId, newTransactionId);\n+                    }\n+                }\n+            }\n+        } else {\n+            //Add a transaction of the type 'linkType' between the selected node and new node\n+            int newTransactionId = graph.addTransaction(selectedNode, newVertexId, directed);", "originalCommit": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5OTc4NA==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470399784", "bodyText": "these 3 can be final", "author": "antares1470", "createdAt": "2020-08-14T04:11:38Z", "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);\n+\n+            if (vertexAttributeName.equals(VisualConcept.VertexAttribute.IDENTIFIER.getName())) {\n+                graph.setStringValue(vertexIdentifierAttributeId, newVertexId, newNodeIdentifier);\n+            } else if ((VisualConcept.VertexAttribute.X.getName()).equals(vertexAttributeName)) {\n+                //The X coordinate is skipped so that the second node is not created in the exact same location\n+                //as the first node. Copiying the Y & Z for a better arrangement as it looks less cluttered.\n             } else {\n-                result.set(GraphRecordStoreUtilities.DESTINATION + key.replace(GraphRecordStoreUtilities.SOURCE, \"\"), query.get(key));\n+                graph.getNativeAttributeType(vertexAttributeId).copyAttributeValue(graph, vertexAttributeId, selectedNode, newVertexId);\n             }\n         }\n \n-        if (ordered_types.size() > 1 && rightVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.DESTINATION + AnalyticConcept.VertexAttribute.TYPE, rightVertexTypesMatches.get(0));\n+        // Transactions\n+        final boolean directed = false;\n+        if (splitIntoSameLevel) {\n+            int transactionCount = graph.getVertexTransactionCount(selectedNode);\n+            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n+                int originalTransactionId = graph.getVertexTransaction(selectedNode, transactionPosition);\n+\n+                int sourceVertex = graph.getTransactionSourceVertex(originalTransactionId);\n+                int destinationVertex = graph.getTransactionDestinationVertex(originalTransactionId);\n+                int newTransactionId = 0;\n+                if (sourceVertex == selectedNode && destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, newVertexId, directed);\n+                } else if (sourceVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, destinationVertex, directed);\n+                } else if (destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(sourceVertex, newVertexId, directed);\n+                }\n+\n+                //Loops through all the transaction attributes and copies them to the new transaction\n+                int transactionAttributeCount = graph.getAttributeCount(GraphElementType.TRANSACTION);\n+                for (int transactionAttributePosition = 0; transactionAttributePosition < transactionAttributeCount; transactionAttributePosition++) {\n+                    int transactionAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, transactionAttributePosition);\n+                    String transactionAttributeName = graph.getAttributeName(transactionAttributeId);\n+                    if (transactionAttributeName.equals(VisualConcept.TransactionAttribute.IDENTIFIER.getName())) {\n+                        graph.setStringValue(transactionAttributeId, newTransactionId, Integer.toString(newTransactionId));\n+                    } else {\n+                        graph.getNativeAttributeType(transactionAttributeId).copyAttributeValue(graph, transactionAttributeId, originalTransactionId, newTransactionId);\n+                    }\n+                }\n+            }\n+        } else {\n+            //Add a transaction of the type 'linkType' between the selected node and new node\n+            int newTransactionId = graph.addTransaction(selectedNode, newVertexId, directed);\n+            graph.setStringValue(transactionTypeAttributeId, newTransactionId, linkType);\n         }\n-        result.set(GraphRecordStoreUtilities.TRANSACTION + AnalyticConcept.TransactionAttribute.TYPE, linkType);\n+        return newVertexId;\n     }\n \n     @Override\n-    protected RecordStore query(final RecordStore query, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final RecordStore result = new GraphRecordStore();\n-\n+    public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException, PluginException {\n         final Map<String, PluginParameter<?>> splitParameters = parameters.getParameters();\n         final String character = splitParameters.get(SPLIT_PARAMETER_ID) != null && splitParameters.get(SPLIT_PARAMETER_ID).getStringValue() != null ? splitParameters.get(SPLIT_PARAMETER_ID).getStringValue() : \"\";\n         final ParameterValue transactionTypeChoice = splitParameters.get(TRANSACTION_TYPE_PARAMETER_ID).getSingleChoice();\n         final String linkType = transactionTypeChoice != null ? transactionTypeChoice.toString() : AnalyticConcept.TransactionType.CORRELATION.getName();\n         final boolean allOccurrences = splitParameters.get(ALL_OCCURRENCES_PARAMETER_ID).getBooleanValue();\n+        final boolean splitIntoSameLevel = splitParameters.get(SPLIT_INTO_SAME_LEVEL_PARAMETER_ID).getBooleanValue();\n+\n+        int vertexSelectedAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.SELECTED.getName());\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        List<Integer> newVertices = new ArrayList<>();", "originalCommit": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDM5OTkwMQ==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470399901", "bodyText": "final", "author": "antares1470", "createdAt": "2020-08-14T04:12:05Z", "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);\n+\n+            if (vertexAttributeName.equals(VisualConcept.VertexAttribute.IDENTIFIER.getName())) {\n+                graph.setStringValue(vertexIdentifierAttributeId, newVertexId, newNodeIdentifier);\n+            } else if ((VisualConcept.VertexAttribute.X.getName()).equals(vertexAttributeName)) {\n+                //The X coordinate is skipped so that the second node is not created in the exact same location\n+                //as the first node. Copiying the Y & Z for a better arrangement as it looks less cluttered.\n             } else {\n-                result.set(GraphRecordStoreUtilities.DESTINATION + key.replace(GraphRecordStoreUtilities.SOURCE, \"\"), query.get(key));\n+                graph.getNativeAttributeType(vertexAttributeId).copyAttributeValue(graph, vertexAttributeId, selectedNode, newVertexId);\n             }\n         }\n \n-        if (ordered_types.size() > 1 && rightVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.DESTINATION + AnalyticConcept.VertexAttribute.TYPE, rightVertexTypesMatches.get(0));\n+        // Transactions\n+        final boolean directed = false;\n+        if (splitIntoSameLevel) {\n+            int transactionCount = graph.getVertexTransactionCount(selectedNode);\n+            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n+                int originalTransactionId = graph.getVertexTransaction(selectedNode, transactionPosition);\n+\n+                int sourceVertex = graph.getTransactionSourceVertex(originalTransactionId);\n+                int destinationVertex = graph.getTransactionDestinationVertex(originalTransactionId);\n+                int newTransactionId = 0;\n+                if (sourceVertex == selectedNode && destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, newVertexId, directed);\n+                } else if (sourceVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, destinationVertex, directed);\n+                } else if (destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(sourceVertex, newVertexId, directed);\n+                }\n+\n+                //Loops through all the transaction attributes and copies them to the new transaction\n+                int transactionAttributeCount = graph.getAttributeCount(GraphElementType.TRANSACTION);\n+                for (int transactionAttributePosition = 0; transactionAttributePosition < transactionAttributeCount; transactionAttributePosition++) {\n+                    int transactionAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, transactionAttributePosition);\n+                    String transactionAttributeName = graph.getAttributeName(transactionAttributeId);\n+                    if (transactionAttributeName.equals(VisualConcept.TransactionAttribute.IDENTIFIER.getName())) {\n+                        graph.setStringValue(transactionAttributeId, newTransactionId, Integer.toString(newTransactionId));\n+                    } else {\n+                        graph.getNativeAttributeType(transactionAttributeId).copyAttributeValue(graph, transactionAttributeId, originalTransactionId, newTransactionId);\n+                    }\n+                }\n+            }\n+        } else {\n+            //Add a transaction of the type 'linkType' between the selected node and new node\n+            int newTransactionId = graph.addTransaction(selectedNode, newVertexId, directed);\n+            graph.setStringValue(transactionTypeAttributeId, newTransactionId, linkType);\n         }\n-        result.set(GraphRecordStoreUtilities.TRANSACTION + AnalyticConcept.TransactionAttribute.TYPE, linkType);\n+        return newVertexId;\n     }\n \n     @Override\n-    protected RecordStore query(final RecordStore query, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final RecordStore result = new GraphRecordStore();\n-\n+    public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException, PluginException {\n         final Map<String, PluginParameter<?>> splitParameters = parameters.getParameters();\n         final String character = splitParameters.get(SPLIT_PARAMETER_ID) != null && splitParameters.get(SPLIT_PARAMETER_ID).getStringValue() != null ? splitParameters.get(SPLIT_PARAMETER_ID).getStringValue() : \"\";\n         final ParameterValue transactionTypeChoice = splitParameters.get(TRANSACTION_TYPE_PARAMETER_ID).getSingleChoice();\n         final String linkType = transactionTypeChoice != null ? transactionTypeChoice.toString() : AnalyticConcept.TransactionType.CORRELATION.getName();\n         final boolean allOccurrences = splitParameters.get(ALL_OCCURRENCES_PARAMETER_ID).getBooleanValue();\n+        final boolean splitIntoSameLevel = splitParameters.get(SPLIT_INTO_SAME_LEVEL_PARAMETER_ID).getBooleanValue();\n+\n+        int vertexSelectedAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.SELECTED.getName());\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        List<Integer> newVertices = new ArrayList<>();\n+\n+        final int graphVertexCount = graph.getVertexCount();\n+        for (int position = 0; position < graphVertexCount; position++) {\n+            int currentVertexId = graph.getVertex(position);", "originalCommit": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDQwMDQ2NQ==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r470400465", "bodyText": "given the use of substrings, I would probably just leave it as an array rather than converting it to a list", "author": "antares1470", "createdAt": "2020-08-14T04:14:26Z", "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);\n+\n+            if (vertexAttributeName.equals(VisualConcept.VertexAttribute.IDENTIFIER.getName())) {\n+                graph.setStringValue(vertexIdentifierAttributeId, newVertexId, newNodeIdentifier);\n+            } else if ((VisualConcept.VertexAttribute.X.getName()).equals(vertexAttributeName)) {\n+                //The X coordinate is skipped so that the second node is not created in the exact same location\n+                //as the first node. Copiying the Y & Z for a better arrangement as it looks less cluttered.\n             } else {\n-                result.set(GraphRecordStoreUtilities.DESTINATION + key.replace(GraphRecordStoreUtilities.SOURCE, \"\"), query.get(key));\n+                graph.getNativeAttributeType(vertexAttributeId).copyAttributeValue(graph, vertexAttributeId, selectedNode, newVertexId);\n             }\n         }\n \n-        if (ordered_types.size() > 1 && rightVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.DESTINATION + AnalyticConcept.VertexAttribute.TYPE, rightVertexTypesMatches.get(0));\n+        // Transactions\n+        final boolean directed = false;\n+        if (splitIntoSameLevel) {\n+            int transactionCount = graph.getVertexTransactionCount(selectedNode);\n+            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n+                int originalTransactionId = graph.getVertexTransaction(selectedNode, transactionPosition);\n+\n+                int sourceVertex = graph.getTransactionSourceVertex(originalTransactionId);\n+                int destinationVertex = graph.getTransactionDestinationVertex(originalTransactionId);\n+                int newTransactionId = 0;\n+                if (sourceVertex == selectedNode && destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, newVertexId, directed);\n+                } else if (sourceVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, destinationVertex, directed);\n+                } else if (destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(sourceVertex, newVertexId, directed);\n+                }\n+\n+                //Loops through all the transaction attributes and copies them to the new transaction\n+                int transactionAttributeCount = graph.getAttributeCount(GraphElementType.TRANSACTION);\n+                for (int transactionAttributePosition = 0; transactionAttributePosition < transactionAttributeCount; transactionAttributePosition++) {\n+                    int transactionAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, transactionAttributePosition);\n+                    String transactionAttributeName = graph.getAttributeName(transactionAttributeId);\n+                    if (transactionAttributeName.equals(VisualConcept.TransactionAttribute.IDENTIFIER.getName())) {\n+                        graph.setStringValue(transactionAttributeId, newTransactionId, Integer.toString(newTransactionId));\n+                    } else {\n+                        graph.getNativeAttributeType(transactionAttributeId).copyAttributeValue(graph, transactionAttributeId, originalTransactionId, newTransactionId);\n+                    }\n+                }\n+            }\n+        } else {\n+            //Add a transaction of the type 'linkType' between the selected node and new node\n+            int newTransactionId = graph.addTransaction(selectedNode, newVertexId, directed);\n+            graph.setStringValue(transactionTypeAttributeId, newTransactionId, linkType);\n         }\n-        result.set(GraphRecordStoreUtilities.TRANSACTION + AnalyticConcept.TransactionAttribute.TYPE, linkType);\n+        return newVertexId;\n     }\n \n     @Override\n-    protected RecordStore query(final RecordStore query, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final RecordStore result = new GraphRecordStore();\n-\n+    public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException, PluginException {\n         final Map<String, PluginParameter<?>> splitParameters = parameters.getParameters();\n         final String character = splitParameters.get(SPLIT_PARAMETER_ID) != null && splitParameters.get(SPLIT_PARAMETER_ID).getStringValue() != null ? splitParameters.get(SPLIT_PARAMETER_ID).getStringValue() : \"\";\n         final ParameterValue transactionTypeChoice = splitParameters.get(TRANSACTION_TYPE_PARAMETER_ID).getSingleChoice();\n         final String linkType = transactionTypeChoice != null ? transactionTypeChoice.toString() : AnalyticConcept.TransactionType.CORRELATION.getName();\n         final boolean allOccurrences = splitParameters.get(ALL_OCCURRENCES_PARAMETER_ID).getBooleanValue();\n+        final boolean splitIntoSameLevel = splitParameters.get(SPLIT_INTO_SAME_LEVEL_PARAMETER_ID).getBooleanValue();\n+\n+        int vertexSelectedAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.SELECTED.getName());\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        List<Integer> newVertices = new ArrayList<>();\n+\n+        final int graphVertexCount = graph.getVertexCount();\n+        for (int position = 0; position < graphVertexCount; position++) {\n+            int currentVertexId = graph.getVertex(position);\n+\n+            if (graph.getBooleanValue(vertexSelectedAttributeId, currentVertexId)) {\n+                final String identifier = graph.getStringValue(vertexIdentifierAttributeId, currentVertexId);\n+\n+                if (identifier != null && identifier.contains(character) && identifier.indexOf(character) < identifier.length() - character.length()) {\n+                    String leftNodeIdentifier = \"\";\n+                    if (allOccurrences) {\n+                        final List<String> substrings = new ArrayList<>(Arrays.asList(identifier.split(character)));", "originalCommit": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2NDk1OQ==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r471864959", "bodyText": "This should probably be a SimpleEditPlugin as it's not performing a query.", "author": "cygnus-x-1", "createdAt": "2020-08-18T01:40:54Z", "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -60,12 +63,10 @@\n     @ServiceProvider(service = DataAccessPlugin.class),\n     @ServiceProvider(service = Plugin.class)})\n @NbBundle.Messages(\"SplitNodesPlugin=Split Nodes Based on Identifier\")\n-public class SplitNodesPlugin extends RecordStoreQueryPlugin implements DataAccessPlugin {\n-\n-    private static final String SOURCE_ID = GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID;\n-    private static final String SOURCE_IDENTIFIER = GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER;\n+public class SplitNodesPlugin extends SimpleQueryPlugin implements DataAccessPlugin {", "originalCommit": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2Nzk2MA==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r471867960", "bodyText": "RecordStoreQueryPlugin has this as an in-built feature - perhaps that could be moved down the stack to SimpleEditPlugin (the first plugin type which can edit a graph) so that it doesn't need to be implemented per plugin?", "author": "cygnus-x-1", "createdAt": "2020-08-18T01:52:44Z", "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);\n+\n+            if (vertexAttributeName.equals(VisualConcept.VertexAttribute.IDENTIFIER.getName())) {\n+                graph.setStringValue(vertexIdentifierAttributeId, newVertexId, newNodeIdentifier);\n+            } else if ((VisualConcept.VertexAttribute.X.getName()).equals(vertexAttributeName)) {\n+                //The X coordinate is skipped so that the second node is not created in the exact same location\n+                //as the first node. Copiying the Y & Z for a better arrangement as it looks less cluttered.\n             } else {\n-                result.set(GraphRecordStoreUtilities.DESTINATION + key.replace(GraphRecordStoreUtilities.SOURCE, \"\"), query.get(key));\n+                graph.getNativeAttributeType(vertexAttributeId).copyAttributeValue(graph, vertexAttributeId, selectedNode, newVertexId);\n             }\n         }\n \n-        if (ordered_types.size() > 1 && rightVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.DESTINATION + AnalyticConcept.VertexAttribute.TYPE, rightVertexTypesMatches.get(0));\n+        // Transactions\n+        final boolean directed = false;\n+        if (splitIntoSameLevel) {\n+            int transactionCount = graph.getVertexTransactionCount(selectedNode);\n+            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n+                int originalTransactionId = graph.getVertexTransaction(selectedNode, transactionPosition);\n+\n+                int sourceVertex = graph.getTransactionSourceVertex(originalTransactionId);\n+                int destinationVertex = graph.getTransactionDestinationVertex(originalTransactionId);\n+                int newTransactionId = 0;\n+                if (sourceVertex == selectedNode && destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, newVertexId, directed);\n+                } else if (sourceVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, destinationVertex, directed);\n+                } else if (destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(sourceVertex, newVertexId, directed);\n+                }\n+\n+                //Loops through all the transaction attributes and copies them to the new transaction\n+                int transactionAttributeCount = graph.getAttributeCount(GraphElementType.TRANSACTION);\n+                for (int transactionAttributePosition = 0; transactionAttributePosition < transactionAttributeCount; transactionAttributePosition++) {\n+                    int transactionAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, transactionAttributePosition);\n+                    String transactionAttributeName = graph.getAttributeName(transactionAttributeId);\n+                    if (transactionAttributeName.equals(VisualConcept.TransactionAttribute.IDENTIFIER.getName())) {\n+                        graph.setStringValue(transactionAttributeId, newTransactionId, Integer.toString(newTransactionId));\n+                    } else {\n+                        graph.getNativeAttributeType(transactionAttributeId).copyAttributeValue(graph, transactionAttributeId, originalTransactionId, newTransactionId);\n+                    }\n+                }\n+            }\n+        } else {\n+            //Add a transaction of the type 'linkType' between the selected node and new node\n+            int newTransactionId = graph.addTransaction(selectedNode, newVertexId, directed);\n+            graph.setStringValue(transactionTypeAttributeId, newTransactionId, linkType);\n         }\n-        result.set(GraphRecordStoreUtilities.TRANSACTION + AnalyticConcept.TransactionAttribute.TYPE, linkType);\n+        return newVertexId;\n     }\n \n     @Override\n-    protected RecordStore query(final RecordStore query, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final RecordStore result = new GraphRecordStore();\n-\n+    public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException, PluginException {\n         final Map<String, PluginParameter<?>> splitParameters = parameters.getParameters();\n         final String character = splitParameters.get(SPLIT_PARAMETER_ID) != null && splitParameters.get(SPLIT_PARAMETER_ID).getStringValue() != null ? splitParameters.get(SPLIT_PARAMETER_ID).getStringValue() : \"\";\n         final ParameterValue transactionTypeChoice = splitParameters.get(TRANSACTION_TYPE_PARAMETER_ID).getSingleChoice();\n         final String linkType = transactionTypeChoice != null ? transactionTypeChoice.toString() : AnalyticConcept.TransactionType.CORRELATION.getName();\n         final boolean allOccurrences = splitParameters.get(ALL_OCCURRENCES_PARAMETER_ID).getBooleanValue();\n+        final boolean splitIntoSameLevel = splitParameters.get(SPLIT_INTO_SAME_LEVEL_PARAMETER_ID).getBooleanValue();\n+\n+        int vertexSelectedAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.SELECTED.getName());\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        List<Integer> newVertices = new ArrayList<>();\n+\n+        final int graphVertexCount = graph.getVertexCount();\n+        for (int position = 0; position < graphVertexCount; position++) {\n+            int currentVertexId = graph.getVertex(position);\n+\n+            if (graph.getBooleanValue(vertexSelectedAttributeId, currentVertexId)) {\n+                final String identifier = graph.getStringValue(vertexIdentifierAttributeId, currentVertexId);\n+\n+                if (identifier != null && identifier.contains(character) && identifier.indexOf(character) < identifier.length() - character.length()) {\n+                    String leftNodeIdentifier = \"\";\n+                    if (allOccurrences) {\n+                        final List<String> substrings = new ArrayList<>(Arrays.asList(identifier.split(character)));\n+                        leftNodeIdentifier = substrings.get(0);\n+                        for (int i = 1; i < substrings.size(); i++) {\n+                            newVertices.add(createNewNode(graph, position, substrings.get(i), linkType, splitIntoSameLevel));\n+                        }\n \n-        query.reset();\n-        while (query.next()) {\n-            final String identifier = query.get(SOURCE_IDENTIFIER);\n-            if (identifier != null && identifier.contains(character) && identifier.indexOf(character) < identifier.length() - character.length()) {\n-                if (allOccurrences) {\n-                    final List<String> substrings = new ArrayList<>(Arrays.asList(identifier.split(character)));\n-                    final String left = substrings.get(0);\n-                    for (int i = 1; i < substrings.size(); i++) {\n-                        final String right = substrings.get(i);\n-                        editResultStore(result, left, right, query, linkType);\n+                    } else {\n+                        final int i = identifier.indexOf(character);\n+                        leftNodeIdentifier = identifier.substring(0, i);\n+                        newVertices.add(createNewNode(graph, position, identifier.substring(i + 1), linkType, splitIntoSameLevel));\n                     }\n-                } else {\n-                    final int i = identifier.indexOf(character);\n-                    final String left = identifier.substring(0, i);\n-                    final String right = identifier.substring(i + 1);\n-                    editResultStore(result, left, right, query, linkType);\n+                    // Rename the selected node\n+                    graph.setStringValue(vertexIdentifierAttributeId, currentVertexId, leftNodeIdentifier);\n                 }\n             }\n         }\n+        if (!newVertices.isEmpty()) {\n+            // Reset the view\n+            graph.validateKey(GraphElementType.VERTEX, true);\n+            graph.validateKey(GraphElementType.TRANSACTION, true);\n \n-        return result;\n+            final PluginExecutor arrangement = completionArrangement();\n+            if (arrangement != null) {\n+                // run the arrangement\n+                final VertexListInclusionGraph vlGraph = new VertexListInclusionGraph(graph, AbstractInclusionGraph.Connections.NONE, newVertices);\n+                arrangement.executeNow(vlGraph.getInclusionGraph());\n+                vlGraph.retrieveCoords();\n+            }\n+\n+            PluginExecution.withPlugin(VisualSchemaPluginRegistry.COMPLETE_SCHEMA).executeNow(graph);\n+            PluginExecutor.startWith(InteractiveGraphPluginRegistry.RESET_VIEW).executeNow(graph);\n+        }\n     }\n+\n+    public PluginExecutor completionArrangement() {", "originalCommit": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzUxNzg0OQ==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r473517849", "bodyText": "@cygnus-x-1 : I tried to move completionArrangement() into the SimpleEditPlugin but addding the Core Arrangement Plugins there throws this warning. RecordStoreQueryPlugin  is different as it's in Core Data Access View module.", "author": "Auriga2", "createdAt": "2020-08-20T01:39:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2Nzk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2OTQ5Mw==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r471869493", "bodyText": "This happens automatically on commit - so unless you're trying to catch it early for custom exception handling, this seems unnecessary.", "author": "cygnus-x-1", "createdAt": "2020-08-18T01:58:51Z", "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/plugins/clean/SplitNodesPlugin.java", "diffHunk": "@@ -130,82 +144,132 @@ public void updateParameters(Graph graph, PluginParameters parameters) {\n                 SingleChoiceParameterType.setChoice(transactionType, AnalyticConcept.TransactionType.CORRELATION.getName());\n             }\n             transactionType.suppressEvent(false, new ArrayList<>());\n+\n         }\n     }\n \n-    private void editResultStore(final RecordStore result, final String left, final String right, final RecordStore query, final String linkType) {\n-        final HashMap<SchemaVertexType, String> types = new HashMap<>();\n-        final List<SchemaVertexType> leftVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(left));\n-        leftVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-        final List<SchemaVertexType> rightVertexTypesMatches = new ArrayList<>(SchemaVertexTypeUtilities.matchVertexTypes(right));\n-        rightVertexTypesMatches.sort((Comparator<? super SchemaVertexType>) VertexDominanceCalculator.getDefault().getComparator());\n-\n-        if (leftVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(left).get(0), left);\n-        }\n-        if (rightVertexTypesMatches.size() > 0) {\n-            types.put(SchemaVertexTypeUtilities.matchVertexTypes(right).get(0), right);\n-        }\n-        final List<SchemaVertexType> ordered_types = new ArrayList<>(types.keySet());\n+    private int createNewNode(final GraphWriteMethods graph, final int selectedNode, final String newNodeIdentifier, final String linkType, final boolean splitIntoSameLevel) {\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        int transactionTypeAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, AnalyticConcept.TransactionAttribute.TYPE.getName());\n+        int vertexAttributeCount = graph.getAttributeCount(GraphElementType.VERTEX);\n \n-        result.add();\n-        result.set(GraphRecordStoreUtilities.SOURCE + GraphRecordStoreUtilities.ID, query.get(SOURCE_ID));\n-        result.set(GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.IDENTIFIER, left);\n-        if (ordered_types.size() > 0 && leftVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.SOURCE + AnalyticConcept.VertexAttribute.TYPE, leftVertexTypesMatches.get(0));\n-        }\n-        result.set(GraphRecordStoreUtilities.DESTINATION + VisualConcept.VertexAttribute.IDENTIFIER, right);\n+        // Add new node\n+        int newVertexId = graph.addVertex();\n \n         //Loops through all of the Node attributes and copies them to the new node\n-        for (final String key : query.keys()) {\n-            if (key.endsWith(\".[id]\") || SOURCE_IDENTIFIER.equals(key)) {\n-                //Skips the id and Identifier to make the new node unique\n-            } else if ((GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.X).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Y).equals(key)\n-                    || (GraphRecordStoreUtilities.SOURCE + VisualConcept.VertexAttribute.Z).equals(key)) {\n-                //The coordinates are also skipped so that the second node is not created in the exact same location\n-                //as the first node\n+        for (int vertexAttributePosition = 0; vertexAttributePosition < vertexAttributeCount; vertexAttributePosition++) {\n+            int vertexAttributeId = graph.getAttribute(GraphElementType.VERTEX, vertexAttributePosition);\n+            String vertexAttributeName = graph.getAttributeName(vertexAttributeId);\n+\n+            if (vertexAttributeName.equals(VisualConcept.VertexAttribute.IDENTIFIER.getName())) {\n+                graph.setStringValue(vertexIdentifierAttributeId, newVertexId, newNodeIdentifier);\n+            } else if ((VisualConcept.VertexAttribute.X.getName()).equals(vertexAttributeName)) {\n+                //The X coordinate is skipped so that the second node is not created in the exact same location\n+                //as the first node. Copiying the Y & Z for a better arrangement as it looks less cluttered.\n             } else {\n-                result.set(GraphRecordStoreUtilities.DESTINATION + key.replace(GraphRecordStoreUtilities.SOURCE, \"\"), query.get(key));\n+                graph.getNativeAttributeType(vertexAttributeId).copyAttributeValue(graph, vertexAttributeId, selectedNode, newVertexId);\n             }\n         }\n \n-        if (ordered_types.size() > 1 && rightVertexTypesMatches.size() > 0) {\n-            result.set(GraphRecordStoreUtilities.DESTINATION + AnalyticConcept.VertexAttribute.TYPE, rightVertexTypesMatches.get(0));\n+        // Transactions\n+        final boolean directed = false;\n+        if (splitIntoSameLevel) {\n+            int transactionCount = graph.getVertexTransactionCount(selectedNode);\n+            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n+                int originalTransactionId = graph.getVertexTransaction(selectedNode, transactionPosition);\n+\n+                int sourceVertex = graph.getTransactionSourceVertex(originalTransactionId);\n+                int destinationVertex = graph.getTransactionDestinationVertex(originalTransactionId);\n+                int newTransactionId = 0;\n+                if (sourceVertex == selectedNode && destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, newVertexId, directed);\n+                } else if (sourceVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(newVertexId, destinationVertex, directed);\n+                } else if (destinationVertex == selectedNode) {\n+                    newTransactionId = graph.addTransaction(sourceVertex, newVertexId, directed);\n+                }\n+\n+                //Loops through all the transaction attributes and copies them to the new transaction\n+                int transactionAttributeCount = graph.getAttributeCount(GraphElementType.TRANSACTION);\n+                for (int transactionAttributePosition = 0; transactionAttributePosition < transactionAttributeCount; transactionAttributePosition++) {\n+                    int transactionAttributeId = graph.getAttribute(GraphElementType.TRANSACTION, transactionAttributePosition);\n+                    String transactionAttributeName = graph.getAttributeName(transactionAttributeId);\n+                    if (transactionAttributeName.equals(VisualConcept.TransactionAttribute.IDENTIFIER.getName())) {\n+                        graph.setStringValue(transactionAttributeId, newTransactionId, Integer.toString(newTransactionId));\n+                    } else {\n+                        graph.getNativeAttributeType(transactionAttributeId).copyAttributeValue(graph, transactionAttributeId, originalTransactionId, newTransactionId);\n+                    }\n+                }\n+            }\n+        } else {\n+            //Add a transaction of the type 'linkType' between the selected node and new node\n+            int newTransactionId = graph.addTransaction(selectedNode, newVertexId, directed);\n+            graph.setStringValue(transactionTypeAttributeId, newTransactionId, linkType);\n         }\n-        result.set(GraphRecordStoreUtilities.TRANSACTION + AnalyticConcept.TransactionAttribute.TYPE, linkType);\n+        return newVertexId;\n     }\n \n     @Override\n-    protected RecordStore query(final RecordStore query, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final RecordStore result = new GraphRecordStore();\n-\n+    public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException, PluginException {\n         final Map<String, PluginParameter<?>> splitParameters = parameters.getParameters();\n         final String character = splitParameters.get(SPLIT_PARAMETER_ID) != null && splitParameters.get(SPLIT_PARAMETER_ID).getStringValue() != null ? splitParameters.get(SPLIT_PARAMETER_ID).getStringValue() : \"\";\n         final ParameterValue transactionTypeChoice = splitParameters.get(TRANSACTION_TYPE_PARAMETER_ID).getSingleChoice();\n         final String linkType = transactionTypeChoice != null ? transactionTypeChoice.toString() : AnalyticConcept.TransactionType.CORRELATION.getName();\n         final boolean allOccurrences = splitParameters.get(ALL_OCCURRENCES_PARAMETER_ID).getBooleanValue();\n+        final boolean splitIntoSameLevel = splitParameters.get(SPLIT_INTO_SAME_LEVEL_PARAMETER_ID).getBooleanValue();\n+\n+        int vertexSelectedAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.SELECTED.getName());\n+        int vertexIdentifierAttributeId = graph.getAttribute(GraphElementType.VERTEX, VisualConcept.VertexAttribute.IDENTIFIER.getName());\n+        List<Integer> newVertices = new ArrayList<>();\n+\n+        final int graphVertexCount = graph.getVertexCount();\n+        for (int position = 0; position < graphVertexCount; position++) {\n+            int currentVertexId = graph.getVertex(position);\n+\n+            if (graph.getBooleanValue(vertexSelectedAttributeId, currentVertexId)) {\n+                final String identifier = graph.getStringValue(vertexIdentifierAttributeId, currentVertexId);\n+\n+                if (identifier != null && identifier.contains(character) && identifier.indexOf(character) < identifier.length() - character.length()) {\n+                    String leftNodeIdentifier = \"\";\n+                    if (allOccurrences) {\n+                        final List<String> substrings = new ArrayList<>(Arrays.asList(identifier.split(character)));\n+                        leftNodeIdentifier = substrings.get(0);\n+                        for (int i = 1; i < substrings.size(); i++) {\n+                            newVertices.add(createNewNode(graph, position, substrings.get(i), linkType, splitIntoSameLevel));\n+                        }\n \n-        query.reset();\n-        while (query.next()) {\n-            final String identifier = query.get(SOURCE_IDENTIFIER);\n-            if (identifier != null && identifier.contains(character) && identifier.indexOf(character) < identifier.length() - character.length()) {\n-                if (allOccurrences) {\n-                    final List<String> substrings = new ArrayList<>(Arrays.asList(identifier.split(character)));\n-                    final String left = substrings.get(0);\n-                    for (int i = 1; i < substrings.size(); i++) {\n-                        final String right = substrings.get(i);\n-                        editResultStore(result, left, right, query, linkType);\n+                    } else {\n+                        final int i = identifier.indexOf(character);\n+                        leftNodeIdentifier = identifier.substring(0, i);\n+                        newVertices.add(createNewNode(graph, position, identifier.substring(i + 1), linkType, splitIntoSameLevel));\n                     }\n-                } else {\n-                    final int i = identifier.indexOf(character);\n-                    final String left = identifier.substring(0, i);\n-                    final String right = identifier.substring(i + 1);\n-                    editResultStore(result, left, right, query, linkType);\n+                    // Rename the selected node\n+                    graph.setStringValue(vertexIdentifierAttributeId, currentVertexId, leftNodeIdentifier);\n                 }\n             }\n         }\n+        if (!newVertices.isEmpty()) {", "originalCommit": "5ba8dd7c5ee2c42d7bf0e01d3d0d47cf175dbef4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MjcxMzI3MQ==", "url": "https://github.com/constellation-app/constellation/pull/773#discussion_r472713271", "bodyText": "Added it to avoid resetting the view when there's no matching node to split. I can remove it if you think it's okay to just flicker the graph sometimes.", "author": "Auriga2", "createdAt": "2020-08-19T05:26:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTg2OTQ5Mw=="}], "type": "inlineReview"}, {"oid": "d8ff89050f896cbeee40b6e484a2be144294ef64", "url": "https://github.com/constellation-app/constellation/commit/d8ff89050f896cbeee40b6e484a2be144294ef64", "message": "Improvements", "committedDate": "2020-08-25T05:47:08Z", "type": "commit"}, {"oid": "bc1df858d86f6a22cdb1f15cfd639d14c4ca33de", "url": "https://github.com/constellation-app/constellation/commit/bc1df858d86f6a22cdb1f15cfd639d14c4ca33de", "message": "More improvements.", "committedDate": "2020-08-28T06:47:06Z", "type": "commit"}, {"oid": "21546c7c4eadfb41a465180df48c302ac89dd02e", "url": "https://github.com/constellation-app/constellation/commit/21546c7c4eadfb41a465180df48c302ac89dd02e", "message": "Merge branch 'master' into feature/Split-Nodes-Plugin-Enhancement", "committedDate": "2020-08-31T03:59:34Z", "type": "commit"}, {"oid": "6fd8bf196ab6dc2a2edcf4d79c81e4580f3385f8", "url": "https://github.com/constellation-app/constellation/commit/6fd8bf196ab6dc2a2edcf4d79c81e4580f3385f8", "message": "Improve what's new text", "committedDate": "2020-08-31T04:54:15Z", "type": "commit"}]}