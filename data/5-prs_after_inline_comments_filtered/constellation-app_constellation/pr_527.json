{"pr_number": 527, "pr_title": "Add in hashmod experimental plugin.", "pr_createdAt": "2020-05-17T15:45:29Z", "pr_url": "https://github.com/constellation-app/constellation/pull/527", "timeline": [{"oid": "e0fa47703950f616526a8835b38724bc3d76edc5", "url": "https://github.com/constellation-app/constellation/commit/e0fa47703950f616526a8835b38724bc3d76edc5", "message": "Fixups from code review for hashmod", "committedDate": "2020-05-17T15:40:54Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMTU2OQ==", "url": "https://github.com/constellation-app/constellation/pull/527#discussion_r426311569", "bodyText": "Use java.util.logging.Logger instead", "author": "antares1470", "createdAt": "2020-05-17T22:23:40Z", "path": "CoreGraphUtilities/src/au/gov/asd/tac/constellation/graph/utilities/hashmod/Hashmod.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.graph.utilities.hashmod;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Level;\n+import static org.geotools.referencing.factory.ReferencingFactory.LOGGER;", "originalCommit": "e0fa47703950f616526a8835b38724bc3d76edc5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMTYzNw==", "url": "https://github.com/constellation-app/constellation/pull/527#discussion_r426311637", "bodyText": "replace data.size() > 0 with !data.isEmpty()", "author": "antares1470", "createdAt": "2020-05-17T22:24:36Z", "path": "CoreGraphUtilities/src/au/gov/asd/tac/constellation/graph/utilities/hashmod/Hashmod.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.graph.utilities.hashmod;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Level;\n+import static org.geotools.referencing.factory.ReferencingFactory.LOGGER;\n+\n+/**\n+ * A text hashmod based on a supplied CSV file. Will modify attributes specified\n+ * in the headers to be values based on the first Key column.\n+ *\n+ * @author CrucisGamma\n+ */\n+public class Hashmod {\n+\n+    public static final String ATTRIBUTE_NAME = \"hashmod\";\n+    private HashmodCSVImportFileParser parser;\n+    private String csvFileStr;\n+    private List<String[]> data;\n+\n+    public Hashmod() {\n+        parser = null;\n+        csvFileStr = \"\";\n+    }\n+\n+    /**\n+     * Create a new Hashmod.\n+     *\n+     * @param csvFile Name of the CSV file the user has chosen\n+     */\n+    public Hashmod(final String csvFileStr) {\n+        if (csvFileStr == null) {\n+            this.csvFileStr = \"\";\n+        } else {\n+            this.csvFileStr = csvFileStr;\n+        }\n+\n+        parser = new HashmodCSVImportFileParser();\n+        try {\n+            data = parser.parse(new HashmodInputSource(new File(csvFileStr)), null);\n+        } catch (IOException ex) {\n+            LOGGER.log(Level.SEVERE, ex.getLocalizedMessage(), ex);\n+        }\n+    }\n+\n+    public void setCSVFileStr(final String csvFileStr) {\n+        this.csvFileStr = csvFileStr;\n+        parser = new HashmodCSVImportFileParser();\n+        try {\n+            data = parser.parse(new HashmodInputSource(new File(csvFileStr)), null);\n+        } catch (IOException ex) {\n+            LOGGER.log(Level.SEVERE, ex.getLocalizedMessage(), ex);\n+        }\n+    }\n+\n+    public String[] getCSVFileHeaders() {\n+        if (data != null && data.size() > 0) {", "originalCommit": "e0fa47703950f616526a8835b38724bc3d76edc5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMTc5MA==", "url": "https://github.com/constellation-app/constellation/pull/527#discussion_r426311790", "bodyText": "replace data.size() > 0 with !data.isEmpty()", "author": "antares1470", "createdAt": "2020-05-17T22:26:03Z", "path": "CoreGraphUtilities/src/au/gov/asd/tac/constellation/graph/utilities/hashmod/Hashmod.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.graph.utilities.hashmod;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Level;\n+import static org.geotools.referencing.factory.ReferencingFactory.LOGGER;\n+\n+/**\n+ * A text hashmod based on a supplied CSV file. Will modify attributes specified\n+ * in the headers to be values based on the first Key column.\n+ *\n+ * @author CrucisGamma\n+ */\n+public class Hashmod {\n+\n+    public static final String ATTRIBUTE_NAME = \"hashmod\";\n+    private HashmodCSVImportFileParser parser;\n+    private String csvFileStr;\n+    private List<String[]> data;\n+\n+    public Hashmod() {\n+        parser = null;\n+        csvFileStr = \"\";\n+    }\n+\n+    /**\n+     * Create a new Hashmod.\n+     *\n+     * @param csvFile Name of the CSV file the user has chosen\n+     */\n+    public Hashmod(final String csvFileStr) {\n+        if (csvFileStr == null) {\n+            this.csvFileStr = \"\";\n+        } else {\n+            this.csvFileStr = csvFileStr;\n+        }\n+\n+        parser = new HashmodCSVImportFileParser();\n+        try {\n+            data = parser.parse(new HashmodInputSource(new File(csvFileStr)), null);\n+        } catch (IOException ex) {\n+            LOGGER.log(Level.SEVERE, ex.getLocalizedMessage(), ex);\n+        }\n+    }\n+\n+    public void setCSVFileStr(final String csvFileStr) {\n+        this.csvFileStr = csvFileStr;\n+        parser = new HashmodCSVImportFileParser();\n+        try {\n+            data = parser.parse(new HashmodInputSource(new File(csvFileStr)), null);\n+        } catch (IOException ex) {\n+            LOGGER.log(Level.SEVERE, ex.getLocalizedMessage(), ex);\n+        }\n+    }\n+\n+    public String[] getCSVFileHeaders() {\n+        if (data != null && data.size() > 0) {\n+            return data.get(0);\n+        }\n+        return null;\n+    }\n+\n+    public String[] getCSVRow(final int row) {\n+        if (data != null && data.size() > row) {\n+            return data.get(row);\n+        }\n+        return null;\n+    }\n+\n+    public String getCSVKey() {\n+        final String[] headers = getCSVFileHeaders();\n+        if (headers != null && headers.length > 0) {\n+            if (headers.length > 0) {\n+                return headers[0];\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public HashMap<String, Integer> getCSVKeys() {\n+        final HashMap<String, Integer> keys = new HashMap<>();\n+        if (data != null && data.size() > 0) {", "originalCommit": "e0fa47703950f616526a8835b38724bc3d76edc5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMTgwNg==", "url": "https://github.com/constellation-app/constellation/pull/527#discussion_r426311806", "bodyText": "replace data.size() > 0 with !data.isEmpty()", "author": "antares1470", "createdAt": "2020-05-17T22:26:19Z", "path": "CoreGraphUtilities/src/au/gov/asd/tac/constellation/graph/utilities/hashmod/Hashmod.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.graph.utilities.hashmod;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Level;\n+import static org.geotools.referencing.factory.ReferencingFactory.LOGGER;\n+\n+/**\n+ * A text hashmod based on a supplied CSV file. Will modify attributes specified\n+ * in the headers to be values based on the first Key column.\n+ *\n+ * @author CrucisGamma\n+ */\n+public class Hashmod {\n+\n+    public static final String ATTRIBUTE_NAME = \"hashmod\";\n+    private HashmodCSVImportFileParser parser;\n+    private String csvFileStr;\n+    private List<String[]> data;\n+\n+    public Hashmod() {\n+        parser = null;\n+        csvFileStr = \"\";\n+    }\n+\n+    /**\n+     * Create a new Hashmod.\n+     *\n+     * @param csvFile Name of the CSV file the user has chosen\n+     */\n+    public Hashmod(final String csvFileStr) {\n+        if (csvFileStr == null) {\n+            this.csvFileStr = \"\";\n+        } else {\n+            this.csvFileStr = csvFileStr;\n+        }\n+\n+        parser = new HashmodCSVImportFileParser();\n+        try {\n+            data = parser.parse(new HashmodInputSource(new File(csvFileStr)), null);\n+        } catch (IOException ex) {\n+            LOGGER.log(Level.SEVERE, ex.getLocalizedMessage(), ex);\n+        }\n+    }\n+\n+    public void setCSVFileStr(final String csvFileStr) {\n+        this.csvFileStr = csvFileStr;\n+        parser = new HashmodCSVImportFileParser();\n+        try {\n+            data = parser.parse(new HashmodInputSource(new File(csvFileStr)), null);\n+        } catch (IOException ex) {\n+            LOGGER.log(Level.SEVERE, ex.getLocalizedMessage(), ex);\n+        }\n+    }\n+\n+    public String[] getCSVFileHeaders() {\n+        if (data != null && data.size() > 0) {\n+            return data.get(0);\n+        }\n+        return null;\n+    }\n+\n+    public String[] getCSVRow(final int row) {\n+        if (data != null && data.size() > row) {\n+            return data.get(row);\n+        }\n+        return null;\n+    }\n+\n+    public String getCSVKey() {\n+        final String[] headers = getCSVFileHeaders();\n+        if (headers != null && headers.length > 0) {\n+            if (headers.length > 0) {\n+                return headers[0];\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public HashMap<String, Integer> getCSVKeys() {\n+        final HashMap<String, Integer> keys = new HashMap<>();\n+        if (data != null && data.size() > 0) {\n+            for (int i = 1; i < data.size(); i++) {\n+                final String[] row = getCSVRow(i);\n+                if (row[0] != null) {\n+                    keys.put(row[0].toUpperCase(), 0);\n+                }\n+            }\n+        }\n+        return keys;\n+    }\n+\n+    public int getNumberCSVColumns() {\n+        final String[] headers = getCSVFileHeaders();\n+        if (headers != null) {\n+            return headers.length;\n+        }\n+        return 0;\n+    }\n+\n+    public String getCSVHeader(final int col) {\n+        final String[] headers = getCSVFileHeaders();\n+        if (headers != null && headers.length > col) {\n+            return headers[col];\n+        }\n+        return null;\n+    }\n+\n+    public List<String[]> getCSVFileData() {\n+        if (data != null && data.size() > 0) {", "originalCommit": "e0fa47703950f616526a8835b38724bc3d76edc5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMTgxOQ==", "url": "https://github.com/constellation-app/constellation/pull/527#discussion_r426311819", "bodyText": "replace data.size() > 0 with !data.isEmpty()", "author": "antares1470", "createdAt": "2020-05-17T22:26:28Z", "path": "CoreGraphUtilities/src/au/gov/asd/tac/constellation/graph/utilities/hashmod/Hashmod.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.graph.utilities.hashmod;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Level;\n+import static org.geotools.referencing.factory.ReferencingFactory.LOGGER;\n+\n+/**\n+ * A text hashmod based on a supplied CSV file. Will modify attributes specified\n+ * in the headers to be values based on the first Key column.\n+ *\n+ * @author CrucisGamma\n+ */\n+public class Hashmod {\n+\n+    public static final String ATTRIBUTE_NAME = \"hashmod\";\n+    private HashmodCSVImportFileParser parser;\n+    private String csvFileStr;\n+    private List<String[]> data;\n+\n+    public Hashmod() {\n+        parser = null;\n+        csvFileStr = \"\";\n+    }\n+\n+    /**\n+     * Create a new Hashmod.\n+     *\n+     * @param csvFile Name of the CSV file the user has chosen\n+     */\n+    public Hashmod(final String csvFileStr) {\n+        if (csvFileStr == null) {\n+            this.csvFileStr = \"\";\n+        } else {\n+            this.csvFileStr = csvFileStr;\n+        }\n+\n+        parser = new HashmodCSVImportFileParser();\n+        try {\n+            data = parser.parse(new HashmodInputSource(new File(csvFileStr)), null);\n+        } catch (IOException ex) {\n+            LOGGER.log(Level.SEVERE, ex.getLocalizedMessage(), ex);\n+        }\n+    }\n+\n+    public void setCSVFileStr(final String csvFileStr) {\n+        this.csvFileStr = csvFileStr;\n+        parser = new HashmodCSVImportFileParser();\n+        try {\n+            data = parser.parse(new HashmodInputSource(new File(csvFileStr)), null);\n+        } catch (IOException ex) {\n+            LOGGER.log(Level.SEVERE, ex.getLocalizedMessage(), ex);\n+        }\n+    }\n+\n+    public String[] getCSVFileHeaders() {\n+        if (data != null && data.size() > 0) {\n+            return data.get(0);\n+        }\n+        return null;\n+    }\n+\n+    public String[] getCSVRow(final int row) {\n+        if (data != null && data.size() > row) {\n+            return data.get(row);\n+        }\n+        return null;\n+    }\n+\n+    public String getCSVKey() {\n+        final String[] headers = getCSVFileHeaders();\n+        if (headers != null && headers.length > 0) {\n+            if (headers.length > 0) {\n+                return headers[0];\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public HashMap<String, Integer> getCSVKeys() {\n+        final HashMap<String, Integer> keys = new HashMap<>();\n+        if (data != null && data.size() > 0) {\n+            for (int i = 1; i < data.size(); i++) {\n+                final String[] row = getCSVRow(i);\n+                if (row[0] != null) {\n+                    keys.put(row[0].toUpperCase(), 0);\n+                }\n+            }\n+        }\n+        return keys;\n+    }\n+\n+    public int getNumberCSVColumns() {\n+        final String[] headers = getCSVFileHeaders();\n+        if (headers != null) {\n+            return headers.length;\n+        }\n+        return 0;\n+    }\n+\n+    public String getCSVHeader(final int col) {\n+        final String[] headers = getCSVFileHeaders();\n+        if (headers != null && headers.length > col) {\n+            return headers[col];\n+        }\n+        return null;\n+    }\n+\n+    public List<String[]> getCSVFileData() {\n+        if (data != null && data.size() > 0) {\n+            return data;\n+        }\n+        return null;\n+    }\n+\n+    public String getValueFromKey(final String key, final int value) {\n+        if (data != null && data.size() > 0) {", "originalCommit": "e0fa47703950f616526a8835b38724bc3d76edc5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjMxMTgyNg==", "url": "https://github.com/constellation-app/constellation/pull/527#discussion_r426311826", "bodyText": "replace data.size() > 0 with !data.isEmpty()", "author": "antares1470", "createdAt": "2020-05-17T22:26:43Z", "path": "CoreGraphUtilities/src/au/gov/asd/tac/constellation/graph/utilities/hashmod/Hashmod.java", "diffHunk": "@@ -0,0 +1,166 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.graph.utilities.hashmod;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.logging.Level;\n+import static org.geotools.referencing.factory.ReferencingFactory.LOGGER;\n+\n+/**\n+ * A text hashmod based on a supplied CSV file. Will modify attributes specified\n+ * in the headers to be values based on the first Key column.\n+ *\n+ * @author CrucisGamma\n+ */\n+public class Hashmod {\n+\n+    public static final String ATTRIBUTE_NAME = \"hashmod\";\n+    private HashmodCSVImportFileParser parser;\n+    private String csvFileStr;\n+    private List<String[]> data;\n+\n+    public Hashmod() {\n+        parser = null;\n+        csvFileStr = \"\";\n+    }\n+\n+    /**\n+     * Create a new Hashmod.\n+     *\n+     * @param csvFile Name of the CSV file the user has chosen\n+     */\n+    public Hashmod(final String csvFileStr) {\n+        if (csvFileStr == null) {\n+            this.csvFileStr = \"\";\n+        } else {\n+            this.csvFileStr = csvFileStr;\n+        }\n+\n+        parser = new HashmodCSVImportFileParser();\n+        try {\n+            data = parser.parse(new HashmodInputSource(new File(csvFileStr)), null);\n+        } catch (IOException ex) {\n+            LOGGER.log(Level.SEVERE, ex.getLocalizedMessage(), ex);\n+        }\n+    }\n+\n+    public void setCSVFileStr(final String csvFileStr) {\n+        this.csvFileStr = csvFileStr;\n+        parser = new HashmodCSVImportFileParser();\n+        try {\n+            data = parser.parse(new HashmodInputSource(new File(csvFileStr)), null);\n+        } catch (IOException ex) {\n+            LOGGER.log(Level.SEVERE, ex.getLocalizedMessage(), ex);\n+        }\n+    }\n+\n+    public String[] getCSVFileHeaders() {\n+        if (data != null && data.size() > 0) {\n+            return data.get(0);\n+        }\n+        return null;\n+    }\n+\n+    public String[] getCSVRow(final int row) {\n+        if (data != null && data.size() > row) {\n+            return data.get(row);\n+        }\n+        return null;\n+    }\n+\n+    public String getCSVKey() {\n+        final String[] headers = getCSVFileHeaders();\n+        if (headers != null && headers.length > 0) {\n+            if (headers.length > 0) {\n+                return headers[0];\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public HashMap<String, Integer> getCSVKeys() {\n+        final HashMap<String, Integer> keys = new HashMap<>();\n+        if (data != null && data.size() > 0) {\n+            for (int i = 1; i < data.size(); i++) {\n+                final String[] row = getCSVRow(i);\n+                if (row[0] != null) {\n+                    keys.put(row[0].toUpperCase(), 0);\n+                }\n+            }\n+        }\n+        return keys;\n+    }\n+\n+    public int getNumberCSVColumns() {\n+        final String[] headers = getCSVFileHeaders();\n+        if (headers != null) {\n+            return headers.length;\n+        }\n+        return 0;\n+    }\n+\n+    public String getCSVHeader(final int col) {\n+        final String[] headers = getCSVFileHeaders();\n+        if (headers != null && headers.length > col) {\n+            return headers[col];\n+        }\n+        return null;\n+    }\n+\n+    public List<String[]> getCSVFileData() {\n+        if (data != null && data.size() > 0) {\n+            return data;\n+        }\n+        return null;\n+    }\n+\n+    public String getValueFromKey(final String key, final int value) {\n+        if (data != null && data.size() > 0) {\n+            for (int i = 1; i < data.size(); i++) {\n+                final String[] row = getCSVRow(i);\n+                if (row[0].equalsIgnoreCase(key)) {\n+\n+                    if (row.length > value) {\n+                        return row[value];\n+                    }\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    public Boolean doesKeyExist(final String key) {\n+        if (key == null) {\n+            return false;\n+        }\n+        if (data != null && data.size() > 0) {", "originalCommit": "e0fa47703950f616526a8835b38724bc3d76edc5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "13b89606f20b109702c05b17ddc8bc31db05c4cc", "url": "https://github.com/constellation-app/constellation/commit/13b89606f20b109702c05b17ddc8bc31db05c4cc", "message": "Fixups from code review for hashmod", "committedDate": "2020-05-18T04:09:56Z", "type": "commit"}]}