{"pr_number": 563, "pr_title": "Quality Control View Multi-threaded", "pr_createdAt": "2020-06-04T01:17:40Z", "pr_url": "https://github.com/constellation-app/constellation/pull/563", "timeline": [{"oid": "b96c645b0ab3e5f6450da2fcf54f3b10ef1a62e3", "url": "https://github.com/constellation-app/constellation/commit/b96c645b0ab3e5f6450da2fcf54f3b10ef1a62e3", "message": "pull code into plugin", "committedDate": "2020-06-03T05:15:51Z", "type": "commit"}, {"oid": "e0d92c31e947cb0e54d0aeab9e554f35e9f24321", "url": "https://github.com/constellation-app/constellation/commit/e0d92c31e947cb0e54d0aeab9e554f35e9f24321", "message": "correct listener behaviour", "committedDate": "2020-06-03T23:16:28Z", "type": "commit"}, {"oid": "910c4b889bbe56f34ca8974f6f9318db0d6da46c", "url": "https://github.com/constellation-app/constellation/commit/910c4b889bbe56f34ca8974f6f9318db0d6da46c", "message": "Merge branch 'master' into QC-threads", "committedDate": "2020-06-04T00:34:18Z", "type": "commit"}, {"oid": "b1fe89ad3339e11d1563805644f4e39dc0183641", "url": "https://github.com/constellation-app/constellation/commit/b1fe89ad3339e11d1563805644f4e39dc0183641", "message": "format code", "committedDate": "2020-06-04T00:58:47Z", "type": "commit"}, {"oid": "538c0508f34ee5712cdb4e0896d84720d5537f31", "url": "https://github.com/constellation-app/constellation/commit/538c0508f34ee5712cdb4e0896d84720d5537f31", "message": "SQ Fix", "committedDate": "2020-06-04T04:11:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczMjYxNA==", "url": "https://github.com/constellation-app/constellation/pull/563#discussion_r435732614", "bodyText": "For some background, there is a quality score available from the data access view near the Go button. An analyst is meant to do their own checks and also double check the quality score before hitting go. The only risk here is that given the plugin runs \"later\", there is no guarantee that it will finish before the analyst decides to press Go.\nThe only advantage of this stuff running on the EDT (though obviously very bad design) is that there is less chance for this race condition to occur because Constellation would effectively lock up until the quality score was updated.\nI will test this out in anger and if you haven't done so already, I will see if there is a way to show a progress or \"thinking\" graphic to the little quality score section to let the analyst know that its not ready for you to press Go.\nHmm, thinking out aloud, perhaps the Go button could also be disabled whilst these jobs run?", "author": "arcturus2", "createdAt": "2020-06-05T07:16:34Z", "path": "CoreQualityControlView/src/au/gov/asd/tac/constellation/views/qualitycontrol/daemon/QualityControlAutoVetter.java", "diffHunk": "@@ -142,71 +148,20 @@ public void graphChanged(final GraphChangeEvent event) {\n      *\n      * @param graph The graph to vet for quality control, may be null if there\n      * is no current graph.\n-     * @return the current quality control state on the given graph.\n      */\n-    public static QualityControlState updateQualityControlState(final GraphReadMethods graph) {\n-        final List<QualityControlRule> registeredRules = new ArrayList<>();\n-        final List<Integer> vertexList = new ArrayList<>();\n-        final List<String> identifierList = new ArrayList<>();\n-        final List<SchemaVertexType> typeList = new ArrayList<>();\n-\n-        if (graph != null) {\n-            final CountDownLatch countDownLatch = new CountDownLatch(1);\n-            final Thread thread = new Thread(\"Quality Control View: Run Rule\") {\n-                @Override\n-                public void run() {\n-                    final int selectedAttribute = VisualConcept.VertexAttribute.SELECTED.get(graph);\n-                    final int identifierAttribute = VisualConcept.VertexAttribute.IDENTIFIER.get(graph);\n-                    final int typeAttribute = AnalyticConcept.VertexAttribute.TYPE.get(graph);\n-                    if (selectedAttribute != Graph.NOT_FOUND && identifierAttribute != Graph.NOT_FOUND && typeAttribute != Graph.NOT_FOUND) {\n-                        final int vxCount = graph.getVertexCount();\n-                        for (int position = 0; position < vxCount; position++) {\n-                            final int vertex = graph.getVertex(position);\n-                            final String identifier = graph.getStringValue(identifierAttribute, vertex);\n-                            final SchemaVertexType type = graph.getObjectValue(typeAttribute, vertex);\n-\n-                            final boolean selected = graph.getBooleanValue(selectedAttribute, vertex);\n-                            if (selected) {\n-                                vertexList.add(vertex);\n-                                identifierList.add(identifier);\n-                                typeList.add(type);\n-                            }\n-                        }\n-                    }\n-\n-                    // Set up and run each rule.\n-                    if (!vertexList.isEmpty()) {\n-                        for (final QualityControlRule rule : getRules()) {\n-                            rule.clearResults();\n-                            rule.executeRule(graph, vertexList);\n-                            registeredRules.add(rule);\n-                        }\n-                    }\n-\n-                    countDownLatch.countDown();\n-                }\n-            };\n-            thread.start();\n-\n-            try {\n-                countDownLatch.await();\n-            } catch (InterruptedException ex) {\n-                Exceptions.printStackTrace(ex);\n-                Thread.currentThread().interrupt();\n-            }\n-        }\n-\n-        // Build quality control events based on results of rules.\n-        // Sort by descending risk.\n-        final List<QualityControlEvent> qualityControlEvents = new ArrayList<>();\n-        for (int i = 0; i < vertexList.size(); i++) {\n-            final QualityControlEvent qualityControlEvent = new QualityControlEvent(vertexList.get(i), identifierList.get(i), typeList.get(i), Collections.unmodifiableList(registeredRules));\n-            qualityControlEvents.add(qualityControlEvent);\n+    public static void updateQualityControlState(final GraphReadMethods graph) {\n+        final Graph currentGraph = GraphManager.getDefault().getActiveGraph();\n+        Future<?> stateFuture = PluginExecution.withPlugin(new QualityControlViewStateUpdater(graph))\n+                .executeLater(currentGraph);", "originalCommit": "538c0508f34ee5712cdb4e0896d84720d5537f31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2MzM3Mw==", "url": "https://github.com/constellation-app/constellation/pull/563#discussion_r437063373", "bodyText": "I've been thinking of how to disable the Go button depending on if the scores are updating. The only solution I could come up with would be to have a static boolean variable within DAV pane. So when QCV updates the rules, the DAV would know when to change button state. This leads to one issue, I don't know how I would be able to trigger a disable or enable of the button from the static context.\nI'm all ears for ideas, as I don't think my solution will exactly work in practice.", "author": "aldebaran30701", "createdAt": "2020-06-08T23:56:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczMjYxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA3OTc0Mw==", "url": "https://github.com/constellation-app/constellation/pull/563#discussion_r437079743", "bodyText": "@aldebaran30701 How about having a static method in the DAV that you can call to enable or disable it from the QC code?", "author": "arcturus2", "createdAt": "2020-06-09T00:59:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczMjYxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4NDQ1Mg==", "url": "https://github.com/constellation-app/constellation/pull/563#discussion_r437084452", "bodyText": "That's what I was trying to explain, but I wouldn't think I would have access to the instance of the button to change it's state (enabled or disabled) because of the static context of that method.", "author": "aldebaran30701", "createdAt": "2020-06-09T01:17:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczMjYxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4NTUxNw==", "url": "https://github.com/constellation-app/constellation/pull/563#discussion_r437085517", "bodyText": "Can you try making the button static?", "author": "arcturus2", "createdAt": "2020-06-09T01:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczMjYxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA5NTU2Ng==", "url": "https://github.com/constellation-app/constellation/pull/563#discussion_r437095566", "bodyText": "I've been messing around with it but cannot get around a cyclic dependency when trying to use the static method DataAccessPane.setCanRun() - A static method which I made.\nWhen I try to access DataAccessPane from QCV AutoVetter class it makes the cyclic dependency.", "author": "aldebaran30701", "createdAt": "2020-06-09T02:01:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczMjYxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzExNTQxNg==", "url": "https://github.com/constellation-app/constellation/pull/563#discussion_r437115416", "bodyText": "Thanks for trying this out. Yeah circular dependencies is a problem and not too surprised it came up because of how the widget is embedded in the DAV.\nOne way to get around this would be to introduce a mini event driven design pattern so that you can \"fire\" and event that can tell the button to be enabled or disabled. You can fire the event from the QC code and pick it up from the DAV code without the dependency.\nThere are several places where this is being done and for an example see fireChangeEvent() in PluginParameter. Happy for you to have a go with this if you like and if you need any assistance let me know.", "author": "arcturus2", "createdAt": "2020-06-09T03:19:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczMjYxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzEzMjc0Ng==", "url": "https://github.com/constellation-app/constellation/pull/563#discussion_r437132746", "bodyText": "From memory, the DAV depends on the QCV (as it makes use of that widget) - so you can't also have the QCV depend on the DAV as that would introduce a circular dependency. What you want instead is to treat the QCV widget as a service - so it would update itself and provide information about its state for the DAV (or any other clients) to use as necessary.", "author": "cygnus-x-1", "createdAt": "2020-06-09T04:37:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczMjYxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzE0MDc1MQ==", "url": "https://github.com/constellation-app/constellation/pull/563#discussion_r437140751", "bodyText": "So from your comment @cygnus-x-1 would that mean I would change code in QCV to become a service, use the fire change event pattern @arcturus2 described, or are they the same thing?", "author": "aldebaran30701", "createdAt": "2020-06-09T05:09:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczMjYxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI0MjQ5Ng==", "url": "https://github.com/constellation-app/constellation/pull/563#discussion_r437242496", "bodyText": "I think they're essentially the same - you'd be sending a signal from the QCV that something has happened, and it would be up to the DAV to listen for that and respond.", "author": "cygnus-x-1", "createdAt": "2020-06-09T08:50:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczMjYxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzg1NjgwNg==", "url": "https://github.com/constellation-app/constellation/pull/563#discussion_r437856806", "bodyText": "I've implemented an observer to fire events and let the button update dependent on the rules running. Let me know if you notice anything. Should I be calling removeListener() at any point?", "author": "aldebaran30701", "createdAt": "2020-06-10T04:43:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczMjYxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTM0MjkyNA==", "url": "https://github.com/constellation-app/constellation/pull/563#discussion_r439342924", "bodyText": "Yes @aldebaran30701 for sure and good on you for thinking thoroughly about this part. The count of addListener's should equal the removeListener's or else that is by definition a memory leak.\nI would suggest the removeListener should run when the component is closed. Therefore can you consider moving the addListener() to DataAccessViewTopCoponent().handleComponentOpened() and the remove in the handleComponentClosed(). I think you have access to the DataAccessPane from there so it should be OK to do. Would you agree?", "author": "arcturus2", "createdAt": "2020-06-12T10:39:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczMjYxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk0MzI3Mg==", "url": "https://github.com/constellation-app/constellation/pull/563#discussion_r439943272", "bodyText": "I've moved the listeners to the specified locations, and fixed the concurrent modification exception.", "author": "aldebaran30701", "createdAt": "2020-06-15T05:52:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczMjYxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk0MzQ4NA==", "url": "https://github.com/constellation-app/constellation/pull/563#discussion_r439943484", "bodyText": "Implemented in most recent commit", "author": "aldebaran30701", "createdAt": "2020-06-15T05:53:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTczMjYxNA=="}], "type": "inlineReview"}, {"oid": "312ef19bf228fd079b39f8fddab8f6d793583b5c", "url": "https://github.com/constellation-app/constellation/commit/312ef19bf228fd079b39f8fddab8f6d793583b5c", "message": "implement observer for run button", "committedDate": "2020-06-10T04:41:42Z", "type": "commit"}, {"oid": "e5ca1dddc1170ab5883678f962c171bf4b1f3224", "url": "https://github.com/constellation-app/constellation/commit/e5ca1dddc1170ab5883678f962c171bf4b1f3224", "message": "SQ Fixes", "committedDate": "2020-06-10T05:00:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMTcyMA==", "url": "https://github.com/constellation-app/constellation/pull/563#discussion_r437921720", "bodyText": "Should this be called something like QualityControlAutoVetterListener to remain consistent with the thing it's listening to?", "author": "cygnus-x-1", "createdAt": "2020-06-10T07:40:18Z", "path": "CoreQualityControlView/src/au/gov/asd/tac/constellation/views/qualitycontrol/daemon/QualityControlButtonListener.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.views.qualitycontrol.daemon;", "originalCommit": "e5ca1dddc1170ab5883678f962c171bf4b1f3224", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzkyMzcyNw==", "url": "https://github.com/constellation-app/constellation/pull/563#discussion_r437923727", "bodyText": "The \"stop\" style is also used when a query is running - i'd probably either create a new \"thinking\" style or just disable the button when canRun = false to avoid any confusion.", "author": "cygnus-x-1", "createdAt": "2020-06-10T07:42:27Z", "path": "CoreDataAccessView/src/au/gov/asd/tac/constellation/views/dataaccess/panes/DataAccessPane.java", "diffHunk": "@@ -1033,6 +1036,23 @@ private void deselectAllPlugins() {\n         });\n     }\n \n+    @Override\n+    public void qualityControlRuleChanged(final boolean canRun) {\n+        if (canRun) {", "originalCommit": "e5ca1dddc1170ab5883678f962c171bf4b1f3224", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6cf8cf50f99e5e5e51972048ce61c22cf0781e3b", "url": "https://github.com/constellation-app/constellation/commit/6cf8cf50f99e5e5e51972048ce61c22cf0781e3b", "message": "Refactor listener and button style", "committedDate": "2020-06-11T01:02:09Z", "type": "commit"}, {"oid": "7cf4d4d82eb591eeac0bc0df3468d17a3c8b4fbf", "url": "https://github.com/constellation-app/constellation/commit/7cf4d4d82eb591eeac0bc0df3468d17a3c8b4fbf", "message": "correct button state and concurrentmodexception", "committedDate": "2020-06-15T05:49:16Z", "type": "commit"}]}