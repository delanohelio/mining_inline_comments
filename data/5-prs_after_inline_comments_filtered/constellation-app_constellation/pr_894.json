{"pr_number": 894, "pr_title": "Performance/28 pagerank memory", "pr_createdAt": "2020-11-20T00:35:28Z", "pr_url": "https://github.com/constellation-app/constellation/pull/894", "timeline": [{"oid": "f96d4bc38fa2eea6a199c7ae92bc404a6c519587", "url": "https://github.com/constellation-app/constellation/commit/f96d4bc38fa2eea6a199c7ae92bc404a6c519587", "message": ":racehorse: Various changes to reduce pagerank memory usage\nNow stores the amount of outward links a vertex has in the separate outcounts map instead of storing it a number of times equal to the amount of verticies it neighbours.\nTidied edge direction logic.\nDeal with sinks (nodes with no outgoing edges) more succinctly.\nAdded progress tracker.\nNo longer build extra set of neighbours for each vertex. Looks like these wern't being garbage collected properly and may have been the main cause of the memory issue.\nMoved maxPagerank and delta calculation to after pagerank calculation instead of during, this is to set up for trialing using the stream framework or parallelising the pagerank calculation to improve performance (neither of these have been done yet).", "committedDate": "2020-11-18T05:01:01Z", "type": "commit"}, {"oid": "3ae3af1f1d3bf1abdb56628a9d7162220450f0a9", "url": "https://github.com/constellation-app/constellation/commit/3ae3af1f1d3bf1abdb56628a9d7162220450f0a9", "message": ":bug: Fixed bug causing early finish\nDelta was being calculated incorrectly. This would cause the epsilon to be met prematurely and the analytic to finish prematurely.", "committedDate": "2020-11-19T02:06:07Z", "type": "commit"}, {"oid": "2a94eeaf399acca5eb2f67085aa9e49af22155f2", "url": "https://github.com/constellation-app/constellation/commit/2a94eeaf399acca5eb2f67085aa9e49af22155f2", "message": ":racehorse: :art: Complete refactor of PagerankCentralityPlugin.edit\nCreated new subclass PagerankVertex to enable sotrage of related information together and allow quicker access to data such as pageRank, neighbours etc\nThis also reduces the amount of duplicate data and makes the code more readable through the creation of multiple new methods.\n\nImproves both the speed and memory usage of the analytic.", "committedDate": "2020-11-19T23:58:04Z", "type": "commit"}, {"oid": "44422dbb6946dde698d32030b91f883c7a0424a5", "url": "https://github.com/constellation-app/constellation/commit/44422dbb6946dde698d32030b91f883c7a0424a5", "message": ":art: Made variables final and private where applicable.", "committedDate": "2020-11-20T00:22:11Z", "type": "commit"}, {"oid": "dc0df09ffea257cd1db3aca4586bfcf778f17997", "url": "https://github.com/constellation-app/constellation/commit/dc0df09ffea257cd1db3aca4586bfcf778f17997", "message": ":art: Updated author due to wholesale changes.", "committedDate": "2020-11-20T00:34:11Z", "type": "commit"}, {"oid": "5e7dda1324f201051c50a5a21905a6829fb76f26", "url": "https://github.com/constellation-app/constellation/commit/5e7dda1324f201051c50a5a21905a6829fb76f26", "message": ":art: Fixed code smells.", "committedDate": "2020-11-20T01:53:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwNzkxNw==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r528407917", "bodyText": "Could this be made private or was the intention that this could be called elsewhere?", "author": "antares1470", "createdAt": "2020-11-22T21:34:00Z", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    static class PagerankVertex {", "originalCommit": "5e7dda1324f201051c50a5a21905a6829fb76f26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4MjE2Ng==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r529882166", "bodyText": "Ahh yes it definitely can :)", "author": "Nova-2119", "createdAt": "2020-11-24T21:15:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwNzkxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwNzk5MA==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r528407990", "bodyText": "Could this potentially be made public? (should be ok if it sits in a private class)", "author": "antares1470", "createdAt": "2020-11-22T21:34:36Z", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(int vertexPosition) {\n+            this.vertexId = graph.getVertex(vertexPosition);\n+            this.pagerank = 1.0/vertexCount;\n+            this.pagerankContribution = 0;\n+        }\n+        \n+        static void initialiseAllPagerankVertices(final GraphWriteMethods graph, final boolean treatUndirectedBidirectional, final double dampingFactor, final boolean normaliseByAvailable) {", "originalCommit": "5e7dda1324f201051c50a5a21905a6829fb76f26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4NTY3MQ==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r529885671", "bodyText": "I can (and will) but what is the advantage over it being package private, given its in a private class? Is it just a legibility thing?", "author": "Nova-2119", "createdAt": "2020-11-24T21:21:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwNzk5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTkxNzE4NQ==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r529917185", "bodyText": "I think it's definitely a legibility thing for me. Even though it's perfectly valid, it just looks odd not having a (visible) access modifier. Given it is in a private class, so long as the function isn't private it probably doesn't make much of difference what access modifier you add to it (package private, protected, public) in this instance. Really I'm just suggesting what I've seen elsewhere", "author": "antares1470", "createdAt": "2020-11-24T22:04:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwNzk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwODA4Mg==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r528408082", "bodyText": "vertexPosition can be final", "author": "antares1470", "createdAt": "2020-11-22T21:35:03Z", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(int vertexPosition) {", "originalCommit": "5e7dda1324f201051c50a5a21905a6829fb76f26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4NTk3OQ==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r529885979", "bodyText": "Done", "author": "Nova-2119", "createdAt": "2020-11-24T21:22:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwODA4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwODI4OQ==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r528408289", "bodyText": "make pgVertex final", "author": "antares1470", "createdAt": "2020-11-22T21:36:35Z", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(int vertexPosition) {\n+            this.vertexId = graph.getVertex(vertexPosition);\n+            this.pagerank = 1.0/vertexCount;\n+            this.pagerankContribution = 0;\n+        }\n+        \n+        static void initialiseAllPagerankVertices(final GraphWriteMethods graph, final boolean treatUndirectedBidirectional, final double dampingFactor, final boolean normaliseByAvailable) {\n+            PagerankVertex.graph = graph;\n+            PagerankVertex.vertexCount = graph.getVertexCount();\n+            PagerankVertex.treatUndirectedBidirectional = treatUndirectedBidirectional;\n+            PagerankVertex.normaliseByAvailable = normaliseByAvailable;\n+            PagerankVertex.pagerankAttribute = PAGERANK_ATTRIBUTE.ensure(graph);\n+            PagerankVertex.pagerankVertices =  new PagerankVertex[vertexCount];\n+            PagerankVertex.dampingFactor = dampingFactor;\n+            PagerankVertex.baseContribution = (1 - dampingFactor) / vertexCount;\n+            \n+            for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n+                // For every vertex\n+                PagerankVertex prVertex = new PagerankVertex(vertexPosition);\n+                pagerankVertices[vertexPosition] = prVertex;\n+            }\n+            \n+            calculateAllOutgoingAndNeighboursAndPagerankContribution();\n+            updateSinkPagerankContribution();\n+        }\n+        \n+        private static void calculateAllOutgoingAndNeighboursAndPagerankContribution() {\n+            for (PagerankVertex pgVertex : pagerankVertices){", "originalCommit": "5e7dda1324f201051c50a5a21905a6829fb76f26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4NjI3NQ==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r529886275", "bodyText": "Done", "author": "Nova-2119", "createdAt": "2020-11-24T21:22:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwODI4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwODUyMQ==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r528408521", "bodyText": "final", "author": "antares1470", "createdAt": "2020-11-22T21:38:39Z", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(int vertexPosition) {\n+            this.vertexId = graph.getVertex(vertexPosition);\n+            this.pagerank = 1.0/vertexCount;\n+            this.pagerankContribution = 0;\n+        }\n+        \n+        static void initialiseAllPagerankVertices(final GraphWriteMethods graph, final boolean treatUndirectedBidirectional, final double dampingFactor, final boolean normaliseByAvailable) {\n+            PagerankVertex.graph = graph;\n+            PagerankVertex.vertexCount = graph.getVertexCount();\n+            PagerankVertex.treatUndirectedBidirectional = treatUndirectedBidirectional;\n+            PagerankVertex.normaliseByAvailable = normaliseByAvailable;\n+            PagerankVertex.pagerankAttribute = PAGERANK_ATTRIBUTE.ensure(graph);\n+            PagerankVertex.pagerankVertices =  new PagerankVertex[vertexCount];\n+            PagerankVertex.dampingFactor = dampingFactor;\n+            PagerankVertex.baseContribution = (1 - dampingFactor) / vertexCount;\n+            \n+            for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n+                // For every vertex\n+                PagerankVertex prVertex = new PagerankVertex(vertexPosition);\n+                pagerankVertices[vertexPosition] = prVertex;\n+            }\n+            \n+            calculateAllOutgoingAndNeighboursAndPagerankContribution();\n+            updateSinkPagerankContribution();\n+        }\n+        \n+        private static void calculateAllOutgoingAndNeighboursAndPagerankContribution() {\n+            for (PagerankVertex pgVertex : pagerankVertices){\n+            // identify incoming connections and store connected vertices and their outgoing connection count\n+                final int linkCount = graph.getVertexLinkCount(pgVertex.vertexId);\n+                for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n+    //              For each link\n+                    final int linkId = graph.getVertexLink(pgVertex.vertexId, linkPosition);\n+                    final int linkLowId = graph.getLinkLowVertex(linkId);\n+                    final int linkHighId = graph.getLinkHighVertex(linkId);\n+                    if (linkLowId != linkHighId) {\n+                        // If it isnt a link to itself\n+                        final Integer neighbourId = pgVertex.vertexId == linkLowId ? linkHighId : linkLowId;\n+                        final int edgeCount = graph.getLinkEdgeCount(linkId);\n+                        for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n+                            // Then for every edge in the link\n+                            final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n+                            final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                            if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n+                                    || graph.getEdgeSourceVertex(edgeId) == pgVertex.vertexId) {\n+                                // If egde is facing outwards, add 1 to outCount.\n+                                pgVertex.outCount +=1;\n+                            } else if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n+                                    || graph.getEdgeDestinationVertex(edgeId) == pgVertex.vertexId) {\n+                                // If edge is facing towards vertex add the source as a neighbour.\n+                                pgVertex.neighbours.add(pagerankVertices[graph.getVertexPosition(neighbourId)]);\n+                            }\n                         }\n                     }\n                 }\n+                // If it is a sink (that is it has no outgoing transaction) then treat it as if it connect to every other vertex. Otherwise the total pagerank will gradually reduce from one to zero.\n+                if (pgVertex.outCount == 0) {\n+                    pgVertex.outCount = vertexCount - 1;\n+                    sinks.add(pgVertex);\n+                    pgVertex.isSink = true;\n+                }\n+                pgVertex.updatePagerankContribution();\n             }\n         }\n-\n-        // handle dangling vertices by linking them to all pages\n-        for (final int neighbourId : verticesWithZeroOutLinks) {\n-            final int updatedCount = vertexInLinks.size();\n-            for (final int vertexId : vertexInLinks.keySet()) {\n-                vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, updatedCount));\n-            }\n+        \n+        private static void updateSinkPagerankContribution() {\n+            sinkPagerankContribution = sinks.parallelStream().mapToDouble(pgVertex -> pgVertex.pagerankContribution).sum();\n         }\n-\n-        // initialise pagerank values\n-        final double[] tempPageranks = new double[graph.getVertexCapacity()];\n-        final double[] pageranks = new double[graph.getVertexCapacity()];\n-        Arrays.fill(pageranks, (double) 1 / vertexInLinks.size());\n-\n-        // calculate pagerank for each vertex\n-        for (int iteration = 0; iteration < iterations; iteration++) {\n-            Arrays.fill(tempPageranks, 0);\n-\n+        \n+        private void updatePagerankContribution() {\n+            pagerankContribution = pagerank/outCount;\n+        }\n+        \n+        private static void updateAllPageranks() {\n+            delta = 0;\n             double maxPagerank = 0;\n-            double delta = 0;\n-            for (final int vertexId : vertexInLinks.keySet()) {\n-                double neighbourContribution = 0.0;\n-                final Set<Tuple<Integer, Integer>> neighbours = vertexInLinks.get(vertexId);\n-                for (final Tuple<Integer, Integer> neighbour : neighbours) {\n-                    final int neighbourId = neighbour.getFirst();\n-                    final int neighbourOutCount = neighbour.getSecond();\n-                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n-                    neighbourContribution += (pageranks[neighbourPosition] / neighbourOutCount);\n+            for( PagerankVertex pgVertex: pagerankVertices) {", "originalCommit": "5e7dda1324f201051c50a5a21905a6829fb76f26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4NjUxMg==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r529886512", "bodyText": "Done", "author": "Nova-2119", "createdAt": "2020-11-24T21:23:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwODUyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwODU1Mw==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r528408553", "bodyText": "final", "author": "antares1470", "createdAt": "2020-11-22T21:39:01Z", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(int vertexPosition) {\n+            this.vertexId = graph.getVertex(vertexPosition);\n+            this.pagerank = 1.0/vertexCount;\n+            this.pagerankContribution = 0;\n+        }\n+        \n+        static void initialiseAllPagerankVertices(final GraphWriteMethods graph, final boolean treatUndirectedBidirectional, final double dampingFactor, final boolean normaliseByAvailable) {\n+            PagerankVertex.graph = graph;\n+            PagerankVertex.vertexCount = graph.getVertexCount();\n+            PagerankVertex.treatUndirectedBidirectional = treatUndirectedBidirectional;\n+            PagerankVertex.normaliseByAvailable = normaliseByAvailable;\n+            PagerankVertex.pagerankAttribute = PAGERANK_ATTRIBUTE.ensure(graph);\n+            PagerankVertex.pagerankVertices =  new PagerankVertex[vertexCount];\n+            PagerankVertex.dampingFactor = dampingFactor;\n+            PagerankVertex.baseContribution = (1 - dampingFactor) / vertexCount;\n+            \n+            for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n+                // For every vertex\n+                PagerankVertex prVertex = new PagerankVertex(vertexPosition);\n+                pagerankVertices[vertexPosition] = prVertex;\n+            }\n+            \n+            calculateAllOutgoingAndNeighboursAndPagerankContribution();\n+            updateSinkPagerankContribution();\n+        }\n+        \n+        private static void calculateAllOutgoingAndNeighboursAndPagerankContribution() {\n+            for (PagerankVertex pgVertex : pagerankVertices){\n+            // identify incoming connections and store connected vertices and their outgoing connection count\n+                final int linkCount = graph.getVertexLinkCount(pgVertex.vertexId);\n+                for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n+    //              For each link\n+                    final int linkId = graph.getVertexLink(pgVertex.vertexId, linkPosition);\n+                    final int linkLowId = graph.getLinkLowVertex(linkId);\n+                    final int linkHighId = graph.getLinkHighVertex(linkId);\n+                    if (linkLowId != linkHighId) {\n+                        // If it isnt a link to itself\n+                        final Integer neighbourId = pgVertex.vertexId == linkLowId ? linkHighId : linkLowId;\n+                        final int edgeCount = graph.getLinkEdgeCount(linkId);\n+                        for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n+                            // Then for every edge in the link\n+                            final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n+                            final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                            if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n+                                    || graph.getEdgeSourceVertex(edgeId) == pgVertex.vertexId) {\n+                                // If egde is facing outwards, add 1 to outCount.\n+                                pgVertex.outCount +=1;\n+                            } else if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n+                                    || graph.getEdgeDestinationVertex(edgeId) == pgVertex.vertexId) {\n+                                // If edge is facing towards vertex add the source as a neighbour.\n+                                pgVertex.neighbours.add(pagerankVertices[graph.getVertexPosition(neighbourId)]);\n+                            }\n                         }\n                     }\n                 }\n+                // If it is a sink (that is it has no outgoing transaction) then treat it as if it connect to every other vertex. Otherwise the total pagerank will gradually reduce from one to zero.\n+                if (pgVertex.outCount == 0) {\n+                    pgVertex.outCount = vertexCount - 1;\n+                    sinks.add(pgVertex);\n+                    pgVertex.isSink = true;\n+                }\n+                pgVertex.updatePagerankContribution();\n             }\n         }\n-\n-        // handle dangling vertices by linking them to all pages\n-        for (final int neighbourId : verticesWithZeroOutLinks) {\n-            final int updatedCount = vertexInLinks.size();\n-            for (final int vertexId : vertexInLinks.keySet()) {\n-                vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, updatedCount));\n-            }\n+        \n+        private static void updateSinkPagerankContribution() {\n+            sinkPagerankContribution = sinks.parallelStream().mapToDouble(pgVertex -> pgVertex.pagerankContribution).sum();\n         }\n-\n-        // initialise pagerank values\n-        final double[] tempPageranks = new double[graph.getVertexCapacity()];\n-        final double[] pageranks = new double[graph.getVertexCapacity()];\n-        Arrays.fill(pageranks, (double) 1 / vertexInLinks.size());\n-\n-        // calculate pagerank for each vertex\n-        for (int iteration = 0; iteration < iterations; iteration++) {\n-            Arrays.fill(tempPageranks, 0);\n-\n+        \n+        private void updatePagerankContribution() {\n+            pagerankContribution = pagerank/outCount;\n+        }\n+        \n+        private static void updateAllPageranks() {\n+            delta = 0;\n             double maxPagerank = 0;\n-            double delta = 0;\n-            for (final int vertexId : vertexInLinks.keySet()) {\n-                double neighbourContribution = 0.0;\n-                final Set<Tuple<Integer, Integer>> neighbours = vertexInLinks.get(vertexId);\n-                for (final Tuple<Integer, Integer> neighbour : neighbours) {\n-                    final int neighbourId = neighbour.getFirst();\n-                    final int neighbourOutCount = neighbour.getSecond();\n-                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n-                    neighbourContribution += (pageranks[neighbourPosition] / neighbourOutCount);\n+            for( PagerankVertex pgVertex: pagerankVertices) {\n+                pgVertex.stageNewPagerank();\n+                delta += Math.abs(pgVertex.pagerank - pgVertex.stagedPagerank);\n+                if (pgVertex.stagedPagerank > maxPagerank) {\n+                    maxPagerank = pgVertex.stagedPagerank;\n                 }\n-\n-                final int vertexPosition = graph.getVertexPosition(vertexId);\n-                tempPageranks[vertexPosition] = ((1 - dampingFactor) / vertexInLinks.size()) + (dampingFactor * neighbourContribution);\n-                maxPagerank = Math.max(tempPageranks[vertexPosition], maxPagerank);\n-                delta += Math.abs(pageranks[vertexPosition] - tempPageranks[vertexPosition]);\n             }\n \n-            for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n+            for (PagerankVertex pgVertex: pagerankVertices) {", "originalCommit": "5e7dda1324f201051c50a5a21905a6829fb76f26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4NjU2Mg==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r529886562", "bodyText": "Done", "author": "Nova-2119", "createdAt": "2020-11-24T21:23:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwODU1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwODYwNg==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r528408606", "bodyText": "final", "author": "antares1470", "createdAt": "2020-11-22T21:39:18Z", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(int vertexPosition) {\n+            this.vertexId = graph.getVertex(vertexPosition);\n+            this.pagerank = 1.0/vertexCount;\n+            this.pagerankContribution = 0;\n+        }\n+        \n+        static void initialiseAllPagerankVertices(final GraphWriteMethods graph, final boolean treatUndirectedBidirectional, final double dampingFactor, final boolean normaliseByAvailable) {\n+            PagerankVertex.graph = graph;\n+            PagerankVertex.vertexCount = graph.getVertexCount();\n+            PagerankVertex.treatUndirectedBidirectional = treatUndirectedBidirectional;\n+            PagerankVertex.normaliseByAvailable = normaliseByAvailable;\n+            PagerankVertex.pagerankAttribute = PAGERANK_ATTRIBUTE.ensure(graph);\n+            PagerankVertex.pagerankVertices =  new PagerankVertex[vertexCount];\n+            PagerankVertex.dampingFactor = dampingFactor;\n+            PagerankVertex.baseContribution = (1 - dampingFactor) / vertexCount;\n+            \n+            for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n+                // For every vertex\n+                PagerankVertex prVertex = new PagerankVertex(vertexPosition);\n+                pagerankVertices[vertexPosition] = prVertex;\n+            }\n+            \n+            calculateAllOutgoingAndNeighboursAndPagerankContribution();\n+            updateSinkPagerankContribution();\n+        }\n+        \n+        private static void calculateAllOutgoingAndNeighboursAndPagerankContribution() {\n+            for (PagerankVertex pgVertex : pagerankVertices){\n+            // identify incoming connections and store connected vertices and their outgoing connection count\n+                final int linkCount = graph.getVertexLinkCount(pgVertex.vertexId);\n+                for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n+    //              For each link\n+                    final int linkId = graph.getVertexLink(pgVertex.vertexId, linkPosition);\n+                    final int linkLowId = graph.getLinkLowVertex(linkId);\n+                    final int linkHighId = graph.getLinkHighVertex(linkId);\n+                    if (linkLowId != linkHighId) {\n+                        // If it isnt a link to itself\n+                        final Integer neighbourId = pgVertex.vertexId == linkLowId ? linkHighId : linkLowId;\n+                        final int edgeCount = graph.getLinkEdgeCount(linkId);\n+                        for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n+                            // Then for every edge in the link\n+                            final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n+                            final int edgeDirection = graph.getEdgeDirection(edgeId);\n+                            if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n+                                    || graph.getEdgeSourceVertex(edgeId) == pgVertex.vertexId) {\n+                                // If egde is facing outwards, add 1 to outCount.\n+                                pgVertex.outCount +=1;\n+                            } else if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n+                                    || graph.getEdgeDestinationVertex(edgeId) == pgVertex.vertexId) {\n+                                // If edge is facing towards vertex add the source as a neighbour.\n+                                pgVertex.neighbours.add(pagerankVertices[graph.getVertexPosition(neighbourId)]);\n+                            }\n                         }\n                     }\n                 }\n+                // If it is a sink (that is it has no outgoing transaction) then treat it as if it connect to every other vertex. Otherwise the total pagerank will gradually reduce from one to zero.\n+                if (pgVertex.outCount == 0) {\n+                    pgVertex.outCount = vertexCount - 1;\n+                    sinks.add(pgVertex);\n+                    pgVertex.isSink = true;\n+                }\n+                pgVertex.updatePagerankContribution();\n             }\n         }\n-\n-        // handle dangling vertices by linking them to all pages\n-        for (final int neighbourId : verticesWithZeroOutLinks) {\n-            final int updatedCount = vertexInLinks.size();\n-            for (final int vertexId : vertexInLinks.keySet()) {\n-                vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, updatedCount));\n-            }\n+        \n+        private static void updateSinkPagerankContribution() {\n+            sinkPagerankContribution = sinks.parallelStream().mapToDouble(pgVertex -> pgVertex.pagerankContribution).sum();\n         }\n-\n-        // initialise pagerank values\n-        final double[] tempPageranks = new double[graph.getVertexCapacity()];\n-        final double[] pageranks = new double[graph.getVertexCapacity()];\n-        Arrays.fill(pageranks, (double) 1 / vertexInLinks.size());\n-\n-        // calculate pagerank for each vertex\n-        for (int iteration = 0; iteration < iterations; iteration++) {\n-            Arrays.fill(tempPageranks, 0);\n-\n+        \n+        private void updatePagerankContribution() {\n+            pagerankContribution = pagerank/outCount;\n+        }\n+        \n+        private static void updateAllPageranks() {\n+            delta = 0;\n             double maxPagerank = 0;\n-            double delta = 0;\n-            for (final int vertexId : vertexInLinks.keySet()) {\n-                double neighbourContribution = 0.0;\n-                final Set<Tuple<Integer, Integer>> neighbours = vertexInLinks.get(vertexId);\n-                for (final Tuple<Integer, Integer> neighbour : neighbours) {\n-                    final int neighbourId = neighbour.getFirst();\n-                    final int neighbourOutCount = neighbour.getSecond();\n-                    final int neighbourPosition = graph.getVertexPosition(neighbourId);\n-                    neighbourContribution += (pageranks[neighbourPosition] / neighbourOutCount);\n+            for( PagerankVertex pgVertex: pagerankVertices) {\n+                pgVertex.stageNewPagerank();\n+                delta += Math.abs(pgVertex.pagerank - pgVertex.stagedPagerank);\n+                if (pgVertex.stagedPagerank > maxPagerank) {\n+                    maxPagerank = pgVertex.stagedPagerank;\n                 }\n-\n-                final int vertexPosition = graph.getVertexPosition(vertexId);\n-                tempPageranks[vertexPosition] = ((1 - dampingFactor) / vertexInLinks.size()) + (dampingFactor * neighbourContribution);\n-                maxPagerank = Math.max(tempPageranks[vertexPosition], maxPagerank);\n-                delta += Math.abs(pageranks[vertexPosition] - tempPageranks[vertexPosition]);\n             }\n \n-            for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n+            for (PagerankVertex pgVertex: pagerankVertices) {\n                 if (normaliseByAvailable && maxPagerank > 0) {\n-                    pageranks[vertexPosition] = tempPageranks[vertexPosition] / maxPagerank;\n+                    pgVertex.pagerank = pgVertex.stagedPagerank / maxPagerank;\n                 } else {\n-                    pageranks[vertexPosition] = tempPageranks[vertexPosition];\n+                    pgVertex.pagerank = pgVertex.stagedPagerank;\n                 }\n+                pgVertex.updatePagerankContribution();\n             }\n-\n-            if (delta < epsilon) {\n-                break;\n+            updateSinkPagerankContribution();\n+        }\n+        \n+        private static void commitPageranksToGraph(){\n+            for (PagerankVertex pgVertex : pagerankVertices) {", "originalCommit": "5e7dda1324f201051c50a5a21905a6829fb76f26", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTg4NjY5MQ==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r529886691", "bodyText": "Done", "author": "Nova-2119", "createdAt": "2020-11-24T21:23:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODQwODYwNg=="}], "type": "inlineReview"}, {"oid": "5cbe3e2047ab4a387d4140556c5a71f3b92e8e2c", "url": "https://github.com/constellation-app/constellation/commit/5cbe3e2047ab4a387d4140556c5a71f3b92e8e2c", "message": ":art: Made changes requested in pull request.", "committedDate": "2020-11-24T21:40:19Z", "type": "commit"}, {"oid": "a2687fdc437b6eccbe55853cf7d2a339e1e45093", "url": "https://github.com/constellation-app/constellation/commit/a2687fdc437b6eccbe55853cf7d2a339e1e45093", "message": ":bug: :white_check_mark: Updates tests.\nTest were previously incorrect, they looked for values that were slightly wrong.\nThese values included a bug where the pageRank distributed to each other node by a sink would\nbe its pageRank divided by the total number of nodes rather than the number of nodes minus 1 (as it wont distributed pageRank to itself).\n\nI have modified the test to only perform 2 iterations. This should still test that multiple iterations works but is also now a small enough test for values to be calculated by hand in order to verify the values are correct. This allows the values to be set based on the true value and not the values being produced by the analytic at the time of writing the test.", "committedDate": "2020-12-21T04:41:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA4NTY2Nw==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r555085667", "bodyText": "@Nova-2119 @cygnus-x-1 so I am OK with updating the unit test but I am worried about this change. Previously vxId4 was last but now vxId3 is last. Does that mean the page rank was wrong before or wrong now?", "author": "arcturus2", "createdAt": "2021-01-11T14:31:03Z", "path": "CoreAlgorithmPlugins/test/unit/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPluginNGTest.java", "diffHunk": "@@ -102,15 +102,15 @@ public void testNormalisedPagerank() throws Exception {\n         final PluginParameters parameters = instance.createParameters();\n         parameters.setBooleanValue(PagerankCentralityPlugin.TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID, true);\n         parameters.setFloatValue(PagerankCentralityPlugin.DAMPING_FACTOR_PARAMETER_ID, 0.85f);\n-        parameters.setIntegerValue(PagerankCentralityPlugin.ITERATIONS_PARAMETER_ID, 100);\n+        parameters.setIntegerValue(PagerankCentralityPlugin.ITERATIONS_PARAMETER_ID, 2);\n         parameters.setFloatValue(PagerankCentralityPlugin.EPSILON_PARAMETER_ID, 1E-8f);\n         parameters.setBooleanValue(PagerankCentralityPlugin.NORMALISE_AVAILABLE_PARAMETER_ID, true);\n         PluginExecution.withPlugin(instance).withParameters(parameters).executeNow(graph);\n \n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId0), 0.22181106f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId1), 0.4309117f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId2), 0.42492065f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId3), 0.8254921f);\n-        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId4), 1f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId0), 0.18089105f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId1), 0.39393282f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId2), 0.5371851f);\n+        assertEquals(graph.getFloatValue(vertexPagerankAttribute, vxId3), 1f);", "originalCommit": "a2687fdc437b6eccbe55853cf7d2a339e1e45093", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjE2MTQ0NQ==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r556161445", "bodyText": "It was wrong beforehand. When there is a sink its pagerank is distributed to all other nodes equally. However rather than divide by the maount of nodes - 1 it used to divide by the amount of nodes. This meant that some of the pagerank would be lost and the other nodes got less then they should have.", "author": "Nova-2119", "createdAt": "2021-01-12T23:20:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA4NTY2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzc3NzUzMw==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r557777533", "bodyText": "ok thanks @Nova-2119", "author": "arcturus2", "createdAt": "2021-01-15T00:02:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTA4NTY2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4NDk0Mg==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r559884942", "bodyText": "You should add an additional author rather than replace the author (although i am happy for all bug reports to go to you :p).", "author": "cygnus-x-1", "createdAt": "2021-01-19T03:00:02Z", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -44,7 +40,7 @@\n  * Calculates pagerank centrality for each vertex. This centrality measure does\n  * not include loops.\n  *\n- * @author cygnus_x-1", "originalCommit": "a2687fdc437b6eccbe55853cf7d2a339e1e45093", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY4MDkyNg==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r565680926", "bodyText": "Oh would you look at that, suddenly you're on the author list again \ud83d\ude04", "author": "Nova-2119", "createdAt": "2021-01-27T22:27:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4NDk0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4NTI4OA==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r559885288", "bodyText": "This is my favourite line of code, i read it as \"iteration, iteration, iteration, iteration, iteration.... true\".", "author": "cygnus-x-1", "createdAt": "2021-01-19T03:01:19Z", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);", "originalCommit": "a2687fdc437b6eccbe55853cf7d2a339e1e45093", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY4MzYxNg==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r565683616", "bodyText": "I have named this line:\nThe iteration of the alliteration of iteration\nBut also i've renamed them to maxIterations and currentIteration", "author": "Nova-2119", "createdAt": "2021-01-27T22:32:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4NTI4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4NTU3MQ==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r559885571", "bodyText": "final PagerankVertex", "author": "cygnus-x-1", "createdAt": "2021-01-19T03:02:28Z", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    private static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(final int vertexPosition) {\n+            this.vertexId = graph.getVertex(vertexPosition);\n+            this.pagerank = 1.0/vertexCount;\n+            this.pagerankContribution = 0;\n+        }\n+        \n+        public static void initialiseAllPagerankVertices(final GraphWriteMethods graph, final boolean treatUndirectedBidirectional, final double dampingFactor, final boolean normaliseByAvailable) {\n+            PagerankVertex.graph = graph;\n+            PagerankVertex.vertexCount = graph.getVertexCount();\n+            PagerankVertex.treatUndirectedBidirectional = treatUndirectedBidirectional;\n+            PagerankVertex.normaliseByAvailable = normaliseByAvailable;\n+            PagerankVertex.pagerankAttribute = PAGERANK_ATTRIBUTE.ensure(graph);\n+            PagerankVertex.pagerankVertices =  new PagerankVertex[vertexCount];\n+            PagerankVertex.dampingFactor = dampingFactor;\n+            PagerankVertex.baseContribution = (1 - dampingFactor) / vertexCount;\n+            \n+            for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n+                // For every vertex\n+                PagerankVertex prVertex = new PagerankVertex(vertexPosition);", "originalCommit": "a2687fdc437b6eccbe55853cf7d2a339e1e45093", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY4NTgwNA==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r565685804", "bodyText": "Done", "author": "Nova-2119", "createdAt": "2021-01-27T22:36:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4NTU3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4NzEwMg==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r559887102", "bodyText": "Is there a reason for instantiating PagerankVertex with a vertex position over a vertex id? I can't see this causing any issues in this instance, but it's generally not recommended practice due to the volatility of vertex position.", "author": "cygnus-x-1", "createdAt": "2021-01-19T03:08:42Z", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    private static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(final int vertexPosition) {\n+            this.vertexId = graph.getVertex(vertexPosition);\n+            this.pagerank = 1.0/vertexCount;\n+            this.pagerankContribution = 0;\n+        }\n+        \n+        public static void initialiseAllPagerankVertices(final GraphWriteMethods graph, final boolean treatUndirectedBidirectional, final double dampingFactor, final boolean normaliseByAvailable) {\n+            PagerankVertex.graph = graph;\n+            PagerankVertex.vertexCount = graph.getVertexCount();\n+            PagerankVertex.treatUndirectedBidirectional = treatUndirectedBidirectional;\n+            PagerankVertex.normaliseByAvailable = normaliseByAvailable;\n+            PagerankVertex.pagerankAttribute = PAGERANK_ATTRIBUTE.ensure(graph);\n+            PagerankVertex.pagerankVertices =  new PagerankVertex[vertexCount];\n+            PagerankVertex.dampingFactor = dampingFactor;\n+            PagerankVertex.baseContribution = (1 - dampingFactor) / vertexCount;\n+            \n+            for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n+                // For every vertex\n+                PagerankVertex prVertex = new PagerankVertex(vertexPosition);", "originalCommit": "a2687fdc437b6eccbe55853cf7d2a339e1e45093", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTY5MzU5MQ==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r565693591", "bodyText": "Hmm, I think the reason is a combination of lines 161 and 192. Im using the position just so that I can add it to the pageRankVerticies array in that position and then refer back to it.\nIf I instead stores them in a Set and used the id as the key then I could change line 192 to retrieve them by ID instead and not use the position at all. Do you think that would be better?", "author": "Nova-2119", "createdAt": "2021-01-27T22:52:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4NzEwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4ODkxMQ==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r559888911", "bodyText": "It feels weird to me that this class both represents a Pagerank controller for a graph as well as an individual Pagerank result for a vertex. Maybe you have a good reason for doing this, but it feels like it could use some logical seperation.", "author": "cygnus-x-1", "createdAt": "2021-01-19T03:16:31Z", "path": "CoreAlgorithmPlugins/src/au/gov/asd/tac/constellation/plugins/algorithms/sna/centrality/PagerankCentralityPlugin.java", "diffHunk": "@@ -95,118 +92,181 @@ public PluginParameters createParameters() {\n \n         return parameters;\n     }\n-\n+ \n     @Override\n     public void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException {\n-        final boolean treatUndirectedBidirectional = parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID);\n         final float dampingFactor = parameters.getFloatValue(DAMPING_FACTOR_PARAMETER_ID);\n         final int iterations = parameters.getIntegerValue(ITERATIONS_PARAMETER_ID);\n         final float epsilon = parameters.getFloatValue(EPSILON_PARAMETER_ID);\n         final boolean normaliseByAvailable = parameters.getBooleanValue(NORMALISE_AVAILABLE_PARAMETER_ID);\n \n-        // identify incoming connections and store connected vertices and their outgoing connection count\n-        final Set<Integer> verticesWithZeroOutLinks = new HashSet<>();\n-        final Map<Integer, Set<Tuple<Integer, Integer>>> vertexInLinks = new HashMap<>();\n-        final int vertexCount = graph.getVertexCount();\n-        for (int vertexPosition = 0; vertexPosition < vertexCount; vertexPosition++) {\n-            final int vertexId = graph.getVertex(vertexPosition);\n-            vertexInLinks.put(vertexId, new HashSet<>());\n \n-            if (graph.getVertexEdgeCount(vertexId, GraphConstants.OUTGOING) == 0) {\n-                verticesWithZeroOutLinks.add(vertexId);\n+        PagerankVertex.initialiseAllPagerankVertices(graph, parameters.getBooleanValue(TREAT_UNDIRECTED_BIDIRECTIONAL_PARAMETER_ID), dampingFactor, normaliseByAvailable);\n+        \n+        // calculate pageranks\n+        for (int iteration = 0; iteration < iterations; iteration++) {\n+            interaction.setProgress(iteration, iterations, \"Iteration \" + iteration + \" of \" + iterations, true);\n+           \n+            PagerankVertex.updateAllPageranks();\n+            \n+            if (PagerankVertex.delta < epsilon) {\n+                break;\n             }\n \n-            final int linkCount = graph.getVertexLinkCount(vertexId);\n-            for (int linkPosition = 0; linkPosition < linkCount; linkPosition++) {\n-                final int linkId = graph.getVertexLink(vertexId, linkPosition);\n-                final int linkLowId = graph.getLinkLowVertex(linkId);\n-                final int linkHighId = graph.getLinkHighVertex(linkId);\n-                if (linkLowId != linkHighId) {\n-                    final int neighbourId = vertexId == linkLowId ? linkHighId : linkLowId;\n-                    final int edgeCount = graph.getLinkEdgeCount(linkId);\n-                    for (int edgePosition = 0; edgePosition < edgeCount; edgePosition++) {\n-                        final int edgeId = graph.getLinkEdge(linkId, edgePosition);\n-                        final int edgeDirection = graph.getEdgeDirection(edgeId);\n-                        if ((treatUndirectedBidirectional && edgeDirection == GraphConstants.FLAT)\n-                                || (vertexId < neighbourId && edgeDirection == GraphConstants.DOWNHILL)\n-                                || (vertexId > neighbourId && edgeDirection == GraphConstants.UPHILL)) {\n-                            int neighbourOutCount = 0;\n-                            final int transactionCount = graph.getVertexTransactionCount(neighbourId);\n-                            for (int transactionPosition = 0; transactionPosition < transactionCount; transactionPosition++) {\n-                                final int transactionId = graph.getVertexTransaction(neighbourId, transactionPosition);\n-                                final int transactionDirection = graph.getTransactionDirection(transactionId);\n-                                final int transactionSourceId = graph.getTransactionSourceVertex(transactionId);\n-                                final int transactionDestinationId = graph.getTransactionDestinationVertex(transactionId);\n-                                if (transactionSourceId != transactionDestinationId) {\n-                                    final int otherId = neighbourId == transactionSourceId ? transactionDestinationId : transactionSourceId;\n-                                    if ((treatUndirectedBidirectional && transactionDirection == GraphConstants.FLAT)\n-                                            || (neighbourId < otherId && transactionDirection == GraphConstants.UPHILL)\n-                                            || (neighbourId > otherId && transactionDirection == GraphConstants.DOWNHILL)) {\n-                                        neighbourOutCount++;\n-                                    }\n-                                }\n-                            }\n+        }\n+\n+        // update the graph with pagerank values\n+        PagerankVertex.commitPageranksToGraph();\n+    }\n+    \n+    private static class PagerankVertex {\n+        private static GraphWriteMethods graph;\n+        private static final Set<PagerankVertex> sinks = new HashSet<>();\n+        private static boolean treatUndirectedBidirectional;\n+        private static boolean normaliseByAvailable;\n+        private static double dampingFactor = 0;\n+        private static int vertexCount = 0;\n+        private static PagerankVertex[] pagerankVertices;\n+        private static double sinkPagerankContribution = 0;\n+        private static double delta = 0;\n+        private static int pagerankAttribute;\n+        private static double baseContribution;\n+        private final int vertexId;\n+        private final Set<PagerankVertex> neighbours = new HashSet<>();\n+        private int outCount = 0;\n+        private double pagerank;\n+        private double pagerankContribution;\n+        private double stagedPagerank;\n+        private boolean isSink = false;\n \n-                            vertexInLinks.get(vertexId).add(Tuple.create(neighbourId, neighbourOutCount));\n+        private PagerankVertex(final int vertexPosition) {", "originalCommit": "a2687fdc437b6eccbe55853cf7d2a339e1e45093", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTcwNDk3NA==", "url": "https://github.com/constellation-app/constellation/pull/894#discussion_r565704974", "bodyText": "Nope no good reason, just hadn't thought about it.\nI think I agree, i'm going to make this change and see how it feels.", "author": "Nova-2119", "createdAt": "2021-01-27T23:18:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1OTg4ODkxMQ=="}], "type": "inlineReview"}, {"oid": "06facaf8cfe5a561b5a378d449b589df63a55776", "url": "https://github.com/constellation-app/constellation/commit/06facaf8cfe5a561b5a378d449b589df63a55776", "message": "Merge branch 'master' into performance/28-PagerankMemory", "committedDate": "2021-01-27T22:24:35Z", "type": "commit"}, {"oid": "d0043a1c1e3cb0e907e6137a1863bef3670abe4d", "url": "https://github.com/constellation-app/constellation/commit/d0043a1c1e3cb0e907e6137a1863bef3670abe4d", "message": ":art: Seperation of controlling logic and PageRankVertex object.\n\nThe main change is the seperation of graph/analytic level actions with\nPageRankVerticies from the actual PageRankVertex. This has been combined\nwith other smaller recommendations made in the pull request for this\nbranch.", "committedDate": "2021-01-29T00:47:28Z", "type": "commit"}, {"oid": "c458f117dd1da50423366dfc63cdb61f760f8828", "url": "https://github.com/constellation-app/constellation/commit/c458f117dd1da50423366dfc63cdb61f760f8828", "message": ":art: Removed vestigial lines from testing", "committedDate": "2021-01-29T02:03:21Z", "type": "commit"}]}