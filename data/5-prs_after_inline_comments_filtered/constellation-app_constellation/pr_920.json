{"pr_number": 920, "pr_title": "JDBC Connector Import", "pr_createdAt": "2020-12-15T02:49:22Z", "pr_url": "https://github.com/constellation-app/constellation/pull/920", "timeline": [{"oid": "063a6b24ef8898c205623892b798cc923e144388", "url": "https://github.com/constellation-app/constellation/commit/063a6b24ef8898c205623892b798cc923e144388", "message": "add JDBC connector", "committedDate": "2020-12-15T02:32:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAxNTQzMA==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543015430", "bodyText": "can the type be omitted here (t -> ...)?", "author": "antares1470", "createdAt": "2020-12-15T03:20:33Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/AttributeList.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import au.gov.asd.tac.constellation.graph.Attribute;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.translator.AttributeTranslator;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.translator.DefaultAttributeTranslator;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n+import javafx.collections.ObservableList;\n+import javafx.geometry.Insets;\n+import javafx.geometry.Point2D;\n+import javafx.geometry.Pos;\n+import javafx.scene.Node;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.layout.VBox;\n+\n+public class AttributeList extends VBox {\n+\n+    private final RunPane runPane;\n+\n+    final ImportController importController;\n+    private final AttributeType attributeType;\n+    private final Map<String, AttributeNode> attributeNodes;\n+    private Set<Integer> keys;\n+\n+    public AttributeList(final ImportController importController, final RunPane runPane, final AttributeType attributeType) {\n+        this.runPane = runPane;\n+\n+        this.importController = importController;\n+        this.attributeType = attributeType;\n+        attributeNodes = new HashMap<>();\n+        keys = new HashSet<>();\n+\n+        setAlignment(Pos.CENTER);\n+        setMinSize(50, 100);\n+        setSpacing(1);\n+        setPadding(new Insets(2));\n+        setFillWidth(true);\n+\n+        setAlignment(Pos.TOP_CENTER);\n+    }\n+\n+    public AttributeType getAttributeType() {\n+        return attributeType;\n+    }\n+\n+    public RunPane getRunPane() {\n+        return runPane;\n+    }\n+\n+    public AttributeNode getAttributeNode(final String label) {\n+        return attributeNodes.get(label);\n+    }\n+\n+    private void createAttribute(final Attribute attribute) {\n+\n+        final AttributeNode attributeNode = new AttributeNode(this, attribute, keys.contains(attribute.getId()));\n+\n+        attributeNodes.put(attribute.getName(), attributeNode);\n+\n+        attributeNode.setOnMousePressed((final MouseEvent t) -> {", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAxNTk5Ng==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543015996", "bodyText": "t could be final but potentially this could be converted to a lambda expression?", "author": "antares1470", "createdAt": "2020-12-15T03:22:16Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/ActionPane.java", "diffHunk": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import au.gov.asd.tac.constellation.plugins.PluginException;\n+import java.io.IOException;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javafx.event.ActionEvent;\n+import javafx.event.EventHandler;\n+import javafx.geometry.Insets;\n+import javafx.scene.control.Button;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.HBox;\n+\n+public class ActionPane extends BorderPane {\n+\n+    private static final Logger LOGGER = Logger.getLogger(ActionPane.class.getName());\n+\n+    public ActionPane(final ImportController importController) {\n+        final HBox runBox = new HBox();\n+        runBox.setSpacing(5);\n+        runBox.setPadding(new Insets(5));\n+        setRight(runBox);\n+\n+        final Button cancelButton = new Button(\"Cancel\");\n+        cancelButton.setOnAction(new EventHandler<ActionEvent>() {\n+            @Override\n+            public void handle(ActionEvent t) {\n+                importController.cancelImport();\n+            }\n+        });\n+\n+        final Button importButton = new Button(\"Import\");\n+        importButton.setOnAction(new EventHandler<ActionEvent>() {\n+            @Override\n+            public void handle(ActionEvent t) {", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAxNjg3OA==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543016878", "bodyText": "omit type if possible", "author": "antares1470", "createdAt": "2020-12-15T03:24:57Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/AttributeNode.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import au.gov.asd.tac.constellation.graph.Attribute;\n+import au.gov.asd.tac.constellation.plugins.gui.PluginParametersDialog;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.translator.AttributeTranslator;\n+import au.gov.asd.tac.constellation.plugins.parameters.PluginParameters;\n+import au.gov.asd.tac.constellation.utilities.color.ConstellationColor;\n+import au.gov.asd.tac.constellation.utilities.icon.UserInterfaceIconProvider;\n+import java.awt.Color;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import javafx.event.ActionEvent;\n+import javafx.geometry.Pos;\n+import javafx.scene.control.ContextMenu;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.Menu;\n+import javafx.scene.control.MenuItem;\n+import javafx.scene.control.RadioMenuItem;\n+import javafx.scene.control.Toggle;\n+import javafx.scene.control.ToggleGroup;\n+import javafx.scene.control.Tooltip;\n+import javafx.scene.image.Image;\n+import javafx.scene.image.ImageView;\n+\n+public final class AttributeNode extends Label implements Comparable<AttributeNode> {\n+\n+    private final AttributeList attributeList;\n+    private Attribute attribute;\n+    private AttributeTranslator translator = AttributeTranslator.getTranslators().get(0);\n+    private ImportTableColumn column = null;\n+    private boolean isKey;\n+\n+    private final ToggleGroup menuGroup = new ToggleGroup();\n+    private final Menu parseMenu = new Menu(\"Formatter\");\n+    private final MenuItem deleteMenu = new MenuItem(\"Delete\");\n+    private final MenuItem setDefaultMenuItem = new MenuItem(\"Set Default Value...\");\n+    private String defaultValue = null;\n+    private PluginParameters translatorParameters;\n+\n+    private static final Image KEY_IMAGE = UserInterfaceIconProvider.KEY.buildImage(16, ConstellationColor.CHERRY.getJavaColor());\n+    private static final Image ADD_IMAGE = UserInterfaceIconProvider.ADD.buildImage(16, Color.BLACK);\n+    private Map<String, PluginParameters> recentTranslatorParameters = new HashMap<>();\n+\n+    /**\n+     *\n+     * @param attributeList The AttributeList to which this AttributeNode\n+     * belongs.\n+     * @param attribute The Attribute that this AttributeNode represents.\n+     * @param isKey True if this Attribute is a key.\n+     */\n+    public AttributeNode(final AttributeList attributeList, final Attribute attribute, final boolean isKey) {\n+\n+        this.attributeList = attributeList;\n+\n+        setMaxWidth(Double.MAX_VALUE);\n+        setAlignment(Pos.CENTER);\n+        setStyle(\"-fx-text-fill: black; -fx-background-color: \" + attributeList.getAttributeType().getColor().getHtmlColor() + \"; -fx-border-color: black; -fx-border-radius: 5; -fx-background-radius: 5;\");\n+\n+        // Create a context menu.\n+        final ContextMenu menu = new ContextMenu();\n+\n+        menu.getItems().add(parseMenu);\n+\n+        final List<AttributeTranslator> attributeTranslators = AttributeTranslator.getTranslators();\n+        for (final Iterator<AttributeTranslator> i = attributeTranslators.iterator(); i.hasNext();) {\n+            if (!i.next().appliesToAttributeType(attribute.getAttributeType())) {\n+                i.remove();\n+            }\n+        }\n+\n+        for (final AttributeTranslator at : attributeTranslators) {\n+            final RadioMenuItem item = new RadioMenuItem(at.getLabel());\n+            item.setSelected(at.getClass().equals(translator.getClass()));\n+            item.setToggleGroup(menuGroup);\n+            item.setOnAction((ActionEvent t) -> {", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAxNzE3MA==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543017170", "bodyText": "omit type if possible", "author": "antares1470", "createdAt": "2020-12-15T03:25:49Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/AttributeNode.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import au.gov.asd.tac.constellation.graph.Attribute;\n+import au.gov.asd.tac.constellation.plugins.gui.PluginParametersDialog;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.translator.AttributeTranslator;\n+import au.gov.asd.tac.constellation.plugins.parameters.PluginParameters;\n+import au.gov.asd.tac.constellation.utilities.color.ConstellationColor;\n+import au.gov.asd.tac.constellation.utilities.icon.UserInterfaceIconProvider;\n+import java.awt.Color;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import javafx.event.ActionEvent;\n+import javafx.geometry.Pos;\n+import javafx.scene.control.ContextMenu;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.Menu;\n+import javafx.scene.control.MenuItem;\n+import javafx.scene.control.RadioMenuItem;\n+import javafx.scene.control.Toggle;\n+import javafx.scene.control.ToggleGroup;\n+import javafx.scene.control.Tooltip;\n+import javafx.scene.image.Image;\n+import javafx.scene.image.ImageView;\n+\n+public final class AttributeNode extends Label implements Comparable<AttributeNode> {\n+\n+    private final AttributeList attributeList;\n+    private Attribute attribute;\n+    private AttributeTranslator translator = AttributeTranslator.getTranslators().get(0);\n+    private ImportTableColumn column = null;\n+    private boolean isKey;\n+\n+    private final ToggleGroup menuGroup = new ToggleGroup();\n+    private final Menu parseMenu = new Menu(\"Formatter\");\n+    private final MenuItem deleteMenu = new MenuItem(\"Delete\");\n+    private final MenuItem setDefaultMenuItem = new MenuItem(\"Set Default Value...\");\n+    private String defaultValue = null;\n+    private PluginParameters translatorParameters;\n+\n+    private static final Image KEY_IMAGE = UserInterfaceIconProvider.KEY.buildImage(16, ConstellationColor.CHERRY.getJavaColor());\n+    private static final Image ADD_IMAGE = UserInterfaceIconProvider.ADD.buildImage(16, Color.BLACK);\n+    private Map<String, PluginParameters> recentTranslatorParameters = new HashMap<>();\n+\n+    /**\n+     *\n+     * @param attributeList The AttributeList to which this AttributeNode\n+     * belongs.\n+     * @param attribute The Attribute that this AttributeNode represents.\n+     * @param isKey True if this Attribute is a key.\n+     */\n+    public AttributeNode(final AttributeList attributeList, final Attribute attribute, final boolean isKey) {\n+\n+        this.attributeList = attributeList;\n+\n+        setMaxWidth(Double.MAX_VALUE);\n+        setAlignment(Pos.CENTER);\n+        setStyle(\"-fx-text-fill: black; -fx-background-color: \" + attributeList.getAttributeType().getColor().getHtmlColor() + \"; -fx-border-color: black; -fx-border-radius: 5; -fx-background-radius: 5;\");\n+\n+        // Create a context menu.\n+        final ContextMenu menu = new ContextMenu();\n+\n+        menu.getItems().add(parseMenu);\n+\n+        final List<AttributeTranslator> attributeTranslators = AttributeTranslator.getTranslators();\n+        for (final Iterator<AttributeTranslator> i = attributeTranslators.iterator(); i.hasNext();) {\n+            if (!i.next().appliesToAttributeType(attribute.getAttributeType())) {\n+                i.remove();\n+            }\n+        }\n+\n+        for (final AttributeTranslator at : attributeTranslators) {\n+            final RadioMenuItem item = new RadioMenuItem(at.getLabel());\n+            item.setSelected(at.getClass().equals(translator.getClass()));\n+            item.setToggleGroup(menuGroup);\n+            item.setOnAction((ActionEvent t) -> {\n+                PluginParameters parameters;\n+                if (recentTranslatorParameters.containsKey(at.getLabel())) {\n+                    parameters = recentTranslatorParameters.get(at.getLabel());\n+                    if (parameters != null) {\n+                        parameters = parameters.copy();\n+                    }\n+                } else {\n+                    parameters = at.createParameters();\n+                }\n+                if (parameters == null) {\n+                    translator = at;\n+                    translatorParameters = null;\n+                    recentTranslatorParameters.put(at.getLabel(), null);\n+                    if (AttributeNode.this.getColumn() != null) {\n+                        attributeList.getRunPane().validate(AttributeNode.this.column);\n+                    }\n+                } else {\n+                    final PluginParametersDialog dialog = new PluginParametersDialog(attributeList.importController.getStage(), at.getLabel() + \" Parameters\", parameters, \"Ok\", \"Cancel\");\n+                    dialog.showAndWait();\n+                    if (PluginParametersDialog.OK.equalsIgnoreCase(dialog.getResult())) {\n+                        translator = at;\n+                        translatorParameters = parameters;\n+                        recentTranslatorParameters.put(at.getLabel(), parameters);\n+                        if (AttributeNode.this.getColumn() != null) {\n+                            attributeList.getRunPane().validate(AttributeNode.this.column);\n+                        }\n+                    } else {\n+                        updateTranslatorGroupToggle();\n+                    }\n+                }\n+            });\n+            parseMenu.getItems().add(item);\n+        }\n+\n+        setDefaultMenuItem.setOnAction((ActionEvent event) -> {", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAxNzIxNA==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543017214", "bodyText": "same here", "author": "antares1470", "createdAt": "2020-12-15T03:25:57Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/AttributeNode.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import au.gov.asd.tac.constellation.graph.Attribute;\n+import au.gov.asd.tac.constellation.plugins.gui.PluginParametersDialog;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.translator.AttributeTranslator;\n+import au.gov.asd.tac.constellation.plugins.parameters.PluginParameters;\n+import au.gov.asd.tac.constellation.utilities.color.ConstellationColor;\n+import au.gov.asd.tac.constellation.utilities.icon.UserInterfaceIconProvider;\n+import java.awt.Color;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import javafx.event.ActionEvent;\n+import javafx.geometry.Pos;\n+import javafx.scene.control.ContextMenu;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.Menu;\n+import javafx.scene.control.MenuItem;\n+import javafx.scene.control.RadioMenuItem;\n+import javafx.scene.control.Toggle;\n+import javafx.scene.control.ToggleGroup;\n+import javafx.scene.control.Tooltip;\n+import javafx.scene.image.Image;\n+import javafx.scene.image.ImageView;\n+\n+public final class AttributeNode extends Label implements Comparable<AttributeNode> {\n+\n+    private final AttributeList attributeList;\n+    private Attribute attribute;\n+    private AttributeTranslator translator = AttributeTranslator.getTranslators().get(0);\n+    private ImportTableColumn column = null;\n+    private boolean isKey;\n+\n+    private final ToggleGroup menuGroup = new ToggleGroup();\n+    private final Menu parseMenu = new Menu(\"Formatter\");\n+    private final MenuItem deleteMenu = new MenuItem(\"Delete\");\n+    private final MenuItem setDefaultMenuItem = new MenuItem(\"Set Default Value...\");\n+    private String defaultValue = null;\n+    private PluginParameters translatorParameters;\n+\n+    private static final Image KEY_IMAGE = UserInterfaceIconProvider.KEY.buildImage(16, ConstellationColor.CHERRY.getJavaColor());\n+    private static final Image ADD_IMAGE = UserInterfaceIconProvider.ADD.buildImage(16, Color.BLACK);\n+    private Map<String, PluginParameters> recentTranslatorParameters = new HashMap<>();\n+\n+    /**\n+     *\n+     * @param attributeList The AttributeList to which this AttributeNode\n+     * belongs.\n+     * @param attribute The Attribute that this AttributeNode represents.\n+     * @param isKey True if this Attribute is a key.\n+     */\n+    public AttributeNode(final AttributeList attributeList, final Attribute attribute, final boolean isKey) {\n+\n+        this.attributeList = attributeList;\n+\n+        setMaxWidth(Double.MAX_VALUE);\n+        setAlignment(Pos.CENTER);\n+        setStyle(\"-fx-text-fill: black; -fx-background-color: \" + attributeList.getAttributeType().getColor().getHtmlColor() + \"; -fx-border-color: black; -fx-border-radius: 5; -fx-background-radius: 5;\");\n+\n+        // Create a context menu.\n+        final ContextMenu menu = new ContextMenu();\n+\n+        menu.getItems().add(parseMenu);\n+\n+        final List<AttributeTranslator> attributeTranslators = AttributeTranslator.getTranslators();\n+        for (final Iterator<AttributeTranslator> i = attributeTranslators.iterator(); i.hasNext();) {\n+            if (!i.next().appliesToAttributeType(attribute.getAttributeType())) {\n+                i.remove();\n+            }\n+        }\n+\n+        for (final AttributeTranslator at : attributeTranslators) {\n+            final RadioMenuItem item = new RadioMenuItem(at.getLabel());\n+            item.setSelected(at.getClass().equals(translator.getClass()));\n+            item.setToggleGroup(menuGroup);\n+            item.setOnAction((ActionEvent t) -> {\n+                PluginParameters parameters;\n+                if (recentTranslatorParameters.containsKey(at.getLabel())) {\n+                    parameters = recentTranslatorParameters.get(at.getLabel());\n+                    if (parameters != null) {\n+                        parameters = parameters.copy();\n+                    }\n+                } else {\n+                    parameters = at.createParameters();\n+                }\n+                if (parameters == null) {\n+                    translator = at;\n+                    translatorParameters = null;\n+                    recentTranslatorParameters.put(at.getLabel(), null);\n+                    if (AttributeNode.this.getColumn() != null) {\n+                        attributeList.getRunPane().validate(AttributeNode.this.column);\n+                    }\n+                } else {\n+                    final PluginParametersDialog dialog = new PluginParametersDialog(attributeList.importController.getStage(), at.getLabel() + \" Parameters\", parameters, \"Ok\", \"Cancel\");\n+                    dialog.showAndWait();\n+                    if (PluginParametersDialog.OK.equalsIgnoreCase(dialog.getResult())) {\n+                        translator = at;\n+                        translatorParameters = parameters;\n+                        recentTranslatorParameters.put(at.getLabel(), parameters);\n+                        if (AttributeNode.this.getColumn() != null) {\n+                            attributeList.getRunPane().validate(AttributeNode.this.column);\n+                        }\n+                    } else {\n+                        updateTranslatorGroupToggle();\n+                    }\n+                }\n+            });\n+            parseMenu.getItems().add(item);\n+        }\n+\n+        setDefaultMenuItem.setOnAction((ActionEvent event) -> {\n+            defaultValue = attributeList.importController.showSetDefaultValueDialog(attribute.getName(), defaultValue);\n+            updateDefaultValue();\n+            attributeList.getRunPane().validate(AttributeNode.this.column);\n+        });\n+        menu.getItems().add(setDefaultMenuItem);\n+\n+        deleteMenu.setOnAction((ActionEvent event) -> {", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAxODI0NA==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543018244", "bodyText": "omit type if possible", "author": "antares1470", "createdAt": "2020-12-15T03:28:56Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/ConfigurationPane.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import au.gov.asd.tac.constellation.graph.Attribute;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.model.TableRow;\n+import au.gov.asd.tac.constellation.utilities.icon.UserInterfaceIconProvider;\n+import java.awt.Color;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javafx.application.Platform;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+import javafx.collections.FXCollections;\n+import javafx.collections.ObservableList;\n+import javafx.event.ActionEvent;\n+import javafx.event.Event;\n+import javafx.event.EventHandler;\n+import javafx.geometry.Side;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.Tab;\n+import javafx.scene.control.TabPane;\n+import javafx.scene.control.TextField;\n+import javafx.scene.image.Image;\n+import javafx.scene.image.ImageView;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.layout.AnchorPane;\n+\n+public class ConfigurationPane extends AnchorPane {\n+\n+    private final ImportController importController;\n+    private final TabPane tabPane;\n+\n+    private static final Image ADD_IMAGE = UserInterfaceIconProvider.ADD.buildImage(16, Color.BLACK);\n+\n+    public ConfigurationPane(final ImportController importController) {\n+        this.importController = importController;\n+\n+        setMaxHeight(Double.MAX_VALUE);\n+        setMaxWidth(Double.MAX_VALUE);\n+        setMinSize(0, 0);\n+\n+        // Add the tab pane that will hold a tab for each run\n+        tabPane = new TabPane();\n+        tabPane.setMaxHeight(Double.MAX_VALUE);\n+        tabPane.setSide(Side.TOP);\n+        AnchorPane.setTopAnchor(tabPane, 5.0);\n+        AnchorPane.setLeftAnchor(tabPane, 5.0);\n+        AnchorPane.setRightAnchor(tabPane, 5.0);\n+        AnchorPane.setBottomAnchor(tabPane, 5.0);\n+        getChildren().add(tabPane);\n+\n+        // Create a button to allow the user to add a new tab (RunPane).\n+        final Button newRunButton = new Button(\"\", new ImageView(ADD_IMAGE));\n+        newRunButton.setOnAction((ActionEvent event) -> {", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAxODQ1MA==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543018450", "bodyText": "lambda?", "author": "antares1470", "createdAt": "2020-12-15T03:29:37Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/ConfigurationPane.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import au.gov.asd.tac.constellation.graph.Attribute;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.model.TableRow;\n+import au.gov.asd.tac.constellation.utilities.icon.UserInterfaceIconProvider;\n+import java.awt.Color;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javafx.application.Platform;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+import javafx.collections.FXCollections;\n+import javafx.collections.ObservableList;\n+import javafx.event.ActionEvent;\n+import javafx.event.Event;\n+import javafx.event.EventHandler;\n+import javafx.geometry.Side;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.Tab;\n+import javafx.scene.control.TabPane;\n+import javafx.scene.control.TextField;\n+import javafx.scene.image.Image;\n+import javafx.scene.image.ImageView;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.layout.AnchorPane;\n+\n+public class ConfigurationPane extends AnchorPane {\n+\n+    private final ImportController importController;\n+    private final TabPane tabPane;\n+\n+    private static final Image ADD_IMAGE = UserInterfaceIconProvider.ADD.buildImage(16, Color.BLACK);\n+\n+    public ConfigurationPane(final ImportController importController) {\n+        this.importController = importController;\n+\n+        setMaxHeight(Double.MAX_VALUE);\n+        setMaxWidth(Double.MAX_VALUE);\n+        setMinSize(0, 0);\n+\n+        // Add the tab pane that will hold a tab for each run\n+        tabPane = new TabPane();\n+        tabPane.setMaxHeight(Double.MAX_VALUE);\n+        tabPane.setSide(Side.TOP);\n+        AnchorPane.setTopAnchor(tabPane, 5.0);\n+        AnchorPane.setLeftAnchor(tabPane, 5.0);\n+        AnchorPane.setRightAnchor(tabPane, 5.0);\n+        AnchorPane.setBottomAnchor(tabPane, 5.0);\n+        getChildren().add(tabPane);\n+\n+        // Create a button to allow the user to add a new tab (RunPane).\n+        final Button newRunButton = new Button(\"\", new ImageView(ADD_IMAGE));\n+        newRunButton.setOnAction((ActionEvent event) -> {\n+            importController.createNewRun();\n+        });\n+        AnchorPane.setTopAnchor(newRunButton, 10.0);\n+        AnchorPane.setRightAnchor(newRunButton, 10.0);\n+        getChildren().add(newRunButton);\n+\n+        // Add a single run to start with\n+        createTab();\n+    }\n+\n+    private Tab createTab() {\n+\n+        // Create a unique label for the new tab\n+        int runNumber = 0;\n+        boolean unique;\n+        do {\n+            final String label = \"Run \" + ++runNumber;\n+            unique = true;\n+            for (final Tab tab : tabPane.getTabs()) {\n+                final Label tabLabel = (Label) tab.getGraphic();\n+                if (label.equals(tabLabel.getText())) {\n+                    unique = false;\n+                    break;\n+                }\n+            }\n+        } while (!unique);\n+        final Label label = new Label(\"Run \" + runNumber);\n+\n+        final Tab tab = new Tab();\n+        tab.setGraphic(label);\n+\n+        tab.setOnClosed(new EventHandler<Event>() {\n+            @Override\n+            public void handle(Event event) {\n+                importController.updateDisplayedAttributes();\n+            }\n+        });", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAxODU0OA==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543018548", "bodyText": "lambda?", "author": "antares1470", "createdAt": "2020-12-15T03:29:50Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/ConfigurationPane.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import au.gov.asd.tac.constellation.graph.Attribute;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.model.TableRow;\n+import au.gov.asd.tac.constellation.utilities.icon.UserInterfaceIconProvider;\n+import java.awt.Color;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javafx.application.Platform;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+import javafx.collections.FXCollections;\n+import javafx.collections.ObservableList;\n+import javafx.event.ActionEvent;\n+import javafx.event.Event;\n+import javafx.event.EventHandler;\n+import javafx.geometry.Side;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.Tab;\n+import javafx.scene.control.TabPane;\n+import javafx.scene.control.TextField;\n+import javafx.scene.image.Image;\n+import javafx.scene.image.ImageView;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.layout.AnchorPane;\n+\n+public class ConfigurationPane extends AnchorPane {\n+\n+    private final ImportController importController;\n+    private final TabPane tabPane;\n+\n+    private static final Image ADD_IMAGE = UserInterfaceIconProvider.ADD.buildImage(16, Color.BLACK);\n+\n+    public ConfigurationPane(final ImportController importController) {\n+        this.importController = importController;\n+\n+        setMaxHeight(Double.MAX_VALUE);\n+        setMaxWidth(Double.MAX_VALUE);\n+        setMinSize(0, 0);\n+\n+        // Add the tab pane that will hold a tab for each run\n+        tabPane = new TabPane();\n+        tabPane.setMaxHeight(Double.MAX_VALUE);\n+        tabPane.setSide(Side.TOP);\n+        AnchorPane.setTopAnchor(tabPane, 5.0);\n+        AnchorPane.setLeftAnchor(tabPane, 5.0);\n+        AnchorPane.setRightAnchor(tabPane, 5.0);\n+        AnchorPane.setBottomAnchor(tabPane, 5.0);\n+        getChildren().add(tabPane);\n+\n+        // Create a button to allow the user to add a new tab (RunPane).\n+        final Button newRunButton = new Button(\"\", new ImageView(ADD_IMAGE));\n+        newRunButton.setOnAction((ActionEvent event) -> {\n+            importController.createNewRun();\n+        });\n+        AnchorPane.setTopAnchor(newRunButton, 10.0);\n+        AnchorPane.setRightAnchor(newRunButton, 10.0);\n+        getChildren().add(newRunButton);\n+\n+        // Add a single run to start with\n+        createTab();\n+    }\n+\n+    private Tab createTab() {\n+\n+        // Create a unique label for the new tab\n+        int runNumber = 0;\n+        boolean unique;\n+        do {\n+            final String label = \"Run \" + ++runNumber;\n+            unique = true;\n+            for (final Tab tab : tabPane.getTabs()) {\n+                final Label tabLabel = (Label) tab.getGraphic();\n+                if (label.equals(tabLabel.getText())) {\n+                    unique = false;\n+                    break;\n+                }\n+            }\n+        } while (!unique);\n+        final Label label = new Label(\"Run \" + runNumber);\n+\n+        final Tab tab = new Tab();\n+        tab.setGraphic(label);\n+\n+        tab.setOnClosed(new EventHandler<Event>() {\n+            @Override\n+            public void handle(Event event) {\n+                importController.updateDisplayedAttributes();\n+            }\n+        });\n+\n+        label.setOnMouseClicked(new EventHandler<MouseEvent>() {\n+            @Override\n+            public void handle(MouseEvent event) {\n+                if (event.getClickCount() == 2) {\n+                    final TextField field = new TextField(label.getText());\n+                    field.setOnAction(new EventHandler<ActionEvent>() {\n+                        @Override\n+                        public void handle(ActionEvent event) {\n+                            label.setText(field.getText());\n+                            tab.setGraphic(label);\n+                        }\n+                    });\n+                    field.focusedProperty().addListener(new ChangeListener<Boolean>() {\n+                        @Override\n+                        public void changed(ObservableValue<? extends Boolean> observable, Boolean oldValue, Boolean newValue) {\n+                            if (!newValue) {\n+                                label.setText(field.getText());\n+                                tab.setGraphic(label);\n+                            }\n+                        }\n+                    });\n+                    tab.setGraphic(field);\n+                    field.selectAll();\n+                    field.requestFocus();\n+                }\n+            }\n+        });", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAxODgwMw==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543018803", "bodyText": "lambda?", "author": "antares1470", "createdAt": "2020-12-15T03:30:41Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/ConfigurationPane.java", "diffHunk": "@@ -0,0 +1,259 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import au.gov.asd.tac.constellation.graph.Attribute;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.model.TableRow;\n+import au.gov.asd.tac.constellation.utilities.icon.UserInterfaceIconProvider;\n+import java.awt.Color;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javafx.application.Platform;\n+import javafx.beans.value.ChangeListener;\n+import javafx.beans.value.ObservableValue;\n+import javafx.collections.FXCollections;\n+import javafx.collections.ObservableList;\n+import javafx.event.ActionEvent;\n+import javafx.event.Event;\n+import javafx.event.EventHandler;\n+import javafx.geometry.Side;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.Tab;\n+import javafx.scene.control.TabPane;\n+import javafx.scene.control.TextField;\n+import javafx.scene.image.Image;\n+import javafx.scene.image.ImageView;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.layout.AnchorPane;\n+\n+public class ConfigurationPane extends AnchorPane {\n+\n+    private final ImportController importController;\n+    private final TabPane tabPane;\n+\n+    private static final Image ADD_IMAGE = UserInterfaceIconProvider.ADD.buildImage(16, Color.BLACK);\n+\n+    public ConfigurationPane(final ImportController importController) {\n+        this.importController = importController;\n+\n+        setMaxHeight(Double.MAX_VALUE);\n+        setMaxWidth(Double.MAX_VALUE);\n+        setMinSize(0, 0);\n+\n+        // Add the tab pane that will hold a tab for each run\n+        tabPane = new TabPane();\n+        tabPane.setMaxHeight(Double.MAX_VALUE);\n+        tabPane.setSide(Side.TOP);\n+        AnchorPane.setTopAnchor(tabPane, 5.0);\n+        AnchorPane.setLeftAnchor(tabPane, 5.0);\n+        AnchorPane.setRightAnchor(tabPane, 5.0);\n+        AnchorPane.setBottomAnchor(tabPane, 5.0);\n+        getChildren().add(tabPane);\n+\n+        // Create a button to allow the user to add a new tab (RunPane).\n+        final Button newRunButton = new Button(\"\", new ImageView(ADD_IMAGE));\n+        newRunButton.setOnAction((ActionEvent event) -> {\n+            importController.createNewRun();\n+        });\n+        AnchorPane.setTopAnchor(newRunButton, 10.0);\n+        AnchorPane.setRightAnchor(newRunButton, 10.0);\n+        getChildren().add(newRunButton);\n+\n+        // Add a single run to start with\n+        createTab();\n+    }\n+\n+    private Tab createTab() {\n+\n+        // Create a unique label for the new tab\n+        int runNumber = 0;\n+        boolean unique;\n+        do {\n+            final String label = \"Run \" + ++runNumber;\n+            unique = true;\n+            for (final Tab tab : tabPane.getTabs()) {\n+                final Label tabLabel = (Label) tab.getGraphic();\n+                if (label.equals(tabLabel.getText())) {\n+                    unique = false;\n+                    break;\n+                }\n+            }\n+        } while (!unique);\n+        final Label label = new Label(\"Run \" + runNumber);\n+\n+        final Tab tab = new Tab();\n+        tab.setGraphic(label);\n+\n+        tab.setOnClosed(new EventHandler<Event>() {\n+            @Override\n+            public void handle(Event event) {\n+                importController.updateDisplayedAttributes();\n+            }\n+        });\n+\n+        label.setOnMouseClicked(new EventHandler<MouseEvent>() {\n+            @Override\n+            public void handle(MouseEvent event) {\n+                if (event.getClickCount() == 2) {\n+                    final TextField field = new TextField(label.getText());\n+                    field.setOnAction(new EventHandler<ActionEvent>() {\n+                        @Override\n+                        public void handle(ActionEvent event) {\n+                            label.setText(field.getText());\n+                            tab.setGraphic(label);\n+                        }\n+                    });", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAyNzU1Mg==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543027552", "bodyText": "This could probably be made an else if given the if block is the only thing in the else block", "author": "antares1470", "createdAt": "2020-12-15T03:58:04Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/ImportController.java", "diffHunk": "@@ -0,0 +1,506 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import au.gov.asd.tac.constellation.graph.Attribute;\n+import au.gov.asd.tac.constellation.graph.Graph;\n+import au.gov.asd.tac.constellation.graph.GraphAttribute;\n+import au.gov.asd.tac.constellation.graph.GraphElementType;\n+import au.gov.asd.tac.constellation.graph.GraphReadMethods;\n+import au.gov.asd.tac.constellation.graph.ReadableGraph;\n+import au.gov.asd.tac.constellation.graph.attribute.BooleanAttributeDescription;\n+import au.gov.asd.tac.constellation.graph.file.opener.GraphOpener;\n+import au.gov.asd.tac.constellation.graph.manager.GraphManager;\n+import au.gov.asd.tac.constellation.graph.manager.GraphManagerListener;\n+import au.gov.asd.tac.constellation.graph.schema.SchemaFactory;\n+import au.gov.asd.tac.constellation.graph.schema.attribute.SchemaAttribute;\n+import au.gov.asd.tac.constellation.plugins.PluginException;\n+import au.gov.asd.tac.constellation.plugins.PluginExecutor;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.MalformedURLException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javafx.scene.control.Alert;\n+import javafx.scene.control.Alert.AlertType;\n+import javafx.scene.control.TextArea;\n+\n+public class ImportController {\n+\n+    /**\n+     * Pseudo-attribute to indicate directed transactions.\n+     */\n+    public static final String DIRECTED = \"__directed__\";\n+\n+    /**\n+     * Limit the number of rows shown in the preview.\n+     */\n+    private static final int PREVIEW_ROW_LIMIT = 100;\n+\n+    private final JDBCImporterStage stage;\n+    private JDBCConnection connection;\n+    private String query;\n+    private String username;\n+    private String password;\n+    private List<String[]> currentData = new ArrayList<>();\n+    private String[] currentColumns = new String[0];\n+    private ConfigurationPane configurationPane;\n+    private boolean schemaInitialised;\n+    private String attributeFilter = \"\";\n+\n+    private ImportDestination<?> currentDestination;\n+    // Attributes that exist in the graph or schema.\n+    private final Map<String, Attribute> autoAddedVertexAttributes;\n+    private final Map<String, Attribute> autoAddedTransactionAttributes;\n+\n+    // Attributes that have been manually added by the user.\n+    private final Map<String, Attribute> manuallyAddedVertexAttributes;\n+    private final Map<String, Attribute> manuallyAddedTransactionAttributes;\n+    private boolean clearManuallyAdded;\n+\n+    private Map<String, Attribute> displayedVertexAttributes;\n+    private Map<String, Attribute> displayedTransactionAttributes;\n+    private final Set<Integer> keys;\n+\n+    public ImportController(final JDBCImporterStage stage) {\n+        this.stage = stage;\n+        schemaInitialised = true;\n+\n+        autoAddedVertexAttributes = new HashMap<>();\n+        autoAddedTransactionAttributes = new HashMap<>();\n+\n+        manuallyAddedVertexAttributes = new HashMap<>();\n+        manuallyAddedTransactionAttributes = new HashMap<>();\n+        clearManuallyAdded = true;\n+\n+        displayedVertexAttributes = new HashMap<>();\n+        displayedTransactionAttributes = new HashMap<>();\n+\n+        keys = new HashSet<>();\n+    }\n+\n+    public JDBCImporterStage getStage() {\n+        return stage;\n+    }\n+\n+    public ConfigurationPane getConfigurationPane() {\n+        return configurationPane;\n+    }\n+\n+    public void setConfigurationPane(final ConfigurationPane configurationPane) {\n+        this.configurationPane = configurationPane;\n+        if (currentDestination != null) {\n+            setDestination(currentDestination);\n+        }\n+    }\n+\n+    public boolean hasDBConnection() {\n+        return !(connection == null);\n+    }\n+\n+    public void setDBConnection(final JDBCConnection connection) {\n+        this.connection = connection;\n+    }\n+\n+    public void setQuery(final String query) {\n+        this.query = query;\n+    }\n+\n+    public void setUsername(final String username) {\n+        this.username = username;\n+    }\n+\n+    public void setPassword(final String password) {\n+        this.password = password;\n+    }\n+\n+    /**\n+     * Whether the ImportController should clear the manually added attributes\n+     * in setDestination().\n+     * <p>\n+     * Defaults to true, but when attributes have been added manually by a\n+     * loaded template, should be false.\n+     *\n+     * @param b True to cause the manually added attributes to be cleared, false\n+     * otherwise.\n+     */\n+    public void setClearManuallyAdded(final boolean b) {\n+        clearManuallyAdded = b;\n+    }\n+\n+    public void setDestination(final ImportDestination<?> destination) {\n+        if (destination != null) {\n+            currentDestination = destination;\n+        }\n+        if (currentDestination == null) {\n+            return;\n+        }\n+\n+        // Clearing the manually added attributes removes them when loading a template.\n+        // The destination is set with clearmanuallyAdded true before loading the\n+        // template, so there are no other left-over attributes to clear out after\n+        // loading a template.\n+        if (clearManuallyAdded) {\n+            manuallyAddedVertexAttributes.clear();\n+            manuallyAddedTransactionAttributes.clear();\n+        }\n+        keys.clear();\n+\n+        final boolean showSchemaAttributes = true;\n+        loadAllSchemaAttributes(currentDestination, showSchemaAttributes);\n+\n+        updateDisplayedAttributes();\n+    }\n+\n+    /**\n+     * Load all the schema attributes of the graph\n+     *\n+     * @param destination the destination for the imported data.\n+     * @param showSchemaAttributes specifies whether schema attributes should be\n+     * included.\n+     */\n+    public void loadAllSchemaAttributes(final ImportDestination<?> destination, final boolean showSchemaAttributes) {\n+        final Graph graph = destination.getGraph();\n+        final ReadableGraph rg = graph.getReadableGraph();\n+        try {\n+            updateAutoAddedAttributes(GraphElementType.VERTEX, autoAddedVertexAttributes, rg, showSchemaAttributes);\n+            updateAutoAddedAttributes(GraphElementType.TRANSACTION, autoAddedTransactionAttributes, rg, showSchemaAttributes);\n+        } finally {\n+            rg.release();\n+        }\n+    }\n+\n+    /**\n+     * True if the specified attribute is known, false otherwise.\n+     * <p>\n+     * Only the auto added attributes are checked.\n+     *\n+     * @param elementType The element type of the attribute.\n+     * @param label The attribute label.\n+     *\n+     * @return True if the specified attribute is known, false otherwise.\n+     */\n+    public boolean hasAttribute(final GraphElementType elementType, final String label) {\n+        switch (elementType) {\n+            case VERTEX:\n+                return autoAddedVertexAttributes.containsKey(label);\n+            case TRANSACTION:\n+                return autoAddedTransactionAttributes.containsKey(label);\n+            default:\n+                throw new IllegalArgumentException(\"Element type must be VERTEX or TRANSACTION\");\n+        }\n+    }\n+\n+    /**\n+     * Get the specified attribute.\n+     * <p>\n+     * Both the auto added and manually added attributes are checked.\n+     *\n+     * @param elementType The element type of the attribute.\n+     * @param label The attribute label.\n+     *\n+     * @return The specified attribute, or null if the attribute is not found.\n+     */\n+    public Attribute getAttribute(final GraphElementType elementType, final String label) {\n+        switch (elementType) {\n+            case VERTEX:\n+                return autoAddedVertexAttributes.containsKey(label) ? autoAddedVertexAttributes.get(label) : manuallyAddedVertexAttributes.get(label);\n+            case TRANSACTION:\n+                return autoAddedTransactionAttributes.containsKey(label) ? autoAddedTransactionAttributes.get(label) : manuallyAddedTransactionAttributes.get(label);\n+            default:\n+                throw new IllegalArgumentException(\"Element type must be VERTEX or TRANSACTION\");\n+        }\n+    }\n+\n+    /**\n+     * Get the attributes that will automatically be added to the attribute\n+     * list.\n+     *\n+     * @param elementType\n+     * @param attributes\n+     * @param rg\n+     */\n+    private void updateAutoAddedAttributes(final GraphElementType elementType, final Map<String, Attribute> attributes, final GraphReadMethods rg, final boolean showSchemaAttributes) {\n+        attributes.clear();\n+\n+        // Add attributes from the graph\n+        final int attributeCount = rg.getAttributeCount(elementType);\n+        for (int i = 0; i < attributeCount; i++) {\n+            final int attributeId = rg.getAttribute(elementType, i);\n+            final Attribute attribute = new GraphAttribute(rg, attributeId);\n+            attributes.put(attribute.getName(), attribute);\n+        }\n+\n+        // Add attributes from the schema\n+        if (showSchemaAttributes && rg.getSchema() != null) {\n+            final SchemaFactory factory = rg.getSchema().getFactory();\n+            for (final SchemaAttribute sattr : factory.getRegisteredAttributes(elementType).values()) {\n+                final Attribute attribute = new GraphAttribute(elementType, sattr.getAttributeType(), sattr.getName(), sattr.getDescription());\n+                if (!attributes.containsKey(attribute.getName())) {\n+                    attributes.put(attribute.getName(), attribute);\n+                }\n+            }\n+        }\n+\n+        // Add pseudo-attributes\n+        if (elementType == GraphElementType.TRANSACTION) {\n+            final Attribute attribute = new GraphAttribute(elementType, BooleanAttributeDescription.ATTRIBUTE_NAME, DIRECTED, \"Is this transaction directed?\");\n+            attributes.put(attribute.getName(), attribute);\n+        }\n+\n+        // Add primary keys\n+        for (final int key : rg.getPrimaryKey(elementType)) {\n+            keys.add(key);\n+        }\n+    }\n+\n+    public void deleteAttribute(final Attribute attribute) {\n+        if (attribute.getElementType() == GraphElementType.VERTEX) {\n+            manuallyAddedVertexAttributes.remove(attribute.getName());\n+        } else {\n+            manuallyAddedTransactionAttributes.remove(attribute.getName());\n+        }\n+\n+        if (configurationPane != null) {\n+            configurationPane.deleteAttribute(attribute);\n+        }\n+    }\n+\n+    public void updateDisplayedAttributes() {\n+        if (configurationPane != null) {\n+\n+            displayedVertexAttributes = createDisplayedAttributes(autoAddedVertexAttributes, manuallyAddedVertexAttributes);\n+            displayedTransactionAttributes = createDisplayedAttributes(autoAddedTransactionAttributes, manuallyAddedTransactionAttributes);\n+\n+            for (final Attribute attribute : configurationPane.getAllocatedAttributes()) {\n+                if (attribute.getElementType() == GraphElementType.VERTEX) {\n+                    if (!displayedVertexAttributes.containsKey(attribute.getName())) {\n+                        final Attribute newAttribute = new NewAttribute(attribute);\n+                        displayedVertexAttributes.put(newAttribute.getName(), newAttribute);\n+                    }\n+                } else {\n+                    if (!displayedTransactionAttributes.containsKey(attribute.getName())) {", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAyOTA4Mg==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543029082", "bodyText": "final", "author": "antares1470", "createdAt": "2020-12-15T04:03:02Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/ImportController.java", "diffHunk": "@@ -0,0 +1,506 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import au.gov.asd.tac.constellation.graph.Attribute;\n+import au.gov.asd.tac.constellation.graph.Graph;\n+import au.gov.asd.tac.constellation.graph.GraphAttribute;\n+import au.gov.asd.tac.constellation.graph.GraphElementType;\n+import au.gov.asd.tac.constellation.graph.GraphReadMethods;\n+import au.gov.asd.tac.constellation.graph.ReadableGraph;\n+import au.gov.asd.tac.constellation.graph.attribute.BooleanAttributeDescription;\n+import au.gov.asd.tac.constellation.graph.file.opener.GraphOpener;\n+import au.gov.asd.tac.constellation.graph.manager.GraphManager;\n+import au.gov.asd.tac.constellation.graph.manager.GraphManagerListener;\n+import au.gov.asd.tac.constellation.graph.schema.SchemaFactory;\n+import au.gov.asd.tac.constellation.graph.schema.attribute.SchemaAttribute;\n+import au.gov.asd.tac.constellation.plugins.PluginException;\n+import au.gov.asd.tac.constellation.plugins.PluginExecutor;\n+import java.io.IOException;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.MalformedURLException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.ResultSetMetaData;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javafx.scene.control.Alert;\n+import javafx.scene.control.Alert.AlertType;\n+import javafx.scene.control.TextArea;\n+\n+public class ImportController {\n+\n+    /**\n+     * Pseudo-attribute to indicate directed transactions.\n+     */\n+    public static final String DIRECTED = \"__directed__\";\n+\n+    /**\n+     * Limit the number of rows shown in the preview.\n+     */\n+    private static final int PREVIEW_ROW_LIMIT = 100;\n+\n+    private final JDBCImporterStage stage;\n+    private JDBCConnection connection;\n+    private String query;\n+    private String username;\n+    private String password;\n+    private List<String[]> currentData = new ArrayList<>();\n+    private String[] currentColumns = new String[0];\n+    private ConfigurationPane configurationPane;\n+    private boolean schemaInitialised;\n+    private String attributeFilter = \"\";\n+\n+    private ImportDestination<?> currentDestination;\n+    // Attributes that exist in the graph or schema.\n+    private final Map<String, Attribute> autoAddedVertexAttributes;\n+    private final Map<String, Attribute> autoAddedTransactionAttributes;\n+\n+    // Attributes that have been manually added by the user.\n+    private final Map<String, Attribute> manuallyAddedVertexAttributes;\n+    private final Map<String, Attribute> manuallyAddedTransactionAttributes;\n+    private boolean clearManuallyAdded;\n+\n+    private Map<String, Attribute> displayedVertexAttributes;\n+    private Map<String, Attribute> displayedTransactionAttributes;\n+    private final Set<Integer> keys;\n+\n+    public ImportController(final JDBCImporterStage stage) {\n+        this.stage = stage;\n+        schemaInitialised = true;\n+\n+        autoAddedVertexAttributes = new HashMap<>();\n+        autoAddedTransactionAttributes = new HashMap<>();\n+\n+        manuallyAddedVertexAttributes = new HashMap<>();\n+        manuallyAddedTransactionAttributes = new HashMap<>();\n+        clearManuallyAdded = true;\n+\n+        displayedVertexAttributes = new HashMap<>();\n+        displayedTransactionAttributes = new HashMap<>();\n+\n+        keys = new HashSet<>();\n+    }\n+\n+    public JDBCImporterStage getStage() {\n+        return stage;\n+    }\n+\n+    public ConfigurationPane getConfigurationPane() {\n+        return configurationPane;\n+    }\n+\n+    public void setConfigurationPane(final ConfigurationPane configurationPane) {\n+        this.configurationPane = configurationPane;\n+        if (currentDestination != null) {\n+            setDestination(currentDestination);\n+        }\n+    }\n+\n+    public boolean hasDBConnection() {\n+        return !(connection == null);\n+    }\n+\n+    public void setDBConnection(final JDBCConnection connection) {\n+        this.connection = connection;\n+    }\n+\n+    public void setQuery(final String query) {\n+        this.query = query;\n+    }\n+\n+    public void setUsername(final String username) {\n+        this.username = username;\n+    }\n+\n+    public void setPassword(final String password) {\n+        this.password = password;\n+    }\n+\n+    /**\n+     * Whether the ImportController should clear the manually added attributes\n+     * in setDestination().\n+     * <p>\n+     * Defaults to true, but when attributes have been added manually by a\n+     * loaded template, should be false.\n+     *\n+     * @param b True to cause the manually added attributes to be cleared, false\n+     * otherwise.\n+     */\n+    public void setClearManuallyAdded(final boolean b) {\n+        clearManuallyAdded = b;\n+    }\n+\n+    public void setDestination(final ImportDestination<?> destination) {\n+        if (destination != null) {\n+            currentDestination = destination;\n+        }\n+        if (currentDestination == null) {\n+            return;\n+        }\n+\n+        // Clearing the manually added attributes removes them when loading a template.\n+        // The destination is set with clearmanuallyAdded true before loading the\n+        // template, so there are no other left-over attributes to clear out after\n+        // loading a template.\n+        if (clearManuallyAdded) {\n+            manuallyAddedVertexAttributes.clear();\n+            manuallyAddedTransactionAttributes.clear();\n+        }\n+        keys.clear();\n+\n+        final boolean showSchemaAttributes = true;\n+        loadAllSchemaAttributes(currentDestination, showSchemaAttributes);\n+\n+        updateDisplayedAttributes();\n+    }\n+\n+    /**\n+     * Load all the schema attributes of the graph\n+     *\n+     * @param destination the destination for the imported data.\n+     * @param showSchemaAttributes specifies whether schema attributes should be\n+     * included.\n+     */\n+    public void loadAllSchemaAttributes(final ImportDestination<?> destination, final boolean showSchemaAttributes) {\n+        final Graph graph = destination.getGraph();\n+        final ReadableGraph rg = graph.getReadableGraph();\n+        try {\n+            updateAutoAddedAttributes(GraphElementType.VERTEX, autoAddedVertexAttributes, rg, showSchemaAttributes);\n+            updateAutoAddedAttributes(GraphElementType.TRANSACTION, autoAddedTransactionAttributes, rg, showSchemaAttributes);\n+        } finally {\n+            rg.release();\n+        }\n+    }\n+\n+    /**\n+     * True if the specified attribute is known, false otherwise.\n+     * <p>\n+     * Only the auto added attributes are checked.\n+     *\n+     * @param elementType The element type of the attribute.\n+     * @param label The attribute label.\n+     *\n+     * @return True if the specified attribute is known, false otherwise.\n+     */\n+    public boolean hasAttribute(final GraphElementType elementType, final String label) {\n+        switch (elementType) {\n+            case VERTEX:\n+                return autoAddedVertexAttributes.containsKey(label);\n+            case TRANSACTION:\n+                return autoAddedTransactionAttributes.containsKey(label);\n+            default:\n+                throw new IllegalArgumentException(\"Element type must be VERTEX or TRANSACTION\");\n+        }\n+    }\n+\n+    /**\n+     * Get the specified attribute.\n+     * <p>\n+     * Both the auto added and manually added attributes are checked.\n+     *\n+     * @param elementType The element type of the attribute.\n+     * @param label The attribute label.\n+     *\n+     * @return The specified attribute, or null if the attribute is not found.\n+     */\n+    public Attribute getAttribute(final GraphElementType elementType, final String label) {\n+        switch (elementType) {\n+            case VERTEX:\n+                return autoAddedVertexAttributes.containsKey(label) ? autoAddedVertexAttributes.get(label) : manuallyAddedVertexAttributes.get(label);\n+            case TRANSACTION:\n+                return autoAddedTransactionAttributes.containsKey(label) ? autoAddedTransactionAttributes.get(label) : manuallyAddedTransactionAttributes.get(label);\n+            default:\n+                throw new IllegalArgumentException(\"Element type must be VERTEX or TRANSACTION\");\n+        }\n+    }\n+\n+    /**\n+     * Get the attributes that will automatically be added to the attribute\n+     * list.\n+     *\n+     * @param elementType\n+     * @param attributes\n+     * @param rg\n+     */\n+    private void updateAutoAddedAttributes(final GraphElementType elementType, final Map<String, Attribute> attributes, final GraphReadMethods rg, final boolean showSchemaAttributes) {\n+        attributes.clear();\n+\n+        // Add attributes from the graph\n+        final int attributeCount = rg.getAttributeCount(elementType);\n+        for (int i = 0; i < attributeCount; i++) {\n+            final int attributeId = rg.getAttribute(elementType, i);\n+            final Attribute attribute = new GraphAttribute(rg, attributeId);\n+            attributes.put(attribute.getName(), attribute);\n+        }\n+\n+        // Add attributes from the schema\n+        if (showSchemaAttributes && rg.getSchema() != null) {\n+            final SchemaFactory factory = rg.getSchema().getFactory();\n+            for (final SchemaAttribute sattr : factory.getRegisteredAttributes(elementType).values()) {\n+                final Attribute attribute = new GraphAttribute(elementType, sattr.getAttributeType(), sattr.getName(), sattr.getDescription());\n+                if (!attributes.containsKey(attribute.getName())) {\n+                    attributes.put(attribute.getName(), attribute);\n+                }\n+            }\n+        }\n+\n+        // Add pseudo-attributes\n+        if (elementType == GraphElementType.TRANSACTION) {\n+            final Attribute attribute = new GraphAttribute(elementType, BooleanAttributeDescription.ATTRIBUTE_NAME, DIRECTED, \"Is this transaction directed?\");\n+            attributes.put(attribute.getName(), attribute);\n+        }\n+\n+        // Add primary keys\n+        for (final int key : rg.getPrimaryKey(elementType)) {\n+            keys.add(key);\n+        }\n+    }\n+\n+    public void deleteAttribute(final Attribute attribute) {\n+        if (attribute.getElementType() == GraphElementType.VERTEX) {\n+            manuallyAddedVertexAttributes.remove(attribute.getName());\n+        } else {\n+            manuallyAddedTransactionAttributes.remove(attribute.getName());\n+        }\n+\n+        if (configurationPane != null) {\n+            configurationPane.deleteAttribute(attribute);\n+        }\n+    }\n+\n+    public void updateDisplayedAttributes() {\n+        if (configurationPane != null) {\n+\n+            displayedVertexAttributes = createDisplayedAttributes(autoAddedVertexAttributes, manuallyAddedVertexAttributes);\n+            displayedTransactionAttributes = createDisplayedAttributes(autoAddedTransactionAttributes, manuallyAddedTransactionAttributes);\n+\n+            for (final Attribute attribute : configurationPane.getAllocatedAttributes()) {\n+                if (attribute.getElementType() == GraphElementType.VERTEX) {\n+                    if (!displayedVertexAttributes.containsKey(attribute.getName())) {\n+                        final Attribute newAttribute = new NewAttribute(attribute);\n+                        displayedVertexAttributes.put(newAttribute.getName(), newAttribute);\n+                    }\n+                } else {\n+                    if (!displayedTransactionAttributes.containsKey(attribute.getName())) {\n+                        final Attribute newAttribute = new NewAttribute(attribute);\n+                        displayedTransactionAttributes.put(newAttribute.getName(), newAttribute);\n+                    }\n+                }\n+            }\n+\n+            configurationPane.setDisplayedAttributes(displayedVertexAttributes, displayedTransactionAttributes, keys);\n+        }\n+    }\n+\n+    private Map<String, Attribute> createDisplayedAttributes(final Map<String, Attribute> autoAddedAttributes, final Map<String, Attribute> manuallyAddedAttributes) {\n+        final Map<String, Attribute> displayedAttributes = new HashMap<>();\n+        if (attributeFilter != null && attributeFilter.length() > 0) {\n+            for (final String attributeName : autoAddedAttributes.keySet()) {\n+                if (attributeName.toLowerCase().contains(attributeFilter.toLowerCase())) {\n+                    displayedAttributes.put(attributeName, autoAddedAttributes.get(attributeName));\n+                }\n+            }\n+            for (final String attributeName : manuallyAddedAttributes.keySet()) {\n+                if (attributeName.toLowerCase().contains(attributeFilter.toLowerCase())) {\n+                    displayedAttributes.put(attributeName, manuallyAddedAttributes.get(attributeName));\n+                }\n+            }\n+        } else {\n+            displayedAttributes.putAll(manuallyAddedAttributes);\n+            displayedAttributes.putAll(autoAddedAttributes);\n+        }\n+        return displayedAttributes;\n+    }\n+\n+    public void createManualAttribute(final Attribute attribute) {\n+        final Map<String, Attribute> attributes = attribute.getElementType() == GraphElementType.VERTEX ? manuallyAddedVertexAttributes : manuallyAddedTransactionAttributes;\n+\n+        if (!attributes.containsKey(attribute.getName())) {\n+            attributes.put(attribute.getName(), attribute);\n+\n+            if (configurationPane != null) {\n+                updateDisplayedAttributes();\n+            }\n+        }\n+    }\n+\n+    public String showSetDefaultValueDialog(final String attributeName, final String currentDefaultValue) {\n+        final DefaultAttributeValueDialog dialog = new DefaultAttributeValueDialog(stage, attributeName, currentDefaultValue);\n+        dialog.showAndWait();\n+        return dialog.getDefaultValue();\n+    }\n+\n+    public ImportDestination<?> getDestination() {\n+        return currentDestination;\n+    }\n+\n+    /**\n+     * A List&lt;ImportDefinition&gt; where each list element corresponds to a\n+     * RunPane tab.\n+     *\n+     * @return A List&lt;ImportDefinition&gt; where each list element\n+     * corresponds to a RunPane tab.\n+     */\n+    public List<ImportDefinition> getDefinitions() {\n+        return configurationPane.createDefinitions();\n+    }\n+\n+    public void processImport() throws IOException, InterruptedException, PluginException {\n+\n+        final List<ImportDefinition> definitions = configurationPane.createDefinitions();\n+\n+        final Graph importGraph = currentDestination.getGraph();\n+        final boolean schema = schemaInitialised;\n+\n+        if (currentDestination instanceof SchemaDestination) {\n+            GraphManager.getDefault().addGraphManagerListener(new GraphManagerListener() {\n+                boolean opened = false;\n+\n+                @Override\n+                public void graphOpened(Graph graph) {\n+                }\n+\n+                @Override\n+                public void graphClosed(Graph graph) {\n+                }\n+\n+                @Override\n+                public synchronized void newActiveGraph(Graph graph) {\n+                    if (graph == importGraph && !opened) {\n+                        opened = true;\n+                        GraphManager.getDefault().removeGraphManagerListener(this);\n+                        PluginExecutor.startWith(ImportJDBCPlugin.class.getName(), false)\n+                                .set(ImportJDBCPlugin.DEFINITIONS_PARAMETER_ID, definitions)\n+                                .set(ImportJDBCPlugin.CONNECTION_PARAMETER_ID, connection)\n+                                .set(ImportJDBCPlugin.SCHEMA_PARAMETER_ID, schema)\n+                                .set(ImportJDBCPlugin.QUERY_PARAMETER_ID, query)\n+                                .set(ImportJDBCPlugin.USERNAME_PARAMETER_ID, username)\n+                                .set(ImportJDBCPlugin.PASSWORD_PARAMETER_ID, password)\n+                                .executeWriteLater(importGraph);\n+                    }\n+                }\n+\n+            });\n+            GraphOpener.getDefault().openGraph(importGraph, \"graph\");\n+        } else {\n+            PluginExecutor.startWith(ImportJDBCPlugin.class.getName(), false)\n+                    .set(ImportJDBCPlugin.DEFINITIONS_PARAMETER_ID, definitions)\n+                    .set(ImportJDBCPlugin.CONNECTION_PARAMETER_ID, connection)\n+                    .set(ImportJDBCPlugin.QUERY_PARAMETER_ID, query)\n+                    .set(ImportJDBCPlugin.USERNAME_PARAMETER_ID, username)\n+                    .set(ImportJDBCPlugin.PASSWORD_PARAMETER_ID, password)\n+                    .set(ImportJDBCPlugin.SCHEMA_PARAMETER_ID, schema)\n+                    .executeWriteLater(importGraph);\n+        }\n+    }\n+\n+    public void cancelImport() {\n+        stage.close();\n+    }\n+\n+    public void updateSampleData() {\n+        if (connection == null || query == null || query.isBlank()) {\n+            currentColumns = new String[0];\n+            currentData = new ArrayList<>();\n+        } else {\n+            try {\n+                try (final Connection dbConnection = connection.getConnection(username, password)) {\n+                    if (!query.toLowerCase().contains(\" limit \") && query.toLowerCase().startsWith(\"select \")) {\n+                        query += \" limit \" + PREVIEW_ROW_LIMIT;\n+                    }\n+                    try (final PreparedStatement ps = dbConnection.prepareStatement(query)) {\n+                        try (final ResultSet rs = ps.executeQuery()) {\n+                            int count = 0;\n+                            currentData.clear();\n+                            while (rs.next() && count < PREVIEW_ROW_LIMIT) {\n+                                count++;\n+                                final String[] d = new String[ps.getMetaData().getColumnCount()];\n+                                for (int i = 0; i < ps.getMetaData().getColumnCount(); i++) {\n+                                    d[i] = rs.getString(i + 1);\n+                                }\n+                                currentData.add(d);\n+                            }\n+                            currentColumns = new String[ps.getMetaData().getColumnCount() + 1];\n+                            currentColumns[0] = \"Row\";\n+                            final ResultSetMetaData rsmd = ps.getMetaData();\n+                            for (int i = 0; i < rsmd.getColumnCount(); i++) {\n+                                currentColumns[i + 1] = rsmd.getColumnName(i + 1);\n+                            }\n+                        }\n+                    }\n+                }\n+            } catch (MalformedURLException | ClassNotFoundException | SQLException | NoSuchMethodException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzMDE0MA==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543030140", "bodyText": "final", "author": "antares1470", "createdAt": "2020-12-15T04:06:21Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/ImportJDBCPlugin.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import au.gov.asd.tac.constellation.graph.Attribute;\n+import au.gov.asd.tac.constellation.graph.Graph;\n+import au.gov.asd.tac.constellation.graph.GraphElementType;\n+import au.gov.asd.tac.constellation.graph.GraphWriteMethods;\n+import au.gov.asd.tac.constellation.graph.schema.visual.concept.VisualConcept;\n+import au.gov.asd.tac.constellation.plugins.Plugin;\n+import au.gov.asd.tac.constellation.plugins.PluginException;\n+import au.gov.asd.tac.constellation.plugins.PluginExecutor;\n+import au.gov.asd.tac.constellation.plugins.PluginInfo;\n+import au.gov.asd.tac.constellation.plugins.PluginInteraction;\n+import au.gov.asd.tac.constellation.plugins.PluginType;\n+import au.gov.asd.tac.constellation.plugins.arrangements.AbstractInclusionGraph;\n+import au.gov.asd.tac.constellation.plugins.arrangements.ArrangementPluginRegistry;\n+import au.gov.asd.tac.constellation.plugins.arrangements.VertexListInclusionGraph;\n+import au.gov.asd.tac.constellation.plugins.parameters.PluginParameter;\n+import au.gov.asd.tac.constellation.plugins.parameters.PluginParameters;\n+import au.gov.asd.tac.constellation.plugins.parameters.types.BooleanParameterType;\n+import au.gov.asd.tac.constellation.plugins.parameters.types.BooleanParameterType.BooleanParameterValue;\n+import au.gov.asd.tac.constellation.plugins.parameters.types.ObjectParameterType;\n+import au.gov.asd.tac.constellation.plugins.parameters.types.ObjectParameterType.ObjectParameterValue;\n+import au.gov.asd.tac.constellation.plugins.parameters.types.PasswordParameterType;\n+import au.gov.asd.tac.constellation.plugins.parameters.types.PasswordParameterValue;\n+import au.gov.asd.tac.constellation.plugins.parameters.types.StringParameterType;\n+import au.gov.asd.tac.constellation.plugins.parameters.types.StringParameterValue;\n+import au.gov.asd.tac.constellation.plugins.templates.SimpleEditPlugin;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.MalformedURLException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.openide.util.NbBundle;\n+import org.openide.util.lookup.ServiceProvider;\n+\n+@ServiceProvider(service = Plugin.class)\n+@PluginInfo(pluginType = PluginType.IMPORT, tags = {\"IMPORT\"})\n+@NbBundle.Messages(\"ImportJDBCPlugin=Import from JDBC Sources\")\n+public class ImportJDBCPlugin extends SimpleEditPlugin {\n+\n+    /**\n+     * When an attribute is not assigned to a column, the value is -145355 so\n+     * its easier to track down if there is an error.\n+     */\n+    public static final int ATTRIBUTE_NOT_ASSIGNED_TO_COLUMN = -145355;\n+\n+    public static final String QUERY_PARAMETER_ID = PluginParameter.buildId(ImportJDBCPlugin.class, \"query\");\n+    public static final String USERNAME_PARAMETER_ID = PluginParameter.buildId(ImportJDBCPlugin.class, \"username\");\n+    public static final String PASSWORD_PARAMETER_ID = PluginParameter.buildId(ImportJDBCPlugin.class, \"password\");\n+    public static final String CONNECTION_PARAMETER_ID = PluginParameter.buildId(ImportJDBCPlugin.class, \"connection\");\n+    public static final String SCHEMA_PARAMETER_ID = PluginParameter.buildId(ImportJDBCPlugin.class, \"schema\");\n+    public static final String DEFINITIONS_PARAMETER_ID = PluginParameter.buildId(ImportJDBCPlugin.class, \"definitions\");\n+\n+    @Override\n+    public PluginParameters createParameters() {\n+        final PluginParameters params = new PluginParameters();\n+\n+        final PluginParameter<ObjectParameterValue> connectionParam = ObjectParameterType.build(CONNECTION_PARAMETER_ID);\n+        connectionParam.setName(\"Connection\");\n+        connectionParam.setDescription(\"The connection to use\");\n+        connectionParam.setObjectValue(null);\n+        params.addParameter(connectionParam);\n+\n+        final PluginParameter<StringParameterValue> queryParam = StringParameterType.build(QUERY_PARAMETER_ID);\n+        queryParam.setName(\"Query\");\n+        queryParam.setDescription(\"The query to run\");\n+        params.addParameter(queryParam);\n+\n+        final PluginParameter<StringParameterValue> usernameParam = StringParameterType.build(USERNAME_PARAMETER_ID);\n+        usernameParam.setName(\"Username\");\n+        params.addParameter(usernameParam);\n+\n+        final PluginParameter<PasswordParameterValue> passwordParam = PasswordParameterType.build(PASSWORD_PARAMETER_ID);\n+        passwordParam.setName(\"Password\");\n+        passwordParam.setDescription(\"Password\");\n+        params.addParameter(passwordParam);\n+\n+        final PluginParameter<BooleanParameterValue> schemaParam = BooleanParameterType.build(SCHEMA_PARAMETER_ID);\n+        schemaParam.setName(\"Complete with Schema\");\n+        schemaParam.setDescription(\"True if the graph should run the schema rules, default is True\");\n+        schemaParam.setBooleanValue(true);\n+        params.addParameter(schemaParam);\n+\n+        final PluginParameter<ObjectParameterValue> definitionParam = ObjectParameterType.build(DEFINITIONS_PARAMETER_ID);\n+        definitionParam.setName(\"Definitions\");\n+        definitionParam.setDescription(\"The list of definitions that extend ImportDefinition\");\n+        definitionParam.setObjectValue(null);\n+        params.addParameter(definitionParam);\n+\n+        return params;\n+    }\n+\n+    @Override\n+    protected void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException, PluginException {\n+        final JDBCConnection connection = (JDBCConnection) parameters.getParameters().get(CONNECTION_PARAMETER_ID).getObjectValue();\n+        final String query = parameters.getParameters().get(QUERY_PARAMETER_ID).getStringValue();\n+        final List<ImportDefinition> definitions = (List<ImportDefinition>) parameters.getParameters().get(DEFINITIONS_PARAMETER_ID).getObjectValue();\n+        final Boolean initialiseWithSchema = parameters.getParameters().get(SCHEMA_PARAMETER_ID).getBooleanValue();\n+        final List<Integer> newVertices = new ArrayList<>();\n+        boolean positionalAtrributesExist = false;\n+\n+        final String username = parameters.getParameters().get(USERNAME_PARAMETER_ID).getStringValue();\n+        final String password = parameters.getParameters().get(PASSWORD_PARAMETER_ID).getStringValue();\n+\n+        if (connection != null && query != null && !query.isBlank()) {\n+            final List<String[]> data = new ArrayList<>();\n+            try {\n+                try (final Connection dbConnection = connection.getConnection(username, password)) {\n+                    try (final PreparedStatement ps = dbConnection.prepareStatement(query)) {\n+                        try (final ResultSet rs = ps.executeQuery()) {\n+                            while (rs.next()) {\n+                                final String[] d = new String[ps.getMetaData().getColumnCount()];\n+                                for (int i = 0; i < ps.getMetaData().getColumnCount(); i++) {\n+                                    d[i] = rs.getString(i + 1);\n+                                }\n+                                data.add(d);\n+                            }\n+                        }\n+                    }\n+                }\n+            } catch (MalformedURLException | ClassNotFoundException | SQLException | NoSuchMethodException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzMDk1Mg==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543030952", "bodyText": "This could be simplified by or'ing the 2 boolean expressions:\nreturn srcAttributeDefinitions... || destAttributeDefinitions...", "author": "antares1470", "createdAt": "2020-12-15T04:08:54Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/ImportJDBCPlugin.java", "diffHunk": "@@ -0,0 +1,305 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import au.gov.asd.tac.constellation.graph.Attribute;\n+import au.gov.asd.tac.constellation.graph.Graph;\n+import au.gov.asd.tac.constellation.graph.GraphElementType;\n+import au.gov.asd.tac.constellation.graph.GraphWriteMethods;\n+import au.gov.asd.tac.constellation.graph.schema.visual.concept.VisualConcept;\n+import au.gov.asd.tac.constellation.plugins.Plugin;\n+import au.gov.asd.tac.constellation.plugins.PluginException;\n+import au.gov.asd.tac.constellation.plugins.PluginExecutor;\n+import au.gov.asd.tac.constellation.plugins.PluginInfo;\n+import au.gov.asd.tac.constellation.plugins.PluginInteraction;\n+import au.gov.asd.tac.constellation.plugins.PluginType;\n+import au.gov.asd.tac.constellation.plugins.arrangements.AbstractInclusionGraph;\n+import au.gov.asd.tac.constellation.plugins.arrangements.ArrangementPluginRegistry;\n+import au.gov.asd.tac.constellation.plugins.arrangements.VertexListInclusionGraph;\n+import au.gov.asd.tac.constellation.plugins.parameters.PluginParameter;\n+import au.gov.asd.tac.constellation.plugins.parameters.PluginParameters;\n+import au.gov.asd.tac.constellation.plugins.parameters.types.BooleanParameterType;\n+import au.gov.asd.tac.constellation.plugins.parameters.types.BooleanParameterType.BooleanParameterValue;\n+import au.gov.asd.tac.constellation.plugins.parameters.types.ObjectParameterType;\n+import au.gov.asd.tac.constellation.plugins.parameters.types.ObjectParameterType.ObjectParameterValue;\n+import au.gov.asd.tac.constellation.plugins.parameters.types.PasswordParameterType;\n+import au.gov.asd.tac.constellation.plugins.parameters.types.PasswordParameterValue;\n+import au.gov.asd.tac.constellation.plugins.parameters.types.StringParameterType;\n+import au.gov.asd.tac.constellation.plugins.parameters.types.StringParameterValue;\n+import au.gov.asd.tac.constellation.plugins.templates.SimpleEditPlugin;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.MalformedURLException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import org.openide.util.NbBundle;\n+import org.openide.util.lookup.ServiceProvider;\n+\n+@ServiceProvider(service = Plugin.class)\n+@PluginInfo(pluginType = PluginType.IMPORT, tags = {\"IMPORT\"})\n+@NbBundle.Messages(\"ImportJDBCPlugin=Import from JDBC Sources\")\n+public class ImportJDBCPlugin extends SimpleEditPlugin {\n+\n+    /**\n+     * When an attribute is not assigned to a column, the value is -145355 so\n+     * its easier to track down if there is an error.\n+     */\n+    public static final int ATTRIBUTE_NOT_ASSIGNED_TO_COLUMN = -145355;\n+\n+    public static final String QUERY_PARAMETER_ID = PluginParameter.buildId(ImportJDBCPlugin.class, \"query\");\n+    public static final String USERNAME_PARAMETER_ID = PluginParameter.buildId(ImportJDBCPlugin.class, \"username\");\n+    public static final String PASSWORD_PARAMETER_ID = PluginParameter.buildId(ImportJDBCPlugin.class, \"password\");\n+    public static final String CONNECTION_PARAMETER_ID = PluginParameter.buildId(ImportJDBCPlugin.class, \"connection\");\n+    public static final String SCHEMA_PARAMETER_ID = PluginParameter.buildId(ImportJDBCPlugin.class, \"schema\");\n+    public static final String DEFINITIONS_PARAMETER_ID = PluginParameter.buildId(ImportJDBCPlugin.class, \"definitions\");\n+\n+    @Override\n+    public PluginParameters createParameters() {\n+        final PluginParameters params = new PluginParameters();\n+\n+        final PluginParameter<ObjectParameterValue> connectionParam = ObjectParameterType.build(CONNECTION_PARAMETER_ID);\n+        connectionParam.setName(\"Connection\");\n+        connectionParam.setDescription(\"The connection to use\");\n+        connectionParam.setObjectValue(null);\n+        params.addParameter(connectionParam);\n+\n+        final PluginParameter<StringParameterValue> queryParam = StringParameterType.build(QUERY_PARAMETER_ID);\n+        queryParam.setName(\"Query\");\n+        queryParam.setDescription(\"The query to run\");\n+        params.addParameter(queryParam);\n+\n+        final PluginParameter<StringParameterValue> usernameParam = StringParameterType.build(USERNAME_PARAMETER_ID);\n+        usernameParam.setName(\"Username\");\n+        params.addParameter(usernameParam);\n+\n+        final PluginParameter<PasswordParameterValue> passwordParam = PasswordParameterType.build(PASSWORD_PARAMETER_ID);\n+        passwordParam.setName(\"Password\");\n+        passwordParam.setDescription(\"Password\");\n+        params.addParameter(passwordParam);\n+\n+        final PluginParameter<BooleanParameterValue> schemaParam = BooleanParameterType.build(SCHEMA_PARAMETER_ID);\n+        schemaParam.setName(\"Complete with Schema\");\n+        schemaParam.setDescription(\"True if the graph should run the schema rules, default is True\");\n+        schemaParam.setBooleanValue(true);\n+        params.addParameter(schemaParam);\n+\n+        final PluginParameter<ObjectParameterValue> definitionParam = ObjectParameterType.build(DEFINITIONS_PARAMETER_ID);\n+        definitionParam.setName(\"Definitions\");\n+        definitionParam.setDescription(\"The list of definitions that extend ImportDefinition\");\n+        definitionParam.setObjectValue(null);\n+        params.addParameter(definitionParam);\n+\n+        return params;\n+    }\n+\n+    @Override\n+    protected void edit(final GraphWriteMethods graph, final PluginInteraction interaction, final PluginParameters parameters) throws InterruptedException, PluginException {\n+        final JDBCConnection connection = (JDBCConnection) parameters.getParameters().get(CONNECTION_PARAMETER_ID).getObjectValue();\n+        final String query = parameters.getParameters().get(QUERY_PARAMETER_ID).getStringValue();\n+        final List<ImportDefinition> definitions = (List<ImportDefinition>) parameters.getParameters().get(DEFINITIONS_PARAMETER_ID).getObjectValue();\n+        final Boolean initialiseWithSchema = parameters.getParameters().get(SCHEMA_PARAMETER_ID).getBooleanValue();\n+        final List<Integer> newVertices = new ArrayList<>();\n+        boolean positionalAtrributesExist = false;\n+\n+        final String username = parameters.getParameters().get(USERNAME_PARAMETER_ID).getStringValue();\n+        final String password = parameters.getParameters().get(PASSWORD_PARAMETER_ID).getStringValue();\n+\n+        if (connection != null && query != null && !query.isBlank()) {\n+            final List<String[]> data = new ArrayList<>();\n+            try {\n+                try (final Connection dbConnection = connection.getConnection(username, password)) {\n+                    try (final PreparedStatement ps = dbConnection.prepareStatement(query)) {\n+                        try (final ResultSet rs = ps.executeQuery()) {\n+                            while (rs.next()) {\n+                                final String[] d = new String[ps.getMetaData().getColumnCount()];\n+                                for (int i = 0; i < ps.getMetaData().getColumnCount(); i++) {\n+                                    d[i] = rs.getString(i + 1);\n+                                }\n+                                data.add(d);\n+                            }\n+                        }\n+                    }\n+                }\n+            } catch (MalformedURLException | ClassNotFoundException | SQLException | NoSuchMethodException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {\n+                return;\n+            }\n+\n+            for (final ImportDefinition definition : definitions) {\n+                if (definition.getDefinitions(AttributeType.SOURCE_VERTEX).isEmpty()) {\n+                    if (!definition.getDefinitions(AttributeType.DESTINATION_VERTEX).isEmpty()) {\n+                        processVertices(definition, graph, data, AttributeType.DESTINATION_VERTEX, initialiseWithSchema, interaction, newVertices);\n+                    }\n+                } else if (definition.getDefinitions(AttributeType.DESTINATION_VERTEX).isEmpty()) {\n+                    processVertices(definition, graph, data, AttributeType.SOURCE_VERTEX, initialiseWithSchema, interaction, newVertices);\n+                } else {\n+                    processTransactions(definition, graph, data, initialiseWithSchema, interaction);\n+                }\n+\n+                // Determine if a positional attribute has been defined, if so update the overall flag\n+                final boolean isPositional = attributeDefintionIsPositional(definition.getDefinitions(AttributeType.SOURCE_VERTEX), definition.getDefinitions(AttributeType.DESTINATION_VERTEX));\n+                positionalAtrributesExist = (positionalAtrributesExist || isPositional);\n+            }\n+\n+            // If at least one positional attribute has been received for either the src or destination vertex we will assume that the user is trying to import positions and won't auto arrange\n+            // the graph. This does mean some nodes could sit on top of each other if multiple nodes have the same coordinates.\n+            if (!positionalAtrributesExist) {\n+                interaction.setProgress(1, 1, \"Arranging\", true);\n+\n+                graph.validateKey(GraphElementType.VERTEX, true);\n+                graph.validateKey(GraphElementType.TRANSACTION, true);\n+\n+                // unfortunately need to arrange with pendants and uncollide because grid arranger works based on selection\n+                final VertexListInclusionGraph vlGraph = new VertexListInclusionGraph(graph, AbstractInclusionGraph.Connections.NONE, newVertices);\n+                PluginExecutor.startWith(ArrangementPluginRegistry.GRID_COMPOSITE)\n+                        .followedBy(ArrangementPluginRegistry.PENDANTS)\n+                        .followedBy(ArrangementPluginRegistry.UNCOLLIDE)\n+                        .executeNow(vlGraph.getInclusionGraph());\n+                vlGraph.retrieveCoords();\n+            }\n+        }\n+    }\n+\n+    // If src or destination attribute definitions have been supplied, check them and return true if any of the positional attributes ('x', 'y', or 'z') are included. Positional\n+    // arguments allow the import to define where nodes will be placed on graph. If src or destination definitons do not exist then an empty list should be supplied.\n+    private static boolean attributeDefintionIsPositional(final List<ImportAttributeDefinition> srcAttributeDefinitions, final List<ImportAttributeDefinition> destAttributeDefinitions) {\n+\n+        // Check if srcAttributeDefintions contain positional attributes\n+        if (srcAttributeDefinitions.stream().map(attribute -> attribute.getAttribute().getName()).anyMatch(name -> (VisualConcept.VertexAttribute.X.getName().equals(name) || VisualConcept.VertexAttribute.Y.getName().equals(name) || VisualConcept.VertexAttribute.Z.getName().equals(name)))) {\n+            return true;\n+        }\n+        // Check if destAttributeDefintions contain positional attributes\n+        return destAttributeDefinitions.stream().map(attribute -> attribute.getAttribute().getName()).anyMatch(name -> (VisualConcept.VertexAttribute.X.getName().equals(name) || VisualConcept.VertexAttribute.Y.getName().equals(name) || VisualConcept.VertexAttribute.Z.getName().equals(name)));", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Njk3NzU4Mg==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r546977582", "bodyText": "I changed this to or over the expressions and to me it seems less readable. Can still go ahead with the change", "author": "aldebaran30701", "createdAt": "2020-12-21T23:14:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzMDk1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYzOTI4OA==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r554639288", "bodyText": "You can always put the 2nd expression on a new line. Personally I prefer my suggestion as it removes the need for the if block", "author": "antares1470", "createdAt": "2021-01-10T23:25:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzMDk1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NTM0NTM4MQ==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r555345381", "bodyText": "Done, I've also added to the whatsnew.txt and fixed that last naming convention issue.", "author": "aldebaran30701", "createdAt": "2021-01-11T21:17:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzMDk1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzMjI3Ng==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543032276", "bodyText": "can convert this to a tertiary statement: getGraphic().setStyle(columnFailed ? .. : ...)", "author": "antares1470", "createdAt": "2020-12-15T04:13:08Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/ImportTableColumn.java", "diffHunk": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import au.gov.asd.tac.constellation.graph.attribute.AttributeDescription;\n+import au.gov.asd.tac.constellation.graph.attribute.AttributeRegistry;\n+import au.gov.asd.tac.constellation.graph.attribute.BooleanAttributeDescription;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.model.CellValue;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.model.CellValueProperty;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.model.TableRow;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.translator.AttributeTranslator;\n+import au.gov.asd.tac.constellation.plugins.parameters.PluginParameters;\n+import java.lang.reflect.InvocationTargetException;\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import javafx.geometry.Insets;\n+import javafx.geometry.Pos;\n+import javafx.scene.Node;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.TableColumn;\n+import javafx.scene.layout.BorderPane;\n+\n+public class ImportTableColumn extends TableColumn<TableRow, CellValue> {\n+\n+    private static final Logger LOGGER = Logger.getLogger(ImportTableColumn.class.getName());\n+\n+    private final String label;\n+    private final int columnIndex;\n+\n+    public ImportTableColumn(final String label, final int columnIndex) {\n+        this.label = label;\n+        this.columnIndex = columnIndex;\n+        final ColumnHeader header = new ColumnHeader(label);\n+        setGraphic(header);\n+    }\n+\n+    public String getLabel() {\n+        return label;\n+    }\n+\n+    public int getColumnIndex() {\n+        return columnIndex;\n+    }\n+\n+    public void validate(final List<TableRow> data) {\n+        final AttributeNode attributeNode = getAttributeNode();\n+\n+        boolean columnFailed = false;\n+\n+        if (attributeNode != null) {\n+            final AttributeTranslator parser = attributeNode.getTranslator();\n+            final PluginParameters parserParameters = attributeNode.getTranslatorParameters();\n+            final String defaultValue = attributeNode.getDefaultValue();\n+\n+            Class<? extends AttributeDescription> attributeDescriptionClass = AttributeRegistry.getDefault().getAttributes().get(attributeNode.getAttribute().getAttributeType());\n+            // Handle pseudo-attributes\n+            if (attributeDescriptionClass == null && attributeNode.getAttribute().getName().equals(ImportController.DIRECTED)) {\n+                attributeDescriptionClass = BooleanAttributeDescription.class;\n+            }\n+            try {\n+                final AttributeDescription attributeDescription = attributeDescriptionClass.getDeclaredConstructor().newInstance();\n+                for (final TableRow row : data) {\n+                    final CellValueProperty property = row.getProperty(columnIndex);\n+                    final String value = property.get().getOriginalText();\n+                    final String parsedValue = parser.translate(value, parserParameters);\n+                    final String errorMessage = attributeDescription.acceptsString(parsedValue);\n+                    columnFailed |= errorMessage != null;\n+                    if (parsedValue == null ? value == null : parsedValue.equals(value)) {\n+                        property.setText(value);\n+                        if (errorMessage != null && defaultValue == null) {\n+                            property.setMessage(errorMessage, true);\n+                        } else {\n+                            property.setMessage(null, false);\n+                            columnFailed = false;\n+                        }\n+                    } else {\n+                        property.setText(parsedValue);\n+                        if (errorMessage != null) {\n+                            property.setMessage(errorMessage, true);\n+                        } else {\n+                            property.setMessage(\"Original: \" + value, false);\n+                        }\n+                    }\n+                }\n+            } catch (final IllegalAccessException | IllegalArgumentException\n+                    | InstantiationException | NoSuchMethodException\n+                    | SecurityException | InvocationTargetException ex) {\n+                LOGGER.log(Level.SEVERE, ex.getLocalizedMessage(), ex);\n+            }\n+        } else {\n+            for (final TableRow row : data) {\n+                final CellValueProperty property = row.getProperty(columnIndex);\n+                property.setText(property.get().getOriginalText());\n+                property.setMessage(null, false);\n+            }\n+        }\n+\n+        if (columnFailed) {\n+            getGraphic().setStyle(\"-fx-background-color: rgba(255, 0, 0, 0.3);\");\n+        } else {\n+            getGraphic().setStyle(\"-fx-background-color: transparent;\");\n+        }", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzMjQ5OA==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543032498", "bodyText": "final", "author": "antares1470", "createdAt": "2020-12-15T04:13:52Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/JDBCConnection.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.MalformedURLException;\n+import java.sql.Connection;\n+import java.sql.Driver;\n+import java.sql.SQLException;\n+import java.util.Properties;\n+import javafx.scene.control.Alert;\n+import javafx.scene.control.TextArea;\n+\n+public class JDBCConnection {\n+\n+    private String _connectionName;\n+    private JDBCDriver _driver;\n+    private String _connectionString;\n+\n+    public JDBCConnection(final String connectionName, final JDBCDriver driver, final String connectionString) {\n+        this._connectionName = connectionName;\n+        this._driver = driver;\n+        this._connectionString = connectionString;\n+    }\n+\n+    public Connection getConnection(final String user, final String password) throws MalformedURLException, ClassNotFoundException, SQLException, NoSuchMethodException, InstantiationException, IllegalAccessException, IllegalArgumentException, InvocationTargetException {\n+        final Driver driver = _driver.getDriver();\n+\n+        final Properties props = new Properties();\n+        props.put(\"user\", user);\n+        props.put(\"password\", password);\n+        final Connection a = driver.connect(_connectionString, props);\n+        return a;\n+    }\n+\n+    public boolean testConnection(final String user, final String password, final boolean showError) {\n+        try (final Connection conn = getConnection(user, password)) {\n+            if (conn == null) {\n+                final Alert a = new Alert(Alert.AlertType.ERROR);\n+                a.setTitle(\"Connection Failed\");\n+                final TextArea b = new TextArea();\n+                b.setEditable(false);\n+                b.setWrapText(true);\n+                b.setText(\"Testing of the connection failed, please recheck your connection string settings.\");\n+                a.getDialogPane().setContent(b);\n+                a.showAndWait();\n+                return false;\n+            }\n+        } catch (MalformedURLException | ClassNotFoundException | SQLException | NoSuchMethodException | InstantiationException | IllegalAccessException | IllegalArgumentException | InvocationTargetException ex) {", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzMjk2Mw==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543032963", "bodyText": "I would rename the variable to connectionManager for similar (following appropriate naming convention where possible)", "author": "antares1470", "createdAt": "2020-12-15T04:15:20Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/JDBCConnectionManager.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import javafx.scene.control.Alert;\n+import javafx.scene.control.Alert.AlertType;\n+import javafx.scene.control.TextArea;\n+import org.openide.util.Exceptions;\n+\n+public class JDBCConnectionManager {\n+\n+    static JDBCConnectionManager __instance__ = null;", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzMzE0NA==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543033144", "bodyText": "omit the underscore from these names", "author": "antares1470", "createdAt": "2020-12-15T04:15:49Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/JDBCConnection.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.MalformedURLException;\n+import java.sql.Connection;\n+import java.sql.Driver;\n+import java.sql.SQLException;\n+import java.util.Properties;\n+import javafx.scene.control.Alert;\n+import javafx.scene.control.TextArea;\n+\n+public class JDBCConnection {\n+\n+    private String _connectionName;\n+    private JDBCDriver _driver;\n+    private String _connectionString;", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzMzMzNw==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543033337", "bodyText": "omit underscores from name and change declaration to plain Map", "author": "antares1470", "createdAt": "2020-12-15T04:16:26Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/JDBCConnectionManager.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import javafx.scene.control.Alert;\n+import javafx.scene.control.Alert.AlertType;\n+import javafx.scene.control.TextArea;\n+import org.openide.util.Exceptions;\n+\n+public class JDBCConnectionManager {\n+\n+    static JDBCConnectionManager __instance__ = null;\n+\n+    private HashMap<String, JDBCConnection> __connections = new HashMap<>();", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzMzYyOQ==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543033629", "bodyText": "can convert this to multicatch", "author": "antares1470", "createdAt": "2020-12-15T04:17:16Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/JDBCConnectionManager.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import javafx.scene.control.Alert;\n+import javafx.scene.control.Alert.AlertType;\n+import javafx.scene.control.TextArea;\n+import org.openide.util.Exceptions;\n+\n+public class JDBCConnectionManager {\n+\n+    static JDBCConnectionManager __instance__ = null;\n+\n+    private HashMap<String, JDBCConnection> __connections = new HashMap<>();\n+    private SQLiteDBManager sql;\n+    private File driversDir;\n+\n+    private JDBCConnectionManager() {\n+        //load drivers from db\n+        final File basePath = new File(String.format(\"%s%s.CONSTELLATION%sJDBCImport%s\", System.getProperty(\"user.home\"), File.separator, File.separator, File.separator));\n+        if (!basePath.exists()) {\n+            basePath.mkdirs();\n+        }\n+        driversDir = new File(basePath.getAbsolutePath() + File.separator + \"jars\");\n+        if (!driversDir.exists()) {\n+            driversDir.mkdirs();\n+        }\n+\n+        sql = SQLiteDBManager.getInstance();\n+\n+        final JDBCDriverManager dm = JDBCDriverManager.getInstance();\n+        try (final Connection connection = sql.getConnection()) {\n+\n+            try (final PreparedStatement statement = connection.prepareStatement(\"SELECT * from connection\")) {\n+                try (final ResultSet connections = statement.executeQuery()) {\n+                    while (connections.next()) {\n+                        final JDBCDriver driver = dm.getDriver(connections.getString(\"driver_name\"));\n+                        if (driver != null) {\n+                            final JDBCConnection d = new JDBCConnection(connections.getString(\"name\"), driver, connections.getString(\"connection_string\"));\n+                            __connections.put(d.getConnectionName(), d);\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (final SQLException ex) {\n+            Exceptions.printStackTrace(ex);\n+        } catch (final IOException ex) {\n+            Exceptions.printStackTrace(ex);", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzMzc5OA==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543033798", "bodyText": "change return type to List", "author": "antares1470", "createdAt": "2020-12-15T04:17:38Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/JDBCConnectionManager.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import javafx.scene.control.Alert;\n+import javafx.scene.control.Alert.AlertType;\n+import javafx.scene.control.TextArea;\n+import org.openide.util.Exceptions;\n+\n+public class JDBCConnectionManager {\n+\n+    static JDBCConnectionManager __instance__ = null;\n+\n+    private HashMap<String, JDBCConnection> __connections = new HashMap<>();\n+    private SQLiteDBManager sql;\n+    private File driversDir;\n+\n+    private JDBCConnectionManager() {\n+        //load drivers from db\n+        final File basePath = new File(String.format(\"%s%s.CONSTELLATION%sJDBCImport%s\", System.getProperty(\"user.home\"), File.separator, File.separator, File.separator));\n+        if (!basePath.exists()) {\n+            basePath.mkdirs();\n+        }\n+        driversDir = new File(basePath.getAbsolutePath() + File.separator + \"jars\");\n+        if (!driversDir.exists()) {\n+            driversDir.mkdirs();\n+        }\n+\n+        sql = SQLiteDBManager.getInstance();\n+\n+        final JDBCDriverManager dm = JDBCDriverManager.getInstance();\n+        try (final Connection connection = sql.getConnection()) {\n+\n+            try (final PreparedStatement statement = connection.prepareStatement(\"SELECT * from connection\")) {\n+                try (final ResultSet connections = statement.executeQuery()) {\n+                    while (connections.next()) {\n+                        final JDBCDriver driver = dm.getDriver(connections.getString(\"driver_name\"));\n+                        if (driver != null) {\n+                            final JDBCConnection d = new JDBCConnection(connections.getString(\"name\"), driver, connections.getString(\"connection_string\"));\n+                            __connections.put(d.getConnectionName(), d);\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (final SQLException ex) {\n+            Exceptions.printStackTrace(ex);\n+        } catch (final IOException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+    }\n+\n+    public ArrayList<JDBCConnection> getConnections() {", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzMzkxMQ==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543033911", "bodyText": "final", "author": "antares1470", "createdAt": "2020-12-15T04:18:01Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/JDBCConnectionManager.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import javafx.scene.control.Alert;\n+import javafx.scene.control.Alert.AlertType;\n+import javafx.scene.control.TextArea;\n+import org.openide.util.Exceptions;\n+\n+public class JDBCConnectionManager {\n+\n+    static JDBCConnectionManager __instance__ = null;\n+\n+    private HashMap<String, JDBCConnection> __connections = new HashMap<>();\n+    private SQLiteDBManager sql;\n+    private File driversDir;\n+\n+    private JDBCConnectionManager() {\n+        //load drivers from db\n+        final File basePath = new File(String.format(\"%s%s.CONSTELLATION%sJDBCImport%s\", System.getProperty(\"user.home\"), File.separator, File.separator, File.separator));\n+        if (!basePath.exists()) {\n+            basePath.mkdirs();\n+        }\n+        driversDir = new File(basePath.getAbsolutePath() + File.separator + \"jars\");\n+        if (!driversDir.exists()) {\n+            driversDir.mkdirs();\n+        }\n+\n+        sql = SQLiteDBManager.getInstance();\n+\n+        final JDBCDriverManager dm = JDBCDriverManager.getInstance();\n+        try (final Connection connection = sql.getConnection()) {\n+\n+            try (final PreparedStatement statement = connection.prepareStatement(\"SELECT * from connection\")) {\n+                try (final ResultSet connections = statement.executeQuery()) {\n+                    while (connections.next()) {\n+                        final JDBCDriver driver = dm.getDriver(connections.getString(\"driver_name\"));\n+                        if (driver != null) {\n+                            final JDBCConnection d = new JDBCConnection(connections.getString(\"name\"), driver, connections.getString(\"connection_string\"));\n+                            __connections.put(d.getConnectionName(), d);\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (final SQLException ex) {\n+            Exceptions.printStackTrace(ex);\n+        } catch (final IOException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+    }\n+\n+    public ArrayList<JDBCConnection> getConnections() {\n+        return new ArrayList(__connections.values());\n+    }\n+\n+    public boolean testConnection(final String connectionName, final JDBCDriver driver, final String username, final String password, final String connectionString) {\n+        final JDBCConnection conn = new JDBCConnection(connectionName, driver, connectionString);\n+        return conn.testConnection(username, password, true);\n+    }\n+\n+    public boolean addConnection(final String connectionName, final JDBCDriver driver, final String username, final String password, final String connectionString) {\n+        final JDBCConnection conn = new JDBCConnection(connectionName, driver, connectionString);\n+        if (testConnection(connectionName, driver, username, password, connectionString)) {\n+            try (final Connection connection = sql.getConnection()) {\n+                try (final PreparedStatement statement = connection.prepareStatement(\"insert into connection (name, driver_name, connection_string) values (?, ?, ?)\")) {\n+                    statement.setString(1, connectionName);\n+                    statement.setString(2, driver.getName());\n+                    statement.setString(3, connectionString);\n+                    statement.executeUpdate();\n+                }\n+                __connections.put(connectionName, new JDBCConnection(connectionName, driver, connectionString));\n+\n+            } catch (IOException | SQLException ex) {", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzNDAxNQ==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543034015", "bodyText": "final", "author": "antares1470", "createdAt": "2020-12-15T04:18:26Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/JDBCConnectionManager.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import javafx.scene.control.Alert;\n+import javafx.scene.control.Alert.AlertType;\n+import javafx.scene.control.TextArea;\n+import org.openide.util.Exceptions;\n+\n+public class JDBCConnectionManager {\n+\n+    static JDBCConnectionManager __instance__ = null;\n+\n+    private HashMap<String, JDBCConnection> __connections = new HashMap<>();\n+    private SQLiteDBManager sql;\n+    private File driversDir;\n+\n+    private JDBCConnectionManager() {\n+        //load drivers from db\n+        final File basePath = new File(String.format(\"%s%s.CONSTELLATION%sJDBCImport%s\", System.getProperty(\"user.home\"), File.separator, File.separator, File.separator));\n+        if (!basePath.exists()) {\n+            basePath.mkdirs();\n+        }\n+        driversDir = new File(basePath.getAbsolutePath() + File.separator + \"jars\");\n+        if (!driversDir.exists()) {\n+            driversDir.mkdirs();\n+        }\n+\n+        sql = SQLiteDBManager.getInstance();\n+\n+        final JDBCDriverManager dm = JDBCDriverManager.getInstance();\n+        try (final Connection connection = sql.getConnection()) {\n+\n+            try (final PreparedStatement statement = connection.prepareStatement(\"SELECT * from connection\")) {\n+                try (final ResultSet connections = statement.executeQuery()) {\n+                    while (connections.next()) {\n+                        final JDBCDriver driver = dm.getDriver(connections.getString(\"driver_name\"));\n+                        if (driver != null) {\n+                            final JDBCConnection d = new JDBCConnection(connections.getString(\"name\"), driver, connections.getString(\"connection_string\"));\n+                            __connections.put(d.getConnectionName(), d);\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (final SQLException ex) {\n+            Exceptions.printStackTrace(ex);\n+        } catch (final IOException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+    }\n+\n+    public ArrayList<JDBCConnection> getConnections() {\n+        return new ArrayList(__connections.values());\n+    }\n+\n+    public boolean testConnection(final String connectionName, final JDBCDriver driver, final String username, final String password, final String connectionString) {\n+        final JDBCConnection conn = new JDBCConnection(connectionName, driver, connectionString);\n+        return conn.testConnection(username, password, true);\n+    }\n+\n+    public boolean addConnection(final String connectionName, final JDBCDriver driver, final String username, final String password, final String connectionString) {\n+        final JDBCConnection conn = new JDBCConnection(connectionName, driver, connectionString);\n+        if (testConnection(connectionName, driver, username, password, connectionString)) {\n+            try (final Connection connection = sql.getConnection()) {\n+                try (final PreparedStatement statement = connection.prepareStatement(\"insert into connection (name, driver_name, connection_string) values (?, ?, ?)\")) {\n+                    statement.setString(1, connectionName);\n+                    statement.setString(2, driver.getName());\n+                    statement.setString(3, connectionString);\n+                    statement.executeUpdate();\n+                }\n+                __connections.put(connectionName, new JDBCConnection(connectionName, driver, connectionString));\n+\n+            } catch (IOException | SQLException ex) {\n+                final Alert a = new Alert(AlertType.ERROR);\n+                a.setTitle(\"Connection add failed\");\n+                a.setContentText(\"Failed to add the connection to the database.\");\n+                final TextArea ta = new TextArea(ex.getMessage());\n+                ta.setEditable(false);\n+                ta.setWrapText(true);\n+                a.getDialogPane().setExpandableContent(ta);\n+\n+                a.showAndWait();\n+                return false;\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void deleteConnection(final String name) {\n+        final JDBCConnection d = __connections.get(name);\n+        if (d != null) {\n+            __connections.remove(name);\n+        }\n+        try (final Connection connection = sql.getConnection()) {\n+            try (final PreparedStatement statement = connection.prepareStatement(\"delete from connection where name=?\")) {\n+                statement.setString(1, name);\n+                statement.executeUpdate();\n+            }\n+        } catch (SQLException | IOException ex) {", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzNDIzMQ==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543034231", "bodyText": "I would change function name to reflect field name change", "author": "antares1470", "createdAt": "2020-12-15T04:19:10Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/JDBCConnectionManager.java", "diffHunk": "@@ -0,0 +1,142 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import javafx.scene.control.Alert;\n+import javafx.scene.control.Alert.AlertType;\n+import javafx.scene.control.TextArea;\n+import org.openide.util.Exceptions;\n+\n+public class JDBCConnectionManager {\n+\n+    static JDBCConnectionManager __instance__ = null;\n+\n+    private HashMap<String, JDBCConnection> __connections = new HashMap<>();\n+    private SQLiteDBManager sql;\n+    private File driversDir;\n+\n+    private JDBCConnectionManager() {\n+        //load drivers from db\n+        final File basePath = new File(String.format(\"%s%s.CONSTELLATION%sJDBCImport%s\", System.getProperty(\"user.home\"), File.separator, File.separator, File.separator));\n+        if (!basePath.exists()) {\n+            basePath.mkdirs();\n+        }\n+        driversDir = new File(basePath.getAbsolutePath() + File.separator + \"jars\");\n+        if (!driversDir.exists()) {\n+            driversDir.mkdirs();\n+        }\n+\n+        sql = SQLiteDBManager.getInstance();\n+\n+        final JDBCDriverManager dm = JDBCDriverManager.getInstance();\n+        try (final Connection connection = sql.getConnection()) {\n+\n+            try (final PreparedStatement statement = connection.prepareStatement(\"SELECT * from connection\")) {\n+                try (final ResultSet connections = statement.executeQuery()) {\n+                    while (connections.next()) {\n+                        final JDBCDriver driver = dm.getDriver(connections.getString(\"driver_name\"));\n+                        if (driver != null) {\n+                            final JDBCConnection d = new JDBCConnection(connections.getString(\"name\"), driver, connections.getString(\"connection_string\"));\n+                            __connections.put(d.getConnectionName(), d);\n+                        }\n+                    }\n+                }\n+            }\n+        } catch (final SQLException ex) {\n+            Exceptions.printStackTrace(ex);\n+        } catch (final IOException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+    }\n+\n+    public ArrayList<JDBCConnection> getConnections() {\n+        return new ArrayList(__connections.values());\n+    }\n+\n+    public boolean testConnection(final String connectionName, final JDBCDriver driver, final String username, final String password, final String connectionString) {\n+        final JDBCConnection conn = new JDBCConnection(connectionName, driver, connectionString);\n+        return conn.testConnection(username, password, true);\n+    }\n+\n+    public boolean addConnection(final String connectionName, final JDBCDriver driver, final String username, final String password, final String connectionString) {\n+        final JDBCConnection conn = new JDBCConnection(connectionName, driver, connectionString);\n+        if (testConnection(connectionName, driver, username, password, connectionString)) {\n+            try (final Connection connection = sql.getConnection()) {\n+                try (final PreparedStatement statement = connection.prepareStatement(\"insert into connection (name, driver_name, connection_string) values (?, ?, ?)\")) {\n+                    statement.setString(1, connectionName);\n+                    statement.setString(2, driver.getName());\n+                    statement.setString(3, connectionString);\n+                    statement.executeUpdate();\n+                }\n+                __connections.put(connectionName, new JDBCConnection(connectionName, driver, connectionString));\n+\n+            } catch (IOException | SQLException ex) {\n+                final Alert a = new Alert(AlertType.ERROR);\n+                a.setTitle(\"Connection add failed\");\n+                a.setContentText(\"Failed to add the connection to the database.\");\n+                final TextArea ta = new TextArea(ex.getMessage());\n+                ta.setEditable(false);\n+                ta.setWrapText(true);\n+                a.getDialogPane().setExpandableContent(ta);\n+\n+                a.showAndWait();\n+                return false;\n+            }\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public void deleteConnection(final String name) {\n+        final JDBCConnection d = __connections.get(name);\n+        if (d != null) {\n+            __connections.remove(name);\n+        }\n+        try (final Connection connection = sql.getConnection()) {\n+            try (final PreparedStatement statement = connection.prepareStatement(\"delete from connection where name=?\")) {\n+                statement.setString(1, name);\n+                statement.executeUpdate();\n+            }\n+        } catch (SQLException | IOException ex) {\n+            final Alert a = new Alert(AlertType.ERROR);\n+            a.setTitle(\"Connection delete failed\");\n+            a.setContentText(\"Failed to delete the connection from the database.\");\n+            final TextArea ta = new TextArea(ex.getMessage());\n+            ta.setEditable(false);\n+            ta.setWrapText(true);\n+            a.getDialogPane().setExpandableContent(ta);\n+\n+            a.showAndWait();\n+        }\n+    }\n+\n+    public static JDBCConnectionManager getInstance() {\n+        if (__instance__ == null) {", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzNDI4NA==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543034284", "bodyText": "return List", "author": "antares1470", "createdAt": "2020-12-15T04:19:22Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/JDBCDriver.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.charset.StandardCharsets;\n+import java.sql.Driver;\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import java.util.zip.ZipEntry;\n+\n+public class JDBCDriver {\n+\n+    private String driverName;\n+    private File jarFile;\n+\n+    public JDBCDriver(final String name, final File file) {\n+        driverName = name;\n+        jarFile = file;\n+    }\n+\n+    public String getName() {\n+        return driverName;\n+    }\n+\n+    public static ArrayList<String> getDrivers(final File jarFile) {", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzNDMyNg==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543034326", "bodyText": "declare as list", "author": "antares1470", "createdAt": "2020-12-15T04:19:29Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/JDBCDriver.java", "diffHunk": "@@ -0,0 +1,129 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import java.io.BufferedReader;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStreamReader;\n+import java.lang.reflect.InvocationTargetException;\n+import java.net.MalformedURLException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.nio.charset.StandardCharsets;\n+import java.sql.Driver;\n+import java.util.ArrayList;\n+import java.util.Enumeration;\n+import java.util.jar.JarEntry;\n+import java.util.jar.JarFile;\n+import java.util.zip.ZipEntry;\n+\n+public class JDBCDriver {\n+\n+    private String driverName;\n+    private File jarFile;\n+\n+    public JDBCDriver(final String name, final File file) {\n+        driverName = name;\n+        jarFile = file;\n+    }\n+\n+    public String getName() {\n+        return driverName;\n+    }\n+\n+    public static ArrayList<String> getDrivers(final File jarFile) {\n+        final ArrayList<String> driverList = new ArrayList<>();", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzNTgzNQ==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543035835", "bodyText": "rename to something without underscores", "author": "antares1470", "createdAt": "2020-12-15T04:24:09Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/JDBCDriverManager.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import com.google.common.io.Files;\n+import java.io.File;\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import org.openide.util.Exceptions;\n+\n+public class JDBCDriverManager {\n+\n+    static JDBCDriverManager __instance__ = null;", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzNTk0OQ==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543035949", "bodyText": "declare as map, remove underscores from name", "author": "antares1470", "createdAt": "2020-12-15T04:24:27Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/JDBCDriverManager.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import com.google.common.io.Files;\n+import java.io.File;\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import org.openide.util.Exceptions;\n+\n+public class JDBCDriverManager {\n+\n+    static JDBCDriverManager __instance__ = null;\n+\n+    private HashMap<String, JDBCDriver> __drivers = new HashMap<>();", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzNjI2Ng==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543036266", "bodyText": "drivers will need name change if changing name of __drivers", "author": "antares1470", "createdAt": "2020-12-15T04:25:25Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/JDBCDriverManager.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import com.google.common.io.Files;\n+import java.io.File;\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import org.openide.util.Exceptions;\n+\n+public class JDBCDriverManager {\n+\n+    static JDBCDriverManager __instance__ = null;\n+\n+    private HashMap<String, JDBCDriver> __drivers = new HashMap<>();\n+    File driversDir;\n+    private SQLiteDBManager sql;\n+\n+    private JDBCDriverManager() {\n+        //load drivers from db\n+        final File basePath = new File(String.format(\"%s%s.CONSTELLATION%sJDBCImport%s\", System.getProperty(\"user.home\"), File.separator, File.separator, File.separator));\n+        if (!basePath.exists()) {\n+            basePath.mkdirs();\n+        }\n+        driversDir = new File(basePath.getAbsolutePath() + File.separator + \"jars\");\n+        if (!driversDir.exists()) {\n+            driversDir.mkdirs();\n+        }\n+\n+        sql = SQLiteDBManager.getInstance();\n+        try (final Connection connection = sql.getConnection()) {\n+            try (final PreparedStatement statement = connection.prepareStatement(\"SELECT name, path from driver\")) {\n+                try (final ResultSet drivers = statement.executeQuery()) {", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzNjM1MQ==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543036351", "bodyText": "multicatch", "author": "antares1470", "createdAt": "2020-12-15T04:25:41Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/JDBCDriverManager.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import com.google.common.io.Files;\n+import java.io.File;\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import org.openide.util.Exceptions;\n+\n+public class JDBCDriverManager {\n+\n+    static JDBCDriverManager __instance__ = null;\n+\n+    private HashMap<String, JDBCDriver> __drivers = new HashMap<>();\n+    File driversDir;\n+    private SQLiteDBManager sql;\n+\n+    private JDBCDriverManager() {\n+        //load drivers from db\n+        final File basePath = new File(String.format(\"%s%s.CONSTELLATION%sJDBCImport%s\", System.getProperty(\"user.home\"), File.separator, File.separator, File.separator));\n+        if (!basePath.exists()) {\n+            basePath.mkdirs();\n+        }\n+        driversDir = new File(basePath.getAbsolutePath() + File.separator + \"jars\");\n+        if (!driversDir.exists()) {\n+            driversDir.mkdirs();\n+        }\n+\n+        sql = SQLiteDBManager.getInstance();\n+        try (final Connection connection = sql.getConnection()) {\n+            try (final PreparedStatement statement = connection.prepareStatement(\"SELECT name, path from driver\")) {\n+                try (final ResultSet drivers = statement.executeQuery()) {\n+                    while (drivers.next()) {\n+                        final JDBCDriver d = new JDBCDriver(drivers.getString(\"name\"), new File(drivers.getString(\"path\")));\n+                        __drivers.put(d.getName(), d);\n+                    }\n+                }\n+            }\n+        } catch (final SQLException ex) {\n+            Exceptions.printStackTrace(ex);\n+        } catch (final IOException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzNjQyMQ==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543036421", "bodyText": "return list", "author": "antares1470", "createdAt": "2020-12-15T04:25:51Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/JDBCDriverManager.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import com.google.common.io.Files;\n+import java.io.File;\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import org.openide.util.Exceptions;\n+\n+public class JDBCDriverManager {\n+\n+    static JDBCDriverManager __instance__ = null;\n+\n+    private HashMap<String, JDBCDriver> __drivers = new HashMap<>();\n+    File driversDir;\n+    private SQLiteDBManager sql;\n+\n+    private JDBCDriverManager() {\n+        //load drivers from db\n+        final File basePath = new File(String.format(\"%s%s.CONSTELLATION%sJDBCImport%s\", System.getProperty(\"user.home\"), File.separator, File.separator, File.separator));\n+        if (!basePath.exists()) {\n+            basePath.mkdirs();\n+        }\n+        driversDir = new File(basePath.getAbsolutePath() + File.separator + \"jars\");\n+        if (!driversDir.exists()) {\n+            driversDir.mkdirs();\n+        }\n+\n+        sql = SQLiteDBManager.getInstance();\n+        try (final Connection connection = sql.getConnection()) {\n+            try (final PreparedStatement statement = connection.prepareStatement(\"SELECT name, path from driver\")) {\n+                try (final ResultSet drivers = statement.executeQuery()) {\n+                    while (drivers.next()) {\n+                        final JDBCDriver d = new JDBCDriver(drivers.getString(\"name\"), new File(drivers.getString(\"path\")));\n+                        __drivers.put(d.getName(), d);\n+                    }\n+                }\n+            }\n+        } catch (final SQLException ex) {\n+            Exceptions.printStackTrace(ex);\n+        } catch (final IOException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+    }\n+\n+    public ArrayList<JDBCDriver> getDrivers() {", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzNjQ5Mg==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543036492", "bodyText": "final", "author": "antares1470", "createdAt": "2020-12-15T04:26:05Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/JDBCDriverManager.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import com.google.common.io.Files;\n+import java.io.File;\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import org.openide.util.Exceptions;\n+\n+public class JDBCDriverManager {\n+\n+    static JDBCDriverManager __instance__ = null;\n+\n+    private HashMap<String, JDBCDriver> __drivers = new HashMap<>();\n+    File driversDir;\n+    private SQLiteDBManager sql;\n+\n+    private JDBCDriverManager() {\n+        //load drivers from db\n+        final File basePath = new File(String.format(\"%s%s.CONSTELLATION%sJDBCImport%s\", System.getProperty(\"user.home\"), File.separator, File.separator, File.separator));\n+        if (!basePath.exists()) {\n+            basePath.mkdirs();\n+        }\n+        driversDir = new File(basePath.getAbsolutePath() + File.separator + \"jars\");\n+        if (!driversDir.exists()) {\n+            driversDir.mkdirs();\n+        }\n+\n+        sql = SQLiteDBManager.getInstance();\n+        try (final Connection connection = sql.getConnection()) {\n+            try (final PreparedStatement statement = connection.prepareStatement(\"SELECT name, path from driver\")) {\n+                try (final ResultSet drivers = statement.executeQuery()) {\n+                    while (drivers.next()) {\n+                        final JDBCDriver d = new JDBCDriver(drivers.getString(\"name\"), new File(drivers.getString(\"path\")));\n+                        __drivers.put(d.getName(), d);\n+                    }\n+                }\n+            }\n+        } catch (final SQLException ex) {\n+            Exceptions.printStackTrace(ex);\n+        } catch (final IOException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+    }\n+\n+    public ArrayList<JDBCDriver> getDrivers() {\n+        return new ArrayList(__drivers.values());\n+    }\n+\n+    public JDBCDriver getDriver(final String name) {\n+        return __drivers.get(name);\n+    }\n+\n+    public boolean isDriverUsed(final String name) {\n+        try (final Connection connection = sql.getConnection()) {\n+            try (final PreparedStatement statement = connection.prepareStatement(\"select count(*) as c from connection where driver_name=?\")) {\n+                statement.setString(1, name);\n+                try (ResultSet rs = statement.executeQuery()) {\n+                    rs.next();\n+                    if (rs.getInt(\"c\") > 0) {\n+                        return true;\n+                    }\n+                }\n+            }\n+        } catch (IOException | SQLException ex) {", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzNjU2Mg==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543036562", "bodyText": "final", "author": "antares1470", "createdAt": "2020-12-15T04:26:17Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/JDBCDriverManager.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import com.google.common.io.Files;\n+import java.io.File;\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import org.openide.util.Exceptions;\n+\n+public class JDBCDriverManager {\n+\n+    static JDBCDriverManager __instance__ = null;\n+\n+    private HashMap<String, JDBCDriver> __drivers = new HashMap<>();\n+    File driversDir;\n+    private SQLiteDBManager sql;\n+\n+    private JDBCDriverManager() {\n+        //load drivers from db\n+        final File basePath = new File(String.format(\"%s%s.CONSTELLATION%sJDBCImport%s\", System.getProperty(\"user.home\"), File.separator, File.separator, File.separator));\n+        if (!basePath.exists()) {\n+            basePath.mkdirs();\n+        }\n+        driversDir = new File(basePath.getAbsolutePath() + File.separator + \"jars\");\n+        if (!driversDir.exists()) {\n+            driversDir.mkdirs();\n+        }\n+\n+        sql = SQLiteDBManager.getInstance();\n+        try (final Connection connection = sql.getConnection()) {\n+            try (final PreparedStatement statement = connection.prepareStatement(\"SELECT name, path from driver\")) {\n+                try (final ResultSet drivers = statement.executeQuery()) {\n+                    while (drivers.next()) {\n+                        final JDBCDriver d = new JDBCDriver(drivers.getString(\"name\"), new File(drivers.getString(\"path\")));\n+                        __drivers.put(d.getName(), d);\n+                    }\n+                }\n+            }\n+        } catch (final SQLException ex) {\n+            Exceptions.printStackTrace(ex);\n+        } catch (final IOException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+    }\n+\n+    public ArrayList<JDBCDriver> getDrivers() {\n+        return new ArrayList(__drivers.values());\n+    }\n+\n+    public JDBCDriver getDriver(final String name) {\n+        return __drivers.get(name);\n+    }\n+\n+    public boolean isDriverUsed(final String name) {\n+        try (final Connection connection = sql.getConnection()) {\n+            try (final PreparedStatement statement = connection.prepareStatement(\"select count(*) as c from connection where driver_name=?\")) {\n+                statement.setString(1, name);\n+                try (ResultSet rs = statement.executeQuery()) {\n+                    rs.next();\n+                    if (rs.getInt(\"c\") > 0) {\n+                        return true;\n+                    }\n+                }\n+            }\n+        } catch (IOException | SQLException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+        return false;\n+    }\n+\n+    public void removeConnectionsWithDriver(final String name) {\n+        try (final Connection connection = sql.getConnection()) {\n+            try (final PreparedStatement statement = connection.prepareStatement(\"delete from connection where driver_name=?\")) {\n+                statement.setString(1, name);\n+                statement.executeUpdate();\n+            }\n+        } catch (IOException | SQLException ex) {", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzNjYyNA==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543036624", "bodyText": "multicatch", "author": "antares1470", "createdAt": "2020-12-15T04:26:27Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/JDBCDriverManager.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import com.google.common.io.Files;\n+import java.io.File;\n+import java.io.IOException;\n+import java.sql.Connection;\n+import java.sql.PreparedStatement;\n+import java.sql.ResultSet;\n+import java.sql.SQLException;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import org.openide.util.Exceptions;\n+\n+public class JDBCDriverManager {\n+\n+    static JDBCDriverManager __instance__ = null;\n+\n+    private HashMap<String, JDBCDriver> __drivers = new HashMap<>();\n+    File driversDir;\n+    private SQLiteDBManager sql;\n+\n+    private JDBCDriverManager() {\n+        //load drivers from db\n+        final File basePath = new File(String.format(\"%s%s.CONSTELLATION%sJDBCImport%s\", System.getProperty(\"user.home\"), File.separator, File.separator, File.separator));\n+        if (!basePath.exists()) {\n+            basePath.mkdirs();\n+        }\n+        driversDir = new File(basePath.getAbsolutePath() + File.separator + \"jars\");\n+        if (!driversDir.exists()) {\n+            driversDir.mkdirs();\n+        }\n+\n+        sql = SQLiteDBManager.getInstance();\n+        try (final Connection connection = sql.getConnection()) {\n+            try (final PreparedStatement statement = connection.prepareStatement(\"SELECT name, path from driver\")) {\n+                try (final ResultSet drivers = statement.executeQuery()) {\n+                    while (drivers.next()) {\n+                        final JDBCDriver d = new JDBCDriver(drivers.getString(\"name\"), new File(drivers.getString(\"path\")));\n+                        __drivers.put(d.getName(), d);\n+                    }\n+                }\n+            }\n+        } catch (final SQLException ex) {\n+            Exceptions.printStackTrace(ex);\n+        } catch (final IOException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+    }\n+\n+    public ArrayList<JDBCDriver> getDrivers() {\n+        return new ArrayList(__drivers.values());\n+    }\n+\n+    public JDBCDriver getDriver(final String name) {\n+        return __drivers.get(name);\n+    }\n+\n+    public boolean isDriverUsed(final String name) {\n+        try (final Connection connection = sql.getConnection()) {\n+            try (final PreparedStatement statement = connection.prepareStatement(\"select count(*) as c from connection where driver_name=?\")) {\n+                statement.setString(1, name);\n+                try (ResultSet rs = statement.executeQuery()) {\n+                    rs.next();\n+                    if (rs.getInt(\"c\") > 0) {\n+                        return true;\n+                    }\n+                }\n+            }\n+        } catch (IOException | SQLException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+        return false;\n+    }\n+\n+    public void removeConnectionsWithDriver(final String name) {\n+        try (final Connection connection = sql.getConnection()) {\n+            try (final PreparedStatement statement = connection.prepareStatement(\"delete from connection where driver_name=?\")) {\n+                statement.setString(1, name);\n+                statement.executeUpdate();\n+            }\n+        } catch (IOException | SQLException ex) {\n+            Exceptions.printStackTrace(ex);\n+        }\n+    }\n+\n+    public void addDriver(final String name, final File jar) {\n+        try (final Connection connection = sql.getConnection()) {\n+            final File out = new File(driversDir.getAbsolutePath() + File.separator + jar.getName());\n+            if (jar.exists() && jar.isFile() && jar.canRead()) {\n+                Files.copy(jar, out);\n+                __drivers.put(name, new JDBCDriver(name, out));\n+            }\n+\n+            try (final PreparedStatement statement = connection.prepareStatement(\"insert into driver (name, path) values (?, ?)\")) {\n+                statement.setString(1, name);\n+                statement.setString(2, out.getAbsolutePath());\n+                statement.executeUpdate();\n+            }\n+\n+        } catch (final IOException ex) {\n+            Exceptions.printStackTrace(ex);\n+        } catch (final SQLException ex) {\n+            Exceptions.printStackTrace(ex);", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzNzAwNw==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543037007", "bodyText": "owner can be final", "author": "antares1470", "createdAt": "2020-12-15T04:27:34Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/NewAttributeDialog.java", "diffHunk": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import au.gov.asd.tac.constellation.graph.Attribute;\n+import au.gov.asd.tac.constellation.graph.GraphElementType;\n+import au.gov.asd.tac.constellation.graph.attribute.AttributeRegistry;\n+import javafx.event.ActionEvent;\n+import javafx.event.EventHandler;\n+import javafx.geometry.Insets;\n+import javafx.geometry.Pos;\n+import javafx.scene.Scene;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.ComboBox;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.TextArea;\n+import javafx.scene.control.TextField;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.FlowPane;\n+import javafx.scene.layout.GridPane;\n+import javafx.stage.Modality;\n+import javafx.stage.Stage;\n+import javafx.stage.StageStyle;\n+\n+public class NewAttributeDialog extends Stage {\n+\n+    private final ComboBox<String> typeBox;\n+    private final TextField labelText;\n+    private final TextArea descriptionText;\n+\n+    private Attribute attribute = null;\n+\n+    public NewAttributeDialog(Stage owner, final GraphElementType elementType) {", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzNzY3Mw==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543037673", "bodyText": "final", "author": "antares1470", "createdAt": "2020-12-15T04:29:40Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/RunPane.java", "diffHunk": "@@ -0,0 +1,561 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import au.gov.asd.tac.constellation.graph.Attribute;\n+import au.gov.asd.tac.constellation.graph.GraphElementType;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.model.CellValue;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.model.TableRow;\n+import au.gov.asd.tac.constellation.utilities.icon.UserInterfaceIconProvider;\n+import java.awt.Color;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.KeyListener;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javafx.beans.value.ObservableValue;\n+import javafx.collections.FXCollections;\n+import javafx.collections.ObservableList;\n+import javafx.event.ActionEvent;\n+import javafx.geometry.HPos;\n+import javafx.geometry.Insets;\n+import javafx.geometry.Orientation;\n+import javafx.geometry.Point2D;\n+import javafx.geometry.Pos;\n+import javafx.geometry.VPos;\n+import javafx.scene.Node;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.ScrollBar;\n+import javafx.scene.control.ScrollPane;\n+import javafx.scene.control.SplitPane;\n+import javafx.scene.control.TableCell;\n+import javafx.scene.control.TableColumn;\n+import javafx.scene.control.TableColumn.CellDataFeatures;\n+import javafx.scene.control.TableView;\n+import javafx.scene.control.TextField;\n+import javafx.scene.control.Tooltip;\n+import javafx.scene.image.Image;\n+import javafx.scene.image.ImageView;\n+import javafx.scene.input.KeyCode;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.Priority;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.shape.Rectangle;\n+import javafx.scene.text.Text;\n+import javafx.util.Callback;\n+\n+public class RunPane extends BorderPane implements KeyListener {\n+\n+    private final ImportController importController;\n+    private final TableView<TableRow> sampleDataView = new TableView<>();\n+    private final AttributeList sourceVertexAttributeList;\n+    private final AttributeList destinationVertexAttributeList;\n+    private final AttributeList transactionAttributeList;\n+    private Point2D draggingOffset;\n+    private AttributeNode draggingAttributeNode;\n+    private ImportTableColumn mouseOverColumn = null;\n+    private Rectangle columnRectangle = new Rectangle();\n+\n+    private final TextField filterField;\n+    private final RowFilter rowFilter = new RowFilter();\n+    private String filter = \"\";\n+\n+    private final SplitPane attributeFilterPane = new SplitPane();\n+    private final TextField attributeFilterTextField = new TextField();\n+    private String attributeFilter = \"\";\n+\n+    private ObservableList<TableRow> currentRows = FXCollections.observableArrayList();\n+    private String[] currentColumnLabels = new String[0];\n+\n+    private static final Image ADD_IMAGE = UserInterfaceIconProvider.ADD.buildImage(16, Color.BLACK);\n+\n+    private class AttributeBox extends BorderPane {\n+\n+        public AttributeBox(final String label, final AttributeList attributeList) {\n+            final BorderPane borderPane = new BorderPane();\n+            borderPane.setTop(attributeList);\n+\n+            setMaxHeight(USE_PREF_SIZE);\n+            setMaxWidth(Double.MAX_VALUE);\n+            setCenter(borderPane);\n+\n+            final Label heading = new Label(label);\n+            heading.setStyle(\"-fx-font-weight: bold;\");\n+\n+            final BorderPane labelPane = new BorderPane();\n+            labelPane.setPadding(new Insets(1));\n+            labelPane.setMinWidth(0);\n+            labelPane.setLeft(heading);\n+\n+            final Button button = new Button(\"\", new ImageView(ADD_IMAGE));\n+            button.setOnAction((ActionEvent event) -> {\n+                final Attribute attribute = importController.showNewAttributeDialog(attributeList.getAttributeType().getElementType());\n+                if (attribute != null) {\n+                    importController.createManualAttribute(attribute);\n+                }\n+            });\n+            button.setTooltip(new Tooltip(\"Add a new \" + attributeList.getAttributeType().getElementType() + \" attribute\"));\n+            labelPane.setRight(button);\n+\n+            setTop(labelPane);\n+        }\n+    }\n+\n+    public RunPane(final ImportController importController) {\n+        this.importController = importController;\n+\n+        setMaxHeight(Double.MAX_VALUE);\n+        setMaxWidth(Double.MAX_VALUE);\n+\n+        final SplitPane splitPane = new SplitPane();\n+        splitPane.setOrientation(Orientation.VERTICAL);\n+        splitPane.setDividerPositions(0.5);\n+        setCenter(splitPane);\n+\n+        filterField = new TextField();\n+        filterField.setMinHeight(USE_PREF_SIZE);\n+        filterField.setPromptText(\"Filter\");\n+        filterField.textProperty().addListener((observable, oldValue, newValue) -> {\n+            if (setFilter(newValue)) {\n+                filterField.setStyle(\"-fx-background-color: white;\");\n+            } else {\n+                filterField.setStyle(\"-fx-background-color: red;\");\n+            }\n+        });\n+\n+        sampleDataView.setMinHeight(100);\n+        sampleDataView.setPrefHeight(200);\n+        sampleDataView.setPrefWidth(750);\n+        sampleDataView.setMaxHeight(Double.MAX_VALUE);\n+\n+        final VBox tableBox = new VBox();\n+        VBox.setVgrow(sampleDataView, Priority.ALWAYS);\n+        tableBox.getChildren().addAll(filterField, sampleDataView);\n+\n+        splitPane.getItems().add(tableBox);\n+\n+        // add a help place holder\n+        final Text startupHelpText = new Text();\n+        startupHelpText.setText(\"1. Select the connection to use\\n\"\n+                + \"2. Select your destination graph.\\n\"\n+                + \"3. Drag and drop attributes onto columns.\\n\"\n+                + \"4. Right click an attribute for more options.\\n\"\n+                + \"5. Click the 'Import' button to add data to your graph.\\n\"\n+        );\n+        startupHelpText.setStyle(\"-fx-font-size: 14pt;-fx-fill: grey;\");\n+        sampleDataView.setPlaceholder(startupHelpText);\n+\n+        sourceVertexAttributeList = new AttributeList(importController, this, AttributeType.SOURCE_VERTEX);\n+        destinationVertexAttributeList = new AttributeList(importController, this, AttributeType.DESTINATION_VERTEX);\n+        transactionAttributeList = new AttributeList(importController, this, AttributeType.TRANSACTION);\n+\n+        final AttributeBox sourceVertexScrollPane = new AttributeBox(\"Source Node Attributes \", sourceVertexAttributeList);\n+        final AttributeBox destinationVertexScrollPane = new AttributeBox(\"Destination Node Attributes \", destinationVertexAttributeList);\n+        final AttributeBox transactionScrollPane = new AttributeBox(\"Transaction Attributes \", transactionAttributeList);\n+\n+        final EasyGridPane attributePane = new EasyGridPane();\n+        attributePane.setMaxWidth(Double.MAX_VALUE);\n+\n+        attributePane.addColumnConstraint(true, HPos.CENTER, Priority.ALWAYS, Double.MAX_VALUE, 100, USE_COMPUTED_SIZE, -1);\n+        attributePane.addColumnConstraint(true, HPos.CENTER, Priority.ALWAYS, Double.MAX_VALUE, 100, USE_COMPUTED_SIZE, -1);\n+        attributePane.addColumnConstraint(true, HPos.CENTER, Priority.ALWAYS, Double.MAX_VALUE, 100, USE_COMPUTED_SIZE, -1);\n+        attributePane.addRowConstraint(true, VPos.TOP, Priority.ALWAYS, Double.MAX_VALUE, 100, USE_COMPUTED_SIZE, -1);\n+\n+        attributePane.addRow(0, sourceVertexScrollPane, destinationVertexScrollPane, transactionScrollPane);\n+\n+        attributePane.setOnKeyPressed(event -> {\n+            final KeyCode c = event.getCode();\n+            if (c == KeyCode.DELETE || c == KeyCode.BACK_SPACE) {\n+                attributeFilter = \"\";\n+                attributeFilterPane.setVisible(false);\n+            } else if (c.isLetterKey()) {\n+                attributeFilter += c.getChar();\n+                attributeFilterTextField.setText(attributeFilter);\n+                attributeFilterPane.setVisible(true);\n+            }\n+            importController.setAttributeFilter(attributeFilter);\n+            importController.setDestination(null);\n+        });\n+\n+        attributePane.setPadding(new Insets(5));\n+        attributePane.setVgap(5);\n+        attributePane.setHgap(5);\n+        attributePane.setAlignment(Pos.TOP_LEFT);\n+\n+        // A scroll pane to hold the attribute boxes\n+        final ScrollPane attributeScrollPane = new ScrollPane();\n+        attributeScrollPane.setContent(attributePane);\n+        attributeScrollPane.setMaxWidth(Double.MAX_VALUE);\n+        attributeScrollPane.setPrefHeight(350);\n+        attributeScrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);\n+        attributeScrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);\n+\n+        final Label filterLabel = new Label(\"Attribute Filter:\");\n+        attributeFilterTextField.setEditable(false);\n+        attributeFilterPane.getItems().addAll(filterLabel, attributeFilterTextField);\n+        attributeFilterPane.setVisible(false);\n+        splitPane.getItems().addAll(attributeFilterPane, attributeScrollPane);\n+        splitPane.onKeyPressedProperty().bind(attributePane.onKeyPressedProperty());\n+\n+        columnRectangle.setStyle(\"-fx-fill: rgba(200, 200, 200, 0.3);\");\n+        columnRectangle.setVisible(false);\n+        columnRectangle.setManaged(false);\n+        RunPane.this.getChildren().add(columnRectangle);\n+\n+        setOnMouseDragged((final MouseEvent t) -> {\n+            handleAttributeMoved(t.getSceneX(), t.getSceneY());\n+        });\n+\n+        setOnMouseReleased((final MouseEvent t) -> {\n+            if (draggingAttributeNode != null) {\n+                if (mouseOverColumn == null) {\n+                    draggingAttributeNode.getAttributeList().addAttributeNode(draggingAttributeNode);\n+                } else {\n+\n+                    // If the active column currently has an attribute node then return\n+                    // the attribute node to its list\n+                    final AttributeNode currentAttributeNode = mouseOverColumn.getAttributeNode();\n+                    if (currentAttributeNode != null) {\n+                        currentAttributeNode.getAttributeList().addAttributeNode(currentAttributeNode);\n+                    }\n+\n+                    // Drop the AttributeNode onto the column.\n+                    mouseOverColumn.setAttributeNode(draggingAttributeNode);\n+                    draggingAttributeNode.setColumn(mouseOverColumn);\n+                    validate(mouseOverColumn);\n+                }\n+\n+                columnRectangle.setVisible(false);\n+                draggingAttributeNode.setManaged(true);\n+                draggingAttributeNode = null;\n+                draggingOffset = null;\n+                mouseOverColumn = null;\n+            }\n+        });\n+    }\n+\n+    public Point2D getDraggingOffset() {\n+        return draggingOffset;\n+    }\n+\n+    public void setDraggingOffset(Point2D draggingOffset) {", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzNzY5Mg==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543037692", "bodyText": "final", "author": "antares1470", "createdAt": "2020-12-15T04:29:46Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/RunPane.java", "diffHunk": "@@ -0,0 +1,561 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc;\n+\n+import au.gov.asd.tac.constellation.graph.Attribute;\n+import au.gov.asd.tac.constellation.graph.GraphElementType;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.model.CellValue;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.model.TableRow;\n+import au.gov.asd.tac.constellation.utilities.icon.UserInterfaceIconProvider;\n+import java.awt.Color;\n+import java.awt.event.KeyEvent;\n+import java.awt.event.KeyListener;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javafx.beans.value.ObservableValue;\n+import javafx.collections.FXCollections;\n+import javafx.collections.ObservableList;\n+import javafx.event.ActionEvent;\n+import javafx.geometry.HPos;\n+import javafx.geometry.Insets;\n+import javafx.geometry.Orientation;\n+import javafx.geometry.Point2D;\n+import javafx.geometry.Pos;\n+import javafx.geometry.VPos;\n+import javafx.scene.Node;\n+import javafx.scene.control.Button;\n+import javafx.scene.control.Label;\n+import javafx.scene.control.ScrollBar;\n+import javafx.scene.control.ScrollPane;\n+import javafx.scene.control.SplitPane;\n+import javafx.scene.control.TableCell;\n+import javafx.scene.control.TableColumn;\n+import javafx.scene.control.TableColumn.CellDataFeatures;\n+import javafx.scene.control.TableView;\n+import javafx.scene.control.TextField;\n+import javafx.scene.control.Tooltip;\n+import javafx.scene.image.Image;\n+import javafx.scene.image.ImageView;\n+import javafx.scene.input.KeyCode;\n+import javafx.scene.input.MouseEvent;\n+import javafx.scene.layout.BorderPane;\n+import javafx.scene.layout.Priority;\n+import javafx.scene.layout.VBox;\n+import javafx.scene.shape.Rectangle;\n+import javafx.scene.text.Text;\n+import javafx.util.Callback;\n+\n+public class RunPane extends BorderPane implements KeyListener {\n+\n+    private final ImportController importController;\n+    private final TableView<TableRow> sampleDataView = new TableView<>();\n+    private final AttributeList sourceVertexAttributeList;\n+    private final AttributeList destinationVertexAttributeList;\n+    private final AttributeList transactionAttributeList;\n+    private Point2D draggingOffset;\n+    private AttributeNode draggingAttributeNode;\n+    private ImportTableColumn mouseOverColumn = null;\n+    private Rectangle columnRectangle = new Rectangle();\n+\n+    private final TextField filterField;\n+    private final RowFilter rowFilter = new RowFilter();\n+    private String filter = \"\";\n+\n+    private final SplitPane attributeFilterPane = new SplitPane();\n+    private final TextField attributeFilterTextField = new TextField();\n+    private String attributeFilter = \"\";\n+\n+    private ObservableList<TableRow> currentRows = FXCollections.observableArrayList();\n+    private String[] currentColumnLabels = new String[0];\n+\n+    private static final Image ADD_IMAGE = UserInterfaceIconProvider.ADD.buildImage(16, Color.BLACK);\n+\n+    private class AttributeBox extends BorderPane {\n+\n+        public AttributeBox(final String label, final AttributeList attributeList) {\n+            final BorderPane borderPane = new BorderPane();\n+            borderPane.setTop(attributeList);\n+\n+            setMaxHeight(USE_PREF_SIZE);\n+            setMaxWidth(Double.MAX_VALUE);\n+            setCenter(borderPane);\n+\n+            final Label heading = new Label(label);\n+            heading.setStyle(\"-fx-font-weight: bold;\");\n+\n+            final BorderPane labelPane = new BorderPane();\n+            labelPane.setPadding(new Insets(1));\n+            labelPane.setMinWidth(0);\n+            labelPane.setLeft(heading);\n+\n+            final Button button = new Button(\"\", new ImageView(ADD_IMAGE));\n+            button.setOnAction((ActionEvent event) -> {\n+                final Attribute attribute = importController.showNewAttributeDialog(attributeList.getAttributeType().getElementType());\n+                if (attribute != null) {\n+                    importController.createManualAttribute(attribute);\n+                }\n+            });\n+            button.setTooltip(new Tooltip(\"Add a new \" + attributeList.getAttributeType().getElementType() + \" attribute\"));\n+            labelPane.setRight(button);\n+\n+            setTop(labelPane);\n+        }\n+    }\n+\n+    public RunPane(final ImportController importController) {\n+        this.importController = importController;\n+\n+        setMaxHeight(Double.MAX_VALUE);\n+        setMaxWidth(Double.MAX_VALUE);\n+\n+        final SplitPane splitPane = new SplitPane();\n+        splitPane.setOrientation(Orientation.VERTICAL);\n+        splitPane.setDividerPositions(0.5);\n+        setCenter(splitPane);\n+\n+        filterField = new TextField();\n+        filterField.setMinHeight(USE_PREF_SIZE);\n+        filterField.setPromptText(\"Filter\");\n+        filterField.textProperty().addListener((observable, oldValue, newValue) -> {\n+            if (setFilter(newValue)) {\n+                filterField.setStyle(\"-fx-background-color: white;\");\n+            } else {\n+                filterField.setStyle(\"-fx-background-color: red;\");\n+            }\n+        });\n+\n+        sampleDataView.setMinHeight(100);\n+        sampleDataView.setPrefHeight(200);\n+        sampleDataView.setPrefWidth(750);\n+        sampleDataView.setMaxHeight(Double.MAX_VALUE);\n+\n+        final VBox tableBox = new VBox();\n+        VBox.setVgrow(sampleDataView, Priority.ALWAYS);\n+        tableBox.getChildren().addAll(filterField, sampleDataView);\n+\n+        splitPane.getItems().add(tableBox);\n+\n+        // add a help place holder\n+        final Text startupHelpText = new Text();\n+        startupHelpText.setText(\"1. Select the connection to use\\n\"\n+                + \"2. Select your destination graph.\\n\"\n+                + \"3. Drag and drop attributes onto columns.\\n\"\n+                + \"4. Right click an attribute for more options.\\n\"\n+                + \"5. Click the 'Import' button to add data to your graph.\\n\"\n+        );\n+        startupHelpText.setStyle(\"-fx-font-size: 14pt;-fx-fill: grey;\");\n+        sampleDataView.setPlaceholder(startupHelpText);\n+\n+        sourceVertexAttributeList = new AttributeList(importController, this, AttributeType.SOURCE_VERTEX);\n+        destinationVertexAttributeList = new AttributeList(importController, this, AttributeType.DESTINATION_VERTEX);\n+        transactionAttributeList = new AttributeList(importController, this, AttributeType.TRANSACTION);\n+\n+        final AttributeBox sourceVertexScrollPane = new AttributeBox(\"Source Node Attributes \", sourceVertexAttributeList);\n+        final AttributeBox destinationVertexScrollPane = new AttributeBox(\"Destination Node Attributes \", destinationVertexAttributeList);\n+        final AttributeBox transactionScrollPane = new AttributeBox(\"Transaction Attributes \", transactionAttributeList);\n+\n+        final EasyGridPane attributePane = new EasyGridPane();\n+        attributePane.setMaxWidth(Double.MAX_VALUE);\n+\n+        attributePane.addColumnConstraint(true, HPos.CENTER, Priority.ALWAYS, Double.MAX_VALUE, 100, USE_COMPUTED_SIZE, -1);\n+        attributePane.addColumnConstraint(true, HPos.CENTER, Priority.ALWAYS, Double.MAX_VALUE, 100, USE_COMPUTED_SIZE, -1);\n+        attributePane.addColumnConstraint(true, HPos.CENTER, Priority.ALWAYS, Double.MAX_VALUE, 100, USE_COMPUTED_SIZE, -1);\n+        attributePane.addRowConstraint(true, VPos.TOP, Priority.ALWAYS, Double.MAX_VALUE, 100, USE_COMPUTED_SIZE, -1);\n+\n+        attributePane.addRow(0, sourceVertexScrollPane, destinationVertexScrollPane, transactionScrollPane);\n+\n+        attributePane.setOnKeyPressed(event -> {\n+            final KeyCode c = event.getCode();\n+            if (c == KeyCode.DELETE || c == KeyCode.BACK_SPACE) {\n+                attributeFilter = \"\";\n+                attributeFilterPane.setVisible(false);\n+            } else if (c.isLetterKey()) {\n+                attributeFilter += c.getChar();\n+                attributeFilterTextField.setText(attributeFilter);\n+                attributeFilterPane.setVisible(true);\n+            }\n+            importController.setAttributeFilter(attributeFilter);\n+            importController.setDestination(null);\n+        });\n+\n+        attributePane.setPadding(new Insets(5));\n+        attributePane.setVgap(5);\n+        attributePane.setHgap(5);\n+        attributePane.setAlignment(Pos.TOP_LEFT);\n+\n+        // A scroll pane to hold the attribute boxes\n+        final ScrollPane attributeScrollPane = new ScrollPane();\n+        attributeScrollPane.setContent(attributePane);\n+        attributeScrollPane.setMaxWidth(Double.MAX_VALUE);\n+        attributeScrollPane.setPrefHeight(350);\n+        attributeScrollPane.setHbarPolicy(ScrollPane.ScrollBarPolicy.NEVER);\n+        attributeScrollPane.setVbarPolicy(ScrollPane.ScrollBarPolicy.AS_NEEDED);\n+\n+        final Label filterLabel = new Label(\"Attribute Filter:\");\n+        attributeFilterTextField.setEditable(false);\n+        attributeFilterPane.getItems().addAll(filterLabel, attributeFilterTextField);\n+        attributeFilterPane.setVisible(false);\n+        splitPane.getItems().addAll(attributeFilterPane, attributeScrollPane);\n+        splitPane.onKeyPressedProperty().bind(attributePane.onKeyPressedProperty());\n+\n+        columnRectangle.setStyle(\"-fx-fill: rgba(200, 200, 200, 0.3);\");\n+        columnRectangle.setVisible(false);\n+        columnRectangle.setManaged(false);\n+        RunPane.this.getChildren().add(columnRectangle);\n+\n+        setOnMouseDragged((final MouseEvent t) -> {\n+            handleAttributeMoved(t.getSceneX(), t.getSceneY());\n+        });\n+\n+        setOnMouseReleased((final MouseEvent t) -> {\n+            if (draggingAttributeNode != null) {\n+                if (mouseOverColumn == null) {\n+                    draggingAttributeNode.getAttributeList().addAttributeNode(draggingAttributeNode);\n+                } else {\n+\n+                    // If the active column currently has an attribute node then return\n+                    // the attribute node to its list\n+                    final AttributeNode currentAttributeNode = mouseOverColumn.getAttributeNode();\n+                    if (currentAttributeNode != null) {\n+                        currentAttributeNode.getAttributeList().addAttributeNode(currentAttributeNode);\n+                    }\n+\n+                    // Drop the AttributeNode onto the column.\n+                    mouseOverColumn.setAttributeNode(draggingAttributeNode);\n+                    draggingAttributeNode.setColumn(mouseOverColumn);\n+                    validate(mouseOverColumn);\n+                }\n+\n+                columnRectangle.setVisible(false);\n+                draggingAttributeNode.setManaged(true);\n+                draggingAttributeNode = null;\n+                draggingOffset = null;\n+                mouseOverColumn = null;\n+            }\n+        });\n+    }\n+\n+    public Point2D getDraggingOffset() {\n+        return draggingOffset;\n+    }\n+\n+    public void setDraggingOffset(Point2D draggingOffset) {\n+        this.draggingOffset = draggingOffset;\n+    }\n+\n+    public AttributeNode getDraggingAttributeNode() {\n+        return draggingAttributeNode;\n+    }\n+\n+    public void setDraggingAttributeNode(AttributeNode draggingAttributeNode) {", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzOTAwNQ==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543039005", "bodyText": "declare as list", "author": "antares1470", "createdAt": "2020-12-15T04:33:42Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/io/ImportJDBCIO.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc.io;\n+\n+import au.gov.asd.tac.constellation.graph.Attribute;\n+import au.gov.asd.tac.constellation.graph.schema.SchemaFactory;\n+import au.gov.asd.tac.constellation.graph.schema.SchemaFactoryUtilities;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.AttributeType;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.GraphDestination;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.ImportAttributeDefinition;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.ImportController;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.ImportDefinition;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.ImportDestination;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.ImportJDBCPlugin;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.JDBCImporterStage;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.NewAttribute;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.RowFilter;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.SchemaDestination;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.translator.AttributeTranslator;\n+import au.gov.asd.tac.constellation.plugins.parameters.PluginParameters;\n+import au.gov.asd.tac.constellation.preferences.ApplicationPreferenceKeys;\n+import au.gov.asd.tac.constellation.utilities.file.FilenameEncoder;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.prefs.Preferences;\n+import org.openide.DialogDisplayer;\n+import org.openide.NotifyDescriptor;\n+import org.openide.awt.StatusDisplayer;\n+import org.openide.util.Exceptions;\n+import org.openide.util.NbPreferences;\n+\n+public class ImportJDBCIO {\n+\n+    private static final String IMPORT_DELIMITED_DIR = \"ImportDelimited\";\n+\n+    private static final String SOURCE = \"source\";\n+    private static final String PARSER = \"parser\";\n+    private static final String SCHEMA_INIT = \"schema_init\";\n+    private static final String DESTINATION = \"destination\";\n+    private static final String DEFINITIONS = \"definitions\";\n+    private static final String FILTER = \"filter\";\n+    private static final String SCRIPT = \"script\";\n+    private static final String COLUMNS = \"columns\";\n+    private static final String FIRST_ROW = \"first_row\";\n+    private static final String ATTRIBUTES = \"attributes\";\n+    private static final String COLUMN_LABEL = \"column_label\";\n+    private static final String ATTRIBUTE_LABEL = \"attribute_label\";\n+    private static final String ATTRIBUTE_TYPE = \"attribute_type\";\n+    private static final String ATTRIBUTE_DESCRIPTION = \"attribute_description\";\n+    private static final String TRANSLATOR = \"translator\";\n+    private static final String TRANSLATOR_ARGS = \"translator_args\";\n+    private static final String DEFAULT_VALUE = \"default_value\";\n+    private static final String PARAMETERS = \"parameters\";\n+    private static final String JSON_EXTENSION = \".json\";\n+\n+    public static void saveParameters(final JDBCImporterStage stage, final ImportController importController) {\n+        final Preferences prefs = NbPreferences.forModule(ApplicationPreferenceKeys.class);\n+        final String userDir = ApplicationPreferenceKeys.getUserDir(prefs);\n+        final File delimIoDir = new File(userDir, IMPORT_DELIMITED_DIR);\n+        if (!delimIoDir.exists()) {\n+            delimIoDir.mkdir();\n+        }\n+\n+        if (!delimIoDir.isDirectory()) {\n+            final String msg = String.format(\"Can't create directory '%s'.\", delimIoDir);\n+            final NotifyDescriptor nd = new NotifyDescriptor.Message(msg, NotifyDescriptor.ERROR_MESSAGE);\n+            DialogDisplayer.getDefault().notify(nd);\n+            return;\n+        }\n+\n+        final String templName = new TemplateListDialog(stage, false, null).getName(stage, delimIoDir);\n+        if (templName != null) {\n+            // A JSON document to store everything in.\n+            // Two objects; the source data + the configuration data.\n+            final ObjectMapper mapper = new ObjectMapper();\n+            final ObjectNode rootNode = mapper.createObjectNode();\n+\n+            final ObjectNode source = rootNode.putObject(SOURCE);\n+            source.put(SCHEMA_INIT, importController.isSchemaInitialised());\n+\n+            // We don't want to rely on a particular kind of graph being current when we load this definition.\n+            // Therefore, we only save a schema factory as the destination.\n+            final ImportDestination<?> importd = importController.getDestination();\n+            final String destination;\n+            if (importd instanceof SchemaDestination) {\n+                destination = ((SchemaDestination) importd).getDestination().getName();\n+            } else if (importd instanceof GraphDestination) {\n+                destination = ((GraphDestination) importd).getGraph().getSchema().getFactory().getName();\n+            } else {\n+                throw new IllegalArgumentException(String.format(\"Unrecognised destination '%s'\", importd));\n+            }\n+            source.put(DESTINATION, destination);\n+\n+            // One ImportDefinition per tab.\n+            final ArrayNode definitionArray = rootNode.putArray(DEFINITIONS);\n+            final List<ImportDefinition> definitions = importController.getDefinitions();\n+            final String[] columns = importController.getCurrentColumns();\n+            definitions.stream().forEach(impdef -> {\n+                final ObjectNode def = definitionArray.addObject();\n+\n+                def.put(FIRST_ROW, impdef.getFirstRow());\n+\n+                if (impdef.getRowFilter() != null) {\n+                    final ObjectNode filter = def.putObject(FILTER);\n+                    final ArrayNode columnsArray = filter.putArray(COLUMNS);\n+                    for (final String column : impdef.getRowFilter().getColumns()) {\n+                        columnsArray.add(column);\n+                    }\n+\n+                    final String script = impdef.getRowFilter().getScript();\n+                    if (script != null) {\n+                        filter.put(SCRIPT, script);\n+                    } else {\n+                        filter.putNull(SCRIPT);\n+                    }\n+                }\n+\n+                final ObjectNode attrDefs = def.putObject(ATTRIBUTES);\n+                for (final AttributeType attrType : AttributeType.values()) {\n+                    final ArrayNode typeArray = attrDefs.putArray(attrType.name());\n+                    final List<ImportAttributeDefinition> iadefs = impdef.getDefinitions(attrType);\n+                    iadefs.stream().forEach(iadef -> {\n+                        if (hasSavableAttribute(iadef)) {\n+                            final ObjectNode type = typeArray.addObject();\n+\n+                            // Remember the column label as a check for a similar column when we load.\n+                            // There's no point remembering the column index:  the user might have moved the columns around.\n+                            //                    type.put(COLUMN_INDEX, iadef.getColumnIndex());\n+                            // If the column index is not defined, then set the column label to null so\n+                            // that the settings still get applied in the attribute list on load\n+                            if (iadef.getColumnIndex() == ImportJDBCPlugin.ATTRIBUTE_NOT_ASSIGNED_TO_COLUMN) {\n+                                type.putNull(COLUMN_LABEL);\n+                            } else {\n+                                type.put(COLUMN_LABEL, columns[iadef.getColumnIndex() + 1]);\n+                            }\n+\n+                            type.put(ATTRIBUTE_LABEL, iadef.getAttribute().getName());\n+                            if (iadef.getAttribute() instanceof NewAttribute) {\n+                                type.put(ATTRIBUTE_TYPE, iadef.getAttribute().getAttributeType());\n+                                type.put(ATTRIBUTE_DESCRIPTION, iadef.getAttribute().getDescription());\n+                            }\n+\n+                            type.put(TRANSLATOR, iadef.getTranslator().getClass().getName());\n+                            type.put(TRANSLATOR_ARGS, iadef.getTranslator().getParameterValues(iadef.getParameters()));\n+\n+                            if (iadef.getDefaultValue() != null) {\n+                                type.put(DEFAULT_VALUE, iadef.getDefaultValue());\n+                            } else {\n+                                type.putNull(DEFAULT_VALUE);\n+                            }\n+                        }\n+                    });\n+                }\n+            });\n+\n+            mapper.configure(SerializationFeature.INDENT_OUTPUT, true);\n+            mapper.configure(SerializationFeature.CLOSE_CLOSEABLE, true);\n+            final File f = new File(delimIoDir, FilenameEncoder.encode(templName + JSON_EXTENSION));\n+            try {\n+                mapper.writeValue(f, rootNode);\n+                StatusDisplayer.getDefault().setStatusText(String.format(\"Import definition saved to %s.\", f.getPath()));\n+            } catch (final IOException ex) {\n+                final String msg = String.format(\"Can't save import definition: %s\", ex.getMessage());\n+                final NotifyDescriptor nd = new NotifyDescriptor.Message(msg, NotifyDescriptor.ERROR_MESSAGE);\n+                DialogDisplayer.getDefault().notify(nd);\n+            }\n+        }\n+    }\n+\n+    public static void loadParameters(final JDBCImporterStage stage, final ImportController importController) {\n+        final Preferences prefs = NbPreferences.forModule(ApplicationPreferenceKeys.class);\n+        final String userDir = ApplicationPreferenceKeys.getUserDir(prefs);\n+        final File delimIoDir = new File(userDir, IMPORT_DELIMITED_DIR);\n+\n+        final String templName = new TemplateListDialog(stage, true, null).getName(stage, delimIoDir);\n+        if (templName != null) {\n+            final File template = new File(delimIoDir, FilenameEncoder.encode(templName) + JSON_EXTENSION);\n+            if (!template.canRead()) {\n+                final NotifyDescriptor nd = new NotifyDescriptor.Message(String.format(\"Template %s does not exist\", templName), NotifyDescriptor.ERROR_MESSAGE);\n+                DialogDisplayer.getDefault().notify(nd);\n+            } else {\n+                try {\n+                    final ObjectMapper mapper = new ObjectMapper();\n+                    final JsonNode root = mapper.readTree(new File(delimIoDir, FilenameEncoder.encode(templName) + JSON_EXTENSION));\n+                    final JsonNode source = root.get(SOURCE);\n+\n+                    final boolean schemaInit = source.get(SCHEMA_INIT).booleanValue();\n+                    importController.setSchemaInitialised(schemaInit);\n+\n+                    final String destination = source.get(DESTINATION).textValue();\n+                    final SchemaFactory schemaFactory = SchemaFactoryUtilities.getSchemaFactory(destination);\n+                    if (schemaFactory != null) {\n+                        importController.setDestination(new SchemaDestination(schemaFactory));\n+\n+                        final List<ImportDefinition> definitions = new ArrayList<>();\n+                        final ArrayNode definitionsArray = (ArrayNode) root.withArray(DEFINITIONS);\n+                        for (final JsonNode definitionNode : definitionsArray) {\n+                            final int firstRow = definitionNode.get(FIRST_ROW).intValue();\n+                            final RowFilter filter = new RowFilter();\n+                            if (definitionNode.has(FILTER)) {\n+                                final JsonNode filterNode = definitionNode.get(FILTER);\n+                                final String script = filterNode.get(SCRIPT).textValue();\n+                                final JsonNode columnsArray = filterNode.withArray(COLUMNS);\n+                                final ArrayList<String> columns = new ArrayList<>();", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzAzOTMyOA==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r543039328", "bodyText": "Should be able to use NotifyDisplayer.notify() instead of these 2 lines", "author": "antares1470", "createdAt": "2020-12-15T04:34:32Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/io/ImportJDBCIO.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2010-2020 Australian Signals Directorate\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package au.gov.asd.tac.constellation.plugins.importexport.jdbc.io;\n+\n+import au.gov.asd.tac.constellation.graph.Attribute;\n+import au.gov.asd.tac.constellation.graph.schema.SchemaFactory;\n+import au.gov.asd.tac.constellation.graph.schema.SchemaFactoryUtilities;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.AttributeType;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.GraphDestination;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.ImportAttributeDefinition;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.ImportController;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.ImportDefinition;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.ImportDestination;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.ImportJDBCPlugin;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.JDBCImporterStage;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.NewAttribute;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.RowFilter;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.SchemaDestination;\n+import au.gov.asd.tac.constellation.plugins.importexport.jdbc.translator.AttributeTranslator;\n+import au.gov.asd.tac.constellation.plugins.parameters.PluginParameters;\n+import au.gov.asd.tac.constellation.preferences.ApplicationPreferenceKeys;\n+import au.gov.asd.tac.constellation.utilities.file.FilenameEncoder;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.SerializationFeature;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.prefs.Preferences;\n+import org.openide.DialogDisplayer;\n+import org.openide.NotifyDescriptor;\n+import org.openide.awt.StatusDisplayer;\n+import org.openide.util.Exceptions;\n+import org.openide.util.NbPreferences;\n+\n+public class ImportJDBCIO {\n+\n+    private static final String IMPORT_DELIMITED_DIR = \"ImportDelimited\";\n+\n+    private static final String SOURCE = \"source\";\n+    private static final String PARSER = \"parser\";\n+    private static final String SCHEMA_INIT = \"schema_init\";\n+    private static final String DESTINATION = \"destination\";\n+    private static final String DEFINITIONS = \"definitions\";\n+    private static final String FILTER = \"filter\";\n+    private static final String SCRIPT = \"script\";\n+    private static final String COLUMNS = \"columns\";\n+    private static final String FIRST_ROW = \"first_row\";\n+    private static final String ATTRIBUTES = \"attributes\";\n+    private static final String COLUMN_LABEL = \"column_label\";\n+    private static final String ATTRIBUTE_LABEL = \"attribute_label\";\n+    private static final String ATTRIBUTE_TYPE = \"attribute_type\";\n+    private static final String ATTRIBUTE_DESCRIPTION = \"attribute_description\";\n+    private static final String TRANSLATOR = \"translator\";\n+    private static final String TRANSLATOR_ARGS = \"translator_args\";\n+    private static final String DEFAULT_VALUE = \"default_value\";\n+    private static final String PARAMETERS = \"parameters\";\n+    private static final String JSON_EXTENSION = \".json\";\n+\n+    public static void saveParameters(final JDBCImporterStage stage, final ImportController importController) {\n+        final Preferences prefs = NbPreferences.forModule(ApplicationPreferenceKeys.class);\n+        final String userDir = ApplicationPreferenceKeys.getUserDir(prefs);\n+        final File delimIoDir = new File(userDir, IMPORT_DELIMITED_DIR);\n+        if (!delimIoDir.exists()) {\n+            delimIoDir.mkdir();\n+        }\n+\n+        if (!delimIoDir.isDirectory()) {\n+            final String msg = String.format(\"Can't create directory '%s'.\", delimIoDir);\n+            final NotifyDescriptor nd = new NotifyDescriptor.Message(msg, NotifyDescriptor.ERROR_MESSAGE);\n+            DialogDisplayer.getDefault().notify(nd);\n+            return;\n+        }\n+\n+        final String templName = new TemplateListDialog(stage, false, null).getName(stage, delimIoDir);\n+        if (templName != null) {\n+            // A JSON document to store everything in.\n+            // Two objects; the source data + the configuration data.\n+            final ObjectMapper mapper = new ObjectMapper();\n+            final ObjectNode rootNode = mapper.createObjectNode();\n+\n+            final ObjectNode source = rootNode.putObject(SOURCE);\n+            source.put(SCHEMA_INIT, importController.isSchemaInitialised());\n+\n+            // We don't want to rely on a particular kind of graph being current when we load this definition.\n+            // Therefore, we only save a schema factory as the destination.\n+            final ImportDestination<?> importd = importController.getDestination();\n+            final String destination;\n+            if (importd instanceof SchemaDestination) {\n+                destination = ((SchemaDestination) importd).getDestination().getName();\n+            } else if (importd instanceof GraphDestination) {\n+                destination = ((GraphDestination) importd).getGraph().getSchema().getFactory().getName();\n+            } else {\n+                throw new IllegalArgumentException(String.format(\"Unrecognised destination '%s'\", importd));\n+            }\n+            source.put(DESTINATION, destination);\n+\n+            // One ImportDefinition per tab.\n+            final ArrayNode definitionArray = rootNode.putArray(DEFINITIONS);\n+            final List<ImportDefinition> definitions = importController.getDefinitions();\n+            final String[] columns = importController.getCurrentColumns();\n+            definitions.stream().forEach(impdef -> {\n+                final ObjectNode def = definitionArray.addObject();\n+\n+                def.put(FIRST_ROW, impdef.getFirstRow());\n+\n+                if (impdef.getRowFilter() != null) {\n+                    final ObjectNode filter = def.putObject(FILTER);\n+                    final ArrayNode columnsArray = filter.putArray(COLUMNS);\n+                    for (final String column : impdef.getRowFilter().getColumns()) {\n+                        columnsArray.add(column);\n+                    }\n+\n+                    final String script = impdef.getRowFilter().getScript();\n+                    if (script != null) {\n+                        filter.put(SCRIPT, script);\n+                    } else {\n+                        filter.putNull(SCRIPT);\n+                    }\n+                }\n+\n+                final ObjectNode attrDefs = def.putObject(ATTRIBUTES);\n+                for (final AttributeType attrType : AttributeType.values()) {\n+                    final ArrayNode typeArray = attrDefs.putArray(attrType.name());\n+                    final List<ImportAttributeDefinition> iadefs = impdef.getDefinitions(attrType);\n+                    iadefs.stream().forEach(iadef -> {\n+                        if (hasSavableAttribute(iadef)) {\n+                            final ObjectNode type = typeArray.addObject();\n+\n+                            // Remember the column label as a check for a similar column when we load.\n+                            // There's no point remembering the column index:  the user might have moved the columns around.\n+                            //                    type.put(COLUMN_INDEX, iadef.getColumnIndex());\n+                            // If the column index is not defined, then set the column label to null so\n+                            // that the settings still get applied in the attribute list on load\n+                            if (iadef.getColumnIndex() == ImportJDBCPlugin.ATTRIBUTE_NOT_ASSIGNED_TO_COLUMN) {\n+                                type.putNull(COLUMN_LABEL);\n+                            } else {\n+                                type.put(COLUMN_LABEL, columns[iadef.getColumnIndex() + 1]);\n+                            }\n+\n+                            type.put(ATTRIBUTE_LABEL, iadef.getAttribute().getName());\n+                            if (iadef.getAttribute() instanceof NewAttribute) {\n+                                type.put(ATTRIBUTE_TYPE, iadef.getAttribute().getAttributeType());\n+                                type.put(ATTRIBUTE_DESCRIPTION, iadef.getAttribute().getDescription());\n+                            }\n+\n+                            type.put(TRANSLATOR, iadef.getTranslator().getClass().getName());\n+                            type.put(TRANSLATOR_ARGS, iadef.getTranslator().getParameterValues(iadef.getParameters()));\n+\n+                            if (iadef.getDefaultValue() != null) {\n+                                type.put(DEFAULT_VALUE, iadef.getDefaultValue());\n+                            } else {\n+                                type.putNull(DEFAULT_VALUE);\n+                            }\n+                        }\n+                    });\n+                }\n+            });\n+\n+            mapper.configure(SerializationFeature.INDENT_OUTPUT, true);\n+            mapper.configure(SerializationFeature.CLOSE_CLOSEABLE, true);\n+            final File f = new File(delimIoDir, FilenameEncoder.encode(templName + JSON_EXTENSION));\n+            try {\n+                mapper.writeValue(f, rootNode);\n+                StatusDisplayer.getDefault().setStatusText(String.format(\"Import definition saved to %s.\", f.getPath()));\n+            } catch (final IOException ex) {\n+                final String msg = String.format(\"Can't save import definition: %s\", ex.getMessage());\n+                final NotifyDescriptor nd = new NotifyDescriptor.Message(msg, NotifyDescriptor.ERROR_MESSAGE);\n+                DialogDisplayer.getDefault().notify(nd);\n+            }\n+        }\n+    }\n+\n+    public static void loadParameters(final JDBCImporterStage stage, final ImportController importController) {\n+        final Preferences prefs = NbPreferences.forModule(ApplicationPreferenceKeys.class);\n+        final String userDir = ApplicationPreferenceKeys.getUserDir(prefs);\n+        final File delimIoDir = new File(userDir, IMPORT_DELIMITED_DIR);\n+\n+        final String templName = new TemplateListDialog(stage, true, null).getName(stage, delimIoDir);\n+        if (templName != null) {\n+            final File template = new File(delimIoDir, FilenameEncoder.encode(templName) + JSON_EXTENSION);\n+            if (!template.canRead()) {\n+                final NotifyDescriptor nd = new NotifyDescriptor.Message(String.format(\"Template %s does not exist\", templName), NotifyDescriptor.ERROR_MESSAGE);\n+                DialogDisplayer.getDefault().notify(nd);\n+            } else {\n+                try {\n+                    final ObjectMapper mapper = new ObjectMapper();\n+                    final JsonNode root = mapper.readTree(new File(delimIoDir, FilenameEncoder.encode(templName) + JSON_EXTENSION));\n+                    final JsonNode source = root.get(SOURCE);\n+\n+                    final boolean schemaInit = source.get(SCHEMA_INIT).booleanValue();\n+                    importController.setSchemaInitialised(schemaInit);\n+\n+                    final String destination = source.get(DESTINATION).textValue();\n+                    final SchemaFactory schemaFactory = SchemaFactoryUtilities.getSchemaFactory(destination);\n+                    if (schemaFactory != null) {\n+                        importController.setDestination(new SchemaDestination(schemaFactory));\n+\n+                        final List<ImportDefinition> definitions = new ArrayList<>();\n+                        final ArrayNode definitionsArray = (ArrayNode) root.withArray(DEFINITIONS);\n+                        for (final JsonNode definitionNode : definitionsArray) {\n+                            final int firstRow = definitionNode.get(FIRST_ROW).intValue();\n+                            final RowFilter filter = new RowFilter();\n+                            if (definitionNode.has(FILTER)) {\n+                                final JsonNode filterNode = definitionNode.get(FILTER);\n+                                final String script = filterNode.get(SCRIPT).textValue();\n+                                final JsonNode columnsArray = filterNode.withArray(COLUMNS);\n+                                final ArrayList<String> columns = new ArrayList<>();\n+                                for (final JsonNode column : columnsArray) {\n+                                    columns.add(column.textValue());\n+                                }\n+\n+                                filter.setScript(script);\n+                                filter.setColumns(columns.toArray(new String[columns.size()]));\n+                            }\n+\n+                            final ImportDefinition impdef = new ImportDefinition(firstRow, filter);\n+\n+                            final JsonNode attributesNode = definitionNode.get(ATTRIBUTES);\n+                            for (final AttributeType attrType : AttributeType.values()) {\n+                                final ArrayNode columnArray = (ArrayNode) attributesNode.withArray(attrType.toString());\n+                                for (final JsonNode column : columnArray) {\n+                                    final String columnLabel = column.get(COLUMN_LABEL).textValue();\n+                                    final String label = column.get(ATTRIBUTE_LABEL).textValue();\n+                                    if (!importController.hasAttribute(attrType.getElementType(), label)) {\n+                                        // Manually created attribute.\n+                                        final String type = column.get(ATTRIBUTE_TYPE).textValue();\n+                                        final String descr = column.get(ATTRIBUTE_DESCRIPTION).textValue();\n+                                        final NewAttribute a = new NewAttribute(attrType.getElementType(), type, label, descr);\n+                                        importController.createManualAttribute(a);\n+                                    }\n+\n+                                    final Attribute attribute = importController.getAttribute(attrType.getElementType(), label);\n+\n+                                    final AttributeTranslator translator = AttributeTranslator.getTranslator(column.get(TRANSLATOR).textValue());\n+                                    final String args = column.get(TRANSLATOR_ARGS).textValue();\n+                                    final String defaultValue = column.get(DEFAULT_VALUE).textValue();\n+                                    final PluginParameters params = translator.createParameters();\n+                                    translator.setParameterValues(params, args);\n+\n+                                    final ImportAttributeDefinition iad = new ImportAttributeDefinition(columnLabel, defaultValue, attribute, translator, params);\n+                                    impdef.addDefinition(attrType, iad);\n+                                }\n+                            }\n+\n+                            definitions.add(impdef);\n+                        }\n+\n+                        importController.setClearManuallyAdded(false);\n+                        try {\n+                            stage.update(importController, definitions);\n+                        } finally {\n+                            importController.setClearManuallyAdded(true);\n+                        }\n+                    } else {\n+                        final String msg = String.format(\"Can't find schema factory '%s'\", destination);\n+                        final NotifyDescriptor nd = new NotifyDescriptor.Message(msg, NotifyDescriptor.ERROR_MESSAGE);\n+                        DialogDisplayer.getDefault().notify(nd);", "originalCommit": "063a6b24ef8898c205623892b798cc923e144388", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b75abe4d60d7d4eb4829fda8f99d68980f618ad1", "url": "https://github.com/constellation-app/constellation/commit/b75abe4d60d7d4eb4829fda8f99d68980f618ad1", "message": "code review fixes", "committedDate": "2020-12-22T00:11:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NDYzOTk3MA==", "url": "https://github.com/constellation-app/constellation/pull/920#discussion_r554639970", "bodyText": "would be good to rename the parameter such that there is no underscore (following naming convention)", "author": "antares1470", "createdAt": "2021-01-10T23:30:42Z", "path": "CoreImportExportPlugins/src/au/gov/asd/tac/constellation/plugins/importexport/jdbc/ConfigurationPane.java", "diffHunk": "@@ -240,9 +219,9 @@ void update(final List<ImportDefinition> definitions) {\n         // (This tends to involve Platform.runLater() so let them be queued.)\n         tabPane.getTabs().clear();\n \n-        for (final ImportDefinition impdef : definitions) {\n+        definitions.forEach(_item -> {", "originalCommit": "b75abe4d60d7d4eb4829fda8f99d68980f618ad1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d2494b4868e8851a752d01a776ebb338ab45f07c", "url": "https://github.com/constellation-app/constellation/commit/d2494b4868e8851a752d01a776ebb338ab45f07c", "message": "naming convention and ternary case", "committedDate": "2021-01-11T04:47:38Z", "type": "commit"}, {"oid": "6bb1837a0068a167eef9455630d657a9d1110c82", "url": "https://github.com/constellation-app/constellation/commit/6bb1837a0068a167eef9455630d657a9d1110c82", "message": "Merge branch 'master' into feature-JDBC_Connector", "committedDate": "2021-01-11T04:47:44Z", "type": "commit"}, {"oid": "f5ec76247216170af9774d157f8130a11eaf9b29", "url": "https://github.com/constellation-app/constellation/commit/f5ec76247216170af9774d157f8130a11eaf9b29", "message": "Update whatsnew.txt", "committedDate": "2021-01-11T04:52:50Z", "type": "commit"}]}