{"pr_number": 3337, "pr_title": "[Improvement][common] HttpClient singleton mode #3332", "pr_createdAt": "2020-07-28T14:43:29Z", "pr_url": "https://github.com/apache/dolphinscheduler/pull/3337", "timeline": [{"oid": "1238333dbddcdefd20d71e4d6b4ad331aae0350c", "url": "https://github.com/apache/dolphinscheduler/commit/1238333dbddcdefd20d71e4d6b4ad331aae0350c", "message": "Optimize the httpclient", "committedDate": "2020-07-28T14:42:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjI0NjY1MA==", "url": "https://github.com/apache/dolphinscheduler/pull/3337#discussion_r462246650", "bodyText": "public static synchronized CloseableHttpClient getHttpClient() {\nThis singleton mode will cause bad performance.", "author": "yangyichao-mango", "createdAt": "2020-07-29T12:03:58Z", "path": "dolphinscheduler-common/src/main/java/org/apache/dolphinscheduler/common/utils/HttpUtils.java", "diffHunk": "@@ -18,41 +18,116 @@\n \n import org.apache.dolphinscheduler.common.Constants;\n import org.apache.http.HttpEntity;\n+import org.apache.http.client.config.AuthSchemes;\n+import org.apache.http.client.config.CookieSpecs;\n import org.apache.http.client.config.RequestConfig;\n import org.apache.http.client.methods.CloseableHttpResponse;\n import org.apache.http.client.methods.HttpGet;\n+import org.apache.http.config.Registry;\n+import org.apache.http.config.RegistryBuilder;\n+import org.apache.http.conn.socket.ConnectionSocketFactory;\n+import org.apache.http.conn.socket.PlainConnectionSocketFactory;\n+import org.apache.http.conn.ssl.NoopHostnameVerifier;\n+import org.apache.http.conn.ssl.SSLConnectionSocketFactory;\n import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.DefaultHttpClient;\n import org.apache.http.impl.client.HttpClients;\n+import org.apache.http.impl.conn.PoolingHttpClientConnectionManager;\n import org.apache.http.util.EntityUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import javax.net.ssl.SSLContext;\n+import javax.net.ssl.TrustManager;\n+import javax.net.ssl.X509TrustManager;\n import java.io.IOException;\n-\n+import java.security.KeyManagementException;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.X509Certificate;\n+import java.util.Arrays;\n /**\n  * http utils\n  */\n public class HttpUtils {\n-\t\n-\t\n+\n+\n \tpublic static final Logger logger = LoggerFactory.getLogger(HttpUtils.class);\n \n+\n+\tprivate static CloseableHttpClient httpClient;\n+\n+\tprivate HttpUtils() {\n+\n+\t}\n+\n+\tprivate static PoolingHttpClientConnectionManager cm;\n+\n+\tprivate static SSLContext ctx = null;\n+\n+\tprivate static SSLConnectionSocketFactory socketFactory;\n+\n+\tprivate static RequestConfig requestConfig;\n+\n+\tprivate static Registry<ConnectionSocketFactory> socketFactoryRegistry;\n+\n+\tprivate static X509TrustManager xtm = new X509TrustManager() {\n+\t\t@Override\n+\t\tpublic void checkClientTrusted(X509Certificate[] chain, String authType) {\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void checkServerTrusted(X509Certificate[] chain, String authType) {\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic X509Certificate[] getAcceptedIssuers() {\n+\t\t\treturn null;\n+\t\t}\n+\t};\n+\n+\tstatic {\n+\t\ttry {\n+\t\t\tctx = SSLContext.getInstance(SSLConnectionSocketFactory.TLS);\n+\t\t\tctx.init(null, new TrustManager[] { xtm }, null);\n+\t\t} catch (NoSuchAlgorithmException e) {\n+\t\t\tlogger.error(\"SSLContext init with NoSuchAlgorithmException\", e);\n+\t\t} catch (KeyManagementException e) {\n+\t\t\tlogger.error(\"SSLContext init with KeyManagementException\", e);\n+\t\t}\n+\t\tsocketFactory = new SSLConnectionSocketFactory(ctx, NoopHostnameVerifier.INSTANCE);\n+\t\t/** set timeout\u3001request time\u3001socket timeout */\n+\t\trequestConfig = RequestConfig.custom().setCookieSpec(CookieSpecs.IGNORE_COOKIES)\n+\t\t\t\t.setExpectContinueEnabled(Boolean.TRUE)\n+\t\t\t\t.setTargetPreferredAuthSchemes(Arrays.asList(AuthSchemes.NTLM, AuthSchemes.DIGEST))\n+\t\t\t\t.setProxyPreferredAuthSchemes(Arrays.asList(AuthSchemes.BASIC))\n+\t\t\t\t.setConnectTimeout(Constants.HTTP_CONNECT_TIMEOUT).setSocketTimeout(Constants.SOCKET_TIMEOUT)\n+\t\t\t\t.setConnectionRequestTimeout(Constants.HTTP_CONNECTION_REQUEST_TIMEOUT).setRedirectsEnabled(true)\n+\t\t\t\t.build();\n+\t\tsocketFactoryRegistry = RegistryBuilder.<ConnectionSocketFactory>create()\n+\t\t\t\t.register(\"http\", PlainConnectionSocketFactory.INSTANCE).register(\"https\", socketFactory).build();\n+\t\tcm = new PoolingHttpClientConnectionManager(socketFactoryRegistry);\n+\t\tcm.setDefaultMaxPerRoute(60);\n+\t\tcm.setMaxTotal(100);\n+\n+\t}\n+\n+\n+\tpublic static synchronized CloseableHttpClient getHttpClient() {", "originalCommit": "1238333dbddcdefd20d71e4d6b4ad331aae0350c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}