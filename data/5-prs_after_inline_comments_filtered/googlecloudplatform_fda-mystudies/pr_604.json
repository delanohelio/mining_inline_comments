{"pr_number": 604, "pr_title": "user mgmt pending integration testcases", "pr_createdAt": "2020-07-08T13:49:37Z", "pr_url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604", "timeline": [{"oid": "52753346d525412760bdf85906a23a532bcd8c5f", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/commit/52753346d525412760bdf85906a23a532bcd8c5f", "message": "pending Integration Testcases for user-mgmt bundle\n\npending Integration Testcases for user-mgmt bundle", "committedDate": "2020-07-08T11:57:35Z", "type": "commit"}, {"oid": "ab81f5157b2f27fe98f82c87adea65496e3cd67e", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/commit/ab81f5157b2f27fe98f82c87adea65496e3cd67e", "message": "Code commit for pending Integration TestCases\n\nCode commit for pending Integration TestCases", "committedDate": "2020-07-08T13:47:14Z", "type": "commit"}, {"oid": "d936de6442c2de6817d1f669f6241c4cfbd1dd59", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/commit/d936de6442c2de6817d1f669f6241c4cfbd1dd59", "message": "change the log level to debug to analyze build issue\n\nadded debug statement and change the log level  to debug", "committedDate": "2020-07-09T07:25:59Z", "type": "commit"}, {"oid": "6a9fba1f2f17ad76cdf92ef8bd7172e105048c79", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/commit/6a9fba1f2f17ad76cdf92ef8bd7172e105048c79", "message": "add a debug statements to analyze build issue\n\nadd a debug statements to analyze build issue", "committedDate": "2020-07-09T07:47:08Z", "type": "commit"}, {"oid": "8e5ad51e86173370381c4fe323671a89ce7cfb80", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/commit/8e5ad51e86173370381c4fe323671a89ce7cfb80", "message": "removed the duplicate lombok", "committedDate": "2020-07-10T12:27:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzA3OTYxOQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453079619", "bodyText": "tests should not be dependent. Proper post test clean up can help with this.", "author": "zohrehj", "createdAt": "2020-07-10T21:12:44Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserRegistrationControllerTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.test.web.servlet.MvcResult;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.github.tomakehurst.wiremock.matching.ContainsPattern;\n+import com.google.cloud.healthcare.fdamystudies.beans.UserRegistrationForm;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;\n+import com.google.cloud.healthcare.fdamystudies.controller.UserRegistrationController;\n+import com.google.cloud.healthcare.fdamystudies.model.UserDetailsBO;\n+import com.google.cloud.healthcare.fdamystudies.service.CommonService;\n+import com.google.cloud.healthcare.fdamystudies.service.FdaEaUserDetailsServiceImpl;\n+import com.google.cloud.healthcare.fdamystudies.testutils.Constants;\n+import com.google.cloud.healthcare.fdamystudies.testutils.TestUtils;\n+import com.jayway.jsonpath.JsonPath;\n+\n+@TestMethodOrder(OrderAnnotation.class)\n+public class UserRegistrationControllerTest extends BaseMockIT {\n+\n+  private static final String REGISTER_PATH = \"/register\";\n+\n+  @Autowired private FdaEaUserDetailsServiceImpl userDetailsService;\n+\n+  @Autowired private UserRegistrationController controller;\n+\n+  @Autowired private CommonService service;\n+\n+  @Value(\"${register.url}\")\n+  private String authRegisterUrl;\n+\n+  @Test\n+  public void contextLoads() {\n+    assertNotNull(controller);\n+    assertNotNull(mockMvc);\n+    assertNotNull(service);\n+  }\n+\n+  @Test\n+  public void healthCheck() throws Exception {\n+    mockMvc.perform(get(\"/healthCheck\")).andDo(print()).andExpect(status().isOk());\n+  }\n+\n+  @Order(1)", "originalCommit": "8e5ad51e86173370381c4fe323671a89ce7cfb80", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "56261cc0b3c516840416d1f377c374eca45314e4", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/commit/56261cc0b3c516840416d1f377c374eca45314e4", "message": "Merge branch 'early-access-user-mgmt-integration-test' into early-access-user-mgmt-pending-integration-testcases", "committedDate": "2020-07-13T10:29:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzY5NA==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553694", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nExtra separation in import group before 'lombok.AllArgsConstructor'", "author": "github-actions", "createdAt": "2020-07-13T10:30:29Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/beans/UserRegistrationForm.java", "diffHunk": "@@ -9,19 +9,24 @@\n package com.google.cloud.healthcare.fdamystudies.beans;\n \n import java.time.LocalDateTime;\n+\n import javax.validation.constraints.NotNull;\n+\n+import lombok.AllArgsConstructor;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYzMjc4Ng==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r463632786", "bodyText": "please fix.", "author": "zohrehj", "createdAt": "2020-07-31T14:07:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzY5Ng==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553696", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nMissing a Javadoc comment.", "author": "github-actions", "createdAt": "2020-07-13T10:30:29Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/beans/UserRegistrationForm.java", "diffHunk": "@@ -39,4 +44,10 @@ public UserRegistrationForm(String userId, String emailId, String password) {\n     this.emailId = emailId;\n     this.password = password;\n   }\n+\n+  public UserRegistrationForm(@NotNull String emailId, String password) {", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzY5OQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553699", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nExtra separation in import group before 'lombok.AllArgsConstructor'", "author": "github-actions", "createdAt": "2020-07-13T10:30:29Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/beans/EmailIdVerificationForm.java", "diffHunk": "@@ -9,11 +9,16 @@\n package com.google.cloud.healthcare.fdamystudies.beans;\n \n import javax.validation.constraints.NotBlank;\n+\n+import lombok.AllArgsConstructor;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYzMjg4MA==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r463632880", "bodyText": "please fix.", "author": "zohrehj", "createdAt": "2020-07-31T14:08:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzY5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzcwMg==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553702", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nExtra separation in import group before 'com.fasterxml.jackson.core.JsonProcessingException'", "author": "github-actions", "createdAt": "2020-07-13T10:30:30Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserSupportControllerTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpHeaders;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYzMjk2MQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r463632961", "bodyText": "please fix.", "author": "zohrehj", "createdAt": "2020-07-31T14:08:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzcwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzcwNQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553705", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.fasterxml.jackson.core.JsonProcessingException' import. Should be before 'org.springframework.http.HttpHeaders'.", "author": "github-actions", "createdAt": "2020-07-13T10:30:30Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserSupportControllerTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpHeaders;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYzMzExMQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r463633111", "bodyText": "please fix the order.", "author": "zohrehj", "createdAt": "2020-07-31T14:08:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzcwNw==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553707", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.beans.ContactUsReqBean' import. Should be before 'org.springframework.http.HttpHeaders'.", "author": "github-actions", "createdAt": "2020-07-13T10:30:30Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserSupportControllerTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpHeaders;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.cloud.healthcare.fdamystudies.beans.ContactUsReqBean;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzcwOQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553709", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.beans.FeedbackReqBean' import. Should be before 'org.springframework.http.HttpHeaders'.", "author": "github-actions", "createdAt": "2020-07-13T10:30:30Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserSupportControllerTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpHeaders;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.cloud.healthcare.fdamystudies.beans.ContactUsReqBean;\n+import com.google.cloud.healthcare.fdamystudies.beans.FeedbackReqBean;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzcxMQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553711", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.common.BaseMockIT' import. Should be before 'org.springframework.http.HttpHeaders'.", "author": "github-actions", "createdAt": "2020-07-13T10:30:30Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserSupportControllerTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpHeaders;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.cloud.healthcare.fdamystudies.beans.ContactUsReqBean;\n+import com.google.cloud.healthcare.fdamystudies.beans.FeedbackReqBean;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzcxMw==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553713", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.config.ApplicationPropertyConfiguration' import. Should be before 'org.springframework.http.HttpHeaders'.", "author": "github-actions", "createdAt": "2020-07-13T10:30:30Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserSupportControllerTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpHeaders;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.cloud.healthcare.fdamystudies.beans.ContactUsReqBean;\n+import com.google.cloud.healthcare.fdamystudies.beans.FeedbackReqBean;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;\n+import com.google.cloud.healthcare.fdamystudies.config.ApplicationPropertyConfiguration;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzcxNA==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553714", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.controller.UserSupportController' import. Should be before 'org.springframework.http.HttpHeaders'.", "author": "github-actions", "createdAt": "2020-07-13T10:30:30Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserSupportControllerTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpHeaders;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.cloud.healthcare.fdamystudies.beans.ContactUsReqBean;\n+import com.google.cloud.healthcare.fdamystudies.beans.FeedbackReqBean;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;\n+import com.google.cloud.healthcare.fdamystudies.config.ApplicationPropertyConfiguration;\n+import com.google.cloud.healthcare.fdamystudies.controller.UserSupportController;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzcxNg==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553716", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.service.UserSupportService' import. Should be before 'org.springframework.http.HttpHeaders'.", "author": "github-actions", "createdAt": "2020-07-13T10:30:30Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserSupportControllerTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpHeaders;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.cloud.healthcare.fdamystudies.beans.ContactUsReqBean;\n+import com.google.cloud.healthcare.fdamystudies.beans.FeedbackReqBean;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;\n+import com.google.cloud.healthcare.fdamystudies.config.ApplicationPropertyConfiguration;\n+import com.google.cloud.healthcare.fdamystudies.controller.UserSupportController;\n+import com.google.cloud.healthcare.fdamystudies.service.UserSupportService;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzcxNw==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553717", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.testutils.Constants' import. Should be before 'org.springframework.http.HttpHeaders'.", "author": "github-actions", "createdAt": "2020-07-13T10:30:31Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserSupportControllerTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpHeaders;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.cloud.healthcare.fdamystudies.beans.ContactUsReqBean;\n+import com.google.cloud.healthcare.fdamystudies.beans.FeedbackReqBean;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;\n+import com.google.cloud.healthcare.fdamystudies.config.ApplicationPropertyConfiguration;\n+import com.google.cloud.healthcare.fdamystudies.controller.UserSupportController;\n+import com.google.cloud.healthcare.fdamystudies.service.UserSupportService;\n+import com.google.cloud.healthcare.fdamystudies.testutils.Constants;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzcxOA==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553718", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.testutils.TestUtils' import. Should be before 'org.springframework.http.HttpHeaders'.", "author": "github-actions", "createdAt": "2020-07-13T10:30:31Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserSupportControllerTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpHeaders;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.cloud.healthcare.fdamystudies.beans.ContactUsReqBean;\n+import com.google.cloud.healthcare.fdamystudies.beans.FeedbackReqBean;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;\n+import com.google.cloud.healthcare.fdamystudies.config.ApplicationPropertyConfiguration;\n+import com.google.cloud.healthcare.fdamystudies.controller.UserSupportController;\n+import com.google.cloud.healthcare.fdamystudies.service.UserSupportService;\n+import com.google.cloud.healthcare.fdamystudies.testutils.Constants;\n+import com.google.cloud.healthcare.fdamystudies.testutils.TestUtils;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzcxOQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553719", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.util.EmailNotification' import. Should be before 'org.springframework.http.HttpHeaders'.", "author": "github-actions", "createdAt": "2020-07-13T10:30:31Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserSupportControllerTest.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.mockito.ArgumentMatchers.eq;\n+import static org.mockito.Mockito.times;\n+import static org.mockito.Mockito.verify;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.junit.jupiter.api.Test;\n+import org.mockito.Mockito;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpHeaders;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.cloud.healthcare.fdamystudies.beans.ContactUsReqBean;\n+import com.google.cloud.healthcare.fdamystudies.beans.FeedbackReqBean;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;\n+import com.google.cloud.healthcare.fdamystudies.config.ApplicationPropertyConfiguration;\n+import com.google.cloud.healthcare.fdamystudies.controller.UserSupportController;\n+import com.google.cloud.healthcare.fdamystudies.service.UserSupportService;\n+import com.google.cloud.healthcare.fdamystudies.testutils.Constants;\n+import com.google.cloud.healthcare.fdamystudies.testutils.TestUtils;\n+import com.google.cloud.healthcare.fdamystudies.util.EmailNotification;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzcyMQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553721", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.util.EmailNotification' import. Should be before 'org.springframework.test.web.servlet.MvcResult'.", "author": "github-actions", "createdAt": "2020-07-13T10:30:31Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserProfileControllerTest.java", "diffHunk": "@@ -28,13 +29,13 @@\n import com.google.cloud.healthcare.fdamystudies.beans.SettingsRespBean;\n import com.google.cloud.healthcare.fdamystudies.beans.UserRequestBean;\n import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;\n-import com.google.cloud.healthcare.fdamystudies.config.AppConfig;\n import com.google.cloud.healthcare.fdamystudies.controller.UserProfileController;\n import com.google.cloud.healthcare.fdamystudies.model.UserDetailsBO;\n import com.google.cloud.healthcare.fdamystudies.service.FdaEaUserDetailsServiceImpl;\n import com.google.cloud.healthcare.fdamystudies.service.UserManagementProfileService;\n import com.google.cloud.healthcare.fdamystudies.testutils.Constants;\n import com.google.cloud.healthcare.fdamystudies.testutils.TestUtils;\n+import com.google.cloud.healthcare.fdamystudies.util.EmailNotification;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzcyMw==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553723", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nExtra separation in import group before 'com.fasterxml.jackson.core.JsonProcessingException'", "author": "github-actions", "createdAt": "2020-07-13T10:30:31Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserRegistrationControllerTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.test.web.servlet.MvcResult;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzcyNg==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553726", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.fasterxml.jackson.core.JsonProcessingException' import. Should be before 'org.springframework.test.web.servlet.MvcResult'.", "author": "github-actions", "createdAt": "2020-07-13T10:30:31Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserRegistrationControllerTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.test.web.servlet.MvcResult;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzcyNw==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553727", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.github.tomakehurst.wiremock.matching.ContainsPattern' import. Should be before 'org.springframework.test.web.servlet.MvcResult'.", "author": "github-actions", "createdAt": "2020-07-13T10:30:31Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserRegistrationControllerTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.test.web.servlet.MvcResult;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.github.tomakehurst.wiremock.matching.ContainsPattern;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzcyOA==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553728", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.beans.UserRegistrationForm' import. Should be before 'org.springframework.test.web.servlet.MvcResult'.", "author": "github-actions", "createdAt": "2020-07-13T10:30:31Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserRegistrationControllerTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.test.web.servlet.MvcResult;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.github.tomakehurst.wiremock.matching.ContainsPattern;\n+import com.google.cloud.healthcare.fdamystudies.beans.UserRegistrationForm;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzcyOQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553729", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.common.BaseMockIT' import. Should be before 'org.springframework.test.web.servlet.MvcResult'.", "author": "github-actions", "createdAt": "2020-07-13T10:30:31Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserRegistrationControllerTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.test.web.servlet.MvcResult;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.github.tomakehurst.wiremock.matching.ContainsPattern;\n+import com.google.cloud.healthcare.fdamystudies.beans.UserRegistrationForm;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzczMQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553731", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.controller.UserRegistrationController' import. Should be before 'org.springframework.test.web.servlet.MvcResult'.", "author": "github-actions", "createdAt": "2020-07-13T10:30:32Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserRegistrationControllerTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.test.web.servlet.MvcResult;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.github.tomakehurst.wiremock.matching.ContainsPattern;\n+import com.google.cloud.healthcare.fdamystudies.beans.UserRegistrationForm;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;\n+import com.google.cloud.healthcare.fdamystudies.controller.UserRegistrationController;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzczMw==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553733", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.model.UserDetailsBO' import. Should be before 'org.springframework.test.web.servlet.MvcResult'.", "author": "github-actions", "createdAt": "2020-07-13T10:30:32Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserRegistrationControllerTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.test.web.servlet.MvcResult;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.github.tomakehurst.wiremock.matching.ContainsPattern;\n+import com.google.cloud.healthcare.fdamystudies.beans.UserRegistrationForm;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;\n+import com.google.cloud.healthcare.fdamystudies.controller.UserRegistrationController;\n+import com.google.cloud.healthcare.fdamystudies.model.UserDetailsBO;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzczNg==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553736", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.service.CommonService' import. Should be before 'org.springframework.test.web.servlet.MvcResult'.", "author": "github-actions", "createdAt": "2020-07-13T10:30:32Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserRegistrationControllerTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.test.web.servlet.MvcResult;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.github.tomakehurst.wiremock.matching.ContainsPattern;\n+import com.google.cloud.healthcare.fdamystudies.beans.UserRegistrationForm;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;\n+import com.google.cloud.healthcare.fdamystudies.controller.UserRegistrationController;\n+import com.google.cloud.healthcare.fdamystudies.model.UserDetailsBO;\n+import com.google.cloud.healthcare.fdamystudies.service.CommonService;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1MzczOQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553739", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.service.FdaEaUserDetailsServiceImpl' import. Should be before 'org.springframework.test.web.servlet.MvcResult'.", "author": "github-actions", "createdAt": "2020-07-13T10:30:32Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserRegistrationControllerTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.test.web.servlet.MvcResult;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.github.tomakehurst.wiremock.matching.ContainsPattern;\n+import com.google.cloud.healthcare.fdamystudies.beans.UserRegistrationForm;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;\n+import com.google.cloud.healthcare.fdamystudies.controller.UserRegistrationController;\n+import com.google.cloud.healthcare.fdamystudies.model.UserDetailsBO;\n+import com.google.cloud.healthcare.fdamystudies.service.CommonService;\n+import com.google.cloud.healthcare.fdamystudies.service.FdaEaUserDetailsServiceImpl;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1Mzc0MA==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553740", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.testutils.Constants' import. Should be before 'org.springframework.test.web.servlet.MvcResult'.", "author": "github-actions", "createdAt": "2020-07-13T10:30:32Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserRegistrationControllerTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.test.web.servlet.MvcResult;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.github.tomakehurst.wiremock.matching.ContainsPattern;\n+import com.google.cloud.healthcare.fdamystudies.beans.UserRegistrationForm;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;\n+import com.google.cloud.healthcare.fdamystudies.controller.UserRegistrationController;\n+import com.google.cloud.healthcare.fdamystudies.model.UserDetailsBO;\n+import com.google.cloud.healthcare.fdamystudies.service.CommonService;\n+import com.google.cloud.healthcare.fdamystudies.service.FdaEaUserDetailsServiceImpl;\n+import com.google.cloud.healthcare.fdamystudies.testutils.Constants;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1Mzc0MQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553741", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.testutils.TestUtils' import. Should be before 'org.springframework.test.web.servlet.MvcResult'.", "author": "github-actions", "createdAt": "2020-07-13T10:30:32Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserRegistrationControllerTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.test.web.servlet.MvcResult;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.github.tomakehurst.wiremock.matching.ContainsPattern;\n+import com.google.cloud.healthcare.fdamystudies.beans.UserRegistrationForm;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;\n+import com.google.cloud.healthcare.fdamystudies.controller.UserRegistrationController;\n+import com.google.cloud.healthcare.fdamystudies.model.UserDetailsBO;\n+import com.google.cloud.healthcare.fdamystudies.service.CommonService;\n+import com.google.cloud.healthcare.fdamystudies.service.FdaEaUserDetailsServiceImpl;\n+import com.google.cloud.healthcare.fdamystudies.testutils.Constants;\n+import com.google.cloud.healthcare.fdamystudies.testutils.TestUtils;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1Mzc0Mg==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553742", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.jayway.jsonpath.JsonPath' import. Should be before 'org.springframework.test.web.servlet.MvcResult'.", "author": "github-actions", "createdAt": "2020-07-13T10:30:32Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/UserRegistrationControllerTest.java", "diffHunk": "@@ -0,0 +1,166 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import org.junit.jupiter.api.MethodOrderer.OrderAnnotation;\n+import org.junit.jupiter.api.Order;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.TestMethodOrder;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.test.web.servlet.MvcResult;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.github.tomakehurst.wiremock.matching.ContainsPattern;\n+import com.google.cloud.healthcare.fdamystudies.beans.UserRegistrationForm;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;\n+import com.google.cloud.healthcare.fdamystudies.controller.UserRegistrationController;\n+import com.google.cloud.healthcare.fdamystudies.model.UserDetailsBO;\n+import com.google.cloud.healthcare.fdamystudies.service.CommonService;\n+import com.google.cloud.healthcare.fdamystudies.service.FdaEaUserDetailsServiceImpl;\n+import com.google.cloud.healthcare.fdamystudies.testutils.Constants;\n+import com.google.cloud.healthcare.fdamystudies.testutils.TestUtils;\n+import com.jayway.jsonpath.JsonPath;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1Mzc0NA==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553744", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nExtra separation in import group before 'org.apache.commons.lang3.StringUtils'", "author": "github-actions", "createdAt": "2020-07-13T10:30:32Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/VerifyEmailIdControllerTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5ODU2OA==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465698568", "bodyText": "please fix.", "author": "zohrehj", "createdAt": "2020-08-05T12:44:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1Mzc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1Mzc0OA==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553748", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nExtra separation in import group before 'com.fasterxml.jackson.core.JsonProcessingException'", "author": "github-actions", "createdAt": "2020-07-13T10:30:32Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/VerifyEmailIdControllerTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5ODQ5MQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465698491", "bodyText": "please fix here as well", "author": "zohrehj", "createdAt": "2020-08-05T12:44:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1Mzc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzU1Mzc0OQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r453553749", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.fasterxml.jackson.core.JsonProcessingException' import. Should be before 'org.springframework.http.HttpStatus'.", "author": "github-actions", "createdAt": "2020-07-13T10:30:33Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/VerifyEmailIdControllerTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;", "originalCommit": "56261cc0b3c516840416d1f377c374eca45314e4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "76abf660a5b779ee321f0b67df02e0ceb938e91b", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/commit/76abf660a5b779ee321f0b67df02e0ceb938e91b", "message": "added wrongly removed lombok dependency", "committedDate": "2020-07-17T09:16:49Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMyMzk3MQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r456323971", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.beans.EmailIdVerificationForm' import. Should be before 'org.springframework.http.HttpStatus'.", "author": "github-actions", "createdAt": "2020-07-17T09:17:47Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/VerifyEmailIdControllerTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.cloud.healthcare.fdamystudies.beans.EmailIdVerificationForm;", "originalCommit": "76abf660a5b779ee321f0b67df02e0ceb938e91b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5ODY2MQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465698661", "bodyText": "please fix", "author": "zohrehj", "createdAt": "2020-08-05T12:44:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMyMzk3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMyMzk3Mw==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r456323973", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.common.BaseMockIT' import. Should be before 'org.springframework.http.HttpStatus'.", "author": "github-actions", "createdAt": "2020-07-17T09:17:47Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/VerifyEmailIdControllerTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.cloud.healthcare.fdamystudies.beans.EmailIdVerificationForm;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;", "originalCommit": "76abf660a5b779ee321f0b67df02e0ceb938e91b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMyMzk3NA==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r456323974", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.controller.VerifyEmailIdController' import. Should be before 'org.springframework.http.HttpStatus'.", "author": "github-actions", "createdAt": "2020-07-17T09:17:47Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/VerifyEmailIdControllerTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.cloud.healthcare.fdamystudies.beans.EmailIdVerificationForm;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;\n+import com.google.cloud.healthcare.fdamystudies.controller.VerifyEmailIdController;", "originalCommit": "76abf660a5b779ee321f0b67df02e0ceb938e91b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMyMzk3Ng==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r456323976", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.dao.UserProfileManagementDaoImpl' import. Should be before 'org.springframework.http.HttpStatus'.", "author": "github-actions", "createdAt": "2020-07-17T09:17:47Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/VerifyEmailIdControllerTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.cloud.healthcare.fdamystudies.beans.EmailIdVerificationForm;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;\n+import com.google.cloud.healthcare.fdamystudies.controller.VerifyEmailIdController;\n+import com.google.cloud.healthcare.fdamystudies.dao.UserProfileManagementDaoImpl;", "originalCommit": "76abf660a5b779ee321f0b67df02e0ceb938e91b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTY5ODgzMA==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465698830", "bodyText": "please fix", "author": "zohrehj", "createdAt": "2020-08-05T12:44:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMyMzk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMyMzk3Nw==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r456323977", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.model.AppInfoDetailsBO' import. Should be before 'org.springframework.http.HttpStatus'.", "author": "github-actions", "createdAt": "2020-07-17T09:17:47Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/VerifyEmailIdControllerTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.cloud.healthcare.fdamystudies.beans.EmailIdVerificationForm;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;\n+import com.google.cloud.healthcare.fdamystudies.controller.VerifyEmailIdController;\n+import com.google.cloud.healthcare.fdamystudies.dao.UserProfileManagementDaoImpl;\n+import com.google.cloud.healthcare.fdamystudies.model.AppInfoDetailsBO;", "originalCommit": "76abf660a5b779ee321f0b67df02e0ceb938e91b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMyMzk3OQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r456323979", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.model.UserDetailsBO' import. Should be before 'org.springframework.http.HttpStatus'.", "author": "github-actions", "createdAt": "2020-07-17T09:17:47Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/VerifyEmailIdControllerTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.cloud.healthcare.fdamystudies.beans.EmailIdVerificationForm;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;\n+import com.google.cloud.healthcare.fdamystudies.controller.VerifyEmailIdController;\n+import com.google.cloud.healthcare.fdamystudies.dao.UserProfileManagementDaoImpl;\n+import com.google.cloud.healthcare.fdamystudies.model.AppInfoDetailsBO;\n+import com.google.cloud.healthcare.fdamystudies.model.UserDetailsBO;", "originalCommit": "76abf660a5b779ee321f0b67df02e0ceb938e91b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMyMzk4MQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r456323981", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.repository.UserDetailsBORepository' import. Should be before 'org.springframework.http.HttpStatus'.", "author": "github-actions", "createdAt": "2020-07-17T09:17:47Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/VerifyEmailIdControllerTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.cloud.healthcare.fdamystudies.beans.EmailIdVerificationForm;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;\n+import com.google.cloud.healthcare.fdamystudies.controller.VerifyEmailIdController;\n+import com.google.cloud.healthcare.fdamystudies.dao.UserProfileManagementDaoImpl;\n+import com.google.cloud.healthcare.fdamystudies.model.AppInfoDetailsBO;\n+import com.google.cloud.healthcare.fdamystudies.model.UserDetailsBO;\n+import com.google.cloud.healthcare.fdamystudies.repository.UserDetailsBORepository;", "originalCommit": "76abf660a5b779ee321f0b67df02e0ceb938e91b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMyMzk4Mg==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r456323982", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.service.CommonService' import. Should be before 'org.springframework.http.HttpStatus'.", "author": "github-actions", "createdAt": "2020-07-17T09:17:47Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/VerifyEmailIdControllerTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.cloud.healthcare.fdamystudies.beans.EmailIdVerificationForm;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;\n+import com.google.cloud.healthcare.fdamystudies.controller.VerifyEmailIdController;\n+import com.google.cloud.healthcare.fdamystudies.dao.UserProfileManagementDaoImpl;\n+import com.google.cloud.healthcare.fdamystudies.model.AppInfoDetailsBO;\n+import com.google.cloud.healthcare.fdamystudies.model.UserDetailsBO;\n+import com.google.cloud.healthcare.fdamystudies.repository.UserDetailsBORepository;\n+import com.google.cloud.healthcare.fdamystudies.service.CommonService;", "originalCommit": "76abf660a5b779ee321f0b67df02e0ceb938e91b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMyMzk4NQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r456323985", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.testutils.Constants' import. Should be before 'org.springframework.http.HttpStatus'.", "author": "github-actions", "createdAt": "2020-07-17T09:17:48Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/VerifyEmailIdControllerTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.cloud.healthcare.fdamystudies.beans.EmailIdVerificationForm;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;\n+import com.google.cloud.healthcare.fdamystudies.controller.VerifyEmailIdController;\n+import com.google.cloud.healthcare.fdamystudies.dao.UserProfileManagementDaoImpl;\n+import com.google.cloud.healthcare.fdamystudies.model.AppInfoDetailsBO;\n+import com.google.cloud.healthcare.fdamystudies.model.UserDetailsBO;\n+import com.google.cloud.healthcare.fdamystudies.repository.UserDetailsBORepository;\n+import com.google.cloud.healthcare.fdamystudies.service.CommonService;\n+import com.google.cloud.healthcare.fdamystudies.testutils.Constants;", "originalCommit": "76abf660a5b779ee321f0b67df02e0ceb938e91b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMyMzk4Ng==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r456323986", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nWrong lexicographical order for 'com.google.cloud.healthcare.fdamystudies.testutils.TestUtils' import. Should be before 'org.springframework.http.HttpStatus'.", "author": "github-actions", "createdAt": "2020-07-17T09:17:48Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/controller/tests/VerifyEmailIdControllerTest.java", "diffHunk": "@@ -0,0 +1,118 @@\n+package com.google.cloud.healthcare.fdamystudies.controller.tests;\n+\n+import static com.github.tomakehurst.wiremock.client.WireMock.postRequestedFor;\n+import static com.github.tomakehurst.wiremock.client.WireMock.urlEqualTo;\n+import static com.github.tomakehurst.wiremock.client.WireMock.verify;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.junit.jupiter.api.Assertions.assertNotNull;\n+import static org.junit.jupiter.api.Assertions.assertTrue;\n+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;\n+import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;\n+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+import org.junit.jupiter.api.Test;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+\n+import com.fasterxml.jackson.core.JsonProcessingException;\n+import com.google.cloud.healthcare.fdamystudies.beans.EmailIdVerificationForm;\n+import com.google.cloud.healthcare.fdamystudies.common.BaseMockIT;\n+import com.google.cloud.healthcare.fdamystudies.controller.VerifyEmailIdController;\n+import com.google.cloud.healthcare.fdamystudies.dao.UserProfileManagementDaoImpl;\n+import com.google.cloud.healthcare.fdamystudies.model.AppInfoDetailsBO;\n+import com.google.cloud.healthcare.fdamystudies.model.UserDetailsBO;\n+import com.google.cloud.healthcare.fdamystudies.repository.UserDetailsBORepository;\n+import com.google.cloud.healthcare.fdamystudies.service.CommonService;\n+import com.google.cloud.healthcare.fdamystudies.testutils.Constants;\n+import com.google.cloud.healthcare.fdamystudies.testutils.TestUtils;", "originalCommit": "76abf660a5b779ee321f0b67df02e0ceb938e91b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "59a94b3c94d5cdcf822104d6448293bb3143fd8b", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/commit/59a94b3c94d5cdcf822104d6448293bb3143fd8b", "message": "added debugger to check which test method fails", "committedDate": "2020-07-17T10:26:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1ODY5Ng==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r456358696", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nExtra separation in import group before 'org.junit.jupiter.api.AfterEach'", "author": "github-actions", "createdAt": "2020-07-17T10:27:14Z", "path": "user-registration-server-ws/user-mgmt/src/test/java/com/google/cloud/healthcare/fdamystudies/common/BaseMockIT.java", "diffHunk": "@@ -15,7 +15,14 @@\n import static org.springframework.test.web.servlet.result.MockMvcResultHandlers.print;\n import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;\n import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;\n+\n import javax.servlet.http.Cookie;\n+\n+import org.junit.jupiter.api.AfterEach;", "originalCommit": "59a94b3c94d5cdcf822104d6448293bb3143fd8b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYzMjAyMg==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r463632022", "bodyText": "please fix.", "author": "zohrehj", "createdAt": "2020-07-31T14:06:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM1ODY5Ng=="}], "type": "inlineReview"}, {"oid": "25fde9f45aa024ab54428b80dc26d92096b72247", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/commit/25fde9f45aa024ab54428b80dc26d92096b72247", "message": "Merge branch 'early-access' into early-access-user-mgmt-pending-integration-testcases", "committedDate": "2020-07-23T20:34:25Z", "type": "commit"}, {"oid": "50a4e4e308f41b4e283d42a7815ec47ef0014be0", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/commit/50a4e4e308f41b4e283d42a7815ec47ef0014be0", "message": "Added TODO(#668) comment to remove @Disabled when Github test case failed issue fix", "committedDate": "2020-07-23T20:43:34Z", "type": "commit"}, {"oid": "8555699bbe4c88a621bf0b27df59b9452ed24fb3", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/commit/8555699bbe4c88a621bf0b27df59b9452ed24fb3", "message": "Merge branch 'early-access' into early-access-user-mgmt-pending-integration-testcases", "committedDate": "2020-07-28T04:25:50Z", "type": "commit"}, {"oid": "4fd2ba035a74f4a789ef221f7eb02a9575d0756f", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/commit/4fd2ba035a74f4a789ef221f7eb02a9575d0756f", "message": "Revert \"Added TODO(#668) comment to remove @Disabled when Github test case failed issue fix\"\n\nThis reverts commit 50a4e4e308f41b4e283d42a7815ec47ef0014be0.", "committedDate": "2020-07-30T05:29:10Z", "type": "commit"}, {"oid": "38e1a9d1faa078f3735e91e96f5cecaf47c9be2c", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/commit/38e1a9d1faa078f3735e91e96f5cecaf47c9be2c", "message": "Added  @disabled to reolved Github builded failed issue fix and also added TODO comment", "committedDate": "2020-07-30T05:46:26Z", "type": "commit"}, {"oid": "5fdcb34fbf7470d2962108186c457bd9d089922a", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/commit/5fdcb34fbf7470d2962108186c457bd9d089922a", "message": "small change to initiate trigger again", "committedDate": "2020-07-30T05:59:30Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYzNDA2Nw==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r463634067", "bodyText": "not needed, please remove extra line.\nRefer to: https://google.github.io/styleguide/javaguide.html#s3.3.3-import-ordering-and-spacing", "author": "zohrehj", "createdAt": "2020-07-31T14:10:06Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/beans/ContactUsReqBean.java", "diffHunk": "@@ -9,15 +9,18 @@\n package com.google.cloud.healthcare.fdamystudies.beans;\n \n import javax.validation.constraints.NotBlank;\n+", "originalCommit": "5fdcb34fbf7470d2962108186c457bd9d089922a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUwMTExMQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465501111", "bodyText": "Organized the imports", "author": "navya-BTC", "createdAt": "2020-08-05T06:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzYzNDA2Nw=="}], "type": "inlineReview"}, {"oid": "1275b0d755dc41d7df75133eab56d82eed9cb5e1", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/commit/1275b0d755dc41d7df75133eab56d82eed9cb5e1", "message": "Organized imports\n\nOrganized imports", "committedDate": "2020-08-05T06:16:57Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5NzcxMw==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465497713", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nLine is longer than 100 characters (found 127).", "author": "github-actions", "createdAt": "2020-08-05T06:18:15Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/controller/UserRegistrationController.java", "diffHunk": "@@ -87,48 +86,52 @@\n     AuthRegistrationResponseBean authServerResponse = null;\n \n     if (!userDomainWhitelist.isValidDomain(userForm.getEmailId())) {\n-      return makeServerError(401,\n-                             MyStudiesUserRegUtil.ErrorCodes.INVALID_INPUT.getValue(),\n-                             MyStudiesUserRegUtil.ErrorCodes.DOMAIN_NOT_WHITELISTED.getValue(),\n-                             response);\n+      return makeServerError(\n+          401,\n+          MyStudiesUserRegUtil.ErrorCodes.INVALID_INPUT.getValue(),\n+          MyStudiesUserRegUtil.ErrorCodes.DOMAIN_NOT_WHITELISTED.getValue(),\n+          response);\n     }\n \n     try {\n       authServerResponse =\n-            userManagementUtil.registerUserInAuthServer(\n-                userForm, appId, orgId, clientId, secretKey);\n+          userManagementUtil.registerUserInAuthServer(userForm, appId, orgId, clientId, secretKey);\n \n       if (authServerResponse == null || !\"OK\".equals(authServerResponse.getMessage())) {\n-        commonService.createActivityLog(null, AppConstants.USER_REGD_FAILURE,\n-                                        AppConstants.USER_REGD_FAILURE_DESC + userForm.getEmailId() + \" .\");\n+        commonService.createActivityLog(\n+            null,\n+            AppConstants.USER_REGD_FAILURE,\n+            AppConstants.USER_REGD_FAILURE_DESC + userForm.getEmailId() + \" .\");\n         return makeAuthServerErrorResponse(authServerResponse, response);\n       }\n       UserDetailsBO userDetailsUsingUserId = prepareUserDetails(authServerResponse.getUserId());\n       if (userDetailsUsingUserId != null) {\n         commonService.createActivityLog(\n-          null,\n-          AppConstants.USER_REGD_FAILURE,\n-          AppConstants.USER_REGD_FAILURE_DESC + userForm.getEmailId() + \" .\");\n-        return makeServerError(400, \n-                               MyStudiesUserRegUtil.ErrorCodes.INVALID_INPUT.getValue(),\n-                               MyStudiesUserRegUtil.ErrorCodes.EMAIL_EXISTS.getValue(),\n-                               response);\n+            null,\n+            AppConstants.USER_REGD_FAILURE,\n+            AppConstants.USER_REGD_FAILURE_DESC + userForm.getEmailId() + \" .\");\n+        return makeServerError(\n+            400,\n+            MyStudiesUserRegUtil.ErrorCodes.INVALID_INPUT.getValue(),\n+            MyStudiesUserRegUtil.ErrorCodes.EMAIL_EXISTS.getValue(),\n+            response);\n       }\n \n       UserDetailsBO userDetailsBO = null;\n       AppOrgInfoBean appInfo = profiledao.getUserAppDetailsByAllApi(null, appId, orgId);\n       if (appInfo == null || appInfo.getAppInfoId() == 0) {\n         commonService.createActivityLog(\n-          null,\n-          AppConstants.USER_REGD_FAILURE,\n-          AppConstants.USER_REGD_FAILURE_DESC + userForm.getEmailId() + \" .\");\n+            null,\n+            AppConstants.USER_REGD_FAILURE,\n+            AppConstants.USER_REGD_FAILURE_DESC + userForm.getEmailId() + \" .\");\n         logger.info(\n-          \"(URS)...DELETING record in Auth Server STARTED. Though appId and orgId are not valid in UserRegistration server\");\n+            \"(URS)...DELETING record in Auth Server STARTED. Though appId and orgId are not valid in UserRegistration server\");", "originalCommit": "1275b0d755dc41d7df75133eab56d82eed9cb5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5NzcxNA==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465497714", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nMissing a Javadoc comment.", "author": "github-actions", "createdAt": "2020-08-05T06:18:15Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/util/GetUserInstitutionResources.java", "diffHunk": "@@ -4,40 +4,40 @@\n import com.google.cloud.healthcare.fdamystudies.model.UserInstitution;\n import com.google.cloud.healthcare.fdamystudies.repository.UserInstitutionRepository;\n import com.google.cloud.healthcare.fdamystudies.service.CloudStorageService;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Component;\n-\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Optional;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n \n @Component\n public class GetUserInstitutionResources {\n-    @Autowired\n-    UserInstitutionRepository userInstitutionRepository;\n-\n-    @Autowired\n-    CloudStorageService cloudStorageService;\n-\n-\tprivate static final UserResourceBean.ResourceType resourceType = UserResourceBean.ResourceType.INSTITUTION_RESOURCE;\n-\n-    // Returns UserResourceBeans for the institution that `userId` belongs to.\n-    // Can be an empty list.\n-    public List<UserResourceBean> getInstitutionResourcesForUser(String userId) {\n-        Optional<UserInstitution> maybeUserInstitution =\n-                userInstitutionRepository.findByUserUserId(userId);\n-        if (!maybeUserInstitution.isPresent()) return new ArrayList<>();\n-        UserInstitution userInstitution = maybeUserInstitution.get();\n-\n-        List<CloudStorageService.InstitutionResource> streams =\n-                cloudStorageService.getAllInstitutionResources(userInstitution.getInstitutionId());\n-        if (streams.isEmpty()) return new ArrayList<>();\n-\n-        List<UserResourceBean> resources = new ArrayList<>();\n-        for (CloudStorageService.InstitutionResource institutionResource : streams) {\n-            String content = new String(institutionResource.stream.toByteArray());\n-            resources.add(new UserResourceBean(institutionResource.title, content, resourceType, institutionResource.hash));\n-        }\n-        return resources;\n+  @Autowired UserInstitutionRepository userInstitutionRepository;\n+\n+  @Autowired CloudStorageService cloudStorageService;\n+\n+  private static final UserResourceBean.ResourceType resourceType =\n+      UserResourceBean.ResourceType.INSTITUTION_RESOURCE;\n+\n+  // Returns UserResourceBeans for the institution that `userId` belongs to.\n+  // Can be an empty list.\n+  public List<UserResourceBean> getInstitutionResourcesForUser(String userId) {", "originalCommit": "1275b0d755dc41d7df75133eab56d82eed9cb5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5NzcxNg==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465497716", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\n'if' construct must use '{}'s.", "author": "github-actions", "createdAt": "2020-08-05T06:18:16Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/util/GetUserInstitutionResources.java", "diffHunk": "@@ -4,40 +4,40 @@\n import com.google.cloud.healthcare.fdamystudies.model.UserInstitution;\n import com.google.cloud.healthcare.fdamystudies.repository.UserInstitutionRepository;\n import com.google.cloud.healthcare.fdamystudies.service.CloudStorageService;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Component;\n-\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Optional;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n \n @Component\n public class GetUserInstitutionResources {\n-    @Autowired\n-    UserInstitutionRepository userInstitutionRepository;\n-\n-    @Autowired\n-    CloudStorageService cloudStorageService;\n-\n-\tprivate static final UserResourceBean.ResourceType resourceType = UserResourceBean.ResourceType.INSTITUTION_RESOURCE;\n-\n-    // Returns UserResourceBeans for the institution that `userId` belongs to.\n-    // Can be an empty list.\n-    public List<UserResourceBean> getInstitutionResourcesForUser(String userId) {\n-        Optional<UserInstitution> maybeUserInstitution =\n-                userInstitutionRepository.findByUserUserId(userId);\n-        if (!maybeUserInstitution.isPresent()) return new ArrayList<>();\n-        UserInstitution userInstitution = maybeUserInstitution.get();\n-\n-        List<CloudStorageService.InstitutionResource> streams =\n-                cloudStorageService.getAllInstitutionResources(userInstitution.getInstitutionId());\n-        if (streams.isEmpty()) return new ArrayList<>();\n-\n-        List<UserResourceBean> resources = new ArrayList<>();\n-        for (CloudStorageService.InstitutionResource institutionResource : streams) {\n-            String content = new String(institutionResource.stream.toByteArray());\n-            resources.add(new UserResourceBean(institutionResource.title, content, resourceType, institutionResource.hash));\n-        }\n-        return resources;\n+  @Autowired UserInstitutionRepository userInstitutionRepository;\n+\n+  @Autowired CloudStorageService cloudStorageService;\n+\n+  private static final UserResourceBean.ResourceType resourceType =\n+      UserResourceBean.ResourceType.INSTITUTION_RESOURCE;\n+\n+  // Returns UserResourceBeans for the institution that `userId` belongs to.\n+  // Can be an empty list.\n+  public List<UserResourceBean> getInstitutionResourcesForUser(String userId) {\n+    Optional<UserInstitution> maybeUserInstitution =\n+        userInstitutionRepository.findByUserUserId(userId);\n+    if (!maybeUserInstitution.isPresent()) return new ArrayList<>();", "originalCommit": "1275b0d755dc41d7df75133eab56d82eed9cb5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5NzcxOA==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465497718", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\n'if' construct must use '{}'s.", "author": "github-actions", "createdAt": "2020-08-05T06:18:16Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/util/GetUserInstitutionResources.java", "diffHunk": "@@ -4,40 +4,40 @@\n import com.google.cloud.healthcare.fdamystudies.model.UserInstitution;\n import com.google.cloud.healthcare.fdamystudies.repository.UserInstitutionRepository;\n import com.google.cloud.healthcare.fdamystudies.service.CloudStorageService;\n-import org.springframework.beans.factory.annotation.Autowired;\n-import org.springframework.stereotype.Component;\n-\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Optional;\n+import org.springframework.beans.factory.annotation.Autowired;\n+import org.springframework.stereotype.Component;\n \n @Component\n public class GetUserInstitutionResources {\n-    @Autowired\n-    UserInstitutionRepository userInstitutionRepository;\n-\n-    @Autowired\n-    CloudStorageService cloudStorageService;\n-\n-\tprivate static final UserResourceBean.ResourceType resourceType = UserResourceBean.ResourceType.INSTITUTION_RESOURCE;\n-\n-    // Returns UserResourceBeans for the institution that `userId` belongs to.\n-    // Can be an empty list.\n-    public List<UserResourceBean> getInstitutionResourcesForUser(String userId) {\n-        Optional<UserInstitution> maybeUserInstitution =\n-                userInstitutionRepository.findByUserUserId(userId);\n-        if (!maybeUserInstitution.isPresent()) return new ArrayList<>();\n-        UserInstitution userInstitution = maybeUserInstitution.get();\n-\n-        List<CloudStorageService.InstitutionResource> streams =\n-                cloudStorageService.getAllInstitutionResources(userInstitution.getInstitutionId());\n-        if (streams.isEmpty()) return new ArrayList<>();\n-\n-        List<UserResourceBean> resources = new ArrayList<>();\n-        for (CloudStorageService.InstitutionResource institutionResource : streams) {\n-            String content = new String(institutionResource.stream.toByteArray());\n-            resources.add(new UserResourceBean(institutionResource.title, content, resourceType, institutionResource.hash));\n-        }\n-        return resources;\n+  @Autowired UserInstitutionRepository userInstitutionRepository;\n+\n+  @Autowired CloudStorageService cloudStorageService;\n+\n+  private static final UserResourceBean.ResourceType resourceType =\n+      UserResourceBean.ResourceType.INSTITUTION_RESOURCE;\n+\n+  // Returns UserResourceBeans for the institution that `userId` belongs to.\n+  // Can be an empty list.\n+  public List<UserResourceBean> getInstitutionResourcesForUser(String userId) {\n+    Optional<UserInstitution> maybeUserInstitution =\n+        userInstitutionRepository.findByUserUserId(userId);\n+    if (!maybeUserInstitution.isPresent()) return new ArrayList<>();\n+    UserInstitution userInstitution = maybeUserInstitution.get();\n+\n+    List<CloudStorageService.InstitutionResource> streams =\n+        cloudStorageService.getAllInstitutionResources(userInstitution.getInstitutionId());\n+    if (streams.isEmpty()) return new ArrayList<>();", "originalCommit": "1275b0d755dc41d7df75133eab56d82eed9cb5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5NzcxOQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465497719", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nLine is longer than 100 characters (found 101).", "author": "github-actions", "createdAt": "2020-08-05T06:18:16Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/util/AuthenticationFilter.java", "diffHunk": "@@ -171,7 +170,8 @@ public void doFilter(ServletRequest request, ServletResponse response, FilterCha\n               }\n             }\n           } else {\n-            logger.warn(\"AuthenticationFilter doFilter failed : missing userId, accessToken or clientToken\");\n+            logger.warn(\n+                \"AuthenticationFilter doFilter failed : missing userId, accessToken or clientToken\");", "originalCommit": "1275b0d755dc41d7df75133eab56d82eed9cb5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5NzcyMQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465497721", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nMember name 'smtp_Hostname' must match pattern '^[a-z][a-z0-9][a-zA-Z0-9]*$'.", "author": "github-actions", "createdAt": "2020-08-05T06:18:16Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/util/Mail.java", "diffHunk": "@@ -23,308 +23,304 @@\n import javax.mail.internet.MimeBodyPart;\n import javax.mail.internet.MimeMessage;\n import javax.mail.internet.MimeMultipart;\n-\n import lombok.Setter;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n public class Mail {\n \n-    private static final Logger logger = LogManager.getLogger(Mail.class);\n-\n-    private String toemail;\n-    private String subject;\n-    private String messageBody;\n-    // Fallback hostname if we are authenticating.\n-    private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n-    // Fallback hostname if we are not authenticating.\n-    private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n-    private static final String SMTP_PORT = \"465\";\n-    private String smtp_Hostname = \"\";\n-    private String smtp_portvalue = \"\";\n-    static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n-    private String sslFactory = \"\";\n-    private String fromEmailAddress = \"\";\n-    private String fromEmailPass = \"\";\n-    private String fromEmailName = \"\";\n-    private String ccEmail;\n-    private String bccEmail;\n-    private String attachmentPath;\n-    // Domain that we send in the EHLO request if we are not authenticating\n-    // with the SMTP server.\n-    @Setter\n-    private String fromDomain = \"\";\n-    // If set to true, we will not authenticate with the SMTP service and\n-    // rather rely on the SMTP service's configured IP whitelist. If false we\n-    // will authenticate with the provided fromEmailAddress and fromEmailPass.\n-    @Setter\n-    private Boolean useIpWhitelist = false;\n-\n-    public boolean sendemail() throws Exception {\n-        logger.debug(\" sendemail() ==== starts\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            message.setFrom(new InternetAddress(username));\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setContent(this.getMessageBody(), \"text/html\");\n-            Transport transport = session.getTransport();\n-            transport.send(message);\n-            logger.debug(\"sendemail()==== ends\");\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"sendemail() MessagingException- error\", e);\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendemail() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    public boolean sendMailWithAttachment() throws Exception {\n-        logger.debug(\"sendMailWithAttachment()==== start\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setFrom(new InternetAddress(username));\n-            // message.setText(\"Check attachment in Mail\");\n-            // message.setContent(messageBody, \"text/html\");\n-            // Create the message part\n-            BodyPart messageBodyPart = new MimeBodyPart();\n-            // Create a multipar message\n-            Multipart multipart = new MimeMultipart();\n-            // Part two is attachment\n-            messageBodyPart = new MimeBodyPart();\n-            // String filename = \"D:\\\\temp\\\\TestLinks.pdf\"; // D:\\temp\\noteb.txt\n-            DataSource source = new FileDataSource(this.getAttachmentPath());\n-            messageBodyPart.setDataHandler(new DataHandler(source));\n-            messageBodyPart.setFileName(source.getName());\n-            messageBodyPart.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n-            messageBodyPart.setHeader(\"Content-Type\", source.getContentType());\n-            // Send the complete message parts\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            messageBodyPart = new MimeBodyPart();\n-            messageBodyPart.setText(messageBody);\n-            messageBodyPart.setHeader(\"MIME-Version\", \"1.0\");\n-            messageBodyPart.setHeader(\"Content-Type\", messageBodyPart.getContentType());\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            message.setContent(multipart);\n-            Transport.send(message);\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-            sentMail = false;\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendMailWithAttachment() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    // Constructs a Propterties either relying on IP Whitelist on the SMTP\n-    // service or on authentication with email and password.\n-    private Properties makeProperties(Boolean useIpWhitelist) {\n-        Properties props = new Properties();\n-        props.put(\"mail.smtp.host\", this.getSmtp_Hostname());\n-        props.put(\"mail.smtp.port\", this.getSmtp_portvalue());\n-        props.put(\"mail.smtp.socketFactory.class\", this.getSslFactory());\n-        props.put(\"mail.smtp.socketFactory.port\", this.getSmtp_portvalue());\n-        if (useIpWhitelist) {\n-            props.put(\"mail.smtp.auth\", \"false\");\n-            props.put(\"mail.smtp.ssl.enable\", \"true\");\n-            props.put(\"mail.smtp.localhost\", fromDomain);\n+  private static final Logger logger = LogManager.getLogger(Mail.class);\n+\n+  private String toemail;\n+  private String subject;\n+  private String messageBody;\n+  // Fallback hostname if we are authenticating.\n+  private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n+  // Fallback hostname if we are not authenticating.\n+  private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n+  private static final String SMTP_PORT = \"465\";\n+  private String smtp_Hostname = \"\";", "originalCommit": "1275b0d755dc41d7df75133eab56d82eed9cb5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5NzcyNA==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465497724", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nMember name 'smtp_portvalue' must match pattern '^[a-z][a-z0-9][a-zA-Z0-9]*$'.", "author": "github-actions", "createdAt": "2020-08-05T06:18:16Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/util/Mail.java", "diffHunk": "@@ -23,308 +23,304 @@\n import javax.mail.internet.MimeBodyPart;\n import javax.mail.internet.MimeMessage;\n import javax.mail.internet.MimeMultipart;\n-\n import lombok.Setter;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n public class Mail {\n \n-    private static final Logger logger = LogManager.getLogger(Mail.class);\n-\n-    private String toemail;\n-    private String subject;\n-    private String messageBody;\n-    // Fallback hostname if we are authenticating.\n-    private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n-    // Fallback hostname if we are not authenticating.\n-    private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n-    private static final String SMTP_PORT = \"465\";\n-    private String smtp_Hostname = \"\";\n-    private String smtp_portvalue = \"\";\n-    static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n-    private String sslFactory = \"\";\n-    private String fromEmailAddress = \"\";\n-    private String fromEmailPass = \"\";\n-    private String fromEmailName = \"\";\n-    private String ccEmail;\n-    private String bccEmail;\n-    private String attachmentPath;\n-    // Domain that we send in the EHLO request if we are not authenticating\n-    // with the SMTP server.\n-    @Setter\n-    private String fromDomain = \"\";\n-    // If set to true, we will not authenticate with the SMTP service and\n-    // rather rely on the SMTP service's configured IP whitelist. If false we\n-    // will authenticate with the provided fromEmailAddress and fromEmailPass.\n-    @Setter\n-    private Boolean useIpWhitelist = false;\n-\n-    public boolean sendemail() throws Exception {\n-        logger.debug(\" sendemail() ==== starts\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            message.setFrom(new InternetAddress(username));\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setContent(this.getMessageBody(), \"text/html\");\n-            Transport transport = session.getTransport();\n-            transport.send(message);\n-            logger.debug(\"sendemail()==== ends\");\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"sendemail() MessagingException- error\", e);\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendemail() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    public boolean sendMailWithAttachment() throws Exception {\n-        logger.debug(\"sendMailWithAttachment()==== start\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setFrom(new InternetAddress(username));\n-            // message.setText(\"Check attachment in Mail\");\n-            // message.setContent(messageBody, \"text/html\");\n-            // Create the message part\n-            BodyPart messageBodyPart = new MimeBodyPart();\n-            // Create a multipar message\n-            Multipart multipart = new MimeMultipart();\n-            // Part two is attachment\n-            messageBodyPart = new MimeBodyPart();\n-            // String filename = \"D:\\\\temp\\\\TestLinks.pdf\"; // D:\\temp\\noteb.txt\n-            DataSource source = new FileDataSource(this.getAttachmentPath());\n-            messageBodyPart.setDataHandler(new DataHandler(source));\n-            messageBodyPart.setFileName(source.getName());\n-            messageBodyPart.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n-            messageBodyPart.setHeader(\"Content-Type\", source.getContentType());\n-            // Send the complete message parts\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            messageBodyPart = new MimeBodyPart();\n-            messageBodyPart.setText(messageBody);\n-            messageBodyPart.setHeader(\"MIME-Version\", \"1.0\");\n-            messageBodyPart.setHeader(\"Content-Type\", messageBodyPart.getContentType());\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            message.setContent(multipart);\n-            Transport.send(message);\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-            sentMail = false;\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendMailWithAttachment() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    // Constructs a Propterties either relying on IP Whitelist on the SMTP\n-    // service or on authentication with email and password.\n-    private Properties makeProperties(Boolean useIpWhitelist) {\n-        Properties props = new Properties();\n-        props.put(\"mail.smtp.host\", this.getSmtp_Hostname());\n-        props.put(\"mail.smtp.port\", this.getSmtp_portvalue());\n-        props.put(\"mail.smtp.socketFactory.class\", this.getSslFactory());\n-        props.put(\"mail.smtp.socketFactory.port\", this.getSmtp_portvalue());\n-        if (useIpWhitelist) {\n-            props.put(\"mail.smtp.auth\", \"false\");\n-            props.put(\"mail.smtp.ssl.enable\", \"true\");\n-            props.put(\"mail.smtp.localhost\", fromDomain);\n+  private static final Logger logger = LogManager.getLogger(Mail.class);\n+\n+  private String toemail;\n+  private String subject;\n+  private String messageBody;\n+  // Fallback hostname if we are authenticating.\n+  private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n+  // Fallback hostname if we are not authenticating.\n+  private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n+  private static final String SMTP_PORT = \"465\";\n+  private String smtp_Hostname = \"\";\n+  private String smtp_portvalue = \"\";", "originalCommit": "1275b0d755dc41d7df75133eab56d82eed9cb5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5NzcyNQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465497725", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nMissing a Javadoc comment.", "author": "github-actions", "createdAt": "2020-08-05T06:18:16Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/util/Mail.java", "diffHunk": "@@ -23,308 +23,304 @@\n import javax.mail.internet.MimeBodyPart;\n import javax.mail.internet.MimeMessage;\n import javax.mail.internet.MimeMultipart;\n-\n import lombok.Setter;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n public class Mail {\n \n-    private static final Logger logger = LogManager.getLogger(Mail.class);\n-\n-    private String toemail;\n-    private String subject;\n-    private String messageBody;\n-    // Fallback hostname if we are authenticating.\n-    private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n-    // Fallback hostname if we are not authenticating.\n-    private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n-    private static final String SMTP_PORT = \"465\";\n-    private String smtp_Hostname = \"\";\n-    private String smtp_portvalue = \"\";\n-    static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n-    private String sslFactory = \"\";\n-    private String fromEmailAddress = \"\";\n-    private String fromEmailPass = \"\";\n-    private String fromEmailName = \"\";\n-    private String ccEmail;\n-    private String bccEmail;\n-    private String attachmentPath;\n-    // Domain that we send in the EHLO request if we are not authenticating\n-    // with the SMTP server.\n-    @Setter\n-    private String fromDomain = \"\";\n-    // If set to true, we will not authenticate with the SMTP service and\n-    // rather rely on the SMTP service's configured IP whitelist. If false we\n-    // will authenticate with the provided fromEmailAddress and fromEmailPass.\n-    @Setter\n-    private Boolean useIpWhitelist = false;\n-\n-    public boolean sendemail() throws Exception {\n-        logger.debug(\" sendemail() ==== starts\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            message.setFrom(new InternetAddress(username));\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setContent(this.getMessageBody(), \"text/html\");\n-            Transport transport = session.getTransport();\n-            transport.send(message);\n-            logger.debug(\"sendemail()==== ends\");\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"sendemail() MessagingException- error\", e);\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendemail() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    public boolean sendMailWithAttachment() throws Exception {\n-        logger.debug(\"sendMailWithAttachment()==== start\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setFrom(new InternetAddress(username));\n-            // message.setText(\"Check attachment in Mail\");\n-            // message.setContent(messageBody, \"text/html\");\n-            // Create the message part\n-            BodyPart messageBodyPart = new MimeBodyPart();\n-            // Create a multipar message\n-            Multipart multipart = new MimeMultipart();\n-            // Part two is attachment\n-            messageBodyPart = new MimeBodyPart();\n-            // String filename = \"D:\\\\temp\\\\TestLinks.pdf\"; // D:\\temp\\noteb.txt\n-            DataSource source = new FileDataSource(this.getAttachmentPath());\n-            messageBodyPart.setDataHandler(new DataHandler(source));\n-            messageBodyPart.setFileName(source.getName());\n-            messageBodyPart.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n-            messageBodyPart.setHeader(\"Content-Type\", source.getContentType());\n-            // Send the complete message parts\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            messageBodyPart = new MimeBodyPart();\n-            messageBodyPart.setText(messageBody);\n-            messageBodyPart.setHeader(\"MIME-Version\", \"1.0\");\n-            messageBodyPart.setHeader(\"Content-Type\", messageBodyPart.getContentType());\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            message.setContent(multipart);\n-            Transport.send(message);\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-            sentMail = false;\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendMailWithAttachment() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    // Constructs a Propterties either relying on IP Whitelist on the SMTP\n-    // service or on authentication with email and password.\n-    private Properties makeProperties(Boolean useIpWhitelist) {\n-        Properties props = new Properties();\n-        props.put(\"mail.smtp.host\", this.getSmtp_Hostname());\n-        props.put(\"mail.smtp.port\", this.getSmtp_portvalue());\n-        props.put(\"mail.smtp.socketFactory.class\", this.getSslFactory());\n-        props.put(\"mail.smtp.socketFactory.port\", this.getSmtp_portvalue());\n-        if (useIpWhitelist) {\n-            props.put(\"mail.smtp.auth\", \"false\");\n-            props.put(\"mail.smtp.ssl.enable\", \"true\");\n-            props.put(\"mail.smtp.localhost\", fromDomain);\n+  private static final Logger logger = LogManager.getLogger(Mail.class);\n+\n+  private String toemail;\n+  private String subject;\n+  private String messageBody;\n+  // Fallback hostname if we are authenticating.\n+  private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n+  // Fallback hostname if we are not authenticating.\n+  private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n+  private static final String SMTP_PORT = \"465\";\n+  private String smtp_Hostname = \"\";\n+  private String smtp_portvalue = \"\";\n+  static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n+  private String sslFactory = \"\";\n+  private String fromEmailAddress = \"\";\n+  private String fromEmailPass = \"\";\n+  private String fromEmailName = \"\";\n+  private String ccEmail;\n+  private String bccEmail;\n+  private String attachmentPath;\n+  // Domain that we send in the EHLO request if we are not authenticating\n+  // with the SMTP server.\n+  @Setter private String fromDomain = \"\";\n+  // If set to true, we will not authenticate with the SMTP service and\n+  // rather rely on the SMTP service's configured IP whitelist. If false we\n+  // will authenticate with the provided fromEmailAddress and fromEmailPass.\n+  @Setter private Boolean useIpWhitelist = false;\n+\n+  public boolean sendemail() throws Exception {", "originalCommit": "1275b0d755dc41d7df75133eab56d82eed9cb5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5NzcyOA==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465497728", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nMissing a Javadoc comment.", "author": "github-actions", "createdAt": "2020-08-05T06:18:17Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/util/Mail.java", "diffHunk": "@@ -23,308 +23,304 @@\n import javax.mail.internet.MimeBodyPart;\n import javax.mail.internet.MimeMessage;\n import javax.mail.internet.MimeMultipart;\n-\n import lombok.Setter;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n public class Mail {\n \n-    private static final Logger logger = LogManager.getLogger(Mail.class);\n-\n-    private String toemail;\n-    private String subject;\n-    private String messageBody;\n-    // Fallback hostname if we are authenticating.\n-    private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n-    // Fallback hostname if we are not authenticating.\n-    private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n-    private static final String SMTP_PORT = \"465\";\n-    private String smtp_Hostname = \"\";\n-    private String smtp_portvalue = \"\";\n-    static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n-    private String sslFactory = \"\";\n-    private String fromEmailAddress = \"\";\n-    private String fromEmailPass = \"\";\n-    private String fromEmailName = \"\";\n-    private String ccEmail;\n-    private String bccEmail;\n-    private String attachmentPath;\n-    // Domain that we send in the EHLO request if we are not authenticating\n-    // with the SMTP server.\n-    @Setter\n-    private String fromDomain = \"\";\n-    // If set to true, we will not authenticate with the SMTP service and\n-    // rather rely on the SMTP service's configured IP whitelist. If false we\n-    // will authenticate with the provided fromEmailAddress and fromEmailPass.\n-    @Setter\n-    private Boolean useIpWhitelist = false;\n-\n-    public boolean sendemail() throws Exception {\n-        logger.debug(\" sendemail() ==== starts\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            message.setFrom(new InternetAddress(username));\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setContent(this.getMessageBody(), \"text/html\");\n-            Transport transport = session.getTransport();\n-            transport.send(message);\n-            logger.debug(\"sendemail()==== ends\");\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"sendemail() MessagingException- error\", e);\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendemail() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    public boolean sendMailWithAttachment() throws Exception {\n-        logger.debug(\"sendMailWithAttachment()==== start\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setFrom(new InternetAddress(username));\n-            // message.setText(\"Check attachment in Mail\");\n-            // message.setContent(messageBody, \"text/html\");\n-            // Create the message part\n-            BodyPart messageBodyPart = new MimeBodyPart();\n-            // Create a multipar message\n-            Multipart multipart = new MimeMultipart();\n-            // Part two is attachment\n-            messageBodyPart = new MimeBodyPart();\n-            // String filename = \"D:\\\\temp\\\\TestLinks.pdf\"; // D:\\temp\\noteb.txt\n-            DataSource source = new FileDataSource(this.getAttachmentPath());\n-            messageBodyPart.setDataHandler(new DataHandler(source));\n-            messageBodyPart.setFileName(source.getName());\n-            messageBodyPart.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n-            messageBodyPart.setHeader(\"Content-Type\", source.getContentType());\n-            // Send the complete message parts\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            messageBodyPart = new MimeBodyPart();\n-            messageBodyPart.setText(messageBody);\n-            messageBodyPart.setHeader(\"MIME-Version\", \"1.0\");\n-            messageBodyPart.setHeader(\"Content-Type\", messageBodyPart.getContentType());\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            message.setContent(multipart);\n-            Transport.send(message);\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-            sentMail = false;\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendMailWithAttachment() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    // Constructs a Propterties either relying on IP Whitelist on the SMTP\n-    // service or on authentication with email and password.\n-    private Properties makeProperties(Boolean useIpWhitelist) {\n-        Properties props = new Properties();\n-        props.put(\"mail.smtp.host\", this.getSmtp_Hostname());\n-        props.put(\"mail.smtp.port\", this.getSmtp_portvalue());\n-        props.put(\"mail.smtp.socketFactory.class\", this.getSslFactory());\n-        props.put(\"mail.smtp.socketFactory.port\", this.getSmtp_portvalue());\n-        if (useIpWhitelist) {\n-            props.put(\"mail.smtp.auth\", \"false\");\n-            props.put(\"mail.smtp.ssl.enable\", \"true\");\n-            props.put(\"mail.smtp.localhost\", fromDomain);\n+  private static final Logger logger = LogManager.getLogger(Mail.class);\n+\n+  private String toemail;\n+  private String subject;\n+  private String messageBody;\n+  // Fallback hostname if we are authenticating.\n+  private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n+  // Fallback hostname if we are not authenticating.\n+  private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n+  private static final String SMTP_PORT = \"465\";\n+  private String smtp_Hostname = \"\";\n+  private String smtp_portvalue = \"\";\n+  static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n+  private String sslFactory = \"\";\n+  private String fromEmailAddress = \"\";\n+  private String fromEmailPass = \"\";\n+  private String fromEmailName = \"\";\n+  private String ccEmail;\n+  private String bccEmail;\n+  private String attachmentPath;\n+  // Domain that we send in the EHLO request if we are not authenticating\n+  // with the SMTP server.\n+  @Setter private String fromDomain = \"\";\n+  // If set to true, we will not authenticate with the SMTP service and\n+  // rather rely on the SMTP service's configured IP whitelist. If false we\n+  // will authenticate with the provided fromEmailAddress and fromEmailPass.\n+  @Setter private Boolean useIpWhitelist = false;\n+\n+  public boolean sendemail() throws Exception {\n+    logger.debug(\" sendemail() ==== starts\");\n+    boolean sentMail = false;\n+    try {\n+      final String username = this.getFromEmailAddress();\n+      final String password = this.getFromEmailPass();\n+      Properties props = makeProperties(useIpWhitelist);\n+      Session session =\n+          useIpWhitelist ? makeSession(props) : makeSession(props, username, password);\n+      Message message = new MimeMessage(session);\n+      message.setFrom(new InternetAddress(username));\n+      if (StringUtils.isNotBlank(this.getToemail())) {\n+        if (this.getToemail().indexOf(\",\") != -1) {\n+          message.setRecipients(\n+              Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n         } else {\n-            props.put(\"mail.smtp.auth\", \"true\");\n+          message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n         }\n-        return props;\n-    }\n-\n-    private Session makeSession(Properties props) {\n-        return Session.getInstance(props, null);\n-    }\n-\n-    private Session makeSession(Properties props, String username,\n-                                String password) {\n-        return Session.getInstance(\n-                props,\n-                new javax.mail.Authenticator() {\n-                    @Override\n-                    protected PasswordAuthentication getPasswordAuthentication() {\n-                        return new PasswordAuthentication(username, password);\n-                    }\n-                });\n-    }\n-\n-    public String getToemail() {\n-        return toemail;\n-    }\n-\n-    public void setToemail(String toemail) {\n-        this.toemail = toemail;\n-    }\n-\n-    public String getSubject() {\n-        return subject;\n-    }\n-\n-    public void setSubject(String subject) {\n-        this.subject = subject;\n-    }\n-\n-    public String getMessageBody() {\n-        return messageBody;\n-    }\n-\n-    public void setMessageBody(String messageBody) {\n-        this.messageBody = messageBody;\n-    }\n-\n-    public String getSmtp_Hostname() {\n-        if (this.smtp_Hostname.equals(\"\")) {\n-            if (useIpWhitelist) {\n-                return Mail.SMTP_RELAY_HOSTNAME;\n-            } else {\n-                return Mail.SMTP_HOSTNAME;\n-            }\n+      }\n+      if (StringUtils.isNotBlank(this.getCcEmail())) {\n+        message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n+      }\n+      if (StringUtils.isNotBlank(this.getBccEmail())) {\n+        message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n+      }\n+      message.setSubject(this.subject);\n+      message.setContent(this.getMessageBody(), \"text/html\");\n+      Transport transport = session.getTransport();\n+      transport.send(message);\n+      logger.debug(\"sendemail()==== ends\");\n+      sentMail = true;\n+    } catch (MessagingException e) {\n+      logger.error(\"sendemail() MessagingException- error\", e);\n+    } catch (Exception e) {\n+      logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n+    }\n+    logger.debug(\"Mail.sendemail() :: Ends\");\n+    return sentMail;\n+  }\n+\n+  public boolean sendMailWithAttachment() throws Exception {", "originalCommit": "1275b0d755dc41d7df75133eab56d82eed9cb5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5NzcyOQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465497729", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nDistance between variable 'multipart' declaration and its first usage is 6, but allowed 3.  Consider making that variable final if you still need to store its value in advance (before method calls that might have side effects on the original value).", "author": "github-actions", "createdAt": "2020-08-05T06:18:17Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/util/Mail.java", "diffHunk": "@@ -23,308 +23,304 @@\n import javax.mail.internet.MimeBodyPart;\n import javax.mail.internet.MimeMessage;\n import javax.mail.internet.MimeMultipart;\n-\n import lombok.Setter;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n public class Mail {\n \n-    private static final Logger logger = LogManager.getLogger(Mail.class);\n-\n-    private String toemail;\n-    private String subject;\n-    private String messageBody;\n-    // Fallback hostname if we are authenticating.\n-    private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n-    // Fallback hostname if we are not authenticating.\n-    private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n-    private static final String SMTP_PORT = \"465\";\n-    private String smtp_Hostname = \"\";\n-    private String smtp_portvalue = \"\";\n-    static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n-    private String sslFactory = \"\";\n-    private String fromEmailAddress = \"\";\n-    private String fromEmailPass = \"\";\n-    private String fromEmailName = \"\";\n-    private String ccEmail;\n-    private String bccEmail;\n-    private String attachmentPath;\n-    // Domain that we send in the EHLO request if we are not authenticating\n-    // with the SMTP server.\n-    @Setter\n-    private String fromDomain = \"\";\n-    // If set to true, we will not authenticate with the SMTP service and\n-    // rather rely on the SMTP service's configured IP whitelist. If false we\n-    // will authenticate with the provided fromEmailAddress and fromEmailPass.\n-    @Setter\n-    private Boolean useIpWhitelist = false;\n-\n-    public boolean sendemail() throws Exception {\n-        logger.debug(\" sendemail() ==== starts\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            message.setFrom(new InternetAddress(username));\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setContent(this.getMessageBody(), \"text/html\");\n-            Transport transport = session.getTransport();\n-            transport.send(message);\n-            logger.debug(\"sendemail()==== ends\");\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"sendemail() MessagingException- error\", e);\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendemail() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    public boolean sendMailWithAttachment() throws Exception {\n-        logger.debug(\"sendMailWithAttachment()==== start\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setFrom(new InternetAddress(username));\n-            // message.setText(\"Check attachment in Mail\");\n-            // message.setContent(messageBody, \"text/html\");\n-            // Create the message part\n-            BodyPart messageBodyPart = new MimeBodyPart();\n-            // Create a multipar message\n-            Multipart multipart = new MimeMultipart();\n-            // Part two is attachment\n-            messageBodyPart = new MimeBodyPart();\n-            // String filename = \"D:\\\\temp\\\\TestLinks.pdf\"; // D:\\temp\\noteb.txt\n-            DataSource source = new FileDataSource(this.getAttachmentPath());\n-            messageBodyPart.setDataHandler(new DataHandler(source));\n-            messageBodyPart.setFileName(source.getName());\n-            messageBodyPart.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n-            messageBodyPart.setHeader(\"Content-Type\", source.getContentType());\n-            // Send the complete message parts\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            messageBodyPart = new MimeBodyPart();\n-            messageBodyPart.setText(messageBody);\n-            messageBodyPart.setHeader(\"MIME-Version\", \"1.0\");\n-            messageBodyPart.setHeader(\"Content-Type\", messageBodyPart.getContentType());\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            message.setContent(multipart);\n-            Transport.send(message);\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-            sentMail = false;\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendMailWithAttachment() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    // Constructs a Propterties either relying on IP Whitelist on the SMTP\n-    // service or on authentication with email and password.\n-    private Properties makeProperties(Boolean useIpWhitelist) {\n-        Properties props = new Properties();\n-        props.put(\"mail.smtp.host\", this.getSmtp_Hostname());\n-        props.put(\"mail.smtp.port\", this.getSmtp_portvalue());\n-        props.put(\"mail.smtp.socketFactory.class\", this.getSslFactory());\n-        props.put(\"mail.smtp.socketFactory.port\", this.getSmtp_portvalue());\n-        if (useIpWhitelist) {\n-            props.put(\"mail.smtp.auth\", \"false\");\n-            props.put(\"mail.smtp.ssl.enable\", \"true\");\n-            props.put(\"mail.smtp.localhost\", fromDomain);\n+  private static final Logger logger = LogManager.getLogger(Mail.class);\n+\n+  private String toemail;\n+  private String subject;\n+  private String messageBody;\n+  // Fallback hostname if we are authenticating.\n+  private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n+  // Fallback hostname if we are not authenticating.\n+  private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n+  private static final String SMTP_PORT = \"465\";\n+  private String smtp_Hostname = \"\";\n+  private String smtp_portvalue = \"\";\n+  static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n+  private String sslFactory = \"\";\n+  private String fromEmailAddress = \"\";\n+  private String fromEmailPass = \"\";\n+  private String fromEmailName = \"\";\n+  private String ccEmail;\n+  private String bccEmail;\n+  private String attachmentPath;\n+  // Domain that we send in the EHLO request if we are not authenticating\n+  // with the SMTP server.\n+  @Setter private String fromDomain = \"\";\n+  // If set to true, we will not authenticate with the SMTP service and\n+  // rather rely on the SMTP service's configured IP whitelist. If false we\n+  // will authenticate with the provided fromEmailAddress and fromEmailPass.\n+  @Setter private Boolean useIpWhitelist = false;\n+\n+  public boolean sendemail() throws Exception {\n+    logger.debug(\" sendemail() ==== starts\");\n+    boolean sentMail = false;\n+    try {\n+      final String username = this.getFromEmailAddress();\n+      final String password = this.getFromEmailPass();\n+      Properties props = makeProperties(useIpWhitelist);\n+      Session session =\n+          useIpWhitelist ? makeSession(props) : makeSession(props, username, password);\n+      Message message = new MimeMessage(session);\n+      message.setFrom(new InternetAddress(username));\n+      if (StringUtils.isNotBlank(this.getToemail())) {\n+        if (this.getToemail().indexOf(\",\") != -1) {\n+          message.setRecipients(\n+              Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n         } else {\n-            props.put(\"mail.smtp.auth\", \"true\");\n+          message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n         }\n-        return props;\n-    }\n-\n-    private Session makeSession(Properties props) {\n-        return Session.getInstance(props, null);\n-    }\n-\n-    private Session makeSession(Properties props, String username,\n-                                String password) {\n-        return Session.getInstance(\n-                props,\n-                new javax.mail.Authenticator() {\n-                    @Override\n-                    protected PasswordAuthentication getPasswordAuthentication() {\n-                        return new PasswordAuthentication(username, password);\n-                    }\n-                });\n-    }\n-\n-    public String getToemail() {\n-        return toemail;\n-    }\n-\n-    public void setToemail(String toemail) {\n-        this.toemail = toemail;\n-    }\n-\n-    public String getSubject() {\n-        return subject;\n-    }\n-\n-    public void setSubject(String subject) {\n-        this.subject = subject;\n-    }\n-\n-    public String getMessageBody() {\n-        return messageBody;\n-    }\n-\n-    public void setMessageBody(String messageBody) {\n-        this.messageBody = messageBody;\n-    }\n-\n-    public String getSmtp_Hostname() {\n-        if (this.smtp_Hostname.equals(\"\")) {\n-            if (useIpWhitelist) {\n-                return Mail.SMTP_RELAY_HOSTNAME;\n-            } else {\n-                return Mail.SMTP_HOSTNAME;\n-            }\n+      }\n+      if (StringUtils.isNotBlank(this.getCcEmail())) {\n+        message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n+      }\n+      if (StringUtils.isNotBlank(this.getBccEmail())) {\n+        message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n+      }\n+      message.setSubject(this.subject);\n+      message.setContent(this.getMessageBody(), \"text/html\");\n+      Transport transport = session.getTransport();\n+      transport.send(message);\n+      logger.debug(\"sendemail()==== ends\");\n+      sentMail = true;\n+    } catch (MessagingException e) {\n+      logger.error(\"sendemail() MessagingException- error\", e);\n+    } catch (Exception e) {\n+      logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n+    }\n+    logger.debug(\"Mail.sendemail() :: Ends\");\n+    return sentMail;\n+  }\n+\n+  public boolean sendMailWithAttachment() throws Exception {\n+    logger.debug(\"sendMailWithAttachment()==== start\");\n+    boolean sentMail = false;\n+    try {\n+      final String username = this.getFromEmailAddress();\n+      final String password = this.getFromEmailPass();\n+      Properties props = makeProperties(useIpWhitelist);\n+      Session session =\n+          useIpWhitelist ? makeSession(props) : makeSession(props, username, password);\n+      Message message = new MimeMessage(session);\n+      if (StringUtils.isNotBlank(this.getToemail())) {\n+        if (this.getToemail().indexOf(\",\") != -1) {\n+          message.setRecipients(\n+              Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n         } else {\n-            return this.smtp_Hostname;\n+          message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n         }\n-    }\n+      }\n+      if (StringUtils.isNotBlank(this.getCcEmail())) {\n+        message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n+      }\n+      if (StringUtils.isNotBlank(this.getBccEmail())) {\n+        message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n+      }\n+      message.setSubject(this.subject);\n+      message.setFrom(new InternetAddress(username));\n+      // message.setText(\"Check attachment in Mail\");\n+      // message.setContent(messageBody, \"text/html\");\n+      // Create the message part\n+      BodyPart messageBodyPart = new MimeBodyPart();\n+      // Create a multipar message\n+      Multipart multipart = new MimeMultipart();", "originalCommit": "1275b0d755dc41d7df75133eab56d82eed9cb5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5NzczMQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465497731", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nMissing a Javadoc comment.", "author": "github-actions", "createdAt": "2020-08-05T06:18:17Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/util/Mail.java", "diffHunk": "@@ -23,308 +23,304 @@\n import javax.mail.internet.MimeBodyPart;\n import javax.mail.internet.MimeMessage;\n import javax.mail.internet.MimeMultipart;\n-\n import lombok.Setter;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n public class Mail {\n \n-    private static final Logger logger = LogManager.getLogger(Mail.class);\n-\n-    private String toemail;\n-    private String subject;\n-    private String messageBody;\n-    // Fallback hostname if we are authenticating.\n-    private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n-    // Fallback hostname if we are not authenticating.\n-    private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n-    private static final String SMTP_PORT = \"465\";\n-    private String smtp_Hostname = \"\";\n-    private String smtp_portvalue = \"\";\n-    static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n-    private String sslFactory = \"\";\n-    private String fromEmailAddress = \"\";\n-    private String fromEmailPass = \"\";\n-    private String fromEmailName = \"\";\n-    private String ccEmail;\n-    private String bccEmail;\n-    private String attachmentPath;\n-    // Domain that we send in the EHLO request if we are not authenticating\n-    // with the SMTP server.\n-    @Setter\n-    private String fromDomain = \"\";\n-    // If set to true, we will not authenticate with the SMTP service and\n-    // rather rely on the SMTP service's configured IP whitelist. If false we\n-    // will authenticate with the provided fromEmailAddress and fromEmailPass.\n-    @Setter\n-    private Boolean useIpWhitelist = false;\n-\n-    public boolean sendemail() throws Exception {\n-        logger.debug(\" sendemail() ==== starts\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            message.setFrom(new InternetAddress(username));\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setContent(this.getMessageBody(), \"text/html\");\n-            Transport transport = session.getTransport();\n-            transport.send(message);\n-            logger.debug(\"sendemail()==== ends\");\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"sendemail() MessagingException- error\", e);\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendemail() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    public boolean sendMailWithAttachment() throws Exception {\n-        logger.debug(\"sendMailWithAttachment()==== start\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setFrom(new InternetAddress(username));\n-            // message.setText(\"Check attachment in Mail\");\n-            // message.setContent(messageBody, \"text/html\");\n-            // Create the message part\n-            BodyPart messageBodyPart = new MimeBodyPart();\n-            // Create a multipar message\n-            Multipart multipart = new MimeMultipart();\n-            // Part two is attachment\n-            messageBodyPart = new MimeBodyPart();\n-            // String filename = \"D:\\\\temp\\\\TestLinks.pdf\"; // D:\\temp\\noteb.txt\n-            DataSource source = new FileDataSource(this.getAttachmentPath());\n-            messageBodyPart.setDataHandler(new DataHandler(source));\n-            messageBodyPart.setFileName(source.getName());\n-            messageBodyPart.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n-            messageBodyPart.setHeader(\"Content-Type\", source.getContentType());\n-            // Send the complete message parts\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            messageBodyPart = new MimeBodyPart();\n-            messageBodyPart.setText(messageBody);\n-            messageBodyPart.setHeader(\"MIME-Version\", \"1.0\");\n-            messageBodyPart.setHeader(\"Content-Type\", messageBodyPart.getContentType());\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            message.setContent(multipart);\n-            Transport.send(message);\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-            sentMail = false;\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendMailWithAttachment() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    // Constructs a Propterties either relying on IP Whitelist on the SMTP\n-    // service or on authentication with email and password.\n-    private Properties makeProperties(Boolean useIpWhitelist) {\n-        Properties props = new Properties();\n-        props.put(\"mail.smtp.host\", this.getSmtp_Hostname());\n-        props.put(\"mail.smtp.port\", this.getSmtp_portvalue());\n-        props.put(\"mail.smtp.socketFactory.class\", this.getSslFactory());\n-        props.put(\"mail.smtp.socketFactory.port\", this.getSmtp_portvalue());\n-        if (useIpWhitelist) {\n-            props.put(\"mail.smtp.auth\", \"false\");\n-            props.put(\"mail.smtp.ssl.enable\", \"true\");\n-            props.put(\"mail.smtp.localhost\", fromDomain);\n+  private static final Logger logger = LogManager.getLogger(Mail.class);\n+\n+  private String toemail;\n+  private String subject;\n+  private String messageBody;\n+  // Fallback hostname if we are authenticating.\n+  private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n+  // Fallback hostname if we are not authenticating.\n+  private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n+  private static final String SMTP_PORT = \"465\";\n+  private String smtp_Hostname = \"\";\n+  private String smtp_portvalue = \"\";\n+  static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n+  private String sslFactory = \"\";\n+  private String fromEmailAddress = \"\";\n+  private String fromEmailPass = \"\";\n+  private String fromEmailName = \"\";\n+  private String ccEmail;\n+  private String bccEmail;\n+  private String attachmentPath;\n+  // Domain that we send in the EHLO request if we are not authenticating\n+  // with the SMTP server.\n+  @Setter private String fromDomain = \"\";\n+  // If set to true, we will not authenticate with the SMTP service and\n+  // rather rely on the SMTP service's configured IP whitelist. If false we\n+  // will authenticate with the provided fromEmailAddress and fromEmailPass.\n+  @Setter private Boolean useIpWhitelist = false;\n+\n+  public boolean sendemail() throws Exception {\n+    logger.debug(\" sendemail() ==== starts\");\n+    boolean sentMail = false;\n+    try {\n+      final String username = this.getFromEmailAddress();\n+      final String password = this.getFromEmailPass();\n+      Properties props = makeProperties(useIpWhitelist);\n+      Session session =\n+          useIpWhitelist ? makeSession(props) : makeSession(props, username, password);\n+      Message message = new MimeMessage(session);\n+      message.setFrom(new InternetAddress(username));\n+      if (StringUtils.isNotBlank(this.getToemail())) {\n+        if (this.getToemail().indexOf(\",\") != -1) {\n+          message.setRecipients(\n+              Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n         } else {\n-            props.put(\"mail.smtp.auth\", \"true\");\n+          message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n         }\n-        return props;\n-    }\n-\n-    private Session makeSession(Properties props) {\n-        return Session.getInstance(props, null);\n-    }\n-\n-    private Session makeSession(Properties props, String username,\n-                                String password) {\n-        return Session.getInstance(\n-                props,\n-                new javax.mail.Authenticator() {\n-                    @Override\n-                    protected PasswordAuthentication getPasswordAuthentication() {\n-                        return new PasswordAuthentication(username, password);\n-                    }\n-                });\n-    }\n-\n-    public String getToemail() {\n-        return toemail;\n-    }\n-\n-    public void setToemail(String toemail) {\n-        this.toemail = toemail;\n-    }\n-\n-    public String getSubject() {\n-        return subject;\n-    }\n-\n-    public void setSubject(String subject) {\n-        this.subject = subject;\n-    }\n-\n-    public String getMessageBody() {\n-        return messageBody;\n-    }\n-\n-    public void setMessageBody(String messageBody) {\n-        this.messageBody = messageBody;\n-    }\n-\n-    public String getSmtp_Hostname() {\n-        if (this.smtp_Hostname.equals(\"\")) {\n-            if (useIpWhitelist) {\n-                return Mail.SMTP_RELAY_HOSTNAME;\n-            } else {\n-                return Mail.SMTP_HOSTNAME;\n-            }\n+      }\n+      if (StringUtils.isNotBlank(this.getCcEmail())) {\n+        message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n+      }\n+      if (StringUtils.isNotBlank(this.getBccEmail())) {\n+        message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n+      }\n+      message.setSubject(this.subject);\n+      message.setContent(this.getMessageBody(), \"text/html\");\n+      Transport transport = session.getTransport();\n+      transport.send(message);\n+      logger.debug(\"sendemail()==== ends\");\n+      sentMail = true;\n+    } catch (MessagingException e) {\n+      logger.error(\"sendemail() MessagingException- error\", e);\n+    } catch (Exception e) {\n+      logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n+    }\n+    logger.debug(\"Mail.sendemail() :: Ends\");\n+    return sentMail;\n+  }\n+\n+  public boolean sendMailWithAttachment() throws Exception {\n+    logger.debug(\"sendMailWithAttachment()==== start\");\n+    boolean sentMail = false;\n+    try {\n+      final String username = this.getFromEmailAddress();\n+      final String password = this.getFromEmailPass();\n+      Properties props = makeProperties(useIpWhitelist);\n+      Session session =\n+          useIpWhitelist ? makeSession(props) : makeSession(props, username, password);\n+      Message message = new MimeMessage(session);\n+      if (StringUtils.isNotBlank(this.getToemail())) {\n+        if (this.getToemail().indexOf(\",\") != -1) {\n+          message.setRecipients(\n+              Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n         } else {\n-            return this.smtp_Hostname;\n+          message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n         }\n-    }\n+      }\n+      if (StringUtils.isNotBlank(this.getCcEmail())) {\n+        message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n+      }\n+      if (StringUtils.isNotBlank(this.getBccEmail())) {\n+        message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n+      }\n+      message.setSubject(this.subject);\n+      message.setFrom(new InternetAddress(username));\n+      // message.setText(\"Check attachment in Mail\");\n+      // message.setContent(messageBody, \"text/html\");\n+      // Create the message part\n+      BodyPart messageBodyPart = new MimeBodyPart();\n+      // Create a multipar message\n+      Multipart multipart = new MimeMultipart();\n+      // Part two is attachment\n+      messageBodyPart = new MimeBodyPart();\n+      // String filename = \"D:\\\\temp\\\\TestLinks.pdf\"; // D:\\temp\\noteb.txt\n+      DataSource source = new FileDataSource(this.getAttachmentPath());\n+      messageBodyPart.setDataHandler(new DataHandler(source));\n+      messageBodyPart.setFileName(source.getName());\n+      messageBodyPart.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n+      messageBodyPart.setHeader(\"Content-Type\", source.getContentType());\n+      // Send the complete message parts\n+      multipart.addBodyPart(messageBodyPart);\n+\n+      messageBodyPart = new MimeBodyPart();\n+      messageBodyPart.setText(messageBody);\n+      messageBodyPart.setHeader(\"MIME-Version\", \"1.0\");\n+      messageBodyPart.setHeader(\"Content-Type\", messageBodyPart.getContentType());\n+      multipart.addBodyPart(messageBodyPart);\n+\n+      message.setContent(multipart);\n+      Transport.send(message);\n+      sentMail = true;\n+    } catch (MessagingException e) {\n+      logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n+      sentMail = false;\n+    } catch (Exception e) {\n+      logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n+    }\n+    logger.debug(\"Mail.sendMailWithAttachment() :: Ends\");\n+    return sentMail;\n+  }\n+\n+  // Constructs a Propterties either relying on IP Whitelist on the SMTP\n+  // service or on authentication with email and password.\n+  private Properties makeProperties(Boolean useIpWhitelist) {\n+    Properties props = new Properties();\n+    props.put(\"mail.smtp.host\", this.getSmtp_Hostname());\n+    props.put(\"mail.smtp.port\", this.getSmtp_portvalue());\n+    props.put(\"mail.smtp.socketFactory.class\", this.getSslFactory());\n+    props.put(\"mail.smtp.socketFactory.port\", this.getSmtp_portvalue());\n+    if (useIpWhitelist) {\n+      props.put(\"mail.smtp.auth\", \"false\");\n+      props.put(\"mail.smtp.ssl.enable\", \"true\");\n+      props.put(\"mail.smtp.localhost\", fromDomain);\n+    } else {\n+      props.put(\"mail.smtp.auth\", \"true\");\n+    }\n+    return props;\n+  }\n+\n+  private Session makeSession(Properties props) {\n+    return Session.getInstance(props, null);\n+  }\n+\n+  private Session makeSession(Properties props, String username, String password) {\n+    return Session.getInstance(\n+        props,\n+        new javax.mail.Authenticator() {\n+          @Override\n+          protected PasswordAuthentication getPasswordAuthentication() {\n+            return new PasswordAuthentication(username, password);\n+          }\n+        });\n+  }\n+\n+  public String getToemail() {\n+    return toemail;\n+  }\n+\n+  public void setToemail(String toemail) {\n+    this.toemail = toemail;\n+  }\n+\n+  public String getSubject() {\n+    return subject;\n+  }\n+\n+  public void setSubject(String subject) {\n+    this.subject = subject;\n+  }\n+\n+  public String getMessageBody() {\n+    return messageBody;\n+  }\n+\n+  public void setMessageBody(String messageBody) {\n+    this.messageBody = messageBody;\n+  }\n+\n+  public String getSmtp_Hostname() {", "originalCommit": "1275b0d755dc41d7df75133eab56d82eed9cb5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5NzczMg==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465497732", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nParameter name 'smtp_Hostname' must match pattern '^a-z?$'.", "author": "github-actions", "createdAt": "2020-08-05T06:18:17Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/util/Mail.java", "diffHunk": "@@ -23,308 +23,304 @@\n import javax.mail.internet.MimeBodyPart;\n import javax.mail.internet.MimeMessage;\n import javax.mail.internet.MimeMultipart;\n-\n import lombok.Setter;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n public class Mail {\n \n-    private static final Logger logger = LogManager.getLogger(Mail.class);\n-\n-    private String toemail;\n-    private String subject;\n-    private String messageBody;\n-    // Fallback hostname if we are authenticating.\n-    private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n-    // Fallback hostname if we are not authenticating.\n-    private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n-    private static final String SMTP_PORT = \"465\";\n-    private String smtp_Hostname = \"\";\n-    private String smtp_portvalue = \"\";\n-    static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n-    private String sslFactory = \"\";\n-    private String fromEmailAddress = \"\";\n-    private String fromEmailPass = \"\";\n-    private String fromEmailName = \"\";\n-    private String ccEmail;\n-    private String bccEmail;\n-    private String attachmentPath;\n-    // Domain that we send in the EHLO request if we are not authenticating\n-    // with the SMTP server.\n-    @Setter\n-    private String fromDomain = \"\";\n-    // If set to true, we will not authenticate with the SMTP service and\n-    // rather rely on the SMTP service's configured IP whitelist. If false we\n-    // will authenticate with the provided fromEmailAddress and fromEmailPass.\n-    @Setter\n-    private Boolean useIpWhitelist = false;\n-\n-    public boolean sendemail() throws Exception {\n-        logger.debug(\" sendemail() ==== starts\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            message.setFrom(new InternetAddress(username));\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setContent(this.getMessageBody(), \"text/html\");\n-            Transport transport = session.getTransport();\n-            transport.send(message);\n-            logger.debug(\"sendemail()==== ends\");\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"sendemail() MessagingException- error\", e);\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendemail() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    public boolean sendMailWithAttachment() throws Exception {\n-        logger.debug(\"sendMailWithAttachment()==== start\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setFrom(new InternetAddress(username));\n-            // message.setText(\"Check attachment in Mail\");\n-            // message.setContent(messageBody, \"text/html\");\n-            // Create the message part\n-            BodyPart messageBodyPart = new MimeBodyPart();\n-            // Create a multipar message\n-            Multipart multipart = new MimeMultipart();\n-            // Part two is attachment\n-            messageBodyPart = new MimeBodyPart();\n-            // String filename = \"D:\\\\temp\\\\TestLinks.pdf\"; // D:\\temp\\noteb.txt\n-            DataSource source = new FileDataSource(this.getAttachmentPath());\n-            messageBodyPart.setDataHandler(new DataHandler(source));\n-            messageBodyPart.setFileName(source.getName());\n-            messageBodyPart.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n-            messageBodyPart.setHeader(\"Content-Type\", source.getContentType());\n-            // Send the complete message parts\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            messageBodyPart = new MimeBodyPart();\n-            messageBodyPart.setText(messageBody);\n-            messageBodyPart.setHeader(\"MIME-Version\", \"1.0\");\n-            messageBodyPart.setHeader(\"Content-Type\", messageBodyPart.getContentType());\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            message.setContent(multipart);\n-            Transport.send(message);\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-            sentMail = false;\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendMailWithAttachment() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    // Constructs a Propterties either relying on IP Whitelist on the SMTP\n-    // service or on authentication with email and password.\n-    private Properties makeProperties(Boolean useIpWhitelist) {\n-        Properties props = new Properties();\n-        props.put(\"mail.smtp.host\", this.getSmtp_Hostname());\n-        props.put(\"mail.smtp.port\", this.getSmtp_portvalue());\n-        props.put(\"mail.smtp.socketFactory.class\", this.getSslFactory());\n-        props.put(\"mail.smtp.socketFactory.port\", this.getSmtp_portvalue());\n-        if (useIpWhitelist) {\n-            props.put(\"mail.smtp.auth\", \"false\");\n-            props.put(\"mail.smtp.ssl.enable\", \"true\");\n-            props.put(\"mail.smtp.localhost\", fromDomain);\n+  private static final Logger logger = LogManager.getLogger(Mail.class);\n+\n+  private String toemail;\n+  private String subject;\n+  private String messageBody;\n+  // Fallback hostname if we are authenticating.\n+  private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n+  // Fallback hostname if we are not authenticating.\n+  private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n+  private static final String SMTP_PORT = \"465\";\n+  private String smtp_Hostname = \"\";\n+  private String smtp_portvalue = \"\";\n+  static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n+  private String sslFactory = \"\";\n+  private String fromEmailAddress = \"\";\n+  private String fromEmailPass = \"\";\n+  private String fromEmailName = \"\";\n+  private String ccEmail;\n+  private String bccEmail;\n+  private String attachmentPath;\n+  // Domain that we send in the EHLO request if we are not authenticating\n+  // with the SMTP server.\n+  @Setter private String fromDomain = \"\";\n+  // If set to true, we will not authenticate with the SMTP service and\n+  // rather rely on the SMTP service's configured IP whitelist. If false we\n+  // will authenticate with the provided fromEmailAddress and fromEmailPass.\n+  @Setter private Boolean useIpWhitelist = false;\n+\n+  public boolean sendemail() throws Exception {\n+    logger.debug(\" sendemail() ==== starts\");\n+    boolean sentMail = false;\n+    try {\n+      final String username = this.getFromEmailAddress();\n+      final String password = this.getFromEmailPass();\n+      Properties props = makeProperties(useIpWhitelist);\n+      Session session =\n+          useIpWhitelist ? makeSession(props) : makeSession(props, username, password);\n+      Message message = new MimeMessage(session);\n+      message.setFrom(new InternetAddress(username));\n+      if (StringUtils.isNotBlank(this.getToemail())) {\n+        if (this.getToemail().indexOf(\",\") != -1) {\n+          message.setRecipients(\n+              Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n         } else {\n-            props.put(\"mail.smtp.auth\", \"true\");\n+          message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n         }\n-        return props;\n-    }\n-\n-    private Session makeSession(Properties props) {\n-        return Session.getInstance(props, null);\n-    }\n-\n-    private Session makeSession(Properties props, String username,\n-                                String password) {\n-        return Session.getInstance(\n-                props,\n-                new javax.mail.Authenticator() {\n-                    @Override\n-                    protected PasswordAuthentication getPasswordAuthentication() {\n-                        return new PasswordAuthentication(username, password);\n-                    }\n-                });\n-    }\n-\n-    public String getToemail() {\n-        return toemail;\n-    }\n-\n-    public void setToemail(String toemail) {\n-        this.toemail = toemail;\n-    }\n-\n-    public String getSubject() {\n-        return subject;\n-    }\n-\n-    public void setSubject(String subject) {\n-        this.subject = subject;\n-    }\n-\n-    public String getMessageBody() {\n-        return messageBody;\n-    }\n-\n-    public void setMessageBody(String messageBody) {\n-        this.messageBody = messageBody;\n-    }\n-\n-    public String getSmtp_Hostname() {\n-        if (this.smtp_Hostname.equals(\"\")) {\n-            if (useIpWhitelist) {\n-                return Mail.SMTP_RELAY_HOSTNAME;\n-            } else {\n-                return Mail.SMTP_HOSTNAME;\n-            }\n+      }\n+      if (StringUtils.isNotBlank(this.getCcEmail())) {\n+        message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n+      }\n+      if (StringUtils.isNotBlank(this.getBccEmail())) {\n+        message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n+      }\n+      message.setSubject(this.subject);\n+      message.setContent(this.getMessageBody(), \"text/html\");\n+      Transport transport = session.getTransport();\n+      transport.send(message);\n+      logger.debug(\"sendemail()==== ends\");\n+      sentMail = true;\n+    } catch (MessagingException e) {\n+      logger.error(\"sendemail() MessagingException- error\", e);\n+    } catch (Exception e) {\n+      logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n+    }\n+    logger.debug(\"Mail.sendemail() :: Ends\");\n+    return sentMail;\n+  }\n+\n+  public boolean sendMailWithAttachment() throws Exception {\n+    logger.debug(\"sendMailWithAttachment()==== start\");\n+    boolean sentMail = false;\n+    try {\n+      final String username = this.getFromEmailAddress();\n+      final String password = this.getFromEmailPass();\n+      Properties props = makeProperties(useIpWhitelist);\n+      Session session =\n+          useIpWhitelist ? makeSession(props) : makeSession(props, username, password);\n+      Message message = new MimeMessage(session);\n+      if (StringUtils.isNotBlank(this.getToemail())) {\n+        if (this.getToemail().indexOf(\",\") != -1) {\n+          message.setRecipients(\n+              Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n         } else {\n-            return this.smtp_Hostname;\n+          message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n         }\n-    }\n+      }\n+      if (StringUtils.isNotBlank(this.getCcEmail())) {\n+        message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n+      }\n+      if (StringUtils.isNotBlank(this.getBccEmail())) {\n+        message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n+      }\n+      message.setSubject(this.subject);\n+      message.setFrom(new InternetAddress(username));\n+      // message.setText(\"Check attachment in Mail\");\n+      // message.setContent(messageBody, \"text/html\");\n+      // Create the message part\n+      BodyPart messageBodyPart = new MimeBodyPart();\n+      // Create a multipar message\n+      Multipart multipart = new MimeMultipart();\n+      // Part two is attachment\n+      messageBodyPart = new MimeBodyPart();\n+      // String filename = \"D:\\\\temp\\\\TestLinks.pdf\"; // D:\\temp\\noteb.txt\n+      DataSource source = new FileDataSource(this.getAttachmentPath());\n+      messageBodyPart.setDataHandler(new DataHandler(source));\n+      messageBodyPart.setFileName(source.getName());\n+      messageBodyPart.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n+      messageBodyPart.setHeader(\"Content-Type\", source.getContentType());\n+      // Send the complete message parts\n+      multipart.addBodyPart(messageBodyPart);\n+\n+      messageBodyPart = new MimeBodyPart();\n+      messageBodyPart.setText(messageBody);\n+      messageBodyPart.setHeader(\"MIME-Version\", \"1.0\");\n+      messageBodyPart.setHeader(\"Content-Type\", messageBodyPart.getContentType());\n+      multipart.addBodyPart(messageBodyPart);\n+\n+      message.setContent(multipart);\n+      Transport.send(message);\n+      sentMail = true;\n+    } catch (MessagingException e) {\n+      logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n+      sentMail = false;\n+    } catch (Exception e) {\n+      logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n+    }\n+    logger.debug(\"Mail.sendMailWithAttachment() :: Ends\");\n+    return sentMail;\n+  }\n+\n+  // Constructs a Propterties either relying on IP Whitelist on the SMTP\n+  // service or on authentication with email and password.\n+  private Properties makeProperties(Boolean useIpWhitelist) {\n+    Properties props = new Properties();\n+    props.put(\"mail.smtp.host\", this.getSmtp_Hostname());\n+    props.put(\"mail.smtp.port\", this.getSmtp_portvalue());\n+    props.put(\"mail.smtp.socketFactory.class\", this.getSslFactory());\n+    props.put(\"mail.smtp.socketFactory.port\", this.getSmtp_portvalue());\n+    if (useIpWhitelist) {\n+      props.put(\"mail.smtp.auth\", \"false\");\n+      props.put(\"mail.smtp.ssl.enable\", \"true\");\n+      props.put(\"mail.smtp.localhost\", fromDomain);\n+    } else {\n+      props.put(\"mail.smtp.auth\", \"true\");\n+    }\n+    return props;\n+  }\n+\n+  private Session makeSession(Properties props) {\n+    return Session.getInstance(props, null);\n+  }\n+\n+  private Session makeSession(Properties props, String username, String password) {\n+    return Session.getInstance(\n+        props,\n+        new javax.mail.Authenticator() {\n+          @Override\n+          protected PasswordAuthentication getPasswordAuthentication() {\n+            return new PasswordAuthentication(username, password);\n+          }\n+        });\n+  }\n+\n+  public String getToemail() {\n+    return toemail;\n+  }\n+\n+  public void setToemail(String toemail) {\n+    this.toemail = toemail;\n+  }\n+\n+  public String getSubject() {\n+    return subject;\n+  }\n+\n+  public void setSubject(String subject) {\n+    this.subject = subject;\n+  }\n+\n+  public String getMessageBody() {\n+    return messageBody;\n+  }\n+\n+  public void setMessageBody(String messageBody) {\n+    this.messageBody = messageBody;\n+  }\n+\n+  public String getSmtp_Hostname() {\n+    if (this.smtp_Hostname.equals(\"\")) {\n+      if (useIpWhitelist) {\n+        return Mail.SMTP_RELAY_HOSTNAME;\n+      } else {\n+        return Mail.SMTP_HOSTNAME;\n+      }\n+    } else {\n+      return this.smtp_Hostname;\n+    }\n+  }\n+\n+  public void setSmtp_Hostname(String smtp_Hostname) {", "originalCommit": "1275b0d755dc41d7df75133eab56d82eed9cb5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5NzczNA==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465497734", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nMissing a Javadoc comment.", "author": "github-actions", "createdAt": "2020-08-05T06:18:17Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/util/Mail.java", "diffHunk": "@@ -23,308 +23,304 @@\n import javax.mail.internet.MimeBodyPart;\n import javax.mail.internet.MimeMessage;\n import javax.mail.internet.MimeMultipart;\n-\n import lombok.Setter;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n public class Mail {\n \n-    private static final Logger logger = LogManager.getLogger(Mail.class);\n-\n-    private String toemail;\n-    private String subject;\n-    private String messageBody;\n-    // Fallback hostname if we are authenticating.\n-    private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n-    // Fallback hostname if we are not authenticating.\n-    private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n-    private static final String SMTP_PORT = \"465\";\n-    private String smtp_Hostname = \"\";\n-    private String smtp_portvalue = \"\";\n-    static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n-    private String sslFactory = \"\";\n-    private String fromEmailAddress = \"\";\n-    private String fromEmailPass = \"\";\n-    private String fromEmailName = \"\";\n-    private String ccEmail;\n-    private String bccEmail;\n-    private String attachmentPath;\n-    // Domain that we send in the EHLO request if we are not authenticating\n-    // with the SMTP server.\n-    @Setter\n-    private String fromDomain = \"\";\n-    // If set to true, we will not authenticate with the SMTP service and\n-    // rather rely on the SMTP service's configured IP whitelist. If false we\n-    // will authenticate with the provided fromEmailAddress and fromEmailPass.\n-    @Setter\n-    private Boolean useIpWhitelist = false;\n-\n-    public boolean sendemail() throws Exception {\n-        logger.debug(\" sendemail() ==== starts\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            message.setFrom(new InternetAddress(username));\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setContent(this.getMessageBody(), \"text/html\");\n-            Transport transport = session.getTransport();\n-            transport.send(message);\n-            logger.debug(\"sendemail()==== ends\");\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"sendemail() MessagingException- error\", e);\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendemail() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    public boolean sendMailWithAttachment() throws Exception {\n-        logger.debug(\"sendMailWithAttachment()==== start\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setFrom(new InternetAddress(username));\n-            // message.setText(\"Check attachment in Mail\");\n-            // message.setContent(messageBody, \"text/html\");\n-            // Create the message part\n-            BodyPart messageBodyPart = new MimeBodyPart();\n-            // Create a multipar message\n-            Multipart multipart = new MimeMultipart();\n-            // Part two is attachment\n-            messageBodyPart = new MimeBodyPart();\n-            // String filename = \"D:\\\\temp\\\\TestLinks.pdf\"; // D:\\temp\\noteb.txt\n-            DataSource source = new FileDataSource(this.getAttachmentPath());\n-            messageBodyPart.setDataHandler(new DataHandler(source));\n-            messageBodyPart.setFileName(source.getName());\n-            messageBodyPart.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n-            messageBodyPart.setHeader(\"Content-Type\", source.getContentType());\n-            // Send the complete message parts\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            messageBodyPart = new MimeBodyPart();\n-            messageBodyPart.setText(messageBody);\n-            messageBodyPart.setHeader(\"MIME-Version\", \"1.0\");\n-            messageBodyPart.setHeader(\"Content-Type\", messageBodyPart.getContentType());\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            message.setContent(multipart);\n-            Transport.send(message);\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-            sentMail = false;\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendMailWithAttachment() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    // Constructs a Propterties either relying on IP Whitelist on the SMTP\n-    // service or on authentication with email and password.\n-    private Properties makeProperties(Boolean useIpWhitelist) {\n-        Properties props = new Properties();\n-        props.put(\"mail.smtp.host\", this.getSmtp_Hostname());\n-        props.put(\"mail.smtp.port\", this.getSmtp_portvalue());\n-        props.put(\"mail.smtp.socketFactory.class\", this.getSslFactory());\n-        props.put(\"mail.smtp.socketFactory.port\", this.getSmtp_portvalue());\n-        if (useIpWhitelist) {\n-            props.put(\"mail.smtp.auth\", \"false\");\n-            props.put(\"mail.smtp.ssl.enable\", \"true\");\n-            props.put(\"mail.smtp.localhost\", fromDomain);\n+  private static final Logger logger = LogManager.getLogger(Mail.class);\n+\n+  private String toemail;\n+  private String subject;\n+  private String messageBody;\n+  // Fallback hostname if we are authenticating.\n+  private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n+  // Fallback hostname if we are not authenticating.\n+  private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n+  private static final String SMTP_PORT = \"465\";\n+  private String smtp_Hostname = \"\";\n+  private String smtp_portvalue = \"\";\n+  static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n+  private String sslFactory = \"\";\n+  private String fromEmailAddress = \"\";\n+  private String fromEmailPass = \"\";\n+  private String fromEmailName = \"\";\n+  private String ccEmail;\n+  private String bccEmail;\n+  private String attachmentPath;\n+  // Domain that we send in the EHLO request if we are not authenticating\n+  // with the SMTP server.\n+  @Setter private String fromDomain = \"\";\n+  // If set to true, we will not authenticate with the SMTP service and\n+  // rather rely on the SMTP service's configured IP whitelist. If false we\n+  // will authenticate with the provided fromEmailAddress and fromEmailPass.\n+  @Setter private Boolean useIpWhitelist = false;\n+\n+  public boolean sendemail() throws Exception {\n+    logger.debug(\" sendemail() ==== starts\");\n+    boolean sentMail = false;\n+    try {\n+      final String username = this.getFromEmailAddress();\n+      final String password = this.getFromEmailPass();\n+      Properties props = makeProperties(useIpWhitelist);\n+      Session session =\n+          useIpWhitelist ? makeSession(props) : makeSession(props, username, password);\n+      Message message = new MimeMessage(session);\n+      message.setFrom(new InternetAddress(username));\n+      if (StringUtils.isNotBlank(this.getToemail())) {\n+        if (this.getToemail().indexOf(\",\") != -1) {\n+          message.setRecipients(\n+              Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n         } else {\n-            props.put(\"mail.smtp.auth\", \"true\");\n+          message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n         }\n-        return props;\n-    }\n-\n-    private Session makeSession(Properties props) {\n-        return Session.getInstance(props, null);\n-    }\n-\n-    private Session makeSession(Properties props, String username,\n-                                String password) {\n-        return Session.getInstance(\n-                props,\n-                new javax.mail.Authenticator() {\n-                    @Override\n-                    protected PasswordAuthentication getPasswordAuthentication() {\n-                        return new PasswordAuthentication(username, password);\n-                    }\n-                });\n-    }\n-\n-    public String getToemail() {\n-        return toemail;\n-    }\n-\n-    public void setToemail(String toemail) {\n-        this.toemail = toemail;\n-    }\n-\n-    public String getSubject() {\n-        return subject;\n-    }\n-\n-    public void setSubject(String subject) {\n-        this.subject = subject;\n-    }\n-\n-    public String getMessageBody() {\n-        return messageBody;\n-    }\n-\n-    public void setMessageBody(String messageBody) {\n-        this.messageBody = messageBody;\n-    }\n-\n-    public String getSmtp_Hostname() {\n-        if (this.smtp_Hostname.equals(\"\")) {\n-            if (useIpWhitelist) {\n-                return Mail.SMTP_RELAY_HOSTNAME;\n-            } else {\n-                return Mail.SMTP_HOSTNAME;\n-            }\n+      }\n+      if (StringUtils.isNotBlank(this.getCcEmail())) {\n+        message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n+      }\n+      if (StringUtils.isNotBlank(this.getBccEmail())) {\n+        message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n+      }\n+      message.setSubject(this.subject);\n+      message.setContent(this.getMessageBody(), \"text/html\");\n+      Transport transport = session.getTransport();\n+      transport.send(message);\n+      logger.debug(\"sendemail()==== ends\");\n+      sentMail = true;\n+    } catch (MessagingException e) {\n+      logger.error(\"sendemail() MessagingException- error\", e);\n+    } catch (Exception e) {\n+      logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n+    }\n+    logger.debug(\"Mail.sendemail() :: Ends\");\n+    return sentMail;\n+  }\n+\n+  public boolean sendMailWithAttachment() throws Exception {\n+    logger.debug(\"sendMailWithAttachment()==== start\");\n+    boolean sentMail = false;\n+    try {\n+      final String username = this.getFromEmailAddress();\n+      final String password = this.getFromEmailPass();\n+      Properties props = makeProperties(useIpWhitelist);\n+      Session session =\n+          useIpWhitelist ? makeSession(props) : makeSession(props, username, password);\n+      Message message = new MimeMessage(session);\n+      if (StringUtils.isNotBlank(this.getToemail())) {\n+        if (this.getToemail().indexOf(\",\") != -1) {\n+          message.setRecipients(\n+              Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n         } else {\n-            return this.smtp_Hostname;\n+          message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n         }\n-    }\n+      }\n+      if (StringUtils.isNotBlank(this.getCcEmail())) {\n+        message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n+      }\n+      if (StringUtils.isNotBlank(this.getBccEmail())) {\n+        message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n+      }\n+      message.setSubject(this.subject);\n+      message.setFrom(new InternetAddress(username));\n+      // message.setText(\"Check attachment in Mail\");\n+      // message.setContent(messageBody, \"text/html\");\n+      // Create the message part\n+      BodyPart messageBodyPart = new MimeBodyPart();\n+      // Create a multipar message\n+      Multipart multipart = new MimeMultipart();\n+      // Part two is attachment\n+      messageBodyPart = new MimeBodyPart();\n+      // String filename = \"D:\\\\temp\\\\TestLinks.pdf\"; // D:\\temp\\noteb.txt\n+      DataSource source = new FileDataSource(this.getAttachmentPath());\n+      messageBodyPart.setDataHandler(new DataHandler(source));\n+      messageBodyPart.setFileName(source.getName());\n+      messageBodyPart.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n+      messageBodyPart.setHeader(\"Content-Type\", source.getContentType());\n+      // Send the complete message parts\n+      multipart.addBodyPart(messageBodyPart);\n+\n+      messageBodyPart = new MimeBodyPart();\n+      messageBodyPart.setText(messageBody);\n+      messageBodyPart.setHeader(\"MIME-Version\", \"1.0\");\n+      messageBodyPart.setHeader(\"Content-Type\", messageBodyPart.getContentType());\n+      multipart.addBodyPart(messageBodyPart);\n+\n+      message.setContent(multipart);\n+      Transport.send(message);\n+      sentMail = true;\n+    } catch (MessagingException e) {\n+      logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n+      sentMail = false;\n+    } catch (Exception e) {\n+      logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n+    }\n+    logger.debug(\"Mail.sendMailWithAttachment() :: Ends\");\n+    return sentMail;\n+  }\n+\n+  // Constructs a Propterties either relying on IP Whitelist on the SMTP\n+  // service or on authentication with email and password.\n+  private Properties makeProperties(Boolean useIpWhitelist) {\n+    Properties props = new Properties();\n+    props.put(\"mail.smtp.host\", this.getSmtp_Hostname());\n+    props.put(\"mail.smtp.port\", this.getSmtp_portvalue());\n+    props.put(\"mail.smtp.socketFactory.class\", this.getSslFactory());\n+    props.put(\"mail.smtp.socketFactory.port\", this.getSmtp_portvalue());\n+    if (useIpWhitelist) {\n+      props.put(\"mail.smtp.auth\", \"false\");\n+      props.put(\"mail.smtp.ssl.enable\", \"true\");\n+      props.put(\"mail.smtp.localhost\", fromDomain);\n+    } else {\n+      props.put(\"mail.smtp.auth\", \"true\");\n+    }\n+    return props;\n+  }\n+\n+  private Session makeSession(Properties props) {\n+    return Session.getInstance(props, null);\n+  }\n+\n+  private Session makeSession(Properties props, String username, String password) {\n+    return Session.getInstance(\n+        props,\n+        new javax.mail.Authenticator() {\n+          @Override\n+          protected PasswordAuthentication getPasswordAuthentication() {\n+            return new PasswordAuthentication(username, password);\n+          }\n+        });\n+  }\n+\n+  public String getToemail() {\n+    return toemail;\n+  }\n+\n+  public void setToemail(String toemail) {\n+    this.toemail = toemail;\n+  }\n+\n+  public String getSubject() {\n+    return subject;\n+  }\n+\n+  public void setSubject(String subject) {\n+    this.subject = subject;\n+  }\n+\n+  public String getMessageBody() {\n+    return messageBody;\n+  }\n+\n+  public void setMessageBody(String messageBody) {\n+    this.messageBody = messageBody;\n+  }\n+\n+  public String getSmtp_Hostname() {\n+    if (this.smtp_Hostname.equals(\"\")) {\n+      if (useIpWhitelist) {\n+        return Mail.SMTP_RELAY_HOSTNAME;\n+      } else {\n+        return Mail.SMTP_HOSTNAME;\n+      }\n+    } else {\n+      return this.smtp_Hostname;\n+    }\n+  }\n+\n+  public void setSmtp_Hostname(String smtp_Hostname) {\n+    this.smtp_Hostname = smtp_Hostname;\n+  }\n+\n+  public String getSmtp_portvalue() {", "originalCommit": "1275b0d755dc41d7df75133eab56d82eed9cb5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5NzczNQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465497735", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nParameter name 'smtp_portvalue' must match pattern '^a-z?$'.", "author": "github-actions", "createdAt": "2020-08-05T06:18:17Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/util/Mail.java", "diffHunk": "@@ -23,308 +23,304 @@\n import javax.mail.internet.MimeBodyPart;\n import javax.mail.internet.MimeMessage;\n import javax.mail.internet.MimeMultipart;\n-\n import lombok.Setter;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n public class Mail {\n \n-    private static final Logger logger = LogManager.getLogger(Mail.class);\n-\n-    private String toemail;\n-    private String subject;\n-    private String messageBody;\n-    // Fallback hostname if we are authenticating.\n-    private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n-    // Fallback hostname if we are not authenticating.\n-    private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n-    private static final String SMTP_PORT = \"465\";\n-    private String smtp_Hostname = \"\";\n-    private String smtp_portvalue = \"\";\n-    static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n-    private String sslFactory = \"\";\n-    private String fromEmailAddress = \"\";\n-    private String fromEmailPass = \"\";\n-    private String fromEmailName = \"\";\n-    private String ccEmail;\n-    private String bccEmail;\n-    private String attachmentPath;\n-    // Domain that we send in the EHLO request if we are not authenticating\n-    // with the SMTP server.\n-    @Setter\n-    private String fromDomain = \"\";\n-    // If set to true, we will not authenticate with the SMTP service and\n-    // rather rely on the SMTP service's configured IP whitelist. If false we\n-    // will authenticate with the provided fromEmailAddress and fromEmailPass.\n-    @Setter\n-    private Boolean useIpWhitelist = false;\n-\n-    public boolean sendemail() throws Exception {\n-        logger.debug(\" sendemail() ==== starts\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            message.setFrom(new InternetAddress(username));\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setContent(this.getMessageBody(), \"text/html\");\n-            Transport transport = session.getTransport();\n-            transport.send(message);\n-            logger.debug(\"sendemail()==== ends\");\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"sendemail() MessagingException- error\", e);\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendemail() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    public boolean sendMailWithAttachment() throws Exception {\n-        logger.debug(\"sendMailWithAttachment()==== start\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setFrom(new InternetAddress(username));\n-            // message.setText(\"Check attachment in Mail\");\n-            // message.setContent(messageBody, \"text/html\");\n-            // Create the message part\n-            BodyPart messageBodyPart = new MimeBodyPart();\n-            // Create a multipar message\n-            Multipart multipart = new MimeMultipart();\n-            // Part two is attachment\n-            messageBodyPart = new MimeBodyPart();\n-            // String filename = \"D:\\\\temp\\\\TestLinks.pdf\"; // D:\\temp\\noteb.txt\n-            DataSource source = new FileDataSource(this.getAttachmentPath());\n-            messageBodyPart.setDataHandler(new DataHandler(source));\n-            messageBodyPart.setFileName(source.getName());\n-            messageBodyPart.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n-            messageBodyPart.setHeader(\"Content-Type\", source.getContentType());\n-            // Send the complete message parts\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            messageBodyPart = new MimeBodyPart();\n-            messageBodyPart.setText(messageBody);\n-            messageBodyPart.setHeader(\"MIME-Version\", \"1.0\");\n-            messageBodyPart.setHeader(\"Content-Type\", messageBodyPart.getContentType());\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            message.setContent(multipart);\n-            Transport.send(message);\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-            sentMail = false;\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendMailWithAttachment() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    // Constructs a Propterties either relying on IP Whitelist on the SMTP\n-    // service or on authentication with email and password.\n-    private Properties makeProperties(Boolean useIpWhitelist) {\n-        Properties props = new Properties();\n-        props.put(\"mail.smtp.host\", this.getSmtp_Hostname());\n-        props.put(\"mail.smtp.port\", this.getSmtp_portvalue());\n-        props.put(\"mail.smtp.socketFactory.class\", this.getSslFactory());\n-        props.put(\"mail.smtp.socketFactory.port\", this.getSmtp_portvalue());\n-        if (useIpWhitelist) {\n-            props.put(\"mail.smtp.auth\", \"false\");\n-            props.put(\"mail.smtp.ssl.enable\", \"true\");\n-            props.put(\"mail.smtp.localhost\", fromDomain);\n+  private static final Logger logger = LogManager.getLogger(Mail.class);\n+\n+  private String toemail;\n+  private String subject;\n+  private String messageBody;\n+  // Fallback hostname if we are authenticating.\n+  private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n+  // Fallback hostname if we are not authenticating.\n+  private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n+  private static final String SMTP_PORT = \"465\";\n+  private String smtp_Hostname = \"\";\n+  private String smtp_portvalue = \"\";\n+  static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n+  private String sslFactory = \"\";\n+  private String fromEmailAddress = \"\";\n+  private String fromEmailPass = \"\";\n+  private String fromEmailName = \"\";\n+  private String ccEmail;\n+  private String bccEmail;\n+  private String attachmentPath;\n+  // Domain that we send in the EHLO request if we are not authenticating\n+  // with the SMTP server.\n+  @Setter private String fromDomain = \"\";\n+  // If set to true, we will not authenticate with the SMTP service and\n+  // rather rely on the SMTP service's configured IP whitelist. If false we\n+  // will authenticate with the provided fromEmailAddress and fromEmailPass.\n+  @Setter private Boolean useIpWhitelist = false;\n+\n+  public boolean sendemail() throws Exception {\n+    logger.debug(\" sendemail() ==== starts\");\n+    boolean sentMail = false;\n+    try {\n+      final String username = this.getFromEmailAddress();\n+      final String password = this.getFromEmailPass();\n+      Properties props = makeProperties(useIpWhitelist);\n+      Session session =\n+          useIpWhitelist ? makeSession(props) : makeSession(props, username, password);\n+      Message message = new MimeMessage(session);\n+      message.setFrom(new InternetAddress(username));\n+      if (StringUtils.isNotBlank(this.getToemail())) {\n+        if (this.getToemail().indexOf(\",\") != -1) {\n+          message.setRecipients(\n+              Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n         } else {\n-            props.put(\"mail.smtp.auth\", \"true\");\n+          message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n         }\n-        return props;\n-    }\n-\n-    private Session makeSession(Properties props) {\n-        return Session.getInstance(props, null);\n-    }\n-\n-    private Session makeSession(Properties props, String username,\n-                                String password) {\n-        return Session.getInstance(\n-                props,\n-                new javax.mail.Authenticator() {\n-                    @Override\n-                    protected PasswordAuthentication getPasswordAuthentication() {\n-                        return new PasswordAuthentication(username, password);\n-                    }\n-                });\n-    }\n-\n-    public String getToemail() {\n-        return toemail;\n-    }\n-\n-    public void setToemail(String toemail) {\n-        this.toemail = toemail;\n-    }\n-\n-    public String getSubject() {\n-        return subject;\n-    }\n-\n-    public void setSubject(String subject) {\n-        this.subject = subject;\n-    }\n-\n-    public String getMessageBody() {\n-        return messageBody;\n-    }\n-\n-    public void setMessageBody(String messageBody) {\n-        this.messageBody = messageBody;\n-    }\n-\n-    public String getSmtp_Hostname() {\n-        if (this.smtp_Hostname.equals(\"\")) {\n-            if (useIpWhitelist) {\n-                return Mail.SMTP_RELAY_HOSTNAME;\n-            } else {\n-                return Mail.SMTP_HOSTNAME;\n-            }\n+      }\n+      if (StringUtils.isNotBlank(this.getCcEmail())) {\n+        message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n+      }\n+      if (StringUtils.isNotBlank(this.getBccEmail())) {\n+        message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n+      }\n+      message.setSubject(this.subject);\n+      message.setContent(this.getMessageBody(), \"text/html\");\n+      Transport transport = session.getTransport();\n+      transport.send(message);\n+      logger.debug(\"sendemail()==== ends\");\n+      sentMail = true;\n+    } catch (MessagingException e) {\n+      logger.error(\"sendemail() MessagingException- error\", e);\n+    } catch (Exception e) {\n+      logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n+    }\n+    logger.debug(\"Mail.sendemail() :: Ends\");\n+    return sentMail;\n+  }\n+\n+  public boolean sendMailWithAttachment() throws Exception {\n+    logger.debug(\"sendMailWithAttachment()==== start\");\n+    boolean sentMail = false;\n+    try {\n+      final String username = this.getFromEmailAddress();\n+      final String password = this.getFromEmailPass();\n+      Properties props = makeProperties(useIpWhitelist);\n+      Session session =\n+          useIpWhitelist ? makeSession(props) : makeSession(props, username, password);\n+      Message message = new MimeMessage(session);\n+      if (StringUtils.isNotBlank(this.getToemail())) {\n+        if (this.getToemail().indexOf(\",\") != -1) {\n+          message.setRecipients(\n+              Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n         } else {\n-            return this.smtp_Hostname;\n+          message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n         }\n-    }\n+      }\n+      if (StringUtils.isNotBlank(this.getCcEmail())) {\n+        message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n+      }\n+      if (StringUtils.isNotBlank(this.getBccEmail())) {\n+        message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n+      }\n+      message.setSubject(this.subject);\n+      message.setFrom(new InternetAddress(username));\n+      // message.setText(\"Check attachment in Mail\");\n+      // message.setContent(messageBody, \"text/html\");\n+      // Create the message part\n+      BodyPart messageBodyPart = new MimeBodyPart();\n+      // Create a multipar message\n+      Multipart multipart = new MimeMultipart();\n+      // Part two is attachment\n+      messageBodyPart = new MimeBodyPart();\n+      // String filename = \"D:\\\\temp\\\\TestLinks.pdf\"; // D:\\temp\\noteb.txt\n+      DataSource source = new FileDataSource(this.getAttachmentPath());\n+      messageBodyPart.setDataHandler(new DataHandler(source));\n+      messageBodyPart.setFileName(source.getName());\n+      messageBodyPart.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n+      messageBodyPart.setHeader(\"Content-Type\", source.getContentType());\n+      // Send the complete message parts\n+      multipart.addBodyPart(messageBodyPart);\n+\n+      messageBodyPart = new MimeBodyPart();\n+      messageBodyPart.setText(messageBody);\n+      messageBodyPart.setHeader(\"MIME-Version\", \"1.0\");\n+      messageBodyPart.setHeader(\"Content-Type\", messageBodyPart.getContentType());\n+      multipart.addBodyPart(messageBodyPart);\n+\n+      message.setContent(multipart);\n+      Transport.send(message);\n+      sentMail = true;\n+    } catch (MessagingException e) {\n+      logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n+      sentMail = false;\n+    } catch (Exception e) {\n+      logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n+    }\n+    logger.debug(\"Mail.sendMailWithAttachment() :: Ends\");\n+    return sentMail;\n+  }\n+\n+  // Constructs a Propterties either relying on IP Whitelist on the SMTP\n+  // service or on authentication with email and password.\n+  private Properties makeProperties(Boolean useIpWhitelist) {\n+    Properties props = new Properties();\n+    props.put(\"mail.smtp.host\", this.getSmtp_Hostname());\n+    props.put(\"mail.smtp.port\", this.getSmtp_portvalue());\n+    props.put(\"mail.smtp.socketFactory.class\", this.getSslFactory());\n+    props.put(\"mail.smtp.socketFactory.port\", this.getSmtp_portvalue());\n+    if (useIpWhitelist) {\n+      props.put(\"mail.smtp.auth\", \"false\");\n+      props.put(\"mail.smtp.ssl.enable\", \"true\");\n+      props.put(\"mail.smtp.localhost\", fromDomain);\n+    } else {\n+      props.put(\"mail.smtp.auth\", \"true\");\n+    }\n+    return props;\n+  }\n+\n+  private Session makeSession(Properties props) {\n+    return Session.getInstance(props, null);\n+  }\n+\n+  private Session makeSession(Properties props, String username, String password) {\n+    return Session.getInstance(\n+        props,\n+        new javax.mail.Authenticator() {\n+          @Override\n+          protected PasswordAuthentication getPasswordAuthentication() {\n+            return new PasswordAuthentication(username, password);\n+          }\n+        });\n+  }\n+\n+  public String getToemail() {\n+    return toemail;\n+  }\n+\n+  public void setToemail(String toemail) {\n+    this.toemail = toemail;\n+  }\n+\n+  public String getSubject() {\n+    return subject;\n+  }\n+\n+  public void setSubject(String subject) {\n+    this.subject = subject;\n+  }\n+\n+  public String getMessageBody() {\n+    return messageBody;\n+  }\n+\n+  public void setMessageBody(String messageBody) {\n+    this.messageBody = messageBody;\n+  }\n+\n+  public String getSmtp_Hostname() {\n+    if (this.smtp_Hostname.equals(\"\")) {\n+      if (useIpWhitelist) {\n+        return Mail.SMTP_RELAY_HOSTNAME;\n+      } else {\n+        return Mail.SMTP_HOSTNAME;\n+      }\n+    } else {\n+      return this.smtp_Hostname;\n+    }\n+  }\n+\n+  public void setSmtp_Hostname(String smtp_Hostname) {\n+    this.smtp_Hostname = smtp_Hostname;\n+  }\n+\n+  public String getSmtp_portvalue() {\n+    String portvalue = \"\";\n+    if (this.smtp_portvalue.equals(\"\")) {\n+      portvalue = Mail.SMTP_PORT;\n+    } else {\n+      portvalue = this.smtp_portvalue;\n+    }\n+\n+    return portvalue;\n+  }\n+\n+  public void setSmtp_portvalue(String smtp_portvalue) {", "originalCommit": "1275b0d755dc41d7df75133eab56d82eed9cb5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5NzczOA==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465497738", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nAbbreviation in name 'getSSL_FACTORY' must contain no more than '2' consecutive capital letters.", "author": "github-actions", "createdAt": "2020-08-05T06:18:17Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/util/Mail.java", "diffHunk": "@@ -23,308 +23,304 @@\n import javax.mail.internet.MimeBodyPart;\n import javax.mail.internet.MimeMessage;\n import javax.mail.internet.MimeMultipart;\n-\n import lombok.Setter;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n public class Mail {\n \n-    private static final Logger logger = LogManager.getLogger(Mail.class);\n-\n-    private String toemail;\n-    private String subject;\n-    private String messageBody;\n-    // Fallback hostname if we are authenticating.\n-    private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n-    // Fallback hostname if we are not authenticating.\n-    private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n-    private static final String SMTP_PORT = \"465\";\n-    private String smtp_Hostname = \"\";\n-    private String smtp_portvalue = \"\";\n-    static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n-    private String sslFactory = \"\";\n-    private String fromEmailAddress = \"\";\n-    private String fromEmailPass = \"\";\n-    private String fromEmailName = \"\";\n-    private String ccEmail;\n-    private String bccEmail;\n-    private String attachmentPath;\n-    // Domain that we send in the EHLO request if we are not authenticating\n-    // with the SMTP server.\n-    @Setter\n-    private String fromDomain = \"\";\n-    // If set to true, we will not authenticate with the SMTP service and\n-    // rather rely on the SMTP service's configured IP whitelist. If false we\n-    // will authenticate with the provided fromEmailAddress and fromEmailPass.\n-    @Setter\n-    private Boolean useIpWhitelist = false;\n-\n-    public boolean sendemail() throws Exception {\n-        logger.debug(\" sendemail() ==== starts\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            message.setFrom(new InternetAddress(username));\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setContent(this.getMessageBody(), \"text/html\");\n-            Transport transport = session.getTransport();\n-            transport.send(message);\n-            logger.debug(\"sendemail()==== ends\");\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"sendemail() MessagingException- error\", e);\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendemail() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    public boolean sendMailWithAttachment() throws Exception {\n-        logger.debug(\"sendMailWithAttachment()==== start\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setFrom(new InternetAddress(username));\n-            // message.setText(\"Check attachment in Mail\");\n-            // message.setContent(messageBody, \"text/html\");\n-            // Create the message part\n-            BodyPart messageBodyPart = new MimeBodyPart();\n-            // Create a multipar message\n-            Multipart multipart = new MimeMultipart();\n-            // Part two is attachment\n-            messageBodyPart = new MimeBodyPart();\n-            // String filename = \"D:\\\\temp\\\\TestLinks.pdf\"; // D:\\temp\\noteb.txt\n-            DataSource source = new FileDataSource(this.getAttachmentPath());\n-            messageBodyPart.setDataHandler(new DataHandler(source));\n-            messageBodyPart.setFileName(source.getName());\n-            messageBodyPart.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n-            messageBodyPart.setHeader(\"Content-Type\", source.getContentType());\n-            // Send the complete message parts\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            messageBodyPart = new MimeBodyPart();\n-            messageBodyPart.setText(messageBody);\n-            messageBodyPart.setHeader(\"MIME-Version\", \"1.0\");\n-            messageBodyPart.setHeader(\"Content-Type\", messageBodyPart.getContentType());\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            message.setContent(multipart);\n-            Transport.send(message);\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-            sentMail = false;\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendMailWithAttachment() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    // Constructs a Propterties either relying on IP Whitelist on the SMTP\n-    // service or on authentication with email and password.\n-    private Properties makeProperties(Boolean useIpWhitelist) {\n-        Properties props = new Properties();\n-        props.put(\"mail.smtp.host\", this.getSmtp_Hostname());\n-        props.put(\"mail.smtp.port\", this.getSmtp_portvalue());\n-        props.put(\"mail.smtp.socketFactory.class\", this.getSslFactory());\n-        props.put(\"mail.smtp.socketFactory.port\", this.getSmtp_portvalue());\n-        if (useIpWhitelist) {\n-            props.put(\"mail.smtp.auth\", \"false\");\n-            props.put(\"mail.smtp.ssl.enable\", \"true\");\n-            props.put(\"mail.smtp.localhost\", fromDomain);\n+  private static final Logger logger = LogManager.getLogger(Mail.class);\n+\n+  private String toemail;\n+  private String subject;\n+  private String messageBody;\n+  // Fallback hostname if we are authenticating.\n+  private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n+  // Fallback hostname if we are not authenticating.\n+  private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n+  private static final String SMTP_PORT = \"465\";\n+  private String smtp_Hostname = \"\";\n+  private String smtp_portvalue = \"\";\n+  static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n+  private String sslFactory = \"\";\n+  private String fromEmailAddress = \"\";\n+  private String fromEmailPass = \"\";\n+  private String fromEmailName = \"\";\n+  private String ccEmail;\n+  private String bccEmail;\n+  private String attachmentPath;\n+  // Domain that we send in the EHLO request if we are not authenticating\n+  // with the SMTP server.\n+  @Setter private String fromDomain = \"\";\n+  // If set to true, we will not authenticate with the SMTP service and\n+  // rather rely on the SMTP service's configured IP whitelist. If false we\n+  // will authenticate with the provided fromEmailAddress and fromEmailPass.\n+  @Setter private Boolean useIpWhitelist = false;\n+\n+  public boolean sendemail() throws Exception {\n+    logger.debug(\" sendemail() ==== starts\");\n+    boolean sentMail = false;\n+    try {\n+      final String username = this.getFromEmailAddress();\n+      final String password = this.getFromEmailPass();\n+      Properties props = makeProperties(useIpWhitelist);\n+      Session session =\n+          useIpWhitelist ? makeSession(props) : makeSession(props, username, password);\n+      Message message = new MimeMessage(session);\n+      message.setFrom(new InternetAddress(username));\n+      if (StringUtils.isNotBlank(this.getToemail())) {\n+        if (this.getToemail().indexOf(\",\") != -1) {\n+          message.setRecipients(\n+              Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n         } else {\n-            props.put(\"mail.smtp.auth\", \"true\");\n+          message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n         }\n-        return props;\n-    }\n-\n-    private Session makeSession(Properties props) {\n-        return Session.getInstance(props, null);\n-    }\n-\n-    private Session makeSession(Properties props, String username,\n-                                String password) {\n-        return Session.getInstance(\n-                props,\n-                new javax.mail.Authenticator() {\n-                    @Override\n-                    protected PasswordAuthentication getPasswordAuthentication() {\n-                        return new PasswordAuthentication(username, password);\n-                    }\n-                });\n-    }\n-\n-    public String getToemail() {\n-        return toemail;\n-    }\n-\n-    public void setToemail(String toemail) {\n-        this.toemail = toemail;\n-    }\n-\n-    public String getSubject() {\n-        return subject;\n-    }\n-\n-    public void setSubject(String subject) {\n-        this.subject = subject;\n-    }\n-\n-    public String getMessageBody() {\n-        return messageBody;\n-    }\n-\n-    public void setMessageBody(String messageBody) {\n-        this.messageBody = messageBody;\n-    }\n-\n-    public String getSmtp_Hostname() {\n-        if (this.smtp_Hostname.equals(\"\")) {\n-            if (useIpWhitelist) {\n-                return Mail.SMTP_RELAY_HOSTNAME;\n-            } else {\n-                return Mail.SMTP_HOSTNAME;\n-            }\n+      }\n+      if (StringUtils.isNotBlank(this.getCcEmail())) {\n+        message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n+      }\n+      if (StringUtils.isNotBlank(this.getBccEmail())) {\n+        message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n+      }\n+      message.setSubject(this.subject);\n+      message.setContent(this.getMessageBody(), \"text/html\");\n+      Transport transport = session.getTransport();\n+      transport.send(message);\n+      logger.debug(\"sendemail()==== ends\");\n+      sentMail = true;\n+    } catch (MessagingException e) {\n+      logger.error(\"sendemail() MessagingException- error\", e);\n+    } catch (Exception e) {\n+      logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n+    }\n+    logger.debug(\"Mail.sendemail() :: Ends\");\n+    return sentMail;\n+  }\n+\n+  public boolean sendMailWithAttachment() throws Exception {\n+    logger.debug(\"sendMailWithAttachment()==== start\");\n+    boolean sentMail = false;\n+    try {\n+      final String username = this.getFromEmailAddress();\n+      final String password = this.getFromEmailPass();\n+      Properties props = makeProperties(useIpWhitelist);\n+      Session session =\n+          useIpWhitelist ? makeSession(props) : makeSession(props, username, password);\n+      Message message = new MimeMessage(session);\n+      if (StringUtils.isNotBlank(this.getToemail())) {\n+        if (this.getToemail().indexOf(\",\") != -1) {\n+          message.setRecipients(\n+              Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n         } else {\n-            return this.smtp_Hostname;\n+          message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n         }\n-    }\n+      }\n+      if (StringUtils.isNotBlank(this.getCcEmail())) {\n+        message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n+      }\n+      if (StringUtils.isNotBlank(this.getBccEmail())) {\n+        message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n+      }\n+      message.setSubject(this.subject);\n+      message.setFrom(new InternetAddress(username));\n+      // message.setText(\"Check attachment in Mail\");\n+      // message.setContent(messageBody, \"text/html\");\n+      // Create the message part\n+      BodyPart messageBodyPart = new MimeBodyPart();\n+      // Create a multipar message\n+      Multipart multipart = new MimeMultipart();\n+      // Part two is attachment\n+      messageBodyPart = new MimeBodyPart();\n+      // String filename = \"D:\\\\temp\\\\TestLinks.pdf\"; // D:\\temp\\noteb.txt\n+      DataSource source = new FileDataSource(this.getAttachmentPath());\n+      messageBodyPart.setDataHandler(new DataHandler(source));\n+      messageBodyPart.setFileName(source.getName());\n+      messageBodyPart.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n+      messageBodyPart.setHeader(\"Content-Type\", source.getContentType());\n+      // Send the complete message parts\n+      multipart.addBodyPart(messageBodyPart);\n+\n+      messageBodyPart = new MimeBodyPart();\n+      messageBodyPart.setText(messageBody);\n+      messageBodyPart.setHeader(\"MIME-Version\", \"1.0\");\n+      messageBodyPart.setHeader(\"Content-Type\", messageBodyPart.getContentType());\n+      multipart.addBodyPart(messageBodyPart);\n+\n+      message.setContent(multipart);\n+      Transport.send(message);\n+      sentMail = true;\n+    } catch (MessagingException e) {\n+      logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n+      sentMail = false;\n+    } catch (Exception e) {\n+      logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n+    }\n+    logger.debug(\"Mail.sendMailWithAttachment() :: Ends\");\n+    return sentMail;\n+  }\n+\n+  // Constructs a Propterties either relying on IP Whitelist on the SMTP\n+  // service or on authentication with email and password.\n+  private Properties makeProperties(Boolean useIpWhitelist) {\n+    Properties props = new Properties();\n+    props.put(\"mail.smtp.host\", this.getSmtp_Hostname());\n+    props.put(\"mail.smtp.port\", this.getSmtp_portvalue());\n+    props.put(\"mail.smtp.socketFactory.class\", this.getSslFactory());\n+    props.put(\"mail.smtp.socketFactory.port\", this.getSmtp_portvalue());\n+    if (useIpWhitelist) {\n+      props.put(\"mail.smtp.auth\", \"false\");\n+      props.put(\"mail.smtp.ssl.enable\", \"true\");\n+      props.put(\"mail.smtp.localhost\", fromDomain);\n+    } else {\n+      props.put(\"mail.smtp.auth\", \"true\");\n+    }\n+    return props;\n+  }\n+\n+  private Session makeSession(Properties props) {\n+    return Session.getInstance(props, null);\n+  }\n+\n+  private Session makeSession(Properties props, String username, String password) {\n+    return Session.getInstance(\n+        props,\n+        new javax.mail.Authenticator() {\n+          @Override\n+          protected PasswordAuthentication getPasswordAuthentication() {\n+            return new PasswordAuthentication(username, password);\n+          }\n+        });\n+  }\n+\n+  public String getToemail() {\n+    return toemail;\n+  }\n+\n+  public void setToemail(String toemail) {\n+    this.toemail = toemail;\n+  }\n+\n+  public String getSubject() {\n+    return subject;\n+  }\n+\n+  public void setSubject(String subject) {\n+    this.subject = subject;\n+  }\n+\n+  public String getMessageBody() {\n+    return messageBody;\n+  }\n+\n+  public void setMessageBody(String messageBody) {\n+    this.messageBody = messageBody;\n+  }\n+\n+  public String getSmtp_Hostname() {\n+    if (this.smtp_Hostname.equals(\"\")) {\n+      if (useIpWhitelist) {\n+        return Mail.SMTP_RELAY_HOSTNAME;\n+      } else {\n+        return Mail.SMTP_HOSTNAME;\n+      }\n+    } else {\n+      return this.smtp_Hostname;\n+    }\n+  }\n+\n+  public void setSmtp_Hostname(String smtp_Hostname) {\n+    this.smtp_Hostname = smtp_Hostname;\n+  }\n+\n+  public String getSmtp_portvalue() {\n+    String portvalue = \"\";\n+    if (this.smtp_portvalue.equals(\"\")) {\n+      portvalue = Mail.SMTP_PORT;\n+    } else {\n+      portvalue = this.smtp_portvalue;\n+    }\n+\n+    return portvalue;\n+  }\n+\n+  public void setSmtp_portvalue(String smtp_portvalue) {\n+    this.smtp_portvalue = smtp_portvalue;\n+  }\n+\n+  public static String getSSL_FACTORY() {", "originalCommit": "1275b0d755dc41d7df75133eab56d82eed9cb5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5NzczOQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465497739", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nAbbreviation in name 'setSSL_FACTORY' must contain no more than '2' consecutive capital letters.", "author": "github-actions", "createdAt": "2020-08-05T06:18:18Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/util/Mail.java", "diffHunk": "@@ -23,308 +23,304 @@\n import javax.mail.internet.MimeBodyPart;\n import javax.mail.internet.MimeMessage;\n import javax.mail.internet.MimeMultipart;\n-\n import lombok.Setter;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n public class Mail {\n \n-    private static final Logger logger = LogManager.getLogger(Mail.class);\n-\n-    private String toemail;\n-    private String subject;\n-    private String messageBody;\n-    // Fallback hostname if we are authenticating.\n-    private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n-    // Fallback hostname if we are not authenticating.\n-    private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n-    private static final String SMTP_PORT = \"465\";\n-    private String smtp_Hostname = \"\";\n-    private String smtp_portvalue = \"\";\n-    static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n-    private String sslFactory = \"\";\n-    private String fromEmailAddress = \"\";\n-    private String fromEmailPass = \"\";\n-    private String fromEmailName = \"\";\n-    private String ccEmail;\n-    private String bccEmail;\n-    private String attachmentPath;\n-    // Domain that we send in the EHLO request if we are not authenticating\n-    // with the SMTP server.\n-    @Setter\n-    private String fromDomain = \"\";\n-    // If set to true, we will not authenticate with the SMTP service and\n-    // rather rely on the SMTP service's configured IP whitelist. If false we\n-    // will authenticate with the provided fromEmailAddress and fromEmailPass.\n-    @Setter\n-    private Boolean useIpWhitelist = false;\n-\n-    public boolean sendemail() throws Exception {\n-        logger.debug(\" sendemail() ==== starts\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            message.setFrom(new InternetAddress(username));\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setContent(this.getMessageBody(), \"text/html\");\n-            Transport transport = session.getTransport();\n-            transport.send(message);\n-            logger.debug(\"sendemail()==== ends\");\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"sendemail() MessagingException- error\", e);\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendemail() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    public boolean sendMailWithAttachment() throws Exception {\n-        logger.debug(\"sendMailWithAttachment()==== start\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setFrom(new InternetAddress(username));\n-            // message.setText(\"Check attachment in Mail\");\n-            // message.setContent(messageBody, \"text/html\");\n-            // Create the message part\n-            BodyPart messageBodyPart = new MimeBodyPart();\n-            // Create a multipar message\n-            Multipart multipart = new MimeMultipart();\n-            // Part two is attachment\n-            messageBodyPart = new MimeBodyPart();\n-            // String filename = \"D:\\\\temp\\\\TestLinks.pdf\"; // D:\\temp\\noteb.txt\n-            DataSource source = new FileDataSource(this.getAttachmentPath());\n-            messageBodyPart.setDataHandler(new DataHandler(source));\n-            messageBodyPart.setFileName(source.getName());\n-            messageBodyPart.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n-            messageBodyPart.setHeader(\"Content-Type\", source.getContentType());\n-            // Send the complete message parts\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            messageBodyPart = new MimeBodyPart();\n-            messageBodyPart.setText(messageBody);\n-            messageBodyPart.setHeader(\"MIME-Version\", \"1.0\");\n-            messageBodyPart.setHeader(\"Content-Type\", messageBodyPart.getContentType());\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            message.setContent(multipart);\n-            Transport.send(message);\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-            sentMail = false;\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendMailWithAttachment() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    // Constructs a Propterties either relying on IP Whitelist on the SMTP\n-    // service or on authentication with email and password.\n-    private Properties makeProperties(Boolean useIpWhitelist) {\n-        Properties props = new Properties();\n-        props.put(\"mail.smtp.host\", this.getSmtp_Hostname());\n-        props.put(\"mail.smtp.port\", this.getSmtp_portvalue());\n-        props.put(\"mail.smtp.socketFactory.class\", this.getSslFactory());\n-        props.put(\"mail.smtp.socketFactory.port\", this.getSmtp_portvalue());\n-        if (useIpWhitelist) {\n-            props.put(\"mail.smtp.auth\", \"false\");\n-            props.put(\"mail.smtp.ssl.enable\", \"true\");\n-            props.put(\"mail.smtp.localhost\", fromDomain);\n+  private static final Logger logger = LogManager.getLogger(Mail.class);\n+\n+  private String toemail;\n+  private String subject;\n+  private String messageBody;\n+  // Fallback hostname if we are authenticating.\n+  private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n+  // Fallback hostname if we are not authenticating.\n+  private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n+  private static final String SMTP_PORT = \"465\";\n+  private String smtp_Hostname = \"\";\n+  private String smtp_portvalue = \"\";\n+  static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n+  private String sslFactory = \"\";\n+  private String fromEmailAddress = \"\";\n+  private String fromEmailPass = \"\";\n+  private String fromEmailName = \"\";\n+  private String ccEmail;\n+  private String bccEmail;\n+  private String attachmentPath;\n+  // Domain that we send in the EHLO request if we are not authenticating\n+  // with the SMTP server.\n+  @Setter private String fromDomain = \"\";\n+  // If set to true, we will not authenticate with the SMTP service and\n+  // rather rely on the SMTP service's configured IP whitelist. If false we\n+  // will authenticate with the provided fromEmailAddress and fromEmailPass.\n+  @Setter private Boolean useIpWhitelist = false;\n+\n+  public boolean sendemail() throws Exception {\n+    logger.debug(\" sendemail() ==== starts\");\n+    boolean sentMail = false;\n+    try {\n+      final String username = this.getFromEmailAddress();\n+      final String password = this.getFromEmailPass();\n+      Properties props = makeProperties(useIpWhitelist);\n+      Session session =\n+          useIpWhitelist ? makeSession(props) : makeSession(props, username, password);\n+      Message message = new MimeMessage(session);\n+      message.setFrom(new InternetAddress(username));\n+      if (StringUtils.isNotBlank(this.getToemail())) {\n+        if (this.getToemail().indexOf(\",\") != -1) {\n+          message.setRecipients(\n+              Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n         } else {\n-            props.put(\"mail.smtp.auth\", \"true\");\n+          message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n         }\n-        return props;\n-    }\n-\n-    private Session makeSession(Properties props) {\n-        return Session.getInstance(props, null);\n-    }\n-\n-    private Session makeSession(Properties props, String username,\n-                                String password) {\n-        return Session.getInstance(\n-                props,\n-                new javax.mail.Authenticator() {\n-                    @Override\n-                    protected PasswordAuthentication getPasswordAuthentication() {\n-                        return new PasswordAuthentication(username, password);\n-                    }\n-                });\n-    }\n-\n-    public String getToemail() {\n-        return toemail;\n-    }\n-\n-    public void setToemail(String toemail) {\n-        this.toemail = toemail;\n-    }\n-\n-    public String getSubject() {\n-        return subject;\n-    }\n-\n-    public void setSubject(String subject) {\n-        this.subject = subject;\n-    }\n-\n-    public String getMessageBody() {\n-        return messageBody;\n-    }\n-\n-    public void setMessageBody(String messageBody) {\n-        this.messageBody = messageBody;\n-    }\n-\n-    public String getSmtp_Hostname() {\n-        if (this.smtp_Hostname.equals(\"\")) {\n-            if (useIpWhitelist) {\n-                return Mail.SMTP_RELAY_HOSTNAME;\n-            } else {\n-                return Mail.SMTP_HOSTNAME;\n-            }\n+      }\n+      if (StringUtils.isNotBlank(this.getCcEmail())) {\n+        message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n+      }\n+      if (StringUtils.isNotBlank(this.getBccEmail())) {\n+        message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n+      }\n+      message.setSubject(this.subject);\n+      message.setContent(this.getMessageBody(), \"text/html\");\n+      Transport transport = session.getTransport();\n+      transport.send(message);\n+      logger.debug(\"sendemail()==== ends\");\n+      sentMail = true;\n+    } catch (MessagingException e) {\n+      logger.error(\"sendemail() MessagingException- error\", e);\n+    } catch (Exception e) {\n+      logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n+    }\n+    logger.debug(\"Mail.sendemail() :: Ends\");\n+    return sentMail;\n+  }\n+\n+  public boolean sendMailWithAttachment() throws Exception {\n+    logger.debug(\"sendMailWithAttachment()==== start\");\n+    boolean sentMail = false;\n+    try {\n+      final String username = this.getFromEmailAddress();\n+      final String password = this.getFromEmailPass();\n+      Properties props = makeProperties(useIpWhitelist);\n+      Session session =\n+          useIpWhitelist ? makeSession(props) : makeSession(props, username, password);\n+      Message message = new MimeMessage(session);\n+      if (StringUtils.isNotBlank(this.getToemail())) {\n+        if (this.getToemail().indexOf(\",\") != -1) {\n+          message.setRecipients(\n+              Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n         } else {\n-            return this.smtp_Hostname;\n+          message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n         }\n-    }\n+      }\n+      if (StringUtils.isNotBlank(this.getCcEmail())) {\n+        message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n+      }\n+      if (StringUtils.isNotBlank(this.getBccEmail())) {\n+        message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n+      }\n+      message.setSubject(this.subject);\n+      message.setFrom(new InternetAddress(username));\n+      // message.setText(\"Check attachment in Mail\");\n+      // message.setContent(messageBody, \"text/html\");\n+      // Create the message part\n+      BodyPart messageBodyPart = new MimeBodyPart();\n+      // Create a multipar message\n+      Multipart multipart = new MimeMultipart();\n+      // Part two is attachment\n+      messageBodyPart = new MimeBodyPart();\n+      // String filename = \"D:\\\\temp\\\\TestLinks.pdf\"; // D:\\temp\\noteb.txt\n+      DataSource source = new FileDataSource(this.getAttachmentPath());\n+      messageBodyPart.setDataHandler(new DataHandler(source));\n+      messageBodyPart.setFileName(source.getName());\n+      messageBodyPart.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n+      messageBodyPart.setHeader(\"Content-Type\", source.getContentType());\n+      // Send the complete message parts\n+      multipart.addBodyPart(messageBodyPart);\n+\n+      messageBodyPart = new MimeBodyPart();\n+      messageBodyPart.setText(messageBody);\n+      messageBodyPart.setHeader(\"MIME-Version\", \"1.0\");\n+      messageBodyPart.setHeader(\"Content-Type\", messageBodyPart.getContentType());\n+      multipart.addBodyPart(messageBodyPart);\n+\n+      message.setContent(multipart);\n+      Transport.send(message);\n+      sentMail = true;\n+    } catch (MessagingException e) {\n+      logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n+      sentMail = false;\n+    } catch (Exception e) {\n+      logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n+    }\n+    logger.debug(\"Mail.sendMailWithAttachment() :: Ends\");\n+    return sentMail;\n+  }\n+\n+  // Constructs a Propterties either relying on IP Whitelist on the SMTP\n+  // service or on authentication with email and password.\n+  private Properties makeProperties(Boolean useIpWhitelist) {\n+    Properties props = new Properties();\n+    props.put(\"mail.smtp.host\", this.getSmtp_Hostname());\n+    props.put(\"mail.smtp.port\", this.getSmtp_portvalue());\n+    props.put(\"mail.smtp.socketFactory.class\", this.getSslFactory());\n+    props.put(\"mail.smtp.socketFactory.port\", this.getSmtp_portvalue());\n+    if (useIpWhitelist) {\n+      props.put(\"mail.smtp.auth\", \"false\");\n+      props.put(\"mail.smtp.ssl.enable\", \"true\");\n+      props.put(\"mail.smtp.localhost\", fromDomain);\n+    } else {\n+      props.put(\"mail.smtp.auth\", \"true\");\n+    }\n+    return props;\n+  }\n+\n+  private Session makeSession(Properties props) {\n+    return Session.getInstance(props, null);\n+  }\n+\n+  private Session makeSession(Properties props, String username, String password) {\n+    return Session.getInstance(\n+        props,\n+        new javax.mail.Authenticator() {\n+          @Override\n+          protected PasswordAuthentication getPasswordAuthentication() {\n+            return new PasswordAuthentication(username, password);\n+          }\n+        });\n+  }\n+\n+  public String getToemail() {\n+    return toemail;\n+  }\n+\n+  public void setToemail(String toemail) {\n+    this.toemail = toemail;\n+  }\n+\n+  public String getSubject() {\n+    return subject;\n+  }\n+\n+  public void setSubject(String subject) {\n+    this.subject = subject;\n+  }\n+\n+  public String getMessageBody() {\n+    return messageBody;\n+  }\n+\n+  public void setMessageBody(String messageBody) {\n+    this.messageBody = messageBody;\n+  }\n+\n+  public String getSmtp_Hostname() {\n+    if (this.smtp_Hostname.equals(\"\")) {\n+      if (useIpWhitelist) {\n+        return Mail.SMTP_RELAY_HOSTNAME;\n+      } else {\n+        return Mail.SMTP_HOSTNAME;\n+      }\n+    } else {\n+      return this.smtp_Hostname;\n+    }\n+  }\n+\n+  public void setSmtp_Hostname(String smtp_Hostname) {\n+    this.smtp_Hostname = smtp_Hostname;\n+  }\n+\n+  public String getSmtp_portvalue() {\n+    String portvalue = \"\";\n+    if (this.smtp_portvalue.equals(\"\")) {\n+      portvalue = Mail.SMTP_PORT;\n+    } else {\n+      portvalue = this.smtp_portvalue;\n+    }\n+\n+    return portvalue;\n+  }\n+\n+  public void setSmtp_portvalue(String smtp_portvalue) {\n+    this.smtp_portvalue = smtp_portvalue;\n+  }\n+\n+  public static String getSSL_FACTORY() {\n+    return SSL_FACTORY;\n+  }\n+\n+  public static void setSSL_FACTORY(String sSL_FACTORY) {", "originalCommit": "1275b0d755dc41d7df75133eab56d82eed9cb5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5Nzc0MA==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465497740", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nAbbreviation in name 'sSL_FACTORY' must contain no more than '2' consecutive capital letters.", "author": "github-actions", "createdAt": "2020-08-05T06:18:18Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/util/Mail.java", "diffHunk": "@@ -23,308 +23,304 @@\n import javax.mail.internet.MimeBodyPart;\n import javax.mail.internet.MimeMessage;\n import javax.mail.internet.MimeMultipart;\n-\n import lombok.Setter;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n public class Mail {\n \n-    private static final Logger logger = LogManager.getLogger(Mail.class);\n-\n-    private String toemail;\n-    private String subject;\n-    private String messageBody;\n-    // Fallback hostname if we are authenticating.\n-    private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n-    // Fallback hostname if we are not authenticating.\n-    private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n-    private static final String SMTP_PORT = \"465\";\n-    private String smtp_Hostname = \"\";\n-    private String smtp_portvalue = \"\";\n-    static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n-    private String sslFactory = \"\";\n-    private String fromEmailAddress = \"\";\n-    private String fromEmailPass = \"\";\n-    private String fromEmailName = \"\";\n-    private String ccEmail;\n-    private String bccEmail;\n-    private String attachmentPath;\n-    // Domain that we send in the EHLO request if we are not authenticating\n-    // with the SMTP server.\n-    @Setter\n-    private String fromDomain = \"\";\n-    // If set to true, we will not authenticate with the SMTP service and\n-    // rather rely on the SMTP service's configured IP whitelist. If false we\n-    // will authenticate with the provided fromEmailAddress and fromEmailPass.\n-    @Setter\n-    private Boolean useIpWhitelist = false;\n-\n-    public boolean sendemail() throws Exception {\n-        logger.debug(\" sendemail() ==== starts\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            message.setFrom(new InternetAddress(username));\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setContent(this.getMessageBody(), \"text/html\");\n-            Transport transport = session.getTransport();\n-            transport.send(message);\n-            logger.debug(\"sendemail()==== ends\");\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"sendemail() MessagingException- error\", e);\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendemail() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    public boolean sendMailWithAttachment() throws Exception {\n-        logger.debug(\"sendMailWithAttachment()==== start\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setFrom(new InternetAddress(username));\n-            // message.setText(\"Check attachment in Mail\");\n-            // message.setContent(messageBody, \"text/html\");\n-            // Create the message part\n-            BodyPart messageBodyPart = new MimeBodyPart();\n-            // Create a multipar message\n-            Multipart multipart = new MimeMultipart();\n-            // Part two is attachment\n-            messageBodyPart = new MimeBodyPart();\n-            // String filename = \"D:\\\\temp\\\\TestLinks.pdf\"; // D:\\temp\\noteb.txt\n-            DataSource source = new FileDataSource(this.getAttachmentPath());\n-            messageBodyPart.setDataHandler(new DataHandler(source));\n-            messageBodyPart.setFileName(source.getName());\n-            messageBodyPart.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n-            messageBodyPart.setHeader(\"Content-Type\", source.getContentType());\n-            // Send the complete message parts\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            messageBodyPart = new MimeBodyPart();\n-            messageBodyPart.setText(messageBody);\n-            messageBodyPart.setHeader(\"MIME-Version\", \"1.0\");\n-            messageBodyPart.setHeader(\"Content-Type\", messageBodyPart.getContentType());\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            message.setContent(multipart);\n-            Transport.send(message);\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-            sentMail = false;\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendMailWithAttachment() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    // Constructs a Propterties either relying on IP Whitelist on the SMTP\n-    // service or on authentication with email and password.\n-    private Properties makeProperties(Boolean useIpWhitelist) {\n-        Properties props = new Properties();\n-        props.put(\"mail.smtp.host\", this.getSmtp_Hostname());\n-        props.put(\"mail.smtp.port\", this.getSmtp_portvalue());\n-        props.put(\"mail.smtp.socketFactory.class\", this.getSslFactory());\n-        props.put(\"mail.smtp.socketFactory.port\", this.getSmtp_portvalue());\n-        if (useIpWhitelist) {\n-            props.put(\"mail.smtp.auth\", \"false\");\n-            props.put(\"mail.smtp.ssl.enable\", \"true\");\n-            props.put(\"mail.smtp.localhost\", fromDomain);\n+  private static final Logger logger = LogManager.getLogger(Mail.class);\n+\n+  private String toemail;\n+  private String subject;\n+  private String messageBody;\n+  // Fallback hostname if we are authenticating.\n+  private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n+  // Fallback hostname if we are not authenticating.\n+  private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n+  private static final String SMTP_PORT = \"465\";\n+  private String smtp_Hostname = \"\";\n+  private String smtp_portvalue = \"\";\n+  static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n+  private String sslFactory = \"\";\n+  private String fromEmailAddress = \"\";\n+  private String fromEmailPass = \"\";\n+  private String fromEmailName = \"\";\n+  private String ccEmail;\n+  private String bccEmail;\n+  private String attachmentPath;\n+  // Domain that we send in the EHLO request if we are not authenticating\n+  // with the SMTP server.\n+  @Setter private String fromDomain = \"\";\n+  // If set to true, we will not authenticate with the SMTP service and\n+  // rather rely on the SMTP service's configured IP whitelist. If false we\n+  // will authenticate with the provided fromEmailAddress and fromEmailPass.\n+  @Setter private Boolean useIpWhitelist = false;\n+\n+  public boolean sendemail() throws Exception {\n+    logger.debug(\" sendemail() ==== starts\");\n+    boolean sentMail = false;\n+    try {\n+      final String username = this.getFromEmailAddress();\n+      final String password = this.getFromEmailPass();\n+      Properties props = makeProperties(useIpWhitelist);\n+      Session session =\n+          useIpWhitelist ? makeSession(props) : makeSession(props, username, password);\n+      Message message = new MimeMessage(session);\n+      message.setFrom(new InternetAddress(username));\n+      if (StringUtils.isNotBlank(this.getToemail())) {\n+        if (this.getToemail().indexOf(\",\") != -1) {\n+          message.setRecipients(\n+              Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n         } else {\n-            props.put(\"mail.smtp.auth\", \"true\");\n+          message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n         }\n-        return props;\n-    }\n-\n-    private Session makeSession(Properties props) {\n-        return Session.getInstance(props, null);\n-    }\n-\n-    private Session makeSession(Properties props, String username,\n-                                String password) {\n-        return Session.getInstance(\n-                props,\n-                new javax.mail.Authenticator() {\n-                    @Override\n-                    protected PasswordAuthentication getPasswordAuthentication() {\n-                        return new PasswordAuthentication(username, password);\n-                    }\n-                });\n-    }\n-\n-    public String getToemail() {\n-        return toemail;\n-    }\n-\n-    public void setToemail(String toemail) {\n-        this.toemail = toemail;\n-    }\n-\n-    public String getSubject() {\n-        return subject;\n-    }\n-\n-    public void setSubject(String subject) {\n-        this.subject = subject;\n-    }\n-\n-    public String getMessageBody() {\n-        return messageBody;\n-    }\n-\n-    public void setMessageBody(String messageBody) {\n-        this.messageBody = messageBody;\n-    }\n-\n-    public String getSmtp_Hostname() {\n-        if (this.smtp_Hostname.equals(\"\")) {\n-            if (useIpWhitelist) {\n-                return Mail.SMTP_RELAY_HOSTNAME;\n-            } else {\n-                return Mail.SMTP_HOSTNAME;\n-            }\n+      }\n+      if (StringUtils.isNotBlank(this.getCcEmail())) {\n+        message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n+      }\n+      if (StringUtils.isNotBlank(this.getBccEmail())) {\n+        message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n+      }\n+      message.setSubject(this.subject);\n+      message.setContent(this.getMessageBody(), \"text/html\");\n+      Transport transport = session.getTransport();\n+      transport.send(message);\n+      logger.debug(\"sendemail()==== ends\");\n+      sentMail = true;\n+    } catch (MessagingException e) {\n+      logger.error(\"sendemail() MessagingException- error\", e);\n+    } catch (Exception e) {\n+      logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n+    }\n+    logger.debug(\"Mail.sendemail() :: Ends\");\n+    return sentMail;\n+  }\n+\n+  public boolean sendMailWithAttachment() throws Exception {\n+    logger.debug(\"sendMailWithAttachment()==== start\");\n+    boolean sentMail = false;\n+    try {\n+      final String username = this.getFromEmailAddress();\n+      final String password = this.getFromEmailPass();\n+      Properties props = makeProperties(useIpWhitelist);\n+      Session session =\n+          useIpWhitelist ? makeSession(props) : makeSession(props, username, password);\n+      Message message = new MimeMessage(session);\n+      if (StringUtils.isNotBlank(this.getToemail())) {\n+        if (this.getToemail().indexOf(\",\") != -1) {\n+          message.setRecipients(\n+              Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n         } else {\n-            return this.smtp_Hostname;\n+          message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n         }\n-    }\n+      }\n+      if (StringUtils.isNotBlank(this.getCcEmail())) {\n+        message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n+      }\n+      if (StringUtils.isNotBlank(this.getBccEmail())) {\n+        message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n+      }\n+      message.setSubject(this.subject);\n+      message.setFrom(new InternetAddress(username));\n+      // message.setText(\"Check attachment in Mail\");\n+      // message.setContent(messageBody, \"text/html\");\n+      // Create the message part\n+      BodyPart messageBodyPart = new MimeBodyPart();\n+      // Create a multipar message\n+      Multipart multipart = new MimeMultipart();\n+      // Part two is attachment\n+      messageBodyPart = new MimeBodyPart();\n+      // String filename = \"D:\\\\temp\\\\TestLinks.pdf\"; // D:\\temp\\noteb.txt\n+      DataSource source = new FileDataSource(this.getAttachmentPath());\n+      messageBodyPart.setDataHandler(new DataHandler(source));\n+      messageBodyPart.setFileName(source.getName());\n+      messageBodyPart.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n+      messageBodyPart.setHeader(\"Content-Type\", source.getContentType());\n+      // Send the complete message parts\n+      multipart.addBodyPart(messageBodyPart);\n+\n+      messageBodyPart = new MimeBodyPart();\n+      messageBodyPart.setText(messageBody);\n+      messageBodyPart.setHeader(\"MIME-Version\", \"1.0\");\n+      messageBodyPart.setHeader(\"Content-Type\", messageBodyPart.getContentType());\n+      multipart.addBodyPart(messageBodyPart);\n+\n+      message.setContent(multipart);\n+      Transport.send(message);\n+      sentMail = true;\n+    } catch (MessagingException e) {\n+      logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n+      sentMail = false;\n+    } catch (Exception e) {\n+      logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n+    }\n+    logger.debug(\"Mail.sendMailWithAttachment() :: Ends\");\n+    return sentMail;\n+  }\n+\n+  // Constructs a Propterties either relying on IP Whitelist on the SMTP\n+  // service or on authentication with email and password.\n+  private Properties makeProperties(Boolean useIpWhitelist) {\n+    Properties props = new Properties();\n+    props.put(\"mail.smtp.host\", this.getSmtp_Hostname());\n+    props.put(\"mail.smtp.port\", this.getSmtp_portvalue());\n+    props.put(\"mail.smtp.socketFactory.class\", this.getSslFactory());\n+    props.put(\"mail.smtp.socketFactory.port\", this.getSmtp_portvalue());\n+    if (useIpWhitelist) {\n+      props.put(\"mail.smtp.auth\", \"false\");\n+      props.put(\"mail.smtp.ssl.enable\", \"true\");\n+      props.put(\"mail.smtp.localhost\", fromDomain);\n+    } else {\n+      props.put(\"mail.smtp.auth\", \"true\");\n+    }\n+    return props;\n+  }\n+\n+  private Session makeSession(Properties props) {\n+    return Session.getInstance(props, null);\n+  }\n+\n+  private Session makeSession(Properties props, String username, String password) {\n+    return Session.getInstance(\n+        props,\n+        new javax.mail.Authenticator() {\n+          @Override\n+          protected PasswordAuthentication getPasswordAuthentication() {\n+            return new PasswordAuthentication(username, password);\n+          }\n+        });\n+  }\n+\n+  public String getToemail() {\n+    return toemail;\n+  }\n+\n+  public void setToemail(String toemail) {\n+    this.toemail = toemail;\n+  }\n+\n+  public String getSubject() {\n+    return subject;\n+  }\n+\n+  public void setSubject(String subject) {\n+    this.subject = subject;\n+  }\n+\n+  public String getMessageBody() {\n+    return messageBody;\n+  }\n+\n+  public void setMessageBody(String messageBody) {\n+    this.messageBody = messageBody;\n+  }\n+\n+  public String getSmtp_Hostname() {\n+    if (this.smtp_Hostname.equals(\"\")) {\n+      if (useIpWhitelist) {\n+        return Mail.SMTP_RELAY_HOSTNAME;\n+      } else {\n+        return Mail.SMTP_HOSTNAME;\n+      }\n+    } else {\n+      return this.smtp_Hostname;\n+    }\n+  }\n+\n+  public void setSmtp_Hostname(String smtp_Hostname) {\n+    this.smtp_Hostname = smtp_Hostname;\n+  }\n+\n+  public String getSmtp_portvalue() {\n+    String portvalue = \"\";\n+    if (this.smtp_portvalue.equals(\"\")) {\n+      portvalue = Mail.SMTP_PORT;\n+    } else {\n+      portvalue = this.smtp_portvalue;\n+    }\n+\n+    return portvalue;\n+  }\n+\n+  public void setSmtp_portvalue(String smtp_portvalue) {\n+    this.smtp_portvalue = smtp_portvalue;\n+  }\n+\n+  public static String getSSL_FACTORY() {\n+    return SSL_FACTORY;\n+  }\n+\n+  public static void setSSL_FACTORY(String sSL_FACTORY) {", "originalCommit": "1275b0d755dc41d7df75133eab56d82eed9cb5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5Nzc0Mw==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465497743", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nParameter name 'sSL_FACTORY' must match pattern '^a-z?$'.", "author": "github-actions", "createdAt": "2020-08-05T06:18:18Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/util/Mail.java", "diffHunk": "@@ -23,308 +23,304 @@\n import javax.mail.internet.MimeBodyPart;\n import javax.mail.internet.MimeMessage;\n import javax.mail.internet.MimeMultipart;\n-\n import lombok.Setter;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n public class Mail {\n \n-    private static final Logger logger = LogManager.getLogger(Mail.class);\n-\n-    private String toemail;\n-    private String subject;\n-    private String messageBody;\n-    // Fallback hostname if we are authenticating.\n-    private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n-    // Fallback hostname if we are not authenticating.\n-    private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n-    private static final String SMTP_PORT = \"465\";\n-    private String smtp_Hostname = \"\";\n-    private String smtp_portvalue = \"\";\n-    static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n-    private String sslFactory = \"\";\n-    private String fromEmailAddress = \"\";\n-    private String fromEmailPass = \"\";\n-    private String fromEmailName = \"\";\n-    private String ccEmail;\n-    private String bccEmail;\n-    private String attachmentPath;\n-    // Domain that we send in the EHLO request if we are not authenticating\n-    // with the SMTP server.\n-    @Setter\n-    private String fromDomain = \"\";\n-    // If set to true, we will not authenticate with the SMTP service and\n-    // rather rely on the SMTP service's configured IP whitelist. If false we\n-    // will authenticate with the provided fromEmailAddress and fromEmailPass.\n-    @Setter\n-    private Boolean useIpWhitelist = false;\n-\n-    public boolean sendemail() throws Exception {\n-        logger.debug(\" sendemail() ==== starts\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            message.setFrom(new InternetAddress(username));\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setContent(this.getMessageBody(), \"text/html\");\n-            Transport transport = session.getTransport();\n-            transport.send(message);\n-            logger.debug(\"sendemail()==== ends\");\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"sendemail() MessagingException- error\", e);\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendemail() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    public boolean sendMailWithAttachment() throws Exception {\n-        logger.debug(\"sendMailWithAttachment()==== start\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setFrom(new InternetAddress(username));\n-            // message.setText(\"Check attachment in Mail\");\n-            // message.setContent(messageBody, \"text/html\");\n-            // Create the message part\n-            BodyPart messageBodyPart = new MimeBodyPart();\n-            // Create a multipar message\n-            Multipart multipart = new MimeMultipart();\n-            // Part two is attachment\n-            messageBodyPart = new MimeBodyPart();\n-            // String filename = \"D:\\\\temp\\\\TestLinks.pdf\"; // D:\\temp\\noteb.txt\n-            DataSource source = new FileDataSource(this.getAttachmentPath());\n-            messageBodyPart.setDataHandler(new DataHandler(source));\n-            messageBodyPart.setFileName(source.getName());\n-            messageBodyPart.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n-            messageBodyPart.setHeader(\"Content-Type\", source.getContentType());\n-            // Send the complete message parts\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            messageBodyPart = new MimeBodyPart();\n-            messageBodyPart.setText(messageBody);\n-            messageBodyPart.setHeader(\"MIME-Version\", \"1.0\");\n-            messageBodyPart.setHeader(\"Content-Type\", messageBodyPart.getContentType());\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            message.setContent(multipart);\n-            Transport.send(message);\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-            sentMail = false;\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendMailWithAttachment() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    // Constructs a Propterties either relying on IP Whitelist on the SMTP\n-    // service or on authentication with email and password.\n-    private Properties makeProperties(Boolean useIpWhitelist) {\n-        Properties props = new Properties();\n-        props.put(\"mail.smtp.host\", this.getSmtp_Hostname());\n-        props.put(\"mail.smtp.port\", this.getSmtp_portvalue());\n-        props.put(\"mail.smtp.socketFactory.class\", this.getSslFactory());\n-        props.put(\"mail.smtp.socketFactory.port\", this.getSmtp_portvalue());\n-        if (useIpWhitelist) {\n-            props.put(\"mail.smtp.auth\", \"false\");\n-            props.put(\"mail.smtp.ssl.enable\", \"true\");\n-            props.put(\"mail.smtp.localhost\", fromDomain);\n+  private static final Logger logger = LogManager.getLogger(Mail.class);\n+\n+  private String toemail;\n+  private String subject;\n+  private String messageBody;\n+  // Fallback hostname if we are authenticating.\n+  private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n+  // Fallback hostname if we are not authenticating.\n+  private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n+  private static final String SMTP_PORT = \"465\";\n+  private String smtp_Hostname = \"\";\n+  private String smtp_portvalue = \"\";\n+  static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n+  private String sslFactory = \"\";\n+  private String fromEmailAddress = \"\";\n+  private String fromEmailPass = \"\";\n+  private String fromEmailName = \"\";\n+  private String ccEmail;\n+  private String bccEmail;\n+  private String attachmentPath;\n+  // Domain that we send in the EHLO request if we are not authenticating\n+  // with the SMTP server.\n+  @Setter private String fromDomain = \"\";\n+  // If set to true, we will not authenticate with the SMTP service and\n+  // rather rely on the SMTP service's configured IP whitelist. If false we\n+  // will authenticate with the provided fromEmailAddress and fromEmailPass.\n+  @Setter private Boolean useIpWhitelist = false;\n+\n+  public boolean sendemail() throws Exception {\n+    logger.debug(\" sendemail() ==== starts\");\n+    boolean sentMail = false;\n+    try {\n+      final String username = this.getFromEmailAddress();\n+      final String password = this.getFromEmailPass();\n+      Properties props = makeProperties(useIpWhitelist);\n+      Session session =\n+          useIpWhitelist ? makeSession(props) : makeSession(props, username, password);\n+      Message message = new MimeMessage(session);\n+      message.setFrom(new InternetAddress(username));\n+      if (StringUtils.isNotBlank(this.getToemail())) {\n+        if (this.getToemail().indexOf(\",\") != -1) {\n+          message.setRecipients(\n+              Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n         } else {\n-            props.put(\"mail.smtp.auth\", \"true\");\n+          message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n         }\n-        return props;\n-    }\n-\n-    private Session makeSession(Properties props) {\n-        return Session.getInstance(props, null);\n-    }\n-\n-    private Session makeSession(Properties props, String username,\n-                                String password) {\n-        return Session.getInstance(\n-                props,\n-                new javax.mail.Authenticator() {\n-                    @Override\n-                    protected PasswordAuthentication getPasswordAuthentication() {\n-                        return new PasswordAuthentication(username, password);\n-                    }\n-                });\n-    }\n-\n-    public String getToemail() {\n-        return toemail;\n-    }\n-\n-    public void setToemail(String toemail) {\n-        this.toemail = toemail;\n-    }\n-\n-    public String getSubject() {\n-        return subject;\n-    }\n-\n-    public void setSubject(String subject) {\n-        this.subject = subject;\n-    }\n-\n-    public String getMessageBody() {\n-        return messageBody;\n-    }\n-\n-    public void setMessageBody(String messageBody) {\n-        this.messageBody = messageBody;\n-    }\n-\n-    public String getSmtp_Hostname() {\n-        if (this.smtp_Hostname.equals(\"\")) {\n-            if (useIpWhitelist) {\n-                return Mail.SMTP_RELAY_HOSTNAME;\n-            } else {\n-                return Mail.SMTP_HOSTNAME;\n-            }\n+      }\n+      if (StringUtils.isNotBlank(this.getCcEmail())) {\n+        message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n+      }\n+      if (StringUtils.isNotBlank(this.getBccEmail())) {\n+        message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n+      }\n+      message.setSubject(this.subject);\n+      message.setContent(this.getMessageBody(), \"text/html\");\n+      Transport transport = session.getTransport();\n+      transport.send(message);\n+      logger.debug(\"sendemail()==== ends\");\n+      sentMail = true;\n+    } catch (MessagingException e) {\n+      logger.error(\"sendemail() MessagingException- error\", e);\n+    } catch (Exception e) {\n+      logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n+    }\n+    logger.debug(\"Mail.sendemail() :: Ends\");\n+    return sentMail;\n+  }\n+\n+  public boolean sendMailWithAttachment() throws Exception {\n+    logger.debug(\"sendMailWithAttachment()==== start\");\n+    boolean sentMail = false;\n+    try {\n+      final String username = this.getFromEmailAddress();\n+      final String password = this.getFromEmailPass();\n+      Properties props = makeProperties(useIpWhitelist);\n+      Session session =\n+          useIpWhitelist ? makeSession(props) : makeSession(props, username, password);\n+      Message message = new MimeMessage(session);\n+      if (StringUtils.isNotBlank(this.getToemail())) {\n+        if (this.getToemail().indexOf(\",\") != -1) {\n+          message.setRecipients(\n+              Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n         } else {\n-            return this.smtp_Hostname;\n+          message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n         }\n-    }\n+      }\n+      if (StringUtils.isNotBlank(this.getCcEmail())) {\n+        message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n+      }\n+      if (StringUtils.isNotBlank(this.getBccEmail())) {\n+        message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n+      }\n+      message.setSubject(this.subject);\n+      message.setFrom(new InternetAddress(username));\n+      // message.setText(\"Check attachment in Mail\");\n+      // message.setContent(messageBody, \"text/html\");\n+      // Create the message part\n+      BodyPart messageBodyPart = new MimeBodyPart();\n+      // Create a multipar message\n+      Multipart multipart = new MimeMultipart();\n+      // Part two is attachment\n+      messageBodyPart = new MimeBodyPart();\n+      // String filename = \"D:\\\\temp\\\\TestLinks.pdf\"; // D:\\temp\\noteb.txt\n+      DataSource source = new FileDataSource(this.getAttachmentPath());\n+      messageBodyPart.setDataHandler(new DataHandler(source));\n+      messageBodyPart.setFileName(source.getName());\n+      messageBodyPart.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n+      messageBodyPart.setHeader(\"Content-Type\", source.getContentType());\n+      // Send the complete message parts\n+      multipart.addBodyPart(messageBodyPart);\n+\n+      messageBodyPart = new MimeBodyPart();\n+      messageBodyPart.setText(messageBody);\n+      messageBodyPart.setHeader(\"MIME-Version\", \"1.0\");\n+      messageBodyPart.setHeader(\"Content-Type\", messageBodyPart.getContentType());\n+      multipart.addBodyPart(messageBodyPart);\n+\n+      message.setContent(multipart);\n+      Transport.send(message);\n+      sentMail = true;\n+    } catch (MessagingException e) {\n+      logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n+      sentMail = false;\n+    } catch (Exception e) {\n+      logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n+    }\n+    logger.debug(\"Mail.sendMailWithAttachment() :: Ends\");\n+    return sentMail;\n+  }\n+\n+  // Constructs a Propterties either relying on IP Whitelist on the SMTP\n+  // service or on authentication with email and password.\n+  private Properties makeProperties(Boolean useIpWhitelist) {\n+    Properties props = new Properties();\n+    props.put(\"mail.smtp.host\", this.getSmtp_Hostname());\n+    props.put(\"mail.smtp.port\", this.getSmtp_portvalue());\n+    props.put(\"mail.smtp.socketFactory.class\", this.getSslFactory());\n+    props.put(\"mail.smtp.socketFactory.port\", this.getSmtp_portvalue());\n+    if (useIpWhitelist) {\n+      props.put(\"mail.smtp.auth\", \"false\");\n+      props.put(\"mail.smtp.ssl.enable\", \"true\");\n+      props.put(\"mail.smtp.localhost\", fromDomain);\n+    } else {\n+      props.put(\"mail.smtp.auth\", \"true\");\n+    }\n+    return props;\n+  }\n+\n+  private Session makeSession(Properties props) {\n+    return Session.getInstance(props, null);\n+  }\n+\n+  private Session makeSession(Properties props, String username, String password) {\n+    return Session.getInstance(\n+        props,\n+        new javax.mail.Authenticator() {\n+          @Override\n+          protected PasswordAuthentication getPasswordAuthentication() {\n+            return new PasswordAuthentication(username, password);\n+          }\n+        });\n+  }\n+\n+  public String getToemail() {\n+    return toemail;\n+  }\n+\n+  public void setToemail(String toemail) {\n+    this.toemail = toemail;\n+  }\n+\n+  public String getSubject() {\n+    return subject;\n+  }\n+\n+  public void setSubject(String subject) {\n+    this.subject = subject;\n+  }\n+\n+  public String getMessageBody() {\n+    return messageBody;\n+  }\n+\n+  public void setMessageBody(String messageBody) {\n+    this.messageBody = messageBody;\n+  }\n+\n+  public String getSmtp_Hostname() {\n+    if (this.smtp_Hostname.equals(\"\")) {\n+      if (useIpWhitelist) {\n+        return Mail.SMTP_RELAY_HOSTNAME;\n+      } else {\n+        return Mail.SMTP_HOSTNAME;\n+      }\n+    } else {\n+      return this.smtp_Hostname;\n+    }\n+  }\n+\n+  public void setSmtp_Hostname(String smtp_Hostname) {\n+    this.smtp_Hostname = smtp_Hostname;\n+  }\n+\n+  public String getSmtp_portvalue() {\n+    String portvalue = \"\";\n+    if (this.smtp_portvalue.equals(\"\")) {\n+      portvalue = Mail.SMTP_PORT;\n+    } else {\n+      portvalue = this.smtp_portvalue;\n+    }\n+\n+    return portvalue;\n+  }\n+\n+  public void setSmtp_portvalue(String smtp_portvalue) {\n+    this.smtp_portvalue = smtp_portvalue;\n+  }\n+\n+  public static String getSSL_FACTORY() {\n+    return SSL_FACTORY;\n+  }\n+\n+  public static void setSSL_FACTORY(String sSL_FACTORY) {", "originalCommit": "1275b0d755dc41d7df75133eab56d82eed9cb5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5Nzc0NA==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465497744", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nMissing a Javadoc comment.", "author": "github-actions", "createdAt": "2020-08-05T06:18:18Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/util/Mail.java", "diffHunk": "@@ -23,308 +23,304 @@\n import javax.mail.internet.MimeBodyPart;\n import javax.mail.internet.MimeMessage;\n import javax.mail.internet.MimeMultipart;\n-\n import lombok.Setter;\n import org.apache.commons.lang3.StringUtils;\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n \n public class Mail {\n \n-    private static final Logger logger = LogManager.getLogger(Mail.class);\n-\n-    private String toemail;\n-    private String subject;\n-    private String messageBody;\n-    // Fallback hostname if we are authenticating.\n-    private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n-    // Fallback hostname if we are not authenticating.\n-    private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n-    private static final String SMTP_PORT = \"465\";\n-    private String smtp_Hostname = \"\";\n-    private String smtp_portvalue = \"\";\n-    static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n-    private String sslFactory = \"\";\n-    private String fromEmailAddress = \"\";\n-    private String fromEmailPass = \"\";\n-    private String fromEmailName = \"\";\n-    private String ccEmail;\n-    private String bccEmail;\n-    private String attachmentPath;\n-    // Domain that we send in the EHLO request if we are not authenticating\n-    // with the SMTP server.\n-    @Setter\n-    private String fromDomain = \"\";\n-    // If set to true, we will not authenticate with the SMTP service and\n-    // rather rely on the SMTP service's configured IP whitelist. If false we\n-    // will authenticate with the provided fromEmailAddress and fromEmailPass.\n-    @Setter\n-    private Boolean useIpWhitelist = false;\n-\n-    public boolean sendemail() throws Exception {\n-        logger.debug(\" sendemail() ==== starts\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            message.setFrom(new InternetAddress(username));\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setContent(this.getMessageBody(), \"text/html\");\n-            Transport transport = session.getTransport();\n-            transport.send(message);\n-            logger.debug(\"sendemail()==== ends\");\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"sendemail() MessagingException- error\", e);\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendemail() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    public boolean sendMailWithAttachment() throws Exception {\n-        logger.debug(\"sendMailWithAttachment()==== start\");\n-        boolean sentMail = false;\n-        try {\n-            final String username = this.getFromEmailAddress();\n-            final String password = this.getFromEmailPass();\n-            Properties props = makeProperties(useIpWhitelist);\n-            Session session = useIpWhitelist ? makeSession(props) :\n-                    makeSession(props, username, password);\n-            Message message = new MimeMessage(session);\n-            if (StringUtils.isNotBlank(this.getToemail())) {\n-                if (this.getToemail().indexOf(\",\") != -1) {\n-                    message.setRecipients(\n-                            Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n-                } else {\n-                    message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n-                }\n-            }\n-            if (StringUtils.isNotBlank(this.getCcEmail())) {\n-                message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n-            }\n-            if (StringUtils.isNotBlank(this.getBccEmail())) {\n-                message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n-            }\n-            message.setSubject(this.subject);\n-            message.setFrom(new InternetAddress(username));\n-            // message.setText(\"Check attachment in Mail\");\n-            // message.setContent(messageBody, \"text/html\");\n-            // Create the message part\n-            BodyPart messageBodyPart = new MimeBodyPart();\n-            // Create a multipar message\n-            Multipart multipart = new MimeMultipart();\n-            // Part two is attachment\n-            messageBodyPart = new MimeBodyPart();\n-            // String filename = \"D:\\\\temp\\\\TestLinks.pdf\"; // D:\\temp\\noteb.txt\n-            DataSource source = new FileDataSource(this.getAttachmentPath());\n-            messageBodyPart.setDataHandler(new DataHandler(source));\n-            messageBodyPart.setFileName(source.getName());\n-            messageBodyPart.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n-            messageBodyPart.setHeader(\"Content-Type\", source.getContentType());\n-            // Send the complete message parts\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            messageBodyPart = new MimeBodyPart();\n-            messageBodyPart.setText(messageBody);\n-            messageBodyPart.setHeader(\"MIME-Version\", \"1.0\");\n-            messageBodyPart.setHeader(\"Content-Type\", messageBodyPart.getContentType());\n-            multipart.addBodyPart(messageBodyPart);\n-\n-            message.setContent(multipart);\n-            Transport.send(message);\n-            sentMail = true;\n-        } catch (MessagingException e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-            sentMail = false;\n-        } catch (Exception e) {\n-            logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n-        }\n-        logger.debug(\"Mail.sendMailWithAttachment() :: Ends\");\n-        return sentMail;\n-    }\n-\n-    // Constructs a Propterties either relying on IP Whitelist on the SMTP\n-    // service or on authentication with email and password.\n-    private Properties makeProperties(Boolean useIpWhitelist) {\n-        Properties props = new Properties();\n-        props.put(\"mail.smtp.host\", this.getSmtp_Hostname());\n-        props.put(\"mail.smtp.port\", this.getSmtp_portvalue());\n-        props.put(\"mail.smtp.socketFactory.class\", this.getSslFactory());\n-        props.put(\"mail.smtp.socketFactory.port\", this.getSmtp_portvalue());\n-        if (useIpWhitelist) {\n-            props.put(\"mail.smtp.auth\", \"false\");\n-            props.put(\"mail.smtp.ssl.enable\", \"true\");\n-            props.put(\"mail.smtp.localhost\", fromDomain);\n+  private static final Logger logger = LogManager.getLogger(Mail.class);\n+\n+  private String toemail;\n+  private String subject;\n+  private String messageBody;\n+  // Fallback hostname if we are authenticating.\n+  private static final String SMTP_HOSTNAME = \"smtp.gmail.com\";\n+  // Fallback hostname if we are not authenticating.\n+  private static final String SMTP_RELAY_HOSTNAME = \"smtp-relay.gmail.com\";\n+  private static final String SMTP_PORT = \"465\";\n+  private String smtp_Hostname = \"\";\n+  private String smtp_portvalue = \"\";\n+  static String SSL_FACTORY = \"javax.net.ssl.SSLSocketFactory\";\n+  private String sslFactory = \"\";\n+  private String fromEmailAddress = \"\";\n+  private String fromEmailPass = \"\";\n+  private String fromEmailName = \"\";\n+  private String ccEmail;\n+  private String bccEmail;\n+  private String attachmentPath;\n+  // Domain that we send in the EHLO request if we are not authenticating\n+  // with the SMTP server.\n+  @Setter private String fromDomain = \"\";\n+  // If set to true, we will not authenticate with the SMTP service and\n+  // rather rely on the SMTP service's configured IP whitelist. If false we\n+  // will authenticate with the provided fromEmailAddress and fromEmailPass.\n+  @Setter private Boolean useIpWhitelist = false;\n+\n+  public boolean sendemail() throws Exception {\n+    logger.debug(\" sendemail() ==== starts\");\n+    boolean sentMail = false;\n+    try {\n+      final String username = this.getFromEmailAddress();\n+      final String password = this.getFromEmailPass();\n+      Properties props = makeProperties(useIpWhitelist);\n+      Session session =\n+          useIpWhitelist ? makeSession(props) : makeSession(props, username, password);\n+      Message message = new MimeMessage(session);\n+      message.setFrom(new InternetAddress(username));\n+      if (StringUtils.isNotBlank(this.getToemail())) {\n+        if (this.getToemail().indexOf(\",\") != -1) {\n+          message.setRecipients(\n+              Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n         } else {\n-            props.put(\"mail.smtp.auth\", \"true\");\n+          message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n         }\n-        return props;\n-    }\n-\n-    private Session makeSession(Properties props) {\n-        return Session.getInstance(props, null);\n-    }\n-\n-    private Session makeSession(Properties props, String username,\n-                                String password) {\n-        return Session.getInstance(\n-                props,\n-                new javax.mail.Authenticator() {\n-                    @Override\n-                    protected PasswordAuthentication getPasswordAuthentication() {\n-                        return new PasswordAuthentication(username, password);\n-                    }\n-                });\n-    }\n-\n-    public String getToemail() {\n-        return toemail;\n-    }\n-\n-    public void setToemail(String toemail) {\n-        this.toemail = toemail;\n-    }\n-\n-    public String getSubject() {\n-        return subject;\n-    }\n-\n-    public void setSubject(String subject) {\n-        this.subject = subject;\n-    }\n-\n-    public String getMessageBody() {\n-        return messageBody;\n-    }\n-\n-    public void setMessageBody(String messageBody) {\n-        this.messageBody = messageBody;\n-    }\n-\n-    public String getSmtp_Hostname() {\n-        if (this.smtp_Hostname.equals(\"\")) {\n-            if (useIpWhitelist) {\n-                return Mail.SMTP_RELAY_HOSTNAME;\n-            } else {\n-                return Mail.SMTP_HOSTNAME;\n-            }\n+      }\n+      if (StringUtils.isNotBlank(this.getCcEmail())) {\n+        message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n+      }\n+      if (StringUtils.isNotBlank(this.getBccEmail())) {\n+        message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n+      }\n+      message.setSubject(this.subject);\n+      message.setContent(this.getMessageBody(), \"text/html\");\n+      Transport transport = session.getTransport();\n+      transport.send(message);\n+      logger.debug(\"sendemail()==== ends\");\n+      sentMail = true;\n+    } catch (MessagingException e) {\n+      logger.error(\"sendemail() MessagingException- error\", e);\n+    } catch (Exception e) {\n+      logger.error(\"ERROR:  sendemail() - error( ) \" + e + \" : \");\n+    }\n+    logger.debug(\"Mail.sendemail() :: Ends\");\n+    return sentMail;\n+  }\n+\n+  public boolean sendMailWithAttachment() throws Exception {\n+    logger.debug(\"sendMailWithAttachment()==== start\");\n+    boolean sentMail = false;\n+    try {\n+      final String username = this.getFromEmailAddress();\n+      final String password = this.getFromEmailPass();\n+      Properties props = makeProperties(useIpWhitelist);\n+      Session session =\n+          useIpWhitelist ? makeSession(props) : makeSession(props, username, password);\n+      Message message = new MimeMessage(session);\n+      if (StringUtils.isNotBlank(this.getToemail())) {\n+        if (this.getToemail().indexOf(\",\") != -1) {\n+          message.setRecipients(\n+              Message.RecipientType.BCC, InternetAddress.parse(this.getToemail()));\n         } else {\n-            return this.smtp_Hostname;\n+          message.setRecipients(Message.RecipientType.TO, InternetAddress.parse(this.getToemail()));\n         }\n-    }\n+      }\n+      if (StringUtils.isNotBlank(this.getCcEmail())) {\n+        message.setRecipients(Message.RecipientType.CC, InternetAddress.parse(this.getCcEmail()));\n+      }\n+      if (StringUtils.isNotBlank(this.getBccEmail())) {\n+        message.setRecipients(Message.RecipientType.BCC, InternetAddress.parse(this.getBccEmail()));\n+      }\n+      message.setSubject(this.subject);\n+      message.setFrom(new InternetAddress(username));\n+      // message.setText(\"Check attachment in Mail\");\n+      // message.setContent(messageBody, \"text/html\");\n+      // Create the message part\n+      BodyPart messageBodyPart = new MimeBodyPart();\n+      // Create a multipar message\n+      Multipart multipart = new MimeMultipart();\n+      // Part two is attachment\n+      messageBodyPart = new MimeBodyPart();\n+      // String filename = \"D:\\\\temp\\\\TestLinks.pdf\"; // D:\\temp\\noteb.txt\n+      DataSource source = new FileDataSource(this.getAttachmentPath());\n+      messageBodyPart.setDataHandler(new DataHandler(source));\n+      messageBodyPart.setFileName(source.getName());\n+      messageBodyPart.setHeader(\"Content-Transfer-Encoding\", \"base64\");\n+      messageBodyPart.setHeader(\"Content-Type\", source.getContentType());\n+      // Send the complete message parts\n+      multipart.addBodyPart(messageBodyPart);\n+\n+      messageBodyPart = new MimeBodyPart();\n+      messageBodyPart.setText(messageBody);\n+      messageBodyPart.setHeader(\"MIME-Version\", \"1.0\");\n+      messageBodyPart.setHeader(\"Content-Type\", messageBodyPart.getContentType());\n+      multipart.addBodyPart(messageBodyPart);\n+\n+      message.setContent(multipart);\n+      Transport.send(message);\n+      sentMail = true;\n+    } catch (MessagingException e) {\n+      logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n+      sentMail = false;\n+    } catch (Exception e) {\n+      logger.error(\"ERROR:  sendemail() - \" + e + \" : \");\n+    }\n+    logger.debug(\"Mail.sendMailWithAttachment() :: Ends\");\n+    return sentMail;\n+  }\n+\n+  // Constructs a Propterties either relying on IP Whitelist on the SMTP\n+  // service or on authentication with email and password.\n+  private Properties makeProperties(Boolean useIpWhitelist) {\n+    Properties props = new Properties();\n+    props.put(\"mail.smtp.host\", this.getSmtp_Hostname());\n+    props.put(\"mail.smtp.port\", this.getSmtp_portvalue());\n+    props.put(\"mail.smtp.socketFactory.class\", this.getSslFactory());\n+    props.put(\"mail.smtp.socketFactory.port\", this.getSmtp_portvalue());\n+    if (useIpWhitelist) {\n+      props.put(\"mail.smtp.auth\", \"false\");\n+      props.put(\"mail.smtp.ssl.enable\", \"true\");\n+      props.put(\"mail.smtp.localhost\", fromDomain);\n+    } else {\n+      props.put(\"mail.smtp.auth\", \"true\");\n+    }\n+    return props;\n+  }\n+\n+  private Session makeSession(Properties props) {\n+    return Session.getInstance(props, null);\n+  }\n+\n+  private Session makeSession(Properties props, String username, String password) {\n+    return Session.getInstance(\n+        props,\n+        new javax.mail.Authenticator() {\n+          @Override\n+          protected PasswordAuthentication getPasswordAuthentication() {\n+            return new PasswordAuthentication(username, password);\n+          }\n+        });\n+  }\n+\n+  public String getToemail() {\n+    return toemail;\n+  }\n+\n+  public void setToemail(String toemail) {\n+    this.toemail = toemail;\n+  }\n+\n+  public String getSubject() {\n+    return subject;\n+  }\n+\n+  public void setSubject(String subject) {\n+    this.subject = subject;\n+  }\n+\n+  public String getMessageBody() {\n+    return messageBody;\n+  }\n+\n+  public void setMessageBody(String messageBody) {\n+    this.messageBody = messageBody;\n+  }\n+\n+  public String getSmtp_Hostname() {\n+    if (this.smtp_Hostname.equals(\"\")) {\n+      if (useIpWhitelist) {\n+        return Mail.SMTP_RELAY_HOSTNAME;\n+      } else {\n+        return Mail.SMTP_HOSTNAME;\n+      }\n+    } else {\n+      return this.smtp_Hostname;\n+    }\n+  }\n+\n+  public void setSmtp_Hostname(String smtp_Hostname) {\n+    this.smtp_Hostname = smtp_Hostname;\n+  }\n+\n+  public String getSmtp_portvalue() {\n+    String portvalue = \"\";\n+    if (this.smtp_portvalue.equals(\"\")) {\n+      portvalue = Mail.SMTP_PORT;\n+    } else {\n+      portvalue = this.smtp_portvalue;\n+    }\n+\n+    return portvalue;\n+  }\n+\n+  public void setSmtp_portvalue(String smtp_portvalue) {\n+    this.smtp_portvalue = smtp_portvalue;\n+  }\n+\n+  public static String getSSL_FACTORY() {\n+    return SSL_FACTORY;\n+  }\n+\n+  public static void setSSL_FACTORY(String sSL_FACTORY) {\n+    SSL_FACTORY = sSL_FACTORY;\n+  }\n+\n+  public String getSslFactory() {", "originalCommit": "1275b0d755dc41d7df75133eab56d82eed9cb5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5Nzc0Ng==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465497746", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\nMissing a Javadoc comment.", "author": "github-actions", "createdAt": "2020-08-05T06:18:18Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/service/CloudStorageService.java", "diffHunk": "@@ -7,76 +7,69 @@\n  */\n package com.google.cloud.healthcare.fdamystudies.service;\n \n-import java.io.ByteArrayOutputStream;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.regex.Pattern;\n-import javax.annotation.PostConstruct;\n-\n import com.google.api.gax.paging.Page;\n+import com.google.cloud.healthcare.fdamystudies.config.ApplicationPropertyConfiguration;\n import com.google.cloud.storage.Blob;\n import com.google.cloud.storage.Bucket;\n import com.google.cloud.storage.Storage;\n import com.google.cloud.storage.StorageException;\n import com.google.cloud.storage.StorageOptions;\n-import java.net.URL;\n+import java.io.ByteArrayOutputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import javax.annotation.PostConstruct;\n import lombok.AllArgsConstructor;\n import lombok.NoArgsConstructor;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n-import com.google.cloud.healthcare.fdamystudies.config.ApplicationPropertyConfiguration;\n \n @Service\n public class CloudStorageService {\n-    private static Logger logger = LoggerFactory.getLogger(CloudStorageService.class);\n+  private static Logger logger = LoggerFactory.getLogger(CloudStorageService.class);\n \n-    private Storage storageService;\n+  private Storage storageService;\n \n-    @Autowired\n-    private ApplicationPropertyConfiguration appConfig;\n+  @Autowired private ApplicationPropertyConfiguration appConfig;\n \n-    @PostConstruct\n-    private void init() {\n-        storageService = StorageOptions.getDefaultInstance().getService();\n-    }\n+  @PostConstruct\n+  private void init() {\n+    storageService = StorageOptions.getDefaultInstance().getService();\n+  }\n \n-    @AllArgsConstructor\n-    @NoArgsConstructor\n-    public static class InstitutionResource {\n-        public String title;\n-        public ByteArrayOutputStream stream = new ByteArrayOutputStream();\n-        public String hash;\n-    }\n+  @AllArgsConstructor\n+  @NoArgsConstructor\n+  public static class InstitutionResource {\n+    public String title;\n+    public ByteArrayOutputStream stream = new ByteArrayOutputStream();\n+    public String hash;\n+  }\n \n-    public List<InstitutionResource> getAllInstitutionResources(String institutionId) {\n-        Bucket bucket = null;\n-        try {\n-            bucket = storageService.get(appConfig.getInstitutionBucketName());\n-        } catch (StorageException e) {\n-            logger.error(e.getMessage());\n-        } finally {\n-            if (bucket == null) return new ArrayList<>();\n-        }\n-        Page<Blob> blobs = bucket.list(Storage.BlobListOption.prefix(institutionId));\n-\n-        ArrayList<InstitutionResource> resources = new ArrayList<>();\n-        for (Blob blob : blobs.iterateAll()) {\n-            InstitutionResource resource = new InstitutionResource();\n-            // Remove institutionId directory path from title.\n-            resource.title = blob.getName().replaceFirst(Pattern.quote(institutionId + \"/\"),\n-                    \"\");\n-            resource.hash = blob.getMd5();\n-            // There are placeholder files in GCS that match the directory\n-            // but do not have a file name. Skip these.\n-            if (resource.title.isEmpty()) continue;\n-            blob.downloadTo(resource.stream);\n-            resources.add(resource);\n-        }\n-        return resources;\n+  public List<InstitutionResource> getAllInstitutionResources(String institutionId) {", "originalCommit": "1275b0d755dc41d7df75133eab56d82eed9cb5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5Nzc0OA==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465497748", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\n'if' construct must use '{}'s.", "author": "github-actions", "createdAt": "2020-08-05T06:18:18Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/service/CloudStorageService.java", "diffHunk": "@@ -7,76 +7,69 @@\n  */\n package com.google.cloud.healthcare.fdamystudies.service;\n \n-import java.io.ByteArrayOutputStream;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.regex.Pattern;\n-import javax.annotation.PostConstruct;\n-\n import com.google.api.gax.paging.Page;\n+import com.google.cloud.healthcare.fdamystudies.config.ApplicationPropertyConfiguration;\n import com.google.cloud.storage.Blob;\n import com.google.cloud.storage.Bucket;\n import com.google.cloud.storage.Storage;\n import com.google.cloud.storage.StorageException;\n import com.google.cloud.storage.StorageOptions;\n-import java.net.URL;\n+import java.io.ByteArrayOutputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import javax.annotation.PostConstruct;\n import lombok.AllArgsConstructor;\n import lombok.NoArgsConstructor;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n-import com.google.cloud.healthcare.fdamystudies.config.ApplicationPropertyConfiguration;\n \n @Service\n public class CloudStorageService {\n-    private static Logger logger = LoggerFactory.getLogger(CloudStorageService.class);\n+  private static Logger logger = LoggerFactory.getLogger(CloudStorageService.class);\n \n-    private Storage storageService;\n+  private Storage storageService;\n \n-    @Autowired\n-    private ApplicationPropertyConfiguration appConfig;\n+  @Autowired private ApplicationPropertyConfiguration appConfig;\n \n-    @PostConstruct\n-    private void init() {\n-        storageService = StorageOptions.getDefaultInstance().getService();\n-    }\n+  @PostConstruct\n+  private void init() {\n+    storageService = StorageOptions.getDefaultInstance().getService();\n+  }\n \n-    @AllArgsConstructor\n-    @NoArgsConstructor\n-    public static class InstitutionResource {\n-        public String title;\n-        public ByteArrayOutputStream stream = new ByteArrayOutputStream();\n-        public String hash;\n-    }\n+  @AllArgsConstructor\n+  @NoArgsConstructor\n+  public static class InstitutionResource {\n+    public String title;\n+    public ByteArrayOutputStream stream = new ByteArrayOutputStream();\n+    public String hash;\n+  }\n \n-    public List<InstitutionResource> getAllInstitutionResources(String institutionId) {\n-        Bucket bucket = null;\n-        try {\n-            bucket = storageService.get(appConfig.getInstitutionBucketName());\n-        } catch (StorageException e) {\n-            logger.error(e.getMessage());\n-        } finally {\n-            if (bucket == null) return new ArrayList<>();\n-        }\n-        Page<Blob> blobs = bucket.list(Storage.BlobListOption.prefix(institutionId));\n-\n-        ArrayList<InstitutionResource> resources = new ArrayList<>();\n-        for (Blob blob : blobs.iterateAll()) {\n-            InstitutionResource resource = new InstitutionResource();\n-            // Remove institutionId directory path from title.\n-            resource.title = blob.getName().replaceFirst(Pattern.quote(institutionId + \"/\"),\n-                    \"\");\n-            resource.hash = blob.getMd5();\n-            // There are placeholder files in GCS that match the directory\n-            // but do not have a file name. Skip these.\n-            if (resource.title.isEmpty()) continue;\n-            blob.downloadTo(resource.stream);\n-            resources.add(resource);\n-        }\n-        return resources;\n+  public List<InstitutionResource> getAllInstitutionResources(String institutionId) {\n+    Bucket bucket = null;\n+    try {\n+      bucket = storageService.get(appConfig.getInstitutionBucketName());\n+    } catch (StorageException e) {\n+      logger.error(e.getMessage());\n+    } finally {\n+      if (bucket == null) return new ArrayList<>();", "originalCommit": "1275b0d755dc41d7df75133eab56d82eed9cb5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5Nzc0OQ==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465497749", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\n'if' construct must use '{}'s.", "author": "github-actions", "createdAt": "2020-08-05T06:18:18Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/service/CloudStorageService.java", "diffHunk": "@@ -7,76 +7,69 @@\n  */\n package com.google.cloud.healthcare.fdamystudies.service;\n \n-import java.io.ByteArrayOutputStream;\n-import java.util.ArrayList;\n-import java.util.List;\n-import java.util.regex.Pattern;\n-import javax.annotation.PostConstruct;\n-\n import com.google.api.gax.paging.Page;\n+import com.google.cloud.healthcare.fdamystudies.config.ApplicationPropertyConfiguration;\n import com.google.cloud.storage.Blob;\n import com.google.cloud.storage.Bucket;\n import com.google.cloud.storage.Storage;\n import com.google.cloud.storage.StorageException;\n import com.google.cloud.storage.StorageOptions;\n-import java.net.URL;\n+import java.io.ByteArrayOutputStream;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import javax.annotation.PostConstruct;\n import lombok.AllArgsConstructor;\n import lombok.NoArgsConstructor;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.beans.factory.annotation.Autowired;\n import org.springframework.stereotype.Service;\n-import com.google.cloud.healthcare.fdamystudies.config.ApplicationPropertyConfiguration;\n \n @Service\n public class CloudStorageService {\n-    private static Logger logger = LoggerFactory.getLogger(CloudStorageService.class);\n+  private static Logger logger = LoggerFactory.getLogger(CloudStorageService.class);\n \n-    private Storage storageService;\n+  private Storage storageService;\n \n-    @Autowired\n-    private ApplicationPropertyConfiguration appConfig;\n+  @Autowired private ApplicationPropertyConfiguration appConfig;\n \n-    @PostConstruct\n-    private void init() {\n-        storageService = StorageOptions.getDefaultInstance().getService();\n-    }\n+  @PostConstruct\n+  private void init() {\n+    storageService = StorageOptions.getDefaultInstance().getService();\n+  }\n \n-    @AllArgsConstructor\n-    @NoArgsConstructor\n-    public static class InstitutionResource {\n-        public String title;\n-        public ByteArrayOutputStream stream = new ByteArrayOutputStream();\n-        public String hash;\n-    }\n+  @AllArgsConstructor\n+  @NoArgsConstructor\n+  public static class InstitutionResource {\n+    public String title;\n+    public ByteArrayOutputStream stream = new ByteArrayOutputStream();\n+    public String hash;\n+  }\n \n-    public List<InstitutionResource> getAllInstitutionResources(String institutionId) {\n-        Bucket bucket = null;\n-        try {\n-            bucket = storageService.get(appConfig.getInstitutionBucketName());\n-        } catch (StorageException e) {\n-            logger.error(e.getMessage());\n-        } finally {\n-            if (bucket == null) return new ArrayList<>();\n-        }\n-        Page<Blob> blobs = bucket.list(Storage.BlobListOption.prefix(institutionId));\n-\n-        ArrayList<InstitutionResource> resources = new ArrayList<>();\n-        for (Blob blob : blobs.iterateAll()) {\n-            InstitutionResource resource = new InstitutionResource();\n-            // Remove institutionId directory path from title.\n-            resource.title = blob.getName().replaceFirst(Pattern.quote(institutionId + \"/\"),\n-                    \"\");\n-            resource.hash = blob.getMd5();\n-            // There are placeholder files in GCS that match the directory\n-            // but do not have a file name. Skip these.\n-            if (resource.title.isEmpty()) continue;\n-            blob.downloadTo(resource.stream);\n-            resources.add(resource);\n-        }\n-        return resources;\n+  public List<InstitutionResource> getAllInstitutionResources(String institutionId) {\n+    Bucket bucket = null;\n+    try {\n+      bucket = storageService.get(appConfig.getInstitutionBucketName());\n+    } catch (StorageException e) {\n+      logger.error(e.getMessage());\n+    } finally {\n+      if (bucket == null) return new ArrayList<>();\n     }\n+    Page<Blob> blobs = bucket.list(Storage.BlobListOption.prefix(institutionId));\n \n+    ArrayList<InstitutionResource> resources = new ArrayList<>();\n+    for (Blob blob : blobs.iterateAll()) {\n+      InstitutionResource resource = new InstitutionResource();\n+      // Remove institutionId directory path from title.\n+      resource.title = blob.getName().replaceFirst(Pattern.quote(institutionId + \"/\"), \"\");\n+      resource.hash = blob.getMd5();\n+      // There are placeholder files in GCS that match the directory\n+      // but do not have a file name. Skip these.\n+      if (resource.title.isEmpty()) continue;", "originalCommit": "1275b0d755dc41d7df75133eab56d82eed9cb5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ5Nzc1Mg==", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/pull/604#discussion_r465497752", "bodyText": "[user-mgmt Checks] reported by reviewdog \ud83d\udc36\n'lambda arguments' has incorrect indentation level 20, expected level should be one of the following: 14, 16.", "author": "github-actions", "createdAt": "2020-08-05T06:18:19Z", "path": "user-registration-server-ws/user-mgmt/src/main/java/com/google/cloud/healthcare/fdamystudies/service/PersonalizedUserReportService.java", "diffHunk": "@@ -38,8 +40,14 @@\n                     Comparator.comparing(PersonalizedUserReportBO::getCreationTime))))\n         .entrySet()\n         .stream()\n-        .filter(e -> e.getValue().getCreationTime()!=null)\n-        .sorted(Comparator.comparing(e -> ((Map.Entry<String, PersonalizedUserReportBO>) e).getValue().getCreationTime()).reversed())\n+        .filter(e -> e.getValue().getCreationTime() != null)\n+        .sorted(\n+            Comparator.comparing(\n+                    e ->", "originalCommit": "1275b0d755dc41d7df75133eab56d82eed9cb5e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cb569f055ae26f6763e48899d551550ae5fe2620", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/commit/cb569f055ae26f6763e48899d551550ae5fe2620", "message": "Oraganized the imports\n\nOraganized the imports", "committedDate": "2020-08-05T13:35:34Z", "type": "commit"}, {"oid": "c5596bb309681b4907d50001c87d334f0c7a06a2", "url": "https://github.com/GoogleCloudPlatform/fda-mystudies/commit/c5596bb309681b4907d50001c87d334f0c7a06a2", "message": "Merge branch 'early-access' into early-access-user-mgmt-pending-integration-testcases", "committedDate": "2020-08-05T13:42:15Z", "type": "commit"}]}