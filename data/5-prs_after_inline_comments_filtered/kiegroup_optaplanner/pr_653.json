{"pr_number": 653, "pr_title": "PLANNER-1652 Migrate ExhaustiveSearchTest", "pr_createdAt": "2020-01-09T10:39:38Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/653", "timeline": [{"oid": "9f6ac82dc660836a63976a964dbaa9d07b48a544", "url": "https://github.com/kiegroup/optaplanner/commit/9f6ac82dc660836a63976a964dbaa9d07b48a544", "message": "PLANNER-1652 Migrate ExhaustiveSearchTest\n\nI've constructed a custom domain for this test, which tries to find the best solution using the least amount of value duplicates. The data in ExhaustiveSearchTest has been checked manually and matches the expected results of different configurations tested.", "committedDate": "2020-01-09T10:34:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY3NTIwNQ==", "url": "https://github.com/kiegroup/optaplanner/pull/653#discussion_r364675205", "bodyText": "Please introduce a new method for each of these.", "author": "triceo", "createdAt": "2020-01-09T10:53:00Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/exhaustivesearch/ExhaustiveSearchTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+package org.optaplanner.core.impl.exhaustivesearch;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.optaplanner.core.api.solver.Solver;\n+import org.optaplanner.core.api.solver.SolverFactory;\n+import org.optaplanner.core.config.exhaustivesearch.ExhaustiveSearchPhaseConfig;\n+import org.optaplanner.core.config.exhaustivesearch.ExhaustiveSearchType;\n+import org.optaplanner.core.config.exhaustivesearch.NodeExplorationType;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionCacheType;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionOrder;\n+import org.optaplanner.core.config.heuristic.selector.entity.EntitySelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.entity.EntitySorterManner;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.ChangeMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.value.ValueSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.value.ValueSorterManner;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+import org.optaplanner.core.impl.exhaustivesearch.event.ExhaustiveSearchListener;\n+import org.optaplanner.core.impl.solver.DefaultSolver;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataComparableEntity;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataComparableSolution;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataComparableValue;\n+import org.optaplanner.core.impl.testdata.score.director.TestdataComparableDifferentValuesCalculator;\n+import org.optaplanner.core.impl.testdata.util.PlannerTestUtils;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+@RunWith(Parameterized.class)\n+public class ExhaustiveSearchTest {\n+\n+    private final ExhaustiveSearchType exhaustiveSearchType;\n+    private final NodeExplorationType nodeExplorationType;\n+    private final EntitySorterManner entitySorterManner;\n+    private final ValueSorterManner valueSorterManner;\n+    private final List<String> steps;\n+    private TestdataComparableSolution solution;\n+    private SolverConfig solverConfig;\n+\n+    public ExhaustiveSearchTest(ExhaustiveSearchType exhaustiveSearchType, NodeExplorationType nodeExplorationType,\n+                                EntitySorterManner entitySorterManner, ValueSorterManner valueSorterManner, List<String> steps) {\n+        this.exhaustiveSearchType = exhaustiveSearchType;\n+        this.nodeExplorationType = nodeExplorationType;\n+        this.entitySorterManner = entitySorterManner;\n+        this.valueSorterManner = valueSorterManner;\n+        this.steps = steps;\n+    }\n+\n+    /**\n+     * Initialize combination of input parameters.\n+     *\n+     * @return collection of combination of input parameters\n+     */\n+    @Parameterized.Parameters(name = \"{0}, NodeExplorationType-{1}, EntitySorterManner-{2}, ValueSorterManner-{3}\")\n+    public static Collection<Object[]> params() {\n+        Collection<Object[]> col = new ArrayList<>();\n+\n+        // -------------------------------\n+        // BRANCH AND BOUND :: Depth First\n+        // -------------------------------", "originalCommit": "9f6ac82dc660836a63976a964dbaa9d07b48a544", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY3NTYzMg==", "url": "https://github.com/kiegroup/optaplanner/pull/653#discussion_r364675632", "bodyText": "It would be nice to have a method for adding to the list. That method could then supply the final list as varargs. Would remove some boilerplate and add a bit of code reuse.", "author": "triceo", "createdAt": "2020-01-09T10:54:02Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/exhaustivesearch/ExhaustiveSearchTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+package org.optaplanner.core.impl.exhaustivesearch;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.optaplanner.core.api.solver.Solver;\n+import org.optaplanner.core.api.solver.SolverFactory;\n+import org.optaplanner.core.config.exhaustivesearch.ExhaustiveSearchPhaseConfig;\n+import org.optaplanner.core.config.exhaustivesearch.ExhaustiveSearchType;\n+import org.optaplanner.core.config.exhaustivesearch.NodeExplorationType;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionCacheType;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionOrder;\n+import org.optaplanner.core.config.heuristic.selector.entity.EntitySelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.entity.EntitySorterManner;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.ChangeMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.value.ValueSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.value.ValueSorterManner;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+import org.optaplanner.core.impl.exhaustivesearch.event.ExhaustiveSearchListener;\n+import org.optaplanner.core.impl.solver.DefaultSolver;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataComparableEntity;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataComparableSolution;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataComparableValue;\n+import org.optaplanner.core.impl.testdata.score.director.TestdataComparableDifferentValuesCalculator;\n+import org.optaplanner.core.impl.testdata.util.PlannerTestUtils;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+@RunWith(Parameterized.class)\n+public class ExhaustiveSearchTest {\n+\n+    private final ExhaustiveSearchType exhaustiveSearchType;\n+    private final NodeExplorationType nodeExplorationType;\n+    private final EntitySorterManner entitySorterManner;\n+    private final ValueSorterManner valueSorterManner;\n+    private final List<String> steps;\n+    private TestdataComparableSolution solution;\n+    private SolverConfig solverConfig;\n+\n+    public ExhaustiveSearchTest(ExhaustiveSearchType exhaustiveSearchType, NodeExplorationType nodeExplorationType,\n+                                EntitySorterManner entitySorterManner, ValueSorterManner valueSorterManner, List<String> steps) {\n+        this.exhaustiveSearchType = exhaustiveSearchType;\n+        this.nodeExplorationType = nodeExplorationType;\n+        this.entitySorterManner = entitySorterManner;\n+        this.valueSorterManner = valueSorterManner;\n+        this.steps = steps;\n+    }\n+\n+    /**\n+     * Initialize combination of input parameters.\n+     *\n+     * @return collection of combination of input parameters\n+     */\n+    @Parameterized.Parameters(name = \"{0}, NodeExplorationType-{1}, EntitySorterManner-{2}, ValueSorterManner-{3}\")\n+    public static Collection<Object[]> params() {\n+        Collection<Object[]> col = new ArrayList<>();\n+\n+        // -------------------------------\n+        // BRANCH AND BOUND :: Depth First\n+        // -------------------------------\n+        col.add(new Object[]{\n+                ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                NodeExplorationType.DEPTH_FIRST,\n+                EntitySorterManner.NONE,\n+                ValueSorterManner.NONE,\n+                Arrays.asList(\"----\", \"1---\", \"13--\", \"132-\", \"13-2\", \"12--\", \"123-\", \"12-3\", \"1-3-\", \"123-\", \"1321\")});", "originalCommit": "9f6ac82dc660836a63976a964dbaa9d07b48a544", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY3NjI4OA==", "url": "https://github.com/kiegroup/optaplanner/pull/653#discussion_r364676288", "bodyText": "If you want to play around a bit with Java's streams, Collectors.joining() is your friend.\n(But there is nothing wrong with this method as it stands now.)", "author": "triceo", "createdAt": "2020-01-09T10:55:38Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/exhaustivesearch/event/ExhaustiveSearchListener.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package org.optaplanner.core.impl.exhaustivesearch.event;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.optaplanner.core.impl.phase.event.PhaseLifecycleListenerAdapter;\n+import org.optaplanner.core.impl.phase.scope.AbstractStepScope;\n+import org.optaplanner.core.impl.solver.scope.DefaultSolverScope;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataComparableEntity;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataComparableSolution;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataComparableValue;\n+\n+public class ExhaustiveSearchListener extends PhaseLifecycleListenerAdapter<TestdataComparableSolution> {\n+\n+    private final List<String> dataConfigurations = new ArrayList<>();\n+\n+    @Override\n+    public void stepEnded(AbstractStepScope<TestdataComparableSolution> abstractStepScope) {\n+        addConfiguration(abstractStepScope.getWorkingSolution());\n+    }\n+\n+    @Override\n+    public void solvingEnded(DefaultSolverScope<TestdataComparableSolution> solverScope) {\n+        addConfiguration(solverScope.getBestSolution());\n+    }\n+\n+    private void addConfiguration(TestdataComparableSolution solution) {\n+        StringBuilder s = new StringBuilder();\n+\n+        for(TestdataComparableEntity entity : solution.getEntityList()) {\n+            TestdataComparableValue value = entity.getValue();\n+            if(value == null) {\n+                s.append(\"-\");\n+            }else {\n+                s.append(value.getCode());\n+            }\n+        }\n+        dataConfigurations.add(s.toString());", "originalCommit": "9f6ac82dc660836a63976a964dbaa9d07b48a544", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY3ODA3Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/653#discussion_r364678077", "bodyText": "I suggest you invert the logic here.\nif (entity.getValue() == null) {\n    continue;\n}\n...\n\nYou'll accomplish two important things:\n\nEasier code to understand. Inverted logic takes people longer to understand.\nEasier code to read. The original contents of the block can move out of the block, removing one level of nesting. Again, less to have to think about.", "author": "triceo", "createdAt": "2020-01-09T10:59:12Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/testdata/score/director/TestdataComparableDifferentValuesCalculator.java", "diffHunk": "@@ -0,0 +1,33 @@\n+package org.optaplanner.core.impl.testdata.score.director;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.optaplanner.core.api.score.buildin.simple.SimpleScore;\n+import org.optaplanner.core.impl.score.director.easy.EasyScoreCalculator;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataComparableEntity;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataComparableSolution;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataComparableValue;\n+\n+public class TestdataComparableDifferentValuesCalculator implements EasyScoreCalculator<TestdataComparableSolution> {\n+\n+    @Override\n+    public SimpleScore calculateScore(TestdataComparableSolution solution) {\n+        int score = 0;\n+        Map<TestdataComparableValue, Integer> alreadyUsedValues = new HashMap<>();\n+\n+        for (TestdataComparableEntity entity : solution.getEntityList()) {\n+            if (entity.getValue() != null) {\n+                TestdataComparableValue value = entity.getValue();\n+                if (alreadyUsedValues.containsKey(value)) {\n+                    int incrementedValue = alreadyUsedValues.get(value) + 1;\n+                    alreadyUsedValues.put(value, incrementedValue);\n+                    score -= incrementedValue;\n+                } else {\n+                    alreadyUsedValues.put(value, 1);\n+                }\n+            }\n+        }", "originalCommit": "9f6ac82dc660836a63976a964dbaa9d07b48a544", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NDY3OTg2MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/653#discussion_r364679861", "bodyText": "This test deserves a Javadoc. Something explaining how the test was put together, what the magic values mean (13--, ...) and that they are, indeed, painstakingly manually crafter.", "author": "triceo", "createdAt": "2020-01-09T11:03:42Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/exhaustivesearch/ExhaustiveSearchTest.java", "diffHunk": "@@ -0,0 +1,363 @@\n+package org.optaplanner.core.impl.exhaustivesearch;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.optaplanner.core.api.solver.Solver;\n+import org.optaplanner.core.api.solver.SolverFactory;\n+import org.optaplanner.core.config.exhaustivesearch.ExhaustiveSearchPhaseConfig;\n+import org.optaplanner.core.config.exhaustivesearch.ExhaustiveSearchType;\n+import org.optaplanner.core.config.exhaustivesearch.NodeExplorationType;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionCacheType;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionOrder;\n+import org.optaplanner.core.config.heuristic.selector.entity.EntitySelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.entity.EntitySorterManner;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.ChangeMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.value.ValueSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.value.ValueSorterManner;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+import org.optaplanner.core.impl.exhaustivesearch.event.ExhaustiveSearchListener;\n+import org.optaplanner.core.impl.solver.DefaultSolver;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataComparableEntity;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataComparableSolution;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataComparableValue;\n+import org.optaplanner.core.impl.testdata.score.director.TestdataComparableDifferentValuesCalculator;\n+import org.optaplanner.core.impl.testdata.util.PlannerTestUtils;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+@RunWith(Parameterized.class)\n+public class ExhaustiveSearchTest {", "originalCommit": "9f6ac82dc660836a63976a964dbaa9d07b48a544", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2c7ceca672f655e2f85588f9e81eec8c3a9ec431", "url": "https://github.com/kiegroup/optaplanner/commit/2c7ceca672f655e2f85588f9e81eec8c3a9ec431", "message": "PLANNER-1652 Done the proposed changes", "committedDate": "2020-01-09T17:29:59Z", "type": "commit"}, {"oid": "1a4ec70fb4a27ec63fd6def778c578add16a4fae", "url": "https://github.com/kiegroup/optaplanner/commit/1a4ec70fb4a27ec63fd6def778c578add16a4fae", "message": "PLANNER-1652 Move listener to appropriate package and rename test\n\nFixed the confusing nature of having DefaultExhaustiveSearchPhaseTest and ExhaustiveSearchTest by renaming the new test to BlackBoxExhaustiveSearchPhaseTest. In addition to that, decided to rename and move the listener to a more appropriate package.", "committedDate": "2020-01-10T10:49:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4NzA1Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/653#discussion_r365187057", "bodyText": "Please Comparator.comparing().thenComparing() instead and avoid having to create the class to begin with.", "author": "ge0ffrey", "createdAt": "2020-01-10T11:16:17Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/testdata/domain/comparable/TestdataCodeComparator.java", "diffHunk": "@@ -0,0 +1,15 @@\n+package org.optaplanner.core.impl.testdata.domain.comparable;\n+\n+import java.util.Comparator;\n+\n+import org.apache.commons.lang3.builder.CompareToBuilder;\n+import org.optaplanner.core.impl.testdata.domain.TestdataObject;\n+\n+public class TestdataCodeComparator implements Comparator<TestdataObject> {\n+\n+    public int compare(TestdataObject a, TestdataObject b) {\n+        return new CompareToBuilder()\n+                .append(a.getCode(), b.getCode())\n+                .toComparison();", "originalCommit": "1a4ec70fb4a27ec63fd6def778c578add16a4fae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTIyOTAwMA==", "url": "https://github.com/kiegroup/optaplanner/pull/653#discussion_r365229000", "bodyText": "I've created the comparator in order to have a difficulty comparator class which I can put into the @PlanningEntity(difficultyComparatorClass = TestdataCodeComparator.class) annotation above the comparable entity. Having comparable entities by difficulty is mandatory when using EntitySorterManner.DECREASING_DIFFICULTY in the ExhaustiveSearchPhaseConfig, that's why it's there. Is there a simpler way how to achieve this without needing to create a Comparator class that you explicitly put into the annotation?", "author": "michaltomco", "createdAt": "2020-01-10T13:18:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4NzA1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzNTA1OA==", "url": "https://github.com/kiegroup/optaplanner/pull/653#discussion_r367935058", "bodyText": "@ge0ffrey I agree with @michaltomco regarding the necessity of this Comparator class. The usage of the CompareToBuilder can be replaced by standard java.util.Comparator, though. See e.g. https://github.com/kiegroup/optaplanner/blob/master/optaplanner-examples/src/main/java/org/optaplanner/examples/cloudbalancing/optional/domain/CloudProcessDifficultyComparator.java#L24", "author": "rsynek", "createdAt": "2020-01-17T13:30:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4NzA1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4NzI2OA==", "url": "https://github.com/kiegroup/optaplanner/pull/653#discussion_r365187268", "bodyText": "It's named ComparableEntity but doesn't implement Comparable?", "author": "ge0ffrey", "createdAt": "2020-01-10T11:16:54Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/testdata/domain/comparable/TestdataComparableEntity.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package org.optaplanner.core.impl.testdata.domain.comparable;\n+\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+import org.optaplanner.core.impl.domain.entity.descriptor.EntityDescriptor;\n+import org.optaplanner.core.impl.domain.solution.descriptor.SolutionDescriptor;\n+import org.optaplanner.core.impl.domain.variable.descriptor.GenuineVariableDescriptor;\n+import org.optaplanner.core.impl.testdata.domain.TestdataObject;\n+\n+@PlanningEntity(difficultyComparatorClass = TestdataCodeComparator.class)\n+public class TestdataComparableEntity extends TestdataObject {", "originalCommit": "1a4ec70fb4a27ec63fd6def778c578add16a4fae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUyMzU3NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/653#discussion_r370523575", "bodyText": "Yes, it does sound a bit confusing. I've found it fitting for the use-case at that time, but it does break the Comparable naming convention. I've changed the entity to TestdataEntityWithDifficultyComparator and the solution to TestdataSolutionWithDifficultyComparatorEntity. I've wanted to fit in \"Class\" and make them into TestdataEntityWithDifficultyComparatorClass and TestdataSolutionWithDifficultyComparatorClassEntity, but decided not to, because I found them to be very lenghty even withouth it.", "author": "michaltomco", "createdAt": "2020-01-24T08:47:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4NzI2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4NzYyNg==", "url": "https://github.com/kiegroup/optaplanner/pull/653#discussion_r365187626", "bodyText": "What's a dataConfiguration? This names doesn't seem to fit the payload.", "author": "ge0ffrey", "createdAt": "2020-01-10T11:18:04Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/testdata/phase/event/TestdataStepValueListener.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package org.optaplanner.core.impl.testdata.phase.event;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.optaplanner.core.impl.phase.event.PhaseLifecycleListenerAdapter;\n+import org.optaplanner.core.impl.phase.scope.AbstractStepScope;\n+import org.optaplanner.core.impl.solver.scope.DefaultSolverScope;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataComparableEntity;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataComparableSolution;\n+\n+public class TestdataStepValueListener extends PhaseLifecycleListenerAdapter<TestdataComparableSolution> {\n+\n+    private final List<String> dataConfigurations = new ArrayList<>();", "originalCommit": "1a4ec70fb4a27ec63fd6def778c578add16a4fae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUyMzYwNA==", "url": "https://github.com/kiegroup/optaplanner/pull/653#discussion_r370523604", "bodyText": "Changed it to workingSolutions. Does it fit the payload properly?", "author": "michaltomco", "createdAt": "2020-01-24T08:47:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4NzYyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4ODU4NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/653#discussion_r365188585", "bodyText": "Looks like this is a solution state recorder.\nBut while listening to steps, you can also have a step (= winning move) recorder.\nThat only has the delta's.", "author": "ge0ffrey", "createdAt": "2020-01-10T11:20:46Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/testdata/phase/event/TestdataStepValueListener.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package org.optaplanner.core.impl.testdata.phase.event;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.optaplanner.core.impl.phase.event.PhaseLifecycleListenerAdapter;\n+import org.optaplanner.core.impl.phase.scope.AbstractStepScope;\n+import org.optaplanner.core.impl.solver.scope.DefaultSolverScope;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataComparableEntity;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataComparableSolution;\n+\n+public class TestdataStepValueListener extends PhaseLifecycleListenerAdapter<TestdataComparableSolution> {", "originalCommit": "1a4ec70fb4a27ec63fd6def778c578add16a4fae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUyMzYyMg==", "url": "https://github.com/kiegroup/optaplanner/pull/653#discussion_r370523622", "bodyText": "The way it is implemented now seems to me being similarly complex as having the winning move recorder with deltas, while being a bit more comprehensible to a human and achieving the same outcome than having the deltas instead, or am I missing something?", "author": "michaltomco", "createdAt": "2020-01-24T08:47:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NTE4ODU4NQ=="}], "type": "inlineReview"}, {"oid": "5759e92ba12fd0b04936b36246fd3cae4e273a16", "url": "https://github.com/kiegroup/optaplanner/commit/5759e92ba12fd0b04936b36246fd3cae4e273a16", "message": "PLANNER-1652 Refactor listener and replace redundant ComparatorValue", "committedDate": "2020-01-10T14:01:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzkzNTQ1NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/653#discussion_r367935455", "bodyText": "test, not tests - there is a single one, as far as I can see", "author": "rsynek", "createdAt": "2020-01-17T13:31:13Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/exhaustivesearch/BlackBoxExhaustiveSearchPhaseTest.java", "diffHunk": "@@ -0,0 +1,433 @@\n+package org.optaplanner.core.impl.exhaustivesearch;\n+\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.optaplanner.core.api.solver.Solver;\n+import org.optaplanner.core.api.solver.SolverFactory;\n+import org.optaplanner.core.config.exhaustivesearch.ExhaustiveSearchPhaseConfig;\n+import org.optaplanner.core.config.exhaustivesearch.ExhaustiveSearchType;\n+import org.optaplanner.core.config.exhaustivesearch.NodeExplorationType;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionCacheType;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionOrder;\n+import org.optaplanner.core.config.heuristic.selector.entity.EntitySelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.entity.EntitySorterManner;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.ChangeMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.value.ValueSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.value.ValueSorterManner;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+import org.optaplanner.core.impl.solver.DefaultSolver;\n+import org.optaplanner.core.impl.testdata.domain.TestdataValue;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataComparableEntity;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataComparableSolution;\n+import org.optaplanner.core.impl.testdata.phase.event.TestdataSolutionSateRecorder;\n+import org.optaplanner.core.impl.testdata.score.director.TestdataComparableDifferentValuesCalculator;\n+import org.optaplanner.core.impl.testdata.util.PlannerTestUtils;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+/**\n+ * The tests run through all available configuration combinations related to ExhaustiveSearch and compares the results", "originalCommit": "5759e92ba12fd0b04936b36246fd3cae4e273a16", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1957024db1d6b2639c04e77bfca938a24856b341", "url": "https://github.com/kiegroup/optaplanner/commit/1957024db1d6b2639c04e77bfca938a24856b341", "message": "PLANNER-1652 Rewrite comparator and singularize comment", "committedDate": "2020-01-17T15:26:40Z", "type": "commit"}, {"oid": "797608a74bd1fda636f2019743208b37455812c4", "url": "https://github.com/kiegroup/optaplanner/commit/797608a74bd1fda636f2019743208b37455812c4", "message": "PLANNER-1652 Refactor naming", "committedDate": "2020-01-24T08:32:00Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTYzNzIxMw==", "url": "https://github.com/kiegroup/optaplanner/pull/653#discussion_r371637213", "bodyText": "This naming is very confusing: it ends with \"Entity\", but it's a planning solution.\nThis naming should be consistent with it's entity.\nProposal A) for names:\n\nthe solution: TestdataDifficultyComparingSolution\nthe entity: TestdataDifficultyComparingEntity", "author": "ge0ffrey", "createdAt": "2020-01-28T07:10:26Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/testdata/domain/comparable/TestdataSolutionWithDifficultyComparatorEntity.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package org.optaplanner.core.impl.testdata.domain.comparable;\n+\n+import java.util.List;\n+\n+import org.optaplanner.core.api.domain.solution.PlanningEntityCollectionProperty;\n+import org.optaplanner.core.api.domain.solution.PlanningScore;\n+import org.optaplanner.core.api.domain.solution.PlanningSolution;\n+import org.optaplanner.core.api.domain.solution.drools.ProblemFactCollectionProperty;\n+import org.optaplanner.core.api.domain.valuerange.ValueRangeProvider;\n+import org.optaplanner.core.api.score.buildin.simple.SimpleScore;\n+import org.optaplanner.core.impl.domain.solution.descriptor.SolutionDescriptor;\n+import org.optaplanner.core.impl.testdata.domain.TestdataObject;\n+import org.optaplanner.core.impl.testdata.domain.TestdataValue;\n+\n+@PlanningSolution\n+public class TestdataSolutionWithDifficultyComparatorEntity extends TestdataObject {", "originalCommit": "797608a74bd1fda636f2019743208b37455812c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTYzNzcxNg==", "url": "https://github.com/kiegroup/optaplanner/pull/653#discussion_r371637716", "bodyText": "Why is this a Map when a Set suffices?\nThe value side is never read. There is never a \"get(key)\", only a \"contains(key\").", "author": "ge0ffrey", "createdAt": "2020-01-28T07:12:31Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/testdata/score/director/TestdataComparableDifferentValuesCalculator.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package org.optaplanner.core.impl.testdata.score.director;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.optaplanner.core.api.score.buildin.simple.SimpleScore;\n+import org.optaplanner.core.impl.score.director.easy.EasyScoreCalculator;\n+import org.optaplanner.core.impl.testdata.domain.TestdataValue;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataEntityWithDifficultyComparator;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataSolutionWithDifficultyComparatorEntity;\n+\n+public class TestdataComparableDifferentValuesCalculator implements EasyScoreCalculator<TestdataSolutionWithDifficultyComparatorEntity> {\n+\n+    @Override\n+    public SimpleScore calculateScore(TestdataSolutionWithDifficultyComparatorEntity solution) {\n+        int score = 0;\n+        Map<TestdataValue, Integer> alreadyUsedValues = new HashMap<>();", "originalCommit": "797608a74bd1fda636f2019743208b37455812c4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ5OTUyNQ==", "url": "https://github.com/kiegroup/optaplanner/pull/653#discussion_r373499525", "bodyText": "This one was a leftover from when I was trying to make a more complex Calculator in order to make the solver do more different steps, but after trying out a simple Set-based one and not seeing any benefit in having the previous one, I've changed it to Set as you've recommended, thank you.", "author": "michaltomco", "createdAt": "2020-01-31T14:15:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTYzNzcxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTYzNzkxMQ==", "url": "https://github.com/kiegroup/optaplanner/pull/653#discussion_r371637911", "bodyText": "Does not belong in package \"testdata\", that package is reserved for domain objects.\nPut it near the test, either as a static class inside the test, or next to it.", "author": "ge0ffrey", "createdAt": "2020-01-28T07:13:18Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/testdata/score/director/TestdataComparableDifferentValuesCalculator.java", "diffHunk": "@@ -0,0 +1,34 @@\n+package org.optaplanner.core.impl.testdata.score.director;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.optaplanner.core.api.score.buildin.simple.SimpleScore;\n+import org.optaplanner.core.impl.score.director.easy.EasyScoreCalculator;\n+import org.optaplanner.core.impl.testdata.domain.TestdataValue;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataEntityWithDifficultyComparator;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataSolutionWithDifficultyComparatorEntity;\n+\n+public class TestdataComparableDifferentValuesCalculator implements EasyScoreCalculator<TestdataSolutionWithDifficultyComparatorEntity> {", "originalCommit": "797608a74bd1fda636f2019743208b37455812c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTYzNzk3OA==", "url": "https://github.com/kiegroup/optaplanner/pull/653#discussion_r371637978", "bodyText": "This doesn't belong in the \"testdata\" package because it's not a domain object.\nPut it near the test (see later comment).", "author": "ge0ffrey", "createdAt": "2020-01-28T07:13:34Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/testdata/phase/event/TestdataSolutionSateRecorder.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package org.optaplanner.core.impl.testdata.phase.event;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import org.optaplanner.core.impl.phase.event.PhaseLifecycleListenerAdapter;\n+import org.optaplanner.core.impl.phase.scope.AbstractStepScope;\n+import org.optaplanner.core.impl.solver.scope.DefaultSolverScope;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataEntityWithDifficultyComparator;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataSolutionWithDifficultyComparatorEntity;\n+\n+public class TestdataSolutionSateRecorder extends PhaseLifecycleListenerAdapter<TestdataSolutionWithDifficultyComparatorEntity> {", "originalCommit": "797608a74bd1fda636f2019743208b37455812c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MTYzODIxMw==", "url": "https://github.com/kiegroup/optaplanner/pull/653#discussion_r371638213", "bodyText": "This naming is a bit confusing. It ends with \"Comparator\", so is it a Comparator?\nNo, it's a entity. See other comment for rename suggestion.", "author": "ge0ffrey", "createdAt": "2020-01-28T07:14:28Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/testdata/domain/comparable/TestdataEntityWithDifficultyComparator.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package org.optaplanner.core.impl.testdata.domain.comparable;\n+\n+import org.optaplanner.core.api.domain.entity.PlanningEntity;\n+import org.optaplanner.core.api.domain.variable.PlanningVariable;\n+import org.optaplanner.core.impl.domain.entity.descriptor.EntityDescriptor;\n+import org.optaplanner.core.impl.domain.solution.descriptor.SolutionDescriptor;\n+import org.optaplanner.core.impl.domain.variable.descriptor.GenuineVariableDescriptor;\n+import org.optaplanner.core.impl.testdata.domain.TestdataObject;\n+import org.optaplanner.core.impl.testdata.domain.TestdataValue;\n+\n+@PlanningEntity(difficultyComparatorClass = TestdataCodeComparator.class)\n+public class TestdataEntityWithDifficultyComparator extends TestdataObject {", "originalCommit": "797608a74bd1fda636f2019743208b37455812c4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6ec140f7cdce0970a96cd0b39837510c77d4f701", "url": "https://github.com/kiegroup/optaplanner/commit/6ec140f7cdce0970a96cd0b39837510c77d4f701", "message": "PLANNER-1652 Rename and simplify comparator", "committedDate": "2020-01-31T12:58:48Z", "type": "commit"}, {"oid": "04154d3389b4f949c1352ab49c3a438b20134231", "url": "https://github.com/kiegroup/optaplanner/commit/04154d3389b4f949c1352ab49c3a438b20134231", "message": "PLANNER-1652 Simplify and move comparator class into the test class", "committedDate": "2020-01-31T13:57:32Z", "type": "commit"}, {"oid": "25776746c846cdbaa482b18671a0d77908be04cf", "url": "https://github.com/kiegroup/optaplanner/commit/25776746c846cdbaa482b18671a0d77908be04cf", "message": "PLANNER-1652 Move TestdataSolutionStateRecorder to test class", "committedDate": "2020-01-31T14:02:24Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NjI4MTY4NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/653#discussion_r376281685", "bodyText": "Rename to valueSet (or alreadyUsedValueSet)", "author": "ge0ffrey", "createdAt": "2020-02-07T09:06:28Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/exhaustivesearch/BlackBoxExhaustiveSearchPhaseTest.java", "diffHunk": "@@ -0,0 +1,490 @@\n+package org.optaplanner.core.impl.exhaustivesearch;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.assertj.core.api.Assertions;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.optaplanner.core.api.score.buildin.simple.SimpleScore;\n+import org.optaplanner.core.api.solver.Solver;\n+import org.optaplanner.core.api.solver.SolverFactory;\n+import org.optaplanner.core.config.exhaustivesearch.ExhaustiveSearchPhaseConfig;\n+import org.optaplanner.core.config.exhaustivesearch.ExhaustiveSearchType;\n+import org.optaplanner.core.config.exhaustivesearch.NodeExplorationType;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionCacheType;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionOrder;\n+import org.optaplanner.core.config.heuristic.selector.entity.EntitySelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.entity.EntitySorterManner;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.ChangeMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.value.ValueSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.value.ValueSorterManner;\n+import org.optaplanner.core.config.score.director.ScoreDirectorFactoryConfig;\n+import org.optaplanner.core.config.solver.SolverConfig;\n+import org.optaplanner.core.config.solver.termination.TerminationConfig;\n+import org.optaplanner.core.impl.phase.event.PhaseLifecycleListenerAdapter;\n+import org.optaplanner.core.impl.phase.scope.AbstractStepScope;\n+import org.optaplanner.core.impl.score.director.easy.EasyScoreCalculator;\n+import org.optaplanner.core.impl.solver.DefaultSolver;\n+import org.optaplanner.core.impl.solver.scope.DefaultSolverScope;\n+import org.optaplanner.core.impl.testdata.domain.TestdataValue;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataDifficultyComparingEntity;\n+import org.optaplanner.core.impl.testdata.domain.comparable.TestdataDifficultyComparingSolution;\n+import org.optaplanner.core.impl.testdata.util.PlannerTestUtils;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+/**\n+ * The test runs through all available configuration combinations related to ExhaustiveSearch and compares the results\n+ * with manually calculated data. It tries to find the best solution for 3 values and 4 entities. When the same value\n+ * is held by different entities, the score is reduced by 1.\n+ * <p>\n+ * A solution state is represented by a string containing 4 characters representing entity values. Uninitialized\n+ * entities are marked by '-' character. (e.g. \"1-21\" means that the first and the fourth entity have value 1,\n+ * the second entity doesn't have a value and the third entity has 2, the score is -1) The score is reduced for\n+ * every duplicate present. (meaning a solution of 1111 has the score of -4)\n+ */\n+@RunWith(Parameterized.class)\n+public class BlackBoxExhaustiveSearchPhaseTest {\n+\n+    private final ExhaustiveSearchType exhaustiveSearchType;\n+    private final NodeExplorationType nodeExplorationType;\n+    private final EntitySorterManner entitySorterManner;\n+    private final ValueSorterManner valueSorterManner;\n+    private final List<String> steps;\n+    private TestdataDifficultyComparingSolution solution;\n+    private SolverConfig solverConfig;\n+\n+    public BlackBoxExhaustiveSearchPhaseTest(ExhaustiveSearchType exhaustiveSearchType, NodeExplorationType nodeExplorationType,\n+                                             EntitySorterManner entitySorterManner, ValueSorterManner valueSorterManner, List<String> steps) {\n+        this.exhaustiveSearchType = exhaustiveSearchType;\n+        this.nodeExplorationType = nodeExplorationType;\n+        this.entitySorterManner = entitySorterManner;\n+        this.valueSorterManner = valueSorterManner;\n+        this.steps = steps;\n+    }\n+\n+    /**\n+     * Initialize combination of input parameters.\n+     *\n+     * @return collection of combination of input parameters\n+     */\n+    @Parameterized.Parameters(name = \"{0}, NodeExplorationType-{1}, EntitySorterManner-{2}, ValueSorterManner-{3}\")\n+    public static Collection<Object[]> params() {\n+        return Stream.concat(getBranchAndBoundConfigs(), getBruteForceConfigs()).collect(Collectors.toList());\n+    }\n+\n+    private static Stream<Object[]> getBranchAndBoundConfigs() {\n+        return Stream.of(getBranchAndBoundDepthFirstConfigs(),\n+                         getBranchAndBoundBreadthFirstConfigs(),\n+                         getBranchAndBoundScoreFirstConfigs(),\n+                         getBranchAndBoundOptimisticBoundFirstConfigs(),\n+                         getBranchAndBoundOriginalOrderConfigs())\n+                .flatMap(i -> i);\n+    }\n+\n+    private static Stream<Object[]> getBranchAndBoundDepthFirstConfigs() {\n+        return Stream.of(\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.DEPTH_FIRST,\n+                        EntitySorterManner.NONE,\n+                        ValueSorterManner.NONE,\n+                        Arrays.asList(\"----\", \"1---\", \"13--\", \"132-\", \"13-2\", \"12--\", \"123-\", \"12-3\", \"1-3-\", \"123-\", \"1321\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.DEPTH_FIRST,\n+                        EntitySorterManner.NONE,\n+                        ValueSorterManner.DECREASING_STRENGTH,\n+                        Arrays.asList(\"----\", \"3---\", \"32--\", \"321-\", \"32-1\", \"31--\", \"312-\", \"31-2\", \"3-2-\", \"312-\", \"3213\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.DEPTH_FIRST,\n+                        EntitySorterManner.NONE,\n+                        ValueSorterManner.INCREASING_STRENGTH,\n+                        Arrays.asList(\"----\", \"1---\", \"12--\", \"123-\", \"12-3\", \"13--\", \"132-\", \"13-2\", \"1-2-\", \"132-\", \"1231\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.DEPTH_FIRST,\n+                        EntitySorterManner.DECREASING_DIFFICULTY,\n+                        ValueSorterManner.NONE,\n+                        Arrays.asList(\"----\", \"1---\", \"1-3-\", \"123-\", \"1-32\", \"1-2-\", \"132-\", \"1-23\", \"13--\", \"132-\", \"1231\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.DEPTH_FIRST,\n+                        EntitySorterManner.DECREASING_DIFFICULTY,\n+                        ValueSorterManner.DECREASING_STRENGTH,\n+                        Arrays.asList(\"----\", \"3---\", \"3-2-\", \"312-\", \"3-21\", \"3-1-\", \"321-\", \"3-12\", \"32--\", \"321-\", \"3123\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.DEPTH_FIRST,\n+                        EntitySorterManner.DECREASING_DIFFICULTY,\n+                        ValueSorterManner.INCREASING_STRENGTH,\n+                        Arrays.asList(\"----\", \"1---\", \"1-2-\", \"132-\", \"1-23\", \"1-3-\", \"123-\", \"1-32\", \"12--\", \"123-\", \"1321\"))\n+        );\n+    }\n+\n+    private static Stream<Object[]> getBranchAndBoundBreadthFirstConfigs() {\n+        return Stream.of(\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.BREADTH_FIRST,\n+                        EntitySorterManner.NONE,\n+                        ValueSorterManner.NONE,\n+                        Arrays.asList(\"----\", \"1---\", \"3---\", \"2---\", \"-1--\", \"-3--\", \"-2--\", \"--1-\", \"--3-\", \"--2-\", \"----\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.BREADTH_FIRST,\n+                        EntitySorterManner.NONE,\n+                        ValueSorterManner.DECREASING_STRENGTH,\n+                        Arrays.asList(\"----\", \"3---\", \"2---\", \"1---\", \"-3--\", \"-2--\", \"-1--\", \"--3-\", \"--2-\", \"--1-\", \"----\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.BREADTH_FIRST,\n+                        EntitySorterManner.NONE,\n+                        ValueSorterManner.INCREASING_STRENGTH,\n+                        Arrays.asList(\"----\", \"1---\", \"2---\", \"3---\", \"-1--\", \"-2--\", \"-3--\", \"--1-\", \"--2-\", \"--3-\", \"----\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.BREADTH_FIRST,\n+                        EntitySorterManner.DECREASING_DIFFICULTY,\n+                        ValueSorterManner.NONE,\n+                        Arrays.asList(\"----\", \"1---\", \"3---\", \"2---\", \"--1-\", \"--3-\", \"--2-\", \"-1--\", \"-3--\", \"-2--\", \"----\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.BREADTH_FIRST,\n+                        EntitySorterManner.DECREASING_DIFFICULTY,\n+                        ValueSorterManner.DECREASING_STRENGTH,\n+                        Arrays.asList(\"----\", \"3---\", \"2---\", \"1---\", \"--3-\", \"--2-\", \"--1-\", \"-3--\", \"-2--\", \"-1--\", \"----\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.BREADTH_FIRST,\n+                        EntitySorterManner.DECREASING_DIFFICULTY,\n+                        ValueSorterManner.INCREASING_STRENGTH,\n+                        Arrays.asList(\"----\", \"1---\", \"2---\", \"3---\", \"--1-\", \"--2-\", \"--3-\", \"-1--\", \"-2--\", \"-3--\", \"----\"))\n+        );\n+    }\n+\n+    private static Stream<Object[]> getBranchAndBoundScoreFirstConfigs() {\n+        return Stream.of(\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.SCORE_FIRST,\n+                        EntitySorterManner.NONE,\n+                        ValueSorterManner.NONE,\n+                        Arrays.asList(\"----\", \"1---\", \"13--\", \"132-\", \"13-2\", \"12--\", \"123-\", \"12-3\", \"1-3-\", \"123-\", \"1321\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.SCORE_FIRST,\n+                        EntitySorterManner.NONE,\n+                        ValueSorterManner.DECREASING_STRENGTH,\n+                        Arrays.asList(\"----\", \"3---\", \"32--\", \"321-\", \"32-1\", \"31--\", \"312-\", \"31-2\", \"3-2-\", \"312-\", \"3213\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.SCORE_FIRST,\n+                        EntitySorterManner.NONE,\n+                        ValueSorterManner.INCREASING_STRENGTH,\n+                        Arrays.asList(\"----\", \"1---\", \"12--\", \"123-\", \"12-3\", \"13--\", \"132-\", \"13-2\", \"1-2-\", \"132-\", \"1231\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.SCORE_FIRST,\n+                        EntitySorterManner.DECREASING_DIFFICULTY,\n+                        ValueSorterManner.NONE,\n+                        Arrays.asList(\"----\", \"1---\", \"1-3-\", \"123-\", \"1-32\", \"1-2-\", \"132-\", \"1-23\", \"13--\", \"132-\", \"1231\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.SCORE_FIRST,\n+                        EntitySorterManner.DECREASING_DIFFICULTY,\n+                        ValueSorterManner.DECREASING_STRENGTH,\n+                        Arrays.asList(\"----\", \"3---\", \"3-2-\", \"312-\", \"3-21\", \"3-1-\", \"321-\", \"3-12\", \"32--\", \"321-\", \"3123\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.SCORE_FIRST,\n+                        EntitySorterManner.DECREASING_DIFFICULTY,\n+                        ValueSorterManner.INCREASING_STRENGTH,\n+                        Arrays.asList(\"----\", \"1---\", \"1-2-\", \"132-\", \"1-23\", \"1-3-\", \"123-\", \"1-32\", \"12--\", \"123-\", \"1321\"))\n+        );\n+    }\n+\n+    private static Stream<Object[]> getBranchAndBoundOptimisticBoundFirstConfigs() {\n+        return Stream.of(\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.OPTIMISTIC_BOUND_FIRST,\n+                        EntitySorterManner.NONE,\n+                        ValueSorterManner.NONE,\n+                        Arrays.asList(\"----\", \"1---\", \"13--\", \"132-\", \"13-2\", \"12--\", \"123-\", \"12-3\", \"1-3-\", \"123-\", \"1321\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.OPTIMISTIC_BOUND_FIRST,\n+                        EntitySorterManner.NONE,\n+                        ValueSorterManner.DECREASING_STRENGTH,\n+                        Arrays.asList(\"----\", \"3---\", \"32--\", \"321-\", \"32-1\", \"31--\", \"312-\", \"31-2\", \"3-2-\", \"312-\", \"3213\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.OPTIMISTIC_BOUND_FIRST,\n+                        EntitySorterManner.NONE,\n+                        ValueSorterManner.INCREASING_STRENGTH,\n+                        Arrays.asList(\"----\", \"1---\", \"12--\", \"123-\", \"12-3\", \"13--\", \"132-\", \"13-2\", \"1-2-\", \"132-\", \"1231\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.OPTIMISTIC_BOUND_FIRST,\n+                        EntitySorterManner.DECREASING_DIFFICULTY,\n+                        ValueSorterManner.NONE,\n+                        Arrays.asList(\"----\", \"1---\", \"1-3-\", \"123-\", \"1-32\", \"1-2-\", \"132-\", \"1-23\", \"13--\", \"132-\", \"1231\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.OPTIMISTIC_BOUND_FIRST,\n+                        EntitySorterManner.DECREASING_DIFFICULTY,\n+                        ValueSorterManner.DECREASING_STRENGTH,\n+                        Arrays.asList(\"----\", \"3---\", \"3-2-\", \"312-\", \"3-21\", \"3-1-\", \"321-\", \"3-12\", \"32--\", \"321-\", \"3123\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.OPTIMISTIC_BOUND_FIRST,\n+                        EntitySorterManner.DECREASING_DIFFICULTY,\n+                        ValueSorterManner.INCREASING_STRENGTH,\n+                        Arrays.asList(\"----\", \"1---\", \"1-2-\", \"132-\", \"1-23\", \"1-3-\", \"123-\", \"1-32\", \"12--\", \"123-\", \"1321\")));\n+    }\n+\n+    private static Stream<Object[]> getBranchAndBoundOriginalOrderConfigs() {\n+        return Stream.of(\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.ORIGINAL_ORDER,\n+                        EntitySorterManner.NONE,\n+                        ValueSorterManner.NONE,\n+                        Arrays.asList(\"----\", \"1---\", \"11--\", \"111-\", \"113-\", \"13--\", \"132-\", \"13-2\", \"12--\", \"123-\", \"1132\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.ORIGINAL_ORDER,\n+                        EntitySorterManner.NONE,\n+                        ValueSorterManner.DECREASING_STRENGTH,\n+                        Arrays.asList(\"----\", \"3---\", \"33--\", \"333-\", \"332-\", \"32--\", \"321-\", \"32-1\", \"31--\", \"312-\", \"3321\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.ORIGINAL_ORDER,\n+                        EntitySorterManner.NONE,\n+                        ValueSorterManner.INCREASING_STRENGTH,\n+                        Arrays.asList(\"----\", \"1---\", \"11--\", \"111-\", \"112-\", \"12--\", \"123-\", \"12-3\", \"13--\", \"132-\", \"1123\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.ORIGINAL_ORDER,\n+                        EntitySorterManner.DECREASING_DIFFICULTY,\n+                        ValueSorterManner.NONE,\n+                        Arrays.asList(\"----\", \"1---\", \"1-1-\", \"111-\", \"131-\", \"1-3-\", \"123-\", \"1-32\", \"1-2-\", \"132-\", \"1312\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.ORIGINAL_ORDER,\n+                        EntitySorterManner.DECREASING_DIFFICULTY,\n+                        ValueSorterManner.DECREASING_STRENGTH,\n+                        Arrays.asList(\"----\", \"3---\", \"3-3-\", \"333-\", \"323-\", \"3-2-\", \"312-\", \"3-21\", \"3-1-\", \"321-\", \"3231\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRANCH_AND_BOUND,\n+                        NodeExplorationType.ORIGINAL_ORDER,\n+                        EntitySorterManner.DECREASING_DIFFICULTY,\n+                        ValueSorterManner.INCREASING_STRENGTH,\n+                        Arrays.asList(\"----\", \"1---\", \"1-1-\", \"111-\", \"121-\", \"1-2-\", \"132-\", \"1-23\", \"1-3-\", \"123-\", \"1213\"))\n+        );\n+    }\n+\n+    private static Stream<Object[]> getBruteForceConfigs() {\n+        return Stream.concat(getBruteForceLegalConfigs(), getBruteForceIllegalConfigs());\n+    }\n+\n+    private static Stream<Object[]> getBruteForceLegalConfigs() {\n+        return Stream.of(\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRUTE_FORCE,\n+                        null,\n+                        EntitySorterManner.NONE,\n+                        ValueSorterManner.NONE,\n+                        Arrays.asList(\"----\", \"1---\", \"11--\", \"111-\", \"113-\", \"112-\", \"11-1\", \"11-3\", \"11-2\", \"13--\", \"1132\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRUTE_FORCE,\n+                        null,\n+                        EntitySorterManner.NONE,\n+                        ValueSorterManner.DECREASING_STRENGTH,\n+                        Arrays.asList(\"----\", \"3---\", \"33--\", \"333-\", \"332-\", \"331-\", \"33-3\", \"33-2\", \"33-1\", \"32--\", \"3321\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRUTE_FORCE,\n+                        null,\n+                        EntitySorterManner.NONE,\n+                        ValueSorterManner.INCREASING_STRENGTH,\n+                        Arrays.asList(\"----\", \"1---\", \"11--\", \"111-\", \"112-\", \"113-\", \"11-1\", \"11-2\", \"11-3\", \"12--\", \"1123\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRUTE_FORCE,\n+                        null,\n+                        EntitySorterManner.DECREASING_DIFFICULTY,\n+                        ValueSorterManner.NONE,\n+                        Arrays.asList(\"----\", \"1---\", \"1-1-\", \"111-\", \"131-\", \"121-\", \"1-11\", \"1-13\", \"1-12\", \"1-3-\", \"1312\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRUTE_FORCE,\n+                        null,\n+                        EntitySorterManner.DECREASING_DIFFICULTY,\n+                        ValueSorterManner.DECREASING_STRENGTH,\n+                        Arrays.asList(\"----\", \"3---\", \"3-3-\", \"333-\", \"323-\", \"313-\", \"3-33\", \"3-32\", \"3-31\", \"3-2-\", \"3231\")),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRUTE_FORCE,\n+                        null,\n+                        EntitySorterManner.DECREASING_DIFFICULTY,\n+                        ValueSorterManner.INCREASING_STRENGTH,\n+                        Arrays.asList(\"----\", \"1---\", \"1-1-\", \"111-\", \"121-\", \"131-\", \"1-11\", \"1-12\", \"1-13\", \"1-2-\", \"1213\"))\n+        );\n+    }\n+\n+    private static Stream<Object[]> getBruteForceIllegalConfigs() {\n+        return Stream.of(\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRUTE_FORCE,\n+                        NodeExplorationType.DEPTH_FIRST,\n+                        EntitySorterManner.DECREASING_DIFFICULTY,\n+                        ValueSorterManner.DECREASING_STRENGTH,\n+                        null),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRUTE_FORCE,\n+                        NodeExplorationType.BREADTH_FIRST,\n+                        EntitySorterManner.DECREASING_DIFFICULTY,\n+                        ValueSorterManner.DECREASING_STRENGTH,\n+                        null),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRUTE_FORCE,\n+                        NodeExplorationType.SCORE_FIRST,\n+                        EntitySorterManner.DECREASING_DIFFICULTY,\n+                        ValueSorterManner.DECREASING_STRENGTH,\n+                        null),\n+                toObjectArray(\n+                        ExhaustiveSearchType.BRUTE_FORCE,\n+                        NodeExplorationType.OPTIMISTIC_BOUND_FIRST,\n+                        EntitySorterManner.DECREASING_DIFFICULTY,\n+                        ValueSorterManner.DECREASING_STRENGTH,\n+                        null)\n+        );\n+    }\n+\n+    private static Object[] toObjectArray(Object... parameters) {\n+        return parameters;\n+    }\n+\n+    @Before\n+    public void setUp() {\n+        solverConfig = PlannerTestUtils.buildSolverConfig(\n+                TestdataDifficultyComparingSolution.class, TestdataDifficultyComparingEntity.class);\n+\n+        EntitySelectorConfig entitySelectorConfig = new EntitySelectorConfig();\n+        entitySelectorConfig.setSelectionOrder(SelectionOrder.SORTED);\n+        entitySelectorConfig.setCacheType(SelectionCacheType.PHASE);\n+        entitySelectorConfig.setSorterManner(entitySorterManner);\n+\n+        ValueSelectorConfig valueSelectorConfig = new ValueSelectorConfig();\n+        valueSelectorConfig.setSelectionOrder(SelectionOrder.SORTED);\n+        valueSelectorConfig.setCacheType(SelectionCacheType.PHASE);\n+        valueSelectorConfig.setSorterManner(valueSorterManner);\n+\n+        ChangeMoveSelectorConfig moveSelectorConfig = new ChangeMoveSelectorConfig();\n+        moveSelectorConfig.setEntitySelectorConfig(entitySelectorConfig);\n+        moveSelectorConfig.setValueSelectorConfig(valueSelectorConfig);\n+\n+        ExhaustiveSearchPhaseConfig exhaustiveSearchPhaseConfig = new ExhaustiveSearchPhaseConfig();\n+        exhaustiveSearchPhaseConfig.setExhaustiveSearchType(exhaustiveSearchType);\n+        exhaustiveSearchPhaseConfig.setNodeExplorationType(nodeExplorationType);\n+        exhaustiveSearchPhaseConfig.setMoveSelectorConfig(moveSelectorConfig);\n+        exhaustiveSearchPhaseConfig.setTerminationConfig(new TerminationConfig().withStepCountLimit(10));\n+\n+        solverConfig.setPhaseConfigList(Collections.singletonList(exhaustiveSearchPhaseConfig));\n+        solverConfig.setScoreDirectorFactoryConfig(new ScoreDirectorFactoryConfig()\n+                                                           .withEasyScoreCalculatorClass(TestdataComparableDifferentValuesCalculator.class)\n+                                                           .withInitializingScoreTrend(\"ONLY_DOWN\"));\n+\n+        solution = new TestdataDifficultyComparingSolution(\"solution\");\n+        // Intentionally not sorted, the string is used for sorting in cases it applies.\n+        solution.setEntityList(Arrays.asList(new TestdataDifficultyComparingEntity(\"entity4\"),\n+                                             new TestdataDifficultyComparingEntity(\"entity2\"),\n+                                             new TestdataDifficultyComparingEntity(\"entity3\"),\n+                                             new TestdataDifficultyComparingEntity(\"entity1\")));\n+        solution.setValueList(Arrays.asList(new TestdataValue(\"1\"),\n+                                            new TestdataValue(\"3\"),\n+                                            new TestdataValue(\"2\")));\n+    }\n+\n+    @Test\n+    public void verifyExhaustiveSearchSteps() {\n+        SolverFactory<TestdataDifficultyComparingSolution> solverFactory = SolverFactory.create(solverConfig);\n+\n+        if (exhaustiveSearchType == ExhaustiveSearchType.BRUTE_FORCE && nodeExplorationType != null) {\n+            Assertions.assertThatIllegalArgumentException()\n+                    .isThrownBy(solverFactory::buildSolver)\n+                    .withMessage(\"The phaseConfig (ExhaustiveSearchPhaseConfig) has an \"\n+                                         + \"nodeExplorationType (\" + nodeExplorationType.name()\n+                                         + \") which is not compatible with its exhaustiveSearchType (BRUTE_FORCE).\");\n+        } else {\n+            Solver<TestdataDifficultyComparingSolution> solver = solverFactory.buildSolver();\n+\n+            TestdataSolutionStateRecorder listener = new TestdataSolutionStateRecorder();\n+            ((DefaultSolver<TestdataDifficultyComparingSolution>) solver).addPhaseLifecycleListener(listener);\n+\n+            solver.solve(solution);\n+\n+            assertThat(listener.getWorkingSolutions()).containsExactlyElementsOf(steps);\n+        }\n+    }\n+\n+    /**\n+     * This class calculates the score of a solution by penalizing repeated value occurrences held by entities.\n+     */\n+    public static class TestdataComparableDifferentValuesCalculator implements EasyScoreCalculator<TestdataDifficultyComparingSolution> {\n+\n+        @Override\n+        public SimpleScore calculateScore(TestdataDifficultyComparingSolution solution) {\n+            int score = 0;\n+            Set<TestdataValue> alreadyUsedValues = new HashSet<>();", "originalCommit": "25776746c846cdbaa482b18671a0d77908be04cf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}