{"pr_number": 1078, "pr_title": "PLANNER-2163 Use Drools groupBy node throughout CS-D", "pr_createdAt": "2020-12-28T09:00:41Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/1078", "timeline": [{"oid": "a9070bdd50a30e61eda9025155328e054d66b9bd", "url": "https://github.com/kiegroup/optaplanner/commit/a9070bdd50a30e61eda9025155328e054d66b9bd", "message": "Remove groupByCount", "committedDate": "2020-12-28T09:32:47Z", "type": "forcePushed"}, {"oid": "113ecff0e3b4e8a62cbb3304474b55324f274c11", "url": "https://github.com/kiegroup/optaplanner/commit/113ecff0e3b4e8a62cbb3304474b55324f274c11", "message": "Disable KieBase mutability", "committedDate": "2020-12-30T17:26:59Z", "type": "forcePushed"}, {"oid": "cf4d87031e245ea1bcba963e9a5613ea271d944f", "url": "https://github.com/kiegroup/optaplanner/commit/cf4d87031e245ea1bcba963e9a5613ea271d944f", "message": "Plug LHS into assemblers", "committedDate": "2021-01-11T10:32:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjQ3MDE4MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1078#discussion_r556470181", "bodyText": "Although technically unrelated, this change improves DRL performance by a couple percentage points, and I was doing the same thing for CS-D, so I decided to introduce it here, too.", "author": "triceo", "createdAt": "2021-01-13T12:02:39Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/director/ScoreDirectorFactoryFactory.java", "diffHunk": "@@ -268,7 +269,7 @@ private void checkMultipleScoreDirectorFactoryTypes(EasyScoreDirectorFactory eas\n         }\n \n         try {\n-            KieBase kieBase = kieHelper.build(ExecutableModelProject.class);\n+            KieBase kieBase = kieHelper.build(ExecutableModelProject.class, KieBaseMutabilityOption.DISABLED);", "originalCommit": "b472bff8831d224d02fc513c2c2f64803a20f20f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6437804ce969d119b88a8894212d49760cc6bddd", "url": "https://github.com/kiegroup/optaplanner/commit/6437804ce969d119b88a8894212d49760cc6bddd", "message": "Remove the old groupBy implementation", "committedDate": "2021-01-13T13:51:10Z", "type": "commit"}, {"oid": "1f56016e110a3909e98516c5147a930ce002a7a3", "url": "https://github.com/kiegroup/optaplanner/commit/1f56016e110a3909e98516c5147a930ce002a7a3", "message": "Disable KieBase mutability", "committedDate": "2021-01-13T13:51:10Z", "type": "commit"}, {"oid": "e63eeba09b8ca39401b18f2fa1217155eacbab41", "url": "https://github.com/kiegroup/optaplanner/commit/e63eeba09b8ca39401b18f2fa1217155eacbab41", "message": "No more expectedGroupByCount", "committedDate": "2021-01-13T13:51:10Z", "type": "commit"}, {"oid": "d8b39f89b2d22733249c0045cf84d7e835f09b79", "url": "https://github.com/kiegroup/optaplanner/commit/d8b39f89b2d22733249c0045cf84d7e835f09b79", "message": "Implement the left hand sides", "committedDate": "2021-01-13T13:51:10Z", "type": "commit"}, {"oid": "ccdc5c34ff47798f58478cfe59d5a4cfe51eb6b6", "url": "https://github.com/kiegroup/optaplanner/commit/ccdc5c34ff47798f58478cfe59d5a4cfe51eb6b6", "message": "Plug LHS into assemblers", "committedDate": "2021-01-13T13:51:10Z", "type": "commit"}, {"oid": "f4a811e5e3073e05b2a2c9ce696ba4c9ce04fb3e", "url": "https://github.com/kiegroup/optaplanner/commit/f4a811e5e3073e05b2a2c9ce696ba4c9ce04fb3e", "message": "Remove alpha indexing", "committedDate": "2021-01-13T13:51:10Z", "type": "commit"}, {"oid": "c42ae01d15cc485ec220acdc27cc303ee104a58a", "url": "https://github.com/kiegroup/optaplanner/commit/c42ae01d15cc485ec220acdc27cc303ee104a58a", "message": "Fix imports", "committedDate": "2021-01-13T13:51:11Z", "type": "commit"}, {"oid": "3da19a461dbcf4c5249726d5bea322ee1e0574a1", "url": "https://github.com/kiegroup/optaplanner/commit/3da19a461dbcf4c5249726d5bea322ee1e0574a1", "message": "Try to get to Sonar", "committedDate": "2021-01-13T13:51:11Z", "type": "commit"}, {"oid": "d61cd849a477cc81a26b3a235d28e68b62974cb3", "url": "https://github.com/kiegroup/optaplanner/commit/d61cd849a477cc81a26b3a235d28e68b62974cb3", "message": "Actually try to get to Sonar", "committedDate": "2021-01-13T13:51:11Z", "type": "commit"}, {"oid": "3360653b81a0f117f6dfd1b1734f45245f837ab5", "url": "https://github.com/kiegroup/optaplanner/commit/3360653b81a0f117f6dfd1b1734f45245f837ab5", "message": "AbstractGroupByMutator is no more", "committedDate": "2021-01-13T13:51:11Z", "type": "commit"}, {"oid": "c3a4d5ef9c6c88059858a4938ba48f8cf2402438", "url": "https://github.com/kiegroup/optaplanner/commit/c3a4d5ef9c6c88059858a4938ba48f8cf2402438", "message": "Remove existence mutators", "committedDate": "2021-01-13T13:51:11Z", "type": "commit"}, {"oid": "29e815d6444043caabe6bf47e061b0142c61954e", "url": "https://github.com/kiegroup/optaplanner/commit/29e815d6444043caabe6bf47e061b0142c61954e", "message": "Remove join mutators", "committedDate": "2021-01-13T13:51:11Z", "type": "commit"}, {"oid": "f845c5efc77b6a7b97b7b237bf4de2057100b9ed", "url": "https://github.com/kiegroup/optaplanner/commit/f845c5efc77b6a7b97b7b237bf4de2057100b9ed", "message": "Unify grouping mutators", "committedDate": "2021-01-13T13:51:11Z", "type": "commit"}, {"oid": "bef90096048d06292d7d6e4591b865857fb4d0a3", "url": "https://github.com/kiegroup/optaplanner/commit/bef90096048d06292d7d6e4591b865857fb4d0a3", "message": "Remove 01 mutator", "committedDate": "2021-01-13T13:51:11Z", "type": "commit"}, {"oid": "075907f995ea07b5d6ff393290d39e5f2befd41a", "url": "https://github.com/kiegroup/optaplanner/commit/075907f995ea07b5d6ff393290d39e5f2befd41a", "message": "Remove 10 mutator", "committedDate": "2021-01-13T13:51:12Z", "type": "commit"}, {"oid": "bce4ea4968e82fd657535c556125d287260c559a", "url": "https://github.com/kiegroup/optaplanner/commit/bce4ea4968e82fd657535c556125d287260c559a", "message": "Remove 11 mutator", "committedDate": "2021-01-13T13:51:12Z", "type": "commit"}, {"oid": "b6334c174705559926d0880400b17ff30d6e4a0a", "url": "https://github.com/kiegroup/optaplanner/commit/b6334c174705559926d0880400b17ff30d6e4a0a", "message": "Remove 20 mutator", "committedDate": "2021-01-13T13:51:12Z", "type": "commit"}, {"oid": "442d260d75537cb1d01d267d35e87fe9a319fab3", "url": "https://github.com/kiegroup/optaplanner/commit/442d260d75537cb1d01d267d35e87fe9a319fab3", "message": "Remove 21 mutator", "committedDate": "2021-01-13T13:51:12Z", "type": "commit"}, {"oid": "dcfdfa6e43d7fb5fa877316b1b3182db4d3c9f6b", "url": "https://github.com/kiegroup/optaplanner/commit/dcfdfa6e43d7fb5fa877316b1b3182db4d3c9f6b", "message": "All mutators are gone", "committedDate": "2021-01-13T13:51:12Z", "type": "commit"}, {"oid": "be645d5e67e96e95b30b899e6dd2fa7fac86492d", "url": "https://github.com/kiegroup/optaplanner/commit/be645d5e67e96e95b30b899e6dd2fa7fac86492d", "message": "Formatting", "committedDate": "2021-01-13T13:51:12Z", "type": "commit"}, {"oid": "661390f9c1055bb0f1b571d322ad6d7b4f8b4043", "url": "https://github.com/kiegroup/optaplanner/commit/661390f9c1055bb0f1b571d322ad6d7b4f8b4043", "message": "Nodes move to the rules package", "committedDate": "2021-01-13T13:51:12Z", "type": "commit"}, {"oid": "52a9f4c2f9ab2036b0fd7792a43352a3af3defb1", "url": "https://github.com/kiegroup/optaplanner/commit/52a9f4c2f9ab2036b0fd7792a43352a3af3defb1", "message": "Nodes get left hand side", "committedDate": "2021-01-13T13:51:13Z", "type": "commit"}, {"oid": "577e1807bce93a6efacb94ee4b796b105a7132c1", "url": "https://github.com/kiegroup/optaplanner/commit/577e1807bce93a6efacb94ee4b796b105a7132c1", "message": "Remove one level of Node construction indirection", "committedDate": "2021-01-13T13:51:13Z", "type": "commit"}, {"oid": "3de9c194314379094a22632260f2f86622f221bb", "url": "https://github.com/kiegroup/optaplanner/commit/3de9c194314379094a22632260f2f86622f221bb", "message": "Convert streams to LHS", "committedDate": "2021-01-13T13:51:13Z", "type": "commit"}, {"oid": "ed9ee481dbfeb59305334b02bffe6df4226fc8c5", "url": "https://github.com/kiegroup/optaplanner/commit/ed9ee481dbfeb59305334b02bffe6df4226fc8c5", "message": "Finish the major refactor", "committedDate": "2021-01-13T13:51:13Z", "type": "commit"}, {"oid": "171b48c1c1f15baf43400de6fec04abf86797121", "url": "https://github.com/kiegroup/optaplanner/commit/171b48c1c1f15baf43400de6fec04abf86797121", "message": "Hide what may be hidden", "committedDate": "2021-01-13T13:51:13Z", "type": "commit"}, {"oid": "49459a3d4260371fcf70c15d616f0d1249307072", "url": "https://github.com/kiegroup/optaplanner/commit/49459a3d4260371fcf70c15d616f0d1249307072", "message": "Address some Sonar stuff", "committedDate": "2021-01-13T13:51:13Z", "type": "commit"}, {"oid": "49459a3d4260371fcf70c15d616f0d1249307072", "url": "https://github.com/kiegroup/optaplanner/commit/49459a3d4260371fcf70c15d616f0d1249307072", "message": "Address some Sonar stuff", "committedDate": "2021-01-13T13:51:13Z", "type": "forcePushed"}, {"oid": "6f2502a4763afd7a5ded1bca3cae199905af6526", "url": "https://github.com/kiegroup/optaplanner/commit/6f2502a4763afd7a5ded1bca3cae199905af6526", "message": "Fix star imports", "committedDate": "2021-01-14T17:04:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NjY5MTA3OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1078#discussion_r556691079", "bodyText": "Please check the star imports; I have seen them on multiple classes in the PR.", "author": "rsynek", "createdAt": "2021-01-13T17:11:51Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/DroolsConstraintFactory.java", "diffHunk": "@@ -18,11 +18,8 @@\n \n import static org.drools.model.DSL.globalOf;\n \n-import java.util.ArrayList;\n-import java.util.HashSet;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n+import java.util.*;", "originalCommit": "49459a3d4260371fcf70c15d616f0d1249307072", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzQ0MTYyNw==", "url": "https://github.com/kiegroup/optaplanner/pull/1078#discussion_r557441627", "bodyText": "The code below seem to access to the first two items of the variables array. Can it contain more items?", "author": "rsynek", "createdAt": "2021-01-14T14:38:50Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/AbstractBiConstraintConsequence.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.drools.common;\n+\n+import java.math.BigDecimal;\n+import java.util.function.BiFunction;\n+import java.util.function.Supplier;\n+import java.util.function.ToIntBiFunction;\n+import java.util.function.ToLongBiFunction;\n+\n+import org.drools.model.DSL;\n+import org.drools.model.Drools;\n+import org.drools.model.Global;\n+import org.drools.model.Variable;\n+import org.drools.model.consequences.ConsequenceBuilder;\n+import org.optaplanner.core.impl.score.holder.AbstractScoreHolder;\n+import org.optaplanner.core.impl.score.stream.drools.DroolsConstraint;\n+\n+abstract class AbstractBiConstraintConsequence<A, B> extends AbstractConstraintConsequence<BiLeftHandSide<A, B>> {\n+\n+    @Override\n+    public int getCardinality() {\n+        return 2;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @return Null.\n+     *         When this method returns {@link ConsequenceMatchWeightType#INTEGER}, children of this class are\n+     *         guaranteed to implement {@link ToIntBiFunction}.\n+     *         When this method returns {@link ConsequenceMatchWeightType#LONG}, children of this class are guaranteed\n+     *         to implement {@link ToLongBiFunction}.\n+     *         When this method returns {@link ConsequenceMatchWeightType#BIG_DECIMAL}, children of this class are\n+     *         guaranteed to implement {@link BiFunction} to {@link BigDecimal}.\n+     */\n+    @Override\n+    public abstract ConsequenceMatchWeightType getMatchWeightType();\n+\n+    @Override\n+    protected final ConsequenceBuilder.ValidBuilder buildConsequence(DroolsConstraint constraint,\n+            Global<? extends AbstractScoreHolder<?>> scoreHolderGlobal, Variable... variables) {", "originalCommit": "49459a3d4260371fcf70c15d616f0d1249307072", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzUzMzM3Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/1078#discussion_r557533373", "bodyText": "\"need want\"? Also not sure about using \"we\" in the comments and docs.", "author": "rsynek", "createdAt": "2021-01-14T16:39:02Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/PatternVariable.java", "diffHunk": "@@ -0,0 +1,161 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.drools.common;\n+\n+import static org.drools.model.PatternDSL.betaIndexedBy;\n+import static org.drools.model.PatternDSL.pattern;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.*;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.drools.model.BetaIndex;\n+import org.drools.model.PatternDSL;\n+import org.drools.model.Variable;\n+import org.drools.model.functions.Function1;\n+import org.drools.model.functions.Predicate2;\n+import org.drools.model.view.ViewItem;\n+import org.optaplanner.core.api.function.QuadFunction;\n+import org.optaplanner.core.api.function.QuadPredicate;\n+import org.optaplanner.core.api.function.TriFunction;\n+import org.optaplanner.core.api.function.TriPredicate;\n+import org.optaplanner.core.impl.score.stream.bi.AbstractBiJoiner;\n+import org.optaplanner.core.impl.score.stream.common.JoinerType;\n+\n+class PatternVariable<A> {\n+\n+    private final Variable<A> primaryVariable;\n+    // Patterns in Drools are mutable, yet we need want to share them. Therefore we need to create them on-demand.", "originalCommit": "49459a3d4260371fcf70c15d616f0d1249307072", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1NzU1OTA1Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/1078#discussion_r557559052", "bodyText": "I think the trick with joining two columns into a BiTuple is worth documenting; mainly the motivation.", "author": "rsynek", "createdAt": "2021-01-14T17:15:55Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/BiLeftHandSide.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.drools.common;\n+\n+import static java.util.Collections.singletonList;\n+import static org.drools.model.DSL.*;\n+import static org.drools.model.PatternDSL.pattern;\n+\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n+import java.util.function.ToIntBiFunction;\n+import java.util.function.ToLongBiFunction;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.drools.model.PatternDSL;\n+import org.drools.model.Variable;\n+import org.drools.model.view.ViewItem;\n+import org.optaplanner.core.api.function.TriPredicate;\n+import org.optaplanner.core.api.score.stream.bi.BiConstraintCollector;\n+import org.optaplanner.core.api.score.stream.tri.TriJoiner;\n+import org.optaplanner.core.impl.score.stream.drools.DroolsVariableFactory;\n+import org.optaplanner.core.impl.score.stream.tri.AbstractTriJoiner;\n+import org.optaplanner.core.impl.score.stream.tri.FilteringTriJoiner;\n+import org.optaplanner.core.impl.score.stream.tri.NoneTriJoiner;\n+\n+public final class BiLeftHandSide<A, B> extends AbstractLeftHandSide {\n+\n+    private final PatternVariable<A> patternVariableA;\n+    private final PatternVariable<B> patternVariableB;\n+\n+    protected BiLeftHandSide(PatternVariable<A> left, PatternVariable<B> right, DroolsVariableFactory variableFactory) {\n+        super(variableFactory);\n+        this.patternVariableA = left;\n+        this.patternVariableB = right;\n+    }\n+\n+    protected BiLeftHandSide(BiLeftHandSide<A, B> leftHandSide, PatternVariable<A> left, PatternVariable<B> right) {\n+        super(leftHandSide.variableFactory);\n+        this.patternVariableA = left;\n+        this.patternVariableB = right;\n+    }\n+\n+    protected PatternVariable<A> getPatternVariableA() {\n+        return patternVariableA;\n+    }\n+\n+    protected PatternVariable<B> getPatternVariableB() {\n+        return patternVariableB;\n+    }\n+\n+    public BiLeftHandSide<A, B> andFilter(BiPredicate<A, B> filter) {\n+        return new BiLeftHandSide<>(this, patternVariableA,\n+                patternVariableB.filter(filter, patternVariableA.getPrimaryVariable()));\n+    }\n+\n+    private <C> BiLeftHandSide<A, B> applyJoiners(Class<C> otherFactType, AbstractTriJoiner<A, B, C> joiner,\n+            TriPredicate<A, B, C> predicate, boolean shouldExist) {\n+        if (joiner == null) {\n+            return applyFilters(otherFactType, predicate, shouldExist);\n+        }\n+        // There is no gamma index in Drools, therefore we replace joining with a filter.\n+        TriPredicate<A, B, C> joinFilter = joiner::matches;\n+        TriPredicate<A, B, C> result = predicate == null ? joinFilter : joinFilter.and(predicate);\n+        // And finally we add the filter to the C pattern.\n+        return applyFilters(otherFactType, result, shouldExist);\n+    }\n+\n+    private <C> BiLeftHandSide<A, B> applyFilters(Class<C> otherFactType, TriPredicate<A, B, C> predicate,\n+            boolean shouldExist) {\n+        Variable<C> toExist = (Variable<C>) variableFactory.createVariable(otherFactType, \"biToExist\");\n+        PatternDSL.PatternDef<C> existencePattern = pattern(toExist);\n+        PatternDSL.PatternDef<C> possiblyFilteredExistencePattern = predicate == null ? existencePattern\n+                : existencePattern.expr(\"Filter using \" + predicate, patternVariableA.getPrimaryVariable(),\n+                        patternVariableB.getPrimaryVariable(), (c, a, b) -> predicate.test(a, b, c));\n+        ViewItem<?> existenceExpression = exists(possiblyFilteredExistencePattern);\n+        if (!shouldExist) {\n+            existenceExpression = not(possiblyFilteredExistencePattern);\n+        }\n+        return new BiLeftHandSide<>(this, patternVariableA, patternVariableB.addDependentExpression(existenceExpression));\n+    }\n+\n+    private <C> BiLeftHandSide<A, B> existsOrNot(Class<C> cClass, TriJoiner<A, B, C>[] joiners, boolean shouldExist) {\n+        int indexOfFirstFilter = -1;\n+        // Prepare the joiner and filter that will be used in the pattern\n+        AbstractTriJoiner<A, B, C> finalJoiner = null;\n+        TriPredicate<A, B, C> finalFilter = null;\n+        for (int i = 0; i < joiners.length; i++) {\n+            AbstractTriJoiner<A, B, C> joiner = (AbstractTriJoiner<A, B, C>) joiners[i];\n+            boolean hasAFilter = indexOfFirstFilter >= 0;\n+            if (joiner instanceof NoneTriJoiner && joiners.length > 1) {\n+                throw new IllegalStateException(\"If present, \" + NoneTriJoiner.class + \" must be the only joiner, got \"\n+                        + Arrays.toString(joiners) + \" instead.\");\n+            } else if (!(joiner instanceof FilteringTriJoiner)) {\n+                if (hasAFilter) {\n+                    throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow a filtering joiner (\"\n+                            + joiners[indexOfFirstFilter] + \").\");\n+                } else { // Merge this Joiner with the existing Joiners.\n+                    finalJoiner = finalJoiner == null ? joiner : AbstractTriJoiner.merge(finalJoiner, joiner);\n+                }\n+            } else {\n+                if (!hasAFilter) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+                // Merge all filters into one to avoid paying the penalty for lack of indexing more than once.\n+                finalFilter = finalFilter == null ? joiner.getFilter() : finalFilter.and(joiner.getFilter());\n+            }\n+        }\n+        return applyJoiners(cClass, finalJoiner, finalFilter, shouldExist);\n+    }\n+\n+    public <C> BiLeftHandSide<A, B> andExists(Class<C> cClass, TriJoiner<A, B, C>[] joiners) {\n+        return existsOrNot(cClass, joiners, true);\n+    }\n+\n+    public <C> BiLeftHandSide<A, B> andNotExists(Class<C> cClass, TriJoiner<A, B, C>[] joiners) {\n+        return existsOrNot(cClass, joiners, false);\n+    }\n+\n+    public <C> TriLeftHandSide<A, B, C> andJoin(UniLeftHandSide<C> right, TriJoiner<A, B, C> joiner) {\n+        AbstractTriJoiner<A, B, C> castJoiner = (AbstractTriJoiner<A, B, C>) joiner;\n+        PatternVariable<C> filteredRight = right.getPatternVariableA()\n+                .filter(castJoiner::matches, patternVariableA.getPrimaryVariable(),\n+                        patternVariableB.getPrimaryVariable());\n+        return new TriLeftHandSide<>(patternVariableA, patternVariableB, filteredRight, variableFactory);\n+    }\n+\n+    public <NewA> UniLeftHandSide<NewA> andGroupBy(BiFunction<A, B, NewA> keyMapping) {\n+        Variable<A> inputA = patternVariableA.getPrimaryVariable();\n+        Variable<B> inputB = patternVariableB.getPrimaryVariable();\n+        Variable<NewA> groupKey = variableFactory.createVariable(\"groupKey\");\n+        ViewItem<?> innerGroupByPattern = joinViewItemsWithLogicalAnd(patternVariableA, patternVariableB);\n+        ViewItem<?> groupByPattern = groupBy(innerGroupByPattern, inputA, inputB, groupKey,\n+                keyMapping::apply);\n+        Variable<NewA> newA = (Variable<NewA>) variableFactory.createVariable(\"newA\", from(groupKey));\n+        return new UniLeftHandSide<>(new PatternVariable<>(newA, singletonList(groupByPattern)), variableFactory);\n+    }\n+\n+    public <NewA> UniLeftHandSide<NewA> andGroupBy(BiConstraintCollector<A, B, ?, NewA> collector) {\n+        Variable<BiTuple<A, B>> accumulateSource =\n+                (Variable<BiTuple<A, B>>) variableFactory.createVariable(BiTuple.class, \"source\");\n+        PatternVariable<B> newPatternVariableB = patternVariableB.bind(accumulateSource,\n+                patternVariableA.getPrimaryVariable(), (b, a) -> new BiTuple<>(a, b));\n+        Variable<NewA> outputVariable = variableFactory.createVariable(\"collected\");\n+        ViewItem<?> innerAccumulatePattern = joinViewItemsWithLogicalAnd(patternVariableA, newPatternVariableB);\n+        ViewItem<?> outerAccumulatePattern = accumulate(innerAccumulatePattern,\n+                accFunction(() -> new DroolsBiAccumulateFunction<>(collector), accumulateSource).as(outputVariable));\n+        return new UniLeftHandSide<>(new PatternVariable<>(outputVariable, singletonList(outerAccumulatePattern)),\n+                variableFactory);\n+    }\n+\n+    public <NewA, NewB> BiLeftHandSide<NewA, NewB> andGroupBy(BiFunction<A, B, NewA> keyMappingA,\n+            BiFunction<A, B, NewB> keyMappingB) {\n+        Variable<A> inputA = patternVariableA.getPrimaryVariable();\n+        Variable<B> inputB = patternVariableB.getPrimaryVariable();\n+        Variable<BiTuple<NewA, NewB>> groupKey =\n+                (Variable<BiTuple<NewA, NewB>>) variableFactory.createVariable(BiTuple.class, \"groupKey\");\n+        ViewItem<?> innerGroupByPattern = joinViewItemsWithLogicalAnd(patternVariableA, patternVariableB);\n+        ViewItem<?> groupByPattern = groupBy(innerGroupByPattern, inputA, inputB, groupKey,\n+                (a, b) -> new BiTuple<>(keyMappingA.apply(a, b), keyMappingB.apply(a, b)));\n+        Variable<NewA> newA =\n+                (Variable<NewA>) variableFactory.createVariable(\"newA\", from(groupKey, k -> k.a));\n+        Variable<NewB> newB =\n+                (Variable<NewB>) variableFactory.createVariable(\"newB\", from(groupKey, k -> k.b));\n+        return new BiLeftHandSide<>(new PatternVariable<>(newA, singletonList(groupByPattern)),\n+                new PatternVariable<>(newB), variableFactory);\n+    }\n+\n+    public <NewA, NewB> BiLeftHandSide<NewA, NewB> andGroupBy(BiFunction<A, B, NewA> keyMappingA,\n+            BiConstraintCollector<A, B, ?, NewB> collectorB) {\n+        Variable<A> inputA = patternVariableA.getPrimaryVariable();\n+        Variable<B> inputB = patternVariableB.getPrimaryVariable();\n+        Variable<BiTuple<A, B>> accumulateSource =\n+                (Variable<BiTuple<A, B>>) variableFactory.createVariable(BiTuple.class, \"source\");\n+        PatternVariable<B> newPatternVariableB = patternVariableB.bind(accumulateSource, inputA,\n+                (b, a) -> new BiTuple<>(a, b));\n+        Variable<NewA> groupKey = variableFactory.createVariable(\"groupKey\");\n+        Variable<NewB> output = variableFactory.createVariable(\"output\");\n+        ViewItem<?> innerGroupByPattern = joinViewItemsWithLogicalAnd(patternVariableA, newPatternVariableB);\n+        ViewItem<?> groupByPattern = groupBy(innerGroupByPattern, inputA, inputB, groupKey,\n+                keyMappingA::apply,\n+                accFunction(() -> new DroolsBiAccumulateFunction<>(collectorB), accumulateSource).as(output));\n+        Variable<NewA> newA = (Variable<NewA>) variableFactory.createVariable(\"newA\", from(groupKey));\n+        Variable<NewB> newB = (Variable<NewB>) variableFactory.createVariable(\"newB\", from(output));\n+        return new BiLeftHandSide<>(new PatternVariable<>(newA, singletonList(groupByPattern)),\n+                new PatternVariable<>(newB), variableFactory);\n+    }\n+\n+    public <NewA, NewB, NewC> TriLeftHandSide<NewA, NewB, NewC> andGroupBy(BiFunction<A, B, NewA> keyMappingA,\n+            BiFunction<A, B, NewB> keyMappingB, BiConstraintCollector<A, B, ?, NewC> collectorC) {\n+        Variable<A> inputA = patternVariableA.getPrimaryVariable();\n+        Variable<B> inputB = patternVariableB.getPrimaryVariable();\n+        Variable<BiTuple<A, B>> accumulateSource =\n+                (Variable<BiTuple<A, B>>) variableFactory.createVariable(BiTuple.class, \"source\");\n+        PatternVariable<B> newPatternVariableB = patternVariableB.bind(accumulateSource, inputA,\n+                (b, a) -> new BiTuple<>(a, b));\n+        Variable<BiTuple<NewA, NewB>> groupKey =\n+                (Variable<BiTuple<NewA, NewB>>) variableFactory.createVariable(BiTuple.class, \"groupKey\");\n+        Variable<NewC> output = variableFactory.createVariable(\"output\");\n+        ViewItem<?> innerGroupByPattern = joinViewItemsWithLogicalAnd(patternVariableA, newPatternVariableB);\n+        ViewItem<?> groupByPattern = groupBy(innerGroupByPattern, inputA, inputB, groupKey,\n+                (a, b) -> new BiTuple<>(keyMappingA.apply(a, b), keyMappingB.apply(a, b)),", "originalCommit": "49459a3d4260371fcf70c15d616f0d1249307072", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9939ea2f15e53fc6e1cfd210a6c350d5dbd6f4d5", "url": "https://github.com/kiegroup/optaplanner/commit/9939ea2f15e53fc6e1cfd210a6c350d5dbd6f4d5", "message": "Address some code review comments", "committedDate": "2021-01-14T17:51:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Nzk2MjIxMg==", "url": "https://github.com/kiegroup/optaplanner/pull/1078#discussion_r557962212", "bodyText": "Naming: I think the parameter should be called predicate:\n\nwe filter based on a predicate\nother methods (see applyJoiners) use that name for the same parameter too", "author": "rsynek", "createdAt": "2021-01-15T07:44:28Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/BiLeftHandSide.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.drools.common;\n+\n+import static java.util.Collections.singletonList;\n+import static org.drools.model.DSL.*;\n+import static org.drools.model.PatternDSL.pattern;\n+\n+import java.math.BigDecimal;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.function.BiFunction;\n+import java.util.function.BiPredicate;\n+import java.util.function.ToIntBiFunction;\n+import java.util.function.ToLongBiFunction;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import org.drools.model.PatternDSL;\n+import org.drools.model.Variable;\n+import org.drools.model.view.ViewItem;\n+import org.optaplanner.core.api.function.TriPredicate;\n+import org.optaplanner.core.api.score.stream.bi.BiConstraintCollector;\n+import org.optaplanner.core.api.score.stream.tri.TriJoiner;\n+import org.optaplanner.core.impl.score.stream.drools.DroolsVariableFactory;\n+import org.optaplanner.core.impl.score.stream.tri.AbstractTriJoiner;\n+import org.optaplanner.core.impl.score.stream.tri.FilteringTriJoiner;\n+import org.optaplanner.core.impl.score.stream.tri.NoneTriJoiner;\n+\n+public final class BiLeftHandSide<A, B> extends AbstractLeftHandSide {\n+\n+    private final PatternVariable<A> patternVariableA;\n+    private final PatternVariable<B> patternVariableB;\n+\n+    protected BiLeftHandSide(PatternVariable<A> left, PatternVariable<B> right, DroolsVariableFactory variableFactory) {\n+        super(variableFactory);\n+        this.patternVariableA = left;\n+        this.patternVariableB = right;\n+    }\n+\n+    protected BiLeftHandSide(BiLeftHandSide<A, B> leftHandSide, PatternVariable<A> left, PatternVariable<B> right) {\n+        super(leftHandSide.variableFactory);\n+        this.patternVariableA = left;\n+        this.patternVariableB = right;\n+    }\n+\n+    protected PatternVariable<A> getPatternVariableA() {\n+        return patternVariableA;\n+    }\n+\n+    protected PatternVariable<B> getPatternVariableB() {\n+        return patternVariableB;\n+    }\n+\n+    public BiLeftHandSide<A, B> andFilter(BiPredicate<A, B> filter) {", "originalCommit": "49459a3d4260371fcf70c15d616f0d1249307072", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d1118d81505411a1391d915d0e484ae411adc0ee", "url": "https://github.com/kiegroup/optaplanner/commit/d1118d81505411a1391d915d0e484ae411adc0ee", "message": "Standardize the creation of accumulate function", "committedDate": "2021-01-15T09:42:35Z", "type": "commit"}, {"oid": "4ac4f2604ed2cd707b348ed90fbb68db3cc53a0c", "url": "https://github.com/kiegroup/optaplanner/commit/4ac4f2604ed2cd707b348ed90fbb68db3cc53a0c", "message": "You gotta love generics", "committedDate": "2021-01-15T10:01:03Z", "type": "commit"}, {"oid": "bed8fde8d0d1677ae092f7a59d635faf1acb4b01", "url": "https://github.com/kiegroup/optaplanner/commit/bed8fde8d0d1677ae092f7a59d635faf1acb4b01", "message": "Standardize composite keys", "committedDate": "2021-01-15T10:10:19Z", "type": "commit"}, {"oid": "2c0653612a0c0259d4ca4682111a4d89e117297c", "url": "https://github.com/kiegroup/optaplanner/commit/2c0653612a0c0259d4ca4682111a4d89e117297c", "message": "Address another code review comment", "committedDate": "2021-01-15T10:11:47Z", "type": "commit"}, {"oid": "72897c90779653d47f1055fe49a3e8459504f6cb", "url": "https://github.com/kiegroup/optaplanner/commit/72897c90779653d47f1055fe49a3e8459504f6cb", "message": "Some more Javadocs", "committedDate": "2021-01-15T10:54:20Z", "type": "commit"}, {"oid": "9119e2e5ef72d60761f665741d1f8b691679d18d", "url": "https://github.com/kiegroup/optaplanner/commit/9119e2e5ef72d60761f665741d1f8b691679d18d", "message": "Better name for impact methods", "committedDate": "2021-01-15T10:57:19Z", "type": "commit"}, {"oid": "b4dba2c2ec042f3f30379d53a4896034b8d70517", "url": "https://github.com/kiegroup/optaplanner/commit/b4dba2c2ec042f3f30379d53a4896034b8d70517", "message": "Finalize the PR", "committedDate": "2021-01-15T11:33:48Z", "type": "commit"}]}