{"pr_number": 739, "pr_title": "PLANNER-1929 Constraint Verifier properly supports match weights", "pr_createdAt": "2020-04-09T09:28:18Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/739", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjA3ODU1OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406078559", "bodyText": "Public API change.\nThis is a default method, so that the interface remains 100 % backwards compatible.", "author": "triceo", "createdAt": "2020-04-09T09:32:56Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/Score.java", "diffHunk": "@@ -102,6 +102,22 @@\n      */\n     Score_ divide(double divisor);\n \n+    /**\n+     * Return a Score whose every level is a result of dividing the matching levels in this and the divisor.\n+     * When rounding is needed, it should be floored (as defined by {@link Math#floor(double)}).\n+     * <p>\n+     * If the implementation has a scale/precision, then the unspecified scale/precision of the double divisor\n+     * should have no impact on the returned scale/precision.\n+     * <p>\n+     * Allows division by zero if and only if both levels are zero, in which case the resulting level will also be zero.\n+     * Otherwise {@link ArithmeticException} is thrown.\n+     * @param divisor value by which this Score is to be divided\n+     * @return this / divisor\n+     */\n+    default Score_ divide(Score_ divisor) {\n+        throw new UnsupportedOperationException();\n+    }", "originalCommit": "c76a95d9d3bac1f0f4b477d0534b25491254f647", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE2NDE2NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406164165", "bodyText": "Soft suggestion: The empty string should be a named constant.", "author": "yurloc", "createdAt": "2020-04-09T12:20:25Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/buildin/simple/SimpleScore.java", "diffHunk": "@@ -133,11 +133,18 @@ public SimpleScore multiply(double multiplicand) {\n \n     @Override\n     public SimpleScore divide(double divisor) {\n-        return new SimpleScore(\n-                (int) Math.floor(initScore / divisor),\n+        int newInitScore = divideInitScore(divisor);\n+        return ofUninitialized(newInitScore,\n                 (int) Math.floor(score / divisor));\n     }\n \n+    @Override\n+    public SimpleScore divide(SimpleScore divisor) {\n+        int newInitScore = divideInitScore(divisor.initScore);\n+        int newScore = divideScoreLevel(score, divisor.score, \"\");", "originalCommit": "0663a1725a5dcf25094d067507ac0f366133b174", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3Mjg5MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406172891", "bodyText": "Given that s is a ConstraintMatchTotal the variable name seems a bit arbitrary. Is it a mistake?", "author": "yurloc", "createdAt": "2020-04-09T12:36:49Z", "path": "optaplanner-test/src/main/java/org/optaplanner/test/api/score/stream/SingleConstraintAssertion.java", "diffHunk": "@@ -39,9 +43,27 @@\n     }\n \n     private Number getImpact() {\n-        return constraintMatchTotalMap.values().stream()\n-                .mapToInt(ConstraintMatchTotal::getConstraintMatchCount)\n-                .sum();\n+        Score<?> zero = getParentConstraintVerifier().getConstraintStreamScoreDirectorFactory()\n+                .getScoreDefinition()\n+                .getZeroScore();\n+        if (constraintMatchTotalMap.isEmpty()) {\n+            return zero.toLevelNumbers()[0]; // Return zero in the numeric type expected by the caller.\n+        }\n+        // We do not know the matchWeight, so we need to deduce it.\n+        // Constraint matches give us a score, whose levels are in the form of (matchWeight * constraintWeight).\n+        // Here, we strip the constraintWeight.\n+        Score<?> totalMatchWeightedScore = constraintMatchTotalMap.values().stream()\n+                .map(s -> s.getScore().divide(s.getConstraintWeight()))", "originalCommit": "0663a1725a5dcf25094d067507ac0f366133b174", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NjA0Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406176047", "bodyText": "IIUC, what this does is that it fails fast if the constraint impacts different score levels with different weights, so -5medium/-5soft is valid but -1medium/-2soft fails here. Is that correct?", "author": "yurloc", "createdAt": "2020-04-09T12:42:39Z", "path": "optaplanner-test/src/main/java/org/optaplanner/test/api/score/stream/SingleConstraintAssertion.java", "diffHunk": "@@ -39,9 +43,27 @@\n     }\n \n     private Number getImpact() {\n-        return constraintMatchTotalMap.values().stream()\n-                .mapToInt(ConstraintMatchTotal::getConstraintMatchCount)\n-                .sum();\n+        Score<?> zero = getParentConstraintVerifier().getConstraintStreamScoreDirectorFactory()\n+                .getScoreDefinition()\n+                .getZeroScore();\n+        if (constraintMatchTotalMap.isEmpty()) {\n+            return zero.toLevelNumbers()[0]; // Return zero in the numeric type expected by the caller.\n+        }\n+        // We do not know the matchWeight, so we need to deduce it.\n+        // Constraint matches give us a score, whose levels are in the form of (matchWeight * constraintWeight).\n+        // Here, we strip the constraintWeight.\n+        Score<?> totalMatchWeightedScore = constraintMatchTotalMap.values().stream()\n+                .map(s -> s.getScore().divide(s.getConstraintWeight()))\n+                .reduce(zero, Score::add);\n+        // Each level of the resulting score now has to be the same number, the matchWeight.\n+        List<Number> matchWeightsFound = Arrays.stream(totalMatchWeightedScore.toLevelNumbers())\n+                .distinct()\n+                .collect(Collectors.toList());\n+        if (matchWeightsFound.size() != 1) {\n+            throw new IllegalStateException(\"Programming error: only one match weight should have been found (\"\n+                    + matchWeightsFound + \").\");", "originalCommit": "0663a1725a5dcf25094d067507ac0f366133b174", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3OTU0Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406179547", "bodyText": "If yes, why there is such restriction? Maybe there's a technical limitation related to how Constraint Streams are implemented, that is obvious to you but it makes me ask this question. Maybe it's a general OptaPlanner limitation.\nPlease consider leaving a short explanation in the source code comment if you think that kind of information would be relevant here.", "author": "yurloc", "createdAt": "2020-04-09T12:49:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NjA0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI0MDg2NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406240865", "bodyText": "The score here is matchWeight * constraintWeight * matchCount.\nAt this point, I have already divided by it constraintWeight.\nWhat remains is therefore matchWeight * matchCount. And therefore the value in every level of the score must be the same.\nI believe there already is an explanatory comment in the code.\n(That said, you correctly point out a bug in case where one level of the score is 0. Fixing that.)", "author": "triceo", "createdAt": "2020-04-09T14:22:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NjA0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI0NDYxOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406244619", "bodyText": "For example, consider .penalize(\"something\", HardSoftScore.of(1, 2), something -> 2).\nAssume that this penalty is only applied once. In this case:\n\nmatchCount = 1\nmatchWeight = 2\nconstraintWeight = 1hard/2soft\n\nAnd therefore, from the end:\n\nconstraintMatchScore = -2hard/-4soft\nconstraintMatchScore / constraintWeight = -2hard/-2soft\nmatchWeightsFound = [-2]\nresult = -2", "author": "triceo", "createdAt": "2020-04-09T14:27:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NjA0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI3MjUxOA==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406272518", "bodyText": "Beautiful explanation, thanks! Now it makes perfect sense.", "author": "yurloc", "createdAt": "2020-04-09T15:05:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjE3NjA0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI4MTM3Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406281372", "bodyText": "Nitpicking: You have just moved one instance of SimpleScore's label to another place. What I was pointing out is that \"\" is the score label of SimpleScore and I noticed the the string literal (\"\") is used multiple times in the SimpleScore class and therefore should be replaced by a constant (provided that all \"\" occurrences have the same meaning, which I presume they do).\nIn another words, what would happen if we decided that SimpleScore will get a new label of simp? We would replace two \"\" occurrences in SimpleScore with \"simp\" and we would probably miss this instance (on line 43).", "author": "yurloc", "createdAt": "2020-04-09T15:18:28Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/AbstractScore.java", "diffHunk": "@@ -34,6 +35,74 @@\n \n     protected static final String INIT_LABEL = \"init\";\n \n+    protected static int divideScoreLevel(int score, int scoreDivisor) {\n+        return divideScoreLevel(score, scoreDivisor, null);\n+    }\n+\n+    protected static int divideScoreLevel(int score, int scoreDivisor, String maybeLabel) {\n+        String label = maybeLabel == null ? \"\" : maybeLabel;", "originalCommit": "9e34cde34bd022aa74eaade7f8a453b870f2992c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI4Mzk2NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406283965", "bodyText": "What would happen is that the exception message would continue to say \"X\" instead of \"Xsimp\".\nI really don't consider this a problem - it was a problem before, where I was propagating something that should have been a constant. I don't anymore.", "author": "triceo", "createdAt": "2020-04-09T15:22:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI4MTM3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI4NjYyOA==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r406286628", "bodyText": "OK, that's another, valid point of view that I didn't think of.", "author": "yurloc", "createdAt": "2020-04-09T15:26:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI4MTM3Mg=="}], "type": "inlineReview"}, {"oid": "09b1611ae17b63f7989eedb4449fdd413b924ca7", "url": "https://github.com/kiegroup/optaplanner/commit/09b1611ae17b63f7989eedb4449fdd413b924ca7", "message": "Merge changes without updates to the API", "committedDate": "2020-04-11T14:28:04Z", "type": "commit"}, {"oid": "b2d1402f2f62f67a70bb7eb229d9898de13736fd", "url": "https://github.com/kiegroup/optaplanner/commit/b2d1402f2f62f67a70bb7eb229d9898de13736fd", "message": "Add new method to the score definition", "committedDate": "2020-04-11T14:59:29Z", "type": "commit"}, {"oid": "5ff0ca627a218c3ac46d81947893f9c9d79e566e", "url": "https://github.com/kiegroup/optaplanner/commit/5ff0ca627a218c3ac46d81947893f9c9d79e566e", "message": "Add tests", "committedDate": "2020-04-11T15:35:12Z", "type": "commit"}, {"oid": "5ff0ca627a218c3ac46d81947893f9c9d79e566e", "url": "https://github.com/kiegroup/optaplanner/commit/5ff0ca627a218c3ac46d81947893f9c9d79e566e", "message": "Add tests", "committedDate": "2020-04-11T15:35:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3Nzg5MA==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r407077890", "bodyText": "My spider sense is tingling, expecting comments here.\nSee table \"Preferred Scales for Results of Arithmetic Operations\" in BigDecimal Javadoc.", "author": "triceo", "createdAt": "2020-04-11T15:39:34Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/definition/AbstractScoreDefinition.java", "diffHunk": "@@ -30,6 +32,38 @@\n \n     private final String[] levelLabels;\n \n+    protected static int sanitize(int number) {\n+        return number == 0 ? 1 : number;\n+    }\n+\n+    protected static long sanitize(long number) {\n+        return number == 0L ? 1L : number;\n+    }\n+\n+    protected static double sanitize(double number) {\n+        return number == 0d ? 1d : number;\n+    }\n+\n+    protected static BigDecimal sanitize(BigDecimal number) {\n+        return number.signum() == 0 ? BigDecimal.ONE : number;\n+    }\n+\n+    protected static int divide(int dividend, int divisor) {\n+        return (int) Math.floor(divide(dividend, (double) divisor));\n+    }\n+\n+    protected static long divide(long dividend, long divisor) {\n+        return (long) Math.floor(divide(dividend, (double) divisor));\n+    }\n+\n+    protected static double divide(double dividend, double divisor) {\n+        return dividend / divisor;\n+    }\n+\n+    protected static BigDecimal divide(BigDecimal dividend, BigDecimal divisor) {\n+        return dividend.divide(divisor, dividend.scale() - divisor.scale(), RoundingMode.FLOOR);", "originalCommit": "5ff0ca627a218c3ac46d81947893f9c9d79e566e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3ODY4MA==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r407078680", "bodyText": "This is fine. Our long existing method Score.divide(boolean) has a javadoc that says \"When rounding is needed, it should be floored (as defined by {@link Math#floor(double)}).\" This is consistent with that.", "author": "ge0ffrey", "createdAt": "2020-04-11T15:47:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3Nzg5MA=="}], "type": "inlineReview"}, {"oid": "d65e206b977f4cf50dc636d1c7e3c84e7579f439", "url": "https://github.com/kiegroup/optaplanner/commit/d65e206b977f4cf50dc636d1c7e3c84e7579f439", "message": "Fix Revapi", "committedDate": "2020-04-11T15:41:28Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3ODcyMQ==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r407078721", "bodyText": "javadoc link to Score", "author": "ge0ffrey", "createdAt": "2020-04-11T15:47:26Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/definition/ScoreDefinition.java", "diffHunk": "@@ -152,4 +152,14 @@ default boolean isNegativeOrZero(S score) {\n      */\n     S buildPessimisticBound(InitializingScoreTrend initializingScoreTrend, S score);\n \n+    /**\n+     * Return a Score whose every level is the result of dividing the matching levels in this and the divisor.", "originalCommit": "d65e206b977f4cf50dc636d1c7e3c84e7579f439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzA3ODc4OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/739#discussion_r407078789", "bodyText": "Did the buildPessimisticBoundOnlyDown() test get removed?", "author": "ge0ffrey", "createdAt": "2020-04-11T15:48:07Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/score/buildin/hardsoft/HardSoftScoreDefinitionTest.java", "diffHunk": "@@ -89,14 +89,18 @@ public void buildPessimisticBoundOnlyUp() {\n     }\n \n     @Test\n-    public void buildPessimisticBoundOnlyDown() {\n+    public void divideBySanitizedDivisor() {", "originalCommit": "d65e206b977f4cf50dc636d1c7e3c84e7579f439", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "74ebcb264f357f568eca02399b3164ea11bdbf1b", "url": "https://github.com/kiegroup/optaplanner/commit/74ebcb264f357f568eca02399b3164ea11bdbf1b", "message": "Address review comments", "committedDate": "2020-04-11T15:51:59Z", "type": "commit"}]}