{"pr_number": 1022, "pr_title": "PLANNER-2419 Add ConstraintProvider for Nurse Rostering example", "pr_createdAt": "2020-11-09T17:37:46Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/1022", "timeline": [{"oid": "c58bf65b38aa7783632002886d8dcfecfd031cf5", "url": "https://github.com/kiegroup/optaplanner/commit/c58bf65b38aa7783632002886d8dcfecfd031cf5", "message": "Made ConsecutiveSetTree accept non-integral index types,\nUpdate API of ConsecutiveData, Start Work on\nNurse Rostering ConstraintProvider", "committedDate": "2021-04-28T20:05:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjc2NDk2NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r622764965", "bodyText": "We need to figure out a way to support LocalDateTime (and similar types) out of the box:\n\nThe current way allows to map anything to a timeline, good;\nbut there needs to be a way to just submit ShiftDate,\nor some other way to provide shiftStartDate and shiftEndDate.", "author": "triceo", "createdAt": "2021-04-29T06:25:56Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java", "diffHunk": "@@ -1966,6 +1968,121 @@ public void remove(Key key, Value value) {\n                                 ConstraintCollectors::throwOnKeyConflict, TreeMap::new)));\n     }\n \n+    // Consecutive\n+\n+    /**\n+     * Creates a constraint collector that returns {@link ConsecutiveData} about the first\n+     * fact.\n+     *\n+     * For instance ${@code [Shift slot=1] [Shift slot=2] [Shift slot=4] [Shift slot=6]}\n+     * returns the following infomation\n+     *\n+     * ${@code\n+     * Consecutive Lengths: 2 1 1\n+     * Break Lengths: 1 2\n+     * Consecutive Items [[Shift slot=1] [Shift slot=2]], [[Shift slot=4]] [[Shift slot=6]]\n+     * }\n+     * \n+     * @param indexMap Maps the fact to its position in the sequence\n+     * @param <A> type of the first mapped fact\n+     * @return never null\n+     */\n+    public static <A> UniConstraintCollector<A, ConsecutiveSetTree<A, Integer, Integer>, ConsecutiveData<A, Integer>>\n+            consecutive(ToIntFunction<A> indexMap) {", "originalCommit": "c58bf65b38aa7783632002886d8dcfecfd031cf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjc2NTIzNQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r622765235", "bodyText": "Let's discuss later which of these methods we really want to expose as the public API.", "author": "triceo", "createdAt": "2021-04-29T06:26:36Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintCollectors.java", "diffHunk": "@@ -1966,6 +1968,121 @@ public void remove(Key key, Value value) {\n                                 ConstraintCollectors::throwOnKeyConflict, TreeMap::new)));\n     }\n \n+    // Consecutive\n+\n+    /**\n+     * Creates a constraint collector that returns {@link ConsecutiveData} about the first\n+     * fact.\n+     *\n+     * For instance ${@code [Shift slot=1] [Shift slot=2] [Shift slot=4] [Shift slot=6]}\n+     * returns the following infomation\n+     *\n+     * ${@code\n+     * Consecutive Lengths: 2 1 1\n+     * Break Lengths: 1 2\n+     * Consecutive Items [[Shift slot=1] [Shift slot=2]], [[Shift slot=4]] [[Shift slot=6]]\n+     * }\n+     * \n+     * @param indexMap Maps the fact to its position in the sequence\n+     * @param <A> type of the first mapped fact\n+     * @return never null\n+     */\n+    public static <A> UniConstraintCollector<A, ConsecutiveSetTree<A, Integer, Integer>, ConsecutiveData<A, Integer>>\n+            consecutive(ToIntFunction<A> indexMap) {\n+        return new DefaultUniConstraintCollector<>(\n+                () -> new ConsecutiveSetTree<A, Integer, Integer>((Class<? extends A>) Object.class,\n+                        indexMap::applyAsInt,\n+                        (Integer a, Integer b) -> b - a, 1, 0),\n+                (acc, a) -> {\n+                    acc.add(a);\n+                    return () -> {\n+                        acc.remove(a);\n+                    };\n+                },\n+                ConsecutiveSetTree::getConsecutiveData);\n+    }\n+\n+    /**\n+     * As defined by {@link #consecutive(ToIntFunction)} (Function, Function, BinaryOperator)}.\n+     *\n+     * @param resultMap Maps both facts to an item in the sequence\n+     * @param indexMap Maps the item to its position in the sequence\n+     * @param <A> type of the first mapped fact\n+     * @param <B> type of the second mapped fact\n+     * @param <Result> type of item in the sequence\n+     * @return never null\n+     */\n+    public static <A, B, Result>\n+            BiConstraintCollector<A, B, ConsecutiveSetTree<Result, Integer, Integer>, ConsecutiveData<Result, Integer>>\n+            consecutive(BiFunction<A, B, Result> resultMap, ToIntFunction<Result> indexMap) {", "originalCommit": "c58bf65b38aa7783632002886d8dcfecfd031cf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjc2NTQ4Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r622765482", "bodyText": "We need a better name for this. Not necessarily now.", "author": "triceo", "createdAt": "2021-04-29T06:27:06Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/ConsecutiveData.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ConsecutiveData<T, D extends Comparable<D>> {", "originalCommit": "c58bf65b38aa7783632002886d8dcfecfd031cf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjc2NTk1OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r622765959", "bodyText": "Please pick descriptive names for T, D. We may have been able to get away with A and B in CS, but those are purely positional names - in this case, these types have meaning, and their names should carry it.", "author": "triceo", "createdAt": "2021-04-29T06:28:05Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/ConsecutiveData.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ConsecutiveData<T, D extends Comparable<D>> {\n+    private final ConsecutiveSetTree<T, ?, D> sourceTree;", "originalCommit": "c58bf65b38aa7783632002886d8dcfecfd031cf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjc2NjMyNw==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r622766327", "bodyText": "In my opinion, we need Break<D> just as we have Sequence<T>.\nBreaks need to be navigable just like Sequences are.", "author": "triceo", "createdAt": "2021-04-29T06:28:57Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/ConsecutiveData.java", "diffHunk": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+public class ConsecutiveData<T, D extends Comparable<D>> {\n+    private final ConsecutiveSetTree<T, ?, D> sourceTree;\n+\n+    protected ConsecutiveData(ConsecutiveSetTree<T, ?, D> sourceTree) {\n+        this.sourceTree = sourceTree;\n+    }\n+\n+    public List<Sequence<T>> getConsecutiveSequences() {\n+        return sourceTree.getConsecutiveSequences();\n+    }\n+\n+    public List<D> getBreaks() {", "originalCommit": "c58bf65b38aa7783632002886d8dcfecfd031cf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjc2Njc0OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r622766749", "bodyText": "private or private final where possible, please.", "author": "triceo", "createdAt": "2021-04-29T06:29:49Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/ConsecutiveSetTree.java", "diffHunk": "@@ -0,0 +1,314 @@\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class ConsecutiveSetTree<T, I extends Comparable<I>, D extends Comparable<D>> implements Collection<T> {\n+    Function<T, I> indexFunction;\n+    BiFunction<I, I, D> differenceFunction;\n+    D maxDifference;\n+    D zeroDifference;\n+    TreeMap<T, Sequence<T>> startItemToSequence;\n+    Class<? extends T> typeClass;\n+    Comparator<T> comparator;\n+\n+    TreeMapValueList<T, Sequence<T>> sequenceList;\n+    ConsecutiveData<T, D> consecutiveData;", "originalCommit": "c58bf65b38aa7783632002886d8dcfecfd031cf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjc2Njg4OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r622766889", "bodyText": "Same comment on generic variable naming as above.", "author": "triceo", "createdAt": "2021-04-29T06:30:07Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/ConsecutiveSetTree.java", "diffHunk": "@@ -0,0 +1,314 @@\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class ConsecutiveSetTree<T, I extends Comparable<I>, D extends Comparable<D>> implements Collection<T> {", "originalCommit": "c58bf65b38aa7783632002886d8dcfecfd031cf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjc2NzEzMQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r622767131", "bodyText": "Do we need this? Where?\nIf we need this, it must be fully incremental. If we don't need this now, I suggest we remove it for now.", "author": "triceo", "createdAt": "2021-04-29T06:30:41Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/ConsecutiveSetTree.java", "diffHunk": "@@ -0,0 +1,314 @@\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class ConsecutiveSetTree<T, I extends Comparable<I>, D extends Comparable<D>> implements Collection<T> {\n+    Function<T, I> indexFunction;\n+    BiFunction<I, I, D> differenceFunction;\n+    D maxDifference;\n+    D zeroDifference;\n+    TreeMap<T, Sequence<T>> startItemToSequence;\n+    Class<? extends T> typeClass;\n+    Comparator<T> comparator;\n+\n+    TreeMapValueList<T, Sequence<T>> sequenceList;\n+    ConsecutiveData<T, D> consecutiveData;\n+\n+    public ConsecutiveSetTree(Class<? extends T> typeClass, Function<T, I> indexFunction,\n+            BiFunction<I, I, D> differenceFunction, D maxDifference, D zeroDifference) {\n+        this.indexFunction = indexFunction;\n+        this.differenceFunction = differenceFunction;\n+        this.maxDifference = maxDifference;\n+        this.zeroDifference = zeroDifference;\n+        this.typeClass = typeClass;\n+        // Hashcode for duplicate protection\n+        // Ex: two different games on the same time slot\n+        comparator = Comparator.comparing(indexFunction).thenComparingInt(System::identityHashCode);\n+        startItemToSequence = new TreeMap<>(comparator);\n+        consecutiveData = new ConsecutiveData<>(this);\n+        sequenceList = new TreeMapValueList<>(startItemToSequence);\n+    }\n+\n+    public List<Sequence<T>> getConsecutiveSequences() {\n+        return sequenceList;\n+    }\n+\n+    public List<D> getBreaks() {\n+        return startItemToSequence.keySet().stream().flatMap(startItem -> {\n+            T nextStartItem = startItemToSequence.higherKey(startItem);\n+            if (nextStartItem == null) {\n+                return Stream.empty();\n+            }\n+            return Stream.of(differenceFunction.apply(indexFunction.apply(startItemToSequence.get(startItem).getItems().last()),\n+                    indexFunction.apply(nextStartItem)));\n+        }).collect(Collectors.toList());\n+    }\n+\n+    public List<D> getConsecutiveLengths() {\n+        return getConsecutiveSequences().stream()\n+                .map(sequence -> differenceFunction.apply(indexFunction.apply(sequence.getItems().first()),\n+                        indexFunction.apply(sequence.getItems().last())))\n+                .collect(Collectors.toList());\n+    }", "originalCommit": "c58bf65b38aa7783632002886d8dcfecfd031cf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjc2NzMzMg==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r622767332", "bodyText": "Needs to be incremental.", "author": "triceo", "createdAt": "2021-04-29T06:31:12Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/ConsecutiveSetTree.java", "diffHunk": "@@ -0,0 +1,314 @@\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class ConsecutiveSetTree<T, I extends Comparable<I>, D extends Comparable<D>> implements Collection<T> {\n+    Function<T, I> indexFunction;\n+    BiFunction<I, I, D> differenceFunction;\n+    D maxDifference;\n+    D zeroDifference;\n+    TreeMap<T, Sequence<T>> startItemToSequence;\n+    Class<? extends T> typeClass;\n+    Comparator<T> comparator;\n+\n+    TreeMapValueList<T, Sequence<T>> sequenceList;\n+    ConsecutiveData<T, D> consecutiveData;\n+\n+    public ConsecutiveSetTree(Class<? extends T> typeClass, Function<T, I> indexFunction,\n+            BiFunction<I, I, D> differenceFunction, D maxDifference, D zeroDifference) {\n+        this.indexFunction = indexFunction;\n+        this.differenceFunction = differenceFunction;\n+        this.maxDifference = maxDifference;\n+        this.zeroDifference = zeroDifference;\n+        this.typeClass = typeClass;\n+        // Hashcode for duplicate protection\n+        // Ex: two different games on the same time slot\n+        comparator = Comparator.comparing(indexFunction).thenComparingInt(System::identityHashCode);\n+        startItemToSequence = new TreeMap<>(comparator);\n+        consecutiveData = new ConsecutiveData<>(this);\n+        sequenceList = new TreeMapValueList<>(startItemToSequence);\n+    }\n+\n+    public List<Sequence<T>> getConsecutiveSequences() {\n+        return sequenceList;\n+    }\n+\n+    public List<D> getBreaks() {\n+        return startItemToSequence.keySet().stream().flatMap(startItem -> {\n+            T nextStartItem = startItemToSequence.higherKey(startItem);\n+            if (nextStartItem == null) {\n+                return Stream.empty();\n+            }\n+            return Stream.of(differenceFunction.apply(indexFunction.apply(startItemToSequence.get(startItem).getItems().last()),\n+                    indexFunction.apply(nextStartItem)));\n+        }).collect(Collectors.toList());", "originalCommit": "c58bf65b38aa7783632002886d8dcfecfd031cf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjc2ODE0Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r622768142", "bodyText": "Surely we can keep a counter instead.", "author": "triceo", "createdAt": "2021-04-29T06:32:57Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/ConsecutiveSetTree.java", "diffHunk": "@@ -0,0 +1,314 @@\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class ConsecutiveSetTree<T, I extends Comparable<I>, D extends Comparable<D>> implements Collection<T> {\n+    Function<T, I> indexFunction;\n+    BiFunction<I, I, D> differenceFunction;\n+    D maxDifference;\n+    D zeroDifference;\n+    TreeMap<T, Sequence<T>> startItemToSequence;\n+    Class<? extends T> typeClass;\n+    Comparator<T> comparator;\n+\n+    TreeMapValueList<T, Sequence<T>> sequenceList;\n+    ConsecutiveData<T, D> consecutiveData;\n+\n+    public ConsecutiveSetTree(Class<? extends T> typeClass, Function<T, I> indexFunction,\n+            BiFunction<I, I, D> differenceFunction, D maxDifference, D zeroDifference) {\n+        this.indexFunction = indexFunction;\n+        this.differenceFunction = differenceFunction;\n+        this.maxDifference = maxDifference;\n+        this.zeroDifference = zeroDifference;\n+        this.typeClass = typeClass;\n+        // Hashcode for duplicate protection\n+        // Ex: two different games on the same time slot\n+        comparator = Comparator.comparing(indexFunction).thenComparingInt(System::identityHashCode);\n+        startItemToSequence = new TreeMap<>(comparator);\n+        consecutiveData = new ConsecutiveData<>(this);\n+        sequenceList = new TreeMapValueList<>(startItemToSequence);\n+    }\n+\n+    public List<Sequence<T>> getConsecutiveSequences() {\n+        return sequenceList;\n+    }\n+\n+    public List<D> getBreaks() {\n+        return startItemToSequence.keySet().stream().flatMap(startItem -> {\n+            T nextStartItem = startItemToSequence.higherKey(startItem);\n+            if (nextStartItem == null) {\n+                return Stream.empty();\n+            }\n+            return Stream.of(differenceFunction.apply(indexFunction.apply(startItemToSequence.get(startItem).getItems().last()),\n+                    indexFunction.apply(nextStartItem)));\n+        }).collect(Collectors.toList());\n+    }\n+\n+    public List<D> getConsecutiveLengths() {\n+        return getConsecutiveSequences().stream()\n+                .map(sequence -> differenceFunction.apply(indexFunction.apply(sequence.getItems().first()),\n+                        indexFunction.apply(sequence.getItems().last())))\n+                .collect(Collectors.toList());\n+    }\n+\n+    public Optional<D> getBreakBefore(Sequence<T> sequence) {\n+        T startItem = sequence.getItems().first();\n+        T prevStartItem = startItemToSequence.lowerKey(startItem);\n+        if (prevStartItem == null) {\n+            return Optional.empty();\n+        }\n+        return Optional\n+                .of(differenceFunction.apply(indexFunction.apply(startItemToSequence.get(prevStartItem).getItems().last()),\n+                        indexFunction.apply(startItem)));\n+    }\n+\n+    public Optional<D> getBreakAfter(Sequence<T> sequence) {\n+        T endItem = sequence.getItems().last();\n+        T nextStartItem = startItemToSequence.higherKey(endItem);\n+        if (nextStartItem == null) {\n+            return Optional.empty();\n+        }\n+        return Optional.of(differenceFunction.apply(indexFunction.apply(endItem),\n+                indexFunction.apply(nextStartItem)));\n+    }\n+\n+    public ConsecutiveData<T, D> getConsecutiveData() {\n+        return consecutiveData;\n+    }\n+\n+    public I getEndIndex(T key) {\n+        return indexFunction.apply(startItemToSequence.get(key).getItems().last());\n+    }\n+\n+    private boolean isSecondSuccessorOfFirst(I first, I second) {\n+        D difference = differenceFunction.apply(second, first);\n+        return !(difference.compareTo(maxDifference) > 0 || difference.compareTo(zeroDifference) < 0);\n+    }\n+\n+    @Override\n+    public boolean add(T item) {\n+        T firstBeforeItem = startItemToSequence.floorKey(item);\n+        I itemIndex = indexFunction.apply(item);\n+        if (firstBeforeItem != null) {\n+            I endIndex = getEndIndex(firstBeforeItem);\n+            if (itemIndex.compareTo(endIndex) <= 0) {\n+                // Item is already in the bag; increase it count\n+                startItemToSequence.get(firstBeforeItem).add(item);\n+            } else {\n+                // Item is outside the bag\n+                T firstAfterItem = startItemToSequence.higherKey(item);\n+                if (firstAfterItem != null) {\n+                    I afterStartIndex = indexFunction.apply(firstAfterItem);\n+                    if (isSecondSuccessorOfFirst(itemIndex, endIndex)) {\n+                        // We need to extend the first bag\n+                        Sequence<T> prevBag = startItemToSequence.get(firstBeforeItem);\n+                        if (isSecondSuccessorOfFirst(afterStartIndex, itemIndex)) {\n+                            // We need to merge the two bags\n+                            Sequence<T> afterBag = startItemToSequence.remove(firstAfterItem);\n+                            prevBag.putAll(afterBag);\n+                        }\n+                        prevBag.add(item);\n+                    } else {\n+                        // Don't need to extend the first bag\n+                        if (isSecondSuccessorOfFirst(afterStartIndex, itemIndex)) {\n+                            // We need to move the after bag to use item as key\n+                            Sequence<T> afterBag = startItemToSequence.remove(firstAfterItem);\n+                            afterBag.add(item);\n+                            startItemToSequence.put(item, afterBag);\n+                        } else {\n+                            // Start a new bag of consecutive items\n+                            Sequence<T> newBag = new Sequence<>(this);\n+                            newBag.add(item);\n+                            startItemToSequence.put(item, newBag);\n+                        }\n+                    }\n+                } else {\n+                    if (isSecondSuccessorOfFirst(itemIndex, endIndex)) {\n+                        // We need to extend the first bag\n+                        Sequence<T> prevBag = startItemToSequence.get(firstBeforeItem);\n+                        prevBag.add(item);\n+                    } else {\n+                        // Start a new bag of consecutive items\n+                        Sequence<T> newBag = new Sequence<>(this);\n+                        newBag.add(item);\n+                        startItemToSequence.put(item, newBag);\n+                    }\n+                }\n+            }\n+        } else {\n+            // No items before it\n+            T firstAfterItem = startItemToSequence.higherKey(item);\n+            if (firstAfterItem != null) {\n+                I afterStartIndex = indexFunction.apply(firstAfterItem);\n+\n+                if (isSecondSuccessorOfFirst(afterStartIndex, itemIndex)) {\n+                    // We need to move the after bag to use item as key\n+                    Sequence<T> afterBag = startItemToSequence.remove(firstAfterItem);\n+                    afterBag.add(item);\n+                    startItemToSequence.put(item, afterBag);\n+                } else {\n+                    // Start a new bag of consecutive items\n+                    Sequence<T> newBag = new Sequence<>(this);\n+                    newBag.add(item);\n+                    startItemToSequence.put(item, newBag);\n+                }\n+            } else {\n+                // Start a new bag of consecutive items\n+                Sequence<T> newBag = new Sequence<>(this);\n+                newBag.add(item);\n+                startItemToSequence.put(item, newBag);\n+            }\n+        }\n+        return true;\n+    }\n+\n+    @Override\n+    public boolean remove(Object o) {\n+        if (!typeClass.isInstance(o)) {\n+            return false;\n+        } else {\n+            T item = typeClass.cast(o);\n+            T firstBeforeItem = startItemToSequence.floorKey(item);\n+            I itemIndex = indexFunction.apply(item);\n+            I endIndex = getEndIndex(firstBeforeItem);\n+\n+            if (itemIndex.compareTo(endIndex) > 0) {\n+                // Item not in bag\n+                return false;\n+            }\n+\n+            Sequence<T> bag = startItemToSequence.get(firstBeforeItem);\n+            T endItem = bag.getItems().last();\n+            boolean isRemoved = bag.remove(item);\n+            if (!isRemoved) {\n+                return true;\n+            }\n+\n+            // Count of item in bag is 0\n+            if (bag.isEmpty()) {\n+                startItemToSequence.remove(firstBeforeItem);\n+                return true;\n+            }\n+\n+            // Bag is not empty\n+            if (item.equals(firstBeforeItem)) {\n+                // Change start key to the item after this one\n+                startItemToSequence.remove(firstBeforeItem);\n+                startItemToSequence.put(bag.getItems().first(), bag);\n+                return true;\n+            }\n+            if (item.equals(endItem)) {\n+                // Item already removed from bag;\n+                // don't need to do anything\n+                return true;\n+            }\n+\n+            // Need to split bag into two halves\n+            // Both halves are not empty as the item was not an endpoint\n+            Sequence<T> splitBag = bag.split(item);\n+            startItemToSequence.put(splitBag.getItems().first(), splitBag);\n+            return true;\n+        }\n+    }\n+\n+    @Override\n+    public boolean containsAll(Collection<?> c) {\n+        return c.stream().allMatch(this::contains);\n+    }\n+\n+    @Override\n+    public boolean addAll(Collection<? extends T> c) {\n+        int oldSize = size();\n+        c.forEach(this::add);\n+        return size() > oldSize;\n+    }\n+\n+    @Override\n+    public boolean removeAll(Collection<?> c) {\n+        int oldSize = size();\n+        c.forEach(this::remove);\n+        return size() < oldSize;\n+    }\n+\n+    @Override\n+    public boolean retainAll(Collection<?> c) {\n+        int oldSize = size();\n+        stream().filter(item -> !c.contains(item)).forEach(this::remove);\n+        return size() < oldSize;\n+    }\n+\n+    @Override\n+    public void clear() {\n+        startItemToSequence.clear();\n+    }\n+\n+    @Override\n+    public int size() {\n+        return startItemToSequence.values().stream().map(Sequence::getCountIncludingDuplicates)\n+                .reduce(0, Integer::sum);", "originalCommit": "c58bf65b38aa7783632002886d8dcfecfd031cf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjc2OTg1Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r622769857", "bodyText": "This is public API, as it is exported by a public method. I suggest we treat these public types in the following way:\n\nInterface with the user-facing stuff is in api. (Sequence)\nImplementation with constructors and all the protected stuff is in impl. (SequenceImpl)\nImplementations have every method public, but the classes themselves are not.\n\nThis way, we make it very clear what is or is not accessible by users, but we get to hide the implementation.\nPlease apply the same to Break, ConsecutiveData and any other type that actually reaches the user.", "author": "triceo", "createdAt": "2021-04-29T06:36:48Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/Sequence.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+public class Sequence<T> {", "originalCommit": "c58bf65b38aa7783632002886d8dcfecfd031cf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjc3MTE4MA==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r622771180", "bodyText": "I am a bit blurry as to what we need this for. But I really do not like the fact that it is not incremental.\nMy view of Sequence is that is just a dumb no-op view to the underlying collection. (See the idea of a timeline I tried to explain earlier.)", "author": "triceo", "createdAt": "2021-04-29T06:39:34Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/Sequence.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.IdentityHashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeSet;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+import java.util.stream.Stream;\n+\n+public class Sequence<T> {\n+    private final TreeSet<T> consecutiveItemsSet;\n+    private final Map<T, Integer> count;\n+    private final ConsecutiveSetTree<T, ?, ?> sourceTree;\n+\n+    protected Sequence(ConsecutiveSetTree<T, ?, ?> sourceTree) {\n+        this(sourceTree, new TreeSet<>(sourceTree.comparator), new IdentityHashMap<>());\n+    }\n+\n+    protected Sequence(ConsecutiveSetTree<T, ?, ?> sourceTree, TreeSet<T> consecutiveItemsSet, Map<T, Integer> count) {\n+        this.sourceTree = sourceTree;\n+        this.consecutiveItemsSet = consecutiveItemsSet;\n+        this.count = count;\n+    }\n+\n+    public TreeSet<T> getItems() {\n+        return consecutiveItemsSet;\n+    }\n+\n+    public int getLength() {\n+        return consecutiveItemsSet.size();\n+    }\n+\n+    protected boolean isEmpty() {\n+        return consecutiveItemsSet.isEmpty();\n+    }\n+\n+    protected int getCountIncludingDuplicates() {\n+        return count.values().stream().reduce(Integer::sum).orElse(0);\n+    }\n+\n+    protected Stream<T> getDuplicatedStream() {\n+        return consecutiveItemsSet.stream()\n+                .flatMap(item -> IntStream.range(0, count.get(item)).mapToObj(index -> item));\n+    }", "originalCommit": "c58bf65b38aa7783632002886d8dcfecfd031cf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjc3MTQwMw==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r622771403", "bodyText": "Type names.", "author": "triceo", "createdAt": "2021-04-29T06:39:58Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/TreeMapValueList.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+import java.util.TreeMap;\n+\n+public class TreeMapValueList<I, T> implements List<T> {", "originalCommit": "c58bf65b38aa7783632002886d8dcfecfd031cf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjc3MzI4Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r622773287", "bodyText": "So all mutating methods are unsupported? In that case I doubt if the type is good for anything.\nWhat's the benefit of this as opposed to a couple of static util methods?\nOr a more tailored class that is not a List? It looks to me as if the List forces you to implement stuff you don't really need, obfuscating the purpose of the class.", "author": "triceo", "createdAt": "2021-04-29T06:43:49Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/TreeMapValueList.java", "diffHunk": "@@ -0,0 +1,277 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.NoSuchElementException;\n+import java.util.TreeMap;\n+\n+public class TreeMapValueList<I, T> implements List<T> {\n+    private final TreeMap<I, T> sourceMap;\n+\n+    public TreeMapValueList(TreeMap<I, T> sourceMap) {\n+        this.sourceMap = sourceMap;\n+    }\n+\n+    @Override\n+    public int size() {\n+        return sourceMap.size();\n+    }\n+\n+    @Override\n+    public boolean isEmpty() {\n+        return sourceMap.isEmpty();\n+    }\n+\n+    @Override\n+    public boolean contains(Object o) {\n+        return sourceMap.values().contains(o);\n+    }\n+\n+    @Override\n+    public Iterator<T> iterator() {\n+        return sourceMap.values().iterator();\n+    }\n+\n+    @Override\n+    public Object[] toArray() {\n+        return sourceMap.values().toArray();\n+    }\n+\n+    @Override\n+    public <T1> T1[] toArray(T1[] a) {\n+        return sourceMap.values().toArray(a);\n+    }\n+\n+    @Override\n+    public boolean add(T t) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean remove(Object o) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean containsAll(Collection<?> c) {\n+        return sourceMap.values().containsAll(c);\n+    }\n+\n+    @Override\n+    public boolean addAll(Collection<? extends T> c) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean addAll(int index, Collection<? extends T> c) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean removeAll(Collection<?> c) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public boolean retainAll(Collection<?> c) {\n+        throw new UnsupportedOperationException();\n+    }", "originalCommit": "c58bf65b38aa7783632002886d8dcfecfd031cf5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzExMTQyNg==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r623111426", "bodyText": "A TreeMap doesn't have a get(index) method. I expect most people wants a list of sequences (in the order the sequence occurs in). I also makes testing easier (as I can refer to the sequence by index). Most of this stuff would need to be implemented for any Collection type, leaving Iterable as the only interface we can implement so we get iterator functionality (but I expect most people want a Collection).", "author": "Christopher-Chianelli", "createdAt": "2021-04-29T14:33:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjc3MzI4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjc3MzY4Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r622773682", "bodyText": "Nice to standardize this.\nConsider implementing one method with the other, so that the logic is not duplicated.", "author": "triceo", "createdAt": "2021-04-29T06:44:36Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/domain/contract/MinMaxContractLine.java", "diffHunk": "@@ -29,6 +29,26 @@\n     private int maximumValue;\n     private int maximumWeight;\n \n+    public boolean isViolated(int count) {\n+        if (minimumEnabled && count < minimumValue) {\n+            return true;\n+        } else if (maximumEnabled && count > maximumValue) {\n+            return true;\n+        } else {\n+            return false;\n+        }\n+    }\n+\n+    public int getViolationAmount(int count) {\n+        if (minimumEnabled && count < minimumValue) {\n+            return (minimumValue - count) * minimumWeight;\n+        } else if (maximumEnabled && count > maximumValue) {\n+            return (count - maximumValue) * maximumWeight;\n+        } else {\n+            return 0;\n+        }\n+    }", "originalCommit": "c58bf65b38aa7783632002886d8dcfecfd031cf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjc3NDM2Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r622774363", "bodyText": "I would put the nested stream first, into its own variable. That way, this will become much better to read.\nAlso, the formatting of the consecutive filters and penalize doesn't seem right here. They should be on the same level.", "author": "triceo", "createdAt": "2021-04-29T06:45:56Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.bi.BiConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Sequence<ShiftAssignment>>\n+            getConsecutiveShifts(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ConstraintCollectors.consecutive((contract, employee, shift) -> shift,\n+                                ShiftAssignment::getShiftDateDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                oneShiftPerDay(constraintFactory),\n+                minimumAndMaximumNumberOfAssignments(constraintFactory),\n+                minimumConsecutiveWorkingDays(constraintFactory),\n+                maximumConsecutiveWorkingDays(constraintFactory)\n+        };\n+    }\n+\n+    // ############################################################################\n+    // Hard constraints\n+    // ############################################################################\n+\n+    // A nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day.\n+    Constraint oneShiftPerDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory\n+                .fromUniquePair(ShiftAssignment.class,\n+                        Joiners.equal(ShiftAssignment::getEmployee, ShiftAssignment::getShiftDate))\n+                .penalize(\"oneShiftPerDay\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    // ############################################################################\n+    // Soft constraints\n+    // ############################################################################\n+    Constraint minimumAndMaximumNumberOfAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((line, employee, shift) -> ImmutablePair.of(employee, line), ConstraintCollectors.countTri())\n+                .filter((employeeContractPair, shiftCount) -> employeeContractPair.getRight().isViolated(shiftCount))\n+                .penalize(\"Minimum and maximum number of assignments\", HardSoftScore.ONE_SOFT,\n+                        (employeeContractPair, shiftCount) -> employeeContractPair.getRight().getViolationAmount(shiftCount));\n+    }\n+\n+    Constraint minimumConsecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isMinimumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() < employeeContractPair.getRight().getMinimumValue())\n+                                .penalize(\"minimumConsecutiveWorkingDays\", HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));", "originalCommit": "c58bf65b38aa7783632002886d8dcfecfd031cf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjc3NDQzNg==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r622774436", "bodyText": "Dtto.", "author": "triceo", "createdAt": "2021-04-29T06:46:05Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,509 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.bi.BiConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Sequence<ShiftAssignment>>\n+            getConsecutiveShifts(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ConstraintCollectors.consecutive((contract, employee, shift) -> shift,\n+                                ShiftAssignment::getShiftDateDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                oneShiftPerDay(constraintFactory),\n+                minimumAndMaximumNumberOfAssignments(constraintFactory),\n+                minimumConsecutiveWorkingDays(constraintFactory),\n+                maximumConsecutiveWorkingDays(constraintFactory)\n+        };\n+    }\n+\n+    // ############################################################################\n+    // Hard constraints\n+    // ############################################################################\n+\n+    // A nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day.\n+    Constraint oneShiftPerDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory\n+                .fromUniquePair(ShiftAssignment.class,\n+                        Joiners.equal(ShiftAssignment::getEmployee, ShiftAssignment::getShiftDate))\n+                .penalize(\"oneShiftPerDay\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    // ############################################################################\n+    // Soft constraints\n+    // ############################################################################\n+    Constraint minimumAndMaximumNumberOfAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((line, employee, shift) -> ImmutablePair.of(employee, line), ConstraintCollectors.countTri())\n+                .filter((employeeContractPair, shiftCount) -> employeeContractPair.getRight().isViolated(shiftCount))\n+                .penalize(\"Minimum and maximum number of assignments\", HardSoftScore.ONE_SOFT,\n+                        (employeeContractPair, shiftCount) -> employeeContractPair.getRight().getViolationAmount(shiftCount));\n+    }\n+\n+    Constraint minimumConsecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isMinimumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() < employeeContractPair.getRight().getMinimumValue())\n+                                .penalize(\"minimumConsecutiveWorkingDays\", HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));\n+\n+    }\n+\n+    Constraint maximumConsecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)", "originalCommit": "c58bf65b38aa7783632002886d8dcfecfd031cf5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjkyODc3Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r622928777", "bodyText": "The additions and removals from these bags are going to be where this code spends the most time, I think.\nIt will be imperative to optimize it.\nI still have the idea of a timeline in my head.\nWhere the timeline would essentially be a list of shifts in order.\nAnd the sequences would essentially just be a tuple of (indexFrom, indexTo), pointing to that list.\nTo retrieve the shifts, you then just do subList(indexFrom, indexTo), which is pretty much a no-op.\nBut I have no proof that it would actually be faster. (It could be simpler, though.)\nIt'd have to be tried.", "author": "triceo", "createdAt": "2021-04-29T10:36:32Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/ConsecutiveSetTree.java", "diffHunk": "@@ -0,0 +1,314 @@\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class ConsecutiveSetTree<T, I extends Comparable<I>, D extends Comparable<D>> implements Collection<T> {\n+    Function<T, I> indexFunction;\n+    BiFunction<I, I, D> differenceFunction;\n+    D maxDifference;\n+    D zeroDifference;\n+    TreeMap<T, Sequence<T>> startItemToSequence;\n+    Class<? extends T> typeClass;\n+    Comparator<T> comparator;\n+\n+    TreeMapValueList<T, Sequence<T>> sequenceList;\n+    ConsecutiveData<T, D> consecutiveData;\n+\n+    public ConsecutiveSetTree(Class<? extends T> typeClass, Function<T, I> indexFunction,\n+            BiFunction<I, I, D> differenceFunction, D maxDifference, D zeroDifference) {\n+        this.indexFunction = indexFunction;\n+        this.differenceFunction = differenceFunction;\n+        this.maxDifference = maxDifference;\n+        this.zeroDifference = zeroDifference;\n+        this.typeClass = typeClass;\n+        // Hashcode for duplicate protection\n+        // Ex: two different games on the same time slot\n+        comparator = Comparator.comparing(indexFunction).thenComparingInt(System::identityHashCode);\n+        startItemToSequence = new TreeMap<>(comparator);\n+        consecutiveData = new ConsecutiveData<>(this);\n+        sequenceList = new TreeMapValueList<>(startItemToSequence);\n+    }\n+\n+    public List<Sequence<T>> getConsecutiveSequences() {\n+        return sequenceList;\n+    }\n+\n+    public List<D> getBreaks() {\n+        return startItemToSequence.keySet().stream().flatMap(startItem -> {\n+            T nextStartItem = startItemToSequence.higherKey(startItem);\n+            if (nextStartItem == null) {\n+                return Stream.empty();\n+            }\n+            return Stream.of(differenceFunction.apply(indexFunction.apply(startItemToSequence.get(startItem).getItems().last()),\n+                    indexFunction.apply(nextStartItem)));\n+        }).collect(Collectors.toList());\n+    }\n+\n+    public List<D> getConsecutiveLengths() {\n+        return getConsecutiveSequences().stream()\n+                .map(sequence -> differenceFunction.apply(indexFunction.apply(sequence.getItems().first()),\n+                        indexFunction.apply(sequence.getItems().last())))\n+                .collect(Collectors.toList());\n+    }\n+\n+    public Optional<D> getBreakBefore(Sequence<T> sequence) {\n+        T startItem = sequence.getItems().first();\n+        T prevStartItem = startItemToSequence.lowerKey(startItem);\n+        if (prevStartItem == null) {\n+            return Optional.empty();\n+        }\n+        return Optional\n+                .of(differenceFunction.apply(indexFunction.apply(startItemToSequence.get(prevStartItem).getItems().last()),\n+                        indexFunction.apply(startItem)));\n+    }\n+\n+    public Optional<D> getBreakAfter(Sequence<T> sequence) {\n+        T endItem = sequence.getItems().last();\n+        T nextStartItem = startItemToSequence.higherKey(endItem);\n+        if (nextStartItem == null) {\n+            return Optional.empty();\n+        }\n+        return Optional.of(differenceFunction.apply(indexFunction.apply(endItem),\n+                indexFunction.apply(nextStartItem)));\n+    }\n+\n+    public ConsecutiveData<T, D> getConsecutiveData() {\n+        return consecutiveData;\n+    }\n+\n+    public I getEndIndex(T key) {\n+        return indexFunction.apply(startItemToSequence.get(key).getItems().last());\n+    }\n+\n+    private boolean isSecondSuccessorOfFirst(I first, I second) {\n+        D difference = differenceFunction.apply(second, first);\n+        return !(difference.compareTo(maxDifference) > 0 || difference.compareTo(zeroDifference) < 0);\n+    }\n+\n+    @Override\n+    public boolean add(T item) {\n+        T firstBeforeItem = startItemToSequence.floorKey(item);\n+        I itemIndex = indexFunction.apply(item);\n+        if (firstBeforeItem != null) {\n+            I endIndex = getEndIndex(firstBeforeItem);\n+            if (itemIndex.compareTo(endIndex) <= 0) {\n+                // Item is already in the bag; increase it count\n+                startItemToSequence.get(firstBeforeItem).add(item);\n+            } else {\n+                // Item is outside the bag\n+                T firstAfterItem = startItemToSequence.higherKey(item);\n+                if (firstAfterItem != null) {\n+                    I afterStartIndex = indexFunction.apply(firstAfterItem);\n+                    if (isSecondSuccessorOfFirst(itemIndex, endIndex)) {\n+                        // We need to extend the first bag\n+                        Sequence<T> prevBag = startItemToSequence.get(firstBeforeItem);\n+                        if (isSecondSuccessorOfFirst(afterStartIndex, itemIndex)) {\n+                            // We need to merge the two bags\n+                            Sequence<T> afterBag = startItemToSequence.remove(firstAfterItem);\n+                            prevBag.putAll(afterBag);", "originalCommit": "c58bf65b38aa7783632002886d8dcfecfd031cf5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzExNTkyOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r623115929", "bodyText": "Intervals are currently not supported (nor do I think can be supported).\nConsider the following example:\n[1,2], [2,3], [3,4],[1,3],[3,5]\nThe following are all consecutive:\n[1,2],[2,3],[3,4]\n[1,3],[3,4]\n[1,3],[3,5]\n[2,3],[3,5]\nIn which case, what should the list of consecutive sequences be? There are duplicate nodes. Currently, what is supported is consecutive points, NOT consecutive intervals.", "author": "Christopher-Chianelli", "createdAt": "2021-04-29T14:38:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjkyODc3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzEyMzAyMg==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r623123022", "bodyText": "I see your point, and that is why I estimated this to take longer than 1 sprint. :-) I believe we need to be able to answer the question, because this use case will show up.\nIn my opinion, overlapping intervals belong in the sequence.\nIt is the job of another constraint to make sure overlapping shifts do not happen.", "author": "triceo", "createdAt": "2021-04-29T14:45:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjkyODc3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMzEyNTA5Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r623125093", "bodyText": "Perhaps Sequence is the wrong name here. Cluster sounds closer to what I think it should be.\nIt is all the shifts that happen between two breaks. If some of them overlap, it is no longer a sequence, it is a cluster.", "author": "triceo", "createdAt": "2021-04-29T14:48:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjkyODc3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzMjA0Mzc4MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r632043781", "bodyText": "Added an interval based implementation for clusters in IntervalTree", "author": "Christopher-Chianelli", "createdAt": "2021-05-13T19:15:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMjkyODc3Nw=="}], "type": "inlineReview"}, {"oid": "8bc0a6b658c087412d7a4b4057a36f316ef5c2b5", "url": "https://github.com/kiegroup/optaplanner/commit/8bc0a6b658c087412d7a4b4057a36f316ef5c2b5", "message": "Add interval version of the consecutive collector", "committedDate": "2021-05-13T18:57:43Z", "type": "forcePushed"}, {"oid": "f5d91181dcc4dfd5cff922c0e5d704d8599ae360", "url": "https://github.com/kiegroup/optaplanner/commit/f5d91181dcc4dfd5cff922c0e5d704d8599ae360", "message": "Formatting", "committedDate": "2021-05-13T19:12:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDY4OTE0Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634689147", "bodyText": "I and D need to be proper names, typically ending with _.", "author": "triceo", "createdAt": "2021-05-18T19:31:33Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/Break.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.Objects;\n+\n+public class Break<I, D> {", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDY4OTM0Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634689347", "bodyText": "The class is called Break. getLength() ought to be enough.", "author": "triceo", "createdAt": "2021-05-18T19:31:54Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/Break.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.Objects;\n+\n+public class Break<I, D> {\n+    final I beforeItem;\n+    final I afterItem;\n+    final D breakLength;\n+\n+    public Break(I beforeItem, I afterItem, D breakLength) {\n+        this.beforeItem = beforeItem;\n+        this.afterItem = afterItem;\n+        this.breakLength = breakLength;\n+    }\n+\n+    public I getBeforeItem() {\n+        return beforeItem;\n+    }\n+\n+    public I getAfterItem() {\n+        return afterItem;\n+    }\n+\n+    public D getBreakLength() {", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDY4OTc5Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634689797", "bodyText": "Why do we need equality? Shouldn't identity be enough for this use case?", "author": "triceo", "createdAt": "2021-05-18T19:32:41Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/Break.java", "diffHunk": "@@ -0,0 +1,68 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.Objects;\n+\n+public class Break<I, D> {\n+    final I beforeItem;\n+    final I afterItem;\n+    final D breakLength;\n+\n+    public Break(I beforeItem, I afterItem, D breakLength) {\n+        this.beforeItem = beforeItem;\n+        this.afterItem = afterItem;\n+        this.breakLength = breakLength;\n+    }\n+\n+    public I getBeforeItem() {\n+        return beforeItem;\n+    }\n+\n+    public I getAfterItem() {\n+        return afterItem;\n+    }\n+\n+    public D getBreakLength() {\n+        return breakLength;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o)\n+            return true;\n+        if (o == null || getClass() != o.getClass())\n+            return false;\n+        Break<?, ?> aBreak = (Break<?, ?>) o;\n+        return Objects.equals(beforeItem, aBreak.beforeItem) && Objects.equals(afterItem, aBreak.afterItem)\n+                && Objects.equals(breakLength, aBreak.breakLength);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(beforeItem, afterItem, breakLength);\n+    }", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDcwMjgwNg==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634702806", "bodyText": "It make it easier to test. It not needed outside of tests, but needed for tests so assertEquals() assertions work", "author": "Christopher-Chianelli", "createdAt": "2021-05-18T19:53:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDY4OTc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDY5MDIxMQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634690211", "bodyText": "The _ goes at the end of the name. :-) But I like the names themselves.", "author": "triceo", "createdAt": "2021-05-18T19:33:25Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/ConsecutiveIntervalData.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import org.apache.commons.lang3.ObjectUtils;\n+\n+public class ConsecutiveIntervalData<_IntervalValue, _PointValue extends Comparable<_PointValue>> {", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDY5MDk3Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634690973", "bodyText": "Same question on what we need equality for here.", "author": "triceo", "createdAt": "2021-05-18T19:34:43Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/ConsecutiveIntervalData.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NavigableMap;\n+import java.util.Objects;\n+import java.util.TreeMap;\n+import java.util.TreeSet;\n+\n+import org.apache.commons.lang3.ObjectUtils;\n+\n+public class ConsecutiveIntervalData<_IntervalValue, _PointValue extends Comparable<_PointValue>> {\n+    private final TreeMap<IntervalSplitPoint<_IntervalValue, _PointValue>, IntervalCluster<_IntervalValue, _PointValue>> clusterStartSplitPointToCluster;\n+    private final TreeSet<IntervalSplitPoint<_IntervalValue, _PointValue>> splitPointSet;\n+    private final List<IntervalCluster<_IntervalValue, _PointValue>> valueList;\n+\n+    public ConsecutiveIntervalData(TreeSet<IntervalSplitPoint<_IntervalValue, _PointValue>> splitPointSet) {\n+        clusterStartSplitPointToCluster = new TreeMap<>();\n+        valueList = new TreeMapValueList<>(clusterStartSplitPointToCluster);\n+        this.splitPointSet = splitPointSet;\n+    }\n+\n+    protected void addInterval(Interval<_IntervalValue, _PointValue> interval) {\n+        NavigableMap<IntervalSplitPoint<_IntervalValue, _PointValue>, IntervalCluster<_IntervalValue, _PointValue>> intersectedIntervalClusterMap =\n+                clusterStartSplitPointToCluster.subMap(\n+                        ObjectUtils.defaultIfNull(clusterStartSplitPointToCluster.floorKey(interval.getStartSplitPoint()),\n+                                interval.getStartSplitPoint()),\n+                        true, interval.getEndSplitPoint(), true);\n+\n+        // Case: the interval cluster before this interval does not intersect this interval\n+        if (!intersectedIntervalClusterMap.isEmpty()\n+                && intersectedIntervalClusterMap.get(intersectedIntervalClusterMap.firstKey()).getEndSplitPoint()\n+                        .compareTo(interval.getStartSplitPoint()) < 0) {\n+            intersectedIntervalClusterMap = intersectedIntervalClusterMap.subMap(intersectedIntervalClusterMap.firstKey(),\n+                    false, intersectedIntervalClusterMap.lastKey(), true);\n+        }\n+\n+        if (intersectedIntervalClusterMap.isEmpty()) {\n+            IntervalSplitPoint<_IntervalValue, _PointValue> start = splitPointSet.floor(interval.getStartSplitPoint());\n+            clusterStartSplitPointToCluster.put(start, new IntervalCluster<>(splitPointSet, start));\n+            return;\n+        }\n+        IntervalCluster<_IntervalValue, _PointValue> intervalCluster =\n+                intersectedIntervalClusterMap.get(intersectedIntervalClusterMap.firstKey());\n+        IntervalSplitPoint<_IntervalValue, _PointValue> oldStart = intervalCluster.getStartSplitPoint();\n+        intervalCluster.addInterval(interval);\n+        intersectedIntervalClusterMap.tailMap(intersectedIntervalClusterMap.firstKey(), false).values()\n+                .forEach(intervalCluster::mergeIntervalCluster);\n+        intersectedIntervalClusterMap.tailMap(intersectedIntervalClusterMap.firstKey(), false).clear();\n+        if (oldStart.compareTo(intervalCluster.getStartSplitPoint()) > 0) {\n+            clusterStartSplitPointToCluster.remove(oldStart);\n+            clusterStartSplitPointToCluster.put(intervalCluster.getStartSplitPoint(), intervalCluster);\n+        }\n+    }\n+\n+    protected void removalInterval(Interval<_IntervalValue, _PointValue> interval) {\n+        Map.Entry<IntervalSplitPoint<_IntervalValue, _PointValue>, IntervalCluster<_IntervalValue, _PointValue>> intervalClusterEntry =\n+                clusterStartSplitPointToCluster.floorEntry(interval.getStartSplitPoint());\n+        IntervalCluster<_IntervalValue, _PointValue> intervalCluster = intervalClusterEntry.getValue();\n+        clusterStartSplitPointToCluster.remove(intervalClusterEntry.getKey());\n+        for (IntervalCluster<_IntervalValue, _PointValue> newIntervalCluster : intervalCluster.removeInterval(interval)) {\n+            clusterStartSplitPointToCluster.put(newIntervalCluster.getStartSplitPoint(), newIntervalCluster);\n+        }\n+    }\n+\n+    public List<IntervalCluster<_IntervalValue, _PointValue>> getIntervalClusters() {\n+        return valueList;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o)\n+            return true;\n+        if (o == null || getClass() != o.getClass())\n+            return false;\n+        ConsecutiveIntervalData<?, ?> that = (ConsecutiveIntervalData<?, ?>) o;\n+        return valueList.equals(that.valueList);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(valueList);\n+    }", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDcwMjk5NA==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634702994", "bodyText": "Same as above; tests", "author": "Christopher-Chianelli", "createdAt": "2021-05-18T19:53:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDY5MDk3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDY5MTQyNg==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634691426", "bodyText": "This is likely to be used in CS. Therefore it needs to be incremental.", "author": "triceo", "createdAt": "2021-05-18T19:35:28Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/ConsecutiveSetTree.java", "diffHunk": "@@ -0,0 +1,316 @@\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class ConsecutiveSetTree<T, I extends Comparable<I>, D extends Comparable<D>> implements Collection<T> {\n+    Function<T, I> indexFunction;\n+    BiFunction<I, I, D> differenceFunction;\n+    D maxDifference;\n+    D zeroDifference;\n+    TreeMap<T, Sequence<T>> startItemToSequence;\n+    Class<? extends T> typeClass;\n+    Comparator<T> comparator;\n+\n+    TreeMapValueList<T, Sequence<T>> sequenceList;\n+    ConsecutiveData<T, D> consecutiveData;\n+\n+    public ConsecutiveSetTree(Class<? extends T> typeClass, Function<T, I> indexFunction,\n+            BiFunction<I, I, D> differenceFunction, D maxDifference, D zeroDifference) {\n+        this.indexFunction = indexFunction;\n+        this.differenceFunction = differenceFunction;\n+        this.maxDifference = maxDifference;\n+        this.zeroDifference = zeroDifference;\n+        this.typeClass = typeClass;\n+        // Hashcode for duplicate protection\n+        // Ex: two different games on the same time slot\n+        comparator = Comparator.comparing(indexFunction).thenComparingInt(System::identityHashCode);\n+        startItemToSequence = new TreeMap<>(comparator);\n+        consecutiveData = new ConsecutiveData<>(this);\n+        sequenceList = new TreeMapValueList<>(startItemToSequence);\n+    }\n+\n+    public List<Sequence<T>> getConsecutiveSequences() {\n+        return sequenceList;\n+    }\n+\n+    public List<Break<T, D>> getBreaks() {\n+        return startItemToSequence.keySet().stream().flatMap(startItem -> {\n+            T nextStartItem = startItemToSequence.higherKey(startItem);\n+            if (nextStartItem == null) {\n+                return Stream.empty();\n+            }\n+            T endOfCurrentSequence = startItemToSequence.get(startItem).getItems().last();\n+            return Stream.of(new Break<>(nextStartItem, endOfCurrentSequence,\n+                    differenceFunction.apply(indexFunction.apply(endOfCurrentSequence),\n+                            indexFunction.apply(nextStartItem))));\n+        }).collect(Collectors.toList());", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDY5MjEzMA==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634692130", "bodyText": "This is hard to understand. I would put the individual components into their own variables, making the information flow more obvious.", "author": "triceo", "createdAt": "2021-05-18T19:36:34Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/ConsecutiveSetTree.java", "diffHunk": "@@ -0,0 +1,316 @@\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.Collection;\n+import java.util.Comparator;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.TreeMap;\n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+public class ConsecutiveSetTree<T, I extends Comparable<I>, D extends Comparable<D>> implements Collection<T> {\n+    Function<T, I> indexFunction;\n+    BiFunction<I, I, D> differenceFunction;\n+    D maxDifference;\n+    D zeroDifference;\n+    TreeMap<T, Sequence<T>> startItemToSequence;\n+    Class<? extends T> typeClass;\n+    Comparator<T> comparator;\n+\n+    TreeMapValueList<T, Sequence<T>> sequenceList;\n+    ConsecutiveData<T, D> consecutiveData;\n+\n+    public ConsecutiveSetTree(Class<? extends T> typeClass, Function<T, I> indexFunction,\n+            BiFunction<I, I, D> differenceFunction, D maxDifference, D zeroDifference) {\n+        this.indexFunction = indexFunction;\n+        this.differenceFunction = differenceFunction;\n+        this.maxDifference = maxDifference;\n+        this.zeroDifference = zeroDifference;\n+        this.typeClass = typeClass;\n+        // Hashcode for duplicate protection\n+        // Ex: two different games on the same time slot\n+        comparator = Comparator.comparing(indexFunction).thenComparingInt(System::identityHashCode);\n+        startItemToSequence = new TreeMap<>(comparator);\n+        consecutiveData = new ConsecutiveData<>(this);\n+        sequenceList = new TreeMapValueList<>(startItemToSequence);\n+    }\n+\n+    public List<Sequence<T>> getConsecutiveSequences() {\n+        return sequenceList;\n+    }\n+\n+    public List<Break<T, D>> getBreaks() {\n+        return startItemToSequence.keySet().stream().flatMap(startItem -> {\n+            T nextStartItem = startItemToSequence.higherKey(startItem);\n+            if (nextStartItem == null) {\n+                return Stream.empty();\n+            }\n+            T endOfCurrentSequence = startItemToSequence.get(startItem).getItems().last();\n+            return Stream.of(new Break<>(nextStartItem, endOfCurrentSequence,\n+                    differenceFunction.apply(indexFunction.apply(endOfCurrentSequence),\n+                            indexFunction.apply(nextStartItem))));\n+        }).collect(Collectors.toList());\n+    }\n+\n+    public List<D> getConsecutiveLengths() {\n+        return getConsecutiveSequences().stream()\n+                .map(sequence -> differenceFunction.apply(indexFunction.apply(sequence.getItems().first()),\n+                        indexFunction.apply(sequence.getItems().last())))\n+                .collect(Collectors.toList());\n+    }\n+\n+    public Optional<D> getBreakBefore(Sequence<T> sequence) {\n+        T startItem = sequence.getItems().first();\n+        T prevStartItem = startItemToSequence.lowerKey(startItem);\n+        if (prevStartItem == null) {\n+            return Optional.empty();\n+        }\n+        return Optional\n+                .of(differenceFunction.apply(indexFunction.apply(startItemToSequence.get(prevStartItem).getItems().last()),\n+                        indexFunction.apply(startItem)));", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDY5MjY2Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634692663", "bodyText": "Same note on _.", "author": "triceo", "createdAt": "2021-05-18T19:37:30Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/Interval.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.function.Function;\n+\n+public class Interval<_IntervalValue, _PointValue extends Comparable<_PointValue>> {", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDY5Mjg3Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634692872", "bodyText": "Same question on the need for equality.", "author": "triceo", "createdAt": "2021-05-18T19:37:53Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/Interval.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.function.Function;\n+\n+public class Interval<_IntervalValue, _PointValue extends Comparable<_PointValue>> {\n+    final _IntervalValue value;\n+    final IntervalSplitPoint<_IntervalValue, _PointValue> startSplitPoint;\n+    final IntervalSplitPoint<_IntervalValue, _PointValue> endSplitPoint;\n+\n+    public Interval(_IntervalValue value, Function<_IntervalValue, _PointValue> startMapping,\n+            Function<_IntervalValue, _PointValue> endMapping) {\n+        this.value = value;\n+        this.startSplitPoint = new IntervalSplitPoint<>(startMapping.apply(value));\n+        this.endSplitPoint = new IntervalSplitPoint<>(endMapping.apply(value));\n+    }\n+\n+    public _IntervalValue getValue() {\n+        return value;\n+    }\n+\n+    public _PointValue getStart() {\n+        return startSplitPoint.splitPoint;\n+    }\n+\n+    public _PointValue getEnd() {\n+        return endSplitPoint.splitPoint;\n+    }\n+\n+    public IntervalSplitPoint<_IntervalValue, _PointValue> getStartSplitPoint() {\n+        return startSplitPoint;\n+    }\n+\n+    public IntervalSplitPoint<_IntervalValue, _PointValue> getEndSplitPoint() {\n+        return endSplitPoint;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o)\n+            return true;\n+        if (o == null || getClass() != o.getClass())\n+            return false;\n+        Interval<?, ?> that = (Interval<?, ?>) o;\n+        return value == that.value;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return System.identityHashCode(value);\n+    }", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDY5MzA4MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634693081", "bodyText": "_ belongs at the end.", "author": "triceo", "createdAt": "2021-05-18T19:38:17Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/IntervalCluster.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.Iterator;\n+import java.util.Objects;\n+import java.util.TreeSet;\n+\n+public class IntervalCluster<_IntervalValue, _PointValue extends Comparable<_PointValue>> implements Iterable<_IntervalValue> {", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDY5MzM5Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634693396", "bodyText": "_ goes at the end.", "author": "triceo", "createdAt": "2021-05-18T19:38:50Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/IntervalSplitPoint.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.Comparator;\n+import java.util.IdentityHashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeSet;\n+import java.util.stream.IntStream;\n+\n+public class IntervalSplitPoint<_IntervalValue, _PointValue extends Comparable<_PointValue>>", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDY5NDI2OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634694269", "bodyText": "The iterator here seems unnecessary - streams are already iterable.\nI do not see where this is used, perhaps there is some reason for it, but unless it's necessary, I'd prefer removing the indirection.", "author": "triceo", "createdAt": "2021-05-18T19:40:25Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/IntervalSplitPoint.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.Comparator;\n+import java.util.IdentityHashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeSet;\n+import java.util.stream.IntStream;\n+\n+public class IntervalSplitPoint<_IntervalValue, _PointValue extends Comparable<_PointValue>>\n+        implements Comparable<IntervalSplitPoint<_IntervalValue, _PointValue>> {\n+    final _PointValue splitPoint;\n+    Map<_IntervalValue, Integer> startIntervalToCountMap;\n+    Map<_IntervalValue, Integer> endIntervalToCountMap;\n+    TreeSet<Interval<_IntervalValue, _PointValue>> intervalsStartingAtSplitPointSet;\n+    TreeSet<Interval<_IntervalValue, _PointValue>> intervalsEndingAtSplitPointSet;\n+\n+    public IntervalSplitPoint(_PointValue splitPoint) {\n+        this.splitPoint = splitPoint;\n+    }\n+\n+    protected void createCollections() {\n+        startIntervalToCountMap = new IdentityHashMap<>();\n+        endIntervalToCountMap = new IdentityHashMap<>();\n+        intervalsStartingAtSplitPointSet = new TreeSet<>(\n+                Comparator.<Interval<_IntervalValue, _PointValue>, _PointValue> comparing(Interval::getEnd)\n+                        .thenComparingInt(interval -> System.identityHashCode(interval.value)));\n+        intervalsEndingAtSplitPointSet = new TreeSet<>(\n+                Comparator.<Interval<_IntervalValue, _PointValue>, _PointValue> comparing(Interval::getStart)\n+                        .thenComparingInt(interval -> System.identityHashCode(interval.value)));\n+    }\n+\n+    public boolean addIntervalStartingAtSplitPoint(Interval<_IntervalValue, _PointValue> interval) {\n+        startIntervalToCountMap.merge(interval.value, 1, Integer::sum);\n+        return intervalsStartingAtSplitPointSet.add(interval);\n+    }\n+\n+    public void removeIntervalStartingAtSplitPoint(Interval<_IntervalValue, _PointValue> interval) {\n+        Integer newCount = startIntervalToCountMap.computeIfPresent(interval.value, (key, count) -> {\n+            if (count > 1) {\n+                return count - 1;\n+            }\n+            return null;\n+        });\n+        if (null == newCount) {\n+            intervalsStartingAtSplitPointSet.remove(interval);\n+        }\n+    }\n+\n+    public boolean addIntervalEndingAtSplitPoint(Interval<_IntervalValue, _PointValue> interval) {\n+        endIntervalToCountMap.merge(interval.value, 1, Integer::sum);\n+        return intervalsEndingAtSplitPointSet.add(interval);\n+    }\n+\n+    public void removeIntervalEndingAtSplitPoint(Interval<_IntervalValue, _PointValue> interval) {\n+        Integer newCount = endIntervalToCountMap.computeIfPresent(interval.value, (key, count) -> {\n+            if (count > 1) {\n+                return count - 1;\n+            }\n+            return null;\n+        });\n+        if (null == newCount) {\n+            intervalsEndingAtSplitPointSet.remove(interval);\n+        }\n+    }\n+\n+    public boolean containsIntervalStarting(Interval<_IntervalValue, _PointValue> interval) {\n+        return intervalsStartingAtSplitPointSet.contains(interval);\n+    }\n+\n+    public boolean containsIntervalEnding(Interval<_IntervalValue, _PointValue> interval) {\n+        return intervalsEndingAtSplitPointSet.contains(interval);\n+    }\n+\n+    public Iterator<_IntervalValue> getValuesStartingFromSplitPointIterator() {\n+        return intervalsStartingAtSplitPointSet.stream()\n+                .flatMap(interval -> IntStream.range(0, startIntervalToCountMap.get(interval.value))\n+                        .mapToObj((index) -> interval.value))\n+                .iterator();\n+    }", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDY5NDU0OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634694549", "bodyText": "Same question on the need for equality.", "author": "triceo", "createdAt": "2021-05-18T19:40:52Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/IntervalSplitPoint.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.Comparator;\n+import java.util.IdentityHashMap;\n+import java.util.Iterator;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.TreeSet;\n+import java.util.stream.IntStream;\n+\n+public class IntervalSplitPoint<_IntervalValue, _PointValue extends Comparable<_PointValue>>\n+        implements Comparable<IntervalSplitPoint<_IntervalValue, _PointValue>> {\n+    final _PointValue splitPoint;\n+    Map<_IntervalValue, Integer> startIntervalToCountMap;\n+    Map<_IntervalValue, Integer> endIntervalToCountMap;\n+    TreeSet<Interval<_IntervalValue, _PointValue>> intervalsStartingAtSplitPointSet;\n+    TreeSet<Interval<_IntervalValue, _PointValue>> intervalsEndingAtSplitPointSet;\n+\n+    public IntervalSplitPoint(_PointValue splitPoint) {\n+        this.splitPoint = splitPoint;\n+    }\n+\n+    protected void createCollections() {\n+        startIntervalToCountMap = new IdentityHashMap<>();\n+        endIntervalToCountMap = new IdentityHashMap<>();\n+        intervalsStartingAtSplitPointSet = new TreeSet<>(\n+                Comparator.<Interval<_IntervalValue, _PointValue>, _PointValue> comparing(Interval::getEnd)\n+                        .thenComparingInt(interval -> System.identityHashCode(interval.value)));\n+        intervalsEndingAtSplitPointSet = new TreeSet<>(\n+                Comparator.<Interval<_IntervalValue, _PointValue>, _PointValue> comparing(Interval::getStart)\n+                        .thenComparingInt(interval -> System.identityHashCode(interval.value)));\n+    }\n+\n+    public boolean addIntervalStartingAtSplitPoint(Interval<_IntervalValue, _PointValue> interval) {\n+        startIntervalToCountMap.merge(interval.value, 1, Integer::sum);\n+        return intervalsStartingAtSplitPointSet.add(interval);\n+    }\n+\n+    public void removeIntervalStartingAtSplitPoint(Interval<_IntervalValue, _PointValue> interval) {\n+        Integer newCount = startIntervalToCountMap.computeIfPresent(interval.value, (key, count) -> {\n+            if (count > 1) {\n+                return count - 1;\n+            }\n+            return null;\n+        });\n+        if (null == newCount) {\n+            intervalsStartingAtSplitPointSet.remove(interval);\n+        }\n+    }\n+\n+    public boolean addIntervalEndingAtSplitPoint(Interval<_IntervalValue, _PointValue> interval) {\n+        endIntervalToCountMap.merge(interval.value, 1, Integer::sum);\n+        return intervalsEndingAtSplitPointSet.add(interval);\n+    }\n+\n+    public void removeIntervalEndingAtSplitPoint(Interval<_IntervalValue, _PointValue> interval) {\n+        Integer newCount = endIntervalToCountMap.computeIfPresent(interval.value, (key, count) -> {\n+            if (count > 1) {\n+                return count - 1;\n+            }\n+            return null;\n+        });\n+        if (null == newCount) {\n+            intervalsEndingAtSplitPointSet.remove(interval);\n+        }\n+    }\n+\n+    public boolean containsIntervalStarting(Interval<_IntervalValue, _PointValue> interval) {\n+        return intervalsStartingAtSplitPointSet.contains(interval);\n+    }\n+\n+    public boolean containsIntervalEnding(Interval<_IntervalValue, _PointValue> interval) {\n+        return intervalsEndingAtSplitPointSet.contains(interval);\n+    }\n+\n+    public Iterator<_IntervalValue> getValuesStartingFromSplitPointIterator() {\n+        return intervalsStartingAtSplitPointSet.stream()\n+                .flatMap(interval -> IntStream.range(0, startIntervalToCountMap.get(interval.value))\n+                        .mapToObj((index) -> interval.value))\n+                .iterator();\n+    }\n+\n+    public boolean isEmpty() {\n+        return intervalsStartingAtSplitPointSet.isEmpty() && intervalsEndingAtSplitPointSet.isEmpty();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o)\n+            return true;\n+        if (o == null || getClass() != o.getClass())\n+            return false;\n+        IntervalSplitPoint<?, ?> that = (IntervalSplitPoint<?, ?>) o;\n+        return splitPoint.equals(that.splitPoint);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(splitPoint);\n+    }", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDcwMzQxNA==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634703414", "bodyText": "IntervalSplitPoint implements Comparable so it should override equals IMO", "author": "Christopher-Chianelli", "createdAt": "2021-05-18T19:54:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDY5NDU0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDY5NDY2Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634694667", "bodyText": "_ goes at the end.", "author": "triceo", "createdAt": "2021-05-18T19:41:04Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/IntervalTree.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.Iterator;\n+import java.util.TreeSet;\n+import java.util.function.Function;\n+\n+public class IntervalTree<_IntervalValue, _PointValue extends Comparable<_PointValue>> {", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDY5NDg0Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634694842", "bodyText": "Instance fields are generally private.", "author": "triceo", "createdAt": "2021-05-18T19:41:21Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/IntervalTree.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.Iterator;\n+import java.util.TreeSet;\n+import java.util.function.Function;\n+\n+public class IntervalTree<_IntervalValue, _PointValue extends Comparable<_PointValue>> {\n+    final TreeSet<IntervalSplitPoint<_IntervalValue, _PointValue>> splitPointSet;\n+    final Function<_IntervalValue, _PointValue> startMapping;\n+    final Function<_IntervalValue, _PointValue> endMapping;\n+    final ConsecutiveIntervalData<_IntervalValue, _PointValue> consecutiveIntervalData;", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDY5NTE2Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634695163", "bodyText": "_ goes at the end.", "author": "triceo", "createdAt": "2021-05-18T19:41:51Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/IntervalTreeIterator.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.Iterator;\n+\n+public class IntervalTreeIterator<_IntervalValue, _PointValue extends Comparable<_PointValue>>", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDY5NTMxMw==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634695313", "bodyText": "private please.", "author": "triceo", "createdAt": "2021-05-18T19:42:05Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/util/IntervalTreeIterator.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.util;\n+\n+import java.util.Iterator;\n+\n+public class IntervalTreeIterator<_IntervalValue, _PointValue extends Comparable<_PointValue>>\n+        implements Iterator<_IntervalValue> {\n+    final Iterator<IntervalSplitPoint<_IntervalValue, _PointValue>> splitPointSetIterator;\n+    Iterator<_IntervalValue> splitPointValueIterator;", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDcwMTMxMg==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634701312", "bodyText": "I'd rather we not use ImmutablePair here if a suitable groupBy() overload is available.\nIt makes for a code that reads better, and does not introduce users to new types which are not strictly necessary.\nIt may even perform a bit better, as we do not create needless tuple objects all the time.", "author": "triceo", "createdAt": "2021-05-18T19:51:14Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.bi.BiConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.BiTuple;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.util.Break;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.common.ExperimentalConstraintCollectors;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.NurseRosterParametrization;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.ShiftDate;\n+import org.optaplanner.examples.nurserostering.domain.ShiftType;\n+import org.optaplanner.examples.nurserostering.domain.ShiftTypeSkillRequirement;\n+import org.optaplanner.examples.nurserostering.domain.SkillProficiency;\n+import org.optaplanner.examples.nurserostering.domain.contract.BooleanContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.PatternContractLine;\n+import org.optaplanner.examples.nurserostering.domain.pattern.FreeBefore2DaysWithAWorkDayPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType2DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType3DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOnRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOnRequest;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentEnd;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentStart;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public <C extends ContractLine> BiConstraintStream<ImmutablePair<Employee, C>, Sequence<ShiftDate>>\n+            getConsecutiveShifts(UniConstraintStream<C> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(ContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDcwNDg0OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634704849", "bodyText": "It was ImmutablePair, but unfortunately ImmutablePair implements Comparable, meaning that when a score corruption occurs (eariler when I was debugging), it tries to access it compareTo method, which fails since MinMaxContractLine does not implement Comparable.", "author": "Christopher-Chianelli", "createdAt": "2021-05-18T19:56:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDcwMTMxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDcwMTU5NA==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634701594", "bodyText": "Dtto.", "author": "triceo", "createdAt": "2021-05-18T19:51:31Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.bi.BiConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.BiTuple;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.util.Break;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.common.ExperimentalConstraintCollectors;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.NurseRosterParametrization;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.ShiftDate;\n+import org.optaplanner.examples.nurserostering.domain.ShiftType;\n+import org.optaplanner.examples.nurserostering.domain.ShiftTypeSkillRequirement;\n+import org.optaplanner.examples.nurserostering.domain.SkillProficiency;\n+import org.optaplanner.examples.nurserostering.domain.contract.BooleanContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.PatternContractLine;\n+import org.optaplanner.examples.nurserostering.domain.pattern.FreeBefore2DaysWithAWorkDayPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType2DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType3DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOnRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOnRequest;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentEnd;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentStart;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public <C extends ContractLine> BiConstraintStream<ImmutablePair<Employee, C>, Sequence<ShiftDate>>\n+            getConsecutiveShifts(UniConstraintStream<C> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(ContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Break<ShiftDate, Integer>>\n+            getBreaks(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDcwMTc1Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634701752", "bodyText": "Dtto.", "author": "triceo", "createdAt": "2021-05-18T19:51:42Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.bi.BiConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.BiTuple;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.util.Break;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.common.ExperimentalConstraintCollectors;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.NurseRosterParametrization;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.ShiftDate;\n+import org.optaplanner.examples.nurserostering.domain.ShiftType;\n+import org.optaplanner.examples.nurserostering.domain.ShiftTypeSkillRequirement;\n+import org.optaplanner.examples.nurserostering.domain.SkillProficiency;\n+import org.optaplanner.examples.nurserostering.domain.contract.BooleanContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.PatternContractLine;\n+import org.optaplanner.examples.nurserostering.domain.pattern.FreeBefore2DaysWithAWorkDayPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType2DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType3DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOnRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOnRequest;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentEnd;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentStart;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public <C extends ContractLine> BiConstraintStream<ImmutablePair<Employee, C>, Sequence<ShiftDate>>\n+            getConsecutiveShifts(UniConstraintStream<C> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(ContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Break<ShiftDate, Integer>>\n+            getBreaks(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getBreaks);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Sequence<ShiftDate>>\n+            getConsecutiveWorkingWeekends(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee),\n+                        Joiners.filtering((c, e, s) -> s.isWeekend()))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDcwMjM4OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634702389", "bodyText": "I understand that you're including the package so that FULL_ASSERT works when compared against the DRL.\nThat said, this does not make the constraint provider easier to understand.\nI'd rather change the DRL package than introduce this boilerplate in the constraint provider.", "author": "triceo", "createdAt": "2021-05-18T19:52:48Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.bi.BiConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.BiTuple;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.util.Break;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.common.ExperimentalConstraintCollectors;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.NurseRosterParametrization;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.ShiftDate;\n+import org.optaplanner.examples.nurserostering.domain.ShiftType;\n+import org.optaplanner.examples.nurserostering.domain.ShiftTypeSkillRequirement;\n+import org.optaplanner.examples.nurserostering.domain.SkillProficiency;\n+import org.optaplanner.examples.nurserostering.domain.contract.BooleanContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.PatternContractLine;\n+import org.optaplanner.examples.nurserostering.domain.pattern.FreeBefore2DaysWithAWorkDayPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType2DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType3DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOnRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOnRequest;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentEnd;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentStart;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public <C extends ContractLine> BiConstraintStream<ImmutablePair<Employee, C>, Sequence<ShiftDate>>\n+            getConsecutiveShifts(UniConstraintStream<C> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(ContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Break<ShiftDate, Integer>>\n+            getBreaks(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getBreaks);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Sequence<ShiftDate>>\n+            getConsecutiveWorkingWeekends(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee),\n+                        Joiners.filtering((c, e, s) -> s.isWeekend()))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getWeekendSundayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                oneShiftPerDay(constraintFactory),\n+                minimumAndMaximumNumberOfAssignments(constraintFactory),\n+                minimumNumberOfAssignmentsNoAssignments(constraintFactory),\n+                minimumConsecutiveWorkingDays(constraintFactory),\n+                maximumConsecutiveWorkingDays(constraintFactory),\n+                minimumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDaysNoAssignments(constraintFactory),\n+                consecutiveFreeDaysFirstBreak(constraintFactory),\n+                consecutiveFreeDaysFinalBreak(constraintFactory),\n+                minimumConsecutiveWorkingWeekends(constraintFactory),\n+                maximumConsecutiveWorkingWeekends(constraintFactory),\n+                startOnNotFirstDayOfWeekend(constraintFactory),\n+                endOnNotLastDayOfWeekend(constraintFactory),\n+                identicalShiftTypesDuringWeekend(constraintFactory),\n+                dayOffRequest(constraintFactory),\n+                dayOnRequest(constraintFactory),\n+                shiftOffRequest(constraintFactory),\n+                shiftOnRequest(constraintFactory),\n+                alternativeSkill(constraintFactory),\n+                unwantedPatternFreeBefore2DaysWithAWorkDayPattern(constraintFactory),\n+                unwantedPatternShiftType2DaysPattern(constraintFactory),\n+                unwantedPatternShiftType3DaysPattern(constraintFactory),\n+        };\n+    }\n+\n+    // ############################################################################\n+    // Hard constraints\n+    // ############################################################################\n+\n+    // A nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day.\n+    Constraint oneShiftPerDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory\n+                .fromUniquePair(ShiftAssignment.class,\n+                        Joiners.equal(ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftAssignment::getShiftDate))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"oneShiftPerDay\", HardSoftScore.ONE_HARD);", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDcwNTk4NA==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634705984", "bodyText": "I don't think it needed so FULL_ASSERT would work. Rather, it removes extra constraint matches shown in the score corruption overview when a score corruption does occur. I'll remove them.", "author": "Christopher-Chianelli", "createdAt": "2021-05-18T19:58:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDcwMjM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDcwMzUzNw==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634703537", "bodyText": "This is hard to read. The fact that the stream is passed to a function is fine, but I think that the stream should first be declared, and then the variable passed. Easier to understand at first sight.", "author": "triceo", "createdAt": "2021-05-18T19:54:44Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.bi.BiConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.BiTuple;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.util.Break;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.common.ExperimentalConstraintCollectors;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.NurseRosterParametrization;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.ShiftDate;\n+import org.optaplanner.examples.nurserostering.domain.ShiftType;\n+import org.optaplanner.examples.nurserostering.domain.ShiftTypeSkillRequirement;\n+import org.optaplanner.examples.nurserostering.domain.SkillProficiency;\n+import org.optaplanner.examples.nurserostering.domain.contract.BooleanContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.PatternContractLine;\n+import org.optaplanner.examples.nurserostering.domain.pattern.FreeBefore2DaysWithAWorkDayPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType2DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType3DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOnRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOnRequest;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentEnd;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentStart;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public <C extends ContractLine> BiConstraintStream<ImmutablePair<Employee, C>, Sequence<ShiftDate>>\n+            getConsecutiveShifts(UniConstraintStream<C> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(ContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Break<ShiftDate, Integer>>\n+            getBreaks(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getBreaks);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Sequence<ShiftDate>>\n+            getConsecutiveWorkingWeekends(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee),\n+                        Joiners.filtering((c, e, s) -> s.isWeekend()))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getWeekendSundayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                oneShiftPerDay(constraintFactory),\n+                minimumAndMaximumNumberOfAssignments(constraintFactory),\n+                minimumNumberOfAssignmentsNoAssignments(constraintFactory),\n+                minimumConsecutiveWorkingDays(constraintFactory),\n+                maximumConsecutiveWorkingDays(constraintFactory),\n+                minimumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDaysNoAssignments(constraintFactory),\n+                consecutiveFreeDaysFirstBreak(constraintFactory),\n+                consecutiveFreeDaysFinalBreak(constraintFactory),\n+                minimumConsecutiveWorkingWeekends(constraintFactory),\n+                maximumConsecutiveWorkingWeekends(constraintFactory),\n+                startOnNotFirstDayOfWeekend(constraintFactory),\n+                endOnNotLastDayOfWeekend(constraintFactory),\n+                identicalShiftTypesDuringWeekend(constraintFactory),\n+                dayOffRequest(constraintFactory),\n+                dayOnRequest(constraintFactory),\n+                shiftOffRequest(constraintFactory),\n+                shiftOnRequest(constraintFactory),\n+                alternativeSkill(constraintFactory),\n+                unwantedPatternFreeBefore2DaysWithAWorkDayPattern(constraintFactory),\n+                unwantedPatternShiftType2DaysPattern(constraintFactory),\n+                unwantedPatternShiftType3DaysPattern(constraintFactory),\n+        };\n+    }\n+\n+    // ############################################################################\n+    // Hard constraints\n+    // ############################################################################\n+\n+    // A nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day.\n+    Constraint oneShiftPerDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory\n+                .fromUniquePair(ShiftAssignment.class,\n+                        Joiners.equal(ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftAssignment::getShiftDate))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"oneShiftPerDay\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    // ############################################################################\n+    // Soft constraints\n+    // ############################################################################\n+    Constraint minimumAndMaximumNumberOfAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((line, employee, shift) -> ImmutablePair.of(employee, line), ConstraintCollectors.countTri())\n+                .filter((employeeContractPair, shiftCount) -> employeeContractPair.getRight().isViolated(shiftCount))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"Minimum and maximum number of assignments\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (employeeContractPair, shiftCount) -> employeeContractPair.getRight().getViolationAmount(shiftCount));\n+    }\n+\n+    Constraint minimumNumberOfAssignmentsNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .filter((contract, employee) -> contract.isViolated(0))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\",\n+                        \"Minimum and maximum number of assignments (no assignments)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee) -> contract.getViolationAmount(0));\n+    }\n+\n+    // Min/Max consecutive working days\n+    // These Min/Max constraints are implemented as two constraints for consistency with DRL\n+    Constraint minimumConsecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isMinimumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() < employeeContractPair.getRight().getMinimumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minimumConsecutiveWorkingDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDcwMzc3Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634703772", "bodyText": "Dtto.", "author": "triceo", "createdAt": "2021-05-18T19:55:08Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.bi.BiConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.BiTuple;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.util.Break;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.common.ExperimentalConstraintCollectors;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.NurseRosterParametrization;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.ShiftDate;\n+import org.optaplanner.examples.nurserostering.domain.ShiftType;\n+import org.optaplanner.examples.nurserostering.domain.ShiftTypeSkillRequirement;\n+import org.optaplanner.examples.nurserostering.domain.SkillProficiency;\n+import org.optaplanner.examples.nurserostering.domain.contract.BooleanContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.PatternContractLine;\n+import org.optaplanner.examples.nurserostering.domain.pattern.FreeBefore2DaysWithAWorkDayPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType2DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType3DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOnRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOnRequest;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentEnd;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentStart;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public <C extends ContractLine> BiConstraintStream<ImmutablePair<Employee, C>, Sequence<ShiftDate>>\n+            getConsecutiveShifts(UniConstraintStream<C> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(ContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Break<ShiftDate, Integer>>\n+            getBreaks(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getBreaks);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Sequence<ShiftDate>>\n+            getConsecutiveWorkingWeekends(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee),\n+                        Joiners.filtering((c, e, s) -> s.isWeekend()))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getWeekendSundayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                oneShiftPerDay(constraintFactory),\n+                minimumAndMaximumNumberOfAssignments(constraintFactory),\n+                minimumNumberOfAssignmentsNoAssignments(constraintFactory),\n+                minimumConsecutiveWorkingDays(constraintFactory),\n+                maximumConsecutiveWorkingDays(constraintFactory),\n+                minimumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDaysNoAssignments(constraintFactory),\n+                consecutiveFreeDaysFirstBreak(constraintFactory),\n+                consecutiveFreeDaysFinalBreak(constraintFactory),\n+                minimumConsecutiveWorkingWeekends(constraintFactory),\n+                maximumConsecutiveWorkingWeekends(constraintFactory),\n+                startOnNotFirstDayOfWeekend(constraintFactory),\n+                endOnNotLastDayOfWeekend(constraintFactory),\n+                identicalShiftTypesDuringWeekend(constraintFactory),\n+                dayOffRequest(constraintFactory),\n+                dayOnRequest(constraintFactory),\n+                shiftOffRequest(constraintFactory),\n+                shiftOnRequest(constraintFactory),\n+                alternativeSkill(constraintFactory),\n+                unwantedPatternFreeBefore2DaysWithAWorkDayPattern(constraintFactory),\n+                unwantedPatternShiftType2DaysPattern(constraintFactory),\n+                unwantedPatternShiftType3DaysPattern(constraintFactory),\n+        };\n+    }\n+\n+    // ############################################################################\n+    // Hard constraints\n+    // ############################################################################\n+\n+    // A nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day.\n+    Constraint oneShiftPerDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory\n+                .fromUniquePair(ShiftAssignment.class,\n+                        Joiners.equal(ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftAssignment::getShiftDate))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"oneShiftPerDay\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    // ############################################################################\n+    // Soft constraints\n+    // ############################################################################\n+    Constraint minimumAndMaximumNumberOfAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((line, employee, shift) -> ImmutablePair.of(employee, line), ConstraintCollectors.countTri())\n+                .filter((employeeContractPair, shiftCount) -> employeeContractPair.getRight().isViolated(shiftCount))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"Minimum and maximum number of assignments\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (employeeContractPair, shiftCount) -> employeeContractPair.getRight().getViolationAmount(shiftCount));\n+    }\n+\n+    Constraint minimumNumberOfAssignmentsNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .filter((contract, employee) -> contract.isViolated(0))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\",\n+                        \"Minimum and maximum number of assignments (no assignments)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee) -> contract.getViolationAmount(0));\n+    }\n+\n+    // Min/Max consecutive working days\n+    // These Min/Max constraints are implemented as two constraints for consistency with DRL\n+    Constraint minimumConsecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isMinimumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() < employeeContractPair.getRight().getMinimumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minimumConsecutiveWorkingDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    Constraint maximumConsecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() > employeeContractPair.getRight().getMaximumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"maximumConsecutiveWorkingDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Min/Max consecutive free days\n+    Constraint minimumConsecutiveFreeDays(ConstraintFactory constraintFactory) {\n+        return getBreaks(constraintFactory.from(MinMaxContractLine.class)", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDcwMzgyMQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634703821", "bodyText": "Dtto.", "author": "triceo", "createdAt": "2021-05-18T19:55:13Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.bi.BiConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.BiTuple;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.util.Break;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.common.ExperimentalConstraintCollectors;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.NurseRosterParametrization;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.ShiftDate;\n+import org.optaplanner.examples.nurserostering.domain.ShiftType;\n+import org.optaplanner.examples.nurserostering.domain.ShiftTypeSkillRequirement;\n+import org.optaplanner.examples.nurserostering.domain.SkillProficiency;\n+import org.optaplanner.examples.nurserostering.domain.contract.BooleanContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.PatternContractLine;\n+import org.optaplanner.examples.nurserostering.domain.pattern.FreeBefore2DaysWithAWorkDayPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType2DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType3DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOnRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOnRequest;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentEnd;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentStart;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public <C extends ContractLine> BiConstraintStream<ImmutablePair<Employee, C>, Sequence<ShiftDate>>\n+            getConsecutiveShifts(UniConstraintStream<C> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(ContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Break<ShiftDate, Integer>>\n+            getBreaks(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getBreaks);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Sequence<ShiftDate>>\n+            getConsecutiveWorkingWeekends(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee),\n+                        Joiners.filtering((c, e, s) -> s.isWeekend()))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getWeekendSundayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                oneShiftPerDay(constraintFactory),\n+                minimumAndMaximumNumberOfAssignments(constraintFactory),\n+                minimumNumberOfAssignmentsNoAssignments(constraintFactory),\n+                minimumConsecutiveWorkingDays(constraintFactory),\n+                maximumConsecutiveWorkingDays(constraintFactory),\n+                minimumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDaysNoAssignments(constraintFactory),\n+                consecutiveFreeDaysFirstBreak(constraintFactory),\n+                consecutiveFreeDaysFinalBreak(constraintFactory),\n+                minimumConsecutiveWorkingWeekends(constraintFactory),\n+                maximumConsecutiveWorkingWeekends(constraintFactory),\n+                startOnNotFirstDayOfWeekend(constraintFactory),\n+                endOnNotLastDayOfWeekend(constraintFactory),\n+                identicalShiftTypesDuringWeekend(constraintFactory),\n+                dayOffRequest(constraintFactory),\n+                dayOnRequest(constraintFactory),\n+                shiftOffRequest(constraintFactory),\n+                shiftOnRequest(constraintFactory),\n+                alternativeSkill(constraintFactory),\n+                unwantedPatternFreeBefore2DaysWithAWorkDayPattern(constraintFactory),\n+                unwantedPatternShiftType2DaysPattern(constraintFactory),\n+                unwantedPatternShiftType3DaysPattern(constraintFactory),\n+        };\n+    }\n+\n+    // ############################################################################\n+    // Hard constraints\n+    // ############################################################################\n+\n+    // A nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day.\n+    Constraint oneShiftPerDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory\n+                .fromUniquePair(ShiftAssignment.class,\n+                        Joiners.equal(ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftAssignment::getShiftDate))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"oneShiftPerDay\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    // ############################################################################\n+    // Soft constraints\n+    // ############################################################################\n+    Constraint minimumAndMaximumNumberOfAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((line, employee, shift) -> ImmutablePair.of(employee, line), ConstraintCollectors.countTri())\n+                .filter((employeeContractPair, shiftCount) -> employeeContractPair.getRight().isViolated(shiftCount))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"Minimum and maximum number of assignments\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (employeeContractPair, shiftCount) -> employeeContractPair.getRight().getViolationAmount(shiftCount));\n+    }\n+\n+    Constraint minimumNumberOfAssignmentsNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .filter((contract, employee) -> contract.isViolated(0))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\",\n+                        \"Minimum and maximum number of assignments (no assignments)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee) -> contract.getViolationAmount(0));\n+    }\n+\n+    // Min/Max consecutive working days\n+    // These Min/Max constraints are implemented as two constraints for consistency with DRL\n+    Constraint minimumConsecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isMinimumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() < employeeContractPair.getRight().getMinimumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minimumConsecutiveWorkingDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    Constraint maximumConsecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() > employeeContractPair.getRight().getMaximumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"maximumConsecutiveWorkingDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Min/Max consecutive free days\n+    Constraint minimumConsecutiveFreeDays(ConstraintFactory constraintFactory) {\n+        return getBreaks(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMinimumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        breakInfo) -> breakInfo.getBreakLength() - 1 < employeeContractPair.getRight()\n+                                                .getMinimumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minimumConsecutiveFreeDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, breakInfo) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(breakInfo.getBreakLength() - 1));\n+    }\n+\n+    Constraint maximumConsecutiveFreeDays(ConstraintFactory constraintFactory) {\n+        return getBreaks(constraintFactory.from(MinMaxContractLine.class)", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDcwNDY0Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634704643", "bodyText": "If you need one reason to not use ImmutablePair here, it is this.\ncontractEmployeePair.a is very cryptic. Especially since it can just be contract.", "author": "triceo", "createdAt": "2021-05-18T19:56:36Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.bi.BiConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.BiTuple;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.util.Break;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.common.ExperimentalConstraintCollectors;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.NurseRosterParametrization;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.ShiftDate;\n+import org.optaplanner.examples.nurserostering.domain.ShiftType;\n+import org.optaplanner.examples.nurserostering.domain.ShiftTypeSkillRequirement;\n+import org.optaplanner.examples.nurserostering.domain.SkillProficiency;\n+import org.optaplanner.examples.nurserostering.domain.contract.BooleanContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.PatternContractLine;\n+import org.optaplanner.examples.nurserostering.domain.pattern.FreeBefore2DaysWithAWorkDayPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType2DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType3DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOnRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOnRequest;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentEnd;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentStart;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public <C extends ContractLine> BiConstraintStream<ImmutablePair<Employee, C>, Sequence<ShiftDate>>\n+            getConsecutiveShifts(UniConstraintStream<C> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(ContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Break<ShiftDate, Integer>>\n+            getBreaks(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getBreaks);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Sequence<ShiftDate>>\n+            getConsecutiveWorkingWeekends(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee),\n+                        Joiners.filtering((c, e, s) -> s.isWeekend()))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getWeekendSundayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                oneShiftPerDay(constraintFactory),\n+                minimumAndMaximumNumberOfAssignments(constraintFactory),\n+                minimumNumberOfAssignmentsNoAssignments(constraintFactory),\n+                minimumConsecutiveWorkingDays(constraintFactory),\n+                maximumConsecutiveWorkingDays(constraintFactory),\n+                minimumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDaysNoAssignments(constraintFactory),\n+                consecutiveFreeDaysFirstBreak(constraintFactory),\n+                consecutiveFreeDaysFinalBreak(constraintFactory),\n+                minimumConsecutiveWorkingWeekends(constraintFactory),\n+                maximumConsecutiveWorkingWeekends(constraintFactory),\n+                startOnNotFirstDayOfWeekend(constraintFactory),\n+                endOnNotLastDayOfWeekend(constraintFactory),\n+                identicalShiftTypesDuringWeekend(constraintFactory),\n+                dayOffRequest(constraintFactory),\n+                dayOnRequest(constraintFactory),\n+                shiftOffRequest(constraintFactory),\n+                shiftOnRequest(constraintFactory),\n+                alternativeSkill(constraintFactory),\n+                unwantedPatternFreeBefore2DaysWithAWorkDayPattern(constraintFactory),\n+                unwantedPatternShiftType2DaysPattern(constraintFactory),\n+                unwantedPatternShiftType3DaysPattern(constraintFactory),\n+        };\n+    }\n+\n+    // ############################################################################\n+    // Hard constraints\n+    // ############################################################################\n+\n+    // A nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day.\n+    Constraint oneShiftPerDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory\n+                .fromUniquePair(ShiftAssignment.class,\n+                        Joiners.equal(ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftAssignment::getShiftDate))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"oneShiftPerDay\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    // ############################################################################\n+    // Soft constraints\n+    // ############################################################################\n+    Constraint minimumAndMaximumNumberOfAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((line, employee, shift) -> ImmutablePair.of(employee, line), ConstraintCollectors.countTri())\n+                .filter((employeeContractPair, shiftCount) -> employeeContractPair.getRight().isViolated(shiftCount))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"Minimum and maximum number of assignments\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (employeeContractPair, shiftCount) -> employeeContractPair.getRight().getViolationAmount(shiftCount));\n+    }\n+\n+    Constraint minimumNumberOfAssignmentsNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .filter((contract, employee) -> contract.isViolated(0))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\",\n+                        \"Minimum and maximum number of assignments (no assignments)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee) -> contract.getViolationAmount(0));\n+    }\n+\n+    // Min/Max consecutive working days\n+    // These Min/Max constraints are implemented as two constraints for consistency with DRL\n+    Constraint minimumConsecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isMinimumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() < employeeContractPair.getRight().getMinimumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minimumConsecutiveWorkingDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    Constraint maximumConsecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() > employeeContractPair.getRight().getMaximumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"maximumConsecutiveWorkingDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Min/Max consecutive free days\n+    Constraint minimumConsecutiveFreeDays(ConstraintFactory constraintFactory) {\n+        return getBreaks(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMinimumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        breakInfo) -> breakInfo.getBreakLength() - 1 < employeeContractPair.getRight()\n+                                                .getMinimumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minimumConsecutiveFreeDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, breakInfo) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(breakInfo.getBreakLength() - 1));\n+    }\n+\n+    Constraint maximumConsecutiveFreeDays(ConstraintFactory constraintFactory) {\n+        return getBreaks(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        breakInfo) -> breakInfo.getBreakLength() - 1 > employeeContractPair.getRight()\n+                                                .getMaximumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"maximumConsecutiveFreeDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, breakInfo) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(breakInfo.getBreakLength() - 1));\n+    }\n+\n+    Constraint maximumConsecutiveFreeDaysNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .join(NurseRosterParametrization.class, Joiners.lessThan((contract, employee) -> contract.getMaximumValue(),\n+                        nrp -> nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"maximumConsecutiveFreeDays (no shifts)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contract, employee, nrp) -> contract\n+                                .getViolationAmount(nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1));\n+    }\n+\n+    Constraint consecutiveFreeDaysFirstBreak(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shiftAssignment) -> new BiTuple<>(contract, employee),\n+                        ConstraintCollectors.<MinMaxContractLine, Employee, ShiftAssignment, ShiftAssignment> min(\n+                                (contract, employee, shiftAssignment) -> shiftAssignment))\n+                .join(NurseRosterParametrization.class)\n+                .filter((contractEmployeePair, sa,\n+                        nrp) -> nrp.getFirstShiftDate() != sa.getShiftDate() && contractEmployeePair.a", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDcwNTE5Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634705196", "bodyText": "Is the cast necessary? It may be some compiler corner-case, but from the looks of it, it appears fairly straight-forward.", "author": "triceo", "createdAt": "2021-05-18T19:57:30Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.bi.BiConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.BiTuple;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.util.Break;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.common.ExperimentalConstraintCollectors;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.NurseRosterParametrization;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.ShiftDate;\n+import org.optaplanner.examples.nurserostering.domain.ShiftType;\n+import org.optaplanner.examples.nurserostering.domain.ShiftTypeSkillRequirement;\n+import org.optaplanner.examples.nurserostering.domain.SkillProficiency;\n+import org.optaplanner.examples.nurserostering.domain.contract.BooleanContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.PatternContractLine;\n+import org.optaplanner.examples.nurserostering.domain.pattern.FreeBefore2DaysWithAWorkDayPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType2DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType3DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOnRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOnRequest;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentEnd;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentStart;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public <C extends ContractLine> BiConstraintStream<ImmutablePair<Employee, C>, Sequence<ShiftDate>>\n+            getConsecutiveShifts(UniConstraintStream<C> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(ContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Break<ShiftDate, Integer>>\n+            getBreaks(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getBreaks);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Sequence<ShiftDate>>\n+            getConsecutiveWorkingWeekends(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee),\n+                        Joiners.filtering((c, e, s) -> s.isWeekend()))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getWeekendSundayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                oneShiftPerDay(constraintFactory),\n+                minimumAndMaximumNumberOfAssignments(constraintFactory),\n+                minimumNumberOfAssignmentsNoAssignments(constraintFactory),\n+                minimumConsecutiveWorkingDays(constraintFactory),\n+                maximumConsecutiveWorkingDays(constraintFactory),\n+                minimumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDaysNoAssignments(constraintFactory),\n+                consecutiveFreeDaysFirstBreak(constraintFactory),\n+                consecutiveFreeDaysFinalBreak(constraintFactory),\n+                minimumConsecutiveWorkingWeekends(constraintFactory),\n+                maximumConsecutiveWorkingWeekends(constraintFactory),\n+                startOnNotFirstDayOfWeekend(constraintFactory),\n+                endOnNotLastDayOfWeekend(constraintFactory),\n+                identicalShiftTypesDuringWeekend(constraintFactory),\n+                dayOffRequest(constraintFactory),\n+                dayOnRequest(constraintFactory),\n+                shiftOffRequest(constraintFactory),\n+                shiftOnRequest(constraintFactory),\n+                alternativeSkill(constraintFactory),\n+                unwantedPatternFreeBefore2DaysWithAWorkDayPattern(constraintFactory),\n+                unwantedPatternShiftType2DaysPattern(constraintFactory),\n+                unwantedPatternShiftType3DaysPattern(constraintFactory),\n+        };\n+    }\n+\n+    // ############################################################################\n+    // Hard constraints\n+    // ############################################################################\n+\n+    // A nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day.\n+    Constraint oneShiftPerDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory\n+                .fromUniquePair(ShiftAssignment.class,\n+                        Joiners.equal(ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftAssignment::getShiftDate))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"oneShiftPerDay\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    // ############################################################################\n+    // Soft constraints\n+    // ############################################################################\n+    Constraint minimumAndMaximumNumberOfAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((line, employee, shift) -> ImmutablePair.of(employee, line), ConstraintCollectors.countTri())\n+                .filter((employeeContractPair, shiftCount) -> employeeContractPair.getRight().isViolated(shiftCount))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"Minimum and maximum number of assignments\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (employeeContractPair, shiftCount) -> employeeContractPair.getRight().getViolationAmount(shiftCount));\n+    }\n+\n+    Constraint minimumNumberOfAssignmentsNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .filter((contract, employee) -> contract.isViolated(0))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\",\n+                        \"Minimum and maximum number of assignments (no assignments)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee) -> contract.getViolationAmount(0));\n+    }\n+\n+    // Min/Max consecutive working days\n+    // These Min/Max constraints are implemented as two constraints for consistency with DRL\n+    Constraint minimumConsecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isMinimumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() < employeeContractPair.getRight().getMinimumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minimumConsecutiveWorkingDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    Constraint maximumConsecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() > employeeContractPair.getRight().getMaximumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"maximumConsecutiveWorkingDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Min/Max consecutive free days\n+    Constraint minimumConsecutiveFreeDays(ConstraintFactory constraintFactory) {\n+        return getBreaks(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMinimumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        breakInfo) -> breakInfo.getBreakLength() - 1 < employeeContractPair.getRight()\n+                                                .getMinimumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minimumConsecutiveFreeDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, breakInfo) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(breakInfo.getBreakLength() - 1));\n+    }\n+\n+    Constraint maximumConsecutiveFreeDays(ConstraintFactory constraintFactory) {\n+        return getBreaks(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        breakInfo) -> breakInfo.getBreakLength() - 1 > employeeContractPair.getRight()\n+                                                .getMaximumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"maximumConsecutiveFreeDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, breakInfo) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(breakInfo.getBreakLength() - 1));\n+    }\n+\n+    Constraint maximumConsecutiveFreeDaysNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .join(NurseRosterParametrization.class, Joiners.lessThan((contract, employee) -> contract.getMaximumValue(),\n+                        nrp -> nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"maximumConsecutiveFreeDays (no shifts)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contract, employee, nrp) -> contract\n+                                .getViolationAmount(nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1));\n+    }\n+\n+    Constraint consecutiveFreeDaysFirstBreak(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shiftAssignment) -> new BiTuple<>(contract, employee),\n+                        ConstraintCollectors.<MinMaxContractLine, Employee, ShiftAssignment, ShiftAssignment> min(\n+                                (contract, employee, shiftAssignment) -> shiftAssignment))", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDcwNjcwNg==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634706706", "bodyText": "It was necessary for me; IDEA was giving me compiler error without it.", "author": "Christopher-Chianelli", "createdAt": "2021-05-18T19:59:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDcwNTE5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzNDcwNjMxMg==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r634706312", "bodyText": "We generally don't use abbreviations like saand stsr.\nI understand the need to shorten these long names, but assignment and skillRequirement should be OK.", "author": "triceo", "createdAt": "2021-05-18T19:59:17Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.bi.BiConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.BiTuple;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.util.Break;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.common.ExperimentalConstraintCollectors;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.NurseRosterParametrization;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.ShiftDate;\n+import org.optaplanner.examples.nurserostering.domain.ShiftType;\n+import org.optaplanner.examples.nurserostering.domain.ShiftTypeSkillRequirement;\n+import org.optaplanner.examples.nurserostering.domain.SkillProficiency;\n+import org.optaplanner.examples.nurserostering.domain.contract.BooleanContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.PatternContractLine;\n+import org.optaplanner.examples.nurserostering.domain.pattern.FreeBefore2DaysWithAWorkDayPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType2DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType3DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOnRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOnRequest;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentEnd;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentStart;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public <C extends ContractLine> BiConstraintStream<ImmutablePair<Employee, C>, Sequence<ShiftDate>>\n+            getConsecutiveShifts(UniConstraintStream<C> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(ContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Break<ShiftDate, Integer>>\n+            getBreaks(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getBreaks);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Sequence<ShiftDate>>\n+            getConsecutiveWorkingWeekends(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee),\n+                        Joiners.filtering((c, e, s) -> s.isWeekend()))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getWeekendSundayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                oneShiftPerDay(constraintFactory),\n+                minimumAndMaximumNumberOfAssignments(constraintFactory),\n+                minimumNumberOfAssignmentsNoAssignments(constraintFactory),\n+                minimumConsecutiveWorkingDays(constraintFactory),\n+                maximumConsecutiveWorkingDays(constraintFactory),\n+                minimumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDaysNoAssignments(constraintFactory),\n+                consecutiveFreeDaysFirstBreak(constraintFactory),\n+                consecutiveFreeDaysFinalBreak(constraintFactory),\n+                minimumConsecutiveWorkingWeekends(constraintFactory),\n+                maximumConsecutiveWorkingWeekends(constraintFactory),\n+                startOnNotFirstDayOfWeekend(constraintFactory),\n+                endOnNotLastDayOfWeekend(constraintFactory),\n+                identicalShiftTypesDuringWeekend(constraintFactory),\n+                dayOffRequest(constraintFactory),\n+                dayOnRequest(constraintFactory),\n+                shiftOffRequest(constraintFactory),\n+                shiftOnRequest(constraintFactory),\n+                alternativeSkill(constraintFactory),\n+                unwantedPatternFreeBefore2DaysWithAWorkDayPattern(constraintFactory),\n+                unwantedPatternShiftType2DaysPattern(constraintFactory),\n+                unwantedPatternShiftType3DaysPattern(constraintFactory),\n+        };\n+    }\n+\n+    // ############################################################################\n+    // Hard constraints\n+    // ############################################################################\n+\n+    // A nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day.\n+    Constraint oneShiftPerDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory\n+                .fromUniquePair(ShiftAssignment.class,\n+                        Joiners.equal(ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftAssignment::getShiftDate))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"oneShiftPerDay\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    // ############################################################################\n+    // Soft constraints\n+    // ############################################################################\n+    Constraint minimumAndMaximumNumberOfAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((line, employee, shift) -> ImmutablePair.of(employee, line), ConstraintCollectors.countTri())\n+                .filter((employeeContractPair, shiftCount) -> employeeContractPair.getRight().isViolated(shiftCount))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"Minimum and maximum number of assignments\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (employeeContractPair, shiftCount) -> employeeContractPair.getRight().getViolationAmount(shiftCount));\n+    }\n+\n+    Constraint minimumNumberOfAssignmentsNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .filter((contract, employee) -> contract.isViolated(0))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\",\n+                        \"Minimum and maximum number of assignments (no assignments)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee) -> contract.getViolationAmount(0));\n+    }\n+\n+    // Min/Max consecutive working days\n+    // These Min/Max constraints are implemented as two constraints for consistency with DRL\n+    Constraint minimumConsecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isMinimumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() < employeeContractPair.getRight().getMinimumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minimumConsecutiveWorkingDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    Constraint maximumConsecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() > employeeContractPair.getRight().getMaximumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"maximumConsecutiveWorkingDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Min/Max consecutive free days\n+    Constraint minimumConsecutiveFreeDays(ConstraintFactory constraintFactory) {\n+        return getBreaks(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMinimumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        breakInfo) -> breakInfo.getBreakLength() - 1 < employeeContractPair.getRight()\n+                                                .getMinimumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minimumConsecutiveFreeDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, breakInfo) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(breakInfo.getBreakLength() - 1));\n+    }\n+\n+    Constraint maximumConsecutiveFreeDays(ConstraintFactory constraintFactory) {\n+        return getBreaks(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        breakInfo) -> breakInfo.getBreakLength() - 1 > employeeContractPair.getRight()\n+                                                .getMaximumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"maximumConsecutiveFreeDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, breakInfo) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(breakInfo.getBreakLength() - 1));\n+    }\n+\n+    Constraint maximumConsecutiveFreeDaysNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .join(NurseRosterParametrization.class, Joiners.lessThan((contract, employee) -> contract.getMaximumValue(),\n+                        nrp -> nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"maximumConsecutiveFreeDays (no shifts)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contract, employee, nrp) -> contract\n+                                .getViolationAmount(nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1));\n+    }\n+\n+    Constraint consecutiveFreeDaysFirstBreak(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shiftAssignment) -> new BiTuple<>(contract, employee),\n+                        ConstraintCollectors.<MinMaxContractLine, Employee, ShiftAssignment, ShiftAssignment> min(\n+                                (contract, employee, shiftAssignment) -> shiftAssignment))\n+                .join(NurseRosterParametrization.class)\n+                .filter((contractEmployeePair, sa,\n+                        nrp) -> nrp.getFirstShiftDate() != sa.getShiftDate() && contractEmployeePair.a\n+                                .isViolated(sa.getShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex()))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minMaxConsecutiveFreeDays (first break)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contractEmployeePair, sa, nrp) -> contractEmployeePair.a\n+                                .getViolationAmount(sa.getShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex()));\n+    }\n+\n+    Constraint consecutiveFreeDaysFinalBreak(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shiftAssignment) -> new BiTuple<>(contract, employee),\n+                        ConstraintCollectors.<MinMaxContractLine, Employee, ShiftAssignment, ShiftAssignment> max(\n+                                (contract, employee, shiftAssignment) -> shiftAssignment))\n+                .join(NurseRosterParametrization.class)\n+                .filter((contractEmployeePair, sa,\n+                        nrp) -> nrp.getLastShiftDate() != sa.getShiftDate() && contractEmployeePair.a\n+                                .isViolated(nrp.getLastShiftDateDayIndex() - sa.getShiftDateDayIndex()))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minMaxConsecutiveFreeDays (final break)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contractEmployeePair, sa, nrp) -> contractEmployeePair.a\n+                                .getViolationAmount(nrp.getLastShiftDateDayIndex() - sa.getShiftDateDayIndex()));\n+    }\n+\n+    // Min/Max consecutive working weekends\n+    Constraint minimumConsecutiveWorkingWeekends(ConstraintFactory constraintFactory) {\n+        return getConsecutiveWorkingWeekends(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_WEEKENDS &&\n+                        minMaxContractLine.isMinimumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() < employeeContractPair.getRight().getMinimumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minimumConsecutiveWorkingWeekends\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    Constraint maximumConsecutiveWorkingWeekends(ConstraintFactory constraintFactory) {\n+        return getConsecutiveWorkingWeekends(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_WEEKENDS &&\n+                        minMaxContractLine.isMaximumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() > employeeContractPair.getRight().getMaximumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"maximumConsecutiveWorkingWeekends\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Complete Weekends\n+    Constraint startOnNotFirstDayOfWeekend(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(BooleanContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.COMPLETE_WEEKENDS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> new EmployeeConsecutiveAssignmentStart(\n+                                                employeeContractPair.getLeft(), shiftList.getItems().first())\n+                                                        .isWeekendAndNotFirstDayOfWeekend())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"startOnNotFirstDayOfWeekend\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> new EmployeeConsecutiveAssignmentStart(\n+                                                employeeContractPair.getLeft(), shiftList.getItems().first())\n+                                                        .getDistanceToFirstDayOfWeekend()\n+                                                * employeeContractPair.getRight().getWeight());\n+    }\n+\n+    Constraint endOnNotLastDayOfWeekend(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(BooleanContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.COMPLETE_WEEKENDS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> new EmployeeConsecutiveAssignmentEnd(\n+                                                employeeContractPair.getLeft(), shiftList.getItems().last())\n+                                                        .isWeekendAndNotLastDayOfWeekend())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"endOnNotLastDayOfWeekend\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> new EmployeeConsecutiveAssignmentEnd(\n+                                                employeeContractPair.getLeft(), shiftList.getItems().last())\n+                                                        .getDistanceToLastDayOfWeekend()\n+                                                * employeeContractPair.getRight().getWeight());\n+    }\n+\n+    // Identical shiftTypes during a weekend\n+    Constraint identicalShiftTypesDuringWeekend(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BooleanContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.IDENTICAL_SHIFT_TYPES_DURING_WEEKEND &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class, Joiners.equal(ContractLine::getContract, Employee::getContract))\n+                .join(ShiftDate.class, Joiners.filtering((c, e, date) -> date.getDayOfWeek() == DayOfWeek.SUNDAY))\n+                .join(ShiftType.class)\n+                .map(QuadTuple::new)\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal(t -> t.c.getWeekendSundayIndex(), ShiftAssignment::getWeekendSundayIndex),\n+                        Joiners.equal(t -> t.b, ShiftAssignment::getEmployee),\n+                        Joiners.equal(t -> t.d, ShiftAssignment::getShiftType),\n+                        Joiners.filtering((t, shift) -> shift.isWeekend()))\n+                .groupBy((tuple, sa) -> tuple, ConstraintCollectors.countBi())\n+                .filter((tuple, count) -> count < tuple.b.getWeekendLength())\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"identicalShiftTypesDuringWeekend\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (tuple, count) -> (tuple.b.getWeekendLength() - count) * tuple.a.getWeight());\n+    }\n+\n+    // Requested day on/off\n+    Constraint dayOffRequest(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(DayOffRequest.class)\n+                .join(ShiftAssignment.class, Joiners.equal(DayOffRequest::getEmployee, ShiftAssignment::getEmployee),\n+                        Joiners.equal(DayOffRequest::getShiftDate, ShiftAssignment::getShiftDate))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"dayOffRequest\", HardSoftScore.ONE_SOFT,\n+                        (dayOffRequest, shiftAssignment) -> dayOffRequest.getWeight());\n+    }\n+\n+    Constraint dayOnRequest(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(DayOnRequest.class)\n+                .ifNotExists(ShiftAssignment.class, Joiners.equal(DayOnRequest::getEmployee, ShiftAssignment::getEmployee),\n+                        Joiners.equal(DayOnRequest::getShiftDate, ShiftAssignment::getShiftDate))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"dayOnRequest\", HardSoftScore.ONE_SOFT,\n+                        DayOnRequest::getWeight);\n+    }\n+\n+    // Requested shift on/off\n+    Constraint shiftOffRequest(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ShiftOffRequest.class)\n+                .join(ShiftAssignment.class, Joiners.equal(ShiftOffRequest::getEmployee, ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftOffRequest::getShift, ShiftAssignment::getShift))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"shiftOffRequest\", HardSoftScore.ONE_SOFT,\n+                        (shiftOffRequest, shiftAssignment) -> shiftOffRequest.getWeight());\n+    }\n+\n+    Constraint shiftOnRequest(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ShiftOnRequest.class)\n+                .ifNotExists(ShiftAssignment.class, Joiners.equal(ShiftOnRequest::getEmployee, ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftOnRequest::getShift, ShiftAssignment::getShift))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"shiftOnRequest\", HardSoftScore.ONE_SOFT,\n+                        ShiftOnRequest::getWeight);\n+    }\n+\n+    // Alternative skill\n+    Constraint alternativeSkill(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BooleanContractLine.class)\n+                .filter(booleanContractLine -> booleanContractLine.getContractLineType()\n+                        .equals(ContractLineType.ALTERNATIVE_SKILL_CATEGORY))\n+                .join(ShiftAssignment.class, Joiners.equal(BooleanContractLine::getContract, ShiftAssignment::getContract))\n+                .join(ShiftTypeSkillRequirement.class,\n+                        Joiners.equal((contract, sa) -> sa.getShiftType(), ShiftTypeSkillRequirement::getShiftType))\n+                .ifNotExists(SkillProficiency.class,\n+                        Joiners.equal((contract, sa, stsr) -> sa.getEmployee(), SkillProficiency::getEmployee),\n+                        Joiners.equal((contract, sa, stsr) -> stsr.getSkill(), SkillProficiency::getSkill))", "originalCommit": "d305db67381ff73e6e4b3706aeacf90498f74933", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e4fb3d4148bf65cefd50c9dfd98a851aee046dc7", "url": "https://github.com/kiegroup/optaplanner/commit/e4fb3d4148bf65cefd50c9dfd98a851aee046dc7", "message": "Rename type variables", "committedDate": "2021-05-19T17:56:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzODUxODk2NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r638518965", "bodyText": "It would seem that you do not need the join with the MinMaxContractLine.\nThe same could possibly be done with ifExists(...) after from(Employee.class).\nThis has the potential to speed up things quite a bit.", "author": "triceo", "createdAt": "2021-05-25T07:17:45Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.bi.BiConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.BiTuple;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.util.Break;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.common.ExperimentalConstraintCollectors;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.NurseRosterParametrization;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.ShiftDate;\n+import org.optaplanner.examples.nurserostering.domain.ShiftType;\n+import org.optaplanner.examples.nurserostering.domain.ShiftTypeSkillRequirement;\n+import org.optaplanner.examples.nurserostering.domain.SkillProficiency;\n+import org.optaplanner.examples.nurserostering.domain.contract.BooleanContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.PatternContractLine;\n+import org.optaplanner.examples.nurserostering.domain.pattern.FreeBefore2DaysWithAWorkDayPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType2DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType3DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOnRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOnRequest;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentEnd;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentStart;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public <C extends ContractLine> BiConstraintStream<ImmutablePair<Employee, C>, Sequence<ShiftDate>>\n+            getConsecutiveShifts(UniConstraintStream<C> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(ContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Break<ShiftDate, Integer>>\n+            getBreaks(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getBreaks);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Sequence<ShiftDate>>\n+            getConsecutiveWorkingWeekends(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee),\n+                        Joiners.filtering((c, e, s) -> s.isWeekend()))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getWeekendSundayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                oneShiftPerDay(constraintFactory),\n+                minimumAndMaximumNumberOfAssignments(constraintFactory),\n+                minimumNumberOfAssignmentsNoAssignments(constraintFactory),\n+                minimumConsecutiveWorkingDays(constraintFactory),\n+                maximumConsecutiveWorkingDays(constraintFactory),\n+                minimumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDaysNoAssignments(constraintFactory),\n+                consecutiveFreeDaysFirstBreak(constraintFactory),\n+                consecutiveFreeDaysFinalBreak(constraintFactory),\n+                minimumConsecutiveWorkingWeekends(constraintFactory),\n+                maximumConsecutiveWorkingWeekends(constraintFactory),\n+                startOnNotFirstDayOfWeekend(constraintFactory),\n+                endOnNotLastDayOfWeekend(constraintFactory),\n+                identicalShiftTypesDuringWeekend(constraintFactory),\n+                dayOffRequest(constraintFactory),\n+                dayOnRequest(constraintFactory),\n+                shiftOffRequest(constraintFactory),\n+                shiftOnRequest(constraintFactory),\n+                alternativeSkill(constraintFactory),\n+                unwantedPatternFreeBefore2DaysWithAWorkDayPattern(constraintFactory),\n+                unwantedPatternShiftType2DaysPattern(constraintFactory),\n+                unwantedPatternShiftType3DaysPattern(constraintFactory),\n+        };\n+    }\n+\n+    // ############################################################################\n+    // Hard constraints\n+    // ############################################################################\n+\n+    // A nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day.\n+    Constraint oneShiftPerDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory\n+                .fromUniquePair(ShiftAssignment.class,\n+                        Joiners.equal(ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftAssignment::getShiftDate))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"oneShiftPerDay\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    // ############################################################################\n+    // Soft constraints\n+    // ############################################################################\n+    Constraint minimumAndMaximumNumberOfAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))", "originalCommit": "15028c8ead7d133b18735887035b4a3d4e92418c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzODUxOTUxNg==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r638519516", "bodyText": "It is questionable if you even need the Employee join. You can read the employee from the ShiftAssignment directly.\nAnother potential perf improvement.", "author": "triceo", "createdAt": "2021-05-25T07:18:41Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.bi.BiConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.BiTuple;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.util.Break;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.common.ExperimentalConstraintCollectors;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.NurseRosterParametrization;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.ShiftDate;\n+import org.optaplanner.examples.nurserostering.domain.ShiftType;\n+import org.optaplanner.examples.nurserostering.domain.ShiftTypeSkillRequirement;\n+import org.optaplanner.examples.nurserostering.domain.SkillProficiency;\n+import org.optaplanner.examples.nurserostering.domain.contract.BooleanContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.PatternContractLine;\n+import org.optaplanner.examples.nurserostering.domain.pattern.FreeBefore2DaysWithAWorkDayPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType2DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType3DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOnRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOnRequest;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentEnd;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentStart;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public <C extends ContractLine> BiConstraintStream<ImmutablePair<Employee, C>, Sequence<ShiftDate>>\n+            getConsecutiveShifts(UniConstraintStream<C> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(ContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Break<ShiftDate, Integer>>\n+            getBreaks(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getBreaks);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Sequence<ShiftDate>>\n+            getConsecutiveWorkingWeekends(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee),\n+                        Joiners.filtering((c, e, s) -> s.isWeekend()))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getWeekendSundayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                oneShiftPerDay(constraintFactory),\n+                minimumAndMaximumNumberOfAssignments(constraintFactory),\n+                minimumNumberOfAssignmentsNoAssignments(constraintFactory),\n+                minimumConsecutiveWorkingDays(constraintFactory),\n+                maximumConsecutiveWorkingDays(constraintFactory),\n+                minimumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDaysNoAssignments(constraintFactory),\n+                consecutiveFreeDaysFirstBreak(constraintFactory),\n+                consecutiveFreeDaysFinalBreak(constraintFactory),\n+                minimumConsecutiveWorkingWeekends(constraintFactory),\n+                maximumConsecutiveWorkingWeekends(constraintFactory),\n+                startOnNotFirstDayOfWeekend(constraintFactory),\n+                endOnNotLastDayOfWeekend(constraintFactory),\n+                identicalShiftTypesDuringWeekend(constraintFactory),\n+                dayOffRequest(constraintFactory),\n+                dayOnRequest(constraintFactory),\n+                shiftOffRequest(constraintFactory),\n+                shiftOnRequest(constraintFactory),\n+                alternativeSkill(constraintFactory),\n+                unwantedPatternFreeBefore2DaysWithAWorkDayPattern(constraintFactory),\n+                unwantedPatternShiftType2DaysPattern(constraintFactory),\n+                unwantedPatternShiftType3DaysPattern(constraintFactory),\n+        };\n+    }\n+\n+    // ############################################################################\n+    // Hard constraints\n+    // ############################################################################\n+\n+    // A nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day.\n+    Constraint oneShiftPerDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory\n+                .fromUniquePair(ShiftAssignment.class,\n+                        Joiners.equal(ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftAssignment::getShiftDate))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"oneShiftPerDay\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    // ############################################################################\n+    // Soft constraints\n+    // ############################################################################\n+    Constraint minimumAndMaximumNumberOfAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))", "originalCommit": "15028c8ead7d133b18735887035b4a3d4e92418c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzODUyMTc2NA==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r638521764", "bodyText": "The improvements to this constraint are probably also applicable to other constraints in this class.", "author": "triceo", "createdAt": "2021-05-25T07:22:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzODUxOTUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzODUyMDQ0Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r638520442", "bodyText": "Please take care to maintain proper indentation, the filtrers and penalties ought to start at the same column. This is just one instance of multiple of this problem.", "author": "triceo", "createdAt": "2021-05-25T07:20:08Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.bi.BiConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.BiTuple;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.util.Break;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.common.ExperimentalConstraintCollectors;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.NurseRosterParametrization;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.ShiftDate;\n+import org.optaplanner.examples.nurserostering.domain.ShiftType;\n+import org.optaplanner.examples.nurserostering.domain.ShiftTypeSkillRequirement;\n+import org.optaplanner.examples.nurserostering.domain.SkillProficiency;\n+import org.optaplanner.examples.nurserostering.domain.contract.BooleanContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.PatternContractLine;\n+import org.optaplanner.examples.nurserostering.domain.pattern.FreeBefore2DaysWithAWorkDayPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType2DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType3DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOnRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOnRequest;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentEnd;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentStart;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public <C extends ContractLine> BiConstraintStream<ImmutablePair<Employee, C>, Sequence<ShiftDate>>\n+            getConsecutiveShifts(UniConstraintStream<C> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(ContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Break<ShiftDate, Integer>>\n+            getBreaks(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getBreaks);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Sequence<ShiftDate>>\n+            getConsecutiveWorkingWeekends(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee),\n+                        Joiners.filtering((c, e, s) -> s.isWeekend()))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getWeekendSundayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                oneShiftPerDay(constraintFactory),\n+                minimumAndMaximumNumberOfAssignments(constraintFactory),\n+                minimumNumberOfAssignmentsNoAssignments(constraintFactory),\n+                minimumConsecutiveWorkingDays(constraintFactory),\n+                maximumConsecutiveWorkingDays(constraintFactory),\n+                minimumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDaysNoAssignments(constraintFactory),\n+                consecutiveFreeDaysFirstBreak(constraintFactory),\n+                consecutiveFreeDaysFinalBreak(constraintFactory),\n+                minimumConsecutiveWorkingWeekends(constraintFactory),\n+                maximumConsecutiveWorkingWeekends(constraintFactory),\n+                startOnNotFirstDayOfWeekend(constraintFactory),\n+                endOnNotLastDayOfWeekend(constraintFactory),\n+                identicalShiftTypesDuringWeekend(constraintFactory),\n+                dayOffRequest(constraintFactory),\n+                dayOnRequest(constraintFactory),\n+                shiftOffRequest(constraintFactory),\n+                shiftOnRequest(constraintFactory),\n+                alternativeSkill(constraintFactory),\n+                unwantedPatternFreeBefore2DaysWithAWorkDayPattern(constraintFactory),\n+                unwantedPatternShiftType2DaysPattern(constraintFactory),\n+                unwantedPatternShiftType3DaysPattern(constraintFactory),\n+        };\n+    }\n+\n+    // ############################################################################\n+    // Hard constraints\n+    // ############################################################################\n+\n+    // A nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day.\n+    Constraint oneShiftPerDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory\n+                .fromUniquePair(ShiftAssignment.class,\n+                        Joiners.equal(ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftAssignment::getShiftDate))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"oneShiftPerDay\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    // ############################################################################\n+    // Soft constraints\n+    // ############################################################################\n+    Constraint minimumAndMaximumNumberOfAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((line, employee, shift) -> ImmutablePair.of(employee, line), ConstraintCollectors.countTri())\n+                .filter((employeeContractPair, shiftCount) -> employeeContractPair.getRight().isViolated(shiftCount))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"Minimum and maximum number of assignments\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (employeeContractPair, shiftCount) -> employeeContractPair.getRight().getViolationAmount(shiftCount));\n+    }\n+\n+    Constraint minimumNumberOfAssignmentsNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .filter((contract, employee) -> contract.isViolated(0))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\",\n+                        \"Minimum and maximum number of assignments (no assignments)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee) -> contract.getViolationAmount(0));\n+    }\n+\n+    // Min/Max consecutive working days\n+    // These Min/Max constraints are implemented as two constraints for consistency with DRL\n+    Constraint minimumConsecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isMinimumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() < employeeContractPair.getRight().getMinimumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minimumConsecutiveWorkingDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    Constraint maximumConsecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() > employeeContractPair.getRight().getMaximumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"maximumConsecutiveWorkingDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));", "originalCommit": "15028c8ead7d133b18735887035b4a3d4e92418c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzODUyMTI5Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r638521296", "bodyText": "Please remove the use of BiTuple here.", "author": "triceo", "createdAt": "2021-05-25T07:21:22Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.bi.BiConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.BiTuple;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.util.Break;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.common.ExperimentalConstraintCollectors;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.NurseRosterParametrization;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.ShiftDate;\n+import org.optaplanner.examples.nurserostering.domain.ShiftType;\n+import org.optaplanner.examples.nurserostering.domain.ShiftTypeSkillRequirement;\n+import org.optaplanner.examples.nurserostering.domain.SkillProficiency;\n+import org.optaplanner.examples.nurserostering.domain.contract.BooleanContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.PatternContractLine;\n+import org.optaplanner.examples.nurserostering.domain.pattern.FreeBefore2DaysWithAWorkDayPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType2DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType3DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOnRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOnRequest;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentEnd;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentStart;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public <C extends ContractLine> BiConstraintStream<ImmutablePair<Employee, C>, Sequence<ShiftDate>>\n+            getConsecutiveShifts(UniConstraintStream<C> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(ContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Break<ShiftDate, Integer>>\n+            getBreaks(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getBreaks);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Sequence<ShiftDate>>\n+            getConsecutiveWorkingWeekends(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee),\n+                        Joiners.filtering((c, e, s) -> s.isWeekend()))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getWeekendSundayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                oneShiftPerDay(constraintFactory),\n+                minimumAndMaximumNumberOfAssignments(constraintFactory),\n+                minimumNumberOfAssignmentsNoAssignments(constraintFactory),\n+                minimumConsecutiveWorkingDays(constraintFactory),\n+                maximumConsecutiveWorkingDays(constraintFactory),\n+                minimumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDaysNoAssignments(constraintFactory),\n+                consecutiveFreeDaysFirstBreak(constraintFactory),\n+                consecutiveFreeDaysFinalBreak(constraintFactory),\n+                minimumConsecutiveWorkingWeekends(constraintFactory),\n+                maximumConsecutiveWorkingWeekends(constraintFactory),\n+                startOnNotFirstDayOfWeekend(constraintFactory),\n+                endOnNotLastDayOfWeekend(constraintFactory),\n+                identicalShiftTypesDuringWeekend(constraintFactory),\n+                dayOffRequest(constraintFactory),\n+                dayOnRequest(constraintFactory),\n+                shiftOffRequest(constraintFactory),\n+                shiftOnRequest(constraintFactory),\n+                alternativeSkill(constraintFactory),\n+                unwantedPatternFreeBefore2DaysWithAWorkDayPattern(constraintFactory),\n+                unwantedPatternShiftType2DaysPattern(constraintFactory),\n+                unwantedPatternShiftType3DaysPattern(constraintFactory),\n+        };\n+    }\n+\n+    // ############################################################################\n+    // Hard constraints\n+    // ############################################################################\n+\n+    // A nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day.\n+    Constraint oneShiftPerDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory\n+                .fromUniquePair(ShiftAssignment.class,\n+                        Joiners.equal(ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftAssignment::getShiftDate))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"oneShiftPerDay\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    // ############################################################################\n+    // Soft constraints\n+    // ############################################################################\n+    Constraint minimumAndMaximumNumberOfAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((line, employee, shift) -> ImmutablePair.of(employee, line), ConstraintCollectors.countTri())\n+                .filter((employeeContractPair, shiftCount) -> employeeContractPair.getRight().isViolated(shiftCount))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"Minimum and maximum number of assignments\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (employeeContractPair, shiftCount) -> employeeContractPair.getRight().getViolationAmount(shiftCount));\n+    }\n+\n+    Constraint minimumNumberOfAssignmentsNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .filter((contract, employee) -> contract.isViolated(0))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\",\n+                        \"Minimum and maximum number of assignments (no assignments)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee) -> contract.getViolationAmount(0));\n+    }\n+\n+    // Min/Max consecutive working days\n+    // These Min/Max constraints are implemented as two constraints for consistency with DRL\n+    Constraint minimumConsecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isMinimumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() < employeeContractPair.getRight().getMinimumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minimumConsecutiveWorkingDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    Constraint maximumConsecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() > employeeContractPair.getRight().getMaximumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"maximumConsecutiveWorkingDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Min/Max consecutive free days\n+    Constraint minimumConsecutiveFreeDays(ConstraintFactory constraintFactory) {\n+        return getBreaks(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMinimumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        breakInfo) -> breakInfo.getLength() - 1 < employeeContractPair.getRight()\n+                                                .getMinimumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minimumConsecutiveFreeDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, breakInfo) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(breakInfo.getLength() - 1));\n+    }\n+\n+    Constraint maximumConsecutiveFreeDays(ConstraintFactory constraintFactory) {\n+        return getBreaks(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        breakInfo) -> breakInfo.getLength() - 1 > employeeContractPair.getRight()\n+                                                .getMaximumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"maximumConsecutiveFreeDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, breakInfo) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(breakInfo.getLength() - 1));\n+    }\n+\n+    Constraint maximumConsecutiveFreeDaysNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .join(NurseRosterParametrization.class, Joiners.lessThan((contract, employee) -> contract.getMaximumValue(),\n+                        nrp -> nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"maximumConsecutiveFreeDays (no shifts)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contract, employee, nrp) -> contract\n+                                .getViolationAmount(nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1));\n+    }\n+\n+    Constraint consecutiveFreeDaysFirstBreak(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shiftAssignment) -> new BiTuple<>(contract, employee),\n+                        ConstraintCollectors.<MinMaxContractLine, Employee, ShiftAssignment, ShiftAssignment> min(\n+                                (contract, employee, shiftAssignment) -> shiftAssignment))\n+                .join(NurseRosterParametrization.class)\n+                .filter((contractEmployeePair, sa,\n+                        nrp) -> nrp.getFirstShiftDate() != sa.getShiftDate() && contractEmployeePair.a\n+                                .isViolated(sa.getShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex()))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minMaxConsecutiveFreeDays (first break)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contractEmployeePair, sa, nrp) -> contractEmployeePair.a\n+                                .getViolationAmount(sa.getShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex()));\n+    }\n+\n+    Constraint consecutiveFreeDaysFinalBreak(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shiftAssignment) -> new BiTuple<>(contract, employee),", "originalCommit": "15028c8ead7d133b18735887035b4a3d4e92418c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzODUyMzU1MA==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r638523550", "bodyText": "Instead of the many joins and the mapping, wouldn't it be better to just group by employee+shiftType on the shift assignment directly?\nQuad joins will be very expensive on their own, we should try to avoid them as much as possible.", "author": "triceo", "createdAt": "2021-05-25T07:24:50Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.bi.BiConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.BiTuple;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.util.Break;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.common.ExperimentalConstraintCollectors;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.NurseRosterParametrization;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.ShiftDate;\n+import org.optaplanner.examples.nurserostering.domain.ShiftType;\n+import org.optaplanner.examples.nurserostering.domain.ShiftTypeSkillRequirement;\n+import org.optaplanner.examples.nurserostering.domain.SkillProficiency;\n+import org.optaplanner.examples.nurserostering.domain.contract.BooleanContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.PatternContractLine;\n+import org.optaplanner.examples.nurserostering.domain.pattern.FreeBefore2DaysWithAWorkDayPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType2DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType3DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOnRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOnRequest;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentEnd;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentStart;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public <C extends ContractLine> BiConstraintStream<ImmutablePair<Employee, C>, Sequence<ShiftDate>>\n+            getConsecutiveShifts(UniConstraintStream<C> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(ContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Break<ShiftDate, Integer>>\n+            getBreaks(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getBreaks);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Sequence<ShiftDate>>\n+            getConsecutiveWorkingWeekends(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee),\n+                        Joiners.filtering((c, e, s) -> s.isWeekend()))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getWeekendSundayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                oneShiftPerDay(constraintFactory),\n+                minimumAndMaximumNumberOfAssignments(constraintFactory),\n+                minimumNumberOfAssignmentsNoAssignments(constraintFactory),\n+                minimumConsecutiveWorkingDays(constraintFactory),\n+                maximumConsecutiveWorkingDays(constraintFactory),\n+                minimumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDaysNoAssignments(constraintFactory),\n+                consecutiveFreeDaysFirstBreak(constraintFactory),\n+                consecutiveFreeDaysFinalBreak(constraintFactory),\n+                minimumConsecutiveWorkingWeekends(constraintFactory),\n+                maximumConsecutiveWorkingWeekends(constraintFactory),\n+                startOnNotFirstDayOfWeekend(constraintFactory),\n+                endOnNotLastDayOfWeekend(constraintFactory),\n+                identicalShiftTypesDuringWeekend(constraintFactory),\n+                dayOffRequest(constraintFactory),\n+                dayOnRequest(constraintFactory),\n+                shiftOffRequest(constraintFactory),\n+                shiftOnRequest(constraintFactory),\n+                alternativeSkill(constraintFactory),\n+                unwantedPatternFreeBefore2DaysWithAWorkDayPattern(constraintFactory),\n+                unwantedPatternShiftType2DaysPattern(constraintFactory),\n+                unwantedPatternShiftType3DaysPattern(constraintFactory),\n+        };\n+    }\n+\n+    // ############################################################################\n+    // Hard constraints\n+    // ############################################################################\n+\n+    // A nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day.\n+    Constraint oneShiftPerDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory\n+                .fromUniquePair(ShiftAssignment.class,\n+                        Joiners.equal(ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftAssignment::getShiftDate))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"oneShiftPerDay\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    // ############################################################################\n+    // Soft constraints\n+    // ############################################################################\n+    Constraint minimumAndMaximumNumberOfAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((line, employee, shift) -> ImmutablePair.of(employee, line), ConstraintCollectors.countTri())\n+                .filter((employeeContractPair, shiftCount) -> employeeContractPair.getRight().isViolated(shiftCount))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"Minimum and maximum number of assignments\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (employeeContractPair, shiftCount) -> employeeContractPair.getRight().getViolationAmount(shiftCount));\n+    }\n+\n+    Constraint minimumNumberOfAssignmentsNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .filter((contract, employee) -> contract.isViolated(0))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\",\n+                        \"Minimum and maximum number of assignments (no assignments)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee) -> contract.getViolationAmount(0));\n+    }\n+\n+    // Min/Max consecutive working days\n+    // These Min/Max constraints are implemented as two constraints for consistency with DRL\n+    Constraint minimumConsecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isMinimumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() < employeeContractPair.getRight().getMinimumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minimumConsecutiveWorkingDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    Constraint maximumConsecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() > employeeContractPair.getRight().getMaximumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"maximumConsecutiveWorkingDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Min/Max consecutive free days\n+    Constraint minimumConsecutiveFreeDays(ConstraintFactory constraintFactory) {\n+        return getBreaks(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMinimumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        breakInfo) -> breakInfo.getLength() - 1 < employeeContractPair.getRight()\n+                                                .getMinimumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minimumConsecutiveFreeDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, breakInfo) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(breakInfo.getLength() - 1));\n+    }\n+\n+    Constraint maximumConsecutiveFreeDays(ConstraintFactory constraintFactory) {\n+        return getBreaks(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        breakInfo) -> breakInfo.getLength() - 1 > employeeContractPair.getRight()\n+                                                .getMaximumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"maximumConsecutiveFreeDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, breakInfo) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(breakInfo.getLength() - 1));\n+    }\n+\n+    Constraint maximumConsecutiveFreeDaysNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .join(NurseRosterParametrization.class, Joiners.lessThan((contract, employee) -> contract.getMaximumValue(),\n+                        nrp -> nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"maximumConsecutiveFreeDays (no shifts)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contract, employee, nrp) -> contract\n+                                .getViolationAmount(nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1));\n+    }\n+\n+    Constraint consecutiveFreeDaysFirstBreak(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shiftAssignment) -> new BiTuple<>(contract, employee),\n+                        ConstraintCollectors.<MinMaxContractLine, Employee, ShiftAssignment, ShiftAssignment> min(\n+                                (contract, employee, shiftAssignment) -> shiftAssignment))\n+                .join(NurseRosterParametrization.class)\n+                .filter((contractEmployeePair, sa,\n+                        nrp) -> nrp.getFirstShiftDate() != sa.getShiftDate() && contractEmployeePair.a\n+                                .isViolated(sa.getShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex()))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minMaxConsecutiveFreeDays (first break)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contractEmployeePair, sa, nrp) -> contractEmployeePair.a\n+                                .getViolationAmount(sa.getShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex()));\n+    }\n+\n+    Constraint consecutiveFreeDaysFinalBreak(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shiftAssignment) -> new BiTuple<>(contract, employee),\n+                        ConstraintCollectors.<MinMaxContractLine, Employee, ShiftAssignment, ShiftAssignment> max(\n+                                (contract, employee, shiftAssignment) -> shiftAssignment))\n+                .join(NurseRosterParametrization.class)\n+                .filter((contractEmployeePair, sa,\n+                        nrp) -> nrp.getLastShiftDate() != sa.getShiftDate() && contractEmployeePair.a\n+                                .isViolated(nrp.getLastShiftDateDayIndex() - sa.getShiftDateDayIndex()))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minMaxConsecutiveFreeDays (final break)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contractEmployeePair, sa, nrp) -> contractEmployeePair.a\n+                                .getViolationAmount(nrp.getLastShiftDateDayIndex() - sa.getShiftDateDayIndex()));\n+    }\n+\n+    // Min/Max consecutive working weekends\n+    Constraint minimumConsecutiveWorkingWeekends(ConstraintFactory constraintFactory) {\n+        return getConsecutiveWorkingWeekends(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_WEEKENDS &&\n+                        minMaxContractLine.isMinimumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() < employeeContractPair.getRight().getMinimumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minimumConsecutiveWorkingWeekends\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    Constraint maximumConsecutiveWorkingWeekends(ConstraintFactory constraintFactory) {\n+        return getConsecutiveWorkingWeekends(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_WEEKENDS &&\n+                        minMaxContractLine.isMaximumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() > employeeContractPair.getRight().getMaximumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"maximumConsecutiveWorkingWeekends\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Complete Weekends\n+    Constraint startOnNotFirstDayOfWeekend(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(BooleanContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.COMPLETE_WEEKENDS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> new EmployeeConsecutiveAssignmentStart(\n+                                                employeeContractPair.getLeft(), shiftList.getItems().first())\n+                                                        .isWeekendAndNotFirstDayOfWeekend())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"startOnNotFirstDayOfWeekend\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> new EmployeeConsecutiveAssignmentStart(\n+                                                employeeContractPair.getLeft(), shiftList.getItems().first())\n+                                                        .getDistanceToFirstDayOfWeekend()\n+                                                * employeeContractPair.getRight().getWeight());\n+    }\n+\n+    Constraint endOnNotLastDayOfWeekend(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(BooleanContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.COMPLETE_WEEKENDS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> new EmployeeConsecutiveAssignmentEnd(\n+                                                employeeContractPair.getLeft(), shiftList.getItems().last())\n+                                                        .isWeekendAndNotLastDayOfWeekend())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"endOnNotLastDayOfWeekend\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> new EmployeeConsecutiveAssignmentEnd(\n+                                                employeeContractPair.getLeft(), shiftList.getItems().last())\n+                                                        .getDistanceToLastDayOfWeekend()\n+                                                * employeeContractPair.getRight().getWeight());\n+    }\n+\n+    // Identical shiftTypes during a weekend\n+    Constraint identicalShiftTypesDuringWeekend(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BooleanContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.IDENTICAL_SHIFT_TYPES_DURING_WEEKEND &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class, Joiners.equal(ContractLine::getContract, Employee::getContract))\n+                .join(ShiftDate.class, Joiners.filtering((c, e, date) -> date.getDayOfWeek() == DayOfWeek.SUNDAY))\n+                .join(ShiftType.class)\n+                .map(QuadTuple::new)\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal(t -> t.c.getWeekendSundayIndex(), ShiftAssignment::getWeekendSundayIndex),\n+                        Joiners.equal(t -> t.b, ShiftAssignment::getEmployee),\n+                        Joiners.equal(t -> t.d, ShiftAssignment::getShiftType),\n+                        Joiners.filtering((t, shift) -> shift.isWeekend()))", "originalCommit": "15028c8ead7d133b18735887035b4a3d4e92418c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzODUyNDI1MA==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r638524250", "bodyText": "Considering that the filter is only applied to ShiftDate and nothing else, this will perform better as a nested filtered stream. (See my latest blog.)", "author": "triceo", "createdAt": "2021-05-25T07:25:57Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,480 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.bi.BiConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.BiTuple;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.util.Break;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.common.ExperimentalConstraintCollectors;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.NurseRosterParametrization;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.ShiftDate;\n+import org.optaplanner.examples.nurserostering.domain.ShiftType;\n+import org.optaplanner.examples.nurserostering.domain.ShiftTypeSkillRequirement;\n+import org.optaplanner.examples.nurserostering.domain.SkillProficiency;\n+import org.optaplanner.examples.nurserostering.domain.contract.BooleanContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.PatternContractLine;\n+import org.optaplanner.examples.nurserostering.domain.pattern.FreeBefore2DaysWithAWorkDayPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType2DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType3DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOnRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOnRequest;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentEnd;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentStart;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public <C extends ContractLine> BiConstraintStream<ImmutablePair<Employee, C>, Sequence<ShiftDate>>\n+            getConsecutiveShifts(UniConstraintStream<C> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(ContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Break<ShiftDate, Integer>>\n+            getBreaks(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getBreaks);\n+    }\n+\n+    public BiConstraintStream<ImmutablePair<Employee, MinMaxContractLine>, Sequence<ShiftDate>>\n+            getConsecutiveWorkingWeekends(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class, Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee),\n+                        Joiners.filtering((c, e, s) -> s.isWeekend()))\n+                .groupBy((contract, employee, shift) -> ImmutablePair.of(employee, contract),\n+                        ExperimentalConstraintCollectors.consecutive((contract, employee, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getWeekendSundayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                oneShiftPerDay(constraintFactory),\n+                minimumAndMaximumNumberOfAssignments(constraintFactory),\n+                minimumNumberOfAssignmentsNoAssignments(constraintFactory),\n+                minimumConsecutiveWorkingDays(constraintFactory),\n+                maximumConsecutiveWorkingDays(constraintFactory),\n+                minimumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDaysNoAssignments(constraintFactory),\n+                consecutiveFreeDaysFirstBreak(constraintFactory),\n+                consecutiveFreeDaysFinalBreak(constraintFactory),\n+                minimumConsecutiveWorkingWeekends(constraintFactory),\n+                maximumConsecutiveWorkingWeekends(constraintFactory),\n+                startOnNotFirstDayOfWeekend(constraintFactory),\n+                endOnNotLastDayOfWeekend(constraintFactory),\n+                identicalShiftTypesDuringWeekend(constraintFactory),\n+                dayOffRequest(constraintFactory),\n+                dayOnRequest(constraintFactory),\n+                shiftOffRequest(constraintFactory),\n+                shiftOnRequest(constraintFactory),\n+                alternativeSkill(constraintFactory),\n+                unwantedPatternFreeBefore2DaysWithAWorkDayPattern(constraintFactory),\n+                unwantedPatternShiftType2DaysPattern(constraintFactory),\n+                unwantedPatternShiftType3DaysPattern(constraintFactory),\n+        };\n+    }\n+\n+    // ############################################################################\n+    // Hard constraints\n+    // ############################################################################\n+\n+    // A nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day.\n+    Constraint oneShiftPerDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory\n+                .fromUniquePair(ShiftAssignment.class,\n+                        Joiners.equal(ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftAssignment::getShiftDate))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"oneShiftPerDay\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    // ############################################################################\n+    // Soft constraints\n+    // ############################################################################\n+    Constraint minimumAndMaximumNumberOfAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((line, employee, shift) -> ImmutablePair.of(employee, line), ConstraintCollectors.countTri())\n+                .filter((employeeContractPair, shiftCount) -> employeeContractPair.getRight().isViolated(shiftCount))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"Minimum and maximum number of assignments\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (employeeContractPair, shiftCount) -> employeeContractPair.getRight().getViolationAmount(shiftCount));\n+    }\n+\n+    Constraint minimumNumberOfAssignmentsNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .filter((contract, employee) -> contract.isViolated(0))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\",\n+                        \"Minimum and maximum number of assignments (no assignments)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee) -> contract.getViolationAmount(0));\n+    }\n+\n+    // Min/Max consecutive working days\n+    // These Min/Max constraints are implemented as two constraints for consistency with DRL\n+    Constraint minimumConsecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isMinimumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() < employeeContractPair.getRight().getMinimumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minimumConsecutiveWorkingDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    Constraint maximumConsecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() > employeeContractPair.getRight().getMaximumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"maximumConsecutiveWorkingDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Min/Max consecutive free days\n+    Constraint minimumConsecutiveFreeDays(ConstraintFactory constraintFactory) {\n+        return getBreaks(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMinimumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        breakInfo) -> breakInfo.getLength() - 1 < employeeContractPair.getRight()\n+                                                .getMinimumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minimumConsecutiveFreeDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, breakInfo) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(breakInfo.getLength() - 1));\n+    }\n+\n+    Constraint maximumConsecutiveFreeDays(ConstraintFactory constraintFactory) {\n+        return getBreaks(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        breakInfo) -> breakInfo.getLength() - 1 > employeeContractPair.getRight()\n+                                                .getMaximumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"maximumConsecutiveFreeDays\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, breakInfo) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(breakInfo.getLength() - 1));\n+    }\n+\n+    Constraint maximumConsecutiveFreeDaysNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .join(NurseRosterParametrization.class, Joiners.lessThan((contract, employee) -> contract.getMaximumValue(),\n+                        nrp -> nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"maximumConsecutiveFreeDays (no shifts)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contract, employee, nrp) -> contract\n+                                .getViolationAmount(nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1));\n+    }\n+\n+    Constraint consecutiveFreeDaysFirstBreak(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shiftAssignment) -> new BiTuple<>(contract, employee),\n+                        ConstraintCollectors.<MinMaxContractLine, Employee, ShiftAssignment, ShiftAssignment> min(\n+                                (contract, employee, shiftAssignment) -> shiftAssignment))\n+                .join(NurseRosterParametrization.class)\n+                .filter((contractEmployeePair, sa,\n+                        nrp) -> nrp.getFirstShiftDate() != sa.getShiftDate() && contractEmployeePair.a\n+                                .isViolated(sa.getShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex()))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minMaxConsecutiveFreeDays (first break)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contractEmployeePair, sa, nrp) -> contractEmployeePair.a\n+                                .getViolationAmount(sa.getShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex()));\n+    }\n+\n+    Constraint consecutiveFreeDaysFinalBreak(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .groupBy((contract, employee, shiftAssignment) -> new BiTuple<>(contract, employee),\n+                        ConstraintCollectors.<MinMaxContractLine, Employee, ShiftAssignment, ShiftAssignment> max(\n+                                (contract, employee, shiftAssignment) -> shiftAssignment))\n+                .join(NurseRosterParametrization.class)\n+                .filter((contractEmployeePair, sa,\n+                        nrp) -> nrp.getLastShiftDate() != sa.getShiftDate() && contractEmployeePair.a\n+                                .isViolated(nrp.getLastShiftDateDayIndex() - sa.getShiftDateDayIndex()))\n+                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minMaxConsecutiveFreeDays (final break)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contractEmployeePair, sa, nrp) -> contractEmployeePair.a\n+                                .getViolationAmount(nrp.getLastShiftDateDayIndex() - sa.getShiftDateDayIndex()));\n+    }\n+\n+    // Min/Max consecutive working weekends\n+    Constraint minimumConsecutiveWorkingWeekends(ConstraintFactory constraintFactory) {\n+        return getConsecutiveWorkingWeekends(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_WEEKENDS &&\n+                        minMaxContractLine.isMinimumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() < employeeContractPair.getRight().getMinimumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"minimumConsecutiveWorkingWeekends\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    Constraint maximumConsecutiveWorkingWeekends(ConstraintFactory constraintFactory) {\n+        return getConsecutiveWorkingWeekends(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_WEEKENDS &&\n+                        minMaxContractLine.isMaximumEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> shiftList.getLength() > employeeContractPair.getRight().getMaximumValue())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"maximumConsecutiveWorkingWeekends\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> employeeContractPair.getRight()\n+                                                .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Complete Weekends\n+    Constraint startOnNotFirstDayOfWeekend(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(BooleanContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.COMPLETE_WEEKENDS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> new EmployeeConsecutiveAssignmentStart(\n+                                                employeeContractPair.getLeft(), shiftList.getItems().first())\n+                                                        .isWeekendAndNotFirstDayOfWeekend())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"startOnNotFirstDayOfWeekend\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> new EmployeeConsecutiveAssignmentStart(\n+                                                employeeContractPair.getLeft(), shiftList.getItems().first())\n+                                                        .getDistanceToFirstDayOfWeekend()\n+                                                * employeeContractPair.getRight().getWeight());\n+    }\n+\n+    Constraint endOnNotLastDayOfWeekend(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(BooleanContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.COMPLETE_WEEKENDS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employeeContractPair,\n+                                        shiftList) -> new EmployeeConsecutiveAssignmentEnd(\n+                                                employeeContractPair.getLeft(), shiftList.getItems().last())\n+                                                        .isWeekendAndNotLastDayOfWeekend())\n+                                .penalize(\"org.optaplanner.examples.nurserostering.solver\", \"endOnNotLastDayOfWeekend\",\n+                                        HardSoftScore.ONE_SOFT,\n+                                        (employeeContractPair, shiftList) -> new EmployeeConsecutiveAssignmentEnd(\n+                                                employeeContractPair.getLeft(), shiftList.getItems().last())\n+                                                        .getDistanceToLastDayOfWeekend()\n+                                                * employeeContractPair.getRight().getWeight());\n+    }\n+\n+    // Identical shiftTypes during a weekend\n+    Constraint identicalShiftTypesDuringWeekend(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BooleanContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.IDENTICAL_SHIFT_TYPES_DURING_WEEKEND &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class, Joiners.equal(ContractLine::getContract, Employee::getContract))\n+                .join(ShiftDate.class, Joiners.filtering((c, e, date) -> date.getDayOfWeek() == DayOfWeek.SUNDAY))", "originalCommit": "15028c8ead7d133b18735887035b4a3d4e92418c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTEzMTA3Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r639131076", "bodyText": "This definitely is not a public type and should not be used in user-facing code.", "author": "triceo", "createdAt": "2021-05-25T19:40:20Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.tri.TriConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;", "originalCommit": "57394f70d678c2cdc90f852b229de6749866c003", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTEzMTk0Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r639131946", "bodyText": "This is probably the only use case where using a single-key overload would have been acceptable. :-)", "author": "triceo", "createdAt": "2021-05-25T19:41:43Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.tri.TriConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.util.Break;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.common.ExperimentalConstraintCollectors;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.NurseRosterParametrization;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.ShiftDate;\n+import org.optaplanner.examples.nurserostering.domain.ShiftTypeSkillRequirement;\n+import org.optaplanner.examples.nurserostering.domain.SkillProficiency;\n+import org.optaplanner.examples.nurserostering.domain.contract.BooleanContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.PatternContractLine;\n+import org.optaplanner.examples.nurserostering.domain.pattern.FreeBefore2DaysWithAWorkDayPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType2DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType3DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOnRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOnRequest;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentEnd;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentStart;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public <C extends ContractLine> TriConstraintStream<Employee, C, Sequence<ShiftDate>>\n+            getConsecutiveShifts(UniConstraintStream<C> constraintStream) {\n+        return constraintStream\n+                .join(ShiftAssignment.class, Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shift) -> shift.getEmployee(), (contract, shift) -> contract,\n+                        ExperimentalConstraintCollectors.consecutive((contract, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    public TriConstraintStream<Employee, MinMaxContractLine, Break<ShiftDate, Integer>>\n+            getBreaks(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream\n+                .join(ShiftAssignment.class, Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shift) -> shift.getEmployee(), (contract, shift) -> contract,\n+                        ExperimentalConstraintCollectors.consecutive((contract, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getBreaks);\n+    }\n+\n+    public TriConstraintStream<Employee, MinMaxContractLine, Sequence<ShiftDate>>\n+            getConsecutiveWorkingWeekends(ConstraintFactory constraintFactory,\n+                    UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(constraintFactory.from(ShiftAssignment.class).filter(ShiftAssignment::isWeekend),\n+                Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shift) -> shift.getEmployee(), (contract, shift) -> contract,\n+                        ExperimentalConstraintCollectors.consecutive((contract, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getWeekendSundayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                oneShiftPerDay(constraintFactory),\n+                minimumAndMaximumNumberOfAssignments(constraintFactory),\n+                minimumNumberOfAssignmentsNoAssignments(constraintFactory),\n+                consecutiveWorkingDays(constraintFactory),\n+                consecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDaysNoAssignments(constraintFactory),\n+                consecutiveFreeDaysFirstBreak(constraintFactory),\n+                consecutiveFreeDaysFinalBreak(constraintFactory),\n+                consecutiveWorkingWeekends(constraintFactory),\n+                startOnNotFirstDayOfWeekend(constraintFactory),\n+                endOnNotLastDayOfWeekend(constraintFactory),\n+                identicalShiftTypesDuringWeekend(constraintFactory),\n+                dayOffRequest(constraintFactory),\n+                dayOnRequest(constraintFactory),\n+                shiftOffRequest(constraintFactory),\n+                shiftOnRequest(constraintFactory),\n+                alternativeSkill(constraintFactory),\n+                unwantedPatternFreeBefore2DaysWithAWorkDayPattern(constraintFactory),\n+                unwantedPatternShiftType2DaysPattern(constraintFactory),\n+                unwantedPatternShiftType3DaysPattern(constraintFactory),\n+        };\n+    }\n+\n+    // ############################################################################\n+    // Hard constraints\n+    // ############################################################################\n+\n+    // A nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day.\n+    Constraint oneShiftPerDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory\n+                .fromUniquePair(ShiftAssignment.class,\n+                        Joiners.equal(ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftAssignment::getShiftDate))\n+                .penalize(\"oneShiftPerDay\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    // ############################################################################\n+    // Soft constraints\n+    // ############################################################################\n+    Constraint minimumAndMaximumNumberOfAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(ShiftAssignment.class, Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((line, shift) -> shift.getEmployee(), (line, shift) -> line, ConstraintCollectors.countBi())\n+                .filter((employee, contract, shiftCount) -> employee != null && contract.isViolated(shiftCount))\n+                .penalize(\"Minimum and maximum number of assignments\", HardSoftScore.ONE_SOFT,\n+                        (employee, contract, shiftCount) -> contract.getViolationAmount(shiftCount));\n+    }\n+\n+    Constraint minimumNumberOfAssignmentsNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .filter((contract, employee) -> contract.isViolated(0))\n+                .penalize(\"Minimum and maximum number of assignments (no assignments)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee) -> contract.getViolationAmount(0));\n+    }\n+\n+    // Min/Max consecutive working days\n+    // These Min/Max constraints are implemented as two constraints for consistency with DRL\n+    Constraint consecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract, shiftList) -> contract.isViolated(shiftList.getLength()))\n+                                .penalize(\"consecutiveWorkingDays\", HardSoftScore.ONE_SOFT,\n+                                        (employee, contract, shiftList) -> contract.getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Min/Max consecutive free days\n+    Constraint consecutiveFreeDays(ConstraintFactory constraintFactory) {\n+        return getBreaks(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract, breakInfo) -> contract.isViolated(breakInfo.getLength() - 1))\n+                                .penalize(\"consecutiveFreeDays\", HardSoftScore.ONE_SOFT,\n+                                        (employee, contract, breakInfo) -> contract\n+                                                .getViolationAmount(breakInfo.getLength() - 1));\n+    }\n+\n+    Constraint maximumConsecutiveFreeDaysNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .join(NurseRosterParametrization.class, Joiners.lessThan((contract, employee) -> contract.getMaximumValue(),\n+                        nrp -> nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1))\n+                .penalize(\"maximumConsecutiveFreeDays (no shifts)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee, nrp) -> contract\n+                                .getViolationAmount(nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1));\n+    }\n+\n+    Constraint consecutiveFreeDaysFirstBreak(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shiftAssignment) -> contract,\n+                        (contract, shiftAssignment) -> shiftAssignment.getEmployee(),\n+                        ConstraintCollectors.<MinMaxContractLine, ShiftAssignment, ShiftAssignment> min(\n+                                (contract, shiftAssignment) -> shiftAssignment))\n+                .join(NurseRosterParametrization.class)\n+                .filter((contract, employee, shiftAssignment,\n+                        nrp) -> nrp.getFirstShiftDate() != shiftAssignment.getShiftDate() && contract\n+                                .isViolated(shiftAssignment.getShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex()))\n+                .penalize(\"consecutiveFreeDays (first break)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contractLine, employee, shiftAssignment, nrp) -> contractLine\n+                                .getViolationAmount(shiftAssignment.getShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex()));\n+    }\n+\n+    Constraint consecutiveFreeDaysFinalBreak(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shiftAssignment) -> contract,\n+                        (contract, shiftAssignment) -> shiftAssignment.getEmployee(),\n+                        ConstraintCollectors.<MinMaxContractLine, ShiftAssignment, ShiftAssignment> max(\n+                                (contract, shiftAssignment) -> shiftAssignment))\n+                .join(NurseRosterParametrization.class)\n+                .filter((contractLine, employee, shiftAssignment,\n+                        nrp) -> nrp.getLastShiftDate() != shiftAssignment.getShiftDate() &&\n+                                contractLine\n+                                        .isViolated(nrp.getLastShiftDateDayIndex() - shiftAssignment.getShiftDateDayIndex()))\n+                .penalize(\"consecutiveFreeDays (final break)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contractLine, employee, shiftAssignment, nrp) -> contractLine\n+                                .getViolationAmount(nrp.getLastShiftDateDayIndex() - shiftAssignment.getShiftDateDayIndex()));\n+    }\n+\n+    // Min/Max consecutive working weekends\n+    Constraint consecutiveWorkingWeekends(ConstraintFactory constraintFactory) {\n+        return getConsecutiveWorkingWeekends(constraintFactory,\n+                constraintFactory.from(MinMaxContractLine.class)\n+                        .filter(minMaxContractLine -> minMaxContractLine\n+                                .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_WEEKENDS &&\n+                                minMaxContractLine.isEnabled()))\n+                                        .filter((employee, contract, shiftList) -> contract.isViolated(shiftList.getLength()))\n+                                        .penalize(\"consecutiveWorkingWeekends\", HardSoftScore.ONE_SOFT,\n+                                                (employee, contract, shiftList) -> contract\n+                                                        .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Complete Weekends\n+    Constraint startOnNotFirstDayOfWeekend(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(BooleanContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.COMPLETE_WEEKENDS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract, shiftList) -> new EmployeeConsecutiveAssignmentStart(\n+                                        employee, shiftList.getItems().first())\n+                                                .isWeekendAndNotFirstDayOfWeekend())\n+                                .penalize(\"startOnNotFirstDayOfWeekend\", HardSoftScore.ONE_SOFT,\n+                                        (employee, contract, shiftList) -> new EmployeeConsecutiveAssignmentStart(employee,\n+                                                shiftList.getItems().first()).getDistanceToFirstDayOfWeekend()\n+                                                * contract.getWeight());\n+    }\n+\n+    Constraint endOnNotLastDayOfWeekend(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(BooleanContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.COMPLETE_WEEKENDS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract,\n+                                        shiftList) -> new EmployeeConsecutiveAssignmentEnd(employee,\n+                                                shiftList.getItems().last())\n+                                                        .isWeekendAndNotLastDayOfWeekend())\n+                                .penalize(\"endOnNotLastDayOfWeekend\", HardSoftScore.ONE_SOFT,\n+                                        (employee, contract, shiftList) -> new EmployeeConsecutiveAssignmentEnd(employee,\n+                                                shiftList.getItems().last()).getDistanceToLastDayOfWeekend()\n+                                                * contract.getWeight());\n+    }\n+\n+    // Identical shiftTypes during a weekend\n+    Constraint identicalShiftTypesDuringWeekend(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BooleanContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.IDENTICAL_SHIFT_TYPES_DURING_WEEKEND &&\n+                        minMaxContractLine.isEnabled())\n+                .join(constraintFactory.from(ShiftDate.class)\n+                        .filter(date -> date.getDayOfWeek() == DayOfWeek.SUNDAY))\n+                .join(constraintFactory.from(ShiftAssignment.class).filter(ShiftAssignment::isWeekend),\n+                        Joiners.equal((contract, date) -> date.getWeekendSundayIndex(), ShiftAssignment::getWeekendSundayIndex),\n+                        Joiners.equal((contract, date) -> contract.getContract(), ShiftAssignment::getContract))\n+                .groupBy((contract, date, sa) -> contract,\n+                        (contract, date, sa) -> sa.getEmployee(),\n+                        (contract, date, sa) -> ImmutablePair.of(sa.getShiftType(), date), // No 4-key groupBy overload\n+                        ConstraintCollectors.countTri())", "originalCommit": "57394f70d678c2cdc90f852b229de6749866c003", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTEzMzc1Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r639133756", "bodyText": "The PatternContractLine apparenty includes the ShiftType3DaysPattern, therefore we can start from it directly, avoiding the join, and therefore avoiding the map() later.", "author": "triceo", "createdAt": "2021-05-25T19:44:57Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.tri.TriConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.util.Break;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.common.ExperimentalConstraintCollectors;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.NurseRosterParametrization;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.ShiftDate;\n+import org.optaplanner.examples.nurserostering.domain.ShiftTypeSkillRequirement;\n+import org.optaplanner.examples.nurserostering.domain.SkillProficiency;\n+import org.optaplanner.examples.nurserostering.domain.contract.BooleanContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.PatternContractLine;\n+import org.optaplanner.examples.nurserostering.domain.pattern.FreeBefore2DaysWithAWorkDayPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType2DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType3DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOnRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOnRequest;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentEnd;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentStart;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public <C extends ContractLine> TriConstraintStream<Employee, C, Sequence<ShiftDate>>\n+            getConsecutiveShifts(UniConstraintStream<C> constraintStream) {\n+        return constraintStream\n+                .join(ShiftAssignment.class, Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shift) -> shift.getEmployee(), (contract, shift) -> contract,\n+                        ExperimentalConstraintCollectors.consecutive((contract, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    public TriConstraintStream<Employee, MinMaxContractLine, Break<ShiftDate, Integer>>\n+            getBreaks(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream\n+                .join(ShiftAssignment.class, Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shift) -> shift.getEmployee(), (contract, shift) -> contract,\n+                        ExperimentalConstraintCollectors.consecutive((contract, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getBreaks);\n+    }\n+\n+    public TriConstraintStream<Employee, MinMaxContractLine, Sequence<ShiftDate>>\n+            getConsecutiveWorkingWeekends(ConstraintFactory constraintFactory,\n+                    UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(constraintFactory.from(ShiftAssignment.class).filter(ShiftAssignment::isWeekend),\n+                Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shift) -> shift.getEmployee(), (contract, shift) -> contract,\n+                        ExperimentalConstraintCollectors.consecutive((contract, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getWeekendSundayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                oneShiftPerDay(constraintFactory),\n+                minimumAndMaximumNumberOfAssignments(constraintFactory),\n+                minimumNumberOfAssignmentsNoAssignments(constraintFactory),\n+                consecutiveWorkingDays(constraintFactory),\n+                consecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDaysNoAssignments(constraintFactory),\n+                consecutiveFreeDaysFirstBreak(constraintFactory),\n+                consecutiveFreeDaysFinalBreak(constraintFactory),\n+                consecutiveWorkingWeekends(constraintFactory),\n+                startOnNotFirstDayOfWeekend(constraintFactory),\n+                endOnNotLastDayOfWeekend(constraintFactory),\n+                identicalShiftTypesDuringWeekend(constraintFactory),\n+                dayOffRequest(constraintFactory),\n+                dayOnRequest(constraintFactory),\n+                shiftOffRequest(constraintFactory),\n+                shiftOnRequest(constraintFactory),\n+                alternativeSkill(constraintFactory),\n+                unwantedPatternFreeBefore2DaysWithAWorkDayPattern(constraintFactory),\n+                unwantedPatternShiftType2DaysPattern(constraintFactory),\n+                unwantedPatternShiftType3DaysPattern(constraintFactory),\n+        };\n+    }\n+\n+    // ############################################################################\n+    // Hard constraints\n+    // ############################################################################\n+\n+    // A nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day.\n+    Constraint oneShiftPerDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory\n+                .fromUniquePair(ShiftAssignment.class,\n+                        Joiners.equal(ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftAssignment::getShiftDate))\n+                .penalize(\"oneShiftPerDay\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    // ############################################################################\n+    // Soft constraints\n+    // ############################################################################\n+    Constraint minimumAndMaximumNumberOfAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(ShiftAssignment.class, Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((line, shift) -> shift.getEmployee(), (line, shift) -> line, ConstraintCollectors.countBi())\n+                .filter((employee, contract, shiftCount) -> employee != null && contract.isViolated(shiftCount))\n+                .penalize(\"Minimum and maximum number of assignments\", HardSoftScore.ONE_SOFT,\n+                        (employee, contract, shiftCount) -> contract.getViolationAmount(shiftCount));\n+    }\n+\n+    Constraint minimumNumberOfAssignmentsNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .filter((contract, employee) -> contract.isViolated(0))\n+                .penalize(\"Minimum and maximum number of assignments (no assignments)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee) -> contract.getViolationAmount(0));\n+    }\n+\n+    // Min/Max consecutive working days\n+    // These Min/Max constraints are implemented as two constraints for consistency with DRL\n+    Constraint consecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract, shiftList) -> contract.isViolated(shiftList.getLength()))\n+                                .penalize(\"consecutiveWorkingDays\", HardSoftScore.ONE_SOFT,\n+                                        (employee, contract, shiftList) -> contract.getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Min/Max consecutive free days\n+    Constraint consecutiveFreeDays(ConstraintFactory constraintFactory) {\n+        return getBreaks(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract, breakInfo) -> contract.isViolated(breakInfo.getLength() - 1))\n+                                .penalize(\"consecutiveFreeDays\", HardSoftScore.ONE_SOFT,\n+                                        (employee, contract, breakInfo) -> contract\n+                                                .getViolationAmount(breakInfo.getLength() - 1));\n+    }\n+\n+    Constraint maximumConsecutiveFreeDaysNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .join(NurseRosterParametrization.class, Joiners.lessThan((contract, employee) -> contract.getMaximumValue(),\n+                        nrp -> nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1))\n+                .penalize(\"maximumConsecutiveFreeDays (no shifts)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee, nrp) -> contract\n+                                .getViolationAmount(nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1));\n+    }\n+\n+    Constraint consecutiveFreeDaysFirstBreak(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shiftAssignment) -> contract,\n+                        (contract, shiftAssignment) -> shiftAssignment.getEmployee(),\n+                        ConstraintCollectors.<MinMaxContractLine, ShiftAssignment, ShiftAssignment> min(\n+                                (contract, shiftAssignment) -> shiftAssignment))\n+                .join(NurseRosterParametrization.class)\n+                .filter((contract, employee, shiftAssignment,\n+                        nrp) -> nrp.getFirstShiftDate() != shiftAssignment.getShiftDate() && contract\n+                                .isViolated(shiftAssignment.getShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex()))\n+                .penalize(\"consecutiveFreeDays (first break)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contractLine, employee, shiftAssignment, nrp) -> contractLine\n+                                .getViolationAmount(shiftAssignment.getShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex()));\n+    }\n+\n+    Constraint consecutiveFreeDaysFinalBreak(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shiftAssignment) -> contract,\n+                        (contract, shiftAssignment) -> shiftAssignment.getEmployee(),\n+                        ConstraintCollectors.<MinMaxContractLine, ShiftAssignment, ShiftAssignment> max(\n+                                (contract, shiftAssignment) -> shiftAssignment))\n+                .join(NurseRosterParametrization.class)\n+                .filter((contractLine, employee, shiftAssignment,\n+                        nrp) -> nrp.getLastShiftDate() != shiftAssignment.getShiftDate() &&\n+                                contractLine\n+                                        .isViolated(nrp.getLastShiftDateDayIndex() - shiftAssignment.getShiftDateDayIndex()))\n+                .penalize(\"consecutiveFreeDays (final break)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contractLine, employee, shiftAssignment, nrp) -> contractLine\n+                                .getViolationAmount(nrp.getLastShiftDateDayIndex() - shiftAssignment.getShiftDateDayIndex()));\n+    }\n+\n+    // Min/Max consecutive working weekends\n+    Constraint consecutiveWorkingWeekends(ConstraintFactory constraintFactory) {\n+        return getConsecutiveWorkingWeekends(constraintFactory,\n+                constraintFactory.from(MinMaxContractLine.class)\n+                        .filter(minMaxContractLine -> minMaxContractLine\n+                                .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_WEEKENDS &&\n+                                minMaxContractLine.isEnabled()))\n+                                        .filter((employee, contract, shiftList) -> contract.isViolated(shiftList.getLength()))\n+                                        .penalize(\"consecutiveWorkingWeekends\", HardSoftScore.ONE_SOFT,\n+                                                (employee, contract, shiftList) -> contract\n+                                                        .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Complete Weekends\n+    Constraint startOnNotFirstDayOfWeekend(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(BooleanContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.COMPLETE_WEEKENDS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract, shiftList) -> new EmployeeConsecutiveAssignmentStart(\n+                                        employee, shiftList.getItems().first())\n+                                                .isWeekendAndNotFirstDayOfWeekend())\n+                                .penalize(\"startOnNotFirstDayOfWeekend\", HardSoftScore.ONE_SOFT,\n+                                        (employee, contract, shiftList) -> new EmployeeConsecutiveAssignmentStart(employee,\n+                                                shiftList.getItems().first()).getDistanceToFirstDayOfWeekend()\n+                                                * contract.getWeight());\n+    }\n+\n+    Constraint endOnNotLastDayOfWeekend(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(BooleanContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.COMPLETE_WEEKENDS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract,\n+                                        shiftList) -> new EmployeeConsecutiveAssignmentEnd(employee,\n+                                                shiftList.getItems().last())\n+                                                        .isWeekendAndNotLastDayOfWeekend())\n+                                .penalize(\"endOnNotLastDayOfWeekend\", HardSoftScore.ONE_SOFT,\n+                                        (employee, contract, shiftList) -> new EmployeeConsecutiveAssignmentEnd(employee,\n+                                                shiftList.getItems().last()).getDistanceToLastDayOfWeekend()\n+                                                * contract.getWeight());\n+    }\n+\n+    // Identical shiftTypes during a weekend\n+    Constraint identicalShiftTypesDuringWeekend(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BooleanContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.IDENTICAL_SHIFT_TYPES_DURING_WEEKEND &&\n+                        minMaxContractLine.isEnabled())\n+                .join(constraintFactory.from(ShiftDate.class)\n+                        .filter(date -> date.getDayOfWeek() == DayOfWeek.SUNDAY))\n+                .join(constraintFactory.from(ShiftAssignment.class).filter(ShiftAssignment::isWeekend),\n+                        Joiners.equal((contract, date) -> date.getWeekendSundayIndex(), ShiftAssignment::getWeekendSundayIndex),\n+                        Joiners.equal((contract, date) -> contract.getContract(), ShiftAssignment::getContract))\n+                .groupBy((contract, date, sa) -> contract,\n+                        (contract, date, sa) -> sa.getEmployee(),\n+                        (contract, date, sa) -> ImmutablePair.of(sa.getShiftType(), date), // No 4-key groupBy overload\n+                        ConstraintCollectors.countTri())\n+                .filter((contract, employee, type, count) -> count < employee.getWeekendLength())\n+                .penalize(\"identicalShiftTypesDuringWeekend\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee, type, count) -> (employee.getWeekendLength() - count) * contract.getWeight());\n+    }\n+\n+    // Requested day on/off\n+    Constraint dayOffRequest(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(DayOffRequest.class)\n+                .join(ShiftAssignment.class, Joiners.equal(DayOffRequest::getEmployee, ShiftAssignment::getEmployee),\n+                        Joiners.equal(DayOffRequest::getShiftDate, ShiftAssignment::getShiftDate))\n+                .penalize(\"dayOffRequest\", HardSoftScore.ONE_SOFT,\n+                        (dayOffRequest, shiftAssignment) -> dayOffRequest.getWeight());\n+    }\n+\n+    Constraint dayOnRequest(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(DayOnRequest.class)\n+                .ifNotExists(ShiftAssignment.class, Joiners.equal(DayOnRequest::getEmployee, ShiftAssignment::getEmployee),\n+                        Joiners.equal(DayOnRequest::getShiftDate, ShiftAssignment::getShiftDate))\n+                .penalize(\"dayOnRequest\", HardSoftScore.ONE_SOFT,\n+                        DayOnRequest::getWeight);\n+    }\n+\n+    // Requested shift on/off\n+    Constraint shiftOffRequest(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ShiftOffRequest.class)\n+                .join(ShiftAssignment.class, Joiners.equal(ShiftOffRequest::getEmployee, ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftOffRequest::getShift, ShiftAssignment::getShift))\n+                .penalize(\"shiftOffRequest\", HardSoftScore.ONE_SOFT,\n+                        (shiftOffRequest, shiftAssignment) -> shiftOffRequest.getWeight());\n+    }\n+\n+    Constraint shiftOnRequest(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ShiftOnRequest.class)\n+                .ifNotExists(ShiftAssignment.class, Joiners.equal(ShiftOnRequest::getEmployee, ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftOnRequest::getShift, ShiftAssignment::getShift))\n+                .penalize(\"shiftOnRequest\", HardSoftScore.ONE_SOFT,\n+                        ShiftOnRequest::getWeight);\n+    }\n+\n+    // Alternative skill\n+    Constraint alternativeSkill(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BooleanContractLine.class)\n+                .filter(booleanContractLine -> booleanContractLine.getContractLineType()\n+                        .equals(ContractLineType.ALTERNATIVE_SKILL_CATEGORY))\n+                .join(ShiftAssignment.class, Joiners.equal(BooleanContractLine::getContract, ShiftAssignment::getContract))\n+                .join(ShiftTypeSkillRequirement.class,\n+                        Joiners.equal((contract, shiftAssignment) -> shiftAssignment.getShiftType(),\n+                                ShiftTypeSkillRequirement::getShiftType))\n+                .ifNotExists(SkillProficiency.class,\n+                        Joiners.equal((contract, shiftAssignment, skillRequirement) -> shiftAssignment.getEmployee(),\n+                                SkillProficiency::getEmployee),\n+                        Joiners.equal((contract, shiftAssignment, skillRequirement) -> skillRequirement.getSkill(),\n+                                SkillProficiency::getSkill))\n+                .penalize(\"alternativeSkill\", HardSoftScore.ONE_SOFT,\n+                        (contractLine, shiftAssignment, skillRequirement) -> contractLine.getWeight());\n+    }\n+\n+    // Unwanted patterns\n+    Constraint unwantedPatternFreeBefore2DaysWithAWorkDayPattern(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(FreeBefore2DaysWithAWorkDayPattern.class)\n+                .join(PatternContractLine.class, Joiners.equal(p -> p, PatternContractLine::getPattern))\n+                .join(ShiftDate.class,\n+                        Joiners.equal((pattern, contract) -> pattern.getFreeDayOfWeek(), ShiftDate::getDayOfWeek))\n+                .join(Employee.class,\n+                        Joiners.equal((pattern, contractLine, date) -> contractLine.getContract(), Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((pattern, contractLine, date, employee) -> employee, ShiftAssignment::getEmployee),\n+                        Joiners.equal((pattern, contractLine, date, employee) -> date.getDayIndex(),\n+                                ShiftAssignment::getShiftDateDayIndex))\n+                .ifExists(ShiftAssignment.class,\n+                        Joiners.equal((pattern, contractLine, date, employee) -> employee, ShiftAssignment::getEmployee),\n+                        // TODO: Replace with pair of greaterThan/lessThan joiners?\n+                        Joiners.filtering((pattern, contractLine, date, employee,\n+                                shift) -> shift.getShiftDateDayIndex() == (date.getDayIndex() + 1)\n+                                        || shift.getShiftDateDayIndex() == (date.getDayIndex() + 2)))\n+                .penalize(\"unwantedPatternFreeBefore2DaysWithAWorkDayPattern\", HardSoftScore.ONE_SOFT,\n+                        (pattern, contractLine, date, employee) -> pattern.getWeight());\n+    }\n+\n+    Constraint unwantedPatternShiftType2DaysPattern(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ShiftType2DaysPattern.class)\n+                .join(PatternContractLine.class, Joiners.equal(p -> p, PatternContractLine::getPattern))\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal((pattern, contractLine) -> pattern.getDayIndex0ShiftType(),\n+                                ShiftAssignment::getShiftType),\n+                        Joiners.equal((pattern, contractLine) -> contractLine.getContract(), ShiftAssignment::getContract))\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal((pattern, contractLine, shift) -> shift.getEmployee(), ShiftAssignment::getEmployee),\n+                        Joiners.equal((pattern, contractLine, shift) -> shift.getShiftDateDayIndex() + 1,\n+                                ShiftAssignment::getShiftDateDayIndex),\n+                        Joiners.filtering((pattern, contractLine, shift1, shift2) -> pattern.getDayIndex1ShiftType() == null\n+                                || shift2.getShiftType() == pattern.getDayIndex1ShiftType()))\n+                .penalize(\"unwantedPatternShiftType2DaysPattern\", HardSoftScore.ONE_SOFT,\n+                        (pattern, contractLine, shift1, shift2) -> pattern.getWeight());\n+    }\n+\n+    Constraint unwantedPatternShiftType3DaysPattern(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ShiftType3DaysPattern.class)", "originalCommit": "57394f70d678c2cdc90f852b229de6749866c003", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTEzNDMzOA==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r639134338", "bodyText": "ShiftType2DaysPattern appears avoidable through PatternContractLine.", "author": "triceo", "createdAt": "2021-05-25T19:46:04Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.tri.TriConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.util.Break;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.common.ExperimentalConstraintCollectors;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.NurseRosterParametrization;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.ShiftDate;\n+import org.optaplanner.examples.nurserostering.domain.ShiftTypeSkillRequirement;\n+import org.optaplanner.examples.nurserostering.domain.SkillProficiency;\n+import org.optaplanner.examples.nurserostering.domain.contract.BooleanContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.PatternContractLine;\n+import org.optaplanner.examples.nurserostering.domain.pattern.FreeBefore2DaysWithAWorkDayPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType2DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType3DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOnRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOnRequest;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentEnd;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentStart;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public <C extends ContractLine> TriConstraintStream<Employee, C, Sequence<ShiftDate>>\n+            getConsecutiveShifts(UniConstraintStream<C> constraintStream) {\n+        return constraintStream\n+                .join(ShiftAssignment.class, Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shift) -> shift.getEmployee(), (contract, shift) -> contract,\n+                        ExperimentalConstraintCollectors.consecutive((contract, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    public TriConstraintStream<Employee, MinMaxContractLine, Break<ShiftDate, Integer>>\n+            getBreaks(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream\n+                .join(ShiftAssignment.class, Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shift) -> shift.getEmployee(), (contract, shift) -> contract,\n+                        ExperimentalConstraintCollectors.consecutive((contract, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getBreaks);\n+    }\n+\n+    public TriConstraintStream<Employee, MinMaxContractLine, Sequence<ShiftDate>>\n+            getConsecutiveWorkingWeekends(ConstraintFactory constraintFactory,\n+                    UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(constraintFactory.from(ShiftAssignment.class).filter(ShiftAssignment::isWeekend),\n+                Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shift) -> shift.getEmployee(), (contract, shift) -> contract,\n+                        ExperimentalConstraintCollectors.consecutive((contract, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getWeekendSundayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                oneShiftPerDay(constraintFactory),\n+                minimumAndMaximumNumberOfAssignments(constraintFactory),\n+                minimumNumberOfAssignmentsNoAssignments(constraintFactory),\n+                consecutiveWorkingDays(constraintFactory),\n+                consecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDaysNoAssignments(constraintFactory),\n+                consecutiveFreeDaysFirstBreak(constraintFactory),\n+                consecutiveFreeDaysFinalBreak(constraintFactory),\n+                consecutiveWorkingWeekends(constraintFactory),\n+                startOnNotFirstDayOfWeekend(constraintFactory),\n+                endOnNotLastDayOfWeekend(constraintFactory),\n+                identicalShiftTypesDuringWeekend(constraintFactory),\n+                dayOffRequest(constraintFactory),\n+                dayOnRequest(constraintFactory),\n+                shiftOffRequest(constraintFactory),\n+                shiftOnRequest(constraintFactory),\n+                alternativeSkill(constraintFactory),\n+                unwantedPatternFreeBefore2DaysWithAWorkDayPattern(constraintFactory),\n+                unwantedPatternShiftType2DaysPattern(constraintFactory),\n+                unwantedPatternShiftType3DaysPattern(constraintFactory),\n+        };\n+    }\n+\n+    // ############################################################################\n+    // Hard constraints\n+    // ############################################################################\n+\n+    // A nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day.\n+    Constraint oneShiftPerDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory\n+                .fromUniquePair(ShiftAssignment.class,\n+                        Joiners.equal(ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftAssignment::getShiftDate))\n+                .penalize(\"oneShiftPerDay\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    // ############################################################################\n+    // Soft constraints\n+    // ############################################################################\n+    Constraint minimumAndMaximumNumberOfAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(ShiftAssignment.class, Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((line, shift) -> shift.getEmployee(), (line, shift) -> line, ConstraintCollectors.countBi())\n+                .filter((employee, contract, shiftCount) -> employee != null && contract.isViolated(shiftCount))\n+                .penalize(\"Minimum and maximum number of assignments\", HardSoftScore.ONE_SOFT,\n+                        (employee, contract, shiftCount) -> contract.getViolationAmount(shiftCount));\n+    }\n+\n+    Constraint minimumNumberOfAssignmentsNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .filter((contract, employee) -> contract.isViolated(0))\n+                .penalize(\"Minimum and maximum number of assignments (no assignments)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee) -> contract.getViolationAmount(0));\n+    }\n+\n+    // Min/Max consecutive working days\n+    // These Min/Max constraints are implemented as two constraints for consistency with DRL\n+    Constraint consecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract, shiftList) -> contract.isViolated(shiftList.getLength()))\n+                                .penalize(\"consecutiveWorkingDays\", HardSoftScore.ONE_SOFT,\n+                                        (employee, contract, shiftList) -> contract.getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Min/Max consecutive free days\n+    Constraint consecutiveFreeDays(ConstraintFactory constraintFactory) {\n+        return getBreaks(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract, breakInfo) -> contract.isViolated(breakInfo.getLength() - 1))\n+                                .penalize(\"consecutiveFreeDays\", HardSoftScore.ONE_SOFT,\n+                                        (employee, contract, breakInfo) -> contract\n+                                                .getViolationAmount(breakInfo.getLength() - 1));\n+    }\n+\n+    Constraint maximumConsecutiveFreeDaysNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .join(NurseRosterParametrization.class, Joiners.lessThan((contract, employee) -> contract.getMaximumValue(),\n+                        nrp -> nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1))\n+                .penalize(\"maximumConsecutiveFreeDays (no shifts)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee, nrp) -> contract\n+                                .getViolationAmount(nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1));\n+    }\n+\n+    Constraint consecutiveFreeDaysFirstBreak(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shiftAssignment) -> contract,\n+                        (contract, shiftAssignment) -> shiftAssignment.getEmployee(),\n+                        ConstraintCollectors.<MinMaxContractLine, ShiftAssignment, ShiftAssignment> min(\n+                                (contract, shiftAssignment) -> shiftAssignment))\n+                .join(NurseRosterParametrization.class)\n+                .filter((contract, employee, shiftAssignment,\n+                        nrp) -> nrp.getFirstShiftDate() != shiftAssignment.getShiftDate() && contract\n+                                .isViolated(shiftAssignment.getShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex()))\n+                .penalize(\"consecutiveFreeDays (first break)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contractLine, employee, shiftAssignment, nrp) -> contractLine\n+                                .getViolationAmount(shiftAssignment.getShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex()));\n+    }\n+\n+    Constraint consecutiveFreeDaysFinalBreak(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shiftAssignment) -> contract,\n+                        (contract, shiftAssignment) -> shiftAssignment.getEmployee(),\n+                        ConstraintCollectors.<MinMaxContractLine, ShiftAssignment, ShiftAssignment> max(\n+                                (contract, shiftAssignment) -> shiftAssignment))\n+                .join(NurseRosterParametrization.class)\n+                .filter((contractLine, employee, shiftAssignment,\n+                        nrp) -> nrp.getLastShiftDate() != shiftAssignment.getShiftDate() &&\n+                                contractLine\n+                                        .isViolated(nrp.getLastShiftDateDayIndex() - shiftAssignment.getShiftDateDayIndex()))\n+                .penalize(\"consecutiveFreeDays (final break)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contractLine, employee, shiftAssignment, nrp) -> contractLine\n+                                .getViolationAmount(nrp.getLastShiftDateDayIndex() - shiftAssignment.getShiftDateDayIndex()));\n+    }\n+\n+    // Min/Max consecutive working weekends\n+    Constraint consecutiveWorkingWeekends(ConstraintFactory constraintFactory) {\n+        return getConsecutiveWorkingWeekends(constraintFactory,\n+                constraintFactory.from(MinMaxContractLine.class)\n+                        .filter(minMaxContractLine -> minMaxContractLine\n+                                .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_WEEKENDS &&\n+                                minMaxContractLine.isEnabled()))\n+                                        .filter((employee, contract, shiftList) -> contract.isViolated(shiftList.getLength()))\n+                                        .penalize(\"consecutiveWorkingWeekends\", HardSoftScore.ONE_SOFT,\n+                                                (employee, contract, shiftList) -> contract\n+                                                        .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Complete Weekends\n+    Constraint startOnNotFirstDayOfWeekend(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(BooleanContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.COMPLETE_WEEKENDS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract, shiftList) -> new EmployeeConsecutiveAssignmentStart(\n+                                        employee, shiftList.getItems().first())\n+                                                .isWeekendAndNotFirstDayOfWeekend())\n+                                .penalize(\"startOnNotFirstDayOfWeekend\", HardSoftScore.ONE_SOFT,\n+                                        (employee, contract, shiftList) -> new EmployeeConsecutiveAssignmentStart(employee,\n+                                                shiftList.getItems().first()).getDistanceToFirstDayOfWeekend()\n+                                                * contract.getWeight());\n+    }\n+\n+    Constraint endOnNotLastDayOfWeekend(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(BooleanContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.COMPLETE_WEEKENDS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract,\n+                                        shiftList) -> new EmployeeConsecutiveAssignmentEnd(employee,\n+                                                shiftList.getItems().last())\n+                                                        .isWeekendAndNotLastDayOfWeekend())\n+                                .penalize(\"endOnNotLastDayOfWeekend\", HardSoftScore.ONE_SOFT,\n+                                        (employee, contract, shiftList) -> new EmployeeConsecutiveAssignmentEnd(employee,\n+                                                shiftList.getItems().last()).getDistanceToLastDayOfWeekend()\n+                                                * contract.getWeight());\n+    }\n+\n+    // Identical shiftTypes during a weekend\n+    Constraint identicalShiftTypesDuringWeekend(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BooleanContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.IDENTICAL_SHIFT_TYPES_DURING_WEEKEND &&\n+                        minMaxContractLine.isEnabled())\n+                .join(constraintFactory.from(ShiftDate.class)\n+                        .filter(date -> date.getDayOfWeek() == DayOfWeek.SUNDAY))\n+                .join(constraintFactory.from(ShiftAssignment.class).filter(ShiftAssignment::isWeekend),\n+                        Joiners.equal((contract, date) -> date.getWeekendSundayIndex(), ShiftAssignment::getWeekendSundayIndex),\n+                        Joiners.equal((contract, date) -> contract.getContract(), ShiftAssignment::getContract))\n+                .groupBy((contract, date, sa) -> contract,\n+                        (contract, date, sa) -> sa.getEmployee(),\n+                        (contract, date, sa) -> ImmutablePair.of(sa.getShiftType(), date), // No 4-key groupBy overload\n+                        ConstraintCollectors.countTri())\n+                .filter((contract, employee, type, count) -> count < employee.getWeekendLength())\n+                .penalize(\"identicalShiftTypesDuringWeekend\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee, type, count) -> (employee.getWeekendLength() - count) * contract.getWeight());\n+    }\n+\n+    // Requested day on/off\n+    Constraint dayOffRequest(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(DayOffRequest.class)\n+                .join(ShiftAssignment.class, Joiners.equal(DayOffRequest::getEmployee, ShiftAssignment::getEmployee),\n+                        Joiners.equal(DayOffRequest::getShiftDate, ShiftAssignment::getShiftDate))\n+                .penalize(\"dayOffRequest\", HardSoftScore.ONE_SOFT,\n+                        (dayOffRequest, shiftAssignment) -> dayOffRequest.getWeight());\n+    }\n+\n+    Constraint dayOnRequest(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(DayOnRequest.class)\n+                .ifNotExists(ShiftAssignment.class, Joiners.equal(DayOnRequest::getEmployee, ShiftAssignment::getEmployee),\n+                        Joiners.equal(DayOnRequest::getShiftDate, ShiftAssignment::getShiftDate))\n+                .penalize(\"dayOnRequest\", HardSoftScore.ONE_SOFT,\n+                        DayOnRequest::getWeight);\n+    }\n+\n+    // Requested shift on/off\n+    Constraint shiftOffRequest(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ShiftOffRequest.class)\n+                .join(ShiftAssignment.class, Joiners.equal(ShiftOffRequest::getEmployee, ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftOffRequest::getShift, ShiftAssignment::getShift))\n+                .penalize(\"shiftOffRequest\", HardSoftScore.ONE_SOFT,\n+                        (shiftOffRequest, shiftAssignment) -> shiftOffRequest.getWeight());\n+    }\n+\n+    Constraint shiftOnRequest(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ShiftOnRequest.class)\n+                .ifNotExists(ShiftAssignment.class, Joiners.equal(ShiftOnRequest::getEmployee, ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftOnRequest::getShift, ShiftAssignment::getShift))\n+                .penalize(\"shiftOnRequest\", HardSoftScore.ONE_SOFT,\n+                        ShiftOnRequest::getWeight);\n+    }\n+\n+    // Alternative skill\n+    Constraint alternativeSkill(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BooleanContractLine.class)\n+                .filter(booleanContractLine -> booleanContractLine.getContractLineType()\n+                        .equals(ContractLineType.ALTERNATIVE_SKILL_CATEGORY))\n+                .join(ShiftAssignment.class, Joiners.equal(BooleanContractLine::getContract, ShiftAssignment::getContract))\n+                .join(ShiftTypeSkillRequirement.class,\n+                        Joiners.equal((contract, shiftAssignment) -> shiftAssignment.getShiftType(),\n+                                ShiftTypeSkillRequirement::getShiftType))\n+                .ifNotExists(SkillProficiency.class,\n+                        Joiners.equal((contract, shiftAssignment, skillRequirement) -> shiftAssignment.getEmployee(),\n+                                SkillProficiency::getEmployee),\n+                        Joiners.equal((contract, shiftAssignment, skillRequirement) -> skillRequirement.getSkill(),\n+                                SkillProficiency::getSkill))\n+                .penalize(\"alternativeSkill\", HardSoftScore.ONE_SOFT,\n+                        (contractLine, shiftAssignment, skillRequirement) -> contractLine.getWeight());\n+    }\n+\n+    // Unwanted patterns\n+    Constraint unwantedPatternFreeBefore2DaysWithAWorkDayPattern(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(FreeBefore2DaysWithAWorkDayPattern.class)\n+                .join(PatternContractLine.class, Joiners.equal(p -> p, PatternContractLine::getPattern))\n+                .join(ShiftDate.class,\n+                        Joiners.equal((pattern, contract) -> pattern.getFreeDayOfWeek(), ShiftDate::getDayOfWeek))\n+                .join(Employee.class,\n+                        Joiners.equal((pattern, contractLine, date) -> contractLine.getContract(), Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((pattern, contractLine, date, employee) -> employee, ShiftAssignment::getEmployee),\n+                        Joiners.equal((pattern, contractLine, date, employee) -> date.getDayIndex(),\n+                                ShiftAssignment::getShiftDateDayIndex))\n+                .ifExists(ShiftAssignment.class,\n+                        Joiners.equal((pattern, contractLine, date, employee) -> employee, ShiftAssignment::getEmployee),\n+                        // TODO: Replace with pair of greaterThan/lessThan joiners?\n+                        Joiners.filtering((pattern, contractLine, date, employee,\n+                                shift) -> shift.getShiftDateDayIndex() == (date.getDayIndex() + 1)\n+                                        || shift.getShiftDateDayIndex() == (date.getDayIndex() + 2)))\n+                .penalize(\"unwantedPatternFreeBefore2DaysWithAWorkDayPattern\", HardSoftScore.ONE_SOFT,\n+                        (pattern, contractLine, date, employee) -> pattern.getWeight());\n+    }\n+\n+    Constraint unwantedPatternShiftType2DaysPattern(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ShiftType2DaysPattern.class)\n+                .join(PatternContractLine.class, Joiners.equal(p -> p, PatternContractLine::getPattern))", "originalCommit": "57394f70d678c2cdc90f852b229de6749866c003", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTEzNDYxNw==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r639134617", "bodyText": "FreeBefore2DaysWithAWorkDayPattern appears avoidable through PatternContractLine.", "author": "triceo", "createdAt": "2021-05-25T19:46:36Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.tri.TriConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.util.Break;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.common.ExperimentalConstraintCollectors;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.NurseRosterParametrization;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.ShiftDate;\n+import org.optaplanner.examples.nurserostering.domain.ShiftTypeSkillRequirement;\n+import org.optaplanner.examples.nurserostering.domain.SkillProficiency;\n+import org.optaplanner.examples.nurserostering.domain.contract.BooleanContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.PatternContractLine;\n+import org.optaplanner.examples.nurserostering.domain.pattern.FreeBefore2DaysWithAWorkDayPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType2DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType3DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOnRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOnRequest;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentEnd;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentStart;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public <C extends ContractLine> TriConstraintStream<Employee, C, Sequence<ShiftDate>>\n+            getConsecutiveShifts(UniConstraintStream<C> constraintStream) {\n+        return constraintStream\n+                .join(ShiftAssignment.class, Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shift) -> shift.getEmployee(), (contract, shift) -> contract,\n+                        ExperimentalConstraintCollectors.consecutive((contract, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    public TriConstraintStream<Employee, MinMaxContractLine, Break<ShiftDate, Integer>>\n+            getBreaks(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream\n+                .join(ShiftAssignment.class, Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shift) -> shift.getEmployee(), (contract, shift) -> contract,\n+                        ExperimentalConstraintCollectors.consecutive((contract, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getBreaks);\n+    }\n+\n+    public TriConstraintStream<Employee, MinMaxContractLine, Sequence<ShiftDate>>\n+            getConsecutiveWorkingWeekends(ConstraintFactory constraintFactory,\n+                    UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(constraintFactory.from(ShiftAssignment.class).filter(ShiftAssignment::isWeekend),\n+                Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shift) -> shift.getEmployee(), (contract, shift) -> contract,\n+                        ExperimentalConstraintCollectors.consecutive((contract, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getWeekendSundayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                oneShiftPerDay(constraintFactory),\n+                minimumAndMaximumNumberOfAssignments(constraintFactory),\n+                minimumNumberOfAssignmentsNoAssignments(constraintFactory),\n+                consecutiveWorkingDays(constraintFactory),\n+                consecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDaysNoAssignments(constraintFactory),\n+                consecutiveFreeDaysFirstBreak(constraintFactory),\n+                consecutiveFreeDaysFinalBreak(constraintFactory),\n+                consecutiveWorkingWeekends(constraintFactory),\n+                startOnNotFirstDayOfWeekend(constraintFactory),\n+                endOnNotLastDayOfWeekend(constraintFactory),\n+                identicalShiftTypesDuringWeekend(constraintFactory),\n+                dayOffRequest(constraintFactory),\n+                dayOnRequest(constraintFactory),\n+                shiftOffRequest(constraintFactory),\n+                shiftOnRequest(constraintFactory),\n+                alternativeSkill(constraintFactory),\n+                unwantedPatternFreeBefore2DaysWithAWorkDayPattern(constraintFactory),\n+                unwantedPatternShiftType2DaysPattern(constraintFactory),\n+                unwantedPatternShiftType3DaysPattern(constraintFactory),\n+        };\n+    }\n+\n+    // ############################################################################\n+    // Hard constraints\n+    // ############################################################################\n+\n+    // A nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day.\n+    Constraint oneShiftPerDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory\n+                .fromUniquePair(ShiftAssignment.class,\n+                        Joiners.equal(ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftAssignment::getShiftDate))\n+                .penalize(\"oneShiftPerDay\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    // ############################################################################\n+    // Soft constraints\n+    // ############################################################################\n+    Constraint minimumAndMaximumNumberOfAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(ShiftAssignment.class, Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((line, shift) -> shift.getEmployee(), (line, shift) -> line, ConstraintCollectors.countBi())\n+                .filter((employee, contract, shiftCount) -> employee != null && contract.isViolated(shiftCount))\n+                .penalize(\"Minimum and maximum number of assignments\", HardSoftScore.ONE_SOFT,\n+                        (employee, contract, shiftCount) -> contract.getViolationAmount(shiftCount));\n+    }\n+\n+    Constraint minimumNumberOfAssignmentsNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .filter((contract, employee) -> contract.isViolated(0))\n+                .penalize(\"Minimum and maximum number of assignments (no assignments)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee) -> contract.getViolationAmount(0));\n+    }\n+\n+    // Min/Max consecutive working days\n+    // These Min/Max constraints are implemented as two constraints for consistency with DRL\n+    Constraint consecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract, shiftList) -> contract.isViolated(shiftList.getLength()))\n+                                .penalize(\"consecutiveWorkingDays\", HardSoftScore.ONE_SOFT,\n+                                        (employee, contract, shiftList) -> contract.getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Min/Max consecutive free days\n+    Constraint consecutiveFreeDays(ConstraintFactory constraintFactory) {\n+        return getBreaks(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract, breakInfo) -> contract.isViolated(breakInfo.getLength() - 1))\n+                                .penalize(\"consecutiveFreeDays\", HardSoftScore.ONE_SOFT,\n+                                        (employee, contract, breakInfo) -> contract\n+                                                .getViolationAmount(breakInfo.getLength() - 1));\n+    }\n+\n+    Constraint maximumConsecutiveFreeDaysNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .join(NurseRosterParametrization.class, Joiners.lessThan((contract, employee) -> contract.getMaximumValue(),\n+                        nrp -> nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1))\n+                .penalize(\"maximumConsecutiveFreeDays (no shifts)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee, nrp) -> contract\n+                                .getViolationAmount(nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1));\n+    }\n+\n+    Constraint consecutiveFreeDaysFirstBreak(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shiftAssignment) -> contract,\n+                        (contract, shiftAssignment) -> shiftAssignment.getEmployee(),\n+                        ConstraintCollectors.<MinMaxContractLine, ShiftAssignment, ShiftAssignment> min(\n+                                (contract, shiftAssignment) -> shiftAssignment))\n+                .join(NurseRosterParametrization.class)\n+                .filter((contract, employee, shiftAssignment,\n+                        nrp) -> nrp.getFirstShiftDate() != shiftAssignment.getShiftDate() && contract\n+                                .isViolated(shiftAssignment.getShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex()))\n+                .penalize(\"consecutiveFreeDays (first break)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contractLine, employee, shiftAssignment, nrp) -> contractLine\n+                                .getViolationAmount(shiftAssignment.getShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex()));\n+    }\n+\n+    Constraint consecutiveFreeDaysFinalBreak(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shiftAssignment) -> contract,\n+                        (contract, shiftAssignment) -> shiftAssignment.getEmployee(),\n+                        ConstraintCollectors.<MinMaxContractLine, ShiftAssignment, ShiftAssignment> max(\n+                                (contract, shiftAssignment) -> shiftAssignment))\n+                .join(NurseRosterParametrization.class)\n+                .filter((contractLine, employee, shiftAssignment,\n+                        nrp) -> nrp.getLastShiftDate() != shiftAssignment.getShiftDate() &&\n+                                contractLine\n+                                        .isViolated(nrp.getLastShiftDateDayIndex() - shiftAssignment.getShiftDateDayIndex()))\n+                .penalize(\"consecutiveFreeDays (final break)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contractLine, employee, shiftAssignment, nrp) -> contractLine\n+                                .getViolationAmount(nrp.getLastShiftDateDayIndex() - shiftAssignment.getShiftDateDayIndex()));\n+    }\n+\n+    // Min/Max consecutive working weekends\n+    Constraint consecutiveWorkingWeekends(ConstraintFactory constraintFactory) {\n+        return getConsecutiveWorkingWeekends(constraintFactory,\n+                constraintFactory.from(MinMaxContractLine.class)\n+                        .filter(minMaxContractLine -> minMaxContractLine\n+                                .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_WEEKENDS &&\n+                                minMaxContractLine.isEnabled()))\n+                                        .filter((employee, contract, shiftList) -> contract.isViolated(shiftList.getLength()))\n+                                        .penalize(\"consecutiveWorkingWeekends\", HardSoftScore.ONE_SOFT,\n+                                                (employee, contract, shiftList) -> contract\n+                                                        .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Complete Weekends\n+    Constraint startOnNotFirstDayOfWeekend(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(BooleanContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.COMPLETE_WEEKENDS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract, shiftList) -> new EmployeeConsecutiveAssignmentStart(\n+                                        employee, shiftList.getItems().first())\n+                                                .isWeekendAndNotFirstDayOfWeekend())\n+                                .penalize(\"startOnNotFirstDayOfWeekend\", HardSoftScore.ONE_SOFT,\n+                                        (employee, contract, shiftList) -> new EmployeeConsecutiveAssignmentStart(employee,\n+                                                shiftList.getItems().first()).getDistanceToFirstDayOfWeekend()\n+                                                * contract.getWeight());\n+    }\n+\n+    Constraint endOnNotLastDayOfWeekend(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(BooleanContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.COMPLETE_WEEKENDS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract,\n+                                        shiftList) -> new EmployeeConsecutiveAssignmentEnd(employee,\n+                                                shiftList.getItems().last())\n+                                                        .isWeekendAndNotLastDayOfWeekend())\n+                                .penalize(\"endOnNotLastDayOfWeekend\", HardSoftScore.ONE_SOFT,\n+                                        (employee, contract, shiftList) -> new EmployeeConsecutiveAssignmentEnd(employee,\n+                                                shiftList.getItems().last()).getDistanceToLastDayOfWeekend()\n+                                                * contract.getWeight());\n+    }\n+\n+    // Identical shiftTypes during a weekend\n+    Constraint identicalShiftTypesDuringWeekend(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BooleanContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.IDENTICAL_SHIFT_TYPES_DURING_WEEKEND &&\n+                        minMaxContractLine.isEnabled())\n+                .join(constraintFactory.from(ShiftDate.class)\n+                        .filter(date -> date.getDayOfWeek() == DayOfWeek.SUNDAY))\n+                .join(constraintFactory.from(ShiftAssignment.class).filter(ShiftAssignment::isWeekend),\n+                        Joiners.equal((contract, date) -> date.getWeekendSundayIndex(), ShiftAssignment::getWeekendSundayIndex),\n+                        Joiners.equal((contract, date) -> contract.getContract(), ShiftAssignment::getContract))\n+                .groupBy((contract, date, sa) -> contract,\n+                        (contract, date, sa) -> sa.getEmployee(),\n+                        (contract, date, sa) -> ImmutablePair.of(sa.getShiftType(), date), // No 4-key groupBy overload\n+                        ConstraintCollectors.countTri())\n+                .filter((contract, employee, type, count) -> count < employee.getWeekendLength())\n+                .penalize(\"identicalShiftTypesDuringWeekend\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee, type, count) -> (employee.getWeekendLength() - count) * contract.getWeight());\n+    }\n+\n+    // Requested day on/off\n+    Constraint dayOffRequest(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(DayOffRequest.class)\n+                .join(ShiftAssignment.class, Joiners.equal(DayOffRequest::getEmployee, ShiftAssignment::getEmployee),\n+                        Joiners.equal(DayOffRequest::getShiftDate, ShiftAssignment::getShiftDate))\n+                .penalize(\"dayOffRequest\", HardSoftScore.ONE_SOFT,\n+                        (dayOffRequest, shiftAssignment) -> dayOffRequest.getWeight());\n+    }\n+\n+    Constraint dayOnRequest(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(DayOnRequest.class)\n+                .ifNotExists(ShiftAssignment.class, Joiners.equal(DayOnRequest::getEmployee, ShiftAssignment::getEmployee),\n+                        Joiners.equal(DayOnRequest::getShiftDate, ShiftAssignment::getShiftDate))\n+                .penalize(\"dayOnRequest\", HardSoftScore.ONE_SOFT,\n+                        DayOnRequest::getWeight);\n+    }\n+\n+    // Requested shift on/off\n+    Constraint shiftOffRequest(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ShiftOffRequest.class)\n+                .join(ShiftAssignment.class, Joiners.equal(ShiftOffRequest::getEmployee, ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftOffRequest::getShift, ShiftAssignment::getShift))\n+                .penalize(\"shiftOffRequest\", HardSoftScore.ONE_SOFT,\n+                        (shiftOffRequest, shiftAssignment) -> shiftOffRequest.getWeight());\n+    }\n+\n+    Constraint shiftOnRequest(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ShiftOnRequest.class)\n+                .ifNotExists(ShiftAssignment.class, Joiners.equal(ShiftOnRequest::getEmployee, ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftOnRequest::getShift, ShiftAssignment::getShift))\n+                .penalize(\"shiftOnRequest\", HardSoftScore.ONE_SOFT,\n+                        ShiftOnRequest::getWeight);\n+    }\n+\n+    // Alternative skill\n+    Constraint alternativeSkill(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BooleanContractLine.class)\n+                .filter(booleanContractLine -> booleanContractLine.getContractLineType()\n+                        .equals(ContractLineType.ALTERNATIVE_SKILL_CATEGORY))\n+                .join(ShiftAssignment.class, Joiners.equal(BooleanContractLine::getContract, ShiftAssignment::getContract))\n+                .join(ShiftTypeSkillRequirement.class,\n+                        Joiners.equal((contract, shiftAssignment) -> shiftAssignment.getShiftType(),\n+                                ShiftTypeSkillRequirement::getShiftType))\n+                .ifNotExists(SkillProficiency.class,\n+                        Joiners.equal((contract, shiftAssignment, skillRequirement) -> shiftAssignment.getEmployee(),\n+                                SkillProficiency::getEmployee),\n+                        Joiners.equal((contract, shiftAssignment, skillRequirement) -> skillRequirement.getSkill(),\n+                                SkillProficiency::getSkill))\n+                .penalize(\"alternativeSkill\", HardSoftScore.ONE_SOFT,\n+                        (contractLine, shiftAssignment, skillRequirement) -> contractLine.getWeight());\n+    }\n+\n+    // Unwanted patterns\n+    Constraint unwantedPatternFreeBefore2DaysWithAWorkDayPattern(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(FreeBefore2DaysWithAWorkDayPattern.class)", "originalCommit": "57394f70d678c2cdc90f852b229de6749866c003", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTEzNTY1MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r639135651", "bodyText": "Formatting,", "author": "triceo", "createdAt": "2021-05-25T19:48:26Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.tri.TriConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.util.Break;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.common.ExperimentalConstraintCollectors;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.NurseRosterParametrization;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.ShiftDate;\n+import org.optaplanner.examples.nurserostering.domain.ShiftTypeSkillRequirement;\n+import org.optaplanner.examples.nurserostering.domain.SkillProficiency;\n+import org.optaplanner.examples.nurserostering.domain.contract.BooleanContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.PatternContractLine;\n+import org.optaplanner.examples.nurserostering.domain.pattern.FreeBefore2DaysWithAWorkDayPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType2DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType3DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOnRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOnRequest;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentEnd;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentStart;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public <C extends ContractLine> TriConstraintStream<Employee, C, Sequence<ShiftDate>>\n+            getConsecutiveShifts(UniConstraintStream<C> constraintStream) {\n+        return constraintStream\n+                .join(ShiftAssignment.class, Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shift) -> shift.getEmployee(), (contract, shift) -> contract,\n+                        ExperimentalConstraintCollectors.consecutive((contract, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    public TriConstraintStream<Employee, MinMaxContractLine, Break<ShiftDate, Integer>>\n+            getBreaks(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream\n+                .join(ShiftAssignment.class, Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shift) -> shift.getEmployee(), (contract, shift) -> contract,\n+                        ExperimentalConstraintCollectors.consecutive((contract, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getBreaks);\n+    }\n+\n+    public TriConstraintStream<Employee, MinMaxContractLine, Sequence<ShiftDate>>\n+            getConsecutiveWorkingWeekends(ConstraintFactory constraintFactory,\n+                    UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(constraintFactory.from(ShiftAssignment.class).filter(ShiftAssignment::isWeekend),\n+                Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shift) -> shift.getEmployee(), (contract, shift) -> contract,\n+                        ExperimentalConstraintCollectors.consecutive((contract, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getWeekendSundayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                oneShiftPerDay(constraintFactory),\n+                minimumAndMaximumNumberOfAssignments(constraintFactory),\n+                minimumNumberOfAssignmentsNoAssignments(constraintFactory),\n+                consecutiveWorkingDays(constraintFactory),\n+                consecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDaysNoAssignments(constraintFactory),\n+                consecutiveFreeDaysFirstBreak(constraintFactory),\n+                consecutiveFreeDaysFinalBreak(constraintFactory),\n+                consecutiveWorkingWeekends(constraintFactory),\n+                startOnNotFirstDayOfWeekend(constraintFactory),\n+                endOnNotLastDayOfWeekend(constraintFactory),\n+                identicalShiftTypesDuringWeekend(constraintFactory),\n+                dayOffRequest(constraintFactory),\n+                dayOnRequest(constraintFactory),\n+                shiftOffRequest(constraintFactory),\n+                shiftOnRequest(constraintFactory),\n+                alternativeSkill(constraintFactory),\n+                unwantedPatternFreeBefore2DaysWithAWorkDayPattern(constraintFactory),\n+                unwantedPatternShiftType2DaysPattern(constraintFactory),\n+                unwantedPatternShiftType3DaysPattern(constraintFactory),\n+        };\n+    }\n+\n+    // ############################################################################\n+    // Hard constraints\n+    // ############################################################################\n+\n+    // A nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day.\n+    Constraint oneShiftPerDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory\n+                .fromUniquePair(ShiftAssignment.class,\n+                        Joiners.equal(ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftAssignment::getShiftDate))\n+                .penalize(\"oneShiftPerDay\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    // ############################################################################\n+    // Soft constraints\n+    // ############################################################################\n+    Constraint minimumAndMaximumNumberOfAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(ShiftAssignment.class, Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((line, shift) -> shift.getEmployee(), (line, shift) -> line, ConstraintCollectors.countBi())\n+                .filter((employee, contract, shiftCount) -> employee != null && contract.isViolated(shiftCount))\n+                .penalize(\"Minimum and maximum number of assignments\", HardSoftScore.ONE_SOFT,\n+                        (employee, contract, shiftCount) -> contract.getViolationAmount(shiftCount));\n+    }\n+\n+    Constraint minimumNumberOfAssignmentsNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .filter((contract, employee) -> contract.isViolated(0))\n+                .penalize(\"Minimum and maximum number of assignments (no assignments)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee) -> contract.getViolationAmount(0));\n+    }\n+\n+    // Min/Max consecutive working days\n+    // These Min/Max constraints are implemented as two constraints for consistency with DRL\n+    Constraint consecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract, shiftList) -> contract.isViolated(shiftList.getLength()))\n+                                .penalize(\"consecutiveWorkingDays\", HardSoftScore.ONE_SOFT,\n+                                        (employee, contract, shiftList) -> contract.getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Min/Max consecutive free days\n+    Constraint consecutiveFreeDays(ConstraintFactory constraintFactory) {\n+        return getBreaks(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract, breakInfo) -> contract.isViolated(breakInfo.getLength() - 1))\n+                                .penalize(\"consecutiveFreeDays\", HardSoftScore.ONE_SOFT,", "originalCommit": "57394f70d678c2cdc90f852b229de6749866c003", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTEzNTc1Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r639135756", "bodyText": "Formatting.", "author": "triceo", "createdAt": "2021-05-25T19:48:36Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.tri.TriConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.util.Break;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.common.ExperimentalConstraintCollectors;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.NurseRosterParametrization;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.ShiftDate;\n+import org.optaplanner.examples.nurserostering.domain.ShiftTypeSkillRequirement;\n+import org.optaplanner.examples.nurserostering.domain.SkillProficiency;\n+import org.optaplanner.examples.nurserostering.domain.contract.BooleanContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.PatternContractLine;\n+import org.optaplanner.examples.nurserostering.domain.pattern.FreeBefore2DaysWithAWorkDayPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType2DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType3DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOnRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOnRequest;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentEnd;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentStart;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public <C extends ContractLine> TriConstraintStream<Employee, C, Sequence<ShiftDate>>\n+            getConsecutiveShifts(UniConstraintStream<C> constraintStream) {\n+        return constraintStream\n+                .join(ShiftAssignment.class, Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shift) -> shift.getEmployee(), (contract, shift) -> contract,\n+                        ExperimentalConstraintCollectors.consecutive((contract, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    public TriConstraintStream<Employee, MinMaxContractLine, Break<ShiftDate, Integer>>\n+            getBreaks(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream\n+                .join(ShiftAssignment.class, Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shift) -> shift.getEmployee(), (contract, shift) -> contract,\n+                        ExperimentalConstraintCollectors.consecutive((contract, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getBreaks);\n+    }\n+\n+    public TriConstraintStream<Employee, MinMaxContractLine, Sequence<ShiftDate>>\n+            getConsecutiveWorkingWeekends(ConstraintFactory constraintFactory,\n+                    UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(constraintFactory.from(ShiftAssignment.class).filter(ShiftAssignment::isWeekend),\n+                Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shift) -> shift.getEmployee(), (contract, shift) -> contract,\n+                        ExperimentalConstraintCollectors.consecutive((contract, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getWeekendSundayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                oneShiftPerDay(constraintFactory),\n+                minimumAndMaximumNumberOfAssignments(constraintFactory),\n+                minimumNumberOfAssignmentsNoAssignments(constraintFactory),\n+                consecutiveWorkingDays(constraintFactory),\n+                consecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDaysNoAssignments(constraintFactory),\n+                consecutiveFreeDaysFirstBreak(constraintFactory),\n+                consecutiveFreeDaysFinalBreak(constraintFactory),\n+                consecutiveWorkingWeekends(constraintFactory),\n+                startOnNotFirstDayOfWeekend(constraintFactory),\n+                endOnNotLastDayOfWeekend(constraintFactory),\n+                identicalShiftTypesDuringWeekend(constraintFactory),\n+                dayOffRequest(constraintFactory),\n+                dayOnRequest(constraintFactory),\n+                shiftOffRequest(constraintFactory),\n+                shiftOnRequest(constraintFactory),\n+                alternativeSkill(constraintFactory),\n+                unwantedPatternFreeBefore2DaysWithAWorkDayPattern(constraintFactory),\n+                unwantedPatternShiftType2DaysPattern(constraintFactory),\n+                unwantedPatternShiftType3DaysPattern(constraintFactory),\n+        };\n+    }\n+\n+    // ############################################################################\n+    // Hard constraints\n+    // ############################################################################\n+\n+    // A nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day.\n+    Constraint oneShiftPerDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory\n+                .fromUniquePair(ShiftAssignment.class,\n+                        Joiners.equal(ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftAssignment::getShiftDate))\n+                .penalize(\"oneShiftPerDay\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    // ############################################################################\n+    // Soft constraints\n+    // ############################################################################\n+    Constraint minimumAndMaximumNumberOfAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(ShiftAssignment.class, Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((line, shift) -> shift.getEmployee(), (line, shift) -> line, ConstraintCollectors.countBi())\n+                .filter((employee, contract, shiftCount) -> employee != null && contract.isViolated(shiftCount))\n+                .penalize(\"Minimum and maximum number of assignments\", HardSoftScore.ONE_SOFT,\n+                        (employee, contract, shiftCount) -> contract.getViolationAmount(shiftCount));\n+    }\n+\n+    Constraint minimumNumberOfAssignmentsNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .filter((contract, employee) -> contract.isViolated(0))\n+                .penalize(\"Minimum and maximum number of assignments (no assignments)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee) -> contract.getViolationAmount(0));\n+    }\n+\n+    // Min/Max consecutive working days\n+    // These Min/Max constraints are implemented as two constraints for consistency with DRL\n+    Constraint consecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract, shiftList) -> contract.isViolated(shiftList.getLength()))\n+                                .penalize(\"consecutiveWorkingDays\", HardSoftScore.ONE_SOFT,\n+                                        (employee, contract, shiftList) -> contract.getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Min/Max consecutive free days\n+    Constraint consecutiveFreeDays(ConstraintFactory constraintFactory) {\n+        return getBreaks(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract, breakInfo) -> contract.isViolated(breakInfo.getLength() - 1))\n+                                .penalize(\"consecutiveFreeDays\", HardSoftScore.ONE_SOFT,\n+                                        (employee, contract, breakInfo) -> contract\n+                                                .getViolationAmount(breakInfo.getLength() - 1));\n+    }\n+\n+    Constraint maximumConsecutiveFreeDaysNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .join(NurseRosterParametrization.class, Joiners.lessThan((contract, employee) -> contract.getMaximumValue(),\n+                        nrp -> nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1))\n+                .penalize(\"maximumConsecutiveFreeDays (no shifts)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee, nrp) -> contract\n+                                .getViolationAmount(nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1));\n+    }\n+\n+    Constraint consecutiveFreeDaysFirstBreak(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shiftAssignment) -> contract,\n+                        (contract, shiftAssignment) -> shiftAssignment.getEmployee(),\n+                        ConstraintCollectors.<MinMaxContractLine, ShiftAssignment, ShiftAssignment> min(\n+                                (contract, shiftAssignment) -> shiftAssignment))\n+                .join(NurseRosterParametrization.class)\n+                .filter((contract, employee, shiftAssignment,\n+                        nrp) -> nrp.getFirstShiftDate() != shiftAssignment.getShiftDate() && contract\n+                                .isViolated(shiftAssignment.getShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex()))\n+                .penalize(\"consecutiveFreeDays (first break)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contractLine, employee, shiftAssignment, nrp) -> contractLine\n+                                .getViolationAmount(shiftAssignment.getShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex()));\n+    }\n+\n+    Constraint consecutiveFreeDaysFinalBreak(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shiftAssignment) -> contract,\n+                        (contract, shiftAssignment) -> shiftAssignment.getEmployee(),\n+                        ConstraintCollectors.<MinMaxContractLine, ShiftAssignment, ShiftAssignment> max(\n+                                (contract, shiftAssignment) -> shiftAssignment))\n+                .join(NurseRosterParametrization.class)\n+                .filter((contractLine, employee, shiftAssignment,\n+                        nrp) -> nrp.getLastShiftDate() != shiftAssignment.getShiftDate() &&\n+                                contractLine\n+                                        .isViolated(nrp.getLastShiftDateDayIndex() - shiftAssignment.getShiftDateDayIndex()))\n+                .penalize(\"consecutiveFreeDays (final break)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contractLine, employee, shiftAssignment, nrp) -> contractLine\n+                                .getViolationAmount(nrp.getLastShiftDateDayIndex() - shiftAssignment.getShiftDateDayIndex()));\n+    }\n+\n+    // Min/Max consecutive working weekends\n+    Constraint consecutiveWorkingWeekends(ConstraintFactory constraintFactory) {\n+        return getConsecutiveWorkingWeekends(constraintFactory,\n+                constraintFactory.from(MinMaxContractLine.class)\n+                        .filter(minMaxContractLine -> minMaxContractLine\n+                                .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_WEEKENDS &&\n+                                minMaxContractLine.isEnabled()))\n+                                        .filter((employee, contract, shiftList) -> contract.isViolated(shiftList.getLength()))\n+                                        .penalize(\"consecutiveWorkingWeekends\", HardSoftScore.ONE_SOFT,", "originalCommit": "57394f70d678c2cdc90f852b229de6749866c003", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTEzNTkzNw==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r639135937", "bodyText": "Formatting.", "author": "triceo", "createdAt": "2021-05-25T19:48:53Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.tri.TriConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.util.Break;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.common.ExperimentalConstraintCollectors;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.NurseRosterParametrization;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.ShiftDate;\n+import org.optaplanner.examples.nurserostering.domain.ShiftTypeSkillRequirement;\n+import org.optaplanner.examples.nurserostering.domain.SkillProficiency;\n+import org.optaplanner.examples.nurserostering.domain.contract.BooleanContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.PatternContractLine;\n+import org.optaplanner.examples.nurserostering.domain.pattern.FreeBefore2DaysWithAWorkDayPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType2DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType3DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOnRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOnRequest;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentEnd;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentStart;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public <C extends ContractLine> TriConstraintStream<Employee, C, Sequence<ShiftDate>>\n+            getConsecutiveShifts(UniConstraintStream<C> constraintStream) {\n+        return constraintStream\n+                .join(ShiftAssignment.class, Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shift) -> shift.getEmployee(), (contract, shift) -> contract,\n+                        ExperimentalConstraintCollectors.consecutive((contract, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    public TriConstraintStream<Employee, MinMaxContractLine, Break<ShiftDate, Integer>>\n+            getBreaks(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream\n+                .join(ShiftAssignment.class, Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shift) -> shift.getEmployee(), (contract, shift) -> contract,\n+                        ExperimentalConstraintCollectors.consecutive((contract, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getBreaks);\n+    }\n+\n+    public TriConstraintStream<Employee, MinMaxContractLine, Sequence<ShiftDate>>\n+            getConsecutiveWorkingWeekends(ConstraintFactory constraintFactory,\n+                    UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(constraintFactory.from(ShiftAssignment.class).filter(ShiftAssignment::isWeekend),\n+                Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shift) -> shift.getEmployee(), (contract, shift) -> contract,\n+                        ExperimentalConstraintCollectors.consecutive((contract, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getWeekendSundayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                oneShiftPerDay(constraintFactory),\n+                minimumAndMaximumNumberOfAssignments(constraintFactory),\n+                minimumNumberOfAssignmentsNoAssignments(constraintFactory),\n+                consecutiveWorkingDays(constraintFactory),\n+                consecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDaysNoAssignments(constraintFactory),\n+                consecutiveFreeDaysFirstBreak(constraintFactory),\n+                consecutiveFreeDaysFinalBreak(constraintFactory),\n+                consecutiveWorkingWeekends(constraintFactory),\n+                startOnNotFirstDayOfWeekend(constraintFactory),\n+                endOnNotLastDayOfWeekend(constraintFactory),\n+                identicalShiftTypesDuringWeekend(constraintFactory),\n+                dayOffRequest(constraintFactory),\n+                dayOnRequest(constraintFactory),\n+                shiftOffRequest(constraintFactory),\n+                shiftOnRequest(constraintFactory),\n+                alternativeSkill(constraintFactory),\n+                unwantedPatternFreeBefore2DaysWithAWorkDayPattern(constraintFactory),\n+                unwantedPatternShiftType2DaysPattern(constraintFactory),\n+                unwantedPatternShiftType3DaysPattern(constraintFactory),\n+        };\n+    }\n+\n+    // ############################################################################\n+    // Hard constraints\n+    // ############################################################################\n+\n+    // A nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day.\n+    Constraint oneShiftPerDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory\n+                .fromUniquePair(ShiftAssignment.class,\n+                        Joiners.equal(ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftAssignment::getShiftDate))\n+                .penalize(\"oneShiftPerDay\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    // ############################################################################\n+    // Soft constraints\n+    // ############################################################################\n+    Constraint minimumAndMaximumNumberOfAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(ShiftAssignment.class, Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((line, shift) -> shift.getEmployee(), (line, shift) -> line, ConstraintCollectors.countBi())\n+                .filter((employee, contract, shiftCount) -> employee != null && contract.isViolated(shiftCount))\n+                .penalize(\"Minimum and maximum number of assignments\", HardSoftScore.ONE_SOFT,\n+                        (employee, contract, shiftCount) -> contract.getViolationAmount(shiftCount));\n+    }\n+\n+    Constraint minimumNumberOfAssignmentsNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .filter((contract, employee) -> contract.isViolated(0))\n+                .penalize(\"Minimum and maximum number of assignments (no assignments)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee) -> contract.getViolationAmount(0));\n+    }\n+\n+    // Min/Max consecutive working days\n+    // These Min/Max constraints are implemented as two constraints for consistency with DRL\n+    Constraint consecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract, shiftList) -> contract.isViolated(shiftList.getLength()))\n+                                .penalize(\"consecutiveWorkingDays\", HardSoftScore.ONE_SOFT,\n+                                        (employee, contract, shiftList) -> contract.getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Min/Max consecutive free days\n+    Constraint consecutiveFreeDays(ConstraintFactory constraintFactory) {\n+        return getBreaks(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract, breakInfo) -> contract.isViolated(breakInfo.getLength() - 1))\n+                                .penalize(\"consecutiveFreeDays\", HardSoftScore.ONE_SOFT,\n+                                        (employee, contract, breakInfo) -> contract\n+                                                .getViolationAmount(breakInfo.getLength() - 1));\n+    }\n+\n+    Constraint maximumConsecutiveFreeDaysNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .join(NurseRosterParametrization.class, Joiners.lessThan((contract, employee) -> contract.getMaximumValue(),\n+                        nrp -> nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1))\n+                .penalize(\"maximumConsecutiveFreeDays (no shifts)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee, nrp) -> contract\n+                                .getViolationAmount(nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1));\n+    }\n+\n+    Constraint consecutiveFreeDaysFirstBreak(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shiftAssignment) -> contract,\n+                        (contract, shiftAssignment) -> shiftAssignment.getEmployee(),\n+                        ConstraintCollectors.<MinMaxContractLine, ShiftAssignment, ShiftAssignment> min(\n+                                (contract, shiftAssignment) -> shiftAssignment))\n+                .join(NurseRosterParametrization.class)\n+                .filter((contract, employee, shiftAssignment,\n+                        nrp) -> nrp.getFirstShiftDate() != shiftAssignment.getShiftDate() && contract\n+                                .isViolated(shiftAssignment.getShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex()))\n+                .penalize(\"consecutiveFreeDays (first break)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contractLine, employee, shiftAssignment, nrp) -> contractLine\n+                                .getViolationAmount(shiftAssignment.getShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex()));\n+    }\n+\n+    Constraint consecutiveFreeDaysFinalBreak(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shiftAssignment) -> contract,\n+                        (contract, shiftAssignment) -> shiftAssignment.getEmployee(),\n+                        ConstraintCollectors.<MinMaxContractLine, ShiftAssignment, ShiftAssignment> max(\n+                                (contract, shiftAssignment) -> shiftAssignment))\n+                .join(NurseRosterParametrization.class)\n+                .filter((contractLine, employee, shiftAssignment,\n+                        nrp) -> nrp.getLastShiftDate() != shiftAssignment.getShiftDate() &&\n+                                contractLine\n+                                        .isViolated(nrp.getLastShiftDateDayIndex() - shiftAssignment.getShiftDateDayIndex()))\n+                .penalize(\"consecutiveFreeDays (final break)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contractLine, employee, shiftAssignment, nrp) -> contractLine\n+                                .getViolationAmount(nrp.getLastShiftDateDayIndex() - shiftAssignment.getShiftDateDayIndex()));\n+    }\n+\n+    // Min/Max consecutive working weekends\n+    Constraint consecutiveWorkingWeekends(ConstraintFactory constraintFactory) {\n+        return getConsecutiveWorkingWeekends(constraintFactory,\n+                constraintFactory.from(MinMaxContractLine.class)\n+                        .filter(minMaxContractLine -> minMaxContractLine\n+                                .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_WEEKENDS &&\n+                                minMaxContractLine.isEnabled()))\n+                                        .filter((employee, contract, shiftList) -> contract.isViolated(shiftList.getLength()))\n+                                        .penalize(\"consecutiveWorkingWeekends\", HardSoftScore.ONE_SOFT,\n+                                                (employee, contract, shiftList) -> contract\n+                                                        .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Complete Weekends\n+    Constraint startOnNotFirstDayOfWeekend(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(BooleanContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.COMPLETE_WEEKENDS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract, shiftList) -> new EmployeeConsecutiveAssignmentStart(\n+                                        employee, shiftList.getItems().first())\n+                                                .isWeekendAndNotFirstDayOfWeekend())\n+                                .penalize(\"startOnNotFirstDayOfWeekend\", HardSoftScore.ONE_SOFT,", "originalCommit": "57394f70d678c2cdc90f852b229de6749866c003", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYzOTEzNjA5MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/1022#discussion_r639136091", "bodyText": "Formatting.", "author": "triceo", "createdAt": "2021-05-25T19:49:07Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/nurserostering/optional/score/NurseRosteringConstraintProvider.java", "diffHunk": "@@ -0,0 +1,416 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.nurserostering.optional.score;\n+\n+import java.time.DayOfWeek;\n+\n+import org.apache.commons.lang3.tuple.ImmutablePair;\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.core.api.score.stream.Joiners;\n+import org.optaplanner.core.api.score.stream.tri.TriConstraintStream;\n+import org.optaplanner.core.api.score.stream.uni.UniConstraintStream;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.util.Break;\n+import org.optaplanner.core.impl.util.ConsecutiveData;\n+import org.optaplanner.core.impl.util.Sequence;\n+import org.optaplanner.examples.common.ExperimentalConstraintCollectors;\n+import org.optaplanner.examples.nurserostering.domain.Employee;\n+import org.optaplanner.examples.nurserostering.domain.NurseRosterParametrization;\n+import org.optaplanner.examples.nurserostering.domain.ShiftAssignment;\n+import org.optaplanner.examples.nurserostering.domain.ShiftDate;\n+import org.optaplanner.examples.nurserostering.domain.ShiftTypeSkillRequirement;\n+import org.optaplanner.examples.nurserostering.domain.SkillProficiency;\n+import org.optaplanner.examples.nurserostering.domain.contract.BooleanContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.ContractLineType;\n+import org.optaplanner.examples.nurserostering.domain.contract.MinMaxContractLine;\n+import org.optaplanner.examples.nurserostering.domain.contract.PatternContractLine;\n+import org.optaplanner.examples.nurserostering.domain.pattern.FreeBefore2DaysWithAWorkDayPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType2DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.pattern.ShiftType3DaysPattern;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.DayOnRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOffRequest;\n+import org.optaplanner.examples.nurserostering.domain.request.ShiftOnRequest;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentEnd;\n+import org.optaplanner.examples.nurserostering.score.drools.EmployeeConsecutiveAssignmentStart;\n+\n+public class NurseRosteringConstraintProvider implements ConstraintProvider {\n+\n+    public <C extends ContractLine> TriConstraintStream<Employee, C, Sequence<ShiftDate>>\n+            getConsecutiveShifts(UniConstraintStream<C> constraintStream) {\n+        return constraintStream\n+                .join(ShiftAssignment.class, Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shift) -> shift.getEmployee(), (contract, shift) -> contract,\n+                        ExperimentalConstraintCollectors.consecutive((contract, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    public TriConstraintStream<Employee, MinMaxContractLine, Break<ShiftDate, Integer>>\n+            getBreaks(UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream\n+                .join(ShiftAssignment.class, Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shift) -> shift.getEmployee(), (contract, shift) -> contract,\n+                        ExperimentalConstraintCollectors.consecutive((contract, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getDayIndex))\n+                .flattenLast(ConsecutiveData::getBreaks);\n+    }\n+\n+    public TriConstraintStream<Employee, MinMaxContractLine, Sequence<ShiftDate>>\n+            getConsecutiveWorkingWeekends(ConstraintFactory constraintFactory,\n+                    UniConstraintStream<MinMaxContractLine> constraintStream) {\n+        return constraintStream.join(constraintFactory.from(ShiftAssignment.class).filter(ShiftAssignment::isWeekend),\n+                Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shift) -> shift.getEmployee(), (contract, shift) -> contract,\n+                        ExperimentalConstraintCollectors.consecutive((contract, shift) -> shift.getShiftDate(),\n+                                ShiftDate::getWeekendSundayIndex))\n+                .flattenLast(ConsecutiveData::getConsecutiveSequences);\n+    }\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                oneShiftPerDay(constraintFactory),\n+                minimumAndMaximumNumberOfAssignments(constraintFactory),\n+                minimumNumberOfAssignmentsNoAssignments(constraintFactory),\n+                consecutiveWorkingDays(constraintFactory),\n+                consecutiveFreeDays(constraintFactory),\n+                maximumConsecutiveFreeDaysNoAssignments(constraintFactory),\n+                consecutiveFreeDaysFirstBreak(constraintFactory),\n+                consecutiveFreeDaysFinalBreak(constraintFactory),\n+                consecutiveWorkingWeekends(constraintFactory),\n+                startOnNotFirstDayOfWeekend(constraintFactory),\n+                endOnNotLastDayOfWeekend(constraintFactory),\n+                identicalShiftTypesDuringWeekend(constraintFactory),\n+                dayOffRequest(constraintFactory),\n+                dayOnRequest(constraintFactory),\n+                shiftOffRequest(constraintFactory),\n+                shiftOnRequest(constraintFactory),\n+                alternativeSkill(constraintFactory),\n+                unwantedPatternFreeBefore2DaysWithAWorkDayPattern(constraintFactory),\n+                unwantedPatternShiftType2DaysPattern(constraintFactory),\n+                unwantedPatternShiftType3DaysPattern(constraintFactory),\n+        };\n+    }\n+\n+    // ############################################################################\n+    // Hard constraints\n+    // ############################################################################\n+\n+    // A nurse can only work one shift per day, i.e. no two shift can be assigned to the same nurse on a day.\n+    Constraint oneShiftPerDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory\n+                .fromUniquePair(ShiftAssignment.class,\n+                        Joiners.equal(ShiftAssignment::getEmployee),\n+                        Joiners.equal(ShiftAssignment::getShiftDate))\n+                .penalize(\"oneShiftPerDay\", HardSoftScore.ONE_HARD);\n+    }\n+\n+    // ############################################################################\n+    // Soft constraints\n+    // ############################################################################\n+    Constraint minimumAndMaximumNumberOfAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(ShiftAssignment.class, Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((line, shift) -> shift.getEmployee(), (line, shift) -> line, ConstraintCollectors.countBi())\n+                .filter((employee, contract, shiftCount) -> employee != null && contract.isViolated(shiftCount))\n+                .penalize(\"Minimum and maximum number of assignments\", HardSoftScore.ONE_SOFT,\n+                        (employee, contract, shiftCount) -> contract.getViolationAmount(shiftCount));\n+    }\n+\n+    Constraint minimumNumberOfAssignmentsNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine.getContractLineType() == ContractLineType.TOTAL_ASSIGNMENTS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(Employee.class,\n+                        Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contractLine, employee) -> employee, ShiftAssignment::getEmployee))\n+                .filter((contract, employee) -> contract.isViolated(0))\n+                .penalize(\"Minimum and maximum number of assignments (no assignments)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee) -> contract.getViolationAmount(0));\n+    }\n+\n+    // Min/Max consecutive working days\n+    // These Min/Max constraints are implemented as two constraints for consistency with DRL\n+    Constraint consecutiveWorkingDays(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_DAYS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract, shiftList) -> contract.isViolated(shiftList.getLength()))\n+                                .penalize(\"consecutiveWorkingDays\", HardSoftScore.ONE_SOFT,\n+                                        (employee, contract, shiftList) -> contract.getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Min/Max consecutive free days\n+    Constraint consecutiveFreeDays(ConstraintFactory constraintFactory) {\n+        return getBreaks(constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract, breakInfo) -> contract.isViolated(breakInfo.getLength() - 1))\n+                                .penalize(\"consecutiveFreeDays\", HardSoftScore.ONE_SOFT,\n+                                        (employee, contract, breakInfo) -> contract\n+                                                .getViolationAmount(breakInfo.getLength() - 1));\n+    }\n+\n+    Constraint maximumConsecutiveFreeDaysNoAssignments(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isMaximumEnabled())\n+                .join(Employee.class, Joiners.equal(MinMaxContractLine::getContract, Employee::getContract))\n+                .ifNotExists(ShiftAssignment.class,\n+                        Joiners.equal((contract, employee) -> employee, ShiftAssignment::getEmployee))\n+                .join(NurseRosterParametrization.class, Joiners.lessThan((contract, employee) -> contract.getMaximumValue(),\n+                        nrp -> nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1))\n+                .penalize(\"maximumConsecutiveFreeDays (no shifts)\", HardSoftScore.ONE_SOFT,\n+                        (contract, employee, nrp) -> contract\n+                                .getViolationAmount(nrp.getLastShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex() + 1));\n+    }\n+\n+    Constraint consecutiveFreeDaysFirstBreak(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shiftAssignment) -> contract,\n+                        (contract, shiftAssignment) -> shiftAssignment.getEmployee(),\n+                        ConstraintCollectors.<MinMaxContractLine, ShiftAssignment, ShiftAssignment> min(\n+                                (contract, shiftAssignment) -> shiftAssignment))\n+                .join(NurseRosterParametrization.class)\n+                .filter((contract, employee, shiftAssignment,\n+                        nrp) -> nrp.getFirstShiftDate() != shiftAssignment.getShiftDate() && contract\n+                                .isViolated(shiftAssignment.getShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex()))\n+                .penalize(\"consecutiveFreeDays (first break)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contractLine, employee, shiftAssignment, nrp) -> contractLine\n+                                .getViolationAmount(shiftAssignment.getShiftDateDayIndex() - nrp.getFirstShiftDateDayIndex()));\n+    }\n+\n+    Constraint consecutiveFreeDaysFinalBreak(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(MinMaxContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.CONSECUTIVE_FREE_DAYS &&\n+                        minMaxContractLine.isEnabled())\n+                .join(ShiftAssignment.class,\n+                        Joiners.equal(ContractLine::getContract, ShiftAssignment::getContract))\n+                .groupBy((contract, shiftAssignment) -> contract,\n+                        (contract, shiftAssignment) -> shiftAssignment.getEmployee(),\n+                        ConstraintCollectors.<MinMaxContractLine, ShiftAssignment, ShiftAssignment> max(\n+                                (contract, shiftAssignment) -> shiftAssignment))\n+                .join(NurseRosterParametrization.class)\n+                .filter((contractLine, employee, shiftAssignment,\n+                        nrp) -> nrp.getLastShiftDate() != shiftAssignment.getShiftDate() &&\n+                                contractLine\n+                                        .isViolated(nrp.getLastShiftDateDayIndex() - shiftAssignment.getShiftDateDayIndex()))\n+                .penalize(\"consecutiveFreeDays (final break)\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (contractLine, employee, shiftAssignment, nrp) -> contractLine\n+                                .getViolationAmount(nrp.getLastShiftDateDayIndex() - shiftAssignment.getShiftDateDayIndex()));\n+    }\n+\n+    // Min/Max consecutive working weekends\n+    Constraint consecutiveWorkingWeekends(ConstraintFactory constraintFactory) {\n+        return getConsecutiveWorkingWeekends(constraintFactory,\n+                constraintFactory.from(MinMaxContractLine.class)\n+                        .filter(minMaxContractLine -> minMaxContractLine\n+                                .getContractLineType() == ContractLineType.CONSECUTIVE_WORKING_WEEKENDS &&\n+                                minMaxContractLine.isEnabled()))\n+                                        .filter((employee, contract, shiftList) -> contract.isViolated(shiftList.getLength()))\n+                                        .penalize(\"consecutiveWorkingWeekends\", HardSoftScore.ONE_SOFT,\n+                                                (employee, contract, shiftList) -> contract\n+                                                        .getViolationAmount(shiftList.getLength()));\n+    }\n+\n+    // Complete Weekends\n+    Constraint startOnNotFirstDayOfWeekend(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(BooleanContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.COMPLETE_WEEKENDS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract, shiftList) -> new EmployeeConsecutiveAssignmentStart(\n+                                        employee, shiftList.getItems().first())\n+                                                .isWeekendAndNotFirstDayOfWeekend())\n+                                .penalize(\"startOnNotFirstDayOfWeekend\", HardSoftScore.ONE_SOFT,\n+                                        (employee, contract, shiftList) -> new EmployeeConsecutiveAssignmentStart(employee,\n+                                                shiftList.getItems().first()).getDistanceToFirstDayOfWeekend()\n+                                                * contract.getWeight());\n+    }\n+\n+    Constraint endOnNotLastDayOfWeekend(ConstraintFactory constraintFactory) {\n+        return getConsecutiveShifts(constraintFactory.from(BooleanContractLine.class)\n+                .filter(minMaxContractLine -> minMaxContractLine\n+                        .getContractLineType() == ContractLineType.COMPLETE_WEEKENDS &&\n+                        minMaxContractLine.isEnabled()))\n+                                .filter((employee, contract,\n+                                        shiftList) -> new EmployeeConsecutiveAssignmentEnd(employee,\n+                                                shiftList.getItems().last())\n+                                                        .isWeekendAndNotLastDayOfWeekend())\n+                                .penalize(\"endOnNotLastDayOfWeekend\", HardSoftScore.ONE_SOFT,", "originalCommit": "57394f70d678c2cdc90f852b229de6749866c003", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "93eee28b3b818e586a49883af16efff58a99cc90", "url": "https://github.com/kiegroup/optaplanner/commit/93eee28b3b818e586a49883af16efff58a99cc90", "message": "Add a consecutive/sequence constraint collector", "committedDate": "2021-05-27T14:56:48Z", "type": "commit"}, {"oid": "68c24625318dd77ffd6d8f0294544619f8e64141", "url": "https://github.com/kiegroup/optaplanner/commit/68c24625318dd77ffd6d8f0294544619f8e64141", "message": "Made ConsecutiveSetTree accept non-integral index types,\nUpdate API of ConsecutiveData, Start Work on\nNurse Rostering ConstraintProvider", "committedDate": "2021-05-27T14:56:48Z", "type": "commit"}, {"oid": "da9c82bad540d940445e5c2fc90b841541123326", "url": "https://github.com/kiegroup/optaplanner/commit/da9c82bad540d940445e5c2fc90b841541123326", "message": "Add interval version of the consecutive collector", "committedDate": "2021-05-27T14:56:48Z", "type": "commit"}, {"oid": "df8032c3cea7b028b4c0384eb997cea081dab1af", "url": "https://github.com/kiegroup/optaplanner/commit/df8032c3cea7b028b4c0384eb997cea081dab1af", "message": "Formatting", "committedDate": "2021-05-27T14:56:48Z", "type": "commit"}, {"oid": "72b7f075a055ce9e4f221b55c1b5be5492fb98dc", "url": "https://github.com/kiegroup/optaplanner/commit/72b7f075a055ce9e4f221b55c1b5be5492fb98dc", "message": "Add fuzzy test for IntervalTree", "committedDate": "2021-05-27T14:56:48Z", "type": "commit"}, {"oid": "b0b7fb26c26c40c511259d5f46b0d03b0a5486f3", "url": "https://github.com/kiegroup/optaplanner/commit/b0b7fb26c26c40c511259d5f46b0d03b0a5486f3", "message": "Add the rest of the nurse rostering constraints to the ConstraintProvider", "committedDate": "2021-05-27T14:56:48Z", "type": "commit"}, {"oid": "68fd0806a7da0ac91784247533cd0432fe069675", "url": "https://github.com/kiegroup/optaplanner/commit/68fd0806a7da0ac91784247533cd0432fe069675", "message": "Add Break class, fix Nurse Rostering Constraint Provider", "committedDate": "2021-05-27T14:56:48Z", "type": "commit"}, {"oid": "2bf2c190774cd52962b440b5350a4a78f2dfd693", "url": "https://github.com/kiegroup/optaplanner/commit/2bf2c190774cd52962b440b5350a4a78f2dfd693", "message": "Update ConsecutiveSetTreeTest to use new Break API", "committedDate": "2021-05-27T14:56:48Z", "type": "commit"}, {"oid": "24820b21bb216cb29dd47badf613b35dcb7dd16e", "url": "https://github.com/kiegroup/optaplanner/commit/24820b21bb216cb29dd47badf613b35dcb7dd16e", "message": "Fix Nurse Rostering Constraint Provider", "committedDate": "2021-05-27T14:56:48Z", "type": "commit"}, {"oid": "bfdbbf14bb2e916307fa3a6a5ebcc48d98a6684c", "url": "https://github.com/kiegroup/optaplanner/commit/bfdbbf14bb2e916307fa3a6a5ebcc48d98a6684c", "message": "Rename type variables", "committedDate": "2021-05-27T14:56:49Z", "type": "commit"}, {"oid": "797788263609859ef21ebed9eff9d8a46f4d15a9", "url": "https://github.com/kiegroup/optaplanner/commit/797788263609859ef21ebed9eff9d8a46f4d15a9", "message": "Remove unused methods, made breaks incremental in ConsecutiveSetTree", "committedDate": "2021-05-27T14:56:49Z", "type": "commit"}, {"oid": "3554b6ffd491ba4296352d5deb3a9ae3d35fcaa4", "url": "https://github.com/kiegroup/optaplanner/commit/3554b6ffd491ba4296352d5deb3a9ae3d35fcaa4", "message": "Improvements to Nurse Rostering Constraint Provider", "committedDate": "2021-05-27T14:56:49Z", "type": "commit"}, {"oid": "ff4c982ccec85861b1d9ba9fa0a952a7798b6cf7", "url": "https://github.com/kiegroup/optaplanner/commit/ff4c982ccec85861b1d9ba9fa0a952a7798b6cf7", "message": "Inline methods, reduce cardinality of pattern constraints", "committedDate": "2021-05-27T14:56:49Z", "type": "commit"}, {"oid": "ff4c982ccec85861b1d9ba9fa0a952a7798b6cf7", "url": "https://github.com/kiegroup/optaplanner/commit/ff4c982ccec85861b1d9ba9fa0a952a7798b6cf7", "message": "Inline methods, reduce cardinality of pattern constraints", "committedDate": "2021-05-27T14:56:49Z", "type": "forcePushed"}, {"oid": "81ae5d9aa4e2066278a8022c6e30d76bcd45f2fb", "url": "https://github.com/kiegroup/optaplanner/commit/81ae5d9aa4e2066278a8022c6e30d76bcd45f2fb", "message": "Add ConstraintProvider test for Nurse Rostering", "committedDate": "2021-05-31T17:16:08Z", "type": "commit"}, {"oid": "27fc062daa5a3ea439a734e0bd97f0dd40bba9f2", "url": "https://github.com/kiegroup/optaplanner/commit/27fc062daa5a3ea439a734e0bd97f0dd40bba9f2", "message": "Remove hashCode and equals from consecutive classes", "committedDate": "2021-05-31T18:04:37Z", "type": "commit"}, {"oid": "a44d2df634710eb99df6e08ba39f84e9fa02728d", "url": "https://github.com/kiegroup/optaplanner/commit/a44d2df634710eb99df6e08ba39f84e9fa02728d", "message": "Move consecutive data structures to examples, fix some code smells", "committedDate": "2021-05-31T20:17:53Z", "type": "commit"}]}