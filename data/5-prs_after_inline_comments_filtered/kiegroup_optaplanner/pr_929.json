{"pr_number": 929, "pr_title": "PLANNER-2143 Validate config XML with a namespace", "pr_createdAt": "2020-09-16T17:01:16Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/929", "timeline": [{"oid": "48c1e3dc683fc6c08b6ea43b6a734751ad3a6d7f", "url": "https://github.com/kiegroup/optaplanner/commit/48c1e3dc683fc6c08b6ea43b6a734751ad3a6d7f", "message": "PLANNER-2143 Validate config XML with a namespace", "committedDate": "2020-09-16T16:59:23Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1MDA2Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/929#discussion_r489750066", "bodyText": "Both changes in this file appear unnecessary.", "author": "triceo", "createdAt": "2020-09-16T20:58:10Z", "path": "optaplanner-benchmark/src/main/java/org/optaplanner/benchmark/config/PlannerBenchmarkConfig.java", "diffHunk": "@@ -158,8 +158,8 @@ public static PlannerBenchmarkConfig createFromXmlResource(String benchmarkConfi\n             }\n             return createFromXmlInputStream(in, classLoader);\n         } catch (OptaPlannerXmlSerializationException e) {\n-            throw new IllegalArgumentException(\"Unmarshalling of benchmarkConfigResource (\" + benchmarkConfigResource\n-                    + \") fails.\", e);\n+            throw new IllegalArgumentException(", "originalCommit": "48c1e3dc683fc6c08b6ea43b6a734751ad3a6d7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA3MjE4OA==", "url": "https://github.com/kiegroup/optaplanner/pull/929#discussion_r490072188", "bodyText": "Thanks, however, I am keeping the second formatting change as now it fits a single line.", "author": "rsynek", "createdAt": "2020-09-17T08:40:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1MDA2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1MjE5OA==", "url": "https://github.com/kiegroup/optaplanner/pull/929#discussion_r489752198", "bodyText": "Shouldn't the reader be in try (...) ?", "author": "triceo", "createdAt": "2020-09-16T21:02:26Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/io/jaxb/GenericJaxbIO.java", "diffHunk": "@@ -129,119 +155,141 @@ public T readAndValidate(Reader reader, Schema schema) {\n         try {\n             unmarshaller.setEventHandler(validationEventCollector);\n         } catch (JAXBException jaxbException) {\n-            String errMessage = String.format(\"Failed to set a validation event handler to the unmarshaller for \"\n-                    + \"a root element class (%s).\", rootClass.getName());\n-            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+            String errorMessage = String.format(\"Failed to set a validation event handler to the %s for \"\n+                    + \"a root element class (%s).\", Unmarshaller.class.getSimpleName(), rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errorMessage, jaxbException);\n         }\n \n         try {\n-            return (T) unmarshaller.unmarshal(nonNullReader);\n+            return (T) unmarshaller.unmarshal(nonNullDocument);\n         } catch (JAXBException jaxbException) {\n             if (validationEventCollector.hasEvents()) {\n-                String errMessage =\n+                String errorMessage =\n                         String.format(\"XML validation failed for a root element class (%s).\", rootClass.getName());\n                 String validationErrors = Stream.of(validationEventCollector.getEvents())\n                         .map(ValidationEvent::getMessage)\n                         .collect(Collectors.joining(\"\\n\"));\n-                String errMessageWithValidationEvents = errMessage + \"\\n\" + validationErrors;\n-                throw new OptaPlannerXmlSerializationException(errMessageWithValidationEvents, jaxbException);\n+                String errorMessageWithValidationEvents = errorMessage + \"\\n\" + validationErrors;\n+                throw new OptaPlannerXmlSerializationException(errorMessageWithValidationEvents, jaxbException);\n             } else {\n-                String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n-                throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+                String errorMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+                throw new OptaPlannerXmlSerializationException(errorMessage, jaxbException);\n             }\n         }\n     }\n \n-    private Unmarshaller createUnmarshaller() {\n-        try {\n-            return jaxbContext.createUnmarshaller();\n-        } catch (JAXBException e) {\n-            String errMessage = String.format(\"Failed to create JAXB unmarshaller for a root element class (%s).\",\n-                    rootClass.getName());\n-            throw new OptaPlannerXmlSerializationException(errMessage, e);\n-        }\n-    }\n-\n     /**\n      * Reads the input XML using the {@link Reader} overriding elements namespaces. If an element already has a namespace and\n      * a {@link ElementNamespaceOverride} is defined for this element, its namespace is overridden. In case the element has no\n      * namespace, new namespace defined in the {@link ElementNamespaceOverride} is added.\n-     * \n+     *\n      * @param reader input XML {@link Reader}; never null\n      * @param elementNamespaceOverrides never null\n      * @return deserialized object representation of the XML.\n      */\n     public T readOverridingNamespace(Reader reader, ElementNamespaceOverride... elementNamespaceOverrides) {\n         Objects.requireNonNull(reader);\n         Objects.requireNonNull(elementNamespaceOverrides);\n+        return readOverridingNamespace(parseXml(reader), elementNamespaceOverrides);\n+    }\n \n-        // Create a SAXParser to use its XMLReader on the XMLFilter\n-        SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n-        SAXParser saxParser;\n+    /**\n+     * Reads the input XML {@link Document} overriding namespaces. If an element already has a namespace and\n+     * a {@link ElementNamespaceOverride} is defined for this element, its namespace is overridden. In case the element has no\n+     * namespace a new namespace defined in the {@link ElementNamespaceOverride} is added.\n+     *\n+     * @param document input XML {@link Document}; never null\n+     * @param elementNamespaceOverrides never null\n+     * @return deserialized object representation of the XML.\n+     */\n+    public T readOverridingNamespace(Document document, ElementNamespaceOverride... elementNamespaceOverrides) {\n+        Document translatedDocument =\n+                overrideNamespaces(Objects.requireNonNull(document), Objects.requireNonNull(elementNamespaceOverrides));\n         try {\n-            // Protect the parser against the XXE attack\n-            // https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A4-XML_External_Entities_(XXE)\n-            saxParserFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n-            saxParser = saxParserFactory.newSAXParser();\n-        } catch (ParserConfigurationException | SAXException e) {\n-            final String errMessage = String.format(ERR_MSG_READ_OVERRIDE_NAMESPACE, rootClass.getName(),\n+            return (T) createUnmarshaller().unmarshal(translatedDocument);\n+        } catch (JAXBException e) {\n+            final String errorMessage = String.format(ERR_MSG_READ_OVERRIDE_NAMESPACE, rootClass.getName(),\n                     Arrays.toString(elementNamespaceOverrides));\n-            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+            throw new OptaPlannerXmlSerializationException(errorMessage, e);\n         }\n-        XMLReader xmlReader;\n+    }\n+\n+    public Document parseXml(Reader reader) {\n+        Reader nonNullReader = Objects.requireNonNull(reader);\n+        DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();\n+        documentBuilderFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, \"\");\n+        documentBuilderFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, \"\");\n+        documentBuilderFactory.setNamespaceAware(true);\n+        DocumentBuilder builder;\n         try {\n-            xmlReader = saxParser.getXMLReader();\n-        } catch (SAXException e) {\n-            final String errMessage = String.format(ERR_MSG_READ_OVERRIDE_NAMESPACE, rootClass.getName(),\n-                    Arrays.toString(elementNamespaceOverrides));\n-            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+            builder = documentBuilderFactory.newDocumentBuilder();\n+        } catch (ParserConfigurationException e) {\n+            String errorMessage = String.format(\"Failed to create a %s instance to parse an XML for a root class (%s).\",\n+                    DocumentBuilder.class.getSimpleName(), rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errorMessage, e);\n         }\n \n-        XMLFilter namespaceOverridingXmlFilter = new NamespaceOverridingXmlFilter(xmlReader, elementNamespaceOverrides);\n-        namespaceOverridingXmlFilter.setParent(xmlReader);\n-\n-        // Use UnmarshallerHandler as a content handler for the XML filter.\n-        Unmarshaller unmarshaller = createUnmarshaller();\n-        UnmarshallerHandler unmarshallerHandler = unmarshaller.getUnmarshallerHandler();\n-        namespaceOverridingXmlFilter.setContentHandler(unmarshallerHandler);\n-\n-        InputSource xmlInputSource = new InputSource(reader);\n         try {\n-            // Parse the XML to feed its content into the UnmarshallerHandler.\n-            namespaceOverridingXmlFilter.parse(xmlInputSource);\n-        } catch (IOException | SAXException e) {\n-            final String errMessage = String.format(ERR_MSG_READ_OVERRIDE_NAMESPACE, rootClass.getName(),\n-                    Arrays.toString(elementNamespaceOverrides));\n-            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+            return builder.parse(new InputSource(nonNullReader));", "originalCommit": "48c1e3dc683fc6c08b6ea43b6a734751ad3a6d7f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA2ODU0NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/929#discussion_r490068545", "bodyText": "Good question. The reader is created outside the method, usually from a stream (which is created inside a try-with-resources).\nBut it doesn't hurt to make sure it's closed even here.", "author": "rsynek", "createdAt": "2020-09-17T08:34:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTc1MjE5OA=="}], "type": "inlineReview"}, {"oid": "91a74ce385034d17e7c053a794fa612924679265", "url": "https://github.com/kiegroup/optaplanner/commit/91a74ce385034d17e7c053a794fa612924679265", "message": "Fix XML comparison tests on Java 8", "committedDate": "2020-09-17T08:15:55Z", "type": "commit"}, {"oid": "e2fa4e7c40e94ee4625b8f67d0edd7ba8cd83c03", "url": "https://github.com/kiegroup/optaplanner/commit/e2fa4e7c40e94ee4625b8f67d0edd7ba8cd83c03", "message": "Address review comments", "committedDate": "2020-09-17T08:40:34Z", "type": "commit"}, {"oid": "af4bdd49fc1f9c15cea3181e9651ff0a1c4453a6", "url": "https://github.com/kiegroup/optaplanner/commit/af4bdd49fc1f9c15cea3181e9651ff0a1c4453a6", "message": "Make test resource encoding uppercase", "committedDate": "2020-09-17T08:58:29Z", "type": "commit"}, {"oid": "fbe9ca43850f0ac923f5335f52f9db93e956a601", "url": "https://github.com/kiegroup/optaplanner/commit/fbe9ca43850f0ac923f5335f52f9db93e956a601", "message": "Fix a test failing on Windows", "committedDate": "2020-09-17T09:21:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDE2OTQ0MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/929#discussion_r490169441", "bodyText": "Nitpick: in other cases in this PR, that errMsg is called errorMessage.\nPersonally, I'd just inline that String every time into the call to the *Exception constructor.", "author": "ge0ffrey", "createdAt": "2020-09-17T11:28:24Z", "path": "optaplanner-benchmark/src/main/java/org/optaplanner/benchmark/impl/io/PlannerBenchmarkConfigIO.java", "diffHunk": "@@ -24,16 +24,36 @@\n import org.optaplanner.core.impl.io.jaxb.ElementNamespaceOverride;\n import org.optaplanner.core.impl.io.jaxb.GenericJaxbIO;\n import org.optaplanner.core.impl.io.jaxb.JaxbIO;\n+import org.w3c.dom.Document;\n \n public class PlannerBenchmarkConfigIO implements JaxbIO<PlannerBenchmarkConfig> {\n \n+    private static final String BENCHMARK_XSD_RESOURCE = \"/benchmark.xsd\";\n     private final GenericJaxbIO<PlannerBenchmarkConfig> genericJaxbIO = new GenericJaxbIO<>(PlannerBenchmarkConfig.class);\n \n     @Override\n     public PlannerBenchmarkConfig read(Reader reader) {\n-        return genericJaxbIO.readOverridingNamespace(reader,\n-                ElementNamespaceOverride.of(PlannerBenchmarkConfig.XML_ELEMENT_NAME, PlannerBenchmarkConfig.XML_NAMESPACE),\n-                ElementNamespaceOverride.of(SolverConfig.XML_ELEMENT_NAME, SolverConfig.XML_NAMESPACE));\n+        Document document = genericJaxbIO.parseXml(reader);\n+        String rootElementNamespace = document.getDocumentElement().getNamespaceURI();\n+        if (PlannerBenchmarkConfig.XML_NAMESPACE.equals(rootElementNamespace)) { // If there is the correct namespace, validate.\n+            genericJaxbIO.validate(document, BENCHMARK_XSD_RESOURCE);\n+            /*\n+             * In JAXB annotations the SolverConfig belongs to a different namespace than the PlannerBenchmarkConfig.\n+             * However, benchmark.xsd merges both namespaces into a single one. As a result, JAXB is incapable of matching\n+             * the solver element in benchmark configuration and thus the solver element's namespace needs to be overridden.\n+             */\n+            return genericJaxbIO.readOverridingNamespace(document,\n+                    ElementNamespaceOverride.of(SolverConfig.XML_ELEMENT_NAME, SolverConfig.XML_NAMESPACE));\n+        } else if (rootElementNamespace == null || rootElementNamespace.isEmpty()) {\n+            // If not, add the missing namespace to maintain backward compatibility.\n+            return genericJaxbIO.readOverridingNamespace(document,\n+                    ElementNamespaceOverride.of(PlannerBenchmarkConfig.XML_ELEMENT_NAME, PlannerBenchmarkConfig.XML_NAMESPACE),\n+                    ElementNamespaceOverride.of(SolverConfig.XML_ELEMENT_NAME, SolverConfig.XML_NAMESPACE));\n+        } else { // If there is an unexpected namespace, fail fast.\n+            String errMsg = String.format(\"The <%s/> element belongs to a different namespace (%s) than expected (%s).\",\n+                    PlannerBenchmarkConfig.XML_ELEMENT_NAME, rootElementNamespace, PlannerBenchmarkConfig.XML_NAMESPACE);\n+            throw new IllegalArgumentException(errMsg);", "originalCommit": "fbe9ca43850f0ac923f5335f52f9db93e956a601", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c471de6714acd12f2253a3c06e5730225ad81efc", "url": "https://github.com/kiegroup/optaplanner/commit/c471de6714acd12f2253a3c06e5730225ad81efc", "message": "Make variable names consistent", "committedDate": "2020-09-17T14:14:41Z", "type": "commit"}, {"oid": "f305b9bbfaac2863771be0dd3fc6f8c5a73e1809", "url": "https://github.com/kiegroup/optaplanner/commit/f305b9bbfaac2863771be0dd3fc6f8c5a73e1809", "message": "Add namespace and XSD reference to configs in documentation", "committedDate": "2020-09-17T15:22:07Z", "type": "commit"}]}