{"pr_number": 928, "pr_title": "Add generic type Score to SolverManager, SE, CMT, CM and Indictment", "pr_createdAt": "2020-09-16T15:29:56Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/928", "timeline": [{"oid": "0e0997e8cff8e5c33731aa6cba13f488e013cbef", "url": "https://github.com/kiegroup/optaplanner/commit/0e0997e8cff8e5c33731aa6cba13f488e013cbef", "message": "PLANNER-2151 Add generic score type to various APIs", "committedDate": "2020-09-14T11:39:05Z", "type": "commit"}, {"oid": "aa95fcfdda31c0ff48e95c233b8cd680cc5a2c0c", "url": "https://github.com/kiegroup/optaplanner/commit/aa95fcfdda31c0ff48e95c233b8cd680cc5a2c0c", "message": "PLANNER-2151 Add generic score type to various APIs", "committedDate": "2020-09-14T12:10:33Z", "type": "commit"}, {"oid": "16472047f635da11fbbba62e3c700d944f99b2df", "url": "https://github.com/kiegroup/optaplanner/commit/16472047f635da11fbbba62e3c700d944f99b2df", "message": "PLANNER-2151 Add generic Score type to ScoreManager, ScoreExplanation, Indictment, ConstraintMatchTotal and ConstraintMatch", "committedDate": "2020-09-16T15:27:48Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY3OTYxMA==", "url": "https://github.com/kiegroup/optaplanner/pull/928#discussion_r489679610", "bodyText": "I'm not exactly sure of what this method does, but shouldn't the first argument rather be Class<? extends AbstractBendableScore<?>>?", "author": "triceo", "createdAt": "2020-09-16T19:04:10Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/AbstractBendableScore.java", "diffHunk": "@@ -28,13 +28,13 @@\n  *\n  * @see BendableScore\n  */\n-public abstract class AbstractBendableScore<S extends Score<S>> extends AbstractScore<S> {\n+public abstract class AbstractBendableScore<Score_ extends AbstractBendableScore<Score_>> extends AbstractScore<Score_> {\n \n     protected static final String HARD_LABEL = \"hard\";\n     protected static final String SOFT_LABEL = \"soft\";\n     protected static final String[] LEVEL_SUFFIXES = new String[] { HARD_LABEL, SOFT_LABEL };\n \n-    protected static String[][] parseBendableScoreTokens(Class<? extends Score> scoreClass, String scoreString) {\n+    protected static String[][] parseBendableScoreTokens(Class<? extends Score<?>> scoreClass, String scoreString) {", "originalCommit": "16472047f635da11fbbba62e3c700d944f99b2df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY4MDcxMw==", "url": "https://github.com/kiegroup/optaplanner/pull/928#discussion_r489680713", "bodyText": "Class<? extends AbstractScore<?>>?\nI'm thinking if we should just make an instance method, and use Score_ instead.\n(Likewise for other similar methods on this class.)", "author": "triceo", "createdAt": "2020-09-16T19:05:00Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/AbstractScore.java", "diffHunk": "@@ -27,16 +27,16 @@\n  * <p>\n  * Subclasses must be immutable.\n  *\n- * @param <S> the actual score type\n+ * @param <Score_> the actual score type\n  * @see Score\n  * @see HardSoftScore\n  */\n-public abstract class AbstractScore<S extends Score> implements Score<S>,\n+public abstract class AbstractScore<Score_ extends AbstractScore<Score_>> implements Score<Score_>,\n         Serializable {\n \n     protected static final String INIT_LABEL = \"init\";\n \n-    protected static String[] parseScoreTokens(Class<? extends Score> scoreClass,\n+    protected static String[] parseScoreTokens(Class<? extends Score<?>> scoreClass,", "originalCommit": "16472047f635da11fbbba62e3c700d944f99b2df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY4MzMzNQ==", "url": "https://github.com/kiegroup/optaplanner/pull/928#discussion_r489683335", "bodyText": "Now wouldn't it be nice if SolutionDescriptor also had a Score_? But maybe that'd just go too far.", "author": "triceo", "createdAt": "2020-09-16T19:07:17Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/solution/descriptor/SolutionDescriptor.java", "diffHunk": "@@ -679,8 +683,8 @@ private void determineGlobalShadowOrder() {\n     /**\n      * @return the {@link Class} of {@link PlanningScore}\n      */\n-    public Class<? extends Score> extractScoreClass() {\n-        return (Class<? extends Score>) scoreMemberAccessor.getType();\n+    public Class<? extends Score<?>> extractScoreClass() {", "originalCommit": "16472047f635da11fbbba62e3c700d944f99b2df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDAzOTk3NA==", "url": "https://github.com/kiegroup/optaplanner/pull/928#discussion_r490039974", "bodyText": "I fear this will go to far. That's a rabbit hole that will lead very deep.\nSeparate PR/experiment in any case. And let's first figure out if InnerScoreDirector should be score generified...", "author": "ge0ffrey", "createdAt": "2020-09-17T07:47:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY4MzMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY4NjAxMA==", "url": "https://github.com/kiegroup/optaplanner/pull/928#discussion_r489686010", "bodyText": "First of all, <Supply_ extends Supply> Supply_ should work, right?\nSecond, wouldn't it make sense to do SupplyManager<Supply_> directly?", "author": "triceo", "createdAt": "2020-09-16T19:09:33Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/variable/supply/SupplyManager.java", "diffHunk": "@@ -22,13 +22,15 @@\n public interface SupplyManager {\n \n     /**\n-     * Returns the {@link Supply} for a {@link Demand}, preferably an existing one.\n-     * If the {@link Supply} doesn't exist yet (as part of the domain model or externalized), it creates and attaches it.\n+     * Returns the {@link org.optaplanner.core.impl.domain.variable.supply.Supply} for a {@link Demand}, preferably an existing\n+     * one.\n+     * If the {@link org.optaplanner.core.impl.domain.variable.supply.Supply} doesn't exist yet (as part of the domain model or\n+     * externalized), it creates and attaches it.\n      *\n      * @param demand never null\n-     * @param <S> Subclass of {@link Supply}\n+     * @param <Supply> Subclass of {@link org.optaplanner.core.impl.domain.variable.supply.Supply}\n      * @return never null\n      */\n-    <S extends Supply> S demand(Demand<S> demand);\n+    <Supply extends org.optaplanner.core.impl.domain.variable.supply.Supply> Supply demand(Demand<Supply> demand);", "originalCommit": "16472047f635da11fbbba62e3c700d944f99b2df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA0MTAzNg==", "url": "https://github.com/kiegroup/optaplanner/pull/928#discussion_r490041036", "bodyText": "Yes, was a mistake\nNo: SupplyManager handles multiple Supply types. For example when you combine an anchor shadow variable and a inverse relation shadow variable.", "author": "ge0ffrey", "createdAt": "2020-09-17T07:49:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY4NjAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY4NzA5Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/928#discussion_r489687092", "bodyText": "This was missing all the time?", "author": "triceo", "createdAt": "2020-09-16T19:10:26Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/ScoreUtils.java", "diffHunk": "@@ -56,6 +57,8 @@ public static Score parseScore(Class<? extends Score> scoreClass, String scoreSt\n             return HardMediumSoftScore.parseScore(scoreString);\n         } else if (HardMediumSoftLongScore.class.equals(scoreClass)) {\n             return HardMediumSoftLongScore.parseScore(scoreString);\n+        } else if (HardMediumSoftBigDecimalScore.class.equals(scoreClass)) {\n+            return HardMediumSoftBigDecimalScore.parseScore(scoreString);", "originalCommit": "16472047f635da11fbbba62e3c700d944f99b2df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA0MTUwNA==", "url": "https://github.com/kiegroup/optaplanner/pull/928#discussion_r490041504", "bodyText": "Yes. Scary :)", "author": "ge0ffrey", "createdAt": "2020-09-17T07:50:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY4NzA5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY4OTE2NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/928#discussion_r489689165", "bodyText": "Now wouldn't it be lovely if AbstractScoreDirector had a generic <Score_> type? :-) Inner and Abstract score directors, and their subclasses, are officially private code in 8, so adding more generics there does not affect users.", "author": "triceo", "createdAt": "2020-09-16T19:12:22Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/director/AbstractScoreDirector.java", "diffHunk": "@@ -378,8 +378,12 @@ public static String explainScore(Score workingScore,\n     }\n \n     @Override\n-    public String explainScore() {\n-        return explainScore(calculateScore(), getConstraintMatchTotalMap().values(), getIndictmentMap().values());\n+    public <Score_ extends Score<Score_>> String explainScore() {", "originalCommit": "16472047f635da11fbbba62e3c700d944f99b2df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA0MjE2MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/928#discussion_r490042161", "bodyText": "Yes, I am starting to think so too. Make InnerScoreDirector (not ScoreDirector!) Score generic. Separate PR in any case. Want to create a jira for it?", "author": "ge0ffrey", "createdAt": "2020-09-17T07:51:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY4OTE2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA1OTY2OA==", "url": "https://github.com/kiegroup/optaplanner/pull/928#discussion_r490059668", "bodyText": "https://issues.redhat.com/browse/PLANNER-2164", "author": "triceo", "createdAt": "2020-09-17T08:20:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY4OTE2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY5MTQ3MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/928#discussion_r489691471", "bodyText": "IMO InnerScoreDirector is really screaming for a <Score_> generic type.", "author": "triceo", "createdAt": "2020-09-16T19:14:20Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/director/InnerScoreDirector.java", "diffHunk": "@@ -76,8 +76,9 @@\n      *         (to create one, use {@link ConstraintMatchTotal#composeConstraintId(String, String)}).\n      * @throws IllegalStateException if {@link #isConstraintMatchEnabled()} returns false\n      * @see #getIndictmentMap()\n+     * @param <Score_> the actual score type\n      */\n-    Map<String, ConstraintMatchTotal> getConstraintMatchTotalMap();\n+    <Score_ extends Score<Score_>> Map<String, ConstraintMatchTotal<Score_>> getConstraintMatchTotalMap();", "originalCommit": "16472047f635da11fbbba62e3c700d944f99b2df", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY5MjUwNQ==", "url": "https://github.com/kiegroup/optaplanner/pull/928#discussion_r489692505", "bodyText": "The cast should not be necessary, as ScoreDefinition also has <Score_>.", "author": "triceo", "createdAt": "2020-09-16T19:15:10Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/director/incremental/IncrementalScoreDirector.java", "diffHunk": "@@ -99,38 +99,41 @@ public boolean isConstraintMatchEnabled() {\n     }\n \n     @Override\n-    public Map<String, ConstraintMatchTotal> getConstraintMatchTotalMap() {\n+    public <Score_ extends Score<Score_>> Map<String, ConstraintMatchTotal<Score_>> getConstraintMatchTotalMap() {\n         if (!isConstraintMatchEnabled()) {\n             throw new IllegalStateException(\"When constraintMatchEnabled (\" + isConstraintMatchEnabled()\n                     + \") is disabled in the constructor, this method should not be called.\");\n         }\n         // Notice that we don't trigger the variable listeners\n-        return ((ConstraintMatchAwareIncrementalScoreCalculator<Solution_>) incrementalScoreCalculator)\n+        return ((ConstraintMatchAwareIncrementalScoreCalculator<Solution_, Score_>) incrementalScoreCalculator)\n                 .getConstraintMatchTotals()\n                 .stream()\n-                .collect(toMap(ConstraintMatchTotal::getConstraintId, identity()));\n+                .collect(toMap(ConstraintMatchTotal<Score_>::getConstraintId, identity()));\n     }\n \n     @Override\n-    public Map<Object, Indictment> getIndictmentMap() {\n+    public <Score_ extends Score<Score_>> Map<Object, Indictment<Score_>> getIndictmentMap() {\n         if (!isConstraintMatchEnabled()) {\n             throw new IllegalStateException(\"When constraintMatchEnabled (\" + isConstraintMatchEnabled()\n                     + \") is disabled in the constructor, this method should not be called.\");\n         }\n-        Map<Object, Indictment> incrementalIndictmentMap =\n-                ((ConstraintMatchAwareIncrementalScoreCalculator<Solution_>) incrementalScoreCalculator).getIndictmentMap();\n+        Map<Object, Indictment<Score_>> incrementalIndictmentMap =\n+                ((ConstraintMatchAwareIncrementalScoreCalculator<Solution_, Score_>) incrementalScoreCalculator)\n+                        .getIndictmentMap();\n         if (incrementalIndictmentMap != null) {\n             return incrementalIndictmentMap;\n         }\n-        Map<Object, Indictment> indictmentMap = new LinkedHashMap<>(); // TODO use entitySize\n-        Score zeroScore = getScoreDefinition().getZeroScore();\n-        for (ConstraintMatchTotal constraintMatchTotal : getConstraintMatchTotalMap().values()) {\n-            for (ConstraintMatch constraintMatch : constraintMatchTotal.getConstraintMatchSet()) {\n+        Map<Object, Indictment<Score_>> indictmentMap = new LinkedHashMap<>(); // TODO use entitySize\n+        Score_ zeroScore = (Score_) getScoreDefinition().getZeroScore();", "originalCommit": "16472047f635da11fbbba62e3c700d944f99b2df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA0MzA1Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/928#discussion_r490043056", "bodyText": "But as long as AbstractScoreDirector doesn't have a generic type, it ScoreDefinition isn't typed either. So can't fix in this PR.", "author": "ge0ffrey", "createdAt": "2020-09-17T07:53:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY5MjUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY5NDA4MA==", "url": "https://github.com/kiegroup/optaplanner/pull/928#discussion_r489694080", "bodyText": "Considering how often these two methods (constraint match total map, indictment map) repeat in various unrelated interfaces, perhaps these should be extracted into their own interface, which the other interfaces would then extend?", "author": "triceo", "createdAt": "2020-09-16T19:16:38Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/ConstraintSession.java", "diffHunk": "@@ -40,15 +40,17 @@\n      * As defined by {@link InnerScoreDirector#getConstraintMatchTotalMap()}.\n      *\n      * @return never null\n+     * @param <Score_> the {@link Score} type\n      */\n-    Map<String, ConstraintMatchTotal> getConstraintMatchTotalMap();\n+    <Score_ extends Score<Score_>> Map<String, ConstraintMatchTotal<Score_>> getConstraintMatchTotalMap();", "originalCommit": "16472047f635da11fbbba62e3c700d944f99b2df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA0NjkzNw==", "url": "https://github.com/kiegroup/optaplanner/pull/928#discussion_r490046937", "bodyText": "I think this is premature optimizaton, that if we clean up some architecture, will become much less needed.\nThey repeat 3 times:\n\nScoreExplenation - which is public API, so the extra interface inheritence will complicate it for users\nScoreDirector\nConstraintSession - which should maybe be removed\n\nI believe ConstraintSession is a needless indirection (that maybe even has a perf impact).\nSame for ConstraintSessionFactory and ConstraintStreamScoreDirectorFactory.\nWe could maybe replace it by [Drools/Bavet]ConstraintStreamScoreDirector(Factory) extends AbstractConstraintStreamScoreDirector(Factory).\nThat experiment needs to be looked into first.", "author": "ge0ffrey", "createdAt": "2020-09-17T07:59:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTY5NDA4MA=="}], "type": "inlineReview"}, {"oid": "d0232ad7821d508b8620019d0de371e754700c8d", "url": "https://github.com/kiegroup/optaplanner/commit/d0232ad7821d508b8620019d0de371e754700c8d", "message": "PLANNER-2151 PR feedback (thanks Lukas)", "committedDate": "2020-09-17T08:20:41Z", "type": "commit"}]}