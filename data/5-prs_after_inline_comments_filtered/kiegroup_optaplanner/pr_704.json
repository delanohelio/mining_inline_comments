{"pr_number": 704, "pr_title": "PLANNER-1819 Add Examination CSProvider", "pr_createdAt": "2020-02-25T13:46:45Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/704", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg4NzkwMA==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383887900", "bodyText": "Let's not include DRL code in here. (Also applies below.) But I appreciate the effort to make the review easier. :-)", "author": "triceo", "createdAt": "2020-02-25T13:48:04Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end", "originalCommit": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQzMzU5NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r384433595", "bodyText": "Yes, that was meant as a help for myself and potentially the reviewer. I will remove it after I fix all the issues.", "author": "michaltomco", "createdAt": "2020-02-26T11:26:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg4NzkwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg4ODQ1OA==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383888458", "bodyText": "Don't you get this automatically? from() only gives you initialized entities by default.", "author": "triceo", "createdAt": "2020-02-25T13:48:59Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)", "originalCommit": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg4ODc1Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383888752", "bodyText": "In this case,  .join(Exam.class, equal(Exam::getPeriod)) is a useful shorthand.", "author": "triceo", "createdAt": "2020-02-25T13:49:32Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))", "originalCommit": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5MDg1Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383890852", "bodyText": "I don't see Period actually used anywhere in this constraint. Maybe you're just interested in knowing if there is a Period that has an Exam? If so, use ifExists() - will work miracles for performance of the constraint.", "author": "triceo", "createdAt": "2020-02-25T13:53:01Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .ifExists(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    //    // More seating required during a period in a room than available in that room.\n+//    rule \"roomCapacityTooSmall\"\n+//    when\n+//    $period : Period()\n+//    $room : Room($capacity : capacity)\n+//    accumulate(\n+//            Exam(period == $period, room == $room, $studentSize : topicStudentSize);\n+//    $totalStudentSize : sum($studentSize);\n+//    $totalStudentSize > $capacity\n+//        )\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, $capacity - $totalStudentSize);\n+//    end\n+    private Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .join(Period.class, equal(Exam::getPeriod, Function.identity()))", "originalCommit": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkxMjAyNQ==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383912025", "bodyText": "Most likely it's a bug, though. The period is actually used in the DRL. Could it be better to start the stream with from(Period.class) instead? It would match the DRL more naturally then.", "author": "triceo", "createdAt": "2020-02-25T14:28:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5MDg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5NzkwMA==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383897900", "bodyText": "This is no longer necessary, right. leftExam.getPeriod() already isn't null, and rightExam.getPeriod() is joined where equal.", "author": "triceo", "createdAt": "2020-02-25T14:05:07Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .ifExists(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    //    // More seating required during a period in a room than available in that room.\n+//    rule \"roomCapacityTooSmall\"\n+//    when\n+//    $period : Period()\n+//    $room : Room($capacity : capacity)\n+//    accumulate(\n+//            Exam(period == $period, room == $room, $studentSize : topicStudentSize);\n+//    $totalStudentSize : sum($studentSize);\n+//    $totalStudentSize > $capacity\n+//        )\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, $capacity - $totalStudentSize);\n+//    end\n+    private Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .join(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .join(Room.class, equal((exam, period) -> exam.getRoom(), Function.identity()))\n+                .groupBy((exam, period, room) -> room.getCapacity(),\n+                         ConstraintCollectors.sum((exam, period, room) -> exam.getTopicStudentSize()))\n+                .filter((capacity, totalStudentSize) -> totalStudentSize > capacity)\n+                .penalize(\"Room capacity too small\",\n+                          HardSoftScore.ONE_HARD,\n+                          (capacity, totalStudentSize) -> totalStudentSize - capacity);\n+    }\n+\n+    //    rule \"periodPenaltyExamCoincidence\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXAM_COINCIDENCE,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != $leftPeriod, period != null)\n+//    // Left and right don't share a student because those are filtered out in ExaminationImporter\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, exam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, exam) -> exam.getPeriod(), Exam::getPeriod))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)", "originalCommit": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg5OTA0Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383899046", "bodyText": "Can  getPeriod() be null if getPeriodIndex() already worked fine?", "author": "triceo", "createdAt": "2020-02-25T14:07:07Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .ifExists(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    //    // More seating required during a period in a room than available in that room.\n+//    rule \"roomCapacityTooSmall\"\n+//    when\n+//    $period : Period()\n+//    $room : Room($capacity : capacity)\n+//    accumulate(\n+//            Exam(period == $period, room == $room, $studentSize : topicStudentSize);\n+//    $totalStudentSize : sum($studentSize);\n+//    $totalStudentSize > $capacity\n+//        )\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, $capacity - $totalStudentSize);\n+//    end\n+    private Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .join(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .join(Room.class, equal((exam, period) -> exam.getRoom(), Function.identity()))\n+                .groupBy((exam, period, room) -> room.getCapacity(),\n+                         ConstraintCollectors.sum((exam, period, room) -> exam.getTopicStudentSize()))\n+                .filter((capacity, totalStudentSize) -> totalStudentSize > capacity)\n+                .penalize(\"Room capacity too small\",\n+                          HardSoftScore.ONE_HARD,\n+                          (capacity, totalStudentSize) -> totalStudentSize - capacity);\n+    }\n+\n+    //    rule \"periodPenaltyExamCoincidence\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXAM_COINCIDENCE,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != $leftPeriod, period != null)\n+//    // Left and right don't share a student because those are filtered out in ExaminationImporter\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, exam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, exam) -> exam.getPeriod(), Exam::getPeriod))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyExclusion\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXCLUSION,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $leftPeriod)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyAfter\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.AFTER,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, $leftPeriodIndex <= periodIndex, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      lessThanOrEqual((periodPenalty, leftExam) -> leftExam.getPeriodIndex(), Exam::getPeriodIndex))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)", "originalCommit": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkwMDE1NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383900155", "bodyText": "Can't you do this using Joiners.equal() within the preceding join()?", "author": "triceo", "createdAt": "2020-02-25T14:08:55Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .ifExists(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    //    // More seating required during a period in a room than available in that room.\n+//    rule \"roomCapacityTooSmall\"\n+//    when\n+//    $period : Period()\n+//    $room : Room($capacity : capacity)\n+//    accumulate(\n+//            Exam(period == $period, room == $room, $studentSize : topicStudentSize);\n+//    $totalStudentSize : sum($studentSize);\n+//    $totalStudentSize > $capacity\n+//        )\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, $capacity - $totalStudentSize);\n+//    end\n+    private Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .join(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .join(Room.class, equal((exam, period) -> exam.getRoom(), Function.identity()))\n+                .groupBy((exam, period, room) -> room.getCapacity(),\n+                         ConstraintCollectors.sum((exam, period, room) -> exam.getTopicStudentSize()))\n+                .filter((capacity, totalStudentSize) -> totalStudentSize > capacity)\n+                .penalize(\"Room capacity too small\",\n+                          HardSoftScore.ONE_HARD,\n+                          (capacity, totalStudentSize) -> totalStudentSize - capacity);\n+    }\n+\n+    //    rule \"periodPenaltyExamCoincidence\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXAM_COINCIDENCE,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != $leftPeriod, period != null)\n+//    // Left and right don't share a student because those are filtered out in ExaminationImporter\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, exam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, exam) -> exam.getPeriod(), Exam::getPeriod))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyExclusion\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXCLUSION,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $leftPeriod)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyAfter\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.AFTER,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, $leftPeriodIndex <= periodIndex, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      lessThanOrEqual((periodPenalty, leftExam) -> leftExam.getPeriodIndex(), Exam::getPeriodIndex))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"roomPenaltyExclusive\"\n+//    when\n+//    $roomPenalty : RoomPenalty(\n+//            roomPenaltyType == RoomPenaltyType.ROOM_EXCLUSIVE,\n+//            $topic : topic\n+//    )\n+//    $leftExam : Exam(topic == $topic, $room : room, room != null, $period : period, period != null)\n+//    $rightExam : Exam(room == $room, period == $period, topic != $topic, $otherTopic : topic)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($topic.getStudentSize() + $otherTopic.getStudentSize()));\n+//    end\n+    private Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                      equal(RoomPenalty::getTopic, Exam::getTopic))\n+                .filter((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null)\n+                .join(Exam.class,\n+                      equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                      equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .filter((roomPenalty, leftExam, rightExam) -> leftExam.getTopic().equals(rightExam.getTopic()))", "originalCommit": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkwMzc5MA==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383903790", "bodyText": "You use this Math.abs(...) >/= 1 construct frequently. I'd extract it to a separate method and reuse.", "author": "triceo", "createdAt": "2020-02-25T14:15:05Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .ifExists(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    //    // More seating required during a period in a room than available in that room.\n+//    rule \"roomCapacityTooSmall\"\n+//    when\n+//    $period : Period()\n+//    $room : Room($capacity : capacity)\n+//    accumulate(\n+//            Exam(period == $period, room == $room, $studentSize : topicStudentSize);\n+//    $totalStudentSize : sum($studentSize);\n+//    $totalStudentSize > $capacity\n+//        )\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, $capacity - $totalStudentSize);\n+//    end\n+    private Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .join(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .join(Room.class, equal((exam, period) -> exam.getRoom(), Function.identity()))\n+                .groupBy((exam, period, room) -> room.getCapacity(),\n+                         ConstraintCollectors.sum((exam, period, room) -> exam.getTopicStudentSize()))\n+                .filter((capacity, totalStudentSize) -> totalStudentSize > capacity)\n+                .penalize(\"Room capacity too small\",\n+                          HardSoftScore.ONE_HARD,\n+                          (capacity, totalStudentSize) -> totalStudentSize - capacity);\n+    }\n+\n+    //    rule \"periodPenaltyExamCoincidence\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXAM_COINCIDENCE,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != $leftPeriod, period != null)\n+//    // Left and right don't share a student because those are filtered out in ExaminationImporter\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, exam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, exam) -> exam.getPeriod(), Exam::getPeriod))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyExclusion\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXCLUSION,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $leftPeriod)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyAfter\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.AFTER,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, $leftPeriodIndex <= periodIndex, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      lessThanOrEqual((periodPenalty, leftExam) -> leftExam.getPeriodIndex(), Exam::getPeriodIndex))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"roomPenaltyExclusive\"\n+//    when\n+//    $roomPenalty : RoomPenalty(\n+//            roomPenaltyType == RoomPenaltyType.ROOM_EXCLUSIVE,\n+//            $topic : topic\n+//    )\n+//    $leftExam : Exam(topic == $topic, $room : room, room != null, $period : period, period != null)\n+//    $rightExam : Exam(room == $room, period == $period, topic != $topic, $otherTopic : topic)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($topic.getStudentSize() + $otherTopic.getStudentSize()));\n+//    end\n+    private Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                      equal(RoomPenalty::getTopic, Exam::getTopic))\n+                .filter((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null)\n+                .join(Exam.class,\n+                      equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                      equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .filter((roomPenalty, leftExam, rightExam) -> leftExam.getTopic().equals(rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    // Two exams in a row which share students\n+//    rule \"twoExamsInARow\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) == 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) == 1)\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT, (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Two exams in a day which share students\n+//    rule \"twoExamsInADay\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) > 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) > 1)\n+                .penalize(\"Two exams in a day\",\n+                          HardSoftScore.ONE_SOFT,\n+                          (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Exams which share students have to few periods between them\n+//    rule \"periodSpread\"\n+//    when\n+//    $constraintConfiguration : ExaminationConstraintConfiguration()\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != null,\n+//                      Math.abs($leftPeriodIndex - periodIndex) < ($constraintConfiguration.getPeriodSpreadLength() + 1))\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint periodSpread(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) > 1)", "originalCommit": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkxNDQwMg==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383914402", "bodyText": "Also same comment regarding ifExists() as with twoExamsInADay.", "author": "triceo", "createdAt": "2020-02-25T14:32:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkwMzc5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkwNDc3Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383904776", "bodyText": "Personally, I like to see all equals() joiners first, but that's mostly aesthetic.", "author": "triceo", "createdAt": "2020-02-25T14:16:43Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .ifExists(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    //    // More seating required during a period in a room than available in that room.\n+//    rule \"roomCapacityTooSmall\"\n+//    when\n+//    $period : Period()\n+//    $room : Room($capacity : capacity)\n+//    accumulate(\n+//            Exam(period == $period, room == $room, $studentSize : topicStudentSize);\n+//    $totalStudentSize : sum($studentSize);\n+//    $totalStudentSize > $capacity\n+//        )\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, $capacity - $totalStudentSize);\n+//    end\n+    private Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .join(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .join(Room.class, equal((exam, period) -> exam.getRoom(), Function.identity()))\n+                .groupBy((exam, period, room) -> room.getCapacity(),\n+                         ConstraintCollectors.sum((exam, period, room) -> exam.getTopicStudentSize()))\n+                .filter((capacity, totalStudentSize) -> totalStudentSize > capacity)\n+                .penalize(\"Room capacity too small\",\n+                          HardSoftScore.ONE_HARD,\n+                          (capacity, totalStudentSize) -> totalStudentSize - capacity);\n+    }\n+\n+    //    rule \"periodPenaltyExamCoincidence\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXAM_COINCIDENCE,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != $leftPeriod, period != null)\n+//    // Left and right don't share a student because those are filtered out in ExaminationImporter\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, exam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, exam) -> exam.getPeriod(), Exam::getPeriod))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyExclusion\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXCLUSION,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $leftPeriod)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyAfter\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.AFTER,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, $leftPeriodIndex <= periodIndex, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      lessThanOrEqual((periodPenalty, leftExam) -> leftExam.getPeriodIndex(), Exam::getPeriodIndex))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"roomPenaltyExclusive\"\n+//    when\n+//    $roomPenalty : RoomPenalty(\n+//            roomPenaltyType == RoomPenaltyType.ROOM_EXCLUSIVE,\n+//            $topic : topic\n+//    )\n+//    $leftExam : Exam(topic == $topic, $room : room, room != null, $period : period, period != null)\n+//    $rightExam : Exam(room == $room, period == $period, topic != $topic, $otherTopic : topic)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($topic.getStudentSize() + $otherTopic.getStudentSize()));\n+//    end\n+    private Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                      equal(RoomPenalty::getTopic, Exam::getTopic))\n+                .filter((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null)\n+                .join(Exam.class,\n+                      equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                      equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .filter((roomPenalty, leftExam, rightExam) -> leftExam.getTopic().equals(rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    // Two exams in a row which share students\n+//    rule \"twoExamsInARow\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) == 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) == 1)\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT, (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Two exams in a day which share students\n+//    rule \"twoExamsInADay\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) > 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) > 1)\n+                .penalize(\"Two exams in a day\",\n+                          HardSoftScore.ONE_SOFT,\n+                          (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Exams which share students have to few periods between them\n+//    rule \"periodSpread\"\n+//    when\n+//    $constraintConfiguration : ExaminationConstraintConfiguration()\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != null,\n+//                      Math.abs($leftPeriodIndex - periodIndex) < ($constraintConfiguration.getPeriodSpreadLength() + 1))\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint periodSpread(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) > 1)\n+                .penalize(\"Period spread\",\n+                          HardSoftScore.ONE_SOFT,\n+                          (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Several exams in the same room and period have different durations\n+//    rule \"mixedDurations\"\n+//    when\n+//    $leftExam : Exam($leftId : id, period != null, $period : period, room != null, $room : room,\n+//                     $leftTopicDuration : topicDuration)\n+//    // 4 mixed durations of 100, 150, 200 and 200 should only result in 2 penalty's (for 100&150 and 100&200)\n+//    // leftExam has lowest id of the period+room combo\n+//    not Exam(period == $period, room == $room, id < $leftId)\n+//    // rightExam has a different duration\n+//    $rightExam : Exam(period == $period, room == $room, id > $leftId,\n+//                      topicDuration != $leftTopicDuration,\n+//                      $rightId : id, $rightTopicDuration : topicDuration\n+//    )\n+//    // rightExam has the lowest id of the period+room+rightDuration combo\n+//    not Exam(period == $period, room == $room, id < $rightId,\n+//            topicDuration == $rightTopicDuration\n+//    )\n+//    then\n+//        scoreHolder.penalize(kcontext);\n+//    end\n+    private Constraint mixedDurations(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .ifExists(Exam.class, equal(Exam::getRoom, Exam::getRoom))\n+                .ifNotExistsOther(Exam.class,\n+                                  equal(Exam::getPeriod, Exam::getPeriod),\n+                                  equal(Exam::getRoom, Exam::getRoom),\n+                                  lessThan(Exam::getId, Exam::getId))\n+                .join(Exam.class,\n+                      equal(Exam::getPeriod, Exam::getPeriod),\n+                      equal(Exam::getRoom, Exam::getRoom),\n+                      greaterThan(Exam::getId, Exam::getId))\n+                .filter((leftExam, rightExam) -> rightExam.getTopicDuration() != leftExam.getTopicDuration())\n+                .ifNotExists(Exam.class,\n+                             equal((leftExam, rightExam) -> rightExam.getPeriod(), Exam::getPeriod),\n+                             equal((leftExam, rightExam) -> rightExam.getRoom(), Exam::getRoom),\n+                             greaterThan((leftExam, rightExam) -> rightExam.getId(), Exam::getId),", "originalCommit": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkwOTk1Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383909952", "bodyText": "Also, this from(Exam).join(Exam) can be replaced by .fromUniquePair(Exam.class, equal(...))", "author": "triceo", "createdAt": "2020-02-25T14:25:05Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))", "originalCommit": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkxMDk1OA==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383910958", "bodyText": "Most likely not necessary, as the rule doesn't use it either.", "author": "triceo", "createdAt": "2020-02-25T14:26:31Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .ifExists(Period.class, equal(Exam::getPeriod, Function.identity()))", "originalCommit": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkxNTA2MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383915061", "bodyText": "Perhaps could be replaced by ifExists(), but then the constraint may no longer be functionally equivalent to the DRL. FULL_ASSERT would tell.", "author": "triceo", "createdAt": "2020-02-25T14:33:19Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .ifExists(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    //    // More seating required during a period in a room than available in that room.\n+//    rule \"roomCapacityTooSmall\"\n+//    when\n+//    $period : Period()\n+//    $room : Room($capacity : capacity)\n+//    accumulate(\n+//            Exam(period == $period, room == $room, $studentSize : topicStudentSize);\n+//    $totalStudentSize : sum($studentSize);\n+//    $totalStudentSize > $capacity\n+//        )\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, $capacity - $totalStudentSize);\n+//    end\n+    private Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .join(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .join(Room.class, equal((exam, period) -> exam.getRoom(), Function.identity()))\n+                .groupBy((exam, period, room) -> room.getCapacity(),\n+                         ConstraintCollectors.sum((exam, period, room) -> exam.getTopicStudentSize()))\n+                .filter((capacity, totalStudentSize) -> totalStudentSize > capacity)\n+                .penalize(\"Room capacity too small\",\n+                          HardSoftScore.ONE_HARD,\n+                          (capacity, totalStudentSize) -> totalStudentSize - capacity);\n+    }\n+\n+    //    rule \"periodPenaltyExamCoincidence\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXAM_COINCIDENCE,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != $leftPeriod, period != null)\n+//    // Left and right don't share a student because those are filtered out in ExaminationImporter\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, exam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, exam) -> exam.getPeriod(), Exam::getPeriod))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyExclusion\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXCLUSION,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $leftPeriod)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyAfter\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.AFTER,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, $leftPeriodIndex <= periodIndex, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      lessThanOrEqual((periodPenalty, leftExam) -> leftExam.getPeriodIndex(), Exam::getPeriodIndex))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"roomPenaltyExclusive\"\n+//    when\n+//    $roomPenalty : RoomPenalty(\n+//            roomPenaltyType == RoomPenaltyType.ROOM_EXCLUSIVE,\n+//            $topic : topic\n+//    )\n+//    $leftExam : Exam(topic == $topic, $room : room, room != null, $period : period, period != null)\n+//    $rightExam : Exam(room == $room, period == $period, topic != $topic, $otherTopic : topic)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($topic.getStudentSize() + $otherTopic.getStudentSize()));\n+//    end\n+    private Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                      equal(RoomPenalty::getTopic, Exam::getTopic))\n+                .filter((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null)\n+                .join(Exam.class,\n+                      equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                      equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .filter((roomPenalty, leftExam, rightExam) -> leftExam.getTopic().equals(rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    // Two exams in a row which share students\n+//    rule \"twoExamsInARow\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) == 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))", "originalCommit": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzkxNTMxOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r383915319", "bodyText": "Dtto. on ifExists().", "author": "triceo", "createdAt": "2020-02-25T14:33:44Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .ifExists(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    //    // More seating required during a period in a room than available in that room.\n+//    rule \"roomCapacityTooSmall\"\n+//    when\n+//    $period : Period()\n+//    $room : Room($capacity : capacity)\n+//    accumulate(\n+//            Exam(period == $period, room == $room, $studentSize : topicStudentSize);\n+//    $totalStudentSize : sum($studentSize);\n+//    $totalStudentSize > $capacity\n+//        )\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, $capacity - $totalStudentSize);\n+//    end\n+    private Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .join(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .join(Room.class, equal((exam, period) -> exam.getRoom(), Function.identity()))\n+                .groupBy((exam, period, room) -> room.getCapacity(),\n+                         ConstraintCollectors.sum((exam, period, room) -> exam.getTopicStudentSize()))\n+                .filter((capacity, totalStudentSize) -> totalStudentSize > capacity)\n+                .penalize(\"Room capacity too small\",\n+                          HardSoftScore.ONE_HARD,\n+                          (capacity, totalStudentSize) -> totalStudentSize - capacity);\n+    }\n+\n+    //    rule \"periodPenaltyExamCoincidence\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXAM_COINCIDENCE,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != $leftPeriod, period != null)\n+//    // Left and right don't share a student because those are filtered out in ExaminationImporter\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, exam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, exam) -> exam.getPeriod(), Exam::getPeriod))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyExclusion\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXCLUSION,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $leftPeriod)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyAfter\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.AFTER,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, $leftPeriodIndex <= periodIndex, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      lessThanOrEqual((periodPenalty, leftExam) -> leftExam.getPeriodIndex(), Exam::getPeriodIndex))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"roomPenaltyExclusive\"\n+//    when\n+//    $roomPenalty : RoomPenalty(\n+//            roomPenaltyType == RoomPenaltyType.ROOM_EXCLUSIVE,\n+//            $topic : topic\n+//    )\n+//    $leftExam : Exam(topic == $topic, $room : room, room != null, $period : period, period != null)\n+//    $rightExam : Exam(room == $room, period == $period, topic != $topic, $otherTopic : topic)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($topic.getStudentSize() + $otherTopic.getStudentSize()));\n+//    end\n+    private Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                      equal(RoomPenalty::getTopic, Exam::getTopic))\n+                .filter((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null)\n+                .join(Exam.class,\n+                      equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                      equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .filter((roomPenalty, leftExam, rightExam) -> leftExam.getTopic().equals(rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    // Two exams in a row which share students\n+//    rule \"twoExamsInARow\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) == 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) == 1)\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT, (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Two exams in a day which share students\n+//    rule \"twoExamsInADay\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) > 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) > 1)", "originalCommit": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5NDkyMQ==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r384194921", "bodyText": "Why is this here? I don't see it in the DRL.", "author": "triceo", "createdAt": "2020-02-25T23:43:04Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .ifExists(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    //    // More seating required during a period in a room than available in that room.\n+//    rule \"roomCapacityTooSmall\"\n+//    when\n+//    $period : Period()\n+//    $room : Room($capacity : capacity)\n+//    accumulate(\n+//            Exam(period == $period, room == $room, $studentSize : topicStudentSize);\n+//    $totalStudentSize : sum($studentSize);\n+//    $totalStudentSize > $capacity\n+//        )\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, $capacity - $totalStudentSize);\n+//    end\n+    private Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .join(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .join(Room.class, equal((exam, period) -> exam.getRoom(), Function.identity()))\n+                .groupBy((exam, period, room) -> room.getCapacity(),\n+                         ConstraintCollectors.sum((exam, period, room) -> exam.getTopicStudentSize()))\n+                .filter((capacity, totalStudentSize) -> totalStudentSize > capacity)\n+                .penalize(\"Room capacity too small\",\n+                          HardSoftScore.ONE_HARD,\n+                          (capacity, totalStudentSize) -> totalStudentSize - capacity);\n+    }\n+\n+    //    rule \"periodPenaltyExamCoincidence\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXAM_COINCIDENCE,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != $leftPeriod, period != null)\n+//    // Left and right don't share a student because those are filtered out in ExaminationImporter\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, exam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, exam) -> exam.getPeriod(), Exam::getPeriod))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyExclusion\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXCLUSION,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $leftPeriod)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyAfter\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.AFTER,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, $leftPeriodIndex <= periodIndex, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      lessThanOrEqual((periodPenalty, leftExam) -> leftExam.getPeriodIndex(), Exam::getPeriodIndex))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"roomPenaltyExclusive\"\n+//    when\n+//    $roomPenalty : RoomPenalty(\n+//            roomPenaltyType == RoomPenaltyType.ROOM_EXCLUSIVE,\n+//            $topic : topic\n+//    )\n+//    $leftExam : Exam(topic == $topic, $room : room, room != null, $period : period, period != null)\n+//    $rightExam : Exam(room == $room, period == $period, topic != $topic, $otherTopic : topic)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($topic.getStudentSize() + $otherTopic.getStudentSize()));\n+//    end\n+    private Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                      equal(RoomPenalty::getTopic, Exam::getTopic))\n+                .filter((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null)\n+                .join(Exam.class,\n+                      equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                      equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .filter((roomPenalty, leftExam, rightExam) -> leftExam.getTopic().equals(rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    // Two exams in a row which share students\n+//    rule \"twoExamsInARow\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) == 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) == 1)\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT, (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Two exams in a day which share students\n+//    rule \"twoExamsInADay\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) > 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) > 1)\n+                .penalize(\"Two exams in a day\",\n+                          HardSoftScore.ONE_SOFT,\n+                          (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Exams which share students have to few periods between them\n+//    rule \"periodSpread\"\n+//    when\n+//    $constraintConfiguration : ExaminationConstraintConfiguration()\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != null,\n+//                      Math.abs($leftPeriodIndex - periodIndex) < ($constraintConfiguration.getPeriodSpreadLength() + 1))\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint periodSpread(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) > 1)\n+                .penalize(\"Period spread\",\n+                          HardSoftScore.ONE_SOFT,\n+                          (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Several exams in the same room and period have different durations\n+//    rule \"mixedDurations\"\n+//    when\n+//    $leftExam : Exam($leftId : id, period != null, $period : period, room != null, $room : room,\n+//                     $leftTopicDuration : topicDuration)\n+//    // 4 mixed durations of 100, 150, 200 and 200 should only result in 2 penalty's (for 100&150 and 100&200)\n+//    // leftExam has lowest id of the period+room combo\n+//    not Exam(period == $period, room == $room, id < $leftId)\n+//    // rightExam has a different duration\n+//    $rightExam : Exam(period == $period, room == $room, id > $leftId,\n+//                      topicDuration != $leftTopicDuration,\n+//                      $rightId : id, $rightTopicDuration : topicDuration\n+//    )\n+//    // rightExam has the lowest id of the period+room+rightDuration combo\n+//    not Exam(period == $period, room == $room, id < $rightId,\n+//            topicDuration == $rightTopicDuration\n+//    )\n+//    then\n+//        scoreHolder.penalize(kcontext);\n+//    end\n+    private Constraint mixedDurations(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .ifExists(Exam.class, equal(Exam::getRoom, Exam::getRoom))", "originalCommit": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5NTcyOA==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r384195728", "bodyText": "Since both left and right are the same type and we're joining on the same field, equal() can lose its second argument.", "author": "triceo", "createdAt": "2020-02-25T23:45:30Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,371 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .join(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .ifExists(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    //    // More seating required during a period in a room than available in that room.\n+//    rule \"roomCapacityTooSmall\"\n+//    when\n+//    $period : Period()\n+//    $room : Room($capacity : capacity)\n+//    accumulate(\n+//            Exam(period == $period, room == $room, $studentSize : topicStudentSize);\n+//    $totalStudentSize : sum($studentSize);\n+//    $totalStudentSize > $capacity\n+//        )\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, $capacity - $totalStudentSize);\n+//    end\n+    private Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .join(Period.class, equal(Exam::getPeriod, Function.identity()))\n+                .join(Room.class, equal((exam, period) -> exam.getRoom(), Function.identity()))\n+                .groupBy((exam, period, room) -> room.getCapacity(),\n+                         ConstraintCollectors.sum((exam, period, room) -> exam.getTopicStudentSize()))\n+                .filter((capacity, totalStudentSize) -> totalStudentSize > capacity)\n+                .penalize(\"Room capacity too small\",\n+                          HardSoftScore.ONE_HARD,\n+                          (capacity, totalStudentSize) -> totalStudentSize - capacity);\n+    }\n+\n+    //    rule \"periodPenaltyExamCoincidence\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXAM_COINCIDENCE,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != $leftPeriod, period != null)\n+//    // Left and right don't share a student because those are filtered out in ExaminationImporter\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, exam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, exam) -> exam.getPeriod(), Exam::getPeriod))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyExclusion\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXCLUSION,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $leftPeriod)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyAfter\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.AFTER,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, $leftPeriodIndex <= periodIndex, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic))\n+                .filter((periodPenalty, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      lessThanOrEqual((periodPenalty, leftExam) -> leftExam.getPeriodIndex(), Exam::getPeriodIndex))\n+                .filter((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null)\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"roomPenaltyExclusive\"\n+//    when\n+//    $roomPenalty : RoomPenalty(\n+//            roomPenaltyType == RoomPenaltyType.ROOM_EXCLUSIVE,\n+//            $topic : topic\n+//    )\n+//    $leftExam : Exam(topic == $topic, $room : room, room != null, $period : period, period != null)\n+//    $rightExam : Exam(room == $room, period == $period, topic != $topic, $otherTopic : topic)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($topic.getStudentSize() + $otherTopic.getStudentSize()));\n+//    end\n+    private Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                      equal(RoomPenalty::getTopic, Exam::getTopic))\n+                .filter((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null)\n+                .join(Exam.class,\n+                      equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                      equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .filter((roomPenalty, leftExam, rightExam) -> leftExam.getTopic().equals(rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    // Two exams in a row which share students\n+//    rule \"twoExamsInARow\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) == 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) == 1)\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT, (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Two exams in a day which share students\n+//    rule \"twoExamsInADay\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) > 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) > 1)\n+                .penalize(\"Two exams in a day\",\n+                          HardSoftScore.ONE_SOFT,\n+                          (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Exams which share students have to few periods between them\n+//    rule \"periodSpread\"\n+//    when\n+//    $constraintConfiguration : ExaminationConstraintConfiguration()\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != null,\n+//                      Math.abs($leftPeriodIndex - periodIndex) < ($constraintConfiguration.getPeriodSpreadLength() + 1))\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint periodSpread(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic))\n+                .filter((topicConflict, leftExam) -> leftExam.getPeriod() != null)\n+                .join(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex))\n+                .filter((topicConflict, leftExam, rightExam) -> Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex()) > 1)\n+                .penalize(\"Period spread\",\n+                          HardSoftScore.ONE_SOFT,\n+                          (topicConflict, leftExam, rightExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Several exams in the same room and period have different durations\n+//    rule \"mixedDurations\"\n+//    when\n+//    $leftExam : Exam($leftId : id, period != null, $period : period, room != null, $room : room,\n+//                     $leftTopicDuration : topicDuration)\n+//    // 4 mixed durations of 100, 150, 200 and 200 should only result in 2 penalty's (for 100&150 and 100&200)\n+//    // leftExam has lowest id of the period+room combo\n+//    not Exam(period == $period, room == $room, id < $leftId)\n+//    // rightExam has a different duration\n+//    $rightExam : Exam(period == $period, room == $room, id > $leftId,\n+//                      topicDuration != $leftTopicDuration,\n+//                      $rightId : id, $rightTopicDuration : topicDuration\n+//    )\n+//    // rightExam has the lowest id of the period+room+rightDuration combo\n+//    not Exam(period == $period, room == $room, id < $rightId,\n+//            topicDuration == $rightTopicDuration\n+//    )\n+//    then\n+//        scoreHolder.penalize(kcontext);\n+//    end\n+    private Constraint mixedDurations(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .ifExists(Exam.class, equal(Exam::getRoom, Exam::getRoom))\n+                .ifNotExistsOther(Exam.class,\n+                                  equal(Exam::getPeriod, Exam::getPeriod),\n+                                  equal(Exam::getRoom, Exam::getRoom),\n+                                  lessThan(Exam::getId, Exam::getId))\n+                .join(Exam.class,\n+                      equal(Exam::getPeriod, Exam::getPeriod),\n+                      equal(Exam::getRoom, Exam::getRoom),\n+                      greaterThan(Exam::getId, Exam::getId))", "originalCommit": "663991d3b87eb7188d3f7b3fd5f6b2a8ff987063", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "58619aa65d2026f4dc6957b6ef1fc271a24205f9", "url": "https://github.com/kiegroup/optaplanner/commit/58619aa65d2026f4dc6957b6ef1fc271a24205f9", "message": "PLANNER-1819 Address PR comments\n\nThere are different score value results for DRL and CS, still need to debug.", "committedDate": "2020-02-27T09:04:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk5NTE3OA==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r384995178", "bodyText": "Choose a better name for the method. Don't describe the code, describe the purpose.", "author": "triceo", "createdAt": "2020-02-27T09:11:32Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/optional/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,369 @@\n+package org.optaplanner.examples.examination.optional.score;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThanOrEqual;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    //// Two exams in the same period which share students.\n+//    rule \"conflictingExamsInSamePeriod\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $period : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $period)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $topicConflict.getStudentSize());\n+//    end\n+    private Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUniquePair(Exam.class, equal(Exam::getPeriod))\n+                .join(TopicConflict.class,\n+                      equal((leftExam, rightExam) -> leftExam.getTopic(), TopicConflict::getLeftTopic),\n+                      equal((leftExam, rightExam) -> rightExam.getTopic(), TopicConflict::getRightTopic))\n+                .penalize(\"Conflicting exams in same period\",\n+                          HardSoftScore.ONE_HARD,\n+                          (leftExam, rightExam, topicConflict) -> topicConflict.getStudentSize());\n+    }\n+\n+    //// More time required during a period than available in that period.\n+//    rule \"periodDurationTooShort\"\n+//    when\n+//    $exam : Exam(topicDuration > periodDuration, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, - $exam.getTopicStudentSize());\n+//    end\n+    private Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    //    // More seating required during a period in a room than available in that room.\n+//    rule \"roomCapacityTooSmall\"\n+//    when\n+//    $period : Period()\n+//    $room : Room($capacity : capacity)\n+//    accumulate(\n+//            Exam(period == $period, room == $room, $studentSize : topicStudentSize);\n+//    $totalStudentSize : sum($studentSize);\n+//    $totalStudentSize > $capacity\n+//        )\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext, $capacity - $totalStudentSize);\n+//    end\n+    private Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Period.class)\n+                .join(Exam.class, equal(Function.identity(), Exam::getPeriod))\n+                .join(Room.class, equal((period, exam) -> exam.getRoom(), Function.identity()))\n+                .groupBy((period, exam, room) -> room.getCapacity(),\n+                         ConstraintCollectors.sum((period, exam, room) -> exam.getTopicStudentSize()))\n+                .filter((capacity, totalStudentSize) -> totalStudentSize > capacity)\n+                .penalize(\"Room capacity too small\",\n+                          HardSoftScore.ONE_HARD,\n+                          (capacity, totalStudentSize) -> totalStudentSize - capacity);\n+    }\n+\n+    //    rule \"periodPenaltyExamCoincidence\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXAM_COINCIDENCE,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != $leftPeriod, period != null)\n+//    // Left and right don't share a student because those are filtered out in ExaminationImporter\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                      filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                      equal((periodPenalty, exam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, exam) -> exam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyExclusion\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.EXCLUSION,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriod : period, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period == $leftPeriod)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                      filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      equal((periodPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"periodPenaltyAfter\"\n+//    when\n+//    $periodPenalty : PeriodPenalty(\n+//            periodPenaltyType == PeriodPenaltyType.AFTER,\n+//            $leftTopic : leftTopic,\n+//            $rightTopic : rightTopic\n+//    )\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, $leftPeriodIndex <= periodIndex, period != null)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($leftTopic.getStudentSize() + $rightTopic.getStudentSize()));\n+//    end\n+    private Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                      equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                      filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                      equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                      lessThanOrEqual((periodPenalty, leftExam) -> leftExam.getPeriodIndex(), Exam::getPeriodIndex))\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) ->\n+                                  leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    rule \"roomPenaltyExclusive\"\n+//    when\n+//    $roomPenalty : RoomPenalty(\n+//            roomPenaltyType == RoomPenaltyType.ROOM_EXCLUSIVE,\n+//            $topic : topic\n+//    )\n+//    $leftExam : Exam(topic == $topic, $room : room, room != null, $period : period, period != null)\n+//    $rightExam : Exam(room == $room, period == $period, topic != $topic, $otherTopic : topic)\n+//    then\n+//        scoreHolder.addHardConstraintMatch(kcontext,\n+//            - ($topic.getStudentSize() + $otherTopic.getStudentSize()));\n+//    end\n+    private Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                      equal(RoomPenalty::getTopic, Exam::getTopic),\n+                      filtering((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null))\n+                .join(Exam.class,\n+                      equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                      equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod),\n+                      equal((roomPenalty, leftExam) -> leftExam.getTopic(), Exam::getTopic))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                          (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize() + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    //    // Two exams in a row which share students\n+//    rule \"twoExamsInARow\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) == 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                      filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                      filtering((topicConflict, leftExam, rightExam) -> getAbsoluteValue(leftExam, rightExam) == 1))\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT, (topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Two exams in a day which share students\n+//    rule \"twoExamsInADay\"\n+//    when\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftDayIndex : dayIndex, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, dayIndex == $leftDayIndex,\n+//                      Math.abs($leftPeriodIndex - periodIndex) > 1)\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                      filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                      filtering((topicConflict, leftExam, rightExam) -> getAbsoluteValue(leftExam, rightExam) > 1))\n+                .penalize(\"Two exams in a day\",\n+                          HardSoftScore.ONE_SOFT,\n+                          (topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Exams which share students have to few periods between them\n+//    rule \"periodSpread\"\n+//    when\n+//    $constraintConfiguration : ExaminationConstraintConfiguration()\n+//    $topicConflict : TopicConflict($leftTopic : leftTopic, $rightTopic : rightTopic)\n+//    $leftExam : Exam(topic == $leftTopic, $leftPeriodIndex : periodIndex, period != null)\n+//    $rightExam : Exam(topic == $rightTopic, period != null,\n+//                      Math.abs($leftPeriodIndex - periodIndex) < ($constraintConfiguration.getPeriodSpreadLength() + 1))\n+//    then\n+//        scoreHolder.penalize(kcontext, $topicConflict.getStudentSize());\n+//    end\n+    private Constraint periodSpread(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                      equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                      filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                      equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                      equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                      filtering((topicConflict, leftExam, rightExam) -> getAbsoluteValue(leftExam, rightExam) > 1))\n+                .penalize(\"Period spread\",\n+                          HardSoftScore.ONE_SOFT,\n+                          (topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    //    // Several exams in the same room and period have different durations\n+//    rule \"mixedDurations\"\n+//    when\n+//    $leftExam : Exam($leftId : id, period != null, $period : period, room != null, $room : room,\n+//                     $leftTopicDuration : topicDuration)\n+//    // 4 mixed durations of 100, 150, 200 and 200 should only result in 2 penalty's (for 100&150 and 100&200)\n+//    // leftExam has lowest id of the period+room combo\n+//    not Exam(period == $period, room == $room, id < $leftId)\n+//    // rightExam has a different duration\n+//    $rightExam : Exam(period == $period, room == $room, id > $leftId,\n+//                      topicDuration != $leftTopicDuration,\n+//                      $rightId : id, $rightTopicDuration : topicDuration\n+//    )\n+//    // rightExam has the lowest id of the period+room+rightDuration combo\n+//    not Exam(period == $period, room == $room, id < $rightId,\n+//            topicDuration == $rightTopicDuration\n+//    )\n+//    then\n+//        scoreHolder.penalize(kcontext);\n+//    end\n+    private Constraint mixedDurations(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .ifNotExistsOther(Exam.class,\n+                                  equal(Exam::getPeriod, Exam::getPeriod),\n+                                  equal(Exam::getRoom, Exam::getRoom),\n+                                  lessThan(Exam::getId, Exam::getId))\n+                .join(Exam.class,\n+                      equal(Exam::getPeriod),\n+                      equal(Exam::getRoom),\n+                      greaterThan(Exam::getId),\n+                      filtering((leftExam, rightExam) -> rightExam.getTopicDuration() != leftExam.getTopicDuration()))\n+                .ifNotExists(Exam.class,\n+                             equal((leftExam, rightExam) -> rightExam.getPeriod(), Exam::getPeriod),\n+                             equal((leftExam, rightExam) -> rightExam.getRoom(), Exam::getRoom),\n+                             equal((leftExam, rightExam) -> rightExam.getTopicDuration(), Exam::getTopicDuration),\n+                             greaterThan((leftExam, rightExam) -> rightExam.getId(), Exam::getId))\n+                .penalize(\"Mixed durations\", HardSoftScore.ONE_SOFT);\n+    }\n+\n+    //    // Larger Exams towards the beginning of the examination session\n+//    rule \"frontLoad\"\n+//    when\n+//    $exam : Exam(topicFrontLoadLarge == true, periodFrontLoadLast == true)\n+//    then\n+//        scoreHolder.penalize(kcontext);\n+//    end\n+    private Constraint frontLoad(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .filter(exam -> exam.isTopicFrontLoadLarge() && exam.isPeriodFrontLoadLast())\n+                .penalize(\"Front load\", HardSoftScore.ONE_SOFT);\n+    }\n+\n+    //    // Period Penalty\n+//    rule \"periodPenalty\"\n+//    when\n+//    $period : Period(penalty != 0)\n+//    $exam: Exam(period == $period)\n+//    then\n+//        scoreHolder.addSoftConstraintMatch(kcontext, - $period.getPenalty());\n+//    end\n+    private Constraint periodPenalty(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Period.class)\n+                .filter(period -> period.getPenalty() != 0)\n+                .ifExists(Exam.class, equal(Function.identity(), Exam::getPeriod))\n+                .penalize(\"Period penalty\", HardSoftScore.ONE_SOFT, Period::getPenalty);\n+    }\n+\n+    //    // Room Penalty\n+//    rule \"roomPenalty\"\n+//    when\n+//    $room : Room(penalty != 0)\n+//    $exam: Exam(room == $room)\n+//    then\n+//        scoreHolder.addSoftConstraintMatch(kcontext, - $room.getPenalty());\n+//    end\n+    private Constraint roomPenalty(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Room.class)\n+                .filter(room -> room.getPenalty() != 0)\n+                .ifExists(Exam.class, equal(Function.identity(), Exam::getRoom))\n+                .penalize(\"Room penalty\", HardSoftScore.ONE_SOFT, Room::getPenalty);\n+    }\n+\n+    private int getAbsoluteValue(Exam leftExam, Exam rightExam) {\n+        return Math.abs(leftExam.getPeriodIndex() - rightExam.getPeriodIndex());\n+    }", "originalCommit": "58619aa65d2026f4dc6957b6ef1fc271a24205f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4d9645c0ff8064317c15581721b2c778423e3896", "url": "https://github.com/kiegroup/optaplanner/commit/4d9645c0ff8064317c15581721b2c778423e3896", "message": "PLANNER-1819 Reconfigure ExaminationCSP to work similarly to drools", "committedDate": "2020-05-25T08:36:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTg2NTMzOA==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r429865338", "bodyText": "I see that there is a ConstraintConfiguration available. Yet, you still use penalize() instead of penalizeConfigurable(). I suggest you change that, @michaltomco .", "author": "triceo", "createdAt": "2020-05-25T10:38:20Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/solver/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,241 @@\n+package org.optaplanner.examples.examination.solver.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.ExaminationConstraintConfiguration;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+\n+                // Soft constraints\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    protected Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Conflicting exams in same period\",\n+                        HardSoftScore.ONE_HARD,\n+                        (topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    protected Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Room.class)\n+                .join(Exam.class, equal(Function.identity(), Exam::getRoom))\n+                .join(Period.class, equal((room, exam) -> exam.getPeriod(), Function.identity()))\n+                .groupBy((room, exam, period) -> room,\n+                        (room, exam, period) -> period,\n+                        ConstraintCollectors.sum((period, exam, room) -> exam.getTopicStudentSize()))\n+                .filter((room, period, totalStudentSize) -> totalStudentSize > room.getCapacity())\n+                .penalize(\"Room capacity too small\",\n+                        HardSoftScore.ONE_HARD,\n+                        (room, period, totalStudentSize) -> totalStudentSize - room.getCapacity());\n+    }\n+\n+    protected Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod() != rightExam.getPeriod()))\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod().equals(rightExam.getPeriod())))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam,\n+                                rightExam) -> leftExam.getPeriod().getPeriodIndex() <= rightExam.getPeriod().getPeriodIndex()))\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                        equal(RoomPenalty::getTopic, Exam::getTopic),\n+                        filtering((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null))\n+                .join(Exam.class,\n+                        equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                        equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod),\n+                        filtering((roomPenalty, leftExam, rightExam) -> leftExam.getTopic() != rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) == 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInARowPenalty());\n+    }\n+\n+    protected Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        // Find exams in a day, but not being held right after each other. That case is handled in the twoExamsInARow constraint.\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) > 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a day\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInADayPenalty());", "originalCommit": "4d9645c0ff8064317c15581721b2c778423e3896", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkwMDY5Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r429900697", "bodyText": "return constraintFactory.from(Exam.class)\n            .ifNotExists(Exam.class,\n                    equal(Exam::getPeriod),\n                    equal(Exam::getRoom),\n                    lessThan(Exam::getId))\n\nBut that won't change much, if anything.", "author": "triceo", "createdAt": "2020-05-25T12:08:27Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/solver/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,241 @@\n+package org.optaplanner.examples.examination.solver.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.ExaminationConstraintConfiguration;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+\n+                // Soft constraints\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    protected Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Conflicting exams in same period\",\n+                        HardSoftScore.ONE_HARD,\n+                        (topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    protected Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Room.class)\n+                .join(Exam.class, equal(Function.identity(), Exam::getRoom))\n+                .join(Period.class, equal((room, exam) -> exam.getPeriod(), Function.identity()))\n+                .groupBy((room, exam, period) -> room,\n+                        (room, exam, period) -> period,\n+                        ConstraintCollectors.sum((period, exam, room) -> exam.getTopicStudentSize()))\n+                .filter((room, period, totalStudentSize) -> totalStudentSize > room.getCapacity())\n+                .penalize(\"Room capacity too small\",\n+                        HardSoftScore.ONE_HARD,\n+                        (room, period, totalStudentSize) -> totalStudentSize - room.getCapacity());\n+    }\n+\n+    protected Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod() != rightExam.getPeriod()))\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod().equals(rightExam.getPeriod())))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam,\n+                                rightExam) -> leftExam.getPeriod().getPeriodIndex() <= rightExam.getPeriod().getPeriodIndex()))\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                        equal(RoomPenalty::getTopic, Exam::getTopic),\n+                        filtering((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null))\n+                .join(Exam.class,\n+                        equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                        equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod),\n+                        filtering((roomPenalty, leftExam, rightExam) -> leftExam.getTopic() != rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) == 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInARowPenalty());\n+    }\n+\n+    protected Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        // Find exams in a day, but not being held right after each other. That case is handled in the twoExamsInARow constraint.\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) > 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a day\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInADayPenalty());\n+    }\n+\n+    protected Constraint periodSpread(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ExaminationConstraintConfiguration.class)\n+                .join(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal((config, topicConflict) -> topicConflict.getLeftTopic(), Exam::getTopic),\n+                        filtering((config, topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((config, topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        filtering((config, topicConflict, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((config, topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam,\n+                                        rightExam) < (config.getPeriodSpreadLength() + 1)))\n+                .penalize(\"Period spread\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (config, topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint mixedDurations(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .ifNotExistsOther(Exam.class,\n+                        equal(Exam::getPeriod, Exam::getPeriod),\n+                        equal(Exam::getRoom, Exam::getRoom),\n+                        lessThan(Exam::getId, Exam::getId))", "originalCommit": "4d9645c0ff8064317c15581721b2c778423e3896", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkwODk3Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r429908977", "bodyText": "Also, I'd put the lessThan filter first. Will eliminate many things quickly.", "author": "triceo", "createdAt": "2020-05-25T12:28:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkwMDY5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkxMDI5Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r429910292", "bodyText": "Also, I wonder why this entire construct isn't simply .fromUniquePair(Exam.class, ...), which handles this ID lessThan/greaterThan mess.", "author": "triceo", "createdAt": "2020-05-25T12:31:21Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/solver/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,241 @@\n+package org.optaplanner.examples.examination.solver.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.ExaminationConstraintConfiguration;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+\n+                // Soft constraints\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    protected Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Conflicting exams in same period\",\n+                        HardSoftScore.ONE_HARD,\n+                        (topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    protected Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Room.class)\n+                .join(Exam.class, equal(Function.identity(), Exam::getRoom))\n+                .join(Period.class, equal((room, exam) -> exam.getPeriod(), Function.identity()))\n+                .groupBy((room, exam, period) -> room,\n+                        (room, exam, period) -> period,\n+                        ConstraintCollectors.sum((period, exam, room) -> exam.getTopicStudentSize()))\n+                .filter((room, period, totalStudentSize) -> totalStudentSize > room.getCapacity())\n+                .penalize(\"Room capacity too small\",\n+                        HardSoftScore.ONE_HARD,\n+                        (room, period, totalStudentSize) -> totalStudentSize - room.getCapacity());\n+    }\n+\n+    protected Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod() != rightExam.getPeriod()))\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod().equals(rightExam.getPeriod())))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam,\n+                                rightExam) -> leftExam.getPeriod().getPeriodIndex() <= rightExam.getPeriod().getPeriodIndex()))\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                        equal(RoomPenalty::getTopic, Exam::getTopic),\n+                        filtering((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null))\n+                .join(Exam.class,\n+                        equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                        equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod),\n+                        filtering((roomPenalty, leftExam, rightExam) -> leftExam.getTopic() != rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) == 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInARowPenalty());\n+    }\n+\n+    protected Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        // Find exams in a day, but not being held right after each other. That case is handled in the twoExamsInARow constraint.\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) > 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a day\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInADayPenalty());\n+    }\n+\n+    protected Constraint periodSpread(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ExaminationConstraintConfiguration.class)\n+                .join(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal((config, topicConflict) -> topicConflict.getLeftTopic(), Exam::getTopic),\n+                        filtering((config, topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((config, topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        filtering((config, topicConflict, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((config, topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam,\n+                                        rightExam) < (config.getPeriodSpreadLength() + 1)))\n+                .penalize(\"Period spread\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (config, topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint mixedDurations(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .ifNotExistsOther(Exam.class,\n+                        equal(Exam::getPeriod, Exam::getPeriod),\n+                        equal(Exam::getRoom, Exam::getRoom),\n+                        lessThan(Exam::getId, Exam::getId))\n+                .join(Exam.class,\n+                        equal(Exam::getPeriod),\n+                        equal(Exam::getRoom),\n+                        greaterThan(Exam::getId),\n+                        filtering((leftExam, rightExam) -> rightExam.getTopicDuration() != leftExam.getTopicDuration()))", "originalCommit": "4d9645c0ff8064317c15581721b2c778423e3896", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkxMTU0OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r429911549", "bodyText": "Why not .filter(exam -> exam.getPeriod().getPenalty() != 0)?", "author": "triceo", "createdAt": "2020-05-25T12:34:28Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/solver/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,241 @@\n+package org.optaplanner.examples.examination.solver.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.ExaminationConstraintConfiguration;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+\n+                // Soft constraints\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    protected Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Conflicting exams in same period\",\n+                        HardSoftScore.ONE_HARD,\n+                        (topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    protected Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Room.class)\n+                .join(Exam.class, equal(Function.identity(), Exam::getRoom))\n+                .join(Period.class, equal((room, exam) -> exam.getPeriod(), Function.identity()))\n+                .groupBy((room, exam, period) -> room,\n+                        (room, exam, period) -> period,\n+                        ConstraintCollectors.sum((period, exam, room) -> exam.getTopicStudentSize()))\n+                .filter((room, period, totalStudentSize) -> totalStudentSize > room.getCapacity())\n+                .penalize(\"Room capacity too small\",\n+                        HardSoftScore.ONE_HARD,\n+                        (room, period, totalStudentSize) -> totalStudentSize - room.getCapacity());\n+    }\n+\n+    protected Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod() != rightExam.getPeriod()))\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod().equals(rightExam.getPeriod())))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam,\n+                                rightExam) -> leftExam.getPeriod().getPeriodIndex() <= rightExam.getPeriod().getPeriodIndex()))\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                        equal(RoomPenalty::getTopic, Exam::getTopic),\n+                        filtering((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null))\n+                .join(Exam.class,\n+                        equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                        equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod),\n+                        filtering((roomPenalty, leftExam, rightExam) -> leftExam.getTopic() != rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) == 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInARowPenalty());\n+    }\n+\n+    protected Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        // Find exams in a day, but not being held right after each other. That case is handled in the twoExamsInARow constraint.\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) > 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a day\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInADayPenalty());\n+    }\n+\n+    protected Constraint periodSpread(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ExaminationConstraintConfiguration.class)\n+                .join(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal((config, topicConflict) -> topicConflict.getLeftTopic(), Exam::getTopic),\n+                        filtering((config, topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((config, topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        filtering((config, topicConflict, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((config, topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam,\n+                                        rightExam) < (config.getPeriodSpreadLength() + 1)))\n+                .penalize(\"Period spread\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (config, topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint mixedDurations(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .ifNotExistsOther(Exam.class,\n+                        equal(Exam::getPeriod, Exam::getPeriod),\n+                        equal(Exam::getRoom, Exam::getRoom),\n+                        lessThan(Exam::getId, Exam::getId))\n+                .join(Exam.class,\n+                        equal(Exam::getPeriod),\n+                        equal(Exam::getRoom),\n+                        greaterThan(Exam::getId),\n+                        filtering((leftExam, rightExam) -> rightExam.getTopicDuration() != leftExam.getTopicDuration()))\n+                .ifNotExists(Exam.class,\n+                        equal((leftExam, rightExam) -> rightExam.getPeriod(), Exam::getPeriod),\n+                        equal((leftExam, rightExam) -> rightExam.getRoom(), Exam::getRoom),\n+                        equal((leftExam, rightExam) -> rightExam.getTopicDuration(), Exam::getTopicDuration),\n+                        greaterThan((leftExam, rightExam) -> rightExam.getId(), Exam::getId))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Mixed durations\", HardSoftScore.ONE_SOFT,\n+                        (leftExam, rightExam, config) -> config.getMixedDurationPenalty());\n+    }\n+\n+    protected Constraint frontLoad(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ExaminationConstraintConfiguration.class)\n+                .join(Exam.class,\n+                        filtering((config, exam) -> exam.isTopicFrontLoadLarge() && exam.isPeriodFrontLoadLast()))\n+                .penalize(\"Front load\", HardSoftScore.ONE_SOFT, (config, exam) -> config.getFrontLoadPenalty());\n+    }\n+\n+    protected Constraint periodPenalty(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Period.class,\n+                        equal(Exam::getPeriod, Function.identity()),\n+                        filtering((exam, period) -> period.getPenalty() != 0))", "originalCommit": "4d9645c0ff8064317c15581721b2c778423e3896", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkxMTk0Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r429911943", "bodyText": "All uses of from/join on ExaminationConstraintConfiguration should theoretically be removable when converted to penalizeConfigurable().", "author": "triceo", "createdAt": "2020-05-25T12:35:27Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/solver/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,241 @@\n+package org.optaplanner.examples.examination.solver.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.ExaminationConstraintConfiguration;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+\n+                // Soft constraints\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    protected Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Conflicting exams in same period\",\n+                        HardSoftScore.ONE_HARD,\n+                        (topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    protected Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Room.class)\n+                .join(Exam.class, equal(Function.identity(), Exam::getRoom))\n+                .join(Period.class, equal((room, exam) -> exam.getPeriod(), Function.identity()))\n+                .groupBy((room, exam, period) -> room,\n+                        (room, exam, period) -> period,\n+                        ConstraintCollectors.sum((period, exam, room) -> exam.getTopicStudentSize()))\n+                .filter((room, period, totalStudentSize) -> totalStudentSize > room.getCapacity())\n+                .penalize(\"Room capacity too small\",\n+                        HardSoftScore.ONE_HARD,\n+                        (room, period, totalStudentSize) -> totalStudentSize - room.getCapacity());\n+    }\n+\n+    protected Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod() != rightExam.getPeriod()))\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod().equals(rightExam.getPeriod())))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam,\n+                                rightExam) -> leftExam.getPeriod().getPeriodIndex() <= rightExam.getPeriod().getPeriodIndex()))\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                        equal(RoomPenalty::getTopic, Exam::getTopic),\n+                        filtering((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null))\n+                .join(Exam.class,\n+                        equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                        equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod),\n+                        filtering((roomPenalty, leftExam, rightExam) -> leftExam.getTopic() != rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) == 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInARowPenalty());\n+    }\n+\n+    protected Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        // Find exams in a day, but not being held right after each other. That case is handled in the twoExamsInARow constraint.\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) > 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a day\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInADayPenalty());\n+    }\n+\n+    protected Constraint periodSpread(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ExaminationConstraintConfiguration.class)\n+                .join(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal((config, topicConflict) -> topicConflict.getLeftTopic(), Exam::getTopic),\n+                        filtering((config, topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((config, topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        filtering((config, topicConflict, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((config, topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam,\n+                                        rightExam) < (config.getPeriodSpreadLength() + 1)))\n+                .penalize(\"Period spread\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (config, topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint mixedDurations(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .ifNotExistsOther(Exam.class,\n+                        equal(Exam::getPeriod, Exam::getPeriod),\n+                        equal(Exam::getRoom, Exam::getRoom),\n+                        lessThan(Exam::getId, Exam::getId))\n+                .join(Exam.class,\n+                        equal(Exam::getPeriod),\n+                        equal(Exam::getRoom),\n+                        greaterThan(Exam::getId),\n+                        filtering((leftExam, rightExam) -> rightExam.getTopicDuration() != leftExam.getTopicDuration()))\n+                .ifNotExists(Exam.class,\n+                        equal((leftExam, rightExam) -> rightExam.getPeriod(), Exam::getPeriod),\n+                        equal((leftExam, rightExam) -> rightExam.getRoom(), Exam::getRoom),\n+                        equal((leftExam, rightExam) -> rightExam.getTopicDuration(), Exam::getTopicDuration),\n+                        greaterThan((leftExam, rightExam) -> rightExam.getId(), Exam::getId))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Mixed durations\", HardSoftScore.ONE_SOFT,\n+                        (leftExam, rightExam, config) -> config.getMixedDurationPenalty());\n+    }\n+\n+    protected Constraint frontLoad(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ExaminationConstraintConfiguration.class)", "originalCommit": "4d9645c0ff8064317c15581721b2c778423e3896", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkxMjIwOA==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r429912208", "bodyText": "Ditto. It appears you have a Room reference on Exam directly.", "author": "triceo", "createdAt": "2020-05-25T12:36:06Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/solver/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,241 @@\n+package org.optaplanner.examples.examination.solver.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.ExaminationConstraintConfiguration;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+\n+                // Soft constraints\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    protected Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Conflicting exams in same period\",\n+                        HardSoftScore.ONE_HARD,\n+                        (topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)\n+                .filter(exam -> exam.getTopicDuration() > exam.getPeriodDuration())\n+                .penalize(\"Period duration too short\", HardSoftScore.ONE_HARD, Exam::getTopicStudentSize);\n+    }\n+\n+    protected Constraint roomCapacityTooSmall(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Room.class)\n+                .join(Exam.class, equal(Function.identity(), Exam::getRoom))\n+                .join(Period.class, equal((room, exam) -> exam.getPeriod(), Function.identity()))\n+                .groupBy((room, exam, period) -> room,\n+                        (room, exam, period) -> period,\n+                        ConstraintCollectors.sum((period, exam, room) -> exam.getTopicStudentSize()))\n+                .filter((room, period, totalStudentSize) -> totalStudentSize > room.getCapacity())\n+                .penalize(\"Room capacity too small\",\n+                        HardSoftScore.ONE_HARD,\n+                        (room, period, totalStudentSize) -> totalStudentSize - room.getCapacity());\n+    }\n+\n+    protected Constraint periodPenaltyExamCoincidence(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXAM_COINCIDENCE)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod() != rightExam.getPeriod()))\n+                .penalize(\"Period penalty exam coincidence\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyExclusion(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.EXCLUSION)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam, rightExam) -> leftExam.getPeriod().equals(rightExam.getPeriod())))\n+                .penalize(\"Period penalty exclusion\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint periodPenaltyAfter(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PeriodPenalty.class)\n+                .filter(periodPenalty -> periodPenalty.getPeriodPenaltyType() == PeriodPenaltyType.AFTER)\n+                .join(Exam.class,\n+                        equal(PeriodPenalty::getLeftTopic, Exam::getTopic),\n+                        filtering((periodPenalty, leftExam) -> leftExam.getPeriod() != null))\n+                .join(Exam.class,\n+                        equal((periodPenalty, leftExam) -> periodPenalty.getRightTopic(), Exam::getTopic),\n+                        filtering((periodPenalty, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((periodPenalty, leftExam,\n+                                rightExam) -> leftExam.getPeriod().getPeriodIndex() <= rightExam.getPeriod().getPeriodIndex()))\n+                .penalize(\"Period penalty after\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint roomPenaltyExclusive(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RoomPenalty.class)\n+                .filter(roomPenalty -> roomPenalty.getRoomPenaltyType() == RoomPenaltyType.ROOM_EXCLUSIVE)\n+                .join(Exam.class,\n+                        equal(RoomPenalty::getTopic, Exam::getTopic),\n+                        filtering((roomPenalty, leftExam) -> leftExam.getPeriod() != null && leftExam.getRoom() != null))\n+                .join(Exam.class,\n+                        equal((roomPenalty, leftExam) -> leftExam.getRoom(), Exam::getRoom),\n+                        equal((roomPenalty, leftExam) -> leftExam.getPeriod(), Exam::getPeriod),\n+                        filtering((roomPenalty, leftExam, rightExam) -> leftExam.getTopic() != rightExam.getTopic()))\n+                .penalize(\"Room penalty exclusive\", HardSoftScore.ONE_HARD,\n+                        (periodPenalty, leftExam, rightExam) -> leftExam.getTopic().getStudentSize()\n+                                + rightExam.getTopic().getStudentSize());\n+    }\n+\n+    protected Constraint twoExamsInARow(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) == 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a row\", HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInARowPenalty());\n+    }\n+\n+    protected Constraint twoExamsInADay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getDayIndex(), Exam::getDayIndex),\n+                        // Find exams in a day, but not being held right after each other. That case is handled in the twoExamsInARow constraint.\n+                        filtering((topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam, rightExam) > 1))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Two exams in a day\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (topicConflict, leftExam, config) -> topicConflict.getStudentSize() * config.getTwoInADayPenalty());\n+    }\n+\n+    protected Constraint periodSpread(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ExaminationConstraintConfiguration.class)\n+                .join(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal((config, topicConflict) -> topicConflict.getLeftTopic(), Exam::getTopic),\n+                        filtering((config, topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((config, topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        filtering((config, topicConflict, leftExam, rightExam) -> rightExam.getPeriod() != null),\n+                        filtering((config, topicConflict, leftExam,\n+                                rightExam) -> getPeriodIndexDifferenceBetweenExams(leftExam,\n+                                        rightExam) < (config.getPeriodSpreadLength() + 1)))\n+                .penalize(\"Period spread\",\n+                        HardSoftScore.ONE_SOFT,\n+                        (config, topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint mixedDurations(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Exam.class, equal(Exam::getPeriod, Exam::getPeriod))\n+                .ifNotExistsOther(Exam.class,\n+                        equal(Exam::getPeriod, Exam::getPeriod),\n+                        equal(Exam::getRoom, Exam::getRoom),\n+                        lessThan(Exam::getId, Exam::getId))\n+                .join(Exam.class,\n+                        equal(Exam::getPeriod),\n+                        equal(Exam::getRoom),\n+                        greaterThan(Exam::getId),\n+                        filtering((leftExam, rightExam) -> rightExam.getTopicDuration() != leftExam.getTopicDuration()))\n+                .ifNotExists(Exam.class,\n+                        equal((leftExam, rightExam) -> rightExam.getPeriod(), Exam::getPeriod),\n+                        equal((leftExam, rightExam) -> rightExam.getRoom(), Exam::getRoom),\n+                        equal((leftExam, rightExam) -> rightExam.getTopicDuration(), Exam::getTopicDuration),\n+                        greaterThan((leftExam, rightExam) -> rightExam.getId(), Exam::getId))\n+                .join(ExaminationConstraintConfiguration.class)\n+                .penalize(\"Mixed durations\", HardSoftScore.ONE_SOFT,\n+                        (leftExam, rightExam, config) -> config.getMixedDurationPenalty());\n+    }\n+\n+    protected Constraint frontLoad(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(ExaminationConstraintConfiguration.class)\n+                .join(Exam.class,\n+                        filtering((config, exam) -> exam.isTopicFrontLoadLarge() && exam.isPeriodFrontLoadLast()))\n+                .penalize(\"Front load\", HardSoftScore.ONE_SOFT, (config, exam) -> config.getFrontLoadPenalty());\n+    }\n+\n+    protected Constraint periodPenalty(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Period.class,\n+                        equal(Exam::getPeriod, Function.identity()),\n+                        filtering((exam, period) -> period.getPenalty() != 0))\n+                .penalize(\"Period penalty\", HardSoftScore.ONE_SOFT, exam -> exam.getPeriod().getPenalty());\n+    }\n+\n+    protected Constraint roomPenalty(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Exam.class)\n+                .ifExists(Room.class,\n+                        equal(Exam::getRoom, Function.identity()),\n+                        filtering((exam, room) -> room.getPenalty() != 0))", "originalCommit": "4d9645c0ff8064317c15581721b2c778423e3896", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTkxMzMzMA==", "url": "https://github.com/kiegroup/optaplanner/pull/704#discussion_r429913330", "bodyText": "Why fromUnfiltered(), if you then filter anyway?", "author": "triceo", "createdAt": "2020-05-25T12:38:59Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/examination/solver/score/ExaminationConstraintProvider.java", "diffHunk": "@@ -0,0 +1,241 @@\n+package org.optaplanner.examples.examination.solver.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardsoft.HardSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintCollectors;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.examination.domain.Exam;\n+import org.optaplanner.examples.examination.domain.ExaminationConstraintConfiguration;\n+import org.optaplanner.examples.examination.domain.Period;\n+import org.optaplanner.examples.examination.domain.PeriodPenalty;\n+import org.optaplanner.examples.examination.domain.PeriodPenaltyType;\n+import org.optaplanner.examples.examination.domain.Room;\n+import org.optaplanner.examples.examination.domain.RoomPenalty;\n+import org.optaplanner.examples.examination.domain.RoomPenaltyType;\n+import org.optaplanner.examples.examination.domain.solver.TopicConflict;\n+\n+public class ExaminationConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                // Hard constraints\n+                conflictingExamsInSamePeriod(constraintFactory),\n+                periodDurationTooShort(constraintFactory),\n+                roomCapacityTooSmall(constraintFactory),\n+                periodPenaltyExamCoincidence(constraintFactory),\n+                periodPenaltyExclusion(constraintFactory),\n+                periodPenaltyAfter(constraintFactory),\n+                roomPenaltyExclusive(constraintFactory),\n+\n+                // Soft constraints\n+                twoExamsInARow(constraintFactory),\n+                twoExamsInADay(constraintFactory),\n+                periodSpread(constraintFactory),\n+                mixedDurations(constraintFactory),\n+                frontLoad(constraintFactory),\n+                periodPenalty(constraintFactory),\n+                roomPenalty(constraintFactory)\n+        };\n+    }\n+\n+    protected Constraint conflictingExamsInSamePeriod(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(TopicConflict.class)\n+                .join(Exam.class,\n+                        equal(TopicConflict::getLeftTopic, Exam::getTopic),\n+                        filtering((topicConflict, leftExam) -> leftExam.getPeriod() != null))\n+                .ifExists(Exam.class,\n+                        equal((topicConflict, leftExam) -> topicConflict.getRightTopic(), Exam::getTopic),\n+                        equal((topicConflict, leftExam) -> leftExam.getPeriod(), Exam::getPeriod))\n+                .penalize(\"Conflicting exams in same period\",\n+                        HardSoftScore.ONE_HARD,\n+                        (topicConflict, leftExam) -> topicConflict.getStudentSize());\n+    }\n+\n+    protected Constraint periodDurationTooShort(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(Exam.class)\n+                .filter(exam -> exam.getPeriod() != null)", "originalCommit": "4d9645c0ff8064317c15581721b2c778423e3896", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "87b5db515d21734a45543542d19cb59a12223fe0", "url": "https://github.com/kiegroup/optaplanner/commit/87b5db515d21734a45543542d19cb59a12223fe0", "message": "PLANNER-1819 Address PR comments and alter string names to work with config", "committedDate": "2020-05-26T08:24:39Z", "type": "forcePushed"}, {"oid": "acc69ee999e3cd06bf5e28bbfca25e0d4ed45ec7", "url": "https://github.com/kiegroup/optaplanner/commit/acc69ee999e3cd06bf5e28bbfca25e0d4ed45ec7", "message": "PLANNER-1819 Add Examination CSProvider\n\nAdd a constraint stream provider for the Examination example.", "committedDate": "2020-06-10T14:29:45Z", "type": "forcePushed"}, {"oid": "d56b11430e04a572b7f0cc69a6969325f291c2cc", "url": "https://github.com/kiegroup/optaplanner/commit/d56b11430e04a572b7f0cc69a6969325f291c2cc", "message": "PLANNER-1819 Add Examination CSProvider\n\nAdd a constraint stream provider for the Examination example.", "committedDate": "2020-06-11T07:10:37Z", "type": "forcePushed"}, {"oid": "49cb65927e83ed2d38030da82883da78de23f9ea", "url": "https://github.com/kiegroup/optaplanner/commit/49cb65927e83ed2d38030da82883da78de23f9ea", "message": "PLANNER-1819 Add Examination CSProvider\n\nAdd a constraint stream provider for the Examination example.", "committedDate": "2020-06-11T07:15:01Z", "type": "forcePushed"}, {"oid": "6b7c60c3795d57ba204265f898ff5304e4210dd7", "url": "https://github.com/kiegroup/optaplanner/commit/6b7c60c3795d57ba204265f898ff5304e4210dd7", "message": "PLANNER-1819 Add Examination CSProvider\n\nAdd a constraint stream provider for the Examination example.", "committedDate": "2020-06-11T09:56:56Z", "type": "forcePushed"}, {"oid": "85fd360b8efdfd269debd87dc407e1bb84dda4ef", "url": "https://github.com/kiegroup/optaplanner/commit/85fd360b8efdfd269debd87dc407e1bb84dda4ef", "message": "PLANNER-1819 Add Examination CSProvider\n\nAdd a constraint stream provider for the Examination example.", "committedDate": "2020-06-11T09:58:22Z", "type": "commit"}, {"oid": "85fd360b8efdfd269debd87dc407e1bb84dda4ef", "url": "https://github.com/kiegroup/optaplanner/commit/85fd360b8efdfd269debd87dc407e1bb84dda4ef", "message": "PLANNER-1819 Add Examination CSProvider\n\nAdd a constraint stream provider for the Examination example.", "committedDate": "2020-06-11T09:58:22Z", "type": "forcePushed"}]}