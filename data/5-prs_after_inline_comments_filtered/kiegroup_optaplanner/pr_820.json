{"pr_number": 820, "pr_title": "PLANNER-2065 Refactor CS-D for greater flexibility", "pr_createdAt": "2020-07-01T10:24:42Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/820", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODI2OTEzNA==", "url": "https://github.com/kiegroup/optaplanner/pull/820#discussion_r448269134", "bodyText": "The only use of fromStreamList() was in this toString().\nTherefore I removed it.", "author": "triceo", "createdAt": "2020-07-01T10:27:13Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/DroolsConstraint.java", "diffHunk": "@@ -77,6 +72,6 @@ public int getExpectedJustificationCount() {\n \n     @Override\n     public String toString() {\n-        return \"DroolsConstraint(\" + getConstraintId() + \") in \" + fromStreamList.size() + \" from() stream(s)\";\n+        return \"DroolsConstraint(\" + getConstraintId() + \")\";", "originalCommit": "8af3252acc12eca9501af6010c8bbb31ebe6608a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5757494a03fb12f31b1a41d979c2467e0d0b574c", "url": "https://github.com/kiegroup/optaplanner/commit/5757494a03fb12f31b1a41d979c2467e0d0b574c", "message": "Implement consequence model", "committedDate": "2020-07-01T12:10:59Z", "type": "forcePushed"}, {"oid": "c0bed3f80842f14bce6b9f5ebdaf4c4b527a7dd2", "url": "https://github.com/kiegroup/optaplanner/commit/c0bed3f80842f14bce6b9f5ebdaf4c4b527a7dd2", "message": "Model should not be doing fancy things", "committedDate": "2020-07-01T16:41:34Z", "type": "forcePushed"}, {"oid": "8255317b3a8f3ffe4caef6900546356ff846382d", "url": "https://github.com/kiegroup/optaplanner/commit/8255317b3a8f3ffe4caef6900546356ff846382d", "message": "Model should not be doing fancy things", "committedDate": "2020-07-01T16:49:52Z", "type": "forcePushed"}, {"oid": "82c3752e811a52b68cb5781da79859ce0c9a5ca1", "url": "https://github.com/kiegroup/optaplanner/commit/82c3752e811a52b68cb5781da79859ce0c9a5ca1", "message": "Model should not be doing fancy things", "committedDate": "2020-07-01T16:53:41Z", "type": "forcePushed"}, {"oid": "ffc0a556e6b7ff69b1619543eec3fcf58b9fea9b", "url": "https://github.com/kiegroup/optaplanner/commit/ffc0a556e6b7ff69b1619543eec3fcf58b9fea9b", "message": "Constraint tree", "committedDate": "2020-07-02T09:43:53Z", "type": "forcePushed"}, {"oid": "07dcd5ce69569076382521e667992816917a107d", "url": "https://github.com/kiegroup/optaplanner/commit/07dcd5ce69569076382521e667992816917a107d", "message": "Fix default match weights (324 tests fail)", "committedDate": "2020-07-13T15:35:02Z", "type": "forcePushed"}, {"oid": "838f4538603ad63a1fa77881e27be5de35757678", "url": "https://github.com/kiegroup/optaplanner/commit/838f4538603ad63a1fa77881e27be5de35757678", "message": "BiJoin (264 tests fail)", "committedDate": "2020-07-14T09:37:17Z", "type": "forcePushed"}, {"oid": "d4472371509a2c4fc71628dfda2b93cb13774b1f", "url": "https://github.com/kiegroup/optaplanner/commit/d4472371509a2c4fc71628dfda2b93cb13774b1f", "message": "Fix filtering in higher cardinalities (96 tests fail)", "committedDate": "2020-07-14T15:44:33Z", "type": "forcePushed"}, {"oid": "09f43d5931ae5f7b23b2258a6de65e6d37e83555", "url": "https://github.com/kiegroup/optaplanner/commit/09f43d5931ae5f7b23b2258a6de65e6d37e83555", "message": "Basic uni groupBy (78 tests fail)", "committedDate": "2020-07-15T11:48:49Z", "type": "forcePushed"}, {"oid": "6958686e19be49c90052275795059ea6b4867cad", "url": "https://github.com/kiegroup/optaplanner/commit/6958686e19be49c90052275795059ea6b4867cad", "message": "Quad grouping is complete (12 tests fail)", "committedDate": "2020-07-16T09:50:01Z", "type": "forcePushed"}, {"oid": "dd118b435d738e7fc8239d3d8c505170eb3acc1e", "url": "https://github.com/kiegroup/optaplanner/commit/dd118b435d738e7fc8239d3d8c505170eb3acc1e", "message": "Move stuff around", "committedDate": "2020-07-16T13:41:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI4NzYwMg==", "url": "https://github.com/kiegroup/optaplanner/pull/820#discussion_r456287602", "bodyText": "Where do these classNames come from?\nWhy are we receiving them as Strings?", "author": "ge0ffrey", "createdAt": "2020-07-17T08:08:55Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/DroolsConstraintSessionFactory.java", "diffHunk": "@@ -70,50 +72,20 @@ public DroolsConstraintSessionFactory(SolutionDescriptor<Solution_> solutionDesc\n                         .findFirst()\n                         .orElseThrow(() -> new IllegalStateException(\"Programming error: Rule for constraint (\" +\n                                 constraint + \") not found.\"))));\n-    }\n-\n-    @Override\n-    public ConstraintSession<Solution_> buildSession(boolean constraintMatchEnabled, Solution_ workingSolution) {\n-        // Make sure the constraint justifications match what comes out of Bavet.\n-        AbstractScoreHolder scoreHolder = getScoreDefinition().buildScoreHolder(constraintMatchEnabled);\n-        scoreHolder.setJustificationListConverter(\n-                (justificationList, rule) -> {\n-                    DroolsConstraint<Solution_> constraint = compiledRuleToConstraintMap.get(rule);\n-                    return matchJustificationsToOutput((List<Object>) justificationList,\n-                            constraint.getExpectedJustificationCount(),\n-                            constraint.getExpectedJustificationTypes());\n-                });\n-        // Determine which rules to enable based on the fact that their constraints carry weight.\n-        Score<?> zeroScore = getScoreDefinition().getZeroScore();\n-        Set<String> disabledConstraintIdSet = new LinkedHashSet<>(0);\n-        compiledRuleToConstraintMap.forEach((compiledRule, constraint) -> {\n-            Score<?> constraintWeight = constraint.extractConstraintWeight(workingSolution);\n-            scoreHolder.configureConstraintWeight(compiledRule, constraintWeight);\n-            if (constraintWeight.equals(zeroScore)) {\n-                disabledConstraintIdSet.add(constraint.getConstraintId());\n-            }\n-        });\n-        // Determine the KieBase to use.\n-        if (disabledConstraintIdSet.isEmpty()) { // Shortcut; don't change the original KieBase.\n-            currentKieBase = originalKieBase;\n-            currentlyDisabledConstraintIdSet = null;\n-        } else if (!disabledConstraintIdSet.equals(currentlyDisabledConstraintIdSet)) {\n-            // Only rebuild the active KieBase when the set of disabled constraints changed.\n-            ModelImpl model = new ModelImpl().withGlobals(originalModel.getGlobals());\n-            constraintToModelRuleMap.forEach((constraintId, modelRule) -> {\n-                if (disabledConstraintIdSet.contains(constraintId)) {\n-                    return;\n-                }\n-                model.addRule(modelRule);\n-            });\n-            currentKieBase = KieBaseBuilder.createKieBaseFromModel(model);\n-            currentlyDisabledConstraintIdSet = disabledConstraintIdSet;\n-        }\n-        // Create the session itself.\n-        KieSession kieSession = currentKieBase.newKieSession();\n-        ((RuleEventManager) kieSession).addEventListener(new OptaPlannerRuleEventListener()); // Enables undo in rules.\n-        kieSession.setGlobal(DroolsScoreDirector.GLOBAL_SCORE_HOLDER_KEY, scoreHolder);\n-        return new DroolsConstraintSession<>(kieSession, scoreHolder);\n+        this.compiledRuleToExpectedTypesMap = compiledRuleToConstraintMap.keySet().stream()\n+                .collect(Collectors.toMap(Function.identity(), rule -> {\n+                    String commaSeparatedFqnList = (String) rule.getMetaData().getOrDefault(\n+                            RuleAssembler.VARIABLE_TYPE_RULE_METADATA_KEY, \"\");\n+                    return Arrays.stream(commaSeparatedFqnList.split(\"\\\\Q,\\\\E\"))\n+                            .map(className -> {\n+                                try {\n+                                    return Class.forName(className.trim());", "originalCommit": "cae85a6935e468bddde8164db34bf2fff0ab7e92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwNjkzNA==", "url": "https://github.com/kiegroup/optaplanner/pull/820#discussion_r456306934", "bodyText": "It comes from here: https://github.com/kiegroup/optaplanner/pull/820/files#diff-ebd21b451df70a2dceb49bbea389ef3eR196\nIt's a way of bypassing several levels of class hierarchy and the breaking of abstraction that it would cause.\nI'll try once more to figure out a way to do it in a cleaner way, but I was already unsuccessful the first time around.", "author": "triceo", "createdAt": "2020-07-17T08:45:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI4NzYwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5MDAyOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/820#discussion_r456290029", "bodyText": "Can the user trigger this error?\nIf not, prefix the error message with \"Impossible state\", so for example \"Impossible state: the nodeList must not be empty.\" It signals that we're 100% sure that if any user sees this, it is an OptaPlanner bug, never their fault.", "author": "ge0ffrey", "createdAt": "2020-07-17T08:13:43Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/ConstraintSubTree.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.drools.common;\n+\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.FROM;\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.GROUPBY_COLLECTING_ONLY;\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.GROUPBY_MAPPING_AND_COLLECTING;\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.GROUPBY_MAPPING_ONLY;\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.JOIN;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNode;\n+import org.optaplanner.core.impl.score.stream.drools.common.rules.RuleAssembler;\n+\n+final class ConstraintSubTree {\n+\n+    private final boolean isJoin;\n+    private final ConstraintSubTree leftSubTree;\n+    private final ConstraintSubTree rightSubTree;\n+    private final List<ConstraintGraphNode> nodes;\n+\n+    public ConstraintSubTree(List<ConstraintGraphNode> nodesWithoutJoin) {\n+        this.isJoin = false;\n+        this.leftSubTree = null;\n+        this.rightSubTree = null;\n+        this.nodes = Collections.unmodifiableList(nodesWithoutJoin);\n+        if (nodes.isEmpty()) {\n+            throw new IllegalStateException(\"Node list may not be empty.\");\n+        }\n+        if (nodes.get(0).getType() != FROM) {\n+            throw new IllegalStateException(\"First node is not a From (\" + nodes.get(0) + \").\");\n+        }\n+    }\n+\n+    public ConstraintSubTree(ConstraintSubTree leftSubTree, ConstraintSubTree rightSubTree,\n+            List<ConstraintGraphNode> joinAndOtherNodes) {\n+        this.isJoin = true;\n+        this.leftSubTree = Objects.requireNonNull(leftSubTree);\n+        this.rightSubTree = Objects.requireNonNull(rightSubTree);\n+        this.nodes = Collections.unmodifiableList(joinAndOtherNodes);\n+        if (nodes.isEmpty()) {\n+            throw new IllegalStateException(\"Node list may not be empty.\");", "originalCommit": "cae85a6935e468bddde8164db34bf2fff0ab7e92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwNTM5MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/820#discussion_r456305391", "bodyText": "Yeah, there will be more places like that in this code. I'll go over it again.", "author": "triceo", "createdAt": "2020-07-17T08:42:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5MDAyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5MDM4OA==", "url": "https://github.com/kiegroup/optaplanner/pull/820#discussion_r456290388", "bodyText": "nodeList for consistency with all other code? :)", "author": "ge0ffrey", "createdAt": "2020-07-17T08:14:25Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/ConstraintSubTree.java", "diffHunk": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.drools.common;\n+\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.FROM;\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.GROUPBY_COLLECTING_ONLY;\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.GROUPBY_MAPPING_AND_COLLECTING;\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.GROUPBY_MAPPING_ONLY;\n+import static org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType.JOIN;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNode;\n+import org.optaplanner.core.impl.score.stream.drools.common.rules.RuleAssembler;\n+\n+final class ConstraintSubTree {\n+\n+    private final boolean isJoin;\n+    private final ConstraintSubTree leftSubTree;\n+    private final ConstraintSubTree rightSubTree;\n+    private final List<ConstraintGraphNode> nodes;", "originalCommit": "cae85a6935e468bddde8164db34bf2fff0ab7e92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5MTI0Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/820#discussion_r456291242", "bodyText": "Stack is a relic from Java 1.0, just like Vector.\nVector was replaced by (Array)List\nStack was replaced by (Array)Deque", "author": "ge0ffrey", "createdAt": "2020-07-17T08:15:58Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/ConstraintTree.java", "diffHunk": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.drools.common;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Stack;\n+\n+import org.optaplanner.core.impl.score.stream.drools.common.consequences.ConstraintConsequence;\n+import org.optaplanner.core.impl.score.stream.drools.common.nodes.ChildNode;\n+import org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNode;\n+import org.optaplanner.core.impl.score.stream.drools.common.nodes.ConstraintGraphNodeType;\n+\n+final class ConstraintTree<Node_ extends ConstraintGraphNode, Consequence_ extends ConstraintConsequence<Node_>> {\n+\n+    private final ConstraintSubTree nestedNodes;\n+\n+    ConstraintTree(Consequence_ consequence) {\n+        List<ConstraintGraphNode> orderedNodeList = orderNodes(consequence);\n+        this.nestedNodes = assembleSubTree(orderedNodeList);\n+        ConstraintGraphNode firstNode = orderedNodeList.get(0);\n+        if (firstNode.getType() != ConstraintGraphNodeType.FROM) {\n+            throw new IllegalStateException(\"First node (\" + firstNode + \") is not a \" + ConstraintGraphNodeType.FROM +\n+                    \" (\" + firstNode.getType() + \").\");\n+        }\n+        ConstraintGraphNode lastNode = orderedNodeList.get(orderedNodeList.size() - 1);\n+        if (lastNode != consequence.getTerminalNode()) {\n+            throw new IllegalStateException(\"Last node (\" + lastNode + \") is not the terminal node (\" +\n+                    consequence.getTerminalNode() + \").\");\n+        }\n+    }\n+\n+    private List<ConstraintGraphNode> orderNodes(Consequence_ consequence) {\n+        // Depth-first search, right parents of join nodes get precedence.\n+        List<ConstraintGraphNode> nodeList = new ArrayList<>(0);\n+        Stack<ConstraintGraphNode> unprocessedNodes = new Stack<>();", "originalCommit": "cae85a6935e468bddde8164db34bf2fff0ab7e92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5Mjg4OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/820#discussion_r456292889", "bodyText": "Seems a bit fishy: A list (naming btw) that is converted into an array that is then copied partially", "author": "ge0ffrey", "createdAt": "2020-07-17T08:19:09Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/rules/AbstractGroupByMutator.java", "diffHunk": "@@ -0,0 +1,225 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.drools.common.rules;\n+\n+import static java.util.Arrays.copyOfRange;\n+import static java.util.Collections.emptyMap;\n+import static java.util.Collections.singletonList;\n+import static org.drools.model.DSL.accFunction;\n+import static org.drools.model.PatternDSL.alphaIndexedBy;\n+import static org.drools.model.PatternDSL.pattern;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+\n+import org.drools.model.DSL;\n+import org.drools.model.Index;\n+import org.drools.model.PatternDSL;\n+import org.drools.model.PatternDSL.PatternDef;\n+import org.drools.model.Variable;\n+import org.drools.model.view.ViewItem;\n+import org.optaplanner.core.api.function.TriFunction;\n+import org.optaplanner.core.impl.score.stream.drools.common.BiTuple;\n+import org.optaplanner.core.impl.score.stream.drools.common.DroolsAbstractAccumulateFunction;\n+import org.optaplanner.core.impl.score.stream.drools.common.DroolsAbstractGroupByAccumulator;\n+import org.optaplanner.core.impl.score.stream.drools.common.FactTuple;\n+import org.optaplanner.core.impl.score.stream.drools.common.QuadTuple;\n+import org.optaplanner.core.impl.score.stream.drools.common.TriTuple;\n+\n+abstract class AbstractGroupByMutator implements Mutator {\n+\n+    protected abstract <InTuple> PatternDef bindTupleVariableOnFirstGrouping(AbstractRuleAssembler ruleAssembler,\n+            PatternDef pattern, Variable<InTuple> tupleVariable);\n+\n+    protected ViewItem<?> getInnerAccumulatePattern(AbstractRuleAssembler ruleAssembler) {\n+        List<ViewItem> allPatterns = new ArrayList<>();\n+        for (int i = 0; i < ruleAssembler.getPrimaryPatterns().size(); i++) {\n+            allPatterns.add(ruleAssembler.getPrimaryPatterns().get(i));\n+            allPatterns.addAll(ruleAssembler.getDependentExpressionMap().getOrDefault(i, Collections.emptyList()));\n+        }\n+        ViewItem[] items = allPatterns.toArray(new ViewItem[0]);\n+        return PatternDSL.and(items[0], copyOfRange(items, 1, items.length));", "originalCommit": "cae85a6935e468bddde8164db34bf2fff0ab7e92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NDc1Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/820#discussion_r456294757", "bodyText": "comment code style: avoid \"we\" and \"you\" just like docs -> \"Merge all filters into on to avoid paying the penalty for ...\"\nMotivation: by always writing in the same style, it's easier to switch back and forth between docs, blogs and comments. It's also a better writting style.", "author": "ge0ffrey", "createdAt": "2020-07-17T08:22:38Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/rules/TriExistenceMutator.java", "diffHunk": "@@ -0,0 +1,102 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.drools.common.rules;\n+\n+import java.util.Arrays;\n+\n+import org.drools.model.PatternDSL;\n+import org.drools.model.Variable;\n+import org.drools.model.view.ExprViewItem;\n+import org.optaplanner.core.api.function.QuadPredicate;\n+import org.optaplanner.core.impl.score.stream.drools.common.nodes.AbstractConstraintModelJoiningNode;\n+import org.optaplanner.core.impl.score.stream.quad.AbstractQuadJoiner;\n+import org.optaplanner.core.impl.score.stream.quad.FilteringQuadJoiner;\n+import org.optaplanner.core.impl.score.stream.quad.NoneQuadJoiner;\n+import org.optaplanner.core.impl.score.stream.tri.NoneTriJoiner;\n+\n+final class TriExistenceMutator<A, B, C, D> implements Mutator {\n+\n+    private final boolean shouldExist;\n+    private final Class<D> otherFactType;\n+    private final AbstractQuadJoiner<A, B, C, D>[] joiners;\n+\n+    public TriExistenceMutator(AbstractConstraintModelJoiningNode<D, AbstractQuadJoiner<A, B, C, D>> node,\n+            boolean shouldExist) {\n+        this.shouldExist = shouldExist;\n+        this.otherFactType = node.getOtherFactType();\n+        this.joiners = node.get().stream()\n+                .toArray(AbstractQuadJoiner[]::new);\n+    }\n+\n+    private AbstractRuleAssembler applyJoiners(AbstractRuleAssembler ruleAssembler, AbstractQuadJoiner<A, B, C, D> joiner,\n+            QuadPredicate<A, B, C, D> predicate) {\n+        if (joiner == null) {\n+            return applyFilters(ruleAssembler, predicate);\n+        }\n+        // There is no delta index in Drools, therefore we replace joining with a filter.\n+        QuadPredicate<A, B, C, D> joinFilter = joiner::matches;\n+        QuadPredicate<A, B, C, D> result = predicate == null ? joinFilter : joinFilter.and(predicate);\n+        // And finally we add the filter to the D pattern,\n+        return applyFilters(ruleAssembler, result);\n+    }\n+\n+    private AbstractRuleAssembler applyFilters(AbstractRuleAssembler ruleAssembler, QuadPredicate<A, B, C, D> predicate) {\n+        Variable<D> toExist = PatternDSL.declarationOf(otherFactType, ruleAssembler.generateNextId(\"triToExist\"));\n+        PatternDSL.PatternDef<D> existencePattern = PatternDSL.pattern(toExist);\n+        PatternDSL.PatternDef<D> possiblyFilteredExistencePattern = predicate == null ? existencePattern\n+                : existencePattern.expr(\"Filter using \" + predicate, ruleAssembler.getVariable(0),\n+                        ruleAssembler.getVariable(1), ruleAssembler.getVariable(2),\n+                        (d, a, b, c) -> predicate.test((A) a, (B) b, (C) c, d));\n+        ExprViewItem existenceExpression = PatternDSL.exists(possiblyFilteredExistencePattern);\n+        if (!shouldExist) {\n+            existenceExpression = PatternDSL.not(possiblyFilteredExistencePattern);\n+        }\n+        ruleAssembler.addDependentExpressionToLastPattern(existenceExpression);\n+        return ruleAssembler;\n+    }\n+\n+    @Override\n+    public AbstractRuleAssembler apply(AbstractRuleAssembler ruleAssembler) {\n+        int indexOfFirstFilter = -1;\n+        // Prepare the joiner and filter that will be used in the pattern\n+        AbstractQuadJoiner<A, B, C, D> finalJoiner = null;\n+        QuadPredicate<A, B, C, D> finalFilter = null;\n+        for (int i = 0; i < joiners.length; i++) {\n+            AbstractQuadJoiner<A, B, C, D> joiner = joiners[i];\n+            boolean hasAFilter = indexOfFirstFilter >= 0;\n+            if (joiner instanceof NoneQuadJoiner && joiners.length > 1) {\n+                throw new IllegalStateException(\"If present, \" + NoneTriJoiner.class + \" must be the only joiner, got \"\n+                        + Arrays.toString(joiners) + \" instead.\");\n+            } else if (!(joiner instanceof FilteringQuadJoiner)) {\n+                if (hasAFilter) {\n+                    throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow a filtering joiner (\"\n+                            + joiners[indexOfFirstFilter] + \").\");\n+                } else { // Merge this Joiner with the existing Joiners.\n+                    finalJoiner = finalJoiner == null ? joiner : AbstractQuadJoiner.merge(finalJoiner, joiner);\n+                }\n+            } else {\n+                if (!hasAFilter) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+                // We merge all filters into one, so that we don't pay the penalty for lack of indexing more than once.", "originalCommit": "cae85a6935e468bddde8164db34bf2fff0ab7e92", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NTU1Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/820#discussion_r456295553", "bodyText": "Seems wierd, because the argument returns \"1\", so it's impact isn't asserted. Does it work without that extra argument?", "author": "ge0ffrey", "createdAt": "2020-07-17T08:24:03Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStreamTest.java", "diffHunk": "@@ -1388,7 +1388,7 @@ public void globalNodeOrder() {\n                     .filter(entity -> entity.getEntityGroup() == entityGroup)\n                     .filter(entity -> entity.getStringProperty().equals(\"MyString1\"))\n                     .join(TestdataLavishEntity.class, equal(TestdataLavishEntity::getIntegerProperty))\n-                    .penalize(TEST_CONSTRAINT_NAME, SimpleScore.ONE);\n+                    .penalize(TEST_CONSTRAINT_NAME, SimpleScore.ONE, (a, b) -> 1);", "originalCommit": "cae85a6935e468bddde8164db34bf2fff0ab7e92", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjMwNTA3Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/820#discussion_r456305077", "bodyText": "That's a leftover from debugging. Yes, it works, will remove.", "author": "triceo", "createdAt": "2020-07-17T08:41:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjI5NTU1Mw=="}], "type": "inlineReview"}, {"oid": "b0b21188ab869219104eedc4745e2b712341203c", "url": "https://github.com/kiegroup/optaplanner/commit/b0b21188ab869219104eedc4745e2b712341203c", "message": "Address most Sonar comments", "committedDate": "2020-07-17T14:37:35Z", "type": "forcePushed"}, {"oid": "930d7af6b37168e0fca16079e004515c1cc0389e", "url": "https://github.com/kiegroup/optaplanner/commit/930d7af6b37168e0fca16079e004515c1cc0389e", "message": "Address the final review comment", "committedDate": "2020-07-17T16:21:39Z", "type": "forcePushed"}, {"oid": "a9bbea858d51452e7b385890928aa074035384bd", "url": "https://github.com/kiegroup/optaplanner/commit/a9bbea858d51452e7b385890928aa074035384bd", "message": "Moar Sonar", "committedDate": "2020-07-21T13:09:45Z", "type": "forcePushed"}, {"oid": "5834a665fda3df79fcd943b3358396b5e3943055", "url": "https://github.com/kiegroup/optaplanner/commit/5834a665fda3df79fcd943b3358396b5e3943055", "message": "Introduce constraint model", "committedDate": "2020-07-22T07:17:19Z", "type": "commit"}, {"oid": "57e608b2fe4cdb9af2c3c95caf02a815cee4960a", "url": "https://github.com/kiegroup/optaplanner/commit/57e608b2fe4cdb9af2c3c95caf02a815cee4960a", "message": "fromStreamList is not necessary", "committedDate": "2020-07-22T07:17:20Z", "type": "commit"}, {"oid": "25b8a53a7d569bf948c8c446530fb4ca229b3045", "url": "https://github.com/kiegroup/optaplanner/commit/25b8a53a7d569bf948c8c446530fb4ca229b3045", "message": "No need to store stream parent", "committedDate": "2020-07-22T07:17:20Z", "type": "commit"}, {"oid": "8d783a8bdbafdd2a51ccc97c6b96ec880395c35d", "url": "https://github.com/kiegroup/optaplanner/commit/8d783a8bdbafdd2a51ccc97c6b96ec880395c35d", "message": "Implement consequence model", "committedDate": "2020-07-22T07:17:20Z", "type": "commit"}, {"oid": "3a15a59d89f20a73da5e42b0f7b95889f2b38c43", "url": "https://github.com/kiegroup/optaplanner/commit/3a15a59d89f20a73da5e42b0f7b95889f2b38c43", "message": "Implement node model", "committedDate": "2020-07-22T07:17:20Z", "type": "commit"}, {"oid": "b39c8b3e177537f9dd03a1542a229ef39d80e6b6", "url": "https://github.com/kiegroup/optaplanner/commit/b39c8b3e177537f9dd03a1542a229ef39d80e6b6", "message": "Model should not be doing fancy things", "committedDate": "2020-07-22T07:17:20Z", "type": "commit"}, {"oid": "eef198da496ffc8bfe6a2302aff8418469f414c1", "url": "https://github.com/kiegroup/optaplanner/commit/eef198da496ffc8bfe6a2302aff8418469f414c1", "message": "ConstraintModel becomes ConstraintGraph", "committedDate": "2020-07-22T07:17:21Z", "type": "commit"}, {"oid": "a1911e1dc1bacb1d528b02efa2144715174293a9", "url": "https://github.com/kiegroup/optaplanner/commit/a1911e1dc1bacb1d528b02efa2144715174293a9", "message": "Constraint tree", "committedDate": "2020-07-22T07:17:21Z", "type": "commit"}, {"oid": "8862f7976b09e91b82b96fdd1b22fc67a1dd4d85", "url": "https://github.com/kiegroup/optaplanner/commit/8862f7976b09e91b82b96fdd1b22fc67a1dd4d85", "message": "Propagate the graph throughout the streams", "committedDate": "2020-07-22T07:17:21Z", "type": "commit"}, {"oid": "956df309176631cccf44ab1e1a9ec7436a4602c2", "url": "https://github.com/kiegroup/optaplanner/commit/956df309176631cccf44ab1e1a9ec7436a4602c2", "message": "Rip out the old exec model (106 test errors, 290 test fails)\n\nKeeping the internals around, as we will be reusing them later.", "committedDate": "2020-07-22T07:17:22Z", "type": "commit"}, {"oid": "ef43ed36763f62ff4382337ce57b998248a89dbd", "url": "https://github.com/kiegroup/optaplanner/commit/ef43ed36763f62ff4382337ce57b998248a89dbd", "message": "Add unused rule check (0 errors, 396 fails)", "committedDate": "2020-07-22T07:17:22Z", "type": "commit"}, {"oid": "24740cf557a1b5ad8b3d74534a6d114f3325b4d8", "url": "https://github.com/kiegroup/optaplanner/commit/24740cf557a1b5ad8b3d74534a6d114f3325b4d8", "message": "Implement .from().filter() (352 core tests fail)", "committedDate": "2020-07-22T07:17:22Z", "type": "commit"}, {"oid": "c7bf6102ad531b8d74afa0a8207b4373ac12c5e9", "url": "https://github.com/kiegroup/optaplanner/commit/c7bf6102ad531b8d74afa0a8207b4373ac12c5e9", "message": "Implement if(Not)Exists on uni (332 tests failing)", "committedDate": "2020-07-22T07:17:22Z", "type": "commit"}, {"oid": "efac46a12128a36cec05170e7af58d9134d214a5", "url": "https://github.com/kiegroup/optaplanner/commit/efac46a12128a36cec05170e7af58d9134d214a5", "message": "Fix default match weights (324 tests fail)", "committedDate": "2020-07-22T07:17:23Z", "type": "commit"}, {"oid": "af94c58aae0a19846066e25a6366637f1de0104a", "url": "https://github.com/kiegroup/optaplanner/commit/af94c58aae0a19846066e25a6366637f1de0104a", "message": "BiJoin (264 tests fail)", "committedDate": "2020-07-22T07:17:23Z", "type": "commit"}, {"oid": "11b9b2b85e43f4a9a84bd0f055184bc78e42c4be", "url": "https://github.com/kiegroup/optaplanner/commit/11b9b2b85e43f4a9a84bd0f055184bc78e42c4be", "message": "Bi existence (248 tests fail)", "committedDate": "2020-07-22T07:17:23Z", "type": "commit"}, {"oid": "5c957426a31175ed35d40928b6eb6e1aeb632d14", "url": "https://github.com/kiegroup/optaplanner/commit/5c957426a31175ed35d40928b6eb6e1aeb632d14", "message": "Remaining cardinalities (124 tests failing)", "committedDate": "2020-07-22T07:17:24Z", "type": "commit"}, {"oid": "541d3e95cfddbd418918c0fec167b552334a6608", "url": "https://github.com/kiegroup/optaplanner/commit/541d3e95cfddbd418918c0fec167b552334a6608", "message": "Fix filtering in higher cardinalities (96 tests fail)", "committedDate": "2020-07-22T07:17:24Z", "type": "commit"}, {"oid": "17edbfeb7641c7fe422c3831bab9c2d93d85c064", "url": "https://github.com/kiegroup/optaplanner/commit/17edbfeb7641c7fe422c3831bab9c2d93d85c064", "message": "Move package", "committedDate": "2020-07-22T07:17:24Z", "type": "commit"}, {"oid": "5040d3d8e683e1498b2ad008dc9a2d687a54cb48", "url": "https://github.com/kiegroup/optaplanner/commit/5040d3d8e683e1498b2ad008dc9a2d687a54cb48", "message": "Make filters more resilient", "committedDate": "2020-07-22T07:17:24Z", "type": "commit"}, {"oid": "0490fbec2f0f0021222edd32e6d60a4c9e93310c", "url": "https://github.com/kiegroup/optaplanner/commit/0490fbec2f0f0021222edd32e6d60a4c9e93310c", "message": "Make existence more resilient", "committedDate": "2020-07-22T07:17:25Z", "type": "commit"}, {"oid": "c96ae43b18872461ae02d384a398be2ba149f56a", "url": "https://github.com/kiegroup/optaplanner/commit/c96ae43b18872461ae02d384a398be2ba149f56a", "message": "Enforce the proper number of variables", "committedDate": "2020-07-22T07:17:25Z", "type": "commit"}, {"oid": "989d8e630111f9b4da7193ff65c97ef0eed35a33", "url": "https://github.com/kiegroup/optaplanner/commit/989d8e630111f9b4da7193ff65c97ef0eed35a33", "message": "Add basic groupBy scaffolding", "committedDate": "2020-07-22T07:17:25Z", "type": "commit"}, {"oid": "c7fc2bc184a0f3b0bb23f1de1ee8098871549aa4", "url": "https://github.com/kiegroup/optaplanner/commit/c7fc2bc184a0f3b0bb23f1de1ee8098871549aa4", "message": "Basic uni groupBy (78 tests fail)", "committedDate": "2020-07-22T07:17:26Z", "type": "commit"}, {"oid": "fd103af0ea6c5c885d80a5f0c540844aa79903e0", "url": "https://github.com/kiegroup/optaplanner/commit/fd103af0ea6c5c885d80a5f0c540844aa79903e0", "message": "More uni groupBy (64 tests fail)", "committedDate": "2020-07-22T07:17:26Z", "type": "commit"}, {"oid": "1949afee394c0ebd8089728370edf78fec0ceac5", "url": "https://github.com/kiegroup/optaplanner/commit/1949afee394c0ebd8089728370edf78fec0ceac5", "message": "Uni grouping is complete (56 tests fail)", "committedDate": "2020-07-22T07:17:26Z", "type": "commit"}, {"oid": "07581c01e03bebe31e3d2a86d4ad9bf02ccc9f33", "url": "https://github.com/kiegroup/optaplanner/commit/07581c01e03bebe31e3d2a86d4ad9bf02ccc9f33", "message": "Bi grouping is complete (38 tests fail)", "committedDate": "2020-07-22T07:17:26Z", "type": "commit"}, {"oid": "e456a5710b554748152a506e099f874a5288ff2d", "url": "https://github.com/kiegroup/optaplanner/commit/e456a5710b554748152a506e099f874a5288ff2d", "message": "Proper test naming", "committedDate": "2020-07-22T07:17:27Z", "type": "commit"}, {"oid": "145328b339288caaba5a4ce37dd7285d4e23895d", "url": "https://github.com/kiegroup/optaplanner/commit/145328b339288caaba5a4ce37dd7285d4e23895d", "message": "Tri grouping is complete (22 tests fail)", "committedDate": "2020-07-22T07:17:27Z", "type": "commit"}, {"oid": "2426ffb4fdfe8d95adedebe8001c44d89ca51291", "url": "https://github.com/kiegroup/optaplanner/commit/2426ffb4fdfe8d95adedebe8001c44d89ca51291", "message": "Quad grouping is complete (12 tests fail)", "committedDate": "2020-07-22T07:17:27Z", "type": "commit"}, {"oid": "cc5fd87f39c9c0637dfbe393991a6095d64c944a", "url": "https://github.com/kiegroup/optaplanner/commit/cc5fd87f39c9c0637dfbe393991a6095d64c944a", "message": "Remove old implementations", "committedDate": "2020-07-22T07:17:45Z", "type": "commit"}, {"oid": "23251d32c9c26b7cdd274d46780c87e7cfded81e", "url": "https://github.com/kiegroup/optaplanner/commit/23251d32c9c26b7cdd274d46780c87e7cfded81e", "message": "Unify test naming", "committedDate": "2020-07-22T07:17:49Z", "type": "commit"}, {"oid": "4b7c3e40093ac55d1fa74b7e37ab36c3fb3279a2", "url": "https://github.com/kiegroup/optaplanner/commit/4b7c3e40093ac55d1fa74b7e37ab36c3fb3279a2", "message": "Fix basic collecting (6 tests fail)", "committedDate": "2020-07-22T07:17:49Z", "type": "commit"}, {"oid": "cc6cb96b8981bad1bd286e4e37eb568a471efc2b", "url": "https://github.com/kiegroup/optaplanner/commit/cc6cb96b8981bad1bd286e4e37eb568a471efc2b", "message": "Fix recollecting (no core tests fail)", "committedDate": "2020-07-22T07:17:50Z", "type": "commit"}, {"oid": "fa5fed11625f3328f87de2438b5903c759ffc3e0", "url": "https://github.com/kiegroup/optaplanner/commit/fa5fed11625f3328f87de2438b5903c759ffc3e0", "message": "Hide things", "committedDate": "2020-07-22T07:17:50Z", "type": "commit"}, {"oid": "159883f1e8316a75c1ce4699471c239ea770c6b4", "url": "https://github.com/kiegroup/optaplanner/commit/159883f1e8316a75c1ce4699471c239ea770c6b4", "message": "Rule builder renamed to rule assembler", "committedDate": "2020-07-22T07:17:50Z", "type": "commit"}, {"oid": "bdfb2c11512db2c017d9f287f6cc24a61a95cac7", "url": "https://github.com/kiegroup/optaplanner/commit/bdfb2c11512db2c017d9f287f6cc24a61a95cac7", "message": "Move stuff around", "committedDate": "2020-07-22T07:17:50Z", "type": "commit"}, {"oid": "d6bdc05f3613cdd032f0a10dad388ac67f8f7401", "url": "https://github.com/kiegroup/optaplanner/commit/d6bdc05f3613cdd032f0a10dad388ac67f8f7401", "message": "Revert accidental changes to docs", "committedDate": "2020-07-22T07:17:50Z", "type": "commit"}, {"oid": "f472d62c808ab3b933274423ae0db7ebb83ef67b", "url": "https://github.com/kiegroup/optaplanner/commit/f472d62c808ab3b933274423ae0db7ebb83ef67b", "message": "Absolutely no changes to docs", "committedDate": "2020-07-22T07:17:51Z", "type": "commit"}, {"oid": "93302a026a672c609e3663100ad0b05dd23a6144", "url": "https://github.com/kiegroup/optaplanner/commit/93302a026a672c609e3663100ad0b05dd23a6144", "message": "Fix whitespace", "committedDate": "2020-07-22T07:17:51Z", "type": "commit"}, {"oid": "b048a354bb14313450f1569dca04330da80445b0", "url": "https://github.com/kiegroup/optaplanner/commit/b048a354bb14313450f1569dca04330da80445b0", "message": "Finally fix the adoc", "committedDate": "2020-07-22T07:17:51Z", "type": "commit"}, {"oid": "2992ca9f58519a98fca2689ec1c1711a1b159390", "url": "https://github.com/kiegroup/optaplanner/commit/2992ca9f58519a98fca2689ec1c1711a1b159390", "message": "More final classes", "committedDate": "2020-07-22T07:17:51Z", "type": "commit"}, {"oid": "fa498742ae24723cdf3bedb822304593ff2d5946", "url": "https://github.com/kiegroup/optaplanner/commit/fa498742ae24723cdf3bedb822304593ff2d5946", "message": "More code reuse", "committedDate": "2020-07-22T07:17:51Z", "type": "commit"}, {"oid": "44caf03109d5e15deac105f74a7df47694e4845e", "url": "https://github.com/kiegroup/optaplanner/commit/44caf03109d5e15deac105f74a7df47694e4845e", "message": "Streamline joining", "committedDate": "2020-07-22T07:17:52Z", "type": "commit"}, {"oid": "276fe964e86926a7aadc7e176fe16dd117f2e55d", "url": "https://github.com/kiegroup/optaplanner/commit/276fe964e86926a7aadc7e176fe16dd117f2e55d", "message": "Address most Sonar comments", "committedDate": "2020-07-22T07:17:52Z", "type": "commit"}, {"oid": "e2d78a5ab70f5c640bab4386fcc516f359b8513c", "url": "https://github.com/kiegroup/optaplanner/commit/e2d78a5ab70f5c640bab4386fcc516f359b8513c", "message": "Remove unnecessary change", "committedDate": "2020-07-22T07:17:52Z", "type": "commit"}, {"oid": "0267e454298f0bb3fc9c60abb343a6623d3aa43a", "url": "https://github.com/kiegroup/optaplanner/commit/0267e454298f0bb3fc9c60abb343a6623d3aa43a", "message": "Better exception messages", "committedDate": "2020-07-22T07:17:52Z", "type": "commit"}, {"oid": "4e15932225f739c5df7abca583c8eccf36267485", "url": "https://github.com/kiegroup/optaplanner/commit/4e15932225f739c5df7abca583c8eccf36267485", "message": "More Sonar stuff", "committedDate": "2020-07-22T07:17:53Z", "type": "commit"}, {"oid": "d20d9485419abe0f1620a9e1a3df2bf36426038d", "url": "https://github.com/kiegroup/optaplanner/commit/d20d9485419abe0f1620a9e1a3df2bf36426038d", "message": "Address the final review comment", "committedDate": "2020-07-22T07:17:53Z", "type": "commit"}, {"oid": "a1039727642a67d42589b2d4fc79042aba0b2096", "url": "https://github.com/kiegroup/optaplanner/commit/a1039727642a67d42589b2d4fc79042aba0b2096", "message": "Moar Sonar", "committedDate": "2020-07-22T07:17:53Z", "type": "commit"}, {"oid": "a1039727642a67d42589b2d4fc79042aba0b2096", "url": "https://github.com/kiegroup/optaplanner/commit/a1039727642a67d42589b2d4fc79042aba0b2096", "message": "Moar Sonar", "committedDate": "2020-07-22T07:17:53Z", "type": "forcePushed"}]}