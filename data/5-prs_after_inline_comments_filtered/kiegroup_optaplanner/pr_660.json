{"pr_number": 660, "pr_title": "PLANNER-1615 ifExists() for UniStream", "pr_createdAt": "2020-01-22T11:10:23Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/660", "timeline": [{"oid": "54a89b2f270506da9b6486057957a09e2a686db7", "url": "https://github.com/kiegroup/optaplanner/commit/54a89b2f270506da9b6486057957a09e2a686db7", "message": "Add filtering bi joiner", "committedDate": "2020-01-22T11:09:35Z", "type": "commit"}, {"oid": "7b2be44cbc5626e36c8ec559547645765530791d", "url": "https://github.com/kiegroup/optaplanner/commit/7b2be44cbc5626e36c8ec559547645765530791d", "message": "Add the API", "committedDate": "2020-01-22T12:08:07Z", "type": "commit"}, {"oid": "96b193d6cba9bf5906aae34211a6e711a5f077b1", "url": "https://github.com/kiegroup/optaplanner/commit/96b193d6cba9bf5906aae34211a6e711a5f077b1", "message": "Implement UniCondition support", "committedDate": "2020-01-22T13:53:07Z", "type": "commit"}, {"oid": "e216f1fd2fe523c2e6fbd91717d51da4acfe8d3e", "url": "https://github.com/kiegroup/optaplanner/commit/e216f1fd2fe523c2e6fbd91717d51da4acfe8d3e", "message": "Make the rule structure cleaner", "committedDate": "2020-01-22T15:32:43Z", "type": "commit"}, {"oid": "da0b31ccf0636889493522c5e662e1481297f67f", "url": "https://github.com/kiegroup/optaplanner/commit/da0b31ccf0636889493522c5e662e1481297f67f", "message": "Finalize the PoC", "committedDate": "2020-01-22T16:56:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5MDgyNQ==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369690825", "bodyText": "Suggested solution: add a default ifExists(Class<B> otherClass, BiJoiner<A,B>... joiners); that callsifExists(Class otherClass, List joiners)`\ndefault <B> UniConstraintStream<A> ifExists(Class<B> otherClass, BiJoiner<A, B>... joiners) {\n    ifExists(otherClass, Arrays.asList(joiners));\n}\n\n<B>  UniConstraintStream<A> ifExists(Class<B> otherClass, List<BiJoiner<A, B>> joiners);", "author": "Christopher-Chianelli", "createdAt": "2020-01-22T17:12:26Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -218,6 +218,88 @@\n         return joined.filter(resultingFilter);\n     }\n \n+    // ************************************************************************\n+    // If Exists\n+    // ************************************************************************\n+\n+    /**\n+     * Create a new {@link UniConstraintStream} for every A, if B exists.\n+     * @param otherClass never null\n+     * @param <B> the type of the second matched fact\n+     * @return a stream that matches every A where a B exists\n+     */\n+    default <B> UniConstraintStream<A> ifExists(Class<B> otherClass) {\n+        return ifExists(otherClass, new NoneBiJoiner<>());\n+    }\n+\n+    /**\n+     * Create a new {@link UniConstraintStream} for every A where B exists for which the {@link BiJoiner} is true\n+     * (for the properties it extracts from both facts).\n+     * <p>\n+     * This method has overloaded methods with multiple {@link BiJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiner never null\n+     * @param <B> the type of the second matched fact\n+     * @return a stream that matches every A where B exists for which the {@link BiJoiner} is true\n+     */\n+    default <B> UniConstraintStream<A> ifExists(Class<B> otherClass, BiJoiner<A, B> joiner) {\n+        return ifExists(otherClass, new BiJoiner[] { joiner });\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, BiJoiner)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param <B> the type of the second matched fact\n+     * @return a stream that matches every A where B exists for which all the {@link BiJoiner}s are true\n+     */\n+    default <B> UniConstraintStream<A> ifExists(Class<B> otherClass, BiJoiner<A, B> joiner1, BiJoiner<A, B> joiner2) {\n+        return ifExists(otherClass, new BiJoiner[] {joiner1, joiner2});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, BiJoiner)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param <B> the type of the second matched fact\n+     * @return a stream that matches every A where B exists for which all the {@link BiJoiner}s are true\n+     */\n+    default <B> UniConstraintStream<A> ifExists(Class<B> otherClass, BiJoiner<A, B> joiner1, BiJoiner<A, B> joiner2,\n+            BiJoiner<A, B> joiner3) {\n+        return ifExists(otherClass, new BiJoiner[] {joiner1, joiner2, joiner3});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, BiJoiner)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param joiner4 never null\n+     * @param <B> the type of the second matched fact\n+     * @return a stream that matches every A where B exists for which all the {@link BiJoiner}s are true\n+     */\n+    default <B> UniConstraintStream<A> ifExists(Class<B> otherClass, BiJoiner<A, B> joiner1, BiJoiner<A, B> joiner2,\n+            BiJoiner<A, B> joiner3, BiJoiner<A, B> joiner4) {\n+        return ifExists(otherClass, new BiJoiner[] {joiner1, joiner2, joiner3, joiner4});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, BiJoiner)}.\n+     * <p>\n+     * This method causes <i>Unchecked generics array creation for varargs parameter</i> warnings,\n+     * but we can't fix it with a {@link SafeVarargs} annotation because it's an interface method.\n+     * Therefore, there are overloaded methods with up to 4 {@link BiJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiners never null\n+     * @param <B> the type of the second matched fact\n+     * @return a stream that matches every A where B exists for which all the {@link BiJoiner}s are true\n+     */\n+    <B> UniConstraintStream<A> ifExists(Class<B> otherClass, BiJoiner<A, B>... joiners);", "originalCommit": "da0b31ccf0636889493522c5e662e1481297f67f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTcyNTk2Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369725963", "bodyText": "Chris, I don't have anything against this change, but if we do it, we need to do the same for joins and perhaps in couple other places. All in all, that's a large amount of work, and scope creep in this context.\nWould you mind filing a JIRA for this? You could even tackle it yourself, if you feel like diving into the CS code.", "author": "triceo", "createdAt": "2020-01-22T18:23:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5MDgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTczMjE3NA==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369732174", "bodyText": "I will first try it out in an example project to make sure my suggested change actually works as intended; if so, I will file a JIRA.", "author": "Christopher-Chianelli", "createdAt": "2020-01-22T18:35:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5MDgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc0MzE2NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369743165", "bodyText": "Cannot make an interface method final, which is a blocker for @SafeVarargs. If you want to use this suggestion, we have two options:\n\nTurn the interfaces into abstract classes (which allow us to use final).\nCreate a static wrapper.\nI think both of those options are bad.\n\nIf you allow @SuppressWarnings, there a third option:\npublic interface TestInterface<A> {\n    \n    default <B> List<A> myMethodVarargs(Class<B> otherClass, @SuppressWarnings(\"unchecked\") A... data) {\n        return myMethodList(otherClass, Arrays.asList(data));\n    }\n    \n    <B> List<A> myMethodList(Class<B> otherClass, List<A> data);\n}", "author": "Christopher-Chianelli", "createdAt": "2020-01-22T18:58:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5MDgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4MDA4Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369780086", "bodyText": "Actually, thinking about this again, could you perhaps explain why you would need a method like that?\nPersonally I consider this:\n   ifExists(Something.class, joiner1, joiner2, joiner3, joiner4);\n\nTo be much better than this:\n   ifExists(Something.class, Arrays.asList(joiner1, joiner2, joiner3, joiner4));\n\nBut perhaps there is some aspect that I'm missing.", "author": "triceo", "createdAt": "2020-01-22T20:15:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5MDgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTc4MzY3Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369783672", "bodyText": "It to make implementing the interface not inherit the varargs warnings (and working with Lists is easier than working with arrays). The varargs option is still available (under the same name; above was from testing trying to find a way to remove the warning). @SafeVarargs might work on implementing classes, as long as the methods are marked as final.", "author": "Christopher-Chianelli", "createdAt": "2020-01-22T20:22:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5MDgyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAwNjg2Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370006867", "bodyText": "I don't want to introduce methods that accepts List or Collection of Joiners in this API.\nMotivation:\n\nDon't proliferate more combinations of each method (join(List) vs join(vararg) and that for join, ifExists, joinOther, ... and then for Uni, Bi, Tri, ...). Not worth the maintenance burden I'd argue.\nWe're not really accepting an array - we're accepting a vararg. I don't see use cases at this point in time where users would actually use an array. I do see cases where they would provide 7+ parameters, hence the need for a vararg.", "author": "ge0ffrey", "createdAt": "2020-01-23T09:23:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTY5MDgyNQ=="}], "type": "inlineReview"}, {"oid": "ebc17999f69bee8cf60d40305f54dc10f4dd3313", "url": "https://github.com/kiegroup/optaplanner/commit/ebc17999f69bee8cf60d40305f54dc10f4dd3313", "message": "Finalize the PoC", "committedDate": "2020-01-22T18:07:50Z", "type": "commit"}, {"oid": "fd40b48f6c7f95fa4486c3d9aa3ca4eaa07259d6", "url": "https://github.com/kiegroup/optaplanner/commit/fd40b48f6c7f95fa4486c3d9aa3ca4eaa07259d6", "message": "Fix test", "committedDate": "2020-01-22T20:50:55Z", "type": "commit"}, {"oid": "db919f28fc18ce0d7f3f8cf59e19e1f5151d6591", "url": "https://github.com/kiegroup/optaplanner/commit/db919f28fc18ce0d7f3f8cf59e19e1f5151d6591", "message": "Fix Revapi", "committedDate": "2020-01-22T21:17:13Z", "type": "commit"}, {"oid": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa", "url": "https://github.com/kiegroup/optaplanner/commit/4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa", "message": "Actually fix Revapi", "committedDate": "2020-01-22T21:23:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3NTUwMA==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369975500", "bodyText": "This is handy! I've had need of it a few times, but never thought about this simple solution.", "author": "ge0ffrey", "createdAt": "2020-01-23T08:07:34Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -41,6 +44,10 @@\n     // BiJoiner\n     // ************************************************************************\n \n+    public static <A> BiJoiner<A, A> equal() {", "originalCommit": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3NjcwNQ==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369976705", "bodyText": "Will notEqual be indexed?\nIf it's not indexed and therefore syntactic sugar for filtering(), there must be fail-fast if any indexed joiner is behind it (so only notEquals and filtering() can come after it).\nIf it is indexed, it could be slower is some cases. Should the user be able to choose between indexed vs non-indexed non-equality? Would that choose be using notEquals() vs filtering(a!=b)?", "author": "ge0ffrey", "createdAt": "2020-01-23T08:11:11Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -50,6 +57,19 @@\n         return new SingleBiJoiner<>(leftMapping, JoinerType.EQUAL, rightMapping);\n     }\n \n+    public static <A> BiJoiner<A, A> notEqual() {\n+        return notEqual(Function.identity());\n+    }\n+\n+    public static <A, Property_> BiJoiner<A, A> notEqual(Function<A, Property_> mapping) {\n+        return notEqual(mapping, mapping);\n+    }\n+\n+    public static <A, B, Property_> BiJoiner<A, B> notEqual(Function<A, Property_> leftMapping,\n+            Function <B, Property_> rightMapping) {\n+        return new SingleBiJoiner<>(leftMapping, JoinerType.NOT_EQUAL, rightMapping);", "originalCommit": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3NzgyNw==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369977827", "bodyText": "All in all, the notEquals raises a red flag of \"when in doubt, leave it out\" for me, especially due to that last question, until we discuss it properly and/or know more about how users use ConstraintStreams. Wdyt?", "author": "ge0ffrey", "createdAt": "2020-01-23T08:14:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3NjcwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3OTAxMg==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369979012", "bodyText": "In Drools, NOT_EQUAL is an implemented index type, so CS-D behaves the same for EQUAL as for NOT_EQUAL.\nThere is no Bavet support for NOT_EQUAL and it will throw an exception if you try to use it.", "author": "triceo", "createdAt": "2020-01-23T08:17:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3NjcwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3OTU4Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369979582", "bodyText": "There is no way to leave this out, as otherwise I can't have ifExistsOther(). That requires notEqual(). (Alternatively, a filter with poor performance.)", "author": "triceo", "createdAt": "2020-01-23T08:19:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3NjcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3ODExMw==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369978113", "bodyText": "Similar to the javadoc of that filter() method, this javadoc should mention the lack of indexing.", "author": "ge0ffrey", "createdAt": "2020-01-23T08:15:19Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -89,6 +109,18 @@\n         return new SingleBiJoiner<>(leftMapping, JoinerType.GREATER_THAN_OR_EQUAL, rightMapping);\n     }\n \n+    /**\n+     * Applies a filter to the joined tuple, with the semantics of {@link BiConstraintStream#filter(BiPredicate)}.", "originalCommit": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4MDQ4Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369980482", "bodyText": "In fact, the reason why I reference that other Javadoc is to avoid having to say this everywhere. That Javadoc says it, and this Javadoc says \"same semantics\".", "author": "triceo", "createdAt": "2020-01-23T08:22:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3ODExMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3ODIzNA==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369978234", "bodyText": "always start with \"never null\" or \"sometimes null\". (in this case never null)", "author": "ge0ffrey", "createdAt": "2020-01-23T08:15:43Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -89,6 +109,18 @@\n         return new SingleBiJoiner<>(leftMapping, JoinerType.GREATER_THAN_OR_EQUAL, rightMapping);\n     }\n \n+    /**\n+     * Applies a filter to the joined tuple, with the semantics of {@link BiConstraintStream#filter(BiPredicate)}.\n+     *\n+     * @param filter filter to apply", "originalCommit": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3ODMyNw==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369978327", "bodyText": "never null or sometimes null?", "author": "ge0ffrey", "createdAt": "2020-01-23T08:15:57Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/Joiners.java", "diffHunk": "@@ -89,6 +109,18 @@\n         return new SingleBiJoiner<>(leftMapping, JoinerType.GREATER_THAN_OR_EQUAL, rightMapping);\n     }\n \n+    /**\n+     * Applies a filter to the joined tuple, with the semantics of {@link BiConstraintStream#filter(BiPredicate)}.\n+     *\n+     * @param filter filter to apply\n+     * @param <A> type of the first fact in the tuple\n+     * @param <B> type of the second fact in the tuple\n+     * @return the joiner", "originalCommit": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3ODQ4MA==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369978480", "bodyText": "I'd not even mention \"the joiner\" as the return type already signals that information. See javadocs on other important API's in optaplanner-core.", "author": "ge0ffrey", "createdAt": "2020-01-23T08:16:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk3ODMyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4MDU3Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369980576", "bodyText": "There is a join(Class<B>, joiners) and a join(Uni<B>, joiners).\nDo both support filtering() joiners now? Isn't this new code below here duplicated between them?\nIt feels to me like we want to extract these new lines below into a separate non-public method if possible.", "author": "ge0ffrey", "createdAt": "2020-01-23T08:22:29Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -180,7 +190,332 @@\n      * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B>... joiners) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiners));", "originalCommit": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4MTUzOA==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369981538", "bodyText": "This is an interface and Java 8, so there are no non-public methods.\nYes, all the join() methods support filtering(). In fact, filtering() is converted to join().filter(), so the JoinStream never even gets to see that particular joiner.", "author": "triceo", "createdAt": "2020-01-23T08:25:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4MDU3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUxOTk5Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370519992", "bodyText": "Good that the JoinStream never sees that partical joiner.\nI am just wondering - if both join(Class) and join(Stream) handle the FilteringJoiner-extraction, do they duplicate the code below? If so, can we de-duplicate it by letting this one delegate to the Stream one?", "author": "ge0ffrey", "createdAt": "2020-01-24T08:36:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4MDU3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4MDgwMg==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369980802", "bodyText": "\"Only found indexing joiners.\" is not a sentence, don't end with \".\"", "author": "ge0ffrey", "createdAt": "2020-01-23T08:23:02Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -180,7 +190,332 @@\n      * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B>... joiners) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        int joinerCount = joiners.length;\n+        int indexOfFirstFilter = -1;\n+        for (int i = 0; i < joinerCount; i++) {\n+            BiJoiner<A, B> joiner = joiners[i];\n+            boolean hasAFilter = indexOfFirstFilter >= 0;\n+            if (joiner instanceof FilteringBiJoiner) {\n+                if (!hasAFilter) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+            } else if (hasAFilter) {\n+                throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow a filtering joiner (\"\n+                        + joiners[indexOfFirstFilter] + \").\");\n+            }\n+        }\n+        if (indexOfFirstFilter < 0) { // Only found indexing joiners.", "originalCommit": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUxODkxNQ==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370518915", "bodyText": "Style issue is still here: remove the \".\" at the end in the comment because it's not a sentance", "author": "ge0ffrey", "createdAt": "2020-01-24T08:33:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4MDgwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4MzQ2MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369983461", "bodyText": "For readability I'd turn these if's order and avoid the boolean hasAFilter:\nif (indexOfFirstFilter >= 0) {\n      if (joiner instanceof FilteringBiJoiner) {\n        throw ...\n      }\n} else if (joiner instanceof FilteringBiJoiner) {\n    indexOfFirstFilter = i;\n}\n\nMost of OptaPlanner's code has the style to first check the fail fasts, before doing the code. I've found this is more readable, because when reading you can skip the fail-fasts, reducing the lines to grok (fail-fast's are usually easy to recognize based on their \"throw\" keyword).", "author": "ge0ffrey", "createdAt": "2020-01-23T08:29:35Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -180,7 +190,332 @@\n      * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B>... joiners) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        int joinerCount = joiners.length;\n+        int indexOfFirstFilter = -1;\n+        for (int i = 0; i < joinerCount; i++) {\n+            BiJoiner<A, B> joiner = joiners[i];\n+            boolean hasAFilter = indexOfFirstFilter >= 0;\n+            if (joiner instanceof FilteringBiJoiner) {\n+                if (!hasAFilter) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+            } else if (hasAFilter) {\n+                throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow a filtering joiner (\"\n+                        + joiners[indexOfFirstFilter] + \").\");\n+            }", "originalCommit": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk5MDkyMA==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369990920", "bodyText": "I partially agree - with the order, not with avoiding the hasAFilter variable, which in my opinion rather adds to readability.", "author": "rsynek", "createdAt": "2020-01-23T08:48:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4MzQ2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4NDk3NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369984975", "bodyText": "Don't create this \"always true\" predicate:\n\nIf there is no filtering, don't call filter().\nIf there is only 1 filter, let's say Foo::isReady, don't create a wrapper predicate of an always true predicate combined with foo.isReady(), just use `Foo::isReady``directly.\nSame reasoning for 2 filters (don't make it 3)\n...", "author": "ge0ffrey", "createdAt": "2020-01-23T08:33:19Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -180,7 +190,332 @@\n      * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B>... joiners) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        int joinerCount = joiners.length;\n+        int indexOfFirstFilter = -1;\n+        for (int i = 0; i < joinerCount; i++) {\n+            BiJoiner<A, B> joiner = joiners[i];\n+            boolean hasAFilter = indexOfFirstFilter >= 0;\n+            if (joiner instanceof FilteringBiJoiner) {\n+                if (!hasAFilter) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+            } else if (hasAFilter) {\n+                throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow a filtering joiner (\"\n+                        + joiners[indexOfFirstFilter] + \").\");\n+            }\n+        }\n+        if (indexOfFirstFilter < 0) { // Only found indexing joiners.\n+            return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        }\n+        // Assemble the join stream.\n+        BiConstraintStream<A, B> joined = indexOfFirstFilter == 0 ?\n+                join(otherClass) :\n+                join(otherClass, Arrays.copyOf(joiners, indexOfFirstFilter));\n+        // We merge all filters into one, so that we don't pay the penalty for lack of indexing more than once.\n+        BiPredicate<A, B> resultingFilter = (a, b) -> true;", "originalCommit": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4NTg1NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369985855", "bodyText": "Motivation:\n\nperformance (especially with the extra filter() call for those that don't use it, it currently will cause non-trivial perf degredation in Bavet that creates tuples for filters)\nnode sharing (same lambda recognition)", "author": "ge0ffrey", "createdAt": "2020-01-23T08:35:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk4NDk3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk5MjUwOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369992509", "bodyText": "join(Class) and join(Class, joiner) are very commonly used, so they don't use \"As defined by\" in the javadocs (the extra click might have some people not read it). They are an exception, because using \"as defined by\" reduces maintenance.\nI'd argue that \"joinOther(Class)\" can use \"As defined by join(Class)\" and then something like \"With the additional joiner than they are not equal\" (but better written).\nSame for \"joinOther(Class, Joiner)\" => \"As defined by join(Class, Joiner) with the additional joiner than they are not equal\"\nBut indeed for joinOther(Class, Joiner, Joiner) and more, I 'd keep using \"As defined by joinOther(Class, Joiner, Joiner)\" (so no need of \"with the additional ...\" because it references joinOther, not join).\nMotivation: users that use \"joinOther\" are likely already to know \"join\", so it's even better for them (= quicker to understand) if we say \"whatever you already know from join() plus they are not equal\"\nWdyt?", "author": "ge0ffrey", "createdAt": "2020-01-23T08:51:32Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -180,7 +190,332 @@\n      * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B>... joiners) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        int joinerCount = joiners.length;\n+        int indexOfFirstFilter = -1;\n+        for (int i = 0; i < joinerCount; i++) {\n+            BiJoiner<A, B> joiner = joiners[i];\n+            boolean hasAFilter = indexOfFirstFilter >= 0;\n+            if (joiner instanceof FilteringBiJoiner) {\n+                if (!hasAFilter) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+            } else if (hasAFilter) {\n+                throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow a filtering joiner (\"\n+                        + joiners[indexOfFirstFilter] + \").\");\n+            }\n+        }\n+        if (indexOfFirstFilter < 0) { // Only found indexing joiners.\n+            return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        }\n+        // Assemble the join stream.\n+        BiConstraintStream<A, B> joined = indexOfFirstFilter == 0 ?\n+                join(otherClass) :\n+                join(otherClass, Arrays.copyOf(joiners, indexOfFirstFilter));\n+        // We merge all filters into one, so that we don't pay the penalty for lack of indexing more than once.\n+        BiPredicate<A, B> resultingFilter = (a, b) -> true;\n+        for (int i = indexOfFirstFilter; i < joinerCount; i++) {\n+            FilteringBiJoiner<A, B> filteringJoiner = (FilteringBiJoiner<A, B>) joiners[i];\n+            resultingFilter = resultingFilter.and(filteringJoiner.getFilter());\n+        }\n+        return joined.filter(resultingFilter);\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every two different A.\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #joinOther(UniConstraintStream) joinOther}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.\n+     * @param otherStream never null\n+     * @return a stream that matches every combination of A and a different A\n+     */\n+    default BiConstraintStream<A, A> joinOther(UniConstraintStream<A> otherStream) {\n+        return join(otherStream, Joiners.notEqual());\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every combination of A and a different A for which the\n+     * {@link BiJoiner} is true (for the properties it extracts from both facts).\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #joinOther(UniConstraintStream) joinOther}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.", "originalCommit": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAzNTE3OA==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370035178", "bodyText": "We've just agreed during our call that we're removing joinOther altogether. :-)", "author": "triceo", "createdAt": "2020-01-23T10:20:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk5MjUwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk5NDQ4Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369994482", "bodyText": "If nonEquals is indexed, does this merge make sure that if we do:\njoinOther(Foo.class, equal(getType), filtering(a, b -> a.getAge * b.getAge == 42))\nit is syntactic sugar for:\njoin(Foo.class, equal(getType), notEqual(), filtering(a, b -> a.getAge * b.getAge == 42))\nSo the first joiner remained the first joiner, but the second joiner became third joiner, because it's the first non-indexed joiner.", "author": "ge0ffrey", "createdAt": "2020-01-23T08:56:03Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -180,7 +190,332 @@\n      * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B>... joiners) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        int joinerCount = joiners.length;\n+        int indexOfFirstFilter = -1;\n+        for (int i = 0; i < joinerCount; i++) {\n+            BiJoiner<A, B> joiner = joiners[i];\n+            boolean hasAFilter = indexOfFirstFilter >= 0;\n+            if (joiner instanceof FilteringBiJoiner) {\n+                if (!hasAFilter) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+            } else if (hasAFilter) {\n+                throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow a filtering joiner (\"\n+                        + joiners[indexOfFirstFilter] + \").\");\n+            }\n+        }\n+        if (indexOfFirstFilter < 0) { // Only found indexing joiners.\n+            return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        }\n+        // Assemble the join stream.\n+        BiConstraintStream<A, B> joined = indexOfFirstFilter == 0 ?\n+                join(otherClass) :\n+                join(otherClass, Arrays.copyOf(joiners, indexOfFirstFilter));\n+        // We merge all filters into one, so that we don't pay the penalty for lack of indexing more than once.\n+        BiPredicate<A, B> resultingFilter = (a, b) -> true;\n+        for (int i = indexOfFirstFilter; i < joinerCount; i++) {\n+            FilteringBiJoiner<A, B> filteringJoiner = (FilteringBiJoiner<A, B>) joiners[i];\n+            resultingFilter = resultingFilter.and(filteringJoiner.getFilter());\n+        }\n+        return joined.filter(resultingFilter);\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every two different A.\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #joinOther(UniConstraintStream) joinOther}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.\n+     * @param otherStream never null\n+     * @return a stream that matches every combination of A and a different A\n+     */\n+    default BiConstraintStream<A, A> joinOther(UniConstraintStream<A> otherStream) {\n+        return join(otherStream, Joiners.notEqual());\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every combination of A and a different A for which the\n+     * {@link BiJoiner} is true (for the properties it extracts from both facts).\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #joinOther(UniConstraintStream) joinOther}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.\n+     * @param otherStream never null\n+     * @param joiner never null\n+     * @return a stream that matches every combination of A and a different A for which the {@link BiJoiner} is true\n+     */\n+    default BiConstraintStream<A, A> joinOther(UniConstraintStream<A> otherStream, BiJoiner<A, A> joiner) {\n+        if (joiner instanceof NoneBiJoiner) {\n+            return join(otherStream, Joiners.notEqual());\n+        } else {\n+            return join(otherStream, AbstractBiJoiner.merge(Joiners.notEqual(), joiner));", "originalCommit": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAwNDc0MA==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370004740", "bodyText": "Ordering of joiners is never changed. When notEqual() is added by the joinOther() statement, it as added as the first joiner.", "author": "triceo", "createdAt": "2020-01-23T09:19:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk5NDQ4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk5NTM1MA==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369995350", "bodyText": "The order of joiners gets changed here:\njoinOther(Foo.class, x, y z) should be join(Foo.class, x, y, z, notEquals())\nThat's currently not the case.", "author": "ge0ffrey", "createdAt": "2020-01-23T08:58:04Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -180,7 +190,332 @@\n      * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B>... joiners) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        int joinerCount = joiners.length;\n+        int indexOfFirstFilter = -1;\n+        for (int i = 0; i < joinerCount; i++) {\n+            BiJoiner<A, B> joiner = joiners[i];\n+            boolean hasAFilter = indexOfFirstFilter >= 0;\n+            if (joiner instanceof FilteringBiJoiner) {\n+                if (!hasAFilter) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+            } else if (hasAFilter) {\n+                throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow a filtering joiner (\"\n+                        + joiners[indexOfFirstFilter] + \").\");\n+            }\n+        }\n+        if (indexOfFirstFilter < 0) { // Only found indexing joiners.\n+            return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        }\n+        // Assemble the join stream.\n+        BiConstraintStream<A, B> joined = indexOfFirstFilter == 0 ?\n+                join(otherClass) :\n+                join(otherClass, Arrays.copyOf(joiners, indexOfFirstFilter));\n+        // We merge all filters into one, so that we don't pay the penalty for lack of indexing more than once.\n+        BiPredicate<A, B> resultingFilter = (a, b) -> true;\n+        for (int i = indexOfFirstFilter; i < joinerCount; i++) {\n+            FilteringBiJoiner<A, B> filteringJoiner = (FilteringBiJoiner<A, B>) joiners[i];\n+            resultingFilter = resultingFilter.and(filteringJoiner.getFilter());\n+        }\n+        return joined.filter(resultingFilter);\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every two different A.\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #joinOther(UniConstraintStream) joinOther}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.\n+     * @param otherStream never null\n+     * @return a stream that matches every combination of A and a different A\n+     */\n+    default BiConstraintStream<A, A> joinOther(UniConstraintStream<A> otherStream) {\n+        return join(otherStream, Joiners.notEqual());\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every combination of A and a different A for which the\n+     * {@link BiJoiner} is true (for the properties it extracts from both facts).\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #joinOther(UniConstraintStream) joinOther}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.\n+     * @param otherStream never null\n+     * @param joiner never null\n+     * @return a stream that matches every combination of A and a different A for which the {@link BiJoiner} is true\n+     */\n+    default BiConstraintStream<A, A> joinOther(UniConstraintStream<A> otherStream, BiJoiner<A, A> joiner) {\n+        if (joiner instanceof NoneBiJoiner) {\n+            return join(otherStream, Joiners.notEqual());\n+        } else {\n+            return join(otherStream, AbstractBiJoiner.merge(Joiners.notEqual(), joiner));\n+        }\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every combination of A and a different A for which the\n+     * {@link BiJoiner} is true (for the properties it extracts from both facts).\n+     * <p>\n+     * Important: {@link BiConstraintStream#filter(BiPredicate) Filtering} this is slower and less scalable\n+     * than a {@link #join(Class, BiJoiner)},\n+     * because it doesn't apply hashing and/or indexing on the properties,\n+     * so it creates and checks every combination of A and B.\n+     * <p>\n+     * This method is syntactic sugar for {@link #joinOther(UniConstraintStream)}.\n+     * @param otherClass never null\n+     * @return a stream that matches every combination of A and a different A\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass) {\n+        return join(otherClass, Joiners.notEqual());\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every combination of A and a different A for which thefor which the\n+     * {@link BiJoiner} is true (for the properties it extracts from both facts).\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #join(Class) join}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.\n+     * <p>\n+     * This method is syntactic sugar for {@link #join(UniConstraintStream, BiJoiner)}.\n+     * <p>\n+     * This method has overloaded methods with multiple {@link BiJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiner never null\n+     * @return a stream that matches every combination of A and a different A for which all the {@link BiJoiner joiner}\n+     * is true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A> joiner) {\n+        if (joiner instanceof FilteringBiJoiner) {\n+            FilteringBiJoiner<A, A> filteringJoiner = (FilteringBiJoiner<A, A>) joiner;\n+            return joinOther(otherClass)\n+                    .filter(filteringJoiner.getFilter());\n+        } else {\n+            return joinOther(getConstraintFactory().from(otherClass), joiner);\n+        }\n+    }\n+\n+    /**\n+     * As defined by {@link #joinOther(Class, BiJoiner)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @return a stream that matches every combination of A and a different A for which all the\n+     * {@link BiJoiner joiners} are true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A> joiner1, BiJoiner<A, A> joiner2) {\n+        return joinOther(otherClass, new BiJoiner[] {joiner1, joiner2});\n+    }\n+\n+    /**\n+     * As defined by {@link #joinOther(Class, BiJoiner)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @return a stream that matches every combination of A and a different A for which all the\n+     * {@link BiJoiner joiners} are true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A> joiner1, BiJoiner<A, A> joiner2,\n+            BiJoiner<A, A> joiner3) {\n+        return joinOther(otherClass, new BiJoiner[] {joiner1, joiner2, joiner3});\n+    }\n+\n+    /**\n+     * As defined by {@link #joinOther(Class, BiJoiner)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param joiner4 never null\n+     * @return a stream that matches every combination of A and a different A for which all the\n+     * {@link BiJoiner joiners} are true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A> joiner1, BiJoiner<A, A> joiner2,\n+            BiJoiner<A, A> joiner3, BiJoiner<A, A> joiner4) {\n+        return joinOther(otherClass, new BiJoiner[] {joiner1, joiner2, joiner3, joiner4});\n+    }\n+\n+    /**\n+     * As defined by {@link #joinOther(Class, BiJoiner)}.\n+     * <p>\n+     * This method causes <i>Unchecked generics array creation for varargs parameter</i> warnings,\n+     * but we can't fix it with a {@link SafeVarargs} annotation because it's an interface method.\n+     * Therefore, there are overloaded methods with up to 4 {@link BiJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiners never null\n+     * @return a stream that matches every combination of A and a different A for which all the\n+     * {@link BiJoiner joiners} are true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A>... joiners) {\n+        BiJoiner<A, A> otherness = Joiners.notEqual();\n+        BiJoiner[] allJoiners = Stream.concat(Stream.of(otherness), Arrays.stream(joiners))\n+                .toArray(BiJoiner[]::new);", "originalCommit": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk5NTY4Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369995683", "bodyText": "Motivation: The order of the joiners can heavily affect performance, so we must respect the user's order such that they can tweak it.", "author": "ge0ffrey", "createdAt": "2020-01-23T08:58:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk5NTM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAwNTQ1OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370005459", "bodyText": "I strongly disagree.\nWhen using joinOther(), your implicit assumption is that you'll be getting only those that are not equal. Therefore, the notEqual() joiner must come first.", "author": "triceo", "createdAt": "2020-01-23T09:20:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk5NTM1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAwNjQzNg==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370006436", "bodyText": "(I agree on the performance point. But the fact that you'll get this joiner with joinOther is just assumed - if you don't want this joiner, call join() and do whatever you wish.)", "author": "triceo", "createdAt": "2020-01-23T09:22:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk5NTM1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk5Nzc4OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r369997789", "bodyText": "Is this method ever going to be useful?\nWhat is the specification? If we have A1, A2, A3, ..., A100 they will match (= survive) if in these cases:\n\nthere is a B1\nthere is a B1, B2\nthere is a B1, B2, ..., 100\n\nbut not if\n\nthere not a single B.\n\nTheory: \"Nobody's every going to need this method.\" When in doubt, leave it out. Let the users tell us that they need and we 'll add it. Or let us feel the need for it in an example and let's then add it. But meanwhile, let's leave it out. Wydt?", "author": "ge0ffrey", "createdAt": "2020-01-23T09:03:58Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -180,7 +190,332 @@\n      * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B>... joiners) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        int joinerCount = joiners.length;\n+        int indexOfFirstFilter = -1;\n+        for (int i = 0; i < joinerCount; i++) {\n+            BiJoiner<A, B> joiner = joiners[i];\n+            boolean hasAFilter = indexOfFirstFilter >= 0;\n+            if (joiner instanceof FilteringBiJoiner) {\n+                if (!hasAFilter) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+            } else if (hasAFilter) {\n+                throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow a filtering joiner (\"\n+                        + joiners[indexOfFirstFilter] + \").\");\n+            }\n+        }\n+        if (indexOfFirstFilter < 0) { // Only found indexing joiners.\n+            return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        }\n+        // Assemble the join stream.\n+        BiConstraintStream<A, B> joined = indexOfFirstFilter == 0 ?\n+                join(otherClass) :\n+                join(otherClass, Arrays.copyOf(joiners, indexOfFirstFilter));\n+        // We merge all filters into one, so that we don't pay the penalty for lack of indexing more than once.\n+        BiPredicate<A, B> resultingFilter = (a, b) -> true;\n+        for (int i = indexOfFirstFilter; i < joinerCount; i++) {\n+            FilteringBiJoiner<A, B> filteringJoiner = (FilteringBiJoiner<A, B>) joiners[i];\n+            resultingFilter = resultingFilter.and(filteringJoiner.getFilter());\n+        }\n+        return joined.filter(resultingFilter);\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every two different A.\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #joinOther(UniConstraintStream) joinOther}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.\n+     * @param otherStream never null\n+     * @return a stream that matches every combination of A and a different A\n+     */\n+    default BiConstraintStream<A, A> joinOther(UniConstraintStream<A> otherStream) {\n+        return join(otherStream, Joiners.notEqual());\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every combination of A and a different A for which the\n+     * {@link BiJoiner} is true (for the properties it extracts from both facts).\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #joinOther(UniConstraintStream) joinOther}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.\n+     * @param otherStream never null\n+     * @param joiner never null\n+     * @return a stream that matches every combination of A and a different A for which the {@link BiJoiner} is true\n+     */\n+    default BiConstraintStream<A, A> joinOther(UniConstraintStream<A> otherStream, BiJoiner<A, A> joiner) {\n+        if (joiner instanceof NoneBiJoiner) {\n+            return join(otherStream, Joiners.notEqual());\n+        } else {\n+            return join(otherStream, AbstractBiJoiner.merge(Joiners.notEqual(), joiner));\n+        }\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every combination of A and a different A for which the\n+     * {@link BiJoiner} is true (for the properties it extracts from both facts).\n+     * <p>\n+     * Important: {@link BiConstraintStream#filter(BiPredicate) Filtering} this is slower and less scalable\n+     * than a {@link #join(Class, BiJoiner)},\n+     * because it doesn't apply hashing and/or indexing on the properties,\n+     * so it creates and checks every combination of A and B.\n+     * <p>\n+     * This method is syntactic sugar for {@link #joinOther(UniConstraintStream)}.\n+     * @param otherClass never null\n+     * @return a stream that matches every combination of A and a different A\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass) {\n+        return join(otherClass, Joiners.notEqual());\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every combination of A and a different A for which thefor which the\n+     * {@link BiJoiner} is true (for the properties it extracts from both facts).\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #join(Class) join}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.\n+     * <p>\n+     * This method is syntactic sugar for {@link #join(UniConstraintStream, BiJoiner)}.\n+     * <p>\n+     * This method has overloaded methods with multiple {@link BiJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiner never null\n+     * @return a stream that matches every combination of A and a different A for which all the {@link BiJoiner joiner}\n+     * is true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A> joiner) {\n+        if (joiner instanceof FilteringBiJoiner) {\n+            FilteringBiJoiner<A, A> filteringJoiner = (FilteringBiJoiner<A, A>) joiner;\n+            return joinOther(otherClass)\n+                    .filter(filteringJoiner.getFilter());\n+        } else {\n+            return joinOther(getConstraintFactory().from(otherClass), joiner);\n+        }\n+    }\n+\n+    /**\n+     * As defined by {@link #joinOther(Class, BiJoiner)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @return a stream that matches every combination of A and a different A for which all the\n+     * {@link BiJoiner joiners} are true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A> joiner1, BiJoiner<A, A> joiner2) {\n+        return joinOther(otherClass, new BiJoiner[] {joiner1, joiner2});\n+    }\n+\n+    /**\n+     * As defined by {@link #joinOther(Class, BiJoiner)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @return a stream that matches every combination of A and a different A for which all the\n+     * {@link BiJoiner joiners} are true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A> joiner1, BiJoiner<A, A> joiner2,\n+            BiJoiner<A, A> joiner3) {\n+        return joinOther(otherClass, new BiJoiner[] {joiner1, joiner2, joiner3});\n+    }\n+\n+    /**\n+     * As defined by {@link #joinOther(Class, BiJoiner)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param joiner4 never null\n+     * @return a stream that matches every combination of A and a different A for which all the\n+     * {@link BiJoiner joiners} are true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A> joiner1, BiJoiner<A, A> joiner2,\n+            BiJoiner<A, A> joiner3, BiJoiner<A, A> joiner4) {\n+        return joinOther(otherClass, new BiJoiner[] {joiner1, joiner2, joiner3, joiner4});\n+    }\n+\n+    /**\n+     * As defined by {@link #joinOther(Class, BiJoiner)}.\n+     * <p>\n+     * This method causes <i>Unchecked generics array creation for varargs parameter</i> warnings,\n+     * but we can't fix it with a {@link SafeVarargs} annotation because it's an interface method.\n+     * Therefore, there are overloaded methods with up to 4 {@link BiJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiners never null\n+     * @return a stream that matches every combination of A and a different A for which all the\n+     * {@link BiJoiner joiners} are true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A>... joiners) {\n+        BiJoiner<A, A> otherness = Joiners.notEqual();\n+        BiJoiner[] allJoiners = Stream.concat(Stream.of(otherness), Arrays.stream(joiners))\n+                .toArray(BiJoiner[]::new);\n+        return join(otherClass, allJoiners);\n+    }\n+\n+    // ************************************************************************\n+    // If Exists\n+    // ************************************************************************\n+\n+    /**\n+     * Create a new {@link UniConstraintStream} for every A, if B exists.\n+     * @param otherClass never null\n+     * @param <B> the type of the second matched fact\n+     * @return a stream that matches every A where a B exists\n+     */\n+    default <B> UniConstraintStream<A> ifExists(Class<B> otherClass) {", "originalCommit": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAwNTg4Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370005887", "bodyText": "I don't mind if we leave it out. I just remember having \"meta-objects\" in Drools working memory to signify some sort of a state change - do something if the state is X, but don't do it when it isn't.", "author": "triceo", "createdAt": "2020-01-23T09:21:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2OTk5Nzc4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAwMjkyNw==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370002927", "bodyText": "Start with \"never null\"? so \"@return never null, a stream that ...\" I see the join() javadocs fail to do that too, they should.", "author": "ge0ffrey", "createdAt": "2020-01-23T09:15:30Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -180,7 +190,332 @@\n      * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B>... joiners) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        int joinerCount = joiners.length;\n+        int indexOfFirstFilter = -1;\n+        for (int i = 0; i < joinerCount; i++) {\n+            BiJoiner<A, B> joiner = joiners[i];\n+            boolean hasAFilter = indexOfFirstFilter >= 0;\n+            if (joiner instanceof FilteringBiJoiner) {\n+                if (!hasAFilter) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+            } else if (hasAFilter) {\n+                throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow a filtering joiner (\"\n+                        + joiners[indexOfFirstFilter] + \").\");\n+            }\n+        }\n+        if (indexOfFirstFilter < 0) { // Only found indexing joiners.\n+            return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        }\n+        // Assemble the join stream.\n+        BiConstraintStream<A, B> joined = indexOfFirstFilter == 0 ?\n+                join(otherClass) :\n+                join(otherClass, Arrays.copyOf(joiners, indexOfFirstFilter));\n+        // We merge all filters into one, so that we don't pay the penalty for lack of indexing more than once.\n+        BiPredicate<A, B> resultingFilter = (a, b) -> true;\n+        for (int i = indexOfFirstFilter; i < joinerCount; i++) {\n+            FilteringBiJoiner<A, B> filteringJoiner = (FilteringBiJoiner<A, B>) joiners[i];\n+            resultingFilter = resultingFilter.and(filteringJoiner.getFilter());\n+        }\n+        return joined.filter(resultingFilter);\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every two different A.\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #joinOther(UniConstraintStream) joinOther}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.\n+     * @param otherStream never null\n+     * @return a stream that matches every combination of A and a different A\n+     */\n+    default BiConstraintStream<A, A> joinOther(UniConstraintStream<A> otherStream) {\n+        return join(otherStream, Joiners.notEqual());\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every combination of A and a different A for which the\n+     * {@link BiJoiner} is true (for the properties it extracts from both facts).\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #joinOther(UniConstraintStream) joinOther}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.\n+     * @param otherStream never null\n+     * @param joiner never null\n+     * @return a stream that matches every combination of A and a different A for which the {@link BiJoiner} is true\n+     */\n+    default BiConstraintStream<A, A> joinOther(UniConstraintStream<A> otherStream, BiJoiner<A, A> joiner) {\n+        if (joiner instanceof NoneBiJoiner) {\n+            return join(otherStream, Joiners.notEqual());\n+        } else {\n+            return join(otherStream, AbstractBiJoiner.merge(Joiners.notEqual(), joiner));\n+        }\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every combination of A and a different A for which the\n+     * {@link BiJoiner} is true (for the properties it extracts from both facts).\n+     * <p>\n+     * Important: {@link BiConstraintStream#filter(BiPredicate) Filtering} this is slower and less scalable\n+     * than a {@link #join(Class, BiJoiner)},\n+     * because it doesn't apply hashing and/or indexing on the properties,\n+     * so it creates and checks every combination of A and B.\n+     * <p>\n+     * This method is syntactic sugar for {@link #joinOther(UniConstraintStream)}.\n+     * @param otherClass never null\n+     * @return a stream that matches every combination of A and a different A\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass) {\n+        return join(otherClass, Joiners.notEqual());\n+    }\n+\n+    /**\n+     * Create a new {@link BiConstraintStream} for every combination of A and a different A for which thefor which the\n+     * {@link BiJoiner} is true (for the properties it extracts from both facts).\n+     * <p>\n+     * Important: This is faster and more scalable than a {@link #join(Class) join}\n+     * followed by a {@link BiConstraintStream#filter(BiPredicate) filter},\n+     * because it applies hashing and/or indexing on the properties,\n+     * so it doesn't create nor checks every combination of A and B.\n+     * <p>\n+     * This method is syntactic sugar for {@link #join(UniConstraintStream, BiJoiner)}.\n+     * <p>\n+     * This method has overloaded methods with multiple {@link BiJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiner never null\n+     * @return a stream that matches every combination of A and a different A for which all the {@link BiJoiner joiner}\n+     * is true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A> joiner) {\n+        if (joiner instanceof FilteringBiJoiner) {\n+            FilteringBiJoiner<A, A> filteringJoiner = (FilteringBiJoiner<A, A>) joiner;\n+            return joinOther(otherClass)\n+                    .filter(filteringJoiner.getFilter());\n+        } else {\n+            return joinOther(getConstraintFactory().from(otherClass), joiner);\n+        }\n+    }\n+\n+    /**\n+     * As defined by {@link #joinOther(Class, BiJoiner)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @return a stream that matches every combination of A and a different A for which all the\n+     * {@link BiJoiner joiners} are true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A> joiner1, BiJoiner<A, A> joiner2) {\n+        return joinOther(otherClass, new BiJoiner[] {joiner1, joiner2});\n+    }\n+\n+    /**\n+     * As defined by {@link #joinOther(Class, BiJoiner)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @return a stream that matches every combination of A and a different A for which all the\n+     * {@link BiJoiner joiners} are true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A> joiner1, BiJoiner<A, A> joiner2,\n+            BiJoiner<A, A> joiner3) {\n+        return joinOther(otherClass, new BiJoiner[] {joiner1, joiner2, joiner3});\n+    }\n+\n+    /**\n+     * As defined by {@link #joinOther(Class, BiJoiner)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param joiner4 never null\n+     * @return a stream that matches every combination of A and a different A for which all the\n+     * {@link BiJoiner joiners} are true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A> joiner1, BiJoiner<A, A> joiner2,\n+            BiJoiner<A, A> joiner3, BiJoiner<A, A> joiner4) {\n+        return joinOther(otherClass, new BiJoiner[] {joiner1, joiner2, joiner3, joiner4});\n+    }\n+\n+    /**\n+     * As defined by {@link #joinOther(Class, BiJoiner)}.\n+     * <p>\n+     * This method causes <i>Unchecked generics array creation for varargs parameter</i> warnings,\n+     * but we can't fix it with a {@link SafeVarargs} annotation because it's an interface method.\n+     * Therefore, there are overloaded methods with up to 4 {@link BiJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiners never null\n+     * @return a stream that matches every combination of A and a different A for which all the\n+     * {@link BiJoiner joiners} are true\n+     */\n+    default BiConstraintStream<A, A> joinOther(Class<A> otherClass, BiJoiner<A, A>... joiners) {\n+        BiJoiner<A, A> otherness = Joiners.notEqual();\n+        BiJoiner[] allJoiners = Stream.concat(Stream.of(otherness), Arrays.stream(joiners))\n+                .toArray(BiJoiner[]::new);\n+        return join(otherClass, allJoiners);\n+    }\n+\n+    // ************************************************************************\n+    // If Exists\n+    // ************************************************************************\n+\n+    /**\n+     * Create a new {@link UniConstraintStream} for every A, if B exists.\n+     * @param otherClass never null\n+     * @param <B> the type of the second matched fact\n+     * @return a stream that matches every A where a B exists\n+     */\n+    default <B> UniConstraintStream<A> ifExists(Class<B> otherClass) {\n+        return ifExists(otherClass, new NoneBiJoiner<>());\n+    }\n+\n+    /**\n+     * Create a new {@link UniConstraintStream} for every A where B exists for which the {@link BiJoiner} is true\n+     * (for the properties it extracts from both facts).\n+     * <p>\n+     * This method has overloaded methods with multiple {@link BiJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiner never null\n+     * @param <B> the type of the second matched fact\n+     * @return a stream that matches every A where B exists for which the {@link BiJoiner} is true", "originalCommit": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAwODQ5Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370008497", "bodyText": "Who's responsible for creaming off the FilteringBiJoiner? Is it UniConstraintStream or the Drools/BavetAbstractUniConstraintStream? currently I see code doing this in both the Uni as the BavetUni (and probably the DroolsUni too).\nCan we extra some of this into seperate method?", "author": "ge0ffrey", "createdAt": "2020-01-23T09:27:10Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/uni/BavetAbstractUniConstraintStream.java", "diffHunk": "@@ -90,8 +91,23 @@ public void addChildStream(BavetAbstractUniConstraintStream<Solution_, A> childS\n         }\n         if (!(joiner instanceof AbstractBiJoiner)) {\n             throw new IllegalArgumentException(\"The joiner class (\" + joiner.getClass() + \") is not supported.\");\n+        } else if (joiner instanceof FilteringBiJoiner) {\n+            return join(otherStream)\n+                    .filter(((FilteringBiJoiner<A, B>) joiner).getFilter());", "originalCommit": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDIwNDcxMQ==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370204711", "bodyText": "Unfortunately, this needs to happen here. This method could be called directly (and not through the other join() methods), and therefore this joiner could be a FilteringBiJoiner. There is no other case where that could happen.", "author": "triceo", "createdAt": "2020-01-23T15:58:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAwODQ5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUyMzgyMg==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370523822", "bodyText": "good point. Maybe we need to introduce a AbstractUniConstraintStream to capture code that is common between Drools and Bavet to avoid duplicating that code, without exposing it in the interface? Similar to how AbstractScoreDirector sits between ScoreDirector and DroolsScoreDirector/etc?\nWe could make an innerJoin() method that the implementations need to implement.\nNot sure if this is worth it's weight though? Such an extra layers don't help readability. Definitly not part of this PR even if we want to consider this, so +1 to merge this as it is now.", "author": "ge0ffrey", "createdAt": "2020-01-24T08:48:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAwODQ5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAwOTYwMA==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370009600", "bodyText": "Please add a Exceptions message that starts with \"Impossible state:\" (which indicates to the user: you should never see this, this is an OptaPlanner bug, this is not your fault). For example \"Impossible state: this joiner should never be treated like a normal joiner internally.\"", "author": "ge0ffrey", "createdAt": "2020-01-23T09:29:21Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bi/FilteringBiJoiner.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.bi;\n+\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.impl.score.stream.common.JoinerType;\n+\n+public final class FilteringBiJoiner<A, B> extends AbstractBiJoiner<A, B> {\n+\n+    public FilteringBiJoiner(BiPredicate<A, B> filter) {\n+        super(filter);\n+    }\n+\n+    @Override\n+    public Function<A, Object> getLeftMapping(int joinerId) {\n+        throw new UnsupportedOperationException();", "originalCommit": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDAxNzg0Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370017842", "bodyText": "This exception and the expected order of joiners should be probably described in a javadoc.\nThis fail-fast is not a super trivial check of inputs - it establishes a contract regarding in which order users are supposed to register joiners of different kinds. There should be a test for it.", "author": "rsynek", "createdAt": "2020-01-23T09:46:01Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -180,7 +190,332 @@\n      * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B>... joiners) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        int joinerCount = joiners.length;\n+        int indexOfFirstFilter = -1;\n+        for (int i = 0; i < joinerCount; i++) {\n+            BiJoiner<A, B> joiner = joiners[i];\n+            boolean hasAFilter = indexOfFirstFilter >= 0;\n+            if (joiner instanceof FilteringBiJoiner) {\n+                if (!hasAFilter) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+            } else if (hasAFilter) {\n+                throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow a filtering joiner (\"", "originalCommit": "4b31710a82d221d553b15cbe0d1c2fdf4a56a8aa", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a5d7eba4c75d1148c7eca52f3a4b24b6d96d948a", "url": "https://github.com/kiegroup/optaplanner/commit/a5d7eba4c75d1148c7eca52f3a4b24b6d96d948a", "message": "joinOther() is gone", "committedDate": "2020-01-23T10:27:42Z", "type": "commit"}, {"oid": "1b149ec15424ab0c6491bacbd68831dcad836141", "url": "https://github.com/kiegroup/optaplanner/commit/1b149ec15424ab0c6491bacbd68831dcad836141", "message": "Remove Joiners.notEquals()", "committedDate": "2020-01-23T15:25:54Z", "type": "commit"}, {"oid": "98fc116df718591207dc6881067aaaf8c3cb0798", "url": "https://github.com/kiegroup/optaplanner/commit/98fc116df718591207dc6881067aaaf8c3cb0798", "message": "Solve review comments", "committedDate": "2020-01-23T16:24:50Z", "type": "commit"}, {"oid": "d1aa1c33ca721c48d2cc9eb17b79bd64d3a4af95", "url": "https://github.com/kiegroup/optaplanner/commit/d1aa1c33ca721c48d2cc9eb17b79bd64d3a4af95", "message": "Add a leftover", "committedDate": "2020-01-23T16:47:21Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUxNTg0OA==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370515848", "bodyText": "Why do we need to handle the FilteringJoiner here already?\nThe join(UniStream, BiJoiner) method must also deal with wether or not that BiJoiner is a FilteringBiJoiner?\nI believe you can keep the original code on this change. And if that fails the test, then the problem is not in this method, but in the delegating method.", "author": "ge0ffrey", "createdAt": "2020-01-24T08:23:44Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -121,66 +125,268 @@\n      * @param otherClass never null\n      * @param joiner never null\n      * @param <B> the type of the second matched fact\n-     * @return a stream that matches every combination of A and B for which the {@link BiJoiner} is true\n+     * @return never null, a stream that matches every combination of A and B for which the {@link BiJoiner} is true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B> joiner) {\n-        return join(getConstraintFactory().from(otherClass), joiner);\n+        if (joiner instanceof FilteringBiJoiner) {\n+            FilteringBiJoiner<A, B> filteringJoiner = (FilteringBiJoiner<A, B>) joiner;\n+            return join(otherClass)\n+                    .filter(filteringJoiner.getFilter());\n+        } else {\n+            return join(getConstraintFactory().from(otherClass), joiner);", "originalCommit": "d1aa1c33ca721c48d2cc9eb17b79bd64d3a4af95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUxODM4MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370518381", "bodyText": "This puts the vararg method front-and-center. This has 2 issues:\n1)The vararg method suffers from \"Unchecked generics array creation for varargs parameter\" JDK warnings, which we can only fix by making the method non-abstract (which is obviously impossible). Therefore, I see the method as a necessary evil: not something we want to put front-and-center.\n2) This javadoc delegates to the vararg method javadoc, which in turn delegates to the single joiner method. Every extra click through looses users. Yet we do delegates due to reduce maintenance burden - and to make users that already know the base method, be able to \"start from there\". For varargs that latest approach doesn't work.\n3) vararg's javadoc is NOT a subset of this javadocs. For example, that warning doesn't apply here at all.", "author": "ge0ffrey", "createdAt": "2020-01-24T08:31:28Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -121,66 +125,268 @@\n      * @param otherClass never null\n      * @param joiner never null\n      * @param <B> the type of the second matched fact\n-     * @return a stream that matches every combination of A and B for which the {@link BiJoiner} is true\n+     * @return never null, a stream that matches every combination of A and B for which the {@link BiJoiner} is true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B> joiner) {\n-        return join(getConstraintFactory().from(otherClass), joiner);\n+        if (joiner instanceof FilteringBiJoiner) {\n+            FilteringBiJoiner<A, B> filteringJoiner = (FilteringBiJoiner<A, B>) joiner;\n+            return join(otherClass)\n+                    .filter(filteringJoiner.getFilter());\n+        } else {\n+            return join(getConstraintFactory().from(otherClass), joiner);\n+        }\n     }\n \n     /**\n-     * As defined by {@link #join(Class, BiJoiner)}.\n+     * As defined by {@link #join(Class, BiJoiner...)}.", "originalCommit": "d1aa1c33ca721c48d2cc9eb17b79bd64d3a4af95", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUxODU1Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370518557", "bodyText": "I recommend going back to delegating to the single joiner param, wdyt?", "author": "ge0ffrey", "createdAt": "2020-01-24T08:31:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUxODM4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUyMjQ5NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370522495", "bodyText": "Due to Lambda identity, I'd implement this slight different. Let me explain:\nThese 2 statements use the same lambda instance:\n\nfrom(A.class).join(B.class).filter(Objects::equal)\nfrom(A.class).join(B.class).filter(Objects::equal)\n\nThese 2 statements do NOT use the lambda instance:\n\nfrom(C.class).join(D.class).filter((c, d) -> c.equals(d))\nfrom(C.class).join(D.class).filter((c, d) -> c.equals(d))\n\nYou can try this out by printing System.systemHashCode() on those BiPredicates.\nNow, why do we care about that? Because of node sharing in Drools AND Bavet.\nIf its the same lambda instance, node sharing work guaranteed.\nIf it isn't, Bavet won't see it and Drools has some dirty ASM magic that might or might not recognize they are the same code.\nUnfortunately, there is no Objects.notEquals in java.util.Objects.\nApache commons-lang3 does have ObjectUtils.notEqual, presuming we want to use that, I would write:\nreturn ifExists(otherClass, Joiners.filtering(ObjectUtils::notEqual);", "author": "ge0ffrey", "createdAt": "2020-01-24T08:44:02Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/uni/UniConstraintStream.java", "diffHunk": "@@ -121,66 +125,268 @@\n      * @param otherClass never null\n      * @param joiner never null\n      * @param <B> the type of the second matched fact\n-     * @return a stream that matches every combination of A and B for which the {@link BiJoiner} is true\n+     * @return never null, a stream that matches every combination of A and B for which the {@link BiJoiner} is true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B> joiner) {\n-        return join(getConstraintFactory().from(otherClass), joiner);\n+        if (joiner instanceof FilteringBiJoiner) {\n+            FilteringBiJoiner<A, B> filteringJoiner = (FilteringBiJoiner<A, B>) joiner;\n+            return join(otherClass)\n+                    .filter(filteringJoiner.getFilter());\n+        } else {\n+            return join(getConstraintFactory().from(otherClass), joiner);\n+        }\n     }\n \n     /**\n-     * As defined by {@link #join(Class, BiJoiner)}.\n+     * As defined by {@link #join(Class, BiJoiner...)}.\n      * @param otherClass never null\n      * @param joiner1 never null\n      * @param joiner2 never null\n      * @param <B> the type of the second matched fact\n-     * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n+     * @return never null, a stream that matches every combination of A and B for which all the {@link BiJoiner joiners}\n+     * are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B> joiner1, BiJoiner<A, B> joiner2) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiner1, joiner2));\n+        return join(otherClass, new BiJoiner[] {joiner1, joiner2});\n     }\n \n     /**\n-     * As defined by {@link #join(Class, BiJoiner)}.\n+     * As defined by {@link #join(Class, BiJoiner...)}.\n      * @param otherClass never null\n      * @param joiner1 never null\n      * @param joiner2 never null\n      * @param joiner3 never null\n      * @param <B> the type of the second matched fact\n-     * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n+     * @return never null, a stream that matches every combination of A and B for which all the {@link BiJoiner joiners}\n+     * are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B> joiner1, BiJoiner<A, B> joiner2,\n             BiJoiner<A, B> joiner3) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiner1, joiner2, joiner3));\n+        return join(otherClass, new BiJoiner[] {joiner1, joiner2, joiner3});\n     }\n \n     /**\n-     * As defined by {@link #join(Class, BiJoiner)}.\n+     * As defined by {@link #join(Class, BiJoiner...)}.\n      * @param otherClass never null\n      * @param joiner1 never null\n      * @param joiner2 never null\n      * @param joiner3 never null\n      * @param joiner4 never null\n      * @param <B> the type of the second matched fact\n-     * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n+     * @return never null, a stream that matches every combination of A and B for which all the {@link BiJoiner joiners}\n+     * are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B> joiner1, BiJoiner<A, B> joiner2,\n             BiJoiner<A, B> joiner3, BiJoiner<A, B> joiner4) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiner1, joiner2, joiner3, joiner4));\n+        return join(otherClass, new BiJoiner[] {joiner1, joiner2, joiner3, joiner4});\n     }\n \n     /**\n-     * As defined by {@link #join(Class, BiJoiner)}.\n+     * As defined by {@link #join(Class, BiJoiner)}. If multiple {@link BiJoiner}s are provided, for performance\n+     * reasons, the indexing joiners must be placed before filtering joiners.\n      * <p>\n      * This method causes <i>Unchecked generics array creation for varargs parameter</i> warnings,\n      * but we can't fix it with a {@link SafeVarargs} annotation because it's an interface method.\n      * Therefore, there are overloaded methods with up to 4 {@link BiJoiner} parameters.\n      * @param otherClass never null\n      * @param joiners never null\n      * @param <B> the type of the second matched fact\n-     * @return a stream that matches every combination of A and B for which all the {@link BiJoiner joiners} are true\n+     * @return never null, a stream that matches every combination of A and B for which all the {@link BiJoiner joiners}\n+     * are true\n      */\n     default <B> BiConstraintStream<A, B> join(Class<B> otherClass, BiJoiner<A, B>... joiners) {\n-        return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        int joinerCount = joiners.length;\n+        int indexOfFirstFilter = -1;\n+        // Make sure all indexing joiners, if any, come before filtering joiners. This is necessary for performance.\n+        for (int i = 0; i < joinerCount; i++) {\n+            BiJoiner<A, B> joiner = joiners[i];\n+            if (indexOfFirstFilter >= 0) {\n+                if (!(joiner instanceof FilteringBiJoiner)) {\n+                    throw new IllegalStateException(\"Indexing joiner (\" + joiner + \") must not follow \" +\n+                            \"a filtering joiner (\" + joiners[indexOfFirstFilter] + \").\\n\" +\n+                            \"Maybe reorder the joiners such that filtering() joiners are later in the parameter list.\");\n+                }\n+            } else {\n+                if (joiner instanceof FilteringBiJoiner) { // From now on, we only allow filtering joiners.\n+                    indexOfFirstFilter = i;\n+                }\n+            }\n+        }\n+        if (indexOfFirstFilter < 0) { // Only found indexing joiners.\n+            return join(otherClass, AbstractBiJoiner.merge(joiners));\n+        }\n+        // Assemble the join stream that may be followed by filter stream.\n+        BiConstraintStream<A, B> joined = indexOfFirstFilter == 0 ?\n+                join(otherClass) :\n+                join(otherClass, Arrays.copyOf(joiners, indexOfFirstFilter));\n+        int filterCount = joinerCount - indexOfFirstFilter;\n+        if (filterCount == 0) { // No filters, return the original join stream.\n+            return joined;\n+        }\n+        // We merge all filters into one, so that we don't pay the penalty for lack of indexing more than once.\n+        FilteringBiJoiner<A, B> filteringJoiner = (FilteringBiJoiner<A, B>) joiners[indexOfFirstFilter];\n+        BiPredicate<A, B> resultingFilter = filteringJoiner.getFilter();\n+        for (int i = indexOfFirstFilter + 1; i < joinerCount; i++) {\n+            FilteringBiJoiner<A, B> anoterFilteringJoiner = (FilteringBiJoiner<A, B>) joiners[i];\n+            resultingFilter = resultingFilter.and(anoterFilteringJoiner.getFilter());\n+        }\n+        return joined.filter(resultingFilter);\n+    }\n+\n+    // ************************************************************************\n+    // If Exists\n+    // ************************************************************************\n+\n+    /**\n+     * Create a new {@link UniConstraintStream} for every A where B exists for which the {@link BiJoiner} is true\n+     * (for the properties it extracts from both facts).\n+     * <p>\n+     * This method has overloaded methods with multiple {@link BiJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiner never null\n+     * @param <B> the type of the second matched fact\n+     * @return never null, a stream that matches every A where B exists for which the {@link BiJoiner} is true\n+     */\n+    default <B> UniConstraintStream<A> ifExists(Class<B> otherClass, BiJoiner<A, B> joiner) {\n+        return ifExists(otherClass, new BiJoiner[] { joiner });\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, BiJoiner...)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param <B> the type of the second matched fact\n+     * @return never null, a stream that matches every A where B exists for which all the {@link BiJoiner}s are true\n+     */\n+    default <B> UniConstraintStream<A> ifExists(Class<B> otherClass, BiJoiner<A, B> joiner1, BiJoiner<A, B> joiner2) {\n+        return ifExists(otherClass, new BiJoiner[] {joiner1, joiner2});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, BiJoiner...)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param <B> the type of the second matched fact\n+     * @return never null, a stream that matches every A where B exists for which all the {@link BiJoiner}s are true\n+     */\n+    default <B> UniConstraintStream<A> ifExists(Class<B> otherClass, BiJoiner<A, B> joiner1, BiJoiner<A, B> joiner2,\n+            BiJoiner<A, B> joiner3) {\n+        return ifExists(otherClass, new BiJoiner[] {joiner1, joiner2, joiner3});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, BiJoiner...)}.\n+     * @param otherClass never null\n+     * @param joiner1 never null\n+     * @param joiner2 never null\n+     * @param joiner3 never null\n+     * @param joiner4 never null\n+     * @param <B> the type of the second matched fact\n+     * @return never null, a stream that matches every A where B exists for which all the {@link BiJoiner}s are true\n+     */\n+    default <B> UniConstraintStream<A> ifExists(Class<B> otherClass, BiJoiner<A, B> joiner1, BiJoiner<A, B> joiner2,\n+            BiJoiner<A, B> joiner3, BiJoiner<A, B> joiner4) {\n+        return ifExists(otherClass, new BiJoiner[] {joiner1, joiner2, joiner3, joiner4});\n+    }\n+\n+    /**\n+     * As defined by {@link #ifExists(Class, BiJoiner...)}.\n+     * <p>\n+     * This method causes <i>Unchecked generics array creation for varargs parameter</i> warnings,\n+     * but we can't fix it with a {@link SafeVarargs} annotation because it's an interface method.\n+     * Therefore, there are overloaded methods with up to 4 {@link BiJoiner} parameters.\n+     * @param otherClass never null\n+     * @param joiners never null\n+     * @param <B> the type of the second matched fact\n+     * @return never null, a stream that matches every A where B exists for which all the {@link BiJoiner}s are true\n+     */\n+    <B> UniConstraintStream<A> ifExists(Class<B> otherClass, BiJoiner<A, B>... joiners);\n+\n+    /**\n+     * Create a new {@link UniConstraintStream} for every A, if another A exists that does not {@link #equals(Object)}\n+     * the first. If multiple {@link BiJoiner}s are provided, for performance reasons, the indexing joiners must be\n+     * placed before filtering joiners.\n+     * @param otherClass never null\n+     * @return never null, a stream that matches every A where a different A exists\n+     */\n+    default UniConstraintStream<A> ifExistsOther(Class<A> otherClass) {\n+        return ifExists(otherClass, Joiners.filtering((a, b) -> !a.equals(b)));", "originalCommit": "d1aa1c33ca721c48d2cc9eb17b79bd64d3a4af95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MDUyNTg5MA==", "url": "https://github.com/kiegroup/optaplanner/pull/660#discussion_r370525890", "bodyText": "Just noticed (not a problem in this PR). This joinerId is not an ID, it's an index, for CombinedBiJoiners. That variable should be renamed to joinerIndex or just index (I 'd say the latter). Again, doesn't need to happen in this PR.\nWhat the different between an ID and and index?\nID's have gaps, as elements get deleted. Examples of ID's: 0, 1, 2, 4, 7\nIndexes don't have gaps, they would naturally change if elements get deleted (ussually they won't): Examples of index: 0, 1, 2, 3, 4, 5", "author": "ge0ffrey", "createdAt": "2020-01-24T08:53:37Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bi/FilteringBiJoiner.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.score.stream.bi;\n+\n+import java.util.function.BiPredicate;\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.impl.score.stream.common.JoinerType;\n+\n+public final class FilteringBiJoiner<A, B> extends AbstractBiJoiner<A, B> {\n+\n+    public FilteringBiJoiner(BiPredicate<A, B> filter) {\n+        super(filter);\n+    }\n+\n+    @Override\n+    public Function<A, Object> getLeftMapping(int joinerId) {", "originalCommit": "d1aa1c33ca721c48d2cc9eb17b79bd64d3a4af95", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2d3a7f66acff3f8992f4661f58c4b86503f55758", "url": "https://github.com/kiegroup/optaplanner/commit/2d3a7f66acff3f8992f4661f58c4b86503f55758", "message": "Address the final review comments", "committedDate": "2020-01-24T08:58:40Z", "type": "commit"}]}