{"pr_number": 712, "pr_title": "PLANNER-1865 Disable Drools rules when constraint weight is zero", "pr_createdAt": "2020-03-03T17:18:45Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/712", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzM0MzAwOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/712#discussion_r387343009", "bodyText": "I'll refactor this to disabledConstraintIdSet - that will cause less operations with the collection, and therefore perform better.", "author": "triceo", "createdAt": "2020-03-03T22:51:20Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/DroolsConstraintSessionFactory.java", "diffHunk": "@@ -42,30 +49,65 @@\n public class DroolsConstraintSessionFactory<Solution_> implements ConstraintSessionFactory<Solution_> {\n \n     private final SolutionDescriptor<Solution_> solutionDescriptor;\n-    private final KieBase kieBase;\n-    private final Map<Rule, DroolsConstraint<Solution_>> constraints;\n+    private final Model originalModel;\n+    private KieBase originalKieBase;\n+    private KieBase activeKieBase;\n+    private Set<String> activeConstraintIdSet = null;\n+    private final Map<Rule, DroolsConstraint<Solution_>> compiledRuleToConstraintMap;\n+    private final Map<String, org.drools.model.Rule> constraintToModelRuleMap;\n \n-    public DroolsConstraintSessionFactory(SolutionDescriptor<Solution_> solutionDescriptor, KieBase kieBase,\n+    public DroolsConstraintSessionFactory(SolutionDescriptor<Solution_> solutionDescriptor, Model model,\n             List<DroolsConstraint<Solution_>> constraintList) {\n         this.solutionDescriptor = solutionDescriptor;\n-        this.kieBase = kieBase;\n-        this.constraints = constraintList.stream()\n-                .collect(toMap(constraint -> kieBase.getRule(constraint.getConstraintPackage(),\n+        this.originalModel = model;\n+        this.originalKieBase = KieBaseBuilder.createKieBaseFromModel(model);\n+        this.activeKieBase = originalKieBase;\n+        this.compiledRuleToConstraintMap = constraintList.stream()\n+                .collect(toMap(constraint -> activeKieBase.getRule(constraint.getConstraintPackage(),\n                         constraint.getConstraintName()), Function.identity()));\n+        this.constraintToModelRuleMap = constraintList.stream()\n+                .collect(toMap(Constraint::getConstraintId, constraint -> model.getRules().stream()\n+                        .filter(rule -> Objects.equals(rule.getName(), constraint.getConstraintName()))\n+                        .filter(rule -> Objects.equals(rule.getPackage(), constraint.getConstraintPackage()))\n+                        .findFirst()\n+                        .orElseThrow(() -> new IllegalStateException(\"Programming error: Rule for constraint (\" +\n+                                constraint + \") not found.\"))));\n     }\n \n     @Override\n     public ConstraintSession<Solution_> buildSession(boolean constraintMatchEnabled, Solution_ workingSolution) {\n         ScoreDefinition scoreDefinition = solutionDescriptor.getScoreDefinition();\n         AbstractScoreHolder scoreHolder = (AbstractScoreHolder) scoreDefinition.buildScoreHolder(constraintMatchEnabled);\n         scoreHolder.setJustificationListConverter((justificationList, rule) ->\n-                matchJustificationsToOutput((List<Object>) justificationList, constraints.get(rule).getExpectedJustificationTypes()));\n-        constraints.forEach((rule, constraint) -> scoreHolder.configureConstraintWeight(rule,\n-                constraint.extractConstraintWeight(workingSolution)));\n-        KieSession kieSession = kieBase.newKieSession();\n-        ((RuleEventManager) kieSession).addEventListener(new OptaPlannerRuleEventListener()); // Enables undo in rules\n+                matchJustificationsToOutput((List<Object>) justificationList,\n+                        compiledRuleToConstraintMap.get(rule).getExpectedJustificationTypes()));\n+        // Determine which rules to enable based on the fact that their constraints carry weight.\n+        Score<?> zero = scoreDefinition.getZeroScore();\n+        Set<String> enabledConstraintIdSet = new LinkedHashSet<>(compiledRuleToConstraintMap.size());", "originalCommit": "606cb28e9d74d1f9326350df9e657acd6cf88eec", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwMTcwMQ==", "url": "https://github.com/kiegroup/optaplanner/pull/712#discussion_r389601701", "bodyText": "Soft: might be worth extracting a NO_OP_UNDO into AbstractConstraintStream?", "author": "ge0ffrey", "createdAt": "2020-03-09T11:26:24Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/bavet/bi/BavetScoringBiConstraintStream.java", "diffHunk": "@@ -113,6 +113,9 @@ private BavetScoringBiConstraintStream(BavetConstraintFactory<Solution_> constra\n             if (intMatchWeigher != null) {\n                 scoreImpacter = (A a, B b, Consumer<Score<?>> matchScoreConsumer) -> {\n                     int matchWeight = intMatchWeigher.applyAsInt(a, b);\n+                    if (matchWeight == 0) { // No need to include and no need to undo later.\n+                        return () -> { /* NOOP */ };", "originalCommit": "f2e006390396d70576ef718c73f75a439845dd0a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwMjg3Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/712#discussion_r389602876", "bodyText": "I still wonder if it shouldn't fail fast if the matchWeight is zero.\nActually, thinking about this more - we probably want to have the indictment anyway, even if the matchWeigh is zero...  even if it's just for debugging purposes - for easy of debugging. Let's discuss.", "author": "ge0ffrey", "createdAt": "2020-03-09T11:29:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwMTcwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwMzUxMw==", "url": "https://github.com/kiegroup/optaplanner/pull/712#discussion_r389603513", "bodyText": "Same here: if a matchWeigth is zero, it probably shouldn't disable the indictment. For clarity: If the constraintWeight is zero, it should (and the entire constraint execution too, as it does in the rest of this PR).", "author": "ge0ffrey", "createdAt": "2020-03-09T11:30:37Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/score/stream/drools/common/DroolsCondition.java", "diffHunk": "@@ -175,20 +175,29 @@ protected DroolsCondition(T ruleStructure) {\n \n     protected <S extends Score<S>, H extends AbstractScoreHolder<S>> void impactScore(DroolsConstraint<?> constraint,\n             Drools drools, H scoreHolder, int impact) {\n+        if (impact == 0) { // No need to include and no need to undo later.\n+            return;\n+        }", "originalCommit": "f2e006390396d70576ef718c73f75a439845dd0a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "85ca83d05474dab3a0df594185500866966f03d6", "url": "https://github.com/kiegroup/optaplanner/commit/85ca83d05474dab3a0df594185500866966f03d6", "message": "Don't do (and undo) zero matches", "committedDate": "2020-03-10T09:26:51Z", "type": "commit"}, {"oid": "072ee93fd57cc838b6785fe4a66955f4300b253e", "url": "https://github.com/kiegroup/optaplanner/commit/072ee93fd57cc838b6785fe4a66955f4300b253e", "message": "Disable rules when necessary", "committedDate": "2020-03-10T09:27:50Z", "type": "commit"}, {"oid": "83f113bb5c5135907c1c2c27d26b0f653e2f806d", "url": "https://github.com/kiegroup/optaplanner/commit/83f113bb5c5135907c1c2c27d26b0f653e2f806d", "message": "Improvements", "committedDate": "2020-03-10T09:27:50Z", "type": "commit"}, {"oid": "7aca855e5c430e488f304f3d1aafd9272c04b37e", "url": "https://github.com/kiegroup/optaplanner/commit/7aca855e5c430e488f304f3d1aafd9272c04b37e", "message": "Comments", "committedDate": "2020-03-10T09:27:50Z", "type": "commit"}, {"oid": "b07c2d3cf9918961f6ebde68ba9784503bbcfd53", "url": "https://github.com/kiegroup/optaplanner/commit/b07c2d3cf9918961f6ebde68ba9784503bbcfd53", "message": "Refactor", "committedDate": "2020-03-10T09:27:50Z", "type": "commit"}, {"oid": "715aaaaf30935becb8e1030c6e3de118068712b5", "url": "https://github.com/kiegroup/optaplanner/commit/715aaaaf30935becb8e1030c6e3de118068712b5", "message": "Revert \"Don't do (and undo) zero matches\"\n\nThis reverts commit 8a7459df", "committedDate": "2020-03-10T09:27:50Z", "type": "commit"}, {"oid": "dac85ad4d82c1260a27a51dcf1592c833b642445", "url": "https://github.com/kiegroup/optaplanner/commit/dac85ad4d82c1260a27a51dcf1592c833b642445", "message": "Revert \"Don't do (and undo) zero matches\"\n\nThis reverts commit 8a7459df", "committedDate": "2020-03-10T09:27:50Z", "type": "commit"}, {"oid": "dac85ad4d82c1260a27a51dcf1592c833b642445", "url": "https://github.com/kiegroup/optaplanner/commit/dac85ad4d82c1260a27a51dcf1592c833b642445", "message": "Revert \"Don't do (and undo) zero matches\"\n\nThis reverts commit 8a7459df", "committedDate": "2020-03-10T09:27:50Z", "type": "forcePushed"}]}