{"pr_number": 872, "pr_title": "Planner-1823 Add ConstraintProvider for Patient Admission Scheduling example", "pr_createdAt": "2020-08-07T17:40:43Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/872", "timeline": [{"oid": "5f594686a67128bd72d97e81e3726e4715e4d2bd", "url": "https://github.com/kiegroup/optaplanner/commit/5f594686a67128bd72d97e81e3726e4715e4d2bd", "message": "Implement constraint stream based rule femaleInMaleRoomTest\n\nAdded new implementation of \"Gender limitation: Female in a male only room\" based on streams [1] without checking if that equals to drl score\n\nTo test if that is working you can run example with smaller\ndataset\n\nhttps://issues.redhat.com/secure/attachment/12482176/smallDataSet.txt\n\n[1] https://docs.optaplanner.org/latest/optaplanner-docs/html_single/index.html#constraintStreams", "committedDate": "2020-07-30T09:23:56Z", "type": "commit"}, {"oid": "ed02700890d301057b6936b1adb516b59f173652", "url": "https://github.com/kiegroup/optaplanner/commit/ed02700890d301057b6936b1adb516b59f173652", "message": "Involve drl assignment to check stream implementation\n\nTo decide if stream is working correctly I add configuration\nSo if stream implementation got different score it should throw an exception like\n\n``` Score corruption (2450hard): the workingScore (-250hard/0medium/0soft) is not the uncorruptedScore (-2700hard/0medium/0soft) after completedAction (Patient1(0-4) {11(0) -> 11(0)}):\nScore corruption analysis:\n  The corrupted scoreDirector has 1 ConstraintMatch(s) which are in excess (and should not be there):\n    org.optaplanner.examples.pas.domain/femaleInMaleRoom/[Patient1(0-4)]=-250hard/0medium/0soft\n  The corrupted scoreDirector has 1 ConstraintMatch(s) which are missing:\n    org.optaplanner.examples.pas.solver/femaleInMaleRoom/[Patient1(0-4)]=-2700hard/0medium/0soft\n  Maybe there is a bug in the score constraints of those ConstraintMatch(s).\n  Maybe a score constraint doesn't select all the entities it depends on, but finds some through a reference in a selected entity. This corrupts incremental score calculation, because the constraint is not re-evaluated if such a non-selected entity changes.```", "committedDate": "2020-07-30T13:48:59Z", "type": "commit"}, {"oid": "96a8dfb82c31693e0986b69789326dfed7ec8458", "url": "https://github.com/kiegroup/optaplanner/commit/96a8dfb82c31693e0986b69789326dfed7ec8458", "message": "Implement sameBedInSameNightConstraint rule", "committedDate": "2020-08-05T11:47:18Z", "type": "commit"}, {"oid": "f89c3d59a06e8fa89ffb653e7f40e5caffec71fd", "url": "https://github.com/kiegroup/optaplanner/commit/f89c3d59a06e8fa89ffb653e7f40e5caffec71fd", "message": "Implement the rest drl constraints\n\nPLANNER-2096", "committedDate": "2020-08-07T14:06:43Z", "type": "commit"}, {"oid": "8a77adbe40cd58339450dc3ec51b8258fbb4dd2e", "url": "https://github.com/kiegroup/optaplanner/commit/8a77adbe40cd58339450dc3ec51b8258fbb4dd2e", "message": "Cleanup constraints implementations\n\nDuring constraints implementation I used tests written in plain way, also I wrote constraints based on the tasks not on the current implementation in drl.\n\nI adjusted a bit constraints tested one by one and in integration with other constraints.\n\nI created test object BedDesignationDO so to make tests more readable", "committedDate": "2020-08-07T17:29:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MDUxNg==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467190516", "bodyText": "Personally, I see this class as unnecessary complexity - I'd simply change BedDesignation to add the constructors etc.\nThe other examples do it the same way, so I'd appreciate if we stayed consistent.", "author": "triceo", "createdAt": "2020-08-07T18:02:14Z", "path": "optaplanner-examples/src/test/java/org/optaplanner/examples/pas/solver/BedDesignationDO.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.optaplanner.examples.pas.solver;\n+\n+import org.optaplanner.examples.pas.domain.AdmissionPart;\n+import org.optaplanner.examples.pas.domain.Bed;\n+import org.optaplanner.examples.pas.domain.BedDesignation;\n+import org.optaplanner.examples.pas.domain.Night;\n+import org.optaplanner.examples.pas.domain.Patient;\n+import org.optaplanner.examples.pas.domain.Room;\n+import org.optaplanner.examples.pas.domain.Specialism;\n+\n+public class BedDesignationDO extends BedDesignation {", "originalCommit": "8a77adbe40cd58339450dc3ec51b8258fbb4dd2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg2OTM5Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467869392", "bodyText": "Ok, just a proposal. Will add with methods", "author": "dupliaka", "createdAt": "2020-08-10T12:29:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MDUxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg4Mjk1Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467882957", "bodyText": "7dd1551", "author": "dupliaka", "createdAt": "2020-08-10T12:55:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MDUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MTkyMQ==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467191921", "bodyText": "null checks for planning variables are not necessary in Constraint Streams. fromUniquePair will make sure bed is never null.\nPlease check for this in the other constraints as well.", "author": "triceo", "createdAt": "2020-08-07T18:05:15Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/pas/solver/score/PatientAdmissionMoveConstraintProvider.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.optaplanner.examples.pas.solver.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.pas.domain.BedDesignation;\n+import org.optaplanner.examples.pas.domain.Department;\n+import org.optaplanner.examples.pas.domain.DepartmentSpecialism;\n+import org.optaplanner.examples.pas.domain.Gender;\n+import org.optaplanner.examples.pas.domain.GenderLimitation;\n+import org.optaplanner.examples.pas.domain.PreferredPatientEquipment;\n+import org.optaplanner.examples.pas.domain.RequiredPatientEquipment;\n+import org.optaplanner.examples.pas.domain.RoomEquipment;\n+import org.optaplanner.examples.pas.domain.RoomSpecialism;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+/*\n+ * This is constraints for Hospital Bed Planning\n+ * They are based on patientAdmissionScheduleConstraints.drl\n+ * Planning Entity: BedDesignation\n+ * Planning Variable: Bed(nullable) - would not be prefiltered on uninitialized solutions\n+ * Bed is nullable so in case you need to access it members check that planning value bed is not null\n+ */\n+\n+public class PatientAdmissionMoveConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                sameBedInSameNightConstraint(constraintFactory),\n+                femaleInMaleRoomConstraint(constraintFactory),\n+                maleInFemaleRoomConstraint(constraintFactory),\n+                differentGenderInSameGenderRoomInSameNightConstraint(constraintFactory),\n+                departmentMinimumAgeConstraint(constraintFactory),\n+                departmentMaximumAgeConstraint(constraintFactory),\n+                requiredPatientEquipmentConstraint(constraintFactory),\n+                assignEveryPatientToABedConstraint(constraintFactory),\n+                preferredMaximumRoomCapacityConstraint(constraintFactory),\n+                departmentSpecialismConstraint(constraintFactory),\n+                roomSpecialismNotExistsConstraint(constraintFactory),\n+                roomSpecialismNotFirstPriorityConstraint(constraintFactory),\n+                preferredPatientEquipmentConstraint(constraintFactory)\n+        };\n+    }\n+\n+    public Constraint sameBedInSameNightConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUniquePair(BedDesignation.class)\n+                .filter((left, right) -> left.getBed() != null\n+                        && right.getBed() != null", "originalCommit": "8a77adbe40cd58339450dc3ec51b8258fbb4dd2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg2ODQwMA==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467868400", "bodyText": "Ignoring since bed is nullable", "author": "dupliaka", "createdAt": "2020-08-10T12:27:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MTkyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MjE2Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467192162", "bodyText": "Please use Joiners.equal(BedDesignation::getBed) for this.", "author": "triceo", "createdAt": "2020-08-07T18:05:48Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/pas/solver/score/PatientAdmissionMoveConstraintProvider.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.optaplanner.examples.pas.solver.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.pas.domain.BedDesignation;\n+import org.optaplanner.examples.pas.domain.Department;\n+import org.optaplanner.examples.pas.domain.DepartmentSpecialism;\n+import org.optaplanner.examples.pas.domain.Gender;\n+import org.optaplanner.examples.pas.domain.GenderLimitation;\n+import org.optaplanner.examples.pas.domain.PreferredPatientEquipment;\n+import org.optaplanner.examples.pas.domain.RequiredPatientEquipment;\n+import org.optaplanner.examples.pas.domain.RoomEquipment;\n+import org.optaplanner.examples.pas.domain.RoomSpecialism;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+/*\n+ * This is constraints for Hospital Bed Planning\n+ * They are based on patientAdmissionScheduleConstraints.drl\n+ * Planning Entity: BedDesignation\n+ * Planning Variable: Bed(nullable) - would not be prefiltered on uninitialized solutions\n+ * Bed is nullable so in case you need to access it members check that planning value bed is not null\n+ */\n+\n+public class PatientAdmissionMoveConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                sameBedInSameNightConstraint(constraintFactory),\n+                femaleInMaleRoomConstraint(constraintFactory),\n+                maleInFemaleRoomConstraint(constraintFactory),\n+                differentGenderInSameGenderRoomInSameNightConstraint(constraintFactory),\n+                departmentMinimumAgeConstraint(constraintFactory),\n+                departmentMaximumAgeConstraint(constraintFactory),\n+                requiredPatientEquipmentConstraint(constraintFactory),\n+                assignEveryPatientToABedConstraint(constraintFactory),\n+                preferredMaximumRoomCapacityConstraint(constraintFactory),\n+                departmentSpecialismConstraint(constraintFactory),\n+                roomSpecialismNotExistsConstraint(constraintFactory),\n+                roomSpecialismNotFirstPriorityConstraint(constraintFactory),\n+                preferredPatientEquipmentConstraint(constraintFactory)\n+        };\n+    }\n+\n+    public Constraint sameBedInSameNightConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUniquePair(BedDesignation.class)\n+                .filter((left, right) -> left.getBed() != null\n+                        && right.getBed() != null\n+                        && left.getBed() == right.getBed()", "originalCommit": "8a77adbe40cd58339450dc3ec51b8258fbb4dd2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg0MDY4OA==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467840688", "bodyText": "BTW is that worth to mention that fromUniquePair is a syntax sugar as here: http://github.com/dupliaka/optaplanner/blob/PLANNER-1823/optaplanner-core/src/main/java/org/optaplanner/core/api/score/stream/ConstraintFactory.java#L95-L95\nSince I was beliving that sugared syntax should behave absolutely the same under the hood.", "author": "dupliaka", "createdAt": "2020-08-10T11:27:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MjE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg0MDk2NA==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467840964", "bodyText": "I mean since fromUniquePair implemented in the way that it is much slower", "author": "dupliaka", "createdAt": "2020-08-10T11:27:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MjE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg0MTQ4NA==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467841484", "bodyText": "I believe that the Javadoc is correct - since join, indeed, also filters out uninitialized entities.", "author": "triceo", "createdAt": "2020-08-10T11:28:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MjE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg0MzYzMw==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467843633", "bodyText": "+I have a concern about that: if I will use regular join, then since bed is nullable I need to check both (left and right) streams for bed!=null, but I will have a problem there bcs I need to do that before joining and I can not do that", "author": "dupliaka", "createdAt": "2020-08-10T11:33:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MjE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg0NDM2Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467844367", "bodyText": "return constraintFactory.from(BedDesignation.class)\n                .filter((left)->left.getBed()!=null) // cannot filter right\n                .join(BedDesignation.class,\n                        equal(BedDesignation::getBed),\n                        lessThan(BedDesignation::getId))\n                .penalize(\"sameBedInSameNight\", HardMediumSoftScore.ofHard(1000)));\n    }```", "author": "dupliaka", "createdAt": "2020-08-10T11:35:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MjE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg0NjMzMA==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467846330", "bodyText": "That's the point though, you don't need to do that. The bed != null check is already done for you. This will be enough:\n return constraintFactory.from(BedDesignation.class)\n            .join(BedDesignation.class,\n                    equal(BedDesignation::getBed),\n                    lessThan(BedDesignation::getId))\n            .penalize(\"sameBedInSameNight\", HardMediumSoftScore.ofHard(1000)));\n\nIn fact, now that this constraint is so simple, you probably just need:\n return constraintFactory.fromUniquePair(BedDesignation.class,\n            equal(BedDesignation::getBed))\n            .penalize(\"sameBedInSameNight\", HardMediumSoftScore.ofHard(1000)));", "author": "triceo", "createdAt": "2020-08-10T11:39:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MjE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg2ODAzNw==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467868037", "bodyText": "Brilliant idea", "author": "dupliaka", "createdAt": "2020-08-10T12:27:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MjE2Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg4Mjg3Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467882877", "bodyText": "7dd1551", "author": "dupliaka", "createdAt": "2020-08-10T12:55:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MjE2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MzQ5MA==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467193490", "bodyText": "Personally, I'd switch the order of operations to first do the ==, then != and only then do the calculateSameNightCount(...). This way, you make sure that the (possibly expensive) calculation is only done when the quick checks are already true, never wasting time.", "author": "triceo", "createdAt": "2020-08-07T18:08:33Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/pas/solver/score/PatientAdmissionMoveConstraintProvider.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.optaplanner.examples.pas.solver.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.pas.domain.BedDesignation;\n+import org.optaplanner.examples.pas.domain.Department;\n+import org.optaplanner.examples.pas.domain.DepartmentSpecialism;\n+import org.optaplanner.examples.pas.domain.Gender;\n+import org.optaplanner.examples.pas.domain.GenderLimitation;\n+import org.optaplanner.examples.pas.domain.PreferredPatientEquipment;\n+import org.optaplanner.examples.pas.domain.RequiredPatientEquipment;\n+import org.optaplanner.examples.pas.domain.RoomEquipment;\n+import org.optaplanner.examples.pas.domain.RoomSpecialism;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+/*\n+ * This is constraints for Hospital Bed Planning\n+ * They are based on patientAdmissionScheduleConstraints.drl\n+ * Planning Entity: BedDesignation\n+ * Planning Variable: Bed(nullable) - would not be prefiltered on uninitialized solutions\n+ * Bed is nullable so in case you need to access it members check that planning value bed is not null\n+ */\n+\n+public class PatientAdmissionMoveConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                sameBedInSameNightConstraint(constraintFactory),\n+                femaleInMaleRoomConstraint(constraintFactory),\n+                maleInFemaleRoomConstraint(constraintFactory),\n+                differentGenderInSameGenderRoomInSameNightConstraint(constraintFactory),\n+                departmentMinimumAgeConstraint(constraintFactory),\n+                departmentMaximumAgeConstraint(constraintFactory),\n+                requiredPatientEquipmentConstraint(constraintFactory),\n+                assignEveryPatientToABedConstraint(constraintFactory),\n+                preferredMaximumRoomCapacityConstraint(constraintFactory),\n+                departmentSpecialismConstraint(constraintFactory),\n+                roomSpecialismNotExistsConstraint(constraintFactory),\n+                roomSpecialismNotFirstPriorityConstraint(constraintFactory),\n+                preferredPatientEquipmentConstraint(constraintFactory)\n+        };\n+    }\n+\n+    public Constraint sameBedInSameNightConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUniquePair(BedDesignation.class)\n+                .filter((left, right) -> left.getBed() != null\n+                        && right.getBed() != null\n+                        && left.getBed() == right.getBed()\n+                        && left.getAdmissionPart().calculateSameNightCount(right.getAdmissionPart()) > 0)\n+                .penalize(\"sameBedInSameNight\", HardMediumSoftScore.ofHard(1000),\n+                        (leftBd, rightBd) -> leftBd.getAdmissionPart().calculateSameNightCount(rightBd.getAdmissionPart()));\n+    }\n+\n+    public Constraint femaleInMaleRoomConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BedDesignation.class)\n+                .filter(bd -> bd.getPatientGender() == Gender.FEMALE\n+                        && bd.getRoomGenderLimitation() == GenderLimitation.MALE_ONLY)\n+                .penalize(\"femaleInMaleRoom\", HardMediumSoftScore.ofHard(50), BedDesignation::getAdmissionPartNightCount);\n+    }\n+\n+    public Constraint maleInFemaleRoomConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BedDesignation.class)\n+                .filter(bd -> bd.getPatientGender() == Gender.MALE\n+                        && bd.getRoomGenderLimitation() == GenderLimitation.FEMALE_ONLY)\n+                .penalize(\"maleInFemaleRoom\", HardMediumSoftScore.ofHard(50), BedDesignation::getAdmissionPartNightCount);\n+    }\n+\n+    public Constraint differentGenderInSameGenderRoomInSameNightConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BedDesignation.class)\n+                .filter(bd -> bd.getRoomGenderLimitation() == GenderLimitation.SAME_GENDER\n+                        && bd.getBed() != null)\n+                .join(BedDesignation.class,\n+                        equal(BedDesignation::getRoom),\n+                        lessThan(BedDesignation::getId),\n+                        filtering((left, right) -> right.getRoomGenderLimitation() == GenderLimitation.SAME_GENDER\n+                                && left.getAdmissionPart().calculateSameNightCount(right.getAdmissionPart()) > 0\n+                                && left.getPatient().getGender() != right.getPatient().getGender()))", "originalCommit": "8a77adbe40cd58339450dc3ec51b8258fbb4dd2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg4MjgyMQ==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467882821", "bodyText": "7dd1551", "author": "dupliaka", "createdAt": "2020-08-10T12:55:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MzQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MzkzNw==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467193937", "bodyText": "Considering how often calculateSameNightCount() is used, I'd consider caching the calculation somehow. But maybe it's not a problem, doing a quick profiler run would tell you.", "author": "triceo", "createdAt": "2020-08-07T18:09:28Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/pas/solver/score/PatientAdmissionMoveConstraintProvider.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.optaplanner.examples.pas.solver.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.pas.domain.BedDesignation;\n+import org.optaplanner.examples.pas.domain.Department;\n+import org.optaplanner.examples.pas.domain.DepartmentSpecialism;\n+import org.optaplanner.examples.pas.domain.Gender;\n+import org.optaplanner.examples.pas.domain.GenderLimitation;\n+import org.optaplanner.examples.pas.domain.PreferredPatientEquipment;\n+import org.optaplanner.examples.pas.domain.RequiredPatientEquipment;\n+import org.optaplanner.examples.pas.domain.RoomEquipment;\n+import org.optaplanner.examples.pas.domain.RoomSpecialism;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+/*\n+ * This is constraints for Hospital Bed Planning\n+ * They are based on patientAdmissionScheduleConstraints.drl\n+ * Planning Entity: BedDesignation\n+ * Planning Variable: Bed(nullable) - would not be prefiltered on uninitialized solutions\n+ * Bed is nullable so in case you need to access it members check that planning value bed is not null\n+ */\n+\n+public class PatientAdmissionMoveConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                sameBedInSameNightConstraint(constraintFactory),\n+                femaleInMaleRoomConstraint(constraintFactory),\n+                maleInFemaleRoomConstraint(constraintFactory),\n+                differentGenderInSameGenderRoomInSameNightConstraint(constraintFactory),\n+                departmentMinimumAgeConstraint(constraintFactory),\n+                departmentMaximumAgeConstraint(constraintFactory),\n+                requiredPatientEquipmentConstraint(constraintFactory),\n+                assignEveryPatientToABedConstraint(constraintFactory),\n+                preferredMaximumRoomCapacityConstraint(constraintFactory),\n+                departmentSpecialismConstraint(constraintFactory),\n+                roomSpecialismNotExistsConstraint(constraintFactory),\n+                roomSpecialismNotFirstPriorityConstraint(constraintFactory),\n+                preferredPatientEquipmentConstraint(constraintFactory)\n+        };\n+    }\n+\n+    public Constraint sameBedInSameNightConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUniquePair(BedDesignation.class)\n+                .filter((left, right) -> left.getBed() != null\n+                        && right.getBed() != null\n+                        && left.getBed() == right.getBed()\n+                        && left.getAdmissionPart().calculateSameNightCount(right.getAdmissionPart()) > 0)\n+                .penalize(\"sameBedInSameNight\", HardMediumSoftScore.ofHard(1000),\n+                        (leftBd, rightBd) -> leftBd.getAdmissionPart().calculateSameNightCount(rightBd.getAdmissionPart()));\n+    }\n+\n+    public Constraint femaleInMaleRoomConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BedDesignation.class)\n+                .filter(bd -> bd.getPatientGender() == Gender.FEMALE\n+                        && bd.getRoomGenderLimitation() == GenderLimitation.MALE_ONLY)\n+                .penalize(\"femaleInMaleRoom\", HardMediumSoftScore.ofHard(50), BedDesignation::getAdmissionPartNightCount);\n+    }\n+\n+    public Constraint maleInFemaleRoomConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BedDesignation.class)\n+                .filter(bd -> bd.getPatientGender() == Gender.MALE\n+                        && bd.getRoomGenderLimitation() == GenderLimitation.FEMALE_ONLY)\n+                .penalize(\"maleInFemaleRoom\", HardMediumSoftScore.ofHard(50), BedDesignation::getAdmissionPartNightCount);\n+    }\n+\n+    public Constraint differentGenderInSameGenderRoomInSameNightConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BedDesignation.class)\n+                .filter(bd -> bd.getRoomGenderLimitation() == GenderLimitation.SAME_GENDER\n+                        && bd.getBed() != null)\n+                .join(BedDesignation.class,\n+                        equal(BedDesignation::getRoom),\n+                        lessThan(BedDesignation::getId),\n+                        filtering((left, right) -> right.getRoomGenderLimitation() == GenderLimitation.SAME_GENDER\n+                                && left.getAdmissionPart().calculateSameNightCount(right.getAdmissionPart()) > 0\n+                                && left.getPatient().getGender() != right.getPatient().getGender()))\n+                .penalize(\"differentGenderInSameGenderRoomInSameNight\", HardMediumSoftScore.ofHard(1000),\n+                        (left, right) -> left.getAdmissionPart().calculateSameNightCount(right.getAdmissionPart()));", "originalCommit": "8a77adbe40cd58339450dc3ec51b8258fbb4dd2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg4MzUzMA==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467883530", "bodyText": "Is that still relevant?", "author": "dupliaka", "createdAt": "2020-08-10T12:56:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MzkzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg4Nzc1NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467887755", "bodyText": "No.", "author": "triceo", "createdAt": "2020-08-10T13:04:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5MzkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5NDMxOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467194319", "bodyText": "Note: we have Joiners.lessThan(...).", "author": "triceo", "createdAt": "2020-08-07T18:10:11Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/pas/solver/score/PatientAdmissionMoveConstraintProvider.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.optaplanner.examples.pas.solver.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.pas.domain.BedDesignation;\n+import org.optaplanner.examples.pas.domain.Department;\n+import org.optaplanner.examples.pas.domain.DepartmentSpecialism;\n+import org.optaplanner.examples.pas.domain.Gender;\n+import org.optaplanner.examples.pas.domain.GenderLimitation;\n+import org.optaplanner.examples.pas.domain.PreferredPatientEquipment;\n+import org.optaplanner.examples.pas.domain.RequiredPatientEquipment;\n+import org.optaplanner.examples.pas.domain.RoomEquipment;\n+import org.optaplanner.examples.pas.domain.RoomSpecialism;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+/*\n+ * This is constraints for Hospital Bed Planning\n+ * They are based on patientAdmissionScheduleConstraints.drl\n+ * Planning Entity: BedDesignation\n+ * Planning Variable: Bed(nullable) - would not be prefiltered on uninitialized solutions\n+ * Bed is nullable so in case you need to access it members check that planning value bed is not null\n+ */\n+\n+public class PatientAdmissionMoveConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                sameBedInSameNightConstraint(constraintFactory),\n+                femaleInMaleRoomConstraint(constraintFactory),\n+                maleInFemaleRoomConstraint(constraintFactory),\n+                differentGenderInSameGenderRoomInSameNightConstraint(constraintFactory),\n+                departmentMinimumAgeConstraint(constraintFactory),\n+                departmentMaximumAgeConstraint(constraintFactory),\n+                requiredPatientEquipmentConstraint(constraintFactory),\n+                assignEveryPatientToABedConstraint(constraintFactory),\n+                preferredMaximumRoomCapacityConstraint(constraintFactory),\n+                departmentSpecialismConstraint(constraintFactory),\n+                roomSpecialismNotExistsConstraint(constraintFactory),\n+                roomSpecialismNotFirstPriorityConstraint(constraintFactory),\n+                preferredPatientEquipmentConstraint(constraintFactory)\n+        };\n+    }\n+\n+    public Constraint sameBedInSameNightConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUniquePair(BedDesignation.class)\n+                .filter((left, right) -> left.getBed() != null\n+                        && right.getBed() != null\n+                        && left.getBed() == right.getBed()\n+                        && left.getAdmissionPart().calculateSameNightCount(right.getAdmissionPart()) > 0)\n+                .penalize(\"sameBedInSameNight\", HardMediumSoftScore.ofHard(1000),\n+                        (leftBd, rightBd) -> leftBd.getAdmissionPart().calculateSameNightCount(rightBd.getAdmissionPart()));\n+    }\n+\n+    public Constraint femaleInMaleRoomConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BedDesignation.class)\n+                .filter(bd -> bd.getPatientGender() == Gender.FEMALE\n+                        && bd.getRoomGenderLimitation() == GenderLimitation.MALE_ONLY)\n+                .penalize(\"femaleInMaleRoom\", HardMediumSoftScore.ofHard(50), BedDesignation::getAdmissionPartNightCount);\n+    }\n+\n+    public Constraint maleInFemaleRoomConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BedDesignation.class)\n+                .filter(bd -> bd.getPatientGender() == Gender.MALE\n+                        && bd.getRoomGenderLimitation() == GenderLimitation.FEMALE_ONLY)\n+                .penalize(\"maleInFemaleRoom\", HardMediumSoftScore.ofHard(50), BedDesignation::getAdmissionPartNightCount);\n+    }\n+\n+    public Constraint differentGenderInSameGenderRoomInSameNightConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BedDesignation.class)\n+                .filter(bd -> bd.getRoomGenderLimitation() == GenderLimitation.SAME_GENDER\n+                        && bd.getBed() != null)\n+                .join(BedDesignation.class,\n+                        equal(BedDesignation::getRoom),\n+                        lessThan(BedDesignation::getId),\n+                        filtering((left, right) -> right.getRoomGenderLimitation() == GenderLimitation.SAME_GENDER\n+                                && left.getAdmissionPart().calculateSameNightCount(right.getAdmissionPart()) > 0\n+                                && left.getPatient().getGender() != right.getPatient().getGender()))\n+                .penalize(\"differentGenderInSameGenderRoomInSameNight\", HardMediumSoftScore.ofHard(1000),\n+                        (left, right) -> left.getAdmissionPart().calculateSameNightCount(right.getAdmissionPart()));\n+    }\n+\n+    public Constraint departmentMinimumAgeConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Department.class)\n+                .filter(d -> d.getMinimumAge() != null)\n+                .join(BedDesignation.class,\n+                        equal(d -> d, BedDesignation::getDepartment),\n+                        filtering((d, bd) -> bd.getPatientAge() < d.getMinimumAge()))", "originalCommit": "8a77adbe40cd58339450dc3ec51b8258fbb4dd2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg4MjQ4NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467882485", "bodyText": "94c6008", "author": "dupliaka", "createdAt": "2020-08-10T12:54:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzE5NDMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3NTEwMA==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467275100", "bodyText": "d -> d should be the same as Function.identity().", "author": "triceo", "createdAt": "2020-08-07T21:23:10Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/pas/solver/score/PatientAdmissionMoveConstraintProvider.java", "diffHunk": "@@ -0,0 +1,180 @@\n+package org.optaplanner.examples.pas.solver.score;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.pas.domain.BedDesignation;\n+import org.optaplanner.examples.pas.domain.Department;\n+import org.optaplanner.examples.pas.domain.DepartmentSpecialism;\n+import org.optaplanner.examples.pas.domain.Gender;\n+import org.optaplanner.examples.pas.domain.GenderLimitation;\n+import org.optaplanner.examples.pas.domain.PreferredPatientEquipment;\n+import org.optaplanner.examples.pas.domain.RequiredPatientEquipment;\n+import org.optaplanner.examples.pas.domain.RoomEquipment;\n+import org.optaplanner.examples.pas.domain.RoomSpecialism;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+/*\n+ * This is constraints for Hospital Bed Planning\n+ * They are based on patientAdmissionScheduleConstraints.drl\n+ * Planning Entity: BedDesignation\n+ * Planning Variable: Bed(nullable) - would not be prefiltered on uninitialized solutions\n+ * Bed is nullable so in case you need to access it members check that planning value bed is not null\n+ */\n+\n+public class PatientAdmissionMoveConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[]{\n+                sameBedInSameNightConstraint(constraintFactory),\n+                femaleInMaleRoomConstraint(constraintFactory),\n+                maleInFemaleRoomConstraint(constraintFactory),\n+                differentGenderInSameGenderRoomInSameNightConstraint(constraintFactory),\n+                departmentMinimumAgeConstraint(constraintFactory),\n+                departmentMaximumAgeConstraint(constraintFactory),\n+                requiredPatientEquipmentConstraint(constraintFactory),\n+                assignEveryPatientToABedConstraint(constraintFactory),\n+                preferredMaximumRoomCapacityConstraint(constraintFactory),\n+                departmentSpecialismConstraint(constraintFactory),\n+                roomSpecialismNotExistsConstraint(constraintFactory),\n+                roomSpecialismNotFirstPriorityConstraint(constraintFactory),\n+                preferredPatientEquipmentConstraint(constraintFactory)\n+        };\n+    }\n+\n+    public Constraint sameBedInSameNightConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUniquePair(BedDesignation.class)\n+                .filter((left, right) -> left.getBed() != null\n+                        && right.getBed() != null\n+                        && left.getBed() == right.getBed()\n+                        && left.getAdmissionPart().calculateSameNightCount(right.getAdmissionPart()) > 0)\n+                .penalize(\"sameBedInSameNight\", HardMediumSoftScore.ofHard(1000),\n+                        (leftBd, rightBd) -> leftBd.getAdmissionPart().calculateSameNightCount(rightBd.getAdmissionPart()));\n+    }\n+\n+    public Constraint femaleInMaleRoomConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BedDesignation.class)\n+                .filter(bd -> bd.getPatientGender() == Gender.FEMALE\n+                        && bd.getRoomGenderLimitation() == GenderLimitation.MALE_ONLY)\n+                .penalize(\"femaleInMaleRoom\", HardMediumSoftScore.ofHard(50), BedDesignation::getAdmissionPartNightCount);\n+    }\n+\n+    public Constraint maleInFemaleRoomConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BedDesignation.class)\n+                .filter(bd -> bd.getPatientGender() == Gender.MALE\n+                        && bd.getRoomGenderLimitation() == GenderLimitation.FEMALE_ONLY)\n+                .penalize(\"maleInFemaleRoom\", HardMediumSoftScore.ofHard(50), BedDesignation::getAdmissionPartNightCount);\n+    }\n+\n+    public Constraint differentGenderInSameGenderRoomInSameNightConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BedDesignation.class)\n+                .filter(bd -> bd.getRoomGenderLimitation() == GenderLimitation.SAME_GENDER\n+                        && bd.getBed() != null)\n+                .join(BedDesignation.class,\n+                        equal(BedDesignation::getRoom),\n+                        lessThan(BedDesignation::getId),\n+                        filtering((left, right) -> right.getRoomGenderLimitation() == GenderLimitation.SAME_GENDER\n+                                && left.getAdmissionPart().calculateSameNightCount(right.getAdmissionPart()) > 0\n+                                && left.getPatient().getGender() != right.getPatient().getGender()))\n+                .penalize(\"differentGenderInSameGenderRoomInSameNight\", HardMediumSoftScore.ofHard(1000),\n+                        (left, right) -> left.getAdmissionPart().calculateSameNightCount(right.getAdmissionPart()));\n+    }\n+\n+    public Constraint departmentMinimumAgeConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Department.class)\n+                .filter(d -> d.getMinimumAge() != null)\n+                .join(BedDesignation.class,\n+                        equal(d -> d, BedDesignation::getDepartment),", "originalCommit": "8a77adbe40cd58339450dc3ec51b8258fbb4dd2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg4MTM1MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467881351", "bodyText": "Fix 94c6008", "author": "dupliaka", "createdAt": "2020-08-10T12:52:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzI3NTEwMA=="}], "type": "inlineReview"}, {"oid": "94c60080ed05dd144db456a18e268b029fdd3328", "url": "https://github.com/kiegroup/optaplanner/commit/94c60080ed05dd144db456a18e268b029fdd3328", "message": "identify() + formatting CI + lessThen vs filter", "committedDate": "2020-08-10T11:06:57Z", "type": "commit"}, {"oid": "7dd155181c6f1f7f867667d82eb53de3aa1d5a38", "url": "https://github.com/kiegroup/optaplanner/commit/7dd155181c6f1f7f867667d82eb53de3aa1d5a38", "message": "PR review feedback changes\n\nRemove test data builder\nSwitch filter on join\nTurn on ONLY_DOWN", "committedDate": "2020-08-10T12:49:31Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg4OTM5NA==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467889394", "bodyText": "In my original comment, I meant that these methods would simply become setters. That is public void set...(...).\nThis way, it becomes consistent with the other examples. (Although unfortunately the test code gets a bit uglier.)\nSorry for not being clear earlier.", "author": "triceo", "createdAt": "2020-08-10T13:07:20Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/pas/domain/BedDesignation.java", "diffHunk": "@@ -118,4 +118,49 @@ public String toString() {\n         return admissionPart.toString();\n     }\n \n+    //Testing builder\n+\n+    public BedDesignation build(){\n+        admissionPart = new AdmissionPart();\n+        bed = new Bed();\n+        return this;\n+    }\n+\n+    //Testing methods\n+\n+    public BedDesignation withNights(int first, int last) {\n+        Night firstNight = new Night();\n+        firstNight.setIndex(first);\n+        admissionPart.setFirstNight(firstNight);\n+        Night lastNight = new Night();\n+        lastNight.setIndex(last);\n+        admissionPart.setLastNight(lastNight);\n+        return this;\n+    }\n+\n+    public BedDesignation withId(Long id) {\n+        this.id = id;\n+        return this;\n+    }\n+\n+    public BedDesignation withPatient(Patient patient) {\n+        this.admissionPart.setPatient(patient);\n+        return this;\n+    }\n+\n+    public BedDesignation withBed(Bed bed) {\n+        this.bed = bed;\n+        return this;\n+    }\n+\n+    public BedDesignation withRoom(Room room) {\n+        this.bed.setRoom(room);\n+        return this;\n+    }\n+\n+    public BedDesignation withSpecialism(Specialism spec1) {\n+        this.admissionPart.setSpecialism(spec1);\n+        return this;\n+    }", "originalCommit": "7dd155181c6f1f7f867667d82eb53de3aa1d5a38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk3MTgzOA==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467971838", "bodyText": "1f9f2b8", "author": "dupliaka", "createdAt": "2020-08-10T15:09:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg4OTM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg5MTE2OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467891169", "bodyText": "Please put the null checks first in the filter.\nAlso, since BedDesignation::getBed is equal, you only need to check if left.getBed() != null.", "author": "triceo", "createdAt": "2020-08-10T13:10:17Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/pas/solver/score/PatientAdmissionMoveConstraintProvider.java", "diffHunk": "@@ -0,0 +1,182 @@\n+package org.optaplanner.examples.pas.solver.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.pas.domain.BedDesignation;\n+import org.optaplanner.examples.pas.domain.Department;\n+import org.optaplanner.examples.pas.domain.DepartmentSpecialism;\n+import org.optaplanner.examples.pas.domain.Gender;\n+import org.optaplanner.examples.pas.domain.GenderLimitation;\n+import org.optaplanner.examples.pas.domain.PreferredPatientEquipment;\n+import org.optaplanner.examples.pas.domain.RequiredPatientEquipment;\n+import org.optaplanner.examples.pas.domain.RoomEquipment;\n+import org.optaplanner.examples.pas.domain.RoomSpecialism;\n+\n+/*\n+ * This is constraints for Hospital Bed Planning\n+ * They are based on patientAdmissionScheduleConstraints.drl\n+ * Planning Entity: BedDesignation\n+ * Planning Variable: Bed(nullable) - would not be prefiltered on uninitialized solutions\n+ * Bed is nullable so in case you need to access it members check that planning value bed is not null\n+ */\n+\n+public class PatientAdmissionMoveConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                sameBedInSameNightConstraint(constraintFactory),\n+                femaleInMaleRoomConstraint(constraintFactory),\n+                maleInFemaleRoomConstraint(constraintFactory),\n+                differentGenderInSameGenderRoomInSameNightConstraint(constraintFactory),\n+                departmentMinimumAgeConstraint(constraintFactory),\n+                departmentMaximumAgeConstraint(constraintFactory),\n+                requiredPatientEquipmentConstraint(constraintFactory),\n+                assignEveryPatientToABedConstraint(constraintFactory),\n+                preferredMaximumRoomCapacityConstraint(constraintFactory),\n+                departmentSpecialismConstraint(constraintFactory),\n+                roomSpecialismNotExistsConstraint(constraintFactory),\n+                roomSpecialismNotFirstPriorityConstraint(constraintFactory),\n+                preferredPatientEquipmentConstraint(constraintFactory)\n+        };\n+    }\n+\n+    public Constraint sameBedInSameNightConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUniquePair(BedDesignation.class,\n+                        equal(BedDesignation::getBed))\n+                .filter((left,right) -> left.getAdmissionPart().calculateSameNightCount(right.getAdmissionPart()) > 0\n+                && left.getBed()!=null && right.getBed()!=null)", "originalCommit": "7dd155181c6f1f7f867667d82eb53de3aa1d5a38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzkwMTAwNw==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467901007", "bodyText": "Yeh, the last one I got a call from somewhere inside, thanks for correcting.", "author": "dupliaka", "createdAt": "2020-08-10T13:25:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg5MTE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg5MjU5MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467892591", "bodyText": "Since bed is nullable, fromUnfiltered() is no different than from(). You might as well use from().", "author": "triceo", "createdAt": "2020-08-10T13:12:50Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/pas/solver/score/PatientAdmissionMoveConstraintProvider.java", "diffHunk": "@@ -0,0 +1,182 @@\n+package org.optaplanner.examples.pas.solver.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.greaterThan;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import java.util.function.Function;\n+\n+import org.optaplanner.core.api.score.buildin.hardmediumsoft.HardMediumSoftScore;\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.pas.domain.BedDesignation;\n+import org.optaplanner.examples.pas.domain.Department;\n+import org.optaplanner.examples.pas.domain.DepartmentSpecialism;\n+import org.optaplanner.examples.pas.domain.Gender;\n+import org.optaplanner.examples.pas.domain.GenderLimitation;\n+import org.optaplanner.examples.pas.domain.PreferredPatientEquipment;\n+import org.optaplanner.examples.pas.domain.RequiredPatientEquipment;\n+import org.optaplanner.examples.pas.domain.RoomEquipment;\n+import org.optaplanner.examples.pas.domain.RoomSpecialism;\n+\n+/*\n+ * This is constraints for Hospital Bed Planning\n+ * They are based on patientAdmissionScheduleConstraints.drl\n+ * Planning Entity: BedDesignation\n+ * Planning Variable: Bed(nullable) - would not be prefiltered on uninitialized solutions\n+ * Bed is nullable so in case you need to access it members check that planning value bed is not null\n+ */\n+\n+public class PatientAdmissionMoveConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                sameBedInSameNightConstraint(constraintFactory),\n+                femaleInMaleRoomConstraint(constraintFactory),\n+                maleInFemaleRoomConstraint(constraintFactory),\n+                differentGenderInSameGenderRoomInSameNightConstraint(constraintFactory),\n+                departmentMinimumAgeConstraint(constraintFactory),\n+                departmentMaximumAgeConstraint(constraintFactory),\n+                requiredPatientEquipmentConstraint(constraintFactory),\n+                assignEveryPatientToABedConstraint(constraintFactory),\n+                preferredMaximumRoomCapacityConstraint(constraintFactory),\n+                departmentSpecialismConstraint(constraintFactory),\n+                roomSpecialismNotExistsConstraint(constraintFactory),\n+                roomSpecialismNotFirstPriorityConstraint(constraintFactory),\n+                preferredPatientEquipmentConstraint(constraintFactory)\n+        };\n+    }\n+\n+    public Constraint sameBedInSameNightConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUniquePair(BedDesignation.class,\n+                        equal(BedDesignation::getBed))\n+                .filter((left,right) -> left.getAdmissionPart().calculateSameNightCount(right.getAdmissionPart()) > 0\n+                && left.getBed()!=null && right.getBed()!=null)\n+                .penalize(\"sameBedInSameNight\", HardMediumSoftScore.ofHard(1000),\n+                          (left,right) -> left.getAdmissionPart().calculateSameNightCount(right.getAdmissionPart()));\n+    }\n+\n+    public Constraint femaleInMaleRoomConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BedDesignation.class)\n+                .filter(bd -> bd.getPatientGender() == Gender.FEMALE\n+                        && bd.getRoomGenderLimitation() == GenderLimitation.MALE_ONLY)\n+                .penalize(\"femaleInMaleRoom\", HardMediumSoftScore.ofHard(50), BedDesignation::getAdmissionPartNightCount);\n+    }\n+\n+    public Constraint maleInFemaleRoomConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BedDesignation.class)\n+                .filter(bd -> bd.getPatientGender() == Gender.MALE\n+                        && bd.getRoomGenderLimitation() == GenderLimitation.FEMALE_ONLY)\n+                .penalize(\"maleInFemaleRoom\", HardMediumSoftScore.ofHard(50), BedDesignation::getAdmissionPartNightCount);\n+    }\n+\n+    public Constraint differentGenderInSameGenderRoomInSameNightConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(BedDesignation.class)\n+                .filter(bd -> bd.getRoomGenderLimitation() == GenderLimitation.SAME_GENDER\n+                        && bd.getBed() != null)\n+                .join(BedDesignation.class,\n+                        equal(BedDesignation::getRoom),\n+                        lessThan(BedDesignation::getId),\n+                        filtering((left, right) -> right.getRoomGenderLimitation() == GenderLimitation.SAME_GENDER\n+                                && left.getPatient().getGender() != right.getPatient().getGender()\n+                                && left.getAdmissionPart().calculateSameNightCount(right.getAdmissionPart()) > 0))\n+                .penalize(\"differentGenderInSameGenderRoomInSameNight\", HardMediumSoftScore.ofHard(1000),\n+                        (left, right) -> left.getAdmissionPart().calculateSameNightCount(right.getAdmissionPart()));\n+    }\n+\n+    public Constraint departmentMinimumAgeConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Department.class)\n+                .filter(d -> d.getMinimumAge() != null)\n+                .join(BedDesignation.class,\n+                        equal(Function.identity(), BedDesignation::getDepartment),\n+                        greaterThan(Department::getMinimumAge, BedDesignation::getPatientAge))\n+                .penalize(\"departmentMinimumAge\", HardMediumSoftScore.ofHard(100),\n+                        (d, bd) -> bd.getAdmissionPartNightCount());\n+    }\n+\n+    public Constraint departmentMaximumAgeConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Department.class)\n+                .filter(d -> d.getMaximumAge() != null)\n+                .join(BedDesignation.class,\n+                        equal(Function.identity(), BedDesignation::getDepartment),\n+                        lessThan(Department::getMaximumAge, BedDesignation::getPatientAge))\n+                .penalize(\"departmentMaximumAge\", HardMediumSoftScore.ofHard(100),\n+                        (d, bd) -> bd.getAdmissionPartNightCount());\n+    }\n+\n+    public Constraint requiredPatientEquipmentConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredPatientEquipment.class)\n+                .join(BedDesignation.class,\n+                        equal(RequiredPatientEquipment::getPatient, BedDesignation::getPatient),\n+                        filtering((rpe, bd) -> bd.getBed() != null))\n+                .ifNotExists(RoomEquipment.class,\n+                        equal((rpe, bd) -> bd.getRoom(), RoomEquipment::getRoom),\n+                        equal((rpe, bd) -> rpe.getEquipment(), RoomEquipment::getEquipment))\n+                .penalize(\"requiredPatientEquipment\", HardMediumSoftScore.ofHard(50),\n+                        (rpe, bd) -> bd.getAdmissionPartNightCount());\n+    }\n+\n+    //Medium\n+    public Constraint assignEveryPatientToABedConstraint(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(BedDesignation.class)", "originalCommit": "7dd155181c6f1f7f867667d82eb53de3aa1d5a38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzkwMDkzOA==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467900938", "bodyText": "Yes, leftover.", "author": "dupliaka", "createdAt": "2020-08-10T13:25:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg5MjU5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzk3MTc2NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/872#discussion_r467971765", "bodyText": "1f9f2b8", "author": "dupliaka", "createdAt": "2020-08-10T15:08:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Nzg5MjU5MQ=="}], "type": "inlineReview"}, {"oid": "1f9f2b888293c0e1f544dfc79931c17386a57b41", "url": "https://github.com/kiegroup/optaplanner/commit/1f9f2b888293c0e1f544dfc79931c17386a57b41", "message": "Pr review fixes\n\nChanged builder to set of constructors\nOptimize assignEveryPatientToABedConstraint", "committedDate": "2020-08-10T15:04:00Z", "type": "commit"}, {"oid": "7586b263c5c25b865c86e20e1837a41e1b6dcecc", "url": "https://github.com/kiegroup/optaplanner/commit/7586b263c5c25b865c86e20e1837a41e1b6dcecc", "message": "Change patientAdmissionScheduleSolverConfig to run drl by default", "committedDate": "2020-08-10T15:53:38Z", "type": "commit"}, {"oid": "5c6827cb17acb0a61479e16c426b3a0bec883374", "url": "https://github.com/kiegroup/optaplanner/commit/5c6827cb17acb0a61479e16c426b3a0bec883374", "message": "Fix the config to no longer hang", "committedDate": "2020-08-10T17:32:32Z", "type": "commit"}, {"oid": "810af288705844447ad98f6107c3af9e05906ae4", "url": "https://github.com/kiegroup/optaplanner/commit/810af288705844447ad98f6107c3af9e05906ae4", "message": "Rename the constraint provider to match the example name", "committedDate": "2020-08-10T17:35:47Z", "type": "commit"}, {"oid": "e7aec620dbad7ced22c46fc89538846b54cf076c", "url": "https://github.com/kiegroup/optaplanner/commit/e7aec620dbad7ced22c46fc89538846b54cf076c", "message": "Fix formatting", "committedDate": "2020-08-10T17:36:36Z", "type": "commit"}]}