{"pr_number": 808, "pr_title": "WIP: Convert MeetingScheduling example to ConstraintStreams", "pr_createdAt": "2020-06-22T21:01:29Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/808", "timeline": [{"oid": "b9125e2e6b51b3cc2ed0086cc15d11280a6b3ed2", "url": "https://github.com/kiegroup/optaplanner/commit/b9125e2e6b51b3cc2ed0086cc15d11280a6b3ed2", "message": "Convert MeetingScheduling example to ConstraintStreams", "committedDate": "2020-06-24T20:20:56Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUxMDQ5MA==", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r447510490", "bodyText": "The problem lies in from(MeetingAssignment.class). There are no such instances, because you never set any value to MeetingAssignment.room planning variable. from() therefore treats those instances as uninitialized, and skips them. Two solutions:\n\nuse fromUnfiltered() in the constraint provider or\ninitialize your entities properly in the test.\n\nAlso, I suggest you make sure your @PlanningIds are never null, because the following PR will start enforcing that pretty soon:\ntriceo#14\nI have not reviewed any other constraints as I assumed the same problem would be plagueing them as well.", "author": "triceo", "createdAt": "2020-06-30T08:35:20Z", "path": "optaplanner-examples/src/test/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProviderTest.java", "diffHunk": "@@ -0,0 +1,616 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+import org.optaplanner.examples.meetingscheduling.domain.*;\n+import org.optaplanner.test.api.score.stream.ConstraintVerifier;\n+\n+public class MeetingSchedulingConstraintProviderTest {\n+\n+    private final ConstraintVerifier<MeetingSchedulingConstraintProvider, MeetingSchedule> constraintVerifier =\n+            ConstraintVerifier.build(new MeetingSchedulingConstraintProvider(), MeetingSchedule.class,\n+                    MeetingAssignment.class);\n+\n+    @Test\n+    public void roomConflictUnpenalized() {\n+        Room room = new Room();\n+\n+        TimeGrain timeGrain1 = new TimeGrain();\n+        timeGrain1.setGrainIndex(0);\n+\n+        Meeting meeting1 = new Meeting();\n+        meeting1.setDurationInGrains(4);\n+\n+        MeetingAssignment leftAssignment = new MeetingAssignment();\n+        leftAssignment.setId(0L);\n+        leftAssignment.setRoom(room);\n+        leftAssignment.setStartingTimeGrain(timeGrain1);\n+        leftAssignment.setMeeting(meeting1);\n+\n+        TimeGrain timeGrain2 = new TimeGrain();\n+        timeGrain2.setGrainIndex(4);\n+\n+        Meeting meeting2 = new Meeting();\n+        meeting2.setDurationInGrains(4);\n+\n+        MeetingAssignment rightAssignment = new MeetingAssignment();\n+        rightAssignment.setId(1L);\n+        rightAssignment.setRoom(room);\n+        rightAssignment.setStartingTimeGrain(timeGrain2);\n+        rightAssignment.setMeeting(meeting2);\n+\n+        constraintVerifier.verifyThat(MeetingSchedulingConstraintProvider::roomConflict)\n+                .given(leftAssignment, rightAssignment)\n+                .penalizesBy(0);\n+    }\n+\n+    @Test\n+    public void roomConflictPenalized() {\n+        Room room = new Room();\n+\n+        TimeGrain timeGrain1 = new TimeGrain();\n+        timeGrain1.setGrainIndex(0);\n+\n+        Meeting meeting1 = new Meeting();\n+        meeting1.setDurationInGrains(4);\n+\n+        MeetingAssignment leftAssignment = new MeetingAssignment();\n+        leftAssignment.setId(0L);\n+        leftAssignment.setRoom(room);\n+        leftAssignment.setStartingTimeGrain(timeGrain1);\n+        leftAssignment.setMeeting(meeting1);\n+\n+        TimeGrain timeGrain2 = new TimeGrain();\n+        timeGrain2.setGrainIndex(2);\n+\n+        Meeting meeting2 = new Meeting();\n+        meeting2.setDurationInGrains(4);\n+\n+        MeetingAssignment rightAssignment = new MeetingAssignment();\n+        rightAssignment.setId(1L);\n+        rightAssignment.setRoom(room);\n+        rightAssignment.setStartingTimeGrain(timeGrain2);\n+        rightAssignment.setMeeting(meeting2);\n+\n+        constraintVerifier.verifyThat(MeetingSchedulingConstraintProvider::roomConflict)\n+                .given(leftAssignment, rightAssignment)\n+                .penalizesBy(2);\n+    }\n+\n+    @Test\n+    public void avoidOvertimeUnpenalized() {\n+        TimeGrain timeGrain = new TimeGrain();\n+        timeGrain.setGrainIndex(3);\n+\n+        TimeGrain assignmentTimeGrain = new TimeGrain();\n+        assignmentTimeGrain.setGrainIndex(0);\n+\n+        Meeting meeting = new Meeting();\n+        meeting.setDurationInGrains(4);\n+\n+        MeetingAssignment meetingAssignment = new MeetingAssignment();\n+        meetingAssignment.setStartingTimeGrain(assignmentTimeGrain);\n+        meetingAssignment.setMeeting(meeting);\n+\n+        constraintVerifier.verifyThat(MeetingSchedulingConstraintProvider::avoidOvertime)\n+                .given(meetingAssignment, timeGrain)\n+                .penalizesBy(0);\n+    }\n+\n+    @Test\n+    public void avoidOvertimePenalized() {\n+        TimeGrain assignmentTimeGrain = new TimeGrain();\n+        assignmentTimeGrain.setGrainIndex(0);\n+\n+        Meeting meeting = new Meeting();\n+        meeting.setDurationInGrains(4);\n+\n+        MeetingAssignment meetingAssignment = new MeetingAssignment();\n+        meetingAssignment.setStartingTimeGrain(assignmentTimeGrain);\n+        meetingAssignment.setMeeting(meeting);\n+\n+        constraintVerifier.verifyThat(MeetingSchedulingConstraintProvider::avoidOvertime)\n+                .given(meetingAssignment)\n+                .penalizesBy(3);\n+    }", "originalCommit": "b9125e2e6b51b3cc2ed0086cc15d11280a6b3ed2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUyMjA2Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r447522066", "bodyText": "I suggest you create constructors for the facts/entities so that you are forced to always provide all the information that must not be null. (As opposed to hoping you always remember to include all the setters.)", "author": "triceo", "createdAt": "2020-06-30T08:52:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUxMDQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzUxMjcyNg==", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r447512726", "bodyText": "Please remember to include in the given(...) call all the facts relevant to the problem. Not including them here means you won't be able to use them in join(), exists() etc.", "author": "triceo", "createdAt": "2020-06-30T08:38:40Z", "path": "optaplanner-examples/src/test/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProviderTest.java", "diffHunk": "@@ -0,0 +1,616 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.junit.jupiter.api.Test;\n+import org.optaplanner.examples.meetingscheduling.domain.*;\n+import org.optaplanner.test.api.score.stream.ConstraintVerifier;\n+\n+public class MeetingSchedulingConstraintProviderTest {\n+\n+    private final ConstraintVerifier<MeetingSchedulingConstraintProvider, MeetingSchedule> constraintVerifier =\n+            ConstraintVerifier.build(new MeetingSchedulingConstraintProvider(), MeetingSchedule.class,\n+                    MeetingAssignment.class);\n+\n+    @Test\n+    public void roomConflictUnpenalized() {\n+        Room room = new Room();\n+\n+        TimeGrain timeGrain1 = new TimeGrain();\n+        timeGrain1.setGrainIndex(0);\n+\n+        Meeting meeting1 = new Meeting();\n+        meeting1.setDurationInGrains(4);\n+\n+        MeetingAssignment leftAssignment = new MeetingAssignment();\n+        leftAssignment.setId(0L);\n+        leftAssignment.setRoom(room);\n+        leftAssignment.setStartingTimeGrain(timeGrain1);\n+        leftAssignment.setMeeting(meeting1);\n+\n+        TimeGrain timeGrain2 = new TimeGrain();\n+        timeGrain2.setGrainIndex(4);\n+\n+        Meeting meeting2 = new Meeting();\n+        meeting2.setDurationInGrains(4);\n+\n+        MeetingAssignment rightAssignment = new MeetingAssignment();\n+        rightAssignment.setId(1L);\n+        rightAssignment.setRoom(room);\n+        rightAssignment.setStartingTimeGrain(timeGrain2);\n+        rightAssignment.setMeeting(meeting2);\n+\n+        constraintVerifier.verifyThat(MeetingSchedulingConstraintProvider::roomConflict)\n+                .given(leftAssignment, rightAssignment)\n+                .penalizesBy(0);\n+    }\n+\n+    @Test\n+    public void roomConflictPenalized() {\n+        Room room = new Room();\n+\n+        TimeGrain timeGrain1 = new TimeGrain();\n+        timeGrain1.setGrainIndex(0);\n+\n+        Meeting meeting1 = new Meeting();\n+        meeting1.setDurationInGrains(4);\n+\n+        MeetingAssignment leftAssignment = new MeetingAssignment();\n+        leftAssignment.setId(0L);\n+        leftAssignment.setRoom(room);\n+        leftAssignment.setStartingTimeGrain(timeGrain1);\n+        leftAssignment.setMeeting(meeting1);\n+\n+        TimeGrain timeGrain2 = new TimeGrain();\n+        timeGrain2.setGrainIndex(2);\n+\n+        Meeting meeting2 = new Meeting();\n+        meeting2.setDurationInGrains(4);\n+\n+        MeetingAssignment rightAssignment = new MeetingAssignment();\n+        rightAssignment.setId(1L);\n+        rightAssignment.setRoom(room);\n+        rightAssignment.setStartingTimeGrain(timeGrain2);\n+        rightAssignment.setMeeting(meeting2);\n+\n+        constraintVerifier.verifyThat(MeetingSchedulingConstraintProvider::roomConflict)\n+                .given(leftAssignment, rightAssignment)\n+                .penalizesBy(2);\n+    }\n+\n+    @Test\n+    public void avoidOvertimeUnpenalized() {\n+        TimeGrain timeGrain = new TimeGrain();\n+        timeGrain.setGrainIndex(3);\n+\n+        TimeGrain assignmentTimeGrain = new TimeGrain();\n+        assignmentTimeGrain.setGrainIndex(0);\n+\n+        Meeting meeting = new Meeting();\n+        meeting.setDurationInGrains(4);\n+\n+        MeetingAssignment meetingAssignment = new MeetingAssignment();\n+        meetingAssignment.setStartingTimeGrain(assignmentTimeGrain);\n+        meetingAssignment.setMeeting(meeting);\n+\n+        constraintVerifier.verifyThat(MeetingSchedulingConstraintProvider::avoidOvertime)\n+                .given(meetingAssignment, timeGrain)\n+                .penalizesBy(0);\n+    }\n+\n+    @Test\n+    public void avoidOvertimePenalized() {\n+        TimeGrain assignmentTimeGrain = new TimeGrain();\n+        assignmentTimeGrain.setGrainIndex(0);\n+\n+        Meeting meeting = new Meeting();\n+        meeting.setDurationInGrains(4);\n+\n+        MeetingAssignment meetingAssignment = new MeetingAssignment();\n+        meetingAssignment.setStartingTimeGrain(assignmentTimeGrain);\n+        meetingAssignment.setMeeting(meeting);\n+\n+        constraintVerifier.verifyThat(MeetingSchedulingConstraintProvider::avoidOvertime)\n+                .given(meetingAssignment)", "originalCommit": "b9125e2e6b51b3cc2ed0086cc15d11280a6b3ed2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8726f57d0eede9f773e32aae9ca00f51fe43f264", "url": "https://github.com/kiegroup/optaplanner/commit/8726f57d0eede9f773e32aae9ca00f51fe43f264", "message": "Convert MeetingScheduling example to ConstraintStreams", "committedDate": "2020-07-08T15:13:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTIxOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451761219", "bodyText": "Joiners.equal(...)?", "author": "triceo", "createdAt": "2020-07-08T18:58:56Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.meetingscheduling.domain.Attendance;\n+import org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment;\n+import org.optaplanner.examples.meetingscheduling.domain.PreferredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.RequiredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.Room;\n+import org.optaplanner.examples.meetingscheduling.domain.TimeGrain;\n+\n+public class MeetingSchedulingConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                roomConflict(constraintFactory),\n+                avoidOvertime(constraintFactory),\n+                requiredAttendanceConflict(constraintFactory),\n+                requiredRoomCapacity(constraintFactory),\n+                startAndEndOnSameDay(constraintFactory),\n+                requiredAndPreferredAttendanceConflict(constraintFactory),\n+                preferredAttendanceConflict(constraintFactory),\n+                doMeetingsAsSoonAsPossible(constraintFactory),\n+                oneBreakBetweenConsecutiveMeetings(constraintFactory),\n+                overlappingMeetings(constraintFactory),\n+                assignLargerRoomsFirst(constraintFactory),\n+                roomStability(constraintFactory)\n+        };\n+    }\n+\n+    // ************************************************************************\n+    // Hard constraints\n+    // ************************************************************************\n+\n+    protected Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(leftAssignment -> leftAssignment.getRoom() != null)\n+                .join(MeetingAssignment.class,\n+                        equal(MeetingAssignment::getRoom, MeetingAssignment::getRoom),\n+                        lessThan(MeetingAssignment::getId, MeetingAssignment::getId),\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Room conflict\",\n+                        (leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint avoidOvertime(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .ifNotExists(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex))\n+                .penalizeConfigurable(\"Don't go in overtime\", MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(RequiredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, RequiredAttendance::getPerson),\n+                        lessThan(RequiredAttendance::getId, RequiredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftRequiredAttendance.getMeeting() == leftAssignment.getMeeting()),", "originalCommit": "8726f57d0eede9f773e32aae9ca00f51fe43f264", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY5NzM0OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r453697349", "bodyText": "How does this work on TriConstraintStreams? I'm guessing something like: equal(RequiredAttendance::getMeeting, MeetingAssignment::getMeeting). But in this case wouldn't the RequiredAttendance being compared be ambiguous, since there are two of them joined in this stream?", "author": "cuijulian", "createdAt": "2020-07-13T14:37:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTIxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc0NzI5Mw==", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r453747293", "bodyText": "The joiner will always take all the arguments from the left, and the single argument from the right.\nSo this would be something like equal((lra, rra) -> lra.getMeeting(), MeetingAssignment::getMeeting).", "author": "triceo", "createdAt": "2020-07-13T15:44:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTIxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTI5OA==", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451761298", "bodyText": "Joiners.equal(...)?", "author": "triceo", "createdAt": "2020-07-08T18:59:06Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.meetingscheduling.domain.Attendance;\n+import org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment;\n+import org.optaplanner.examples.meetingscheduling.domain.PreferredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.RequiredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.Room;\n+import org.optaplanner.examples.meetingscheduling.domain.TimeGrain;\n+\n+public class MeetingSchedulingConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                roomConflict(constraintFactory),\n+                avoidOvertime(constraintFactory),\n+                requiredAttendanceConflict(constraintFactory),\n+                requiredRoomCapacity(constraintFactory),\n+                startAndEndOnSameDay(constraintFactory),\n+                requiredAndPreferredAttendanceConflict(constraintFactory),\n+                preferredAttendanceConflict(constraintFactory),\n+                doMeetingsAsSoonAsPossible(constraintFactory),\n+                oneBreakBetweenConsecutiveMeetings(constraintFactory),\n+                overlappingMeetings(constraintFactory),\n+                assignLargerRoomsFirst(constraintFactory),\n+                roomStability(constraintFactory)\n+        };\n+    }\n+\n+    // ************************************************************************\n+    // Hard constraints\n+    // ************************************************************************\n+\n+    protected Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(leftAssignment -> leftAssignment.getRoom() != null)\n+                .join(MeetingAssignment.class,\n+                        equal(MeetingAssignment::getRoom, MeetingAssignment::getRoom),\n+                        lessThan(MeetingAssignment::getId, MeetingAssignment::getId),\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Room conflict\",\n+                        (leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint avoidOvertime(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .ifNotExists(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex))\n+                .penalizeConfigurable(\"Don't go in overtime\", MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(RequiredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, RequiredAttendance::getPerson),\n+                        lessThan(RequiredAttendance::getId, RequiredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftRequiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightRequiredAttendance.getMeeting() == rightAssignment.getMeeting()),", "originalCommit": "8726f57d0eede9f773e32aae9ca00f51fe43f264", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzY5OTY5MA==", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r453699690", "bodyText": "Same question here, if the Joiner used here is equal(RequiredAttendance::getMeeting, MeetingAssignment::getMeeting), wouldn't the instances being compared be ambiguous?", "author": "cuijulian", "createdAt": "2020-07-13T14:40:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTI5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc0ODg5MA==", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r453748890", "bodyText": "Same answer. :-)", "author": "triceo", "createdAt": "2020-07-13T15:47:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTI5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTU5NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451761595", "bodyText": "Joiners.equal(...)?", "author": "triceo", "createdAt": "2020-07-08T18:59:37Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.meetingscheduling.domain.Attendance;\n+import org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment;\n+import org.optaplanner.examples.meetingscheduling.domain.PreferredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.RequiredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.Room;\n+import org.optaplanner.examples.meetingscheduling.domain.TimeGrain;\n+\n+public class MeetingSchedulingConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                roomConflict(constraintFactory),\n+                avoidOvertime(constraintFactory),\n+                requiredAttendanceConflict(constraintFactory),\n+                requiredRoomCapacity(constraintFactory),\n+                startAndEndOnSameDay(constraintFactory),\n+                requiredAndPreferredAttendanceConflict(constraintFactory),\n+                preferredAttendanceConflict(constraintFactory),\n+                doMeetingsAsSoonAsPossible(constraintFactory),\n+                oneBreakBetweenConsecutiveMeetings(constraintFactory),\n+                overlappingMeetings(constraintFactory),\n+                assignLargerRoomsFirst(constraintFactory),\n+                roomStability(constraintFactory)\n+        };\n+    }\n+\n+    // ************************************************************************\n+    // Hard constraints\n+    // ************************************************************************\n+\n+    protected Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(leftAssignment -> leftAssignment.getRoom() != null)\n+                .join(MeetingAssignment.class,\n+                        equal(MeetingAssignment::getRoom, MeetingAssignment::getRoom),\n+                        lessThan(MeetingAssignment::getId, MeetingAssignment::getId),\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Room conflict\",\n+                        (leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint avoidOvertime(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .ifNotExists(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex))\n+                .penalizeConfigurable(\"Don't go in overtime\", MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(RequiredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, RequiredAttendance::getPerson),\n+                        lessThan(RequiredAttendance::getId, RequiredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftRequiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightRequiredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required attendance conflict\",\n+                        (leftRequiredAttendance, rightRequiredAttendance, leftAssignment, rightAssignment) -> rightAssignment\n+                                .calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint requiredRoomCapacity(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRequiredCapacity() > meetingAssignment.getRoomCapacity())\n+                .penalizeConfigurable(\"Required room capacity\",\n+                        meetingAssignment -> meetingAssignment.getRequiredCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint startAndEndOnSameDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex),\n+                        filtering((meetingAssignment,\n+                                timeGrain) -> meetingAssignment.getStartingTimeGrain().getDay() != timeGrain.getDay()))\n+                .penalizeConfigurable(\"Start and end on same day\");\n+    }\n+\n+    // ************************************************************************\n+    // Medium constraints\n+    // ************************************************************************\n+\n+    protected Constraint requiredAndPreferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, PreferredAttendance::getPerson))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> requiredAttendance.getMeeting() == leftAssignment.getMeeting()),", "originalCommit": "8726f57d0eede9f773e32aae9ca00f51fe43f264", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTY0OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451761649", "bodyText": "Joiners.equal(...)?", "author": "triceo", "createdAt": "2020-07-08T18:59:43Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.meetingscheduling.domain.Attendance;\n+import org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment;\n+import org.optaplanner.examples.meetingscheduling.domain.PreferredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.RequiredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.Room;\n+import org.optaplanner.examples.meetingscheduling.domain.TimeGrain;\n+\n+public class MeetingSchedulingConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                roomConflict(constraintFactory),\n+                avoidOvertime(constraintFactory),\n+                requiredAttendanceConflict(constraintFactory),\n+                requiredRoomCapacity(constraintFactory),\n+                startAndEndOnSameDay(constraintFactory),\n+                requiredAndPreferredAttendanceConflict(constraintFactory),\n+                preferredAttendanceConflict(constraintFactory),\n+                doMeetingsAsSoonAsPossible(constraintFactory),\n+                oneBreakBetweenConsecutiveMeetings(constraintFactory),\n+                overlappingMeetings(constraintFactory),\n+                assignLargerRoomsFirst(constraintFactory),\n+                roomStability(constraintFactory)\n+        };\n+    }\n+\n+    // ************************************************************************\n+    // Hard constraints\n+    // ************************************************************************\n+\n+    protected Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(leftAssignment -> leftAssignment.getRoom() != null)\n+                .join(MeetingAssignment.class,\n+                        equal(MeetingAssignment::getRoom, MeetingAssignment::getRoom),\n+                        lessThan(MeetingAssignment::getId, MeetingAssignment::getId),\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Room conflict\",\n+                        (leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint avoidOvertime(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .ifNotExists(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex))\n+                .penalizeConfigurable(\"Don't go in overtime\", MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(RequiredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, RequiredAttendance::getPerson),\n+                        lessThan(RequiredAttendance::getId, RequiredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftRequiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightRequiredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required attendance conflict\",\n+                        (leftRequiredAttendance, rightRequiredAttendance, leftAssignment, rightAssignment) -> rightAssignment\n+                                .calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint requiredRoomCapacity(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRequiredCapacity() > meetingAssignment.getRoomCapacity())\n+                .penalizeConfigurable(\"Required room capacity\",\n+                        meetingAssignment -> meetingAssignment.getRequiredCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint startAndEndOnSameDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex),\n+                        filtering((meetingAssignment,\n+                                timeGrain) -> meetingAssignment.getStartingTimeGrain().getDay() != timeGrain.getDay()))\n+                .penalizeConfigurable(\"Start and end on same day\");\n+    }\n+\n+    // ************************************************************************\n+    // Medium constraints\n+    // ************************************************************************\n+\n+    protected Constraint requiredAndPreferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, PreferredAttendance::getPerson))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> requiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> preferredAttendance.getMeeting() == rightAssignment.getMeeting()),", "originalCommit": "8726f57d0eede9f773e32aae9ca00f51fe43f264", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTgxMg==", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451761812", "bodyText": "Joiners.equal(...)?", "author": "triceo", "createdAt": "2020-07-08T19:00:02Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.meetingscheduling.domain.Attendance;\n+import org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment;\n+import org.optaplanner.examples.meetingscheduling.domain.PreferredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.RequiredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.Room;\n+import org.optaplanner.examples.meetingscheduling.domain.TimeGrain;\n+\n+public class MeetingSchedulingConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                roomConflict(constraintFactory),\n+                avoidOvertime(constraintFactory),\n+                requiredAttendanceConflict(constraintFactory),\n+                requiredRoomCapacity(constraintFactory),\n+                startAndEndOnSameDay(constraintFactory),\n+                requiredAndPreferredAttendanceConflict(constraintFactory),\n+                preferredAttendanceConflict(constraintFactory),\n+                doMeetingsAsSoonAsPossible(constraintFactory),\n+                oneBreakBetweenConsecutiveMeetings(constraintFactory),\n+                overlappingMeetings(constraintFactory),\n+                assignLargerRoomsFirst(constraintFactory),\n+                roomStability(constraintFactory)\n+        };\n+    }\n+\n+    // ************************************************************************\n+    // Hard constraints\n+    // ************************************************************************\n+\n+    protected Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(leftAssignment -> leftAssignment.getRoom() != null)\n+                .join(MeetingAssignment.class,\n+                        equal(MeetingAssignment::getRoom, MeetingAssignment::getRoom),\n+                        lessThan(MeetingAssignment::getId, MeetingAssignment::getId),\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Room conflict\",\n+                        (leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint avoidOvertime(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .ifNotExists(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex))\n+                .penalizeConfigurable(\"Don't go in overtime\", MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(RequiredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, RequiredAttendance::getPerson),\n+                        lessThan(RequiredAttendance::getId, RequiredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftRequiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightRequiredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required attendance conflict\",\n+                        (leftRequiredAttendance, rightRequiredAttendance, leftAssignment, rightAssignment) -> rightAssignment\n+                                .calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint requiredRoomCapacity(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRequiredCapacity() > meetingAssignment.getRoomCapacity())\n+                .penalizeConfigurable(\"Required room capacity\",\n+                        meetingAssignment -> meetingAssignment.getRequiredCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint startAndEndOnSameDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex),\n+                        filtering((meetingAssignment,\n+                                timeGrain) -> meetingAssignment.getStartingTimeGrain().getDay() != timeGrain.getDay()))\n+                .penalizeConfigurable(\"Start and end on same day\");\n+    }\n+\n+    // ************************************************************************\n+    // Medium constraints\n+    // ************************************************************************\n+\n+    protected Constraint requiredAndPreferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, PreferredAttendance::getPerson))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> requiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> preferredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required and preferred attendance conflict\");\n+    }\n+\n+    protected Constraint preferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PreferredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(PreferredAttendance::getPerson, PreferredAttendance::getPerson),\n+                        lessThan(PreferredAttendance::getId, PreferredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAttendance.getMeeting() == leftAssignment.getMeeting()),", "originalCommit": "8726f57d0eede9f773e32aae9ca00f51fe43f264", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MTg2Ng==", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451761866", "bodyText": "Joiners.equal(...)?", "author": "triceo", "createdAt": "2020-07-08T19:00:08Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.meetingscheduling.domain.Attendance;\n+import org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment;\n+import org.optaplanner.examples.meetingscheduling.domain.PreferredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.RequiredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.Room;\n+import org.optaplanner.examples.meetingscheduling.domain.TimeGrain;\n+\n+public class MeetingSchedulingConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                roomConflict(constraintFactory),\n+                avoidOvertime(constraintFactory),\n+                requiredAttendanceConflict(constraintFactory),\n+                requiredRoomCapacity(constraintFactory),\n+                startAndEndOnSameDay(constraintFactory),\n+                requiredAndPreferredAttendanceConflict(constraintFactory),\n+                preferredAttendanceConflict(constraintFactory),\n+                doMeetingsAsSoonAsPossible(constraintFactory),\n+                oneBreakBetweenConsecutiveMeetings(constraintFactory),\n+                overlappingMeetings(constraintFactory),\n+                assignLargerRoomsFirst(constraintFactory),\n+                roomStability(constraintFactory)\n+        };\n+    }\n+\n+    // ************************************************************************\n+    // Hard constraints\n+    // ************************************************************************\n+\n+    protected Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(leftAssignment -> leftAssignment.getRoom() != null)\n+                .join(MeetingAssignment.class,\n+                        equal(MeetingAssignment::getRoom, MeetingAssignment::getRoom),\n+                        lessThan(MeetingAssignment::getId, MeetingAssignment::getId),\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Room conflict\",\n+                        (leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint avoidOvertime(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .ifNotExists(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex))\n+                .penalizeConfigurable(\"Don't go in overtime\", MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(RequiredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, RequiredAttendance::getPerson),\n+                        lessThan(RequiredAttendance::getId, RequiredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftRequiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightRequiredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required attendance conflict\",\n+                        (leftRequiredAttendance, rightRequiredAttendance, leftAssignment, rightAssignment) -> rightAssignment\n+                                .calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint requiredRoomCapacity(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRequiredCapacity() > meetingAssignment.getRoomCapacity())\n+                .penalizeConfigurable(\"Required room capacity\",\n+                        meetingAssignment -> meetingAssignment.getRequiredCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint startAndEndOnSameDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex),\n+                        filtering((meetingAssignment,\n+                                timeGrain) -> meetingAssignment.getStartingTimeGrain().getDay() != timeGrain.getDay()))\n+                .penalizeConfigurable(\"Start and end on same day\");\n+    }\n+\n+    // ************************************************************************\n+    // Medium constraints\n+    // ************************************************************************\n+\n+    protected Constraint requiredAndPreferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, PreferredAttendance::getPerson))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> requiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> preferredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required and preferred attendance conflict\");\n+    }\n+\n+    protected Constraint preferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PreferredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(PreferredAttendance::getPerson, PreferredAttendance::getPerson),\n+                        lessThan(PreferredAttendance::getId, PreferredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAttendance.getMeeting() == rightAssignment.getMeeting()),", "originalCommit": "8726f57d0eede9f773e32aae9ca00f51fe43f264", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MjkzMA==", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451762930", "bodyText": "fromUniquePair(...)?\nAlso, when operating on objects of the same type, equal(PreferredAttendance::getPerson) is syntactic sugar for equal(PreferredAttendance::getPerson, PreferredAttendance::getPerson).\nI believe the same is true for lessThan().", "author": "triceo", "createdAt": "2020-07-08T19:02:04Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.meetingscheduling.domain.Attendance;\n+import org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment;\n+import org.optaplanner.examples.meetingscheduling.domain.PreferredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.RequiredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.Room;\n+import org.optaplanner.examples.meetingscheduling.domain.TimeGrain;\n+\n+public class MeetingSchedulingConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                roomConflict(constraintFactory),\n+                avoidOvertime(constraintFactory),\n+                requiredAttendanceConflict(constraintFactory),\n+                requiredRoomCapacity(constraintFactory),\n+                startAndEndOnSameDay(constraintFactory),\n+                requiredAndPreferredAttendanceConflict(constraintFactory),\n+                preferredAttendanceConflict(constraintFactory),\n+                doMeetingsAsSoonAsPossible(constraintFactory),\n+                oneBreakBetweenConsecutiveMeetings(constraintFactory),\n+                overlappingMeetings(constraintFactory),\n+                assignLargerRoomsFirst(constraintFactory),\n+                roomStability(constraintFactory)\n+        };\n+    }\n+\n+    // ************************************************************************\n+    // Hard constraints\n+    // ************************************************************************\n+\n+    protected Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(leftAssignment -> leftAssignment.getRoom() != null)\n+                .join(MeetingAssignment.class,\n+                        equal(MeetingAssignment::getRoom, MeetingAssignment::getRoom),\n+                        lessThan(MeetingAssignment::getId, MeetingAssignment::getId),\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Room conflict\",\n+                        (leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint avoidOvertime(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .ifNotExists(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex))\n+                .penalizeConfigurable(\"Don't go in overtime\", MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(RequiredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, RequiredAttendance::getPerson),\n+                        lessThan(RequiredAttendance::getId, RequiredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftRequiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightRequiredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required attendance conflict\",\n+                        (leftRequiredAttendance, rightRequiredAttendance, leftAssignment, rightAssignment) -> rightAssignment\n+                                .calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint requiredRoomCapacity(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRequiredCapacity() > meetingAssignment.getRoomCapacity())\n+                .penalizeConfigurable(\"Required room capacity\",\n+                        meetingAssignment -> meetingAssignment.getRequiredCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint startAndEndOnSameDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex),\n+                        filtering((meetingAssignment,\n+                                timeGrain) -> meetingAssignment.getStartingTimeGrain().getDay() != timeGrain.getDay()))\n+                .penalizeConfigurable(\"Start and end on same day\");\n+    }\n+\n+    // ************************************************************************\n+    // Medium constraints\n+    // ************************************************************************\n+\n+    protected Constraint requiredAndPreferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, PreferredAttendance::getPerson))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> requiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> preferredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required and preferred attendance conflict\");\n+    }\n+\n+    protected Constraint preferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PreferredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(PreferredAttendance::getPerson, PreferredAttendance::getPerson),\n+                        lessThan(PreferredAttendance::getId, PreferredAttendance::getId))", "originalCommit": "8726f57d0eede9f773e32aae9ca00f51fe43f264", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzcxMzc1MA==", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r453713750", "bodyText": "Ah, good to know, wasn't aware of the equal(PreferredAttendance::getPerson) syntactic sugar. As for fromUniquePair, I actually decided against using it since doing the join manually reads better for me. I don't have an issue to changing it, but in general is syntactic sugar preferred?", "author": "cuijulian", "createdAt": "2020-07-13T15:00:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MjkzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MzI0NA==", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451763244", "bodyText": "I think this should be doable via equal() as well.", "author": "triceo", "createdAt": "2020-07-08T19:02:42Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.meetingscheduling.domain.Attendance;\n+import org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment;\n+import org.optaplanner.examples.meetingscheduling.domain.PreferredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.RequiredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.Room;\n+import org.optaplanner.examples.meetingscheduling.domain.TimeGrain;\n+\n+public class MeetingSchedulingConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                roomConflict(constraintFactory),\n+                avoidOvertime(constraintFactory),\n+                requiredAttendanceConflict(constraintFactory),\n+                requiredRoomCapacity(constraintFactory),\n+                startAndEndOnSameDay(constraintFactory),\n+                requiredAndPreferredAttendanceConflict(constraintFactory),\n+                preferredAttendanceConflict(constraintFactory),\n+                doMeetingsAsSoonAsPossible(constraintFactory),\n+                oneBreakBetweenConsecutiveMeetings(constraintFactory),\n+                overlappingMeetings(constraintFactory),\n+                assignLargerRoomsFirst(constraintFactory),\n+                roomStability(constraintFactory)\n+        };\n+    }\n+\n+    // ************************************************************************\n+    // Hard constraints\n+    // ************************************************************************\n+\n+    protected Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(leftAssignment -> leftAssignment.getRoom() != null)\n+                .join(MeetingAssignment.class,\n+                        equal(MeetingAssignment::getRoom, MeetingAssignment::getRoom),\n+                        lessThan(MeetingAssignment::getId, MeetingAssignment::getId),\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Room conflict\",\n+                        (leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint avoidOvertime(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .ifNotExists(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex))\n+                .penalizeConfigurable(\"Don't go in overtime\", MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(RequiredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, RequiredAttendance::getPerson),\n+                        lessThan(RequiredAttendance::getId, RequiredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftRequiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightRequiredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required attendance conflict\",\n+                        (leftRequiredAttendance, rightRequiredAttendance, leftAssignment, rightAssignment) -> rightAssignment\n+                                .calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint requiredRoomCapacity(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRequiredCapacity() > meetingAssignment.getRoomCapacity())\n+                .penalizeConfigurable(\"Required room capacity\",\n+                        meetingAssignment -> meetingAssignment.getRequiredCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint startAndEndOnSameDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex),\n+                        filtering((meetingAssignment,\n+                                timeGrain) -> meetingAssignment.getStartingTimeGrain().getDay() != timeGrain.getDay()))\n+                .penalizeConfigurable(\"Start and end on same day\");\n+    }\n+\n+    // ************************************************************************\n+    // Medium constraints\n+    // ************************************************************************\n+\n+    protected Constraint requiredAndPreferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, PreferredAttendance::getPerson))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> requiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> preferredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required and preferred attendance conflict\");\n+    }\n+\n+    protected Constraint preferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PreferredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(PreferredAttendance::getPerson, PreferredAttendance::getPerson),\n+                        lessThan(PreferredAttendance::getId, PreferredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Preferred attendance conflict\");\n+    }\n+\n+    // ************************************************************************\n+    // Soft constraints\n+    // ************************************************************************\n+\n+    protected Constraint doMeetingsAsSoonAsPossible(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .penalizeConfigurable(\"Do all meetings as soon as possible\",\n+                        MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint oneBreakBetweenConsecutiveMeetings(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.getStartingTimeGrain() != null),\n+                        filtering((leftAssignment,\n+                                rightAssignment) -> leftAssignment\n+                                        .getLastTimeGrainIndex() == rightAssignment.getStartingTimeGrain().getGrainIndex() - 1))", "originalCommit": "8726f57d0eede9f773e32aae9ca00f51fe43f264", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc0NDEyNg==", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r453744126", "bodyText": "I don't see it, is there a way to use lambda expressions with equal()?", "author": "cuijulian", "createdAt": "2020-07-13T15:40:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MzI0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MzY1Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451763657", "bodyText": "lessThan()?", "author": "triceo", "createdAt": "2020-07-08T19:03:30Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.meetingscheduling.domain.Attendance;\n+import org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment;\n+import org.optaplanner.examples.meetingscheduling.domain.PreferredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.RequiredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.Room;\n+import org.optaplanner.examples.meetingscheduling.domain.TimeGrain;\n+\n+public class MeetingSchedulingConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                roomConflict(constraintFactory),\n+                avoidOvertime(constraintFactory),\n+                requiredAttendanceConflict(constraintFactory),\n+                requiredRoomCapacity(constraintFactory),\n+                startAndEndOnSameDay(constraintFactory),\n+                requiredAndPreferredAttendanceConflict(constraintFactory),\n+                preferredAttendanceConflict(constraintFactory),\n+                doMeetingsAsSoonAsPossible(constraintFactory),\n+                oneBreakBetweenConsecutiveMeetings(constraintFactory),\n+                overlappingMeetings(constraintFactory),\n+                assignLargerRoomsFirst(constraintFactory),\n+                roomStability(constraintFactory)\n+        };\n+    }\n+\n+    // ************************************************************************\n+    // Hard constraints\n+    // ************************************************************************\n+\n+    protected Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(leftAssignment -> leftAssignment.getRoom() != null)\n+                .join(MeetingAssignment.class,\n+                        equal(MeetingAssignment::getRoom, MeetingAssignment::getRoom),\n+                        lessThan(MeetingAssignment::getId, MeetingAssignment::getId),\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Room conflict\",\n+                        (leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint avoidOvertime(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .ifNotExists(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex))\n+                .penalizeConfigurable(\"Don't go in overtime\", MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(RequiredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, RequiredAttendance::getPerson),\n+                        lessThan(RequiredAttendance::getId, RequiredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftRequiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightRequiredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required attendance conflict\",\n+                        (leftRequiredAttendance, rightRequiredAttendance, leftAssignment, rightAssignment) -> rightAssignment\n+                                .calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint requiredRoomCapacity(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRequiredCapacity() > meetingAssignment.getRoomCapacity())\n+                .penalizeConfigurable(\"Required room capacity\",\n+                        meetingAssignment -> meetingAssignment.getRequiredCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint startAndEndOnSameDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex),\n+                        filtering((meetingAssignment,\n+                                timeGrain) -> meetingAssignment.getStartingTimeGrain().getDay() != timeGrain.getDay()))\n+                .penalizeConfigurable(\"Start and end on same day\");\n+    }\n+\n+    // ************************************************************************\n+    // Medium constraints\n+    // ************************************************************************\n+\n+    protected Constraint requiredAndPreferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, PreferredAttendance::getPerson))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> requiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> preferredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required and preferred attendance conflict\");\n+    }\n+\n+    protected Constraint preferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PreferredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(PreferredAttendance::getPerson, PreferredAttendance::getPerson),\n+                        lessThan(PreferredAttendance::getId, PreferredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Preferred attendance conflict\");\n+    }\n+\n+    // ************************************************************************\n+    // Soft constraints\n+    // ************************************************************************\n+\n+    protected Constraint doMeetingsAsSoonAsPossible(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .penalizeConfigurable(\"Do all meetings as soon as possible\",\n+                        MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint oneBreakBetweenConsecutiveMeetings(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.getStartingTimeGrain() != null),\n+                        filtering((leftAssignment,\n+                                rightAssignment) -> leftAssignment\n+                                        .getLastTimeGrainIndex() == rightAssignment.getStartingTimeGrain().getGrainIndex() - 1))\n+                .penalizeConfigurable(\"One TimeGrain break between two consecutive meetings\");\n+    }\n+\n+    protected Constraint overlappingMeetings(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.getStartingTimeGrain() != null),\n+                        filtering((leftAssignment,\n+                                rightAssignment) -> rightAssignment.getMeeting().getId() < leftAssignment.getMeeting().getId()),", "originalCommit": "8726f57d0eede9f773e32aae9ca00f51fe43f264", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc0OTc0NQ==", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r453749745", "bodyText": "Similar to equal(), how to put lambda expression in lessThan()?", "author": "cuijulian", "createdAt": "2020-07-13T15:48:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MzY1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc1MzIzMA==", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r453753230", "bodyText": "You need to move past method references. Simply use full lambda syntax - (a, b) -> c. That will allow you to write all joiners without restrictions.", "author": "triceo", "createdAt": "2020-07-13T15:53:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2MzY1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2Mzg3OA==", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451763878", "bodyText": "Joiners.equal()?", "author": "triceo", "createdAt": "2020-07-08T19:03:55Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.meetingscheduling.domain.Attendance;\n+import org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment;\n+import org.optaplanner.examples.meetingscheduling.domain.PreferredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.RequiredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.Room;\n+import org.optaplanner.examples.meetingscheduling.domain.TimeGrain;\n+\n+public class MeetingSchedulingConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                roomConflict(constraintFactory),\n+                avoidOvertime(constraintFactory),\n+                requiredAttendanceConflict(constraintFactory),\n+                requiredRoomCapacity(constraintFactory),\n+                startAndEndOnSameDay(constraintFactory),\n+                requiredAndPreferredAttendanceConflict(constraintFactory),\n+                preferredAttendanceConflict(constraintFactory),\n+                doMeetingsAsSoonAsPossible(constraintFactory),\n+                oneBreakBetweenConsecutiveMeetings(constraintFactory),\n+                overlappingMeetings(constraintFactory),\n+                assignLargerRoomsFirst(constraintFactory),\n+                roomStability(constraintFactory)\n+        };\n+    }\n+\n+    // ************************************************************************\n+    // Hard constraints\n+    // ************************************************************************\n+\n+    protected Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(leftAssignment -> leftAssignment.getRoom() != null)\n+                .join(MeetingAssignment.class,\n+                        equal(MeetingAssignment::getRoom, MeetingAssignment::getRoom),\n+                        lessThan(MeetingAssignment::getId, MeetingAssignment::getId),\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Room conflict\",\n+                        (leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint avoidOvertime(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .ifNotExists(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex))\n+                .penalizeConfigurable(\"Don't go in overtime\", MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(RequiredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, RequiredAttendance::getPerson),\n+                        lessThan(RequiredAttendance::getId, RequiredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftRequiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightRequiredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required attendance conflict\",\n+                        (leftRequiredAttendance, rightRequiredAttendance, leftAssignment, rightAssignment) -> rightAssignment\n+                                .calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint requiredRoomCapacity(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRequiredCapacity() > meetingAssignment.getRoomCapacity())\n+                .penalizeConfigurable(\"Required room capacity\",\n+                        meetingAssignment -> meetingAssignment.getRequiredCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint startAndEndOnSameDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex),\n+                        filtering((meetingAssignment,\n+                                timeGrain) -> meetingAssignment.getStartingTimeGrain().getDay() != timeGrain.getDay()))\n+                .penalizeConfigurable(\"Start and end on same day\");\n+    }\n+\n+    // ************************************************************************\n+    // Medium constraints\n+    // ************************************************************************\n+\n+    protected Constraint requiredAndPreferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, PreferredAttendance::getPerson))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> requiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> preferredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required and preferred attendance conflict\");\n+    }\n+\n+    protected Constraint preferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PreferredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(PreferredAttendance::getPerson, PreferredAttendance::getPerson),\n+                        lessThan(PreferredAttendance::getId, PreferredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Preferred attendance conflict\");\n+    }\n+\n+    // ************************************************************************\n+    // Soft constraints\n+    // ************************************************************************\n+\n+    protected Constraint doMeetingsAsSoonAsPossible(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .penalizeConfigurable(\"Do all meetings as soon as possible\",\n+                        MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint oneBreakBetweenConsecutiveMeetings(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.getStartingTimeGrain() != null),\n+                        filtering((leftAssignment,\n+                                rightAssignment) -> leftAssignment\n+                                        .getLastTimeGrainIndex() == rightAssignment.getStartingTimeGrain().getGrainIndex() - 1))\n+                .penalizeConfigurable(\"One TimeGrain break between two consecutive meetings\");\n+    }\n+\n+    protected Constraint overlappingMeetings(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.getStartingTimeGrain() != null),\n+                        filtering((leftAssignment,\n+                                rightAssignment) -> rightAssignment.getMeeting().getId() < leftAssignment.getMeeting().getId()),\n+                        filtering((leftAssignment,\n+                                rightAssignment) -> leftAssignment.getMeeting() != rightAssignment.getMeeting()),\n+                        filtering((leftAssignment, rightAssignment) -> leftAssignment.calculateOverlap(rightAssignment) != 0))\n+                .penalizeConfigurable(\"Overlapping meetings\");\n+    }\n+\n+    // TODO: Unspecified bug marked in DRL\n+    protected Constraint assignLargerRoomsFirst(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRoom() != null)\n+                .join(Room.class,\n+                        lessThan(MeetingAssignment::getRoomCapacity, Room::getCapacity))\n+                .penalizeConfigurable(\"Assign larger rooms first\",\n+                        (meetingAssignment, room) -> room.getCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint roomStability(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Attendance.class)\n+                .join(Attendance.class,\n+                        equal(Attendance::getPerson, Attendance::getPerson),\n+                        filtering((leftAttendance,\n+                                rightAttendance) -> leftAttendance.getMeeting() != rightAttendance.getMeeting()))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAttendance.getMeeting() == leftAssignment.getMeeting()),", "originalCommit": "8726f57d0eede9f773e32aae9ca00f51fe43f264", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2Mzk5OQ==", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451763999", "bodyText": "Joiners.equal()?", "author": "triceo", "createdAt": "2020-07-08T19:04:11Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.meetingscheduling.domain.Attendance;\n+import org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment;\n+import org.optaplanner.examples.meetingscheduling.domain.PreferredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.RequiredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.Room;\n+import org.optaplanner.examples.meetingscheduling.domain.TimeGrain;\n+\n+public class MeetingSchedulingConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                roomConflict(constraintFactory),\n+                avoidOvertime(constraintFactory),\n+                requiredAttendanceConflict(constraintFactory),\n+                requiredRoomCapacity(constraintFactory),\n+                startAndEndOnSameDay(constraintFactory),\n+                requiredAndPreferredAttendanceConflict(constraintFactory),\n+                preferredAttendanceConflict(constraintFactory),\n+                doMeetingsAsSoonAsPossible(constraintFactory),\n+                oneBreakBetweenConsecutiveMeetings(constraintFactory),\n+                overlappingMeetings(constraintFactory),\n+                assignLargerRoomsFirst(constraintFactory),\n+                roomStability(constraintFactory)\n+        };\n+    }\n+\n+    // ************************************************************************\n+    // Hard constraints\n+    // ************************************************************************\n+\n+    protected Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(leftAssignment -> leftAssignment.getRoom() != null)\n+                .join(MeetingAssignment.class,\n+                        equal(MeetingAssignment::getRoom, MeetingAssignment::getRoom),\n+                        lessThan(MeetingAssignment::getId, MeetingAssignment::getId),\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Room conflict\",\n+                        (leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint avoidOvertime(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .ifNotExists(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex))\n+                .penalizeConfigurable(\"Don't go in overtime\", MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(RequiredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, RequiredAttendance::getPerson),\n+                        lessThan(RequiredAttendance::getId, RequiredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftRequiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightRequiredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required attendance conflict\",\n+                        (leftRequiredAttendance, rightRequiredAttendance, leftAssignment, rightAssignment) -> rightAssignment\n+                                .calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint requiredRoomCapacity(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRequiredCapacity() > meetingAssignment.getRoomCapacity())\n+                .penalizeConfigurable(\"Required room capacity\",\n+                        meetingAssignment -> meetingAssignment.getRequiredCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint startAndEndOnSameDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex),\n+                        filtering((meetingAssignment,\n+                                timeGrain) -> meetingAssignment.getStartingTimeGrain().getDay() != timeGrain.getDay()))\n+                .penalizeConfigurable(\"Start and end on same day\");\n+    }\n+\n+    // ************************************************************************\n+    // Medium constraints\n+    // ************************************************************************\n+\n+    protected Constraint requiredAndPreferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, PreferredAttendance::getPerson))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> requiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> preferredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required and preferred attendance conflict\");\n+    }\n+\n+    protected Constraint preferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PreferredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(PreferredAttendance::getPerson, PreferredAttendance::getPerson),\n+                        lessThan(PreferredAttendance::getId, PreferredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Preferred attendance conflict\");\n+    }\n+\n+    // ************************************************************************\n+    // Soft constraints\n+    // ************************************************************************\n+\n+    protected Constraint doMeetingsAsSoonAsPossible(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .penalizeConfigurable(\"Do all meetings as soon as possible\",\n+                        MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint oneBreakBetweenConsecutiveMeetings(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.getStartingTimeGrain() != null),\n+                        filtering((leftAssignment,\n+                                rightAssignment) -> leftAssignment\n+                                        .getLastTimeGrainIndex() == rightAssignment.getStartingTimeGrain().getGrainIndex() - 1))\n+                .penalizeConfigurable(\"One TimeGrain break between two consecutive meetings\");\n+    }\n+\n+    protected Constraint overlappingMeetings(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.getStartingTimeGrain() != null),\n+                        filtering((leftAssignment,\n+                                rightAssignment) -> rightAssignment.getMeeting().getId() < leftAssignment.getMeeting().getId()),\n+                        filtering((leftAssignment,\n+                                rightAssignment) -> leftAssignment.getMeeting() != rightAssignment.getMeeting()),\n+                        filtering((leftAssignment, rightAssignment) -> leftAssignment.calculateOverlap(rightAssignment) != 0))\n+                .penalizeConfigurable(\"Overlapping meetings\");\n+    }\n+\n+    // TODO: Unspecified bug marked in DRL\n+    protected Constraint assignLargerRoomsFirst(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRoom() != null)\n+                .join(Room.class,\n+                        lessThan(MeetingAssignment::getRoomCapacity, Room::getCapacity))\n+                .penalizeConfigurable(\"Assign larger rooms first\",\n+                        (meetingAssignment, room) -> room.getCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint roomStability(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Attendance.class)\n+                .join(Attendance.class,\n+                        equal(Attendance::getPerson, Attendance::getPerson),\n+                        filtering((leftAttendance,\n+                                rightAttendance) -> leftAttendance.getMeeting() != rightAttendance.getMeeting()))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAttendance.getMeeting() == rightAssignment.getMeeting()),", "originalCommit": "8726f57d0eede9f773e32aae9ca00f51fe43f264", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2NDUxOA==", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r451764518", "bodyText": "From the looks of it, this should be doable with lessThan(...).", "author": "triceo", "createdAt": "2020-07-08T19:05:10Z", "path": "optaplanner-examples/src/main/java/org/optaplanner/examples/meetingscheduling/optional/score/MeetingSchedulingConstraintProvider.java", "diffHunk": "@@ -0,0 +1,224 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.examples.meetingscheduling.optional.score;\n+\n+import static org.optaplanner.core.api.score.stream.Joiners.equal;\n+import static org.optaplanner.core.api.score.stream.Joiners.filtering;\n+import static org.optaplanner.core.api.score.stream.Joiners.lessThan;\n+\n+import org.optaplanner.core.api.score.stream.Constraint;\n+import org.optaplanner.core.api.score.stream.ConstraintFactory;\n+import org.optaplanner.core.api.score.stream.ConstraintProvider;\n+import org.optaplanner.examples.meetingscheduling.domain.Attendance;\n+import org.optaplanner.examples.meetingscheduling.domain.MeetingAssignment;\n+import org.optaplanner.examples.meetingscheduling.domain.PreferredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.RequiredAttendance;\n+import org.optaplanner.examples.meetingscheduling.domain.Room;\n+import org.optaplanner.examples.meetingscheduling.domain.TimeGrain;\n+\n+public class MeetingSchedulingConstraintProvider implements ConstraintProvider {\n+\n+    @Override\n+    public Constraint[] defineConstraints(ConstraintFactory constraintFactory) {\n+        return new Constraint[] {\n+                roomConflict(constraintFactory),\n+                avoidOvertime(constraintFactory),\n+                requiredAttendanceConflict(constraintFactory),\n+                requiredRoomCapacity(constraintFactory),\n+                startAndEndOnSameDay(constraintFactory),\n+                requiredAndPreferredAttendanceConflict(constraintFactory),\n+                preferredAttendanceConflict(constraintFactory),\n+                doMeetingsAsSoonAsPossible(constraintFactory),\n+                oneBreakBetweenConsecutiveMeetings(constraintFactory),\n+                overlappingMeetings(constraintFactory),\n+                assignLargerRoomsFirst(constraintFactory),\n+                roomStability(constraintFactory)\n+        };\n+    }\n+\n+    // ************************************************************************\n+    // Hard constraints\n+    // ************************************************************************\n+\n+    protected Constraint roomConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(leftAssignment -> leftAssignment.getRoom() != null)\n+                .join(MeetingAssignment.class,\n+                        equal(MeetingAssignment::getRoom, MeetingAssignment::getRoom),\n+                        lessThan(MeetingAssignment::getId, MeetingAssignment::getId),\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Room conflict\",\n+                        (leftAssignment, rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint avoidOvertime(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .ifNotExists(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex))\n+                .penalizeConfigurable(\"Don't go in overtime\", MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint requiredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(RequiredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, RequiredAttendance::getPerson),\n+                        lessThan(RequiredAttendance::getId, RequiredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftRequiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightRequiredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftRequiredAttendance, rightRequiredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required attendance conflict\",\n+                        (leftRequiredAttendance, rightRequiredAttendance, leftAssignment, rightAssignment) -> rightAssignment\n+                                .calculateOverlap(leftAssignment));\n+    }\n+\n+    protected Constraint requiredRoomCapacity(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRequiredCapacity() > meetingAssignment.getRoomCapacity())\n+                .penalizeConfigurable(\"Required room capacity\",\n+                        meetingAssignment -> meetingAssignment.getRequiredCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint startAndEndOnSameDay(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(TimeGrain.class,\n+                        equal(MeetingAssignment::getLastTimeGrainIndex, TimeGrain::getGrainIndex),\n+                        filtering((meetingAssignment,\n+                                timeGrain) -> meetingAssignment.getStartingTimeGrain().getDay() != timeGrain.getDay()))\n+                .penalizeConfigurable(\"Start and end on same day\");\n+    }\n+\n+    // ************************************************************************\n+    // Medium constraints\n+    // ************************************************************************\n+\n+    protected Constraint requiredAndPreferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(RequiredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(RequiredAttendance::getPerson, PreferredAttendance::getPerson))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> requiredAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> preferredAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((requiredAttendance, preferredAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Required and preferred attendance conflict\");\n+    }\n+\n+    protected Constraint preferredAttendanceConflict(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(PreferredAttendance.class)\n+                .join(PreferredAttendance.class,\n+                        equal(PreferredAttendance::getPerson, PreferredAttendance::getPerson),\n+                        lessThan(PreferredAttendance::getId, PreferredAttendance::getId))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.calculateOverlap(leftAssignment) > 0))\n+                .penalizeConfigurable(\"Preferred attendance conflict\");\n+    }\n+\n+    // ************************************************************************\n+    // Soft constraints\n+    // ************************************************************************\n+\n+    protected Constraint doMeetingsAsSoonAsPossible(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .penalizeConfigurable(\"Do all meetings as soon as possible\",\n+                        MeetingAssignment::getLastTimeGrainIndex);\n+    }\n+\n+    protected Constraint oneBreakBetweenConsecutiveMeetings(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.getStartingTimeGrain() != null),\n+                        filtering((leftAssignment,\n+                                rightAssignment) -> leftAssignment\n+                                        .getLastTimeGrainIndex() == rightAssignment.getStartingTimeGrain().getGrainIndex() - 1))\n+                .penalizeConfigurable(\"One TimeGrain break between two consecutive meetings\");\n+    }\n+\n+    protected Constraint overlappingMeetings(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getStartingTimeGrain() != null)\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAssignment, rightAssignment) -> rightAssignment.getStartingTimeGrain() != null),\n+                        filtering((leftAssignment,\n+                                rightAssignment) -> rightAssignment.getMeeting().getId() < leftAssignment.getMeeting().getId()),\n+                        filtering((leftAssignment,\n+                                rightAssignment) -> leftAssignment.getMeeting() != rightAssignment.getMeeting()),\n+                        filtering((leftAssignment, rightAssignment) -> leftAssignment.calculateOverlap(rightAssignment) != 0))\n+                .penalizeConfigurable(\"Overlapping meetings\");\n+    }\n+\n+    // TODO: Unspecified bug marked in DRL\n+    protected Constraint assignLargerRoomsFirst(ConstraintFactory constraintFactory) {\n+        return constraintFactory.fromUnfiltered(MeetingAssignment.class)\n+                .filter(meetingAssignment -> meetingAssignment.getRoom() != null)\n+                .join(Room.class,\n+                        lessThan(MeetingAssignment::getRoomCapacity, Room::getCapacity))\n+                .penalizeConfigurable(\"Assign larger rooms first\",\n+                        (meetingAssignment, room) -> room.getCapacity() - meetingAssignment.getRoomCapacity());\n+    }\n+\n+    protected Constraint roomStability(ConstraintFactory constraintFactory) {\n+        return constraintFactory.from(Attendance.class)\n+                .join(Attendance.class,\n+                        equal(Attendance::getPerson, Attendance::getPerson),\n+                        filtering((leftAttendance,\n+                                rightAttendance) -> leftAttendance.getMeeting() != rightAttendance.getMeeting()))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAttendance.getMeeting() == leftAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance,\n+                                leftAssignment) -> leftAssignment.getStartingTimeGrain() != null))\n+                .join(MeetingAssignment.class,\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAttendance.getMeeting() == rightAssignment.getMeeting()),\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> rightAssignment.getStartingTimeGrain() != null),\n+                        filtering((leftAttendance, rightAttendance, leftAssignment,\n+                                rightAssignment) -> leftAssignment.getStartingTimeGrain().getGrainIndex() < rightAssignment\n+                                        .getStartingTimeGrain().getGrainIndex()),", "originalCommit": "8726f57d0eede9f773e32aae9ca00f51fe43f264", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzc1MDk1NA==", "url": "https://github.com/kiegroup/optaplanner/pull/808#discussion_r453750954", "bodyText": "Same as above, how to put lambda expression in lessThan()?", "author": "cuijulian", "createdAt": "2020-07-13T15:50:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2NDUxOA=="}], "type": "inlineReview"}, {"oid": "1fb3899aefdb5a35be2e3a615306fcbcbe3b2867", "url": "https://github.com/kiegroup/optaplanner/commit/1fb3899aefdb5a35be2e3a615306fcbcbe3b2867", "message": "Convert MeetingScheduling example to ConstraintStreams", "committedDate": "2020-07-13T20:31:16Z", "type": "commit"}, {"oid": "1fb3899aefdb5a35be2e3a615306fcbcbe3b2867", "url": "https://github.com/kiegroup/optaplanner/commit/1fb3899aefdb5a35be2e3a615306fcbcbe3b2867", "message": "Convert MeetingScheduling example to ConstraintStreams", "committedDate": "2020-07-13T20:31:16Z", "type": "forcePushed"}]}