{"pr_number": 882, "pr_title": "PLANNER-2114 Extract build methods from Config", "pr_createdAt": "2020-08-13T11:09:21Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/882", "timeline": [{"oid": "70a4bf2a4dea37191f024f07fa896e23b67069e5", "url": "https://github.com/kiegroup/optaplanner/commit/70a4bf2a4dea37191f024f07fa896e23b67069e5", "message": "PLANNER-2114 Extract build methods from Config\n\nThis commit scope is move selectors.", "committedDate": "2020-08-13T11:20:00Z", "type": "forcePushed"}, {"oid": "5097fdb32bcb6e8d4087f24084b61384bb35cc2a", "url": "https://github.com/kiegroup/optaplanner/commit/5097fdb32bcb6e8d4087f24084b61384bb35cc2a", "message": "PLANNER-2114 Extract build methods from Config\n\nThis commit scope is move selectors.", "committedDate": "2020-08-13T12:51:59Z", "type": "commit"}, {"oid": "5097fdb32bcb6e8d4087f24084b61384bb35cc2a", "url": "https://github.com/kiegroup/optaplanner/commit/5097fdb32bcb6e8d4087f24084b61384bb35cc2a", "message": "PLANNER-2114 Extract build methods from Config\n\nThis commit scope is move selectors.", "committedDate": "2020-08-13T12:51:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0MDU2Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/882#discussion_r470040567", "bodyText": "Missing @Override.", "author": "yurloc", "createdAt": "2020-08-13T15:32:42Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/MoveSelectorFactory.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.heuristic.selector.move;\n+\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionCacheType;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionOrder;\n+import org.optaplanner.core.config.heuristic.selector.move.MoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.composite.CartesianProductMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.composite.UnionMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.factory.MoveIteratorFactoryConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.factory.MoveListFactoryConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.ChangeMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.PillarChangeMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.PillarSwapMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.SwapMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.chained.KOptMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.chained.SubChainChangeMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.chained.SubChainSwapMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.chained.TailChainSwapMoveSelectorConfig;\n+import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n+import org.optaplanner.core.impl.heuristic.selector.move.composite.CartesianProductMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.composite.UnionMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.factory.MoveIteratorFactoryFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.factory.MoveListFactoryFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.ChangeMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.PillarChangeMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.PillarSwapMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.SwapMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.chained.KOptMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.chained.SubChainChangeMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.chained.SubChainSwapMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.chained.TailChainSwapMoveSelectorFactory;\n+\n+public interface MoveSelectorFactory {\n+\n+    static MoveSelectorFactory get(MoveSelectorConfig<?> moveSelectorConfig) {\n+        if (ChangeMoveSelectorConfig.class.isAssignableFrom(moveSelectorConfig.getClass())) {\n+            return new ChangeMoveSelectorFactory((ChangeMoveSelectorConfig) moveSelectorConfig);\n+        } else if (SwapMoveSelectorConfig.class.isAssignableFrom(moveSelectorConfig.getClass())) {\n+            return new SwapMoveSelectorFactory((SwapMoveSelectorConfig) moveSelectorConfig);\n+        } else if (PillarChangeMoveSelectorConfig.class.isAssignableFrom(moveSelectorConfig.getClass())) {\n+            return new PillarChangeMoveSelectorFactory((PillarChangeMoveSelectorConfig) moveSelectorConfig);\n+        } else if (PillarSwapMoveSelectorConfig.class.isAssignableFrom(moveSelectorConfig.getClass())) {\n+            return new PillarSwapMoveSelectorFactory((PillarSwapMoveSelectorConfig) moveSelectorConfig);\n+        } else if (UnionMoveSelectorConfig.class.isAssignableFrom(moveSelectorConfig.getClass())) {\n+            return new UnionMoveSelectorFactory((UnionMoveSelectorConfig) moveSelectorConfig);\n+        } else if (CartesianProductMoveSelectorConfig.class.isAssignableFrom(moveSelectorConfig.getClass())) {\n+            return new CartesianProductMoveSelectorFactory((CartesianProductMoveSelectorConfig) moveSelectorConfig);\n+        } else if (SubChainChangeMoveSelectorConfig.class.isAssignableFrom(moveSelectorConfig.getClass())) {\n+            return new SubChainChangeMoveSelectorFactory((SubChainChangeMoveSelectorConfig) moveSelectorConfig);\n+        } else if (SubChainSwapMoveSelectorConfig.class.isAssignableFrom(moveSelectorConfig.getClass())) {\n+            return new SubChainSwapMoveSelectorFactory((SubChainSwapMoveSelectorConfig) moveSelectorConfig);\n+        } else if (TailChainSwapMoveSelectorConfig.class.isAssignableFrom(moveSelectorConfig.getClass())) {\n+            return new TailChainSwapMoveSelectorFactory((TailChainSwapMoveSelectorConfig) moveSelectorConfig);\n+        } else if (MoveIteratorFactoryConfig.class.isAssignableFrom(moveSelectorConfig.getClass())) {\n+            return new MoveIteratorFactoryFactory((MoveIteratorFactoryConfig) moveSelectorConfig);\n+        } else if (MoveListFactoryConfig.class.isAssignableFrom(moveSelectorConfig.getClass())) {\n+            return new MoveListFactoryFactory((MoveListFactoryConfig) moveSelectorConfig);\n+        } else if (KOptMoveSelectorConfig.class.isAssignableFrom(moveSelectorConfig.getClass())) {\n+            return new KOptMoveSelectorFactory((KOptMoveSelectorConfig) moveSelectorConfig);\n+        } else {\n+            throw new IllegalArgumentException(\n+                    String.format(\"Unknown MoveSelectorConfig type: (%s).\", moveSelectorConfig.getClass().getName()));\n+        }\n+    }\n+\n+    /**\n+     * Builds {@link MoveSelector} from the {@link MoveSelectorConfig} and provided parameters.\n+     * \n+     * @param configPolicy never null\n+     * @param minimumCacheType never null, If caching is used (different from {@link SelectionCacheType#JUST_IN_TIME}),\n+     *        then it should be at least this {@link SelectionCacheType} because an ancestor already uses such caching\n+     *        and less would be pointless.\n+     * @param inheritedSelectionOrder never null\n+     * @return never null\n+     */\n+    MoveSelector buildMoveSelector(HeuristicConfigPolicy configPolicy, SelectionCacheType minimumCacheType,", "originalCommit": "5097fdb32bcb6e8d4087f24084b61384bb35cc2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTI5OTcyNA==", "url": "https://github.com/kiegroup/optaplanner/pull/882#discussion_r471299724", "bodyText": "This is an interface, maybe you meant the same method on the AbstractMoveSelectorFactory?. Added, thanks.", "author": "rsynek", "createdAt": "2020-08-17T07:44:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0MDU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0MTAyOA==", "url": "https://github.com/kiegroup/optaplanner/pull/882#discussion_r470041028", "bodyText": "I didn't notice it in the previous PR but this should be called create() for consistency with SolverFactory.", "author": "yurloc", "createdAt": "2020-08-13T15:33:25Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/heuristic/selector/move/MoveSelectorFactory.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.heuristic.selector.move;\n+\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionCacheType;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionOrder;\n+import org.optaplanner.core.config.heuristic.selector.move.MoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.composite.CartesianProductMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.composite.UnionMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.factory.MoveIteratorFactoryConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.factory.MoveListFactoryConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.ChangeMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.PillarChangeMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.PillarSwapMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.SwapMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.chained.KOptMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.chained.SubChainChangeMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.chained.SubChainSwapMoveSelectorConfig;\n+import org.optaplanner.core.config.heuristic.selector.move.generic.chained.TailChainSwapMoveSelectorConfig;\n+import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n+import org.optaplanner.core.impl.heuristic.selector.move.composite.CartesianProductMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.composite.UnionMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.factory.MoveIteratorFactoryFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.factory.MoveListFactoryFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.ChangeMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.PillarChangeMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.PillarSwapMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.SwapMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.chained.KOptMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.chained.SubChainChangeMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.chained.SubChainSwapMoveSelectorFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.generic.chained.TailChainSwapMoveSelectorFactory;\n+\n+public interface MoveSelectorFactory {\n+\n+    static MoveSelectorFactory get(MoveSelectorConfig<?> moveSelectorConfig) {", "originalCommit": "5097fdb32bcb6e8d4087f24084b61384bb35cc2a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0NzQxMw==", "url": "https://github.com/kiegroup/optaplanner/pull/882#discussion_r470047413", "bodyText": "TODO improve this method in the next PR (I can do that).\n\nAdd a zero-arg method instead of checking whether the argument is null.\nMaybe access entityDescriptorMap directly.", "author": "yurloc", "createdAt": "2020-08-13T15:43:00Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/solution/descriptor/SolutionDescriptor.java", "diffHunk": "@@ -727,6 +727,32 @@ public ScoreDefinition getScoreDefinition() {\n     // Model methods\n     // ************************************************************************\n \n+    public EntityDescriptor deduceEntityDescriptor(Class<?> entityClass) {", "originalCommit": "5097fdb32bcb6e8d4087f24084b61384bb35cc2a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTE1NzMwNA==", "url": "https://github.com/kiegroup/optaplanner/pull/882#discussion_r471157304", "bodyText": "Please don't access collections directly. Leaking references to collections leads to a virtual impossibility of figuring out who has the opportunity to read (and more importantly write) it.\nThe config code is full of places where collections are being exported to other places, where they are being modified indiscriminately. Refactoring such code becomes a nightmare, as you are never sure if you've covered all the possible state mutators.\nTherefore I would like to suggest that exporting a modifiable collection should be prohibited.", "author": "triceo", "createdAt": "2020-08-16T20:53:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0NzQxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTMwNjIzOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/882#discussion_r471306239", "bodyText": "As for the first suggestion, I will look into it in the next PR, which will be focused on the entity and value selection config. As for the second suggestion, I would end up duplicating a part of the getGenuineEntityDescriptors method, with the drawbacks @triceo has mentioned (although the reference does not leak out the class).\n@yurloc could you please explain what is your concern about not accessing the map directly?", "author": "rsynek", "createdAt": "2020-08-17T07:58:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0NzQxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIwNzMyNQ==", "url": "https://github.com/kiegroup/optaplanner/pull/882#discussion_r477207325", "bodyText": "The original post in this thread was a note for myself. I understand the second suggestion might be a bit confusing. Let's continue on line 733.", "author": "yurloc", "createdAt": "2020-08-26T10:45:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0NzQxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzIwNzk3Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/882#discussion_r477207972", "bodyText": "I fully agree with what Lukas have said.", "author": "yurloc", "createdAt": "2020-08-26T10:46:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDA0NzQxMw=="}], "type": "inlineReview"}, {"oid": "274d198ad020bb07ed2b34008d976d30f711b3c0", "url": "https://github.com/kiegroup/optaplanner/commit/274d198ad020bb07ed2b34008d976d30f711b3c0", "message": "Rename factory methods to 'create'", "committedDate": "2020-08-17T07:38:20Z", "type": "commit"}, {"oid": "afa736f7b64a74298234b324ed8e35314870105a", "url": "https://github.com/kiegroup/optaplanner/commit/afa736f7b64a74298234b324ed8e35314870105a", "message": "Add missing override annotation", "committedDate": "2020-08-17T07:45:45Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM4NzQxNw==", "url": "https://github.com/kiegroup/optaplanner/pull/882#discussion_r471387417", "bodyText": "This method, it's actually two methods. One accepts the argument, the other doesn't need it. Let's do it like that.", "author": "triceo", "createdAt": "2020-08-17T10:29:20Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/entity/descriptor/EntityDescriptor.java", "diffHunk": "@@ -516,6 +516,58 @@ public boolean hasAnyChainedGenuineVariables() {\n         return false;\n     }\n \n+    public GenuineVariableDescriptor deduceVariableDescriptor(String variableName) {\n+        GenuineVariableDescriptor<Solution_> variableDescriptor;\n+        if (variableName != null) {\n+            variableDescriptor = getGenuineVariableDescriptor(variableName);\n+            if (variableDescriptor == null) {\n+                throw new IllegalArgumentException(\"The config (\" + this\n+                        + \") has a variableName (\" + variableName\n+                        + \") which is not a valid planning variable on entityClass (\"\n+                        + getEntityClass() + \").\\n\"\n+                        + buildInvalidVariableNameExceptionMessage(variableName));\n+            }\n+        } else {\n+            Collection<GenuineVariableDescriptor<Solution_>> variableDescriptors = getGenuineVariableDescriptors();\n+            if (variableDescriptors.size() != 1) {\n+                throw new IllegalArgumentException(\"The config (\" + this\n+                        + \") has no configured variableName (\" + variableName\n+                        + \") for entityClass (\" + getEntityClass()\n+                        + \") and because there are multiple variableNames (\"\n+                        + getGenuineVariableNameSet()\n+                        + \"), it cannot be deduced automatically.\");\n+            }\n+            variableDescriptor = variableDescriptors.iterator().next();\n+        }\n+        return variableDescriptor;\n+    }", "originalCommit": "afa736f7b64a74298234b324ed8e35314870105a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQwNjk0OA==", "url": "https://github.com/kiegroup/optaplanner/pull/882#discussion_r471406948", "bodyText": "will be addressed in the next PR, see the comment below.", "author": "rsynek", "createdAt": "2020-08-17T11:09:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM4NzQxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM4Nzk0MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/882#discussion_r471387941", "bodyText": "I'd prefer a no-arg overload to just putting null here.", "author": "triceo", "createdAt": "2020-08-17T10:30:07Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/entity/descriptor/EntityDescriptor.java", "diffHunk": "@@ -516,6 +516,58 @@ public boolean hasAnyChainedGenuineVariables() {\n         return false;\n     }\n \n+    public GenuineVariableDescriptor deduceVariableDescriptor(String variableName) {\n+        GenuineVariableDescriptor<Solution_> variableDescriptor;\n+        if (variableName != null) {\n+            variableDescriptor = getGenuineVariableDescriptor(variableName);\n+            if (variableDescriptor == null) {\n+                throw new IllegalArgumentException(\"The config (\" + this\n+                        + \") has a variableName (\" + variableName\n+                        + \") which is not a valid planning variable on entityClass (\"\n+                        + getEntityClass() + \").\\n\"\n+                        + buildInvalidVariableNameExceptionMessage(variableName));\n+            }\n+        } else {\n+            Collection<GenuineVariableDescriptor<Solution_>> variableDescriptors = getGenuineVariableDescriptors();\n+            if (variableDescriptors.size() != 1) {\n+                throw new IllegalArgumentException(\"The config (\" + this\n+                        + \") has no configured variableName (\" + variableName\n+                        + \") for entityClass (\" + getEntityClass()\n+                        + \") and because there are multiple variableNames (\"\n+                        + getGenuineVariableNameSet()\n+                        + \"), it cannot be deduced automatically.\");\n+            }\n+            variableDescriptor = variableDescriptors.iterator().next();\n+        }\n+        return variableDescriptor;\n+    }\n+\n+    public List<GenuineVariableDescriptor<Solution_>> deduceVariableDescriptorList(List<String> variableNameIncludeList) {", "originalCommit": "afa736f7b64a74298234b324ed8e35314870105a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQwNjk5Mg==", "url": "https://github.com/kiegroup/optaplanner/pull/882#discussion_r471406992", "bodyText": "will be addressed in the next PR, see the comment below.", "author": "rsynek", "createdAt": "2020-08-17T11:09:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM4Nzk0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM4ODM3Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/882#discussion_r471388377", "bodyText": "Same comment on the entityClass nullity. This is two methods masquerading as one.", "author": "triceo", "createdAt": "2020-08-17T10:30:58Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/domain/solution/descriptor/SolutionDescriptor.java", "diffHunk": "@@ -727,6 +727,32 @@ public ScoreDefinition getScoreDefinition() {\n     // Model methods\n     // ************************************************************************\n \n+    public EntityDescriptor deduceEntityDescriptor(Class<?> entityClass) {\n+        EntityDescriptor<Solution_> entityDescriptor;\n+        if (entityClass != null) {\n+            entityDescriptor = getEntityDescriptorStrict(entityClass);\n+            if (entityDescriptor == null) {\n+                throw new IllegalArgumentException(\"The config (\" + this\n+                        + \") has an entityClass (\" + entityClass + \") that is not a known planning entity.\\n\"\n+                        + \"Check your solver configuration. If that class (\" + entityClass.getSimpleName()\n+                        + \") is not in the entityClassSet (\" + getEntityClassSet()\n+                        + \"), check your \" + PlanningSolution.class.getSimpleName()\n+                        + \" implementation's annotated methods too.\");\n+            }\n+        } else {\n+            Collection<EntityDescriptor<Solution_>> entityDescriptors = getGenuineEntityDescriptors();\n+            if (entityDescriptors.size() != 1) {\n+                throw new IllegalArgumentException(\"The config (\" + this\n+                        + \") has no entityClass (\" + entityClass\n+                        + \") configured and because there are multiple in the entityClassSet (\"\n+                        + getEntityClassSet()\n+                        + \"), it cannot be deduced automatically.\");\n+            }\n+            entityDescriptor = entityDescriptors.iterator().next();\n+        }\n+        return entityDescriptor;\n+    }\n+", "originalCommit": "afa736f7b64a74298234b324ed8e35314870105a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQwMjIwNw==", "url": "https://github.com/kiegroup/optaplanner/pull/882#discussion_r471402207", "bodyText": "Regarding the last three comments - I agree, my plan was to look into it in the next PR, which focuses on the remaining part of the config code - including config of ValueSelector and EntitySelector. For this PR, I just moved these existing methods to - in my opinion - a more suitable place without changing their internals.\nI should have clearly stated my intentions before opening the PR for review.", "author": "rsynek", "createdAt": "2020-08-17T10:59:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM4ODM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM5ODIxMQ==", "url": "https://github.com/kiegroup/optaplanner/pull/882#discussion_r471398211", "bodyText": "Is this what the code formatter does? Pretty sure it fits on one 120-char line.", "author": "triceo", "createdAt": "2020-08-17T10:50:36Z", "path": "optaplanner-core/src/test/java/org/optaplanner/core/impl/heuristic/selector/move/MoveSelectorFactoryTest.java", "diffHunk": "@@ -0,0 +1,302 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.heuristic.selector.move;\n+\n+import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatIllegalArgumentException;\n+\n+import java.util.Comparator;\n+\n+import org.junit.jupiter.api.Test;\n+import org.optaplanner.core.api.score.director.ScoreDirector;\n+import org.optaplanner.core.config.heuristic.selector.AbstractSelectorConfigTest;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionCacheType;\n+import org.optaplanner.core.config.heuristic.selector.common.SelectionOrder;\n+import org.optaplanner.core.config.heuristic.selector.common.decorator.SelectionSorterOrder;\n+import org.optaplanner.core.config.heuristic.selector.move.MoveSelectorConfig;\n+import org.optaplanner.core.impl.heuristic.HeuristicConfigPolicy;\n+import org.optaplanner.core.impl.heuristic.move.DummyMove;\n+import org.optaplanner.core.impl.heuristic.selector.SelectorTestUtils;\n+import org.optaplanner.core.impl.heuristic.selector.common.decorator.SelectionProbabilityWeightFactory;\n+import org.optaplanner.core.impl.heuristic.selector.move.decorator.CachingMoveSelector;\n+import org.optaplanner.core.impl.heuristic.selector.move.decorator.ProbabilityMoveSelector;\n+import org.optaplanner.core.impl.heuristic.selector.move.decorator.ShufflingMoveSelector;\n+import org.optaplanner.core.impl.heuristic.selector.move.decorator.SortingMoveSelector;\n+import org.optaplanner.core.impl.testdata.domain.TestdataSolution;\n+\n+class MoveSelectorFactoryTest extends AbstractSelectorConfigTest {\n+\n+    @Test\n+    void phaseOriginal() {\n+        final MoveSelector baseMoveSelector = SelectorTestUtils.mockMoveSelector(DummyMove.class);\n+        DummyMoveSelectorConfig moveSelectorConfig = new DummyMoveSelectorConfig();\n+        moveSelectorConfig.setCacheType(SelectionCacheType.PHASE);\n+        moveSelectorConfig.setSelectionOrder(SelectionOrder.ORIGINAL);\n+        MoveSelectorFactory moveSelectorFactory =\n+                new AssertingMoveSelectorFactory(moveSelectorConfig, baseMoveSelector, SelectionCacheType.PHASE, false);\n+        MoveSelector moveSelector = moveSelectorFactory.buildMoveSelector(\n+                buildHeuristicConfigPolicy(),\n+                SelectionCacheType.JUST_IN_TIME, SelectionOrder.RANDOM);\n+        assertThat(moveSelector)\n+                .isInstanceOf(CachingMoveSelector.class)\n+                .isNotInstanceOf(ShufflingMoveSelector.class);\n+        assertThat(moveSelector.getCacheType()).isEqualTo(SelectionCacheType.PHASE);\n+        assertThat(((CachingMoveSelector) moveSelector).getChildMoveSelector()).isSameAs(baseMoveSelector);\n+    }\n+\n+    @Test\n+    void stepOriginal() {\n+        final MoveSelector baseMoveSelector = SelectorTestUtils.mockMoveSelector(DummyMove.class);\n+        DummyMoveSelectorConfig moveSelectorConfig = new DummyMoveSelectorConfig();\n+        moveSelectorConfig.setCacheType(SelectionCacheType.STEP);\n+        moveSelectorConfig.setSelectionOrder(SelectionOrder.ORIGINAL);\n+        MoveSelectorFactory moveSelectorFactory =\n+                new AssertingMoveSelectorFactory(moveSelectorConfig, baseMoveSelector, SelectionCacheType.STEP, false);\n+        MoveSelector moveSelector = moveSelectorFactory.buildMoveSelector(\n+                buildHeuristicConfigPolicy(),\n+                SelectionCacheType.JUST_IN_TIME, SelectionOrder.RANDOM);\n+        assertThat(moveSelector)\n+                .isInstanceOf(CachingMoveSelector.class)\n+                .isNotInstanceOf(ShufflingMoveSelector.class);\n+        assertThat(moveSelector.getCacheType()).isEqualTo(SelectionCacheType.STEP);\n+        assertThat(((CachingMoveSelector) moveSelector).getChildMoveSelector()).isSameAs(baseMoveSelector);\n+    }\n+\n+    @Test\n+    void justInTimeOriginal() {\n+        final MoveSelector baseMoveSelector = SelectorTestUtils.mockMoveSelector(DummyMove.class);\n+        DummyMoveSelectorConfig moveSelectorConfig = new DummyMoveSelectorConfig();\n+        MoveSelectorFactory moveSelectorFactory =\n+                new AssertingMoveSelectorFactory(moveSelectorConfig, baseMoveSelector, SelectionCacheType.JUST_IN_TIME, false);\n+        moveSelectorConfig.setCacheType(SelectionCacheType.JUST_IN_TIME);\n+        moveSelectorConfig.setSelectionOrder(SelectionOrder.ORIGINAL);\n+        MoveSelector moveSelector = moveSelectorFactory.buildMoveSelector(\n+                buildHeuristicConfigPolicy(),\n+                SelectionCacheType.JUST_IN_TIME, SelectionOrder.RANDOM);\n+        assertThat(moveSelector).isSameAs(baseMoveSelector);\n+        assertThat(moveSelector.getCacheType()).isEqualTo(SelectionCacheType.JUST_IN_TIME);\n+    }\n+\n+    @Test\n+    void phaseRandom() {\n+        final MoveSelector baseMoveSelector = SelectorTestUtils.mockMoveSelector(DummyMove.class);\n+        DummyMoveSelectorConfig moveSelectorConfig = new DummyMoveSelectorConfig();\n+        MoveSelectorFactory moveSelectorFactory =\n+                new AssertingMoveSelectorFactory(moveSelectorConfig, baseMoveSelector, SelectionCacheType.PHASE, false);\n+        moveSelectorConfig.setCacheType(SelectionCacheType.PHASE);\n+        moveSelectorConfig.setSelectionOrder(SelectionOrder.RANDOM);\n+        MoveSelector moveSelector = moveSelectorFactory.buildMoveSelector(\n+                buildHeuristicConfigPolicy(),\n+                SelectionCacheType.JUST_IN_TIME, SelectionOrder.RANDOM);\n+        assertThat(moveSelector)\n+                .isInstanceOf(CachingMoveSelector.class)\n+                .isNotInstanceOf(ShufflingMoveSelector.class);\n+        assertThat(moveSelector.getCacheType()).isEqualTo(SelectionCacheType.PHASE);\n+        assertThat(((CachingMoveSelector) moveSelector).getChildMoveSelector()).isSameAs(baseMoveSelector);\n+    }\n+\n+    @Test\n+    void stepRandom() {\n+        final MoveSelector baseMoveSelector = SelectorTestUtils.mockMoveSelector(DummyMove.class);\n+        DummyMoveSelectorConfig moveSelectorConfig = new DummyMoveSelectorConfig();\n+        MoveSelectorFactory moveSelectorFactory =\n+                new AssertingMoveSelectorFactory(moveSelectorConfig, baseMoveSelector, SelectionCacheType.STEP, false);\n+        moveSelectorConfig.setCacheType(SelectionCacheType.STEP);\n+        moveSelectorConfig.setSelectionOrder(SelectionOrder.RANDOM);\n+        MoveSelector moveSelector = moveSelectorFactory.buildMoveSelector(\n+                buildHeuristicConfigPolicy(),", "originalCommit": "afa736f7b64a74298234b324ed8e35314870105a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTQwNDcxMw==", "url": "https://github.com/kiegroup/optaplanner/pull/882#discussion_r471404713", "bodyText": "No, the formatter is not guilty; there must have been a new line already and the formatter didn't touch it, precisely as we wanted. Some of the test methods were moved from a different test class.\nGood catch, thanks!", "author": "rsynek", "createdAt": "2020-08-17T11:05:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MTM5ODIxMQ=="}], "type": "inlineReview"}, {"oid": "0ae37830016d33b223e63104652f31d77bf6a407", "url": "https://github.com/kiegroup/optaplanner/commit/0ae37830016d33b223e63104652f31d77bf6a407", "message": "Reformat the MoveSelectorFactoryTest", "committedDate": "2020-08-17T11:08:32Z", "type": "commit"}]}