{"pr_number": 902, "pr_title": "PLANNER-2093 Schema Definition for SolverConfig and BenchmarkConfig", "pr_createdAt": "2020-08-26T10:25:45Z", "pr_url": "https://github.com/kiegroup/optaplanner/pull/902", "timeline": [{"oid": "07110014a685b4c7699387e025faccd110949ef0", "url": "https://github.com/kiegroup/optaplanner/commit/07110014a685b4c7699387e025faccd110949ef0", "message": "PLANNER-2025 Provide XSD for SolverConfig", "committedDate": "2020-08-24T14:44:36Z", "type": "commit"}, {"oid": "d6cded8002459bd4e01d1461a36bf4969bbd59e4", "url": "https://github.com/kiegroup/optaplanner/commit/d6cded8002459bd4e01d1461a36bf4969bbd59e4", "message": "Remove @SuppressWarning(\"unchecked\")", "committedDate": "2020-08-24T14:44:36Z", "type": "commit"}, {"oid": "0640c8a9394dc4d4220ceb529493fc02feae87f0", "url": "https://github.com/kiegroup/optaplanner/commit/0640c8a9394dc4d4220ceb529493fc02feae87f0", "message": "Use return value of requireNonNull()", "committedDate": "2020-08-24T14:44:36Z", "type": "commit"}, {"oid": "2b47e73cc5ce988063259289d88709bba4d17925", "url": "https://github.com/kiegroup/optaplanner/commit/2b47e73cc5ce988063259289d88709bba4d17925", "message": "Resolve conflicts after rebase to master", "committedDate": "2020-08-25T09:26:31Z", "type": "commit"}, {"oid": "05ee684d7c9f52e7dd69fd36fa9d98b4523f817f", "url": "https://github.com/kiegroup/optaplanner/commit/05ee684d7c9f52e7dd69fd36fa9d98b4523f817f", "message": "PLANNER-2093 Provide XSD for BenchmarkConfig", "committedDate": "2020-08-25T13:37:22Z", "type": "commit"}, {"oid": "9729c7101284a69604836ded4f7181a00c63dae3", "url": "https://github.com/kiegroup/optaplanner/commit/9729c7101284a69604836ded4f7181a00c63dae3", "message": "Generate XSD for BenchmarkConfig", "committedDate": "2020-08-25T17:59:56Z", "type": "commit"}, {"oid": "9bc25020a35acc4f624fee38fe7cd5e110e4d7ed", "url": "https://github.com/kiegroup/optaplanner/commit/9bc25020a35acc4f624fee38fe7cd5e110e4d7ed", "message": "Define explicit element order", "committedDate": "2020-08-26T09:20:29Z", "type": "commit"}, {"oid": "1ea6f809b6a37d15539d850751cff6cf6c1a28f8", "url": "https://github.com/kiegroup/optaplanner/commit/1ea6f809b6a37d15539d850751cff6cf6c1a28f8", "message": "Rework the IO classes", "committedDate": "2020-08-26T09:27:05Z", "type": "commit"}, {"oid": "5febe2a653bbc419b8097d28ebaada4abac4701b", "url": "https://github.com/kiegroup/optaplanner/commit/5febe2a653bbc419b8097d28ebaada4abac4701b", "message": "Fix incorrect comment", "committedDate": "2020-08-26T10:28:19Z", "type": "commit"}, {"oid": "2e24d05d4d509b2a0eec1d66053d93df660879ef", "url": "https://github.com/kiegroup/optaplanner/commit/2e24d05d4d509b2a0eec1d66053d93df660879ef", "message": "Add missing Locale adapter", "committedDate": "2020-08-26T12:15:41Z", "type": "commit"}, {"oid": "829914df7618e2fcf50eea59b0024eb20a74b2cf", "url": "https://github.com/kiegroup/optaplanner/commit/829914df7618e2fcf50eea59b0024eb20a74b2cf", "message": "Make naming of JAXB adapters consistent", "committedDate": "2020-08-26T12:19:44Z", "type": "commit"}, {"oid": "533fba3dd24a2e4c872e6a8780ca9ed740f4ed80", "url": "https://github.com/kiegroup/optaplanner/commit/533fba3dd24a2e4c872e6a8780ca9ed740f4ed80", "message": "Move JAXB adapters to a subpackage", "committedDate": "2020-08-26T12:29:31Z", "type": "commit"}, {"oid": "865139133529354fcd086b6376470417a27d715f", "url": "https://github.com/kiegroup/optaplanner/commit/865139133529354fcd086b6376470417a27d715f", "message": "Simplify comparison of xml content in tests", "committedDate": "2020-08-26T12:34:21Z", "type": "commit"}, {"oid": "59d6ac7d627fb5955056e737a6acba629d2984bc", "url": "https://github.com/kiegroup/optaplanner/commit/59d6ac7d627fb5955056e737a6acba629d2984bc", "message": "Fix a typo", "committedDate": "2020-08-26T12:43:40Z", "type": "commit"}, {"oid": "69eea1d55a5db4cb1123b6242a368a374e01d142", "url": "https://github.com/kiegroup/optaplanner/commit/69eea1d55a5db4cb1123b6242a368a374e01d142", "message": "Remove unnecessary element override", "committedDate": "2020-08-26T12:48:48Z", "type": "commit"}, {"oid": "59891d9f105a5c630b8c1c5faeb1eba53457e56e", "url": "https://github.com/kiegroup/optaplanner/commit/59891d9f105a5c630b8c1c5faeb1eba53457e56e", "message": "Remove incorrect comment", "committedDate": "2020-08-26T12:59:27Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzI4ODgzMg==", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r477288832", "bodyText": "As we agreed, we don't validate the input solver config XML. We use the validation just in tests to make sure the solver config XML is valid by the generated XSD.", "author": "rsynek", "createdAt": "2020-08-26T13:12:45Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/io/jaxb/GenericJaxbIO.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.io.jaxb;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.UnmarshallerHandler;\n+import javax.xml.bind.ValidationEvent;\n+import javax.xml.bind.util.ValidationEventCollector;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.transform.stream.StreamSource;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+\n+import org.optaplanner.core.impl.io.OptaPlannerXmlSerializationException;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.XMLFilter;\n+import org.xml.sax.XMLReader;\n+import org.xml.sax.helpers.XMLFilterImpl;\n+\n+public final class GenericJaxbIO<T> implements JaxbIO<T> {\n+    private static final int DEFAULT_INDENTATION = 2;\n+\n+    private static final String ERR_MSG_WRITE = \"Unable to write the %s to XML.\";\n+    private static final String ERR_MSG_READ = \"Unable to read the (%s) from XML.\";\n+\n+    private final JAXBContext jaxbContext;\n+    private final Marshaller marshaller;\n+    private final Class<T> rootClass;\n+    private final int indentation;\n+\n+    public GenericJaxbIO(Class<T> rootClass) {\n+        this(rootClass, DEFAULT_INDENTATION);\n+    }\n+\n+    public GenericJaxbIO(Class<T> rootClass, int indentation) {\n+        Objects.requireNonNull(rootClass);\n+        this.rootClass = rootClass;\n+        this.indentation = indentation;\n+        try {\n+            jaxbContext = JAXBContext.newInstance(rootClass);\n+            marshaller = jaxbContext.createMarshaller();\n+            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            marshaller.setProperty(Marshaller.JAXB_ENCODING, StandardCharsets.UTF_8.toString());\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to create JAXB Marshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    @Override\n+    public T read(Reader reader) {\n+        Objects.requireNonNull(reader);\n+        try {\n+            return (T) createUnmarshaller().unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    public T readAndValidate(Reader reader, String schemaResource) {", "originalCommit": "865139133529354fcd086b6376470417a27d715f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "83be25dec1cb097837f99797cf198a63fc1dd22a", "url": "https://github.com/kiegroup/optaplanner/commit/83be25dec1cb097837f99797cf198a63fc1dd22a", "message": "Improve javadoc comment", "committedDate": "2020-08-26T13:13:37Z", "type": "commit"}, {"oid": "d1627e2b4475ff47fcbc72eb97da9bec060e65ca", "url": "https://github.com/kiegroup/optaplanner/commit/d1627e2b4475ff47fcbc72eb97da9bec060e65ca", "message": "Make a nested class final", "committedDate": "2020-08-26T13:15:56Z", "type": "commit"}, {"oid": "3b9fec6b4c18d7fb38b9dd9c09a8517eb7238875", "url": "https://github.com/kiegroup/optaplanner/commit/3b9fec6b4c18d7fb38b9dd9c09a8517eb7238875", "message": "Move adapter tests", "committedDate": "2020-08-26T13:21:36Z", "type": "commit"}, {"oid": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596", "url": "https://github.com/kiegroup/optaplanner/commit/1d0bed8beead1d5dbf6e20bd8eb5556f77321596", "message": "Update revapi config", "committedDate": "2020-08-26T13:23:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI5NDYwNw==", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478294607", "bodyText": "soft: I think putting error messages in a constant - if it's only used once - is a form of unneeded indirection, making the code harder to read (code is read 10 times more than it it written) because it reduces \"vertical density\" (that which belongs together is together).\nIn this case, the ERR_MSG_READ is used more than once, but that's often a sign that multiple different error causes are being reported as the same error, providing less information to the user. See examples below.", "author": "ge0ffrey", "createdAt": "2020-08-27T09:48:17Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/io/jaxb/GenericJaxbIO.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.io.jaxb;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.UnmarshallerHandler;\n+import javax.xml.bind.ValidationEvent;\n+import javax.xml.bind.util.ValidationEventCollector;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.transform.stream.StreamSource;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+\n+import org.optaplanner.core.impl.io.OptaPlannerXmlSerializationException;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.XMLFilter;\n+import org.xml.sax.XMLReader;\n+import org.xml.sax.helpers.XMLFilterImpl;\n+\n+public final class GenericJaxbIO<T> implements JaxbIO<T> {\n+    private static final int DEFAULT_INDENTATION = 2;\n+\n+    private static final String ERR_MSG_WRITE = \"Unable to write the %s to XML.\";\n+    private static final String ERR_MSG_READ = \"Unable to read the (%s) from XML.\";", "originalCommit": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI5ODczMA==", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478298730", "bodyText": "These error message formatting are not consistent with our normal formatting \"... parameterName (parameterValue) ...\"\nSo\n\"Unable to write the %s to XML.\"\n=> \"Unable to write rootClass (%s) to XML.\"", "author": "ge0ffrey", "createdAt": "2020-08-27T09:55:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI5NDYwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI5OTYwNQ==", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478299605", "bodyText": "A rootClass isn't written to XML, it's marshalled to XML.\nWe typically favor \"Failed to\" instead of \"Unable to\".\n=> \"Failed to marshall rootClass (%s) to XML.\"", "author": "ge0ffrey", "createdAt": "2020-08-27T09:56:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI5NDYwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM3MzEwNA==", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478373104", "bodyText": "Only messages that repeat are defined as constants. However, I changed the message in a couple of places to make it more specific.\nThanks.", "author": "rsynek", "createdAt": "2020-08-27T12:15:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI5NDYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI5NTgzNw==", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478295837", "bodyText": "DRY with the first few lines of write(T root, Writer writer).", "author": "ge0ffrey", "createdAt": "2020-08-27T09:50:28Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/io/jaxb/GenericJaxbIO.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.io.jaxb;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.UnmarshallerHandler;\n+import javax.xml.bind.ValidationEvent;\n+import javax.xml.bind.util.ValidationEventCollector;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.transform.stream.StreamSource;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+\n+import org.optaplanner.core.impl.io.OptaPlannerXmlSerializationException;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.XMLFilter;\n+import org.xml.sax.XMLReader;\n+import org.xml.sax.helpers.XMLFilterImpl;\n+\n+public final class GenericJaxbIO<T> implements JaxbIO<T> {\n+    private static final int DEFAULT_INDENTATION = 2;\n+\n+    private static final String ERR_MSG_WRITE = \"Unable to write the %s to XML.\";\n+    private static final String ERR_MSG_READ = \"Unable to read the (%s) from XML.\";\n+\n+    private final JAXBContext jaxbContext;\n+    private final Marshaller marshaller;\n+    private final Class<T> rootClass;\n+    private final int indentation;\n+\n+    public GenericJaxbIO(Class<T> rootClass) {\n+        this(rootClass, DEFAULT_INDENTATION);\n+    }\n+\n+    public GenericJaxbIO(Class<T> rootClass, int indentation) {\n+        Objects.requireNonNull(rootClass);\n+        this.rootClass = rootClass;\n+        this.indentation = indentation;\n+        try {\n+            jaxbContext = JAXBContext.newInstance(rootClass);\n+            marshaller = jaxbContext.createMarshaller();\n+            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            marshaller.setProperty(Marshaller.JAXB_ENCODING, StandardCharsets.UTF_8.toString());\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to create JAXB Marshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    @Override\n+    public T read(Reader reader) {\n+        Objects.requireNonNull(reader);\n+        try {\n+            return (T) createUnmarshaller().unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    public T readAndValidate(Reader reader, String schemaResource) {\n+        Objects.requireNonNull(reader);\n+        String nonNullSchemaResource = Objects.requireNonNull(schemaResource);\n+        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n+        Schema schema;\n+        try {\n+            schema = schemaFactory.newSchema(GenericJaxbIO.class.getResource(nonNullSchemaResource));\n+        } catch (SAXException e) {\n+            throw new IllegalArgumentException(\"Unable to read input schema resource (\" + nonNullSchemaResource + \")\", e);\n+        }\n+\n+        Unmarshaller unmarshaller = createUnmarshaller();\n+        unmarshaller.setSchema(schema);\n+        ValidationEventStringCollector validationEventHandler = new ValidationEventStringCollector();\n+\n+        try {\n+            unmarshaller.setEventHandler(validationEventHandler);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to set validation event handler to the unmarshaller for \"\n+                    + \"a root element class (%s).\", rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        try {\n+            return (T) unmarshaller.unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            if (validationEventHandler.hasEvents()) {\n+                String errMessageWithValidationEvents = errMessage + \"\\n\" + validationEventHandler.reportAll();\n+                throw new OptaPlannerXmlSerializationException(errMessageWithValidationEvents, jaxbException);\n+            } else {\n+                throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+            }\n+        }\n+    }\n+\n+    private Unmarshaller createUnmarshaller() {\n+        try {\n+            return jaxbContext.createUnmarshaller();\n+        } catch (JAXBException e) {\n+            String errMessage = String.format(\"Unable to create JAXB unmarshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Reads the input XML using the {@link Reader} overriding elements namespaces. If an element already has a namespace and\n+     * a {@link ElementNamespaceOverride} is defined for this element, its namespace is overridden. In case the element has no\n+     * namespace, new namespace defined in the {@link ElementNamespaceOverride} is added.\n+     * \n+     * @param reader input XML {@link Reader}; never null\n+     * @param elementNamespaceOverrides never null\n+     * @return deserialized object representation of the XML.\n+     */\n+    public T readOverridingNamespace(Reader reader, ElementNamespaceOverride... elementNamespaceOverrides) {\n+        Objects.requireNonNull(reader);\n+        Objects.requireNonNull(elementNamespaceOverrides);\n+\n+        final String errMessage = String.format(\"Unable to read the (%s) from XML with overriding elements' namespaces: %s.\",\n+                rootClass.getName(), Arrays.toString(elementNamespaceOverrides));\n+\n+        // Create a SAXParser to use its XMLReader on the XMLFilter\n+        SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n+        SAXParser saxParser;\n+        try {\n+            // Protect the parser against the XXE attack\n+            // https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A4-XML_External_Entities_(XXE)\n+            saxParserFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+            saxParser = saxParserFactory.newSAXParser();\n+        } catch (ParserConfigurationException | SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+        XMLReader xmlReader;\n+        try {\n+            xmlReader = saxParser.getXMLReader();\n+        } catch (SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+\n+        XMLFilter namespaceOverridingXmlFilter = new NamespaceOverridingXmlFilter(xmlReader, elementNamespaceOverrides);\n+        namespaceOverridingXmlFilter.setParent(xmlReader);\n+\n+        // Use UnmarshallerHandler as a content handler for the XML filter.\n+        Unmarshaller unmarshaller = createUnmarshaller();\n+        UnmarshallerHandler unmarshallerHandler = unmarshaller.getUnmarshallerHandler();\n+        namespaceOverridingXmlFilter.setContentHandler(unmarshallerHandler);\n+\n+        InputSource xmlInputSource = new InputSource(reader);\n+        try {\n+            // Parse the XML to feed its content into the UnmarshallerHandler.\n+            namespaceOverridingXmlFilter.parse(xmlInputSource);\n+        } catch (IOException | SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+\n+        try {\n+            return (T) unmarshallerHandler.getResult();\n+        } catch (JAXBException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    @Override\n+    public void write(T root, Writer writer) {\n+        Objects.requireNonNull(root);\n+        Objects.requireNonNull(writer);\n+        DOMResult domResult = new DOMResult();\n+        try {\n+            marshaller.marshal(root, domResult);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_WRITE, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        formatXml(new DOMSource(domResult.getNode()), null, writer);\n+    }\n+\n+    public void writeWithoutNamespaces(T root, Writer writer) {\n+        Objects.requireNonNull(root);\n+        Objects.requireNonNull(writer);\n+        DOMResult domResult = new DOMResult();\n+        final String errMessage = String.format(ERR_MSG_WRITE, rootClass.getName());\n+        try {\n+            marshaller.marshal(root, domResult);\n+        } catch (JAXBException jaxbException) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }", "originalCommit": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI5NzA5MQ==", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478297091", "bodyText": "The errorMessage String should only be created if it actually fails, so inside the catch", "author": "ge0ffrey", "createdAt": "2020-08-27T09:52:39Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/io/jaxb/GenericJaxbIO.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.io.jaxb;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.UnmarshallerHandler;\n+import javax.xml.bind.ValidationEvent;\n+import javax.xml.bind.util.ValidationEventCollector;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.transform.stream.StreamSource;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+\n+import org.optaplanner.core.impl.io.OptaPlannerXmlSerializationException;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.XMLFilter;\n+import org.xml.sax.XMLReader;\n+import org.xml.sax.helpers.XMLFilterImpl;\n+\n+public final class GenericJaxbIO<T> implements JaxbIO<T> {\n+    private static final int DEFAULT_INDENTATION = 2;\n+\n+    private static final String ERR_MSG_WRITE = \"Unable to write the %s to XML.\";\n+    private static final String ERR_MSG_READ = \"Unable to read the (%s) from XML.\";\n+\n+    private final JAXBContext jaxbContext;\n+    private final Marshaller marshaller;\n+    private final Class<T> rootClass;\n+    private final int indentation;\n+\n+    public GenericJaxbIO(Class<T> rootClass) {\n+        this(rootClass, DEFAULT_INDENTATION);\n+    }\n+\n+    public GenericJaxbIO(Class<T> rootClass, int indentation) {\n+        Objects.requireNonNull(rootClass);\n+        this.rootClass = rootClass;\n+        this.indentation = indentation;\n+        try {\n+            jaxbContext = JAXBContext.newInstance(rootClass);\n+            marshaller = jaxbContext.createMarshaller();\n+            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            marshaller.setProperty(Marshaller.JAXB_ENCODING, StandardCharsets.UTF_8.toString());\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to create JAXB Marshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    @Override\n+    public T read(Reader reader) {\n+        Objects.requireNonNull(reader);\n+        try {\n+            return (T) createUnmarshaller().unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    public T readAndValidate(Reader reader, String schemaResource) {\n+        Objects.requireNonNull(reader);\n+        String nonNullSchemaResource = Objects.requireNonNull(schemaResource);\n+        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n+        Schema schema;\n+        try {\n+            schema = schemaFactory.newSchema(GenericJaxbIO.class.getResource(nonNullSchemaResource));\n+        } catch (SAXException e) {\n+            throw new IllegalArgumentException(\"Unable to read input schema resource (\" + nonNullSchemaResource + \")\", e);\n+        }\n+\n+        Unmarshaller unmarshaller = createUnmarshaller();\n+        unmarshaller.setSchema(schema);\n+        ValidationEventStringCollector validationEventHandler = new ValidationEventStringCollector();\n+\n+        try {\n+            unmarshaller.setEventHandler(validationEventHandler);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to set validation event handler to the unmarshaller for \"\n+                    + \"a root element class (%s).\", rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        try {\n+            return (T) unmarshaller.unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            if (validationEventHandler.hasEvents()) {\n+                String errMessageWithValidationEvents = errMessage + \"\\n\" + validationEventHandler.reportAll();\n+                throw new OptaPlannerXmlSerializationException(errMessageWithValidationEvents, jaxbException);\n+            } else {\n+                throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+            }\n+        }\n+    }\n+\n+    private Unmarshaller createUnmarshaller() {\n+        try {\n+            return jaxbContext.createUnmarshaller();\n+        } catch (JAXBException e) {\n+            String errMessage = String.format(\"Unable to create JAXB unmarshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Reads the input XML using the {@link Reader} overriding elements namespaces. If an element already has a namespace and\n+     * a {@link ElementNamespaceOverride} is defined for this element, its namespace is overridden. In case the element has no\n+     * namespace, new namespace defined in the {@link ElementNamespaceOverride} is added.\n+     * \n+     * @param reader input XML {@link Reader}; never null\n+     * @param elementNamespaceOverrides never null\n+     * @return deserialized object representation of the XML.\n+     */\n+    public T readOverridingNamespace(Reader reader, ElementNamespaceOverride... elementNamespaceOverrides) {\n+        Objects.requireNonNull(reader);\n+        Objects.requireNonNull(elementNamespaceOverrides);\n+\n+        final String errMessage = String.format(\"Unable to read the (%s) from XML with overriding elements' namespaces: %s.\",\n+                rootClass.getName(), Arrays.toString(elementNamespaceOverrides));\n+\n+        // Create a SAXParser to use its XMLReader on the XMLFilter\n+        SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n+        SAXParser saxParser;\n+        try {\n+            // Protect the parser against the XXE attack\n+            // https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A4-XML_External_Entities_(XXE)\n+            saxParserFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+            saxParser = saxParserFactory.newSAXParser();\n+        } catch (ParserConfigurationException | SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+        XMLReader xmlReader;\n+        try {\n+            xmlReader = saxParser.getXMLReader();\n+        } catch (SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+\n+        XMLFilter namespaceOverridingXmlFilter = new NamespaceOverridingXmlFilter(xmlReader, elementNamespaceOverrides);\n+        namespaceOverridingXmlFilter.setParent(xmlReader);\n+\n+        // Use UnmarshallerHandler as a content handler for the XML filter.\n+        Unmarshaller unmarshaller = createUnmarshaller();\n+        UnmarshallerHandler unmarshallerHandler = unmarshaller.getUnmarshallerHandler();\n+        namespaceOverridingXmlFilter.setContentHandler(unmarshallerHandler);\n+\n+        InputSource xmlInputSource = new InputSource(reader);\n+        try {\n+            // Parse the XML to feed its content into the UnmarshallerHandler.\n+            namespaceOverridingXmlFilter.parse(xmlInputSource);\n+        } catch (IOException | SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+\n+        try {\n+            return (T) unmarshallerHandler.getResult();\n+        } catch (JAXBException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    @Override\n+    public void write(T root, Writer writer) {\n+        Objects.requireNonNull(root);\n+        Objects.requireNonNull(writer);\n+        DOMResult domResult = new DOMResult();\n+        try {\n+            marshaller.marshal(root, domResult);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_WRITE, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        formatXml(new DOMSource(domResult.getNode()), null, writer);\n+    }\n+\n+    public void writeWithoutNamespaces(T root, Writer writer) {\n+        Objects.requireNonNull(root);\n+        Objects.requireNonNull(writer);\n+        DOMResult domResult = new DOMResult();\n+        final String errMessage = String.format(ERR_MSG_WRITE, rootClass.getName());", "originalCommit": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMwMDYxNg==", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478300616", "bodyText": "Here, it didn't fail to marshall the rootClass to XML, so the error message should be different.\n=> \"Failed to format XML for rootClass(...).\" maybe?", "author": "ge0ffrey", "createdAt": "2020-08-27T09:58:45Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/io/jaxb/GenericJaxbIO.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.io.jaxb;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.UnmarshallerHandler;\n+import javax.xml.bind.ValidationEvent;\n+import javax.xml.bind.util.ValidationEventCollector;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.transform.stream.StreamSource;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+\n+import org.optaplanner.core.impl.io.OptaPlannerXmlSerializationException;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.XMLFilter;\n+import org.xml.sax.XMLReader;\n+import org.xml.sax.helpers.XMLFilterImpl;\n+\n+public final class GenericJaxbIO<T> implements JaxbIO<T> {\n+    private static final int DEFAULT_INDENTATION = 2;\n+\n+    private static final String ERR_MSG_WRITE = \"Unable to write the %s to XML.\";\n+    private static final String ERR_MSG_READ = \"Unable to read the (%s) from XML.\";\n+\n+    private final JAXBContext jaxbContext;\n+    private final Marshaller marshaller;\n+    private final Class<T> rootClass;\n+    private final int indentation;\n+\n+    public GenericJaxbIO(Class<T> rootClass) {\n+        this(rootClass, DEFAULT_INDENTATION);\n+    }\n+\n+    public GenericJaxbIO(Class<T> rootClass, int indentation) {\n+        Objects.requireNonNull(rootClass);\n+        this.rootClass = rootClass;\n+        this.indentation = indentation;\n+        try {\n+            jaxbContext = JAXBContext.newInstance(rootClass);\n+            marshaller = jaxbContext.createMarshaller();\n+            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            marshaller.setProperty(Marshaller.JAXB_ENCODING, StandardCharsets.UTF_8.toString());\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to create JAXB Marshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    @Override\n+    public T read(Reader reader) {\n+        Objects.requireNonNull(reader);\n+        try {\n+            return (T) createUnmarshaller().unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    public T readAndValidate(Reader reader, String schemaResource) {\n+        Objects.requireNonNull(reader);\n+        String nonNullSchemaResource = Objects.requireNonNull(schemaResource);\n+        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n+        Schema schema;\n+        try {\n+            schema = schemaFactory.newSchema(GenericJaxbIO.class.getResource(nonNullSchemaResource));\n+        } catch (SAXException e) {\n+            throw new IllegalArgumentException(\"Unable to read input schema resource (\" + nonNullSchemaResource + \")\", e);\n+        }\n+\n+        Unmarshaller unmarshaller = createUnmarshaller();\n+        unmarshaller.setSchema(schema);\n+        ValidationEventStringCollector validationEventHandler = new ValidationEventStringCollector();\n+\n+        try {\n+            unmarshaller.setEventHandler(validationEventHandler);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to set validation event handler to the unmarshaller for \"\n+                    + \"a root element class (%s).\", rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        try {\n+            return (T) unmarshaller.unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            if (validationEventHandler.hasEvents()) {\n+                String errMessageWithValidationEvents = errMessage + \"\\n\" + validationEventHandler.reportAll();\n+                throw new OptaPlannerXmlSerializationException(errMessageWithValidationEvents, jaxbException);\n+            } else {\n+                throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+            }\n+        }\n+    }\n+\n+    private Unmarshaller createUnmarshaller() {\n+        try {\n+            return jaxbContext.createUnmarshaller();\n+        } catch (JAXBException e) {\n+            String errMessage = String.format(\"Unable to create JAXB unmarshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Reads the input XML using the {@link Reader} overriding elements namespaces. If an element already has a namespace and\n+     * a {@link ElementNamespaceOverride} is defined for this element, its namespace is overridden. In case the element has no\n+     * namespace, new namespace defined in the {@link ElementNamespaceOverride} is added.\n+     * \n+     * @param reader input XML {@link Reader}; never null\n+     * @param elementNamespaceOverrides never null\n+     * @return deserialized object representation of the XML.\n+     */\n+    public T readOverridingNamespace(Reader reader, ElementNamespaceOverride... elementNamespaceOverrides) {\n+        Objects.requireNonNull(reader);\n+        Objects.requireNonNull(elementNamespaceOverrides);\n+\n+        final String errMessage = String.format(\"Unable to read the (%s) from XML with overriding elements' namespaces: %s.\",\n+                rootClass.getName(), Arrays.toString(elementNamespaceOverrides));\n+\n+        // Create a SAXParser to use its XMLReader on the XMLFilter\n+        SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n+        SAXParser saxParser;\n+        try {\n+            // Protect the parser against the XXE attack\n+            // https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A4-XML_External_Entities_(XXE)\n+            saxParserFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+            saxParser = saxParserFactory.newSAXParser();\n+        } catch (ParserConfigurationException | SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+        XMLReader xmlReader;\n+        try {\n+            xmlReader = saxParser.getXMLReader();\n+        } catch (SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+\n+        XMLFilter namespaceOverridingXmlFilter = new NamespaceOverridingXmlFilter(xmlReader, elementNamespaceOverrides);\n+        namespaceOverridingXmlFilter.setParent(xmlReader);\n+\n+        // Use UnmarshallerHandler as a content handler for the XML filter.\n+        Unmarshaller unmarshaller = createUnmarshaller();\n+        UnmarshallerHandler unmarshallerHandler = unmarshaller.getUnmarshallerHandler();\n+        namespaceOverridingXmlFilter.setContentHandler(unmarshallerHandler);\n+\n+        InputSource xmlInputSource = new InputSource(reader);\n+        try {\n+            // Parse the XML to feed its content into the UnmarshallerHandler.\n+            namespaceOverridingXmlFilter.parse(xmlInputSource);\n+        } catch (IOException | SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+\n+        try {\n+            return (T) unmarshallerHandler.getResult();\n+        } catch (JAXBException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    @Override\n+    public void write(T root, Writer writer) {\n+        Objects.requireNonNull(root);\n+        Objects.requireNonNull(writer);\n+        DOMResult domResult = new DOMResult();\n+        try {\n+            marshaller.marshal(root, domResult);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_WRITE, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        formatXml(new DOMSource(domResult.getNode()), null, writer);\n+    }\n+\n+    public void writeWithoutNamespaces(T root, Writer writer) {\n+        Objects.requireNonNull(root);\n+        Objects.requireNonNull(writer);\n+        DOMResult domResult = new DOMResult();\n+        final String errMessage = String.format(ERR_MSG_WRITE, rootClass.getName());\n+        try {\n+            marshaller.marshal(root, domResult);\n+        } catch (JAXBException jaxbException) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        try (InputStream xsltInputStream = getClass().getResourceAsStream(\"removeNamespaces.xslt\")) {\n+            formatXml(new DOMSource(domResult.getNode()), new StreamSource(xsltInputStream), writer);\n+        } catch (IOException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    private void formatXml(Source source, Source transformationTemplate, Writer writer) {\n+        /*\n+         * The code is not vulnerable to XXE-based attacks as it does not process any external XML nor XSL input.\n+         * Should the transformerFactory be used for such purposes, it has to be appropriately secured:\n+         * https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A4-XML_External_Entities_(XXE)\n+         */\n+        @SuppressWarnings({ \"java:S2755\", \"java:S4435\" })\n+        TransformerFactory transformerFactory = TransformerFactory.newInstance();\n+        try {\n+            Transformer transformer = transformationTemplate == null ? transformerFactory.newTransformer()\n+                    : transformerFactory.newTransformer(transformationTemplate);\n+            // See https://stackoverflow.com/questions/46708498/jaxb-marshaller-indentation.\n+            transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n+            transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", String.valueOf(indentation));\n+            transformer.transform(source, new StreamResult(writer));\n+        } catch (TransformerException transformerException) {\n+            String errMessage = String.format(ERR_MSG_WRITE, rootClass.getName());", "originalCommit": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMwMjAxOQ==", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478302019", "bodyText": "Do we need to bring in an XSLT formatter to format the JAXB output?\nCan we not use this instead?\nmarshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);\nLess XSLT is always better ;-)", "author": "ge0ffrey", "createdAt": "2020-08-27T10:01:04Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/io/jaxb/GenericJaxbIO.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.io.jaxb;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.UnmarshallerHandler;\n+import javax.xml.bind.ValidationEvent;\n+import javax.xml.bind.util.ValidationEventCollector;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.transform.stream.StreamSource;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+\n+import org.optaplanner.core.impl.io.OptaPlannerXmlSerializationException;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.XMLFilter;\n+import org.xml.sax.XMLReader;\n+import org.xml.sax.helpers.XMLFilterImpl;\n+\n+public final class GenericJaxbIO<T> implements JaxbIO<T> {\n+    private static final int DEFAULT_INDENTATION = 2;\n+\n+    private static final String ERR_MSG_WRITE = \"Unable to write the %s to XML.\";\n+    private static final String ERR_MSG_READ = \"Unable to read the (%s) from XML.\";\n+\n+    private final JAXBContext jaxbContext;\n+    private final Marshaller marshaller;\n+    private final Class<T> rootClass;\n+    private final int indentation;\n+\n+    public GenericJaxbIO(Class<T> rootClass) {\n+        this(rootClass, DEFAULT_INDENTATION);\n+    }\n+\n+    public GenericJaxbIO(Class<T> rootClass, int indentation) {\n+        Objects.requireNonNull(rootClass);\n+        this.rootClass = rootClass;\n+        this.indentation = indentation;\n+        try {\n+            jaxbContext = JAXBContext.newInstance(rootClass);\n+            marshaller = jaxbContext.createMarshaller();\n+            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            marshaller.setProperty(Marshaller.JAXB_ENCODING, StandardCharsets.UTF_8.toString());\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to create JAXB Marshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    @Override\n+    public T read(Reader reader) {\n+        Objects.requireNonNull(reader);\n+        try {\n+            return (T) createUnmarshaller().unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    public T readAndValidate(Reader reader, String schemaResource) {\n+        Objects.requireNonNull(reader);\n+        String nonNullSchemaResource = Objects.requireNonNull(schemaResource);\n+        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n+        Schema schema;\n+        try {\n+            schema = schemaFactory.newSchema(GenericJaxbIO.class.getResource(nonNullSchemaResource));\n+        } catch (SAXException e) {\n+            throw new IllegalArgumentException(\"Unable to read input schema resource (\" + nonNullSchemaResource + \")\", e);\n+        }\n+\n+        Unmarshaller unmarshaller = createUnmarshaller();\n+        unmarshaller.setSchema(schema);\n+        ValidationEventStringCollector validationEventHandler = new ValidationEventStringCollector();\n+\n+        try {\n+            unmarshaller.setEventHandler(validationEventHandler);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to set validation event handler to the unmarshaller for \"\n+                    + \"a root element class (%s).\", rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        try {\n+            return (T) unmarshaller.unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            if (validationEventHandler.hasEvents()) {\n+                String errMessageWithValidationEvents = errMessage + \"\\n\" + validationEventHandler.reportAll();\n+                throw new OptaPlannerXmlSerializationException(errMessageWithValidationEvents, jaxbException);\n+            } else {\n+                throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+            }\n+        }\n+    }\n+\n+    private Unmarshaller createUnmarshaller() {\n+        try {\n+            return jaxbContext.createUnmarshaller();\n+        } catch (JAXBException e) {\n+            String errMessage = String.format(\"Unable to create JAXB unmarshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Reads the input XML using the {@link Reader} overriding elements namespaces. If an element already has a namespace and\n+     * a {@link ElementNamespaceOverride} is defined for this element, its namespace is overridden. In case the element has no\n+     * namespace, new namespace defined in the {@link ElementNamespaceOverride} is added.\n+     * \n+     * @param reader input XML {@link Reader}; never null\n+     * @param elementNamespaceOverrides never null\n+     * @return deserialized object representation of the XML.\n+     */\n+    public T readOverridingNamespace(Reader reader, ElementNamespaceOverride... elementNamespaceOverrides) {\n+        Objects.requireNonNull(reader);\n+        Objects.requireNonNull(elementNamespaceOverrides);\n+\n+        final String errMessage = String.format(\"Unable to read the (%s) from XML with overriding elements' namespaces: %s.\",\n+                rootClass.getName(), Arrays.toString(elementNamespaceOverrides));\n+\n+        // Create a SAXParser to use its XMLReader on the XMLFilter\n+        SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n+        SAXParser saxParser;\n+        try {\n+            // Protect the parser against the XXE attack\n+            // https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A4-XML_External_Entities_(XXE)\n+            saxParserFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+            saxParser = saxParserFactory.newSAXParser();\n+        } catch (ParserConfigurationException | SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+        XMLReader xmlReader;\n+        try {\n+            xmlReader = saxParser.getXMLReader();\n+        } catch (SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+\n+        XMLFilter namespaceOverridingXmlFilter = new NamespaceOverridingXmlFilter(xmlReader, elementNamespaceOverrides);\n+        namespaceOverridingXmlFilter.setParent(xmlReader);\n+\n+        // Use UnmarshallerHandler as a content handler for the XML filter.\n+        Unmarshaller unmarshaller = createUnmarshaller();\n+        UnmarshallerHandler unmarshallerHandler = unmarshaller.getUnmarshallerHandler();\n+        namespaceOverridingXmlFilter.setContentHandler(unmarshallerHandler);\n+\n+        InputSource xmlInputSource = new InputSource(reader);\n+        try {\n+            // Parse the XML to feed its content into the UnmarshallerHandler.\n+            namespaceOverridingXmlFilter.parse(xmlInputSource);\n+        } catch (IOException | SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+\n+        try {\n+            return (T) unmarshallerHandler.getResult();\n+        } catch (JAXBException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    @Override\n+    public void write(T root, Writer writer) {\n+        Objects.requireNonNull(root);\n+        Objects.requireNonNull(writer);\n+        DOMResult domResult = new DOMResult();\n+        try {\n+            marshaller.marshal(root, domResult);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_WRITE, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        formatXml(new DOMSource(domResult.getNode()), null, writer);\n+    }\n+\n+    public void writeWithoutNamespaces(T root, Writer writer) {\n+        Objects.requireNonNull(root);\n+        Objects.requireNonNull(writer);\n+        DOMResult domResult = new DOMResult();\n+        final String errMessage = String.format(ERR_MSG_WRITE, rootClass.getName());\n+        try {\n+            marshaller.marshal(root, domResult);\n+        } catch (JAXBException jaxbException) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        try (InputStream xsltInputStream = getClass().getResourceAsStream(\"removeNamespaces.xslt\")) {\n+            formatXml(new DOMSource(domResult.getNode()), new StreamSource(xsltInputStream), writer);\n+        } catch (IOException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    private void formatXml(Source source, Source transformationTemplate, Writer writer) {", "originalCommit": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMxMzQ1MA==", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478313450", "bodyText": "Unfortunately, the Marshaller.JAXB_FORMATTED_OUTPUT does always 4 spaces of indentation. We use the XSLT to make it 2 (or any other number, if needed).\nFor the \"backward compatibility mode\", when writing the elements, we remove their namespaces via an XSLT, so we need a transformation anyway.", "author": "rsynek", "createdAt": "2020-08-27T10:21:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMwMjAxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMwMzY1OA==", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478303658", "bodyText": "error style, always use braces to mention values at runtime.\n=> \"... rootClass (%s) ... namespaces (%s).\"", "author": "ge0ffrey", "createdAt": "2020-08-27T10:04:02Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/io/jaxb/GenericJaxbIO.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.io.jaxb;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.UnmarshallerHandler;\n+import javax.xml.bind.ValidationEvent;\n+import javax.xml.bind.util.ValidationEventCollector;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.transform.stream.StreamSource;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+\n+import org.optaplanner.core.impl.io.OptaPlannerXmlSerializationException;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.XMLFilter;\n+import org.xml.sax.XMLReader;\n+import org.xml.sax.helpers.XMLFilterImpl;\n+\n+public final class GenericJaxbIO<T> implements JaxbIO<T> {\n+    private static final int DEFAULT_INDENTATION = 2;\n+\n+    private static final String ERR_MSG_WRITE = \"Unable to write the %s to XML.\";\n+    private static final String ERR_MSG_READ = \"Unable to read the (%s) from XML.\";\n+\n+    private final JAXBContext jaxbContext;\n+    private final Marshaller marshaller;\n+    private final Class<T> rootClass;\n+    private final int indentation;\n+\n+    public GenericJaxbIO(Class<T> rootClass) {\n+        this(rootClass, DEFAULT_INDENTATION);\n+    }\n+\n+    public GenericJaxbIO(Class<T> rootClass, int indentation) {\n+        Objects.requireNonNull(rootClass);\n+        this.rootClass = rootClass;\n+        this.indentation = indentation;\n+        try {\n+            jaxbContext = JAXBContext.newInstance(rootClass);\n+            marshaller = jaxbContext.createMarshaller();\n+            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            marshaller.setProperty(Marshaller.JAXB_ENCODING, StandardCharsets.UTF_8.toString());\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to create JAXB Marshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    @Override\n+    public T read(Reader reader) {\n+        Objects.requireNonNull(reader);\n+        try {\n+            return (T) createUnmarshaller().unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    public T readAndValidate(Reader reader, String schemaResource) {\n+        Objects.requireNonNull(reader);\n+        String nonNullSchemaResource = Objects.requireNonNull(schemaResource);\n+        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n+        Schema schema;\n+        try {\n+            schema = schemaFactory.newSchema(GenericJaxbIO.class.getResource(nonNullSchemaResource));\n+        } catch (SAXException e) {\n+            throw new IllegalArgumentException(\"Unable to read input schema resource (\" + nonNullSchemaResource + \")\", e);\n+        }\n+\n+        Unmarshaller unmarshaller = createUnmarshaller();\n+        unmarshaller.setSchema(schema);\n+        ValidationEventStringCollector validationEventHandler = new ValidationEventStringCollector();\n+\n+        try {\n+            unmarshaller.setEventHandler(validationEventHandler);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to set validation event handler to the unmarshaller for \"\n+                    + \"a root element class (%s).\", rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        try {\n+            return (T) unmarshaller.unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            if (validationEventHandler.hasEvents()) {\n+                String errMessageWithValidationEvents = errMessage + \"\\n\" + validationEventHandler.reportAll();\n+                throw new OptaPlannerXmlSerializationException(errMessageWithValidationEvents, jaxbException);\n+            } else {\n+                throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+            }\n+        }\n+    }\n+\n+    private Unmarshaller createUnmarshaller() {\n+        try {\n+            return jaxbContext.createUnmarshaller();\n+        } catch (JAXBException e) {\n+            String errMessage = String.format(\"Unable to create JAXB unmarshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Reads the input XML using the {@link Reader} overriding elements namespaces. If an element already has a namespace and\n+     * a {@link ElementNamespaceOverride} is defined for this element, its namespace is overridden. In case the element has no\n+     * namespace, new namespace defined in the {@link ElementNamespaceOverride} is added.\n+     * \n+     * @param reader input XML {@link Reader}; never null\n+     * @param elementNamespaceOverrides never null\n+     * @return deserialized object representation of the XML.\n+     */\n+    public T readOverridingNamespace(Reader reader, ElementNamespaceOverride... elementNamespaceOverrides) {\n+        Objects.requireNonNull(reader);\n+        Objects.requireNonNull(elementNamespaceOverrides);\n+\n+        final String errMessage = String.format(\"Unable to read the (%s) from XML with overriding elements' namespaces: %s.\",", "originalCommit": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMwNjExMw==", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478306113", "bodyText": "Do we need a custom class for this?\nWe can probably just do\nString s = validationEventCollector.getEvents().stream().map(Event::getMessage).collect(Collectors.joining(\"\\n\"))", "author": "ge0ffrey", "createdAt": "2020-08-27T10:07:41Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/io/jaxb/GenericJaxbIO.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.io.jaxb;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.UnmarshallerHandler;\n+import javax.xml.bind.ValidationEvent;\n+import javax.xml.bind.util.ValidationEventCollector;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.transform.stream.StreamSource;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+\n+import org.optaplanner.core.impl.io.OptaPlannerXmlSerializationException;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.XMLFilter;\n+import org.xml.sax.XMLReader;\n+import org.xml.sax.helpers.XMLFilterImpl;\n+\n+public final class GenericJaxbIO<T> implements JaxbIO<T> {\n+    private static final int DEFAULT_INDENTATION = 2;\n+\n+    private static final String ERR_MSG_WRITE = \"Unable to write the %s to XML.\";\n+    private static final String ERR_MSG_READ = \"Unable to read the (%s) from XML.\";\n+\n+    private final JAXBContext jaxbContext;\n+    private final Marshaller marshaller;\n+    private final Class<T> rootClass;\n+    private final int indentation;\n+\n+    public GenericJaxbIO(Class<T> rootClass) {\n+        this(rootClass, DEFAULT_INDENTATION);\n+    }\n+\n+    public GenericJaxbIO(Class<T> rootClass, int indentation) {\n+        Objects.requireNonNull(rootClass);\n+        this.rootClass = rootClass;\n+        this.indentation = indentation;\n+        try {\n+            jaxbContext = JAXBContext.newInstance(rootClass);\n+            marshaller = jaxbContext.createMarshaller();\n+            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            marshaller.setProperty(Marshaller.JAXB_ENCODING, StandardCharsets.UTF_8.toString());\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to create JAXB Marshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    @Override\n+    public T read(Reader reader) {\n+        Objects.requireNonNull(reader);\n+        try {\n+            return (T) createUnmarshaller().unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    public T readAndValidate(Reader reader, String schemaResource) {\n+        Objects.requireNonNull(reader);\n+        String nonNullSchemaResource = Objects.requireNonNull(schemaResource);\n+        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n+        Schema schema;\n+        try {\n+            schema = schemaFactory.newSchema(GenericJaxbIO.class.getResource(nonNullSchemaResource));\n+        } catch (SAXException e) {\n+            throw new IllegalArgumentException(\"Unable to read input schema resource (\" + nonNullSchemaResource + \")\", e);\n+        }\n+\n+        Unmarshaller unmarshaller = createUnmarshaller();\n+        unmarshaller.setSchema(schema);\n+        ValidationEventStringCollector validationEventHandler = new ValidationEventStringCollector();\n+\n+        try {\n+            unmarshaller.setEventHandler(validationEventHandler);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to set validation event handler to the unmarshaller for \"\n+                    + \"a root element class (%s).\", rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        try {\n+            return (T) unmarshaller.unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            if (validationEventHandler.hasEvents()) {\n+                String errMessageWithValidationEvents = errMessage + \"\\n\" + validationEventHandler.reportAll();\n+                throw new OptaPlannerXmlSerializationException(errMessageWithValidationEvents, jaxbException);\n+            } else {\n+                throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+            }\n+        }\n+    }\n+\n+    private Unmarshaller createUnmarshaller() {\n+        try {\n+            return jaxbContext.createUnmarshaller();\n+        } catch (JAXBException e) {\n+            String errMessage = String.format(\"Unable to create JAXB unmarshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    /**\n+     * Reads the input XML using the {@link Reader} overriding elements namespaces. If an element already has a namespace and\n+     * a {@link ElementNamespaceOverride} is defined for this element, its namespace is overridden. In case the element has no\n+     * namespace, new namespace defined in the {@link ElementNamespaceOverride} is added.\n+     * \n+     * @param reader input XML {@link Reader}; never null\n+     * @param elementNamespaceOverrides never null\n+     * @return deserialized object representation of the XML.\n+     */\n+    public T readOverridingNamespace(Reader reader, ElementNamespaceOverride... elementNamespaceOverrides) {\n+        Objects.requireNonNull(reader);\n+        Objects.requireNonNull(elementNamespaceOverrides);\n+\n+        final String errMessage = String.format(\"Unable to read the (%s) from XML with overriding elements' namespaces: %s.\",\n+                rootClass.getName(), Arrays.toString(elementNamespaceOverrides));\n+\n+        // Create a SAXParser to use its XMLReader on the XMLFilter\n+        SAXParserFactory saxParserFactory = SAXParserFactory.newInstance();\n+        SAXParser saxParser;\n+        try {\n+            // Protect the parser against the XXE attack\n+            // https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A4-XML_External_Entities_(XXE)\n+            saxParserFactory.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n+            saxParser = saxParserFactory.newSAXParser();\n+        } catch (ParserConfigurationException | SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+        XMLReader xmlReader;\n+        try {\n+            xmlReader = saxParser.getXMLReader();\n+        } catch (SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+\n+        XMLFilter namespaceOverridingXmlFilter = new NamespaceOverridingXmlFilter(xmlReader, elementNamespaceOverrides);\n+        namespaceOverridingXmlFilter.setParent(xmlReader);\n+\n+        // Use UnmarshallerHandler as a content handler for the XML filter.\n+        Unmarshaller unmarshaller = createUnmarshaller();\n+        UnmarshallerHandler unmarshallerHandler = unmarshaller.getUnmarshallerHandler();\n+        namespaceOverridingXmlFilter.setContentHandler(unmarshallerHandler);\n+\n+        InputSource xmlInputSource = new InputSource(reader);\n+        try {\n+            // Parse the XML to feed its content into the UnmarshallerHandler.\n+            namespaceOverridingXmlFilter.parse(xmlInputSource);\n+        } catch (IOException | SAXException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+\n+        try {\n+            return (T) unmarshallerHandler.getResult();\n+        } catch (JAXBException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    @Override\n+    public void write(T root, Writer writer) {\n+        Objects.requireNonNull(root);\n+        Objects.requireNonNull(writer);\n+        DOMResult domResult = new DOMResult();\n+        try {\n+            marshaller.marshal(root, domResult);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_WRITE, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        formatXml(new DOMSource(domResult.getNode()), null, writer);\n+    }\n+\n+    public void writeWithoutNamespaces(T root, Writer writer) {\n+        Objects.requireNonNull(root);\n+        Objects.requireNonNull(writer);\n+        DOMResult domResult = new DOMResult();\n+        final String errMessage = String.format(ERR_MSG_WRITE, rootClass.getName());\n+        try {\n+            marshaller.marshal(root, domResult);\n+        } catch (JAXBException jaxbException) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        try (InputStream xsltInputStream = getClass().getResourceAsStream(\"removeNamespaces.xslt\")) {\n+            formatXml(new DOMSource(domResult.getNode()), new StreamSource(xsltInputStream), writer);\n+        } catch (IOException e) {\n+            throw new OptaPlannerXmlSerializationException(errMessage, e);\n+        }\n+    }\n+\n+    private void formatXml(Source source, Source transformationTemplate, Writer writer) {\n+        /*\n+         * The code is not vulnerable to XXE-based attacks as it does not process any external XML nor XSL input.\n+         * Should the transformerFactory be used for such purposes, it has to be appropriately secured:\n+         * https://owasp.org/www-project-top-ten/OWASP_Top_Ten_2017/Top_10-2017_A4-XML_External_Entities_(XXE)\n+         */\n+        @SuppressWarnings({ \"java:S2755\", \"java:S4435\" })\n+        TransformerFactory transformerFactory = TransformerFactory.newInstance();\n+        try {\n+            Transformer transformer = transformationTemplate == null ? transformerFactory.newTransformer()\n+                    : transformerFactory.newTransformer(transformationTemplate);\n+            // See https://stackoverflow.com/questions/46708498/jaxb-marshaller-indentation.\n+            transformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n+            transformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", String.valueOf(indentation));\n+            transformer.transform(source, new StreamResult(writer));\n+        } catch (TransformerException transformerException) {\n+            String errMessage = String.format(ERR_MSG_WRITE, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, transformerException);\n+        }\n+    }\n+\n+    /**\n+     * Overrides namespace of every XML element by the namespace defined in the {@link ElementNamespaceOverride}.\n+     */\n+    private static final class NamespaceOverridingXmlFilter extends XMLFilterImpl {\n+\n+        private final Deque<String> activeNamespace = new ArrayDeque<>();\n+        private final Map<String, String> elementNamespaceOverridesMap = new HashMap<>();\n+\n+        public NamespaceOverridingXmlFilter(XMLReader xmlReader, ElementNamespaceOverride... elementNamespaceOverrides) {\n+            super(xmlReader);\n+            Objects.requireNonNull(elementNamespaceOverrides);\n+            for (ElementNamespaceOverride namespaceOverride : elementNamespaceOverrides) {\n+                elementNamespaceOverridesMap.put(namespaceOverride.getElementLocalName(),\n+                        namespaceOverride.getNamespaceOverride());\n+            }\n+        }\n+\n+        @Override\n+        public void endElement(String uri, String localName, String qName) throws SAXException {\n+            String resultingUri = activeNamespace.isEmpty() ? uri : activeNamespace.peek();\n+            if (elementNamespaceOverridesMap.containsKey(qName)) {\n+                activeNamespace.pop();\n+            }\n+            super.endElement(resultingUri, localName, qName);\n+        }\n+\n+        @Override\n+        public void startElement(String uri, String localName, String qName, Attributes atts) throws SAXException {\n+            String namespaceOverride = elementNamespaceOverridesMap.get(qName);\n+            if (namespaceOverride != null) {\n+                activeNamespace.push(namespaceOverride);\n+            }\n+\n+            String resultingUri = activeNamespace.isEmpty() ? uri : activeNamespace.peek();\n+            super.startElement(resultingUri, localName, qName, atts);\n+        }\n+\n+    }\n+\n+    private static final class ValidationEventStringCollector extends ValidationEventCollector {", "originalCommit": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMwODE4MA==", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478308180", "bodyText": "open question (maybe for another PR): Is this public API? Should SolverFactory.createFromXmlResource()'s javadoc have a \"@throws OptaPlannerXmlSerializationException\" ? In that case we might want to move it into the api package.", "author": "ge0ffrey", "createdAt": "2020-08-27T10:11:23Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/io/OptaPlannerXmlSerializationException.java", "diffHunk": "@@ -16,21 +16,21 @@\n \n package org.optaplanner.core.impl.io;\n \n-public class XmlUnmarshallingException extends RuntimeException {\n+public class OptaPlannerXmlSerializationException extends RuntimeException {", "originalCommit": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMwODgwNw==", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478308807", "bodyText": "Naming:\n\nWe avoid class names that contain the word \"OptaPlanner\" because everything in our repository is about OptaPlanner.\nIs it Serialization or Marshalling? Much of the other code naming and error messages seem to talk about marshalling, not serialization. Let's use one term and stick with that.", "author": "ge0ffrey", "createdAt": "2020-08-27T10:12:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMwODE4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMyMjI3NA==", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478322274", "bodyText": "The same question applies to all the fail-fast checks: should we mention there the IllegalArgumentException? Maybe it should. In that case, I would definitely do it in a separate PR.", "author": "rsynek", "createdAt": "2020-08-27T10:38:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMwODE4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMxMDAzMA==", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478310030", "bodyText": "Naming consistency: the only implementation of an interface Foo is normally called DefaultFoo in the rest of the optaplanner repo. This makes it easier to guess when doing ctrl-n.\n=> rename GenericJaxbIO to DefaultJaxbIO", "author": "ge0ffrey", "createdAt": "2020-08-27T10:15:01Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/io/jaxb/GenericJaxbIO.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.io.jaxb;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.UnmarshallerHandler;\n+import javax.xml.bind.ValidationEvent;\n+import javax.xml.bind.util.ValidationEventCollector;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.transform.stream.StreamSource;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+\n+import org.optaplanner.core.impl.io.OptaPlannerXmlSerializationException;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.XMLFilter;\n+import org.xml.sax.XMLReader;\n+import org.xml.sax.helpers.XMLFilterImpl;\n+\n+public final class GenericJaxbIO<T> implements JaxbIO<T> {", "originalCommit": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMyMDc5Nw==", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478320797", "bodyText": "It's not the only implementation; it's just the only one that takes a generic type parameter. Other implementations deal e.g. with the SolverConfig and use this generic one under the hood.", "author": "rsynek", "createdAt": "2020-08-27T10:35:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMxMDAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMxMTUwNA==", "url": "https://github.com/kiegroup/optaplanner/pull/902#discussion_r478311504", "bodyText": "Read didn't fail here. Validation failed. Or if read includes validation, then actually stating \"validation failed\" is more specific. The error message should reflect that, so users don't think that the file wasn't found.", "author": "ge0ffrey", "createdAt": "2020-08-27T10:17:54Z", "path": "optaplanner-core/src/main/java/org/optaplanner/core/impl/io/jaxb/GenericJaxbIO.java", "diffHunk": "@@ -0,0 +1,318 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.optaplanner.core.impl.io.jaxb;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.io.Writer;\n+import java.nio.charset.StandardCharsets;\n+import java.util.ArrayDeque;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Objects;\n+\n+import javax.xml.XMLConstants;\n+import javax.xml.bind.JAXBContext;\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.Marshaller;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.UnmarshallerHandler;\n+import javax.xml.bind.ValidationEvent;\n+import javax.xml.bind.util.ValidationEventCollector;\n+import javax.xml.parsers.ParserConfigurationException;\n+import javax.xml.parsers.SAXParser;\n+import javax.xml.parsers.SAXParserFactory;\n+import javax.xml.transform.OutputKeys;\n+import javax.xml.transform.Source;\n+import javax.xml.transform.Transformer;\n+import javax.xml.transform.TransformerException;\n+import javax.xml.transform.TransformerFactory;\n+import javax.xml.transform.dom.DOMResult;\n+import javax.xml.transform.dom.DOMSource;\n+import javax.xml.transform.stream.StreamResult;\n+import javax.xml.transform.stream.StreamSource;\n+import javax.xml.validation.Schema;\n+import javax.xml.validation.SchemaFactory;\n+\n+import org.optaplanner.core.impl.io.OptaPlannerXmlSerializationException;\n+import org.xml.sax.Attributes;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+import org.xml.sax.XMLFilter;\n+import org.xml.sax.XMLReader;\n+import org.xml.sax.helpers.XMLFilterImpl;\n+\n+public final class GenericJaxbIO<T> implements JaxbIO<T> {\n+    private static final int DEFAULT_INDENTATION = 2;\n+\n+    private static final String ERR_MSG_WRITE = \"Unable to write the %s to XML.\";\n+    private static final String ERR_MSG_READ = \"Unable to read the (%s) from XML.\";\n+\n+    private final JAXBContext jaxbContext;\n+    private final Marshaller marshaller;\n+    private final Class<T> rootClass;\n+    private final int indentation;\n+\n+    public GenericJaxbIO(Class<T> rootClass) {\n+        this(rootClass, DEFAULT_INDENTATION);\n+    }\n+\n+    public GenericJaxbIO(Class<T> rootClass, int indentation) {\n+        Objects.requireNonNull(rootClass);\n+        this.rootClass = rootClass;\n+        this.indentation = indentation;\n+        try {\n+            jaxbContext = JAXBContext.newInstance(rootClass);\n+            marshaller = jaxbContext.createMarshaller();\n+            marshaller.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, true);\n+            marshaller.setProperty(Marshaller.JAXB_ENCODING, StandardCharsets.UTF_8.toString());\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to create JAXB Marshaller for a root element class (%s).\",\n+                    rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    @Override\n+    public T read(Reader reader) {\n+        Objects.requireNonNull(reader);\n+        try {\n+            return (T) createUnmarshaller().unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+    }\n+\n+    public T readAndValidate(Reader reader, String schemaResource) {\n+        Objects.requireNonNull(reader);\n+        String nonNullSchemaResource = Objects.requireNonNull(schemaResource);\n+        SchemaFactory schemaFactory = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);\n+        Schema schema;\n+        try {\n+            schema = schemaFactory.newSchema(GenericJaxbIO.class.getResource(nonNullSchemaResource));\n+        } catch (SAXException e) {\n+            throw new IllegalArgumentException(\"Unable to read input schema resource (\" + nonNullSchemaResource + \")\", e);\n+        }\n+\n+        Unmarshaller unmarshaller = createUnmarshaller();\n+        unmarshaller.setSchema(schema);\n+        ValidationEventStringCollector validationEventHandler = new ValidationEventStringCollector();\n+\n+        try {\n+            unmarshaller.setEventHandler(validationEventHandler);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(\"Unable to set validation event handler to the unmarshaller for \"\n+                    + \"a root element class (%s).\", rootClass.getName());\n+            throw new OptaPlannerXmlSerializationException(errMessage, jaxbException);\n+        }\n+\n+        try {\n+            return (T) unmarshaller.unmarshal(reader);\n+        } catch (JAXBException jaxbException) {\n+            String errMessage = String.format(ERR_MSG_READ, rootClass.getName());\n+            if (validationEventHandler.hasEvents()) {\n+                String errMessageWithValidationEvents = errMessage + \"\\n\" + validationEventHandler.reportAll();\n+                throw new OptaPlannerXmlSerializationException(errMessageWithValidationEvents, jaxbException);", "originalCommit": "1d0bed8beead1d5dbf6e20bd8eb5556f77321596", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "39d10d5f5404ff8537bef0dcc5b2848f007c107b", "url": "https://github.com/kiegroup/optaplanner/commit/39d10d5f5404ff8537bef0dcc5b2848f007c107b", "message": "Address review comments", "committedDate": "2020-08-27T12:12:11Z", "type": "commit"}, {"oid": "39d10d5f5404ff8537bef0dcc5b2848f007c107b", "url": "https://github.com/kiegroup/optaplanner/commit/39d10d5f5404ff8537bef0dcc5b2848f007c107b", "message": "Address review comments", "committedDate": "2020-08-27T12:12:11Z", "type": "forcePushed"}]}