{"pr_number": 2019, "pr_title": "Faster Property fetching with derived classes ", "pr_createdAt": "2020-09-05T11:03:36Z", "pr_url": "https://github.com/graphql-java/graphql-java/pull/2019", "timeline": [{"oid": "aa04b80dd6f97a300058230e5e12f95987e46caf", "url": "https://github.com/graphql-java/graphql-java/commit/aa04b80dd6f97a300058230e5e12f95987e46caf", "message": "Faster Property fetching", "committedDate": "2020-09-05T11:00:47Z", "type": "commit"}, {"oid": "18f7217f9f7cb5315d15ef49d8841a7279b84fa0", "url": "https://github.com/graphql-java/graphql-java/commit/18f7217f9f7cb5315d15ef49d8841a7279b84fa0", "message": "Slight change in heuristic", "committedDate": "2020-09-05T11:36:11Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk0NDY3OA==", "url": "https://github.com/graphql-java/graphql-java/pull/2019#discussion_r483944678", "bodyText": "I flipped the negative cache down in the order because I think the \"positive case\" is more likely - that is for any property X on a source object we have a method to get it.\nSo now if we DONT have a cached method we will try to see if its negatively cached (could not be found before) and the do the full search for it\nThis is a minor improvement because it avoids a map lookup in the case where we have methods, which I beleive is the best case to chase first", "author": "bbakerman", "createdAt": "2020-09-05T12:04:16Z", "path": "src/main/java/graphql/schema/PropertyDataFetcherHelper.java", "diffHunk": "@@ -42,49 +52,52 @@ public static Object getPropertyValue(String propertyName, Object object, GraphQ\n             return ((Map<?, ?>) object).get(propertyName);\n         }\n \n-        String key = mkKey(object, propertyName);\n-        //\n-        // if we have tried all strategies before and they have all failed then we negatively cache\n-        // the key and assume that its never going to turn up.  This shortcuts the property lookup\n-        // in systems where there was a `foo` graphql property but they never provided an POJO\n-        // version of `foo`.\n-        if (isNegativelyCached(key)) {\n-            return null;\n-        }\n-        // lets try positive cache mechanisms next.  If we have seen the method or field before\n+        String cacheKey = mkKey(object, propertyName);\n+        // lets try positive cache mechanisms first.  If we have seen the method or field before\n         // then we invoke it directly without burning any cycles doing reflection.\n-        Method cachedMethod = METHOD_CACHE.get(key);\n+        CachedMethod cachedMethod = METHOD_CACHE.get(cacheKey);\n         if (cachedMethod != null) {\n-            MethodFinder methodFinder = (aClass, methodName) -> cachedMethod;\n             try {\n-                return getPropertyViaGetterMethod(object, propertyName, graphQLType, methodFinder, environment);\n+                return invokeMethod(object, environment, cachedMethod.method, cachedMethod.takesDataFetcherEnvironmentAsOnlyArgument);\n             } catch (NoSuchMethodException ignored) {\n-                assertShouldNeverHappen(\"A method cached as '%s' is no longer available??\", key);\n+                assertShouldNeverHappen(\"A method cached as '%s' is no longer available??\", cacheKey);\n             }\n         }\n-        Field cachedField = FIELD_CACHE.get(key);\n+        Field cachedField = FIELD_CACHE.get(cacheKey);\n         if (cachedField != null) {\n-            try {\n-                return getPropertyViaFieldAccess(object, propertyName);\n-            } catch (FastNoSuchMethodException ignored) {\n-                assertShouldNeverHappen(\"A field cached as '%s' is no longer available??\", key);\n-            }\n+            return invokeField(object, cachedField);\n         }\n \n+        //\n+        // if we have tried all strategies before and they have all failed then we negatively cache\n+        // the cacheKey and assume that its never going to turn up.  This shortcuts the property lookup\n+        // in systems where there was a `foo` graphql property but they never provided an POJO\n+        // version of `foo`.\n+        //\n+        // we do this second because we believe in the positive cached version will mostly prevail\n+        // but if we then look it up and negatively cache it then lest do that look up next\n+        //\n+        if (isNegativelyCached(cacheKey)) {\n+            return null;\n+        }", "originalCommit": "18f7217f9f7cb5315d15ef49d8841a7279b84fa0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk0NDY5Mw==", "url": "https://github.com/graphql-java/graphql-java/pull/2019#discussion_r483944693", "bodyText": "We now do LESS work to invoke the property get", "author": "bbakerman", "createdAt": "2020-09-05T12:04:31Z", "path": "src/main/java/graphql/schema/PropertyDataFetcherHelper.java", "diffHunk": "@@ -42,49 +52,52 @@ public static Object getPropertyValue(String propertyName, Object object, GraphQ\n             return ((Map<?, ?>) object).get(propertyName);\n         }\n \n-        String key = mkKey(object, propertyName);\n-        //\n-        // if we have tried all strategies before and they have all failed then we negatively cache\n-        // the key and assume that its never going to turn up.  This shortcuts the property lookup\n-        // in systems where there was a `foo` graphql property but they never provided an POJO\n-        // version of `foo`.\n-        if (isNegativelyCached(key)) {\n-            return null;\n-        }\n-        // lets try positive cache mechanisms next.  If we have seen the method or field before\n+        String cacheKey = mkKey(object, propertyName);\n+        // lets try positive cache mechanisms first.  If we have seen the method or field before\n         // then we invoke it directly without burning any cycles doing reflection.\n-        Method cachedMethod = METHOD_CACHE.get(key);\n+        CachedMethod cachedMethod = METHOD_CACHE.get(cacheKey);\n         if (cachedMethod != null) {\n-            MethodFinder methodFinder = (aClass, methodName) -> cachedMethod;\n             try {\n-                return getPropertyViaGetterMethod(object, propertyName, graphQLType, methodFinder, environment);\n+                return invokeMethod(object, environment, cachedMethod.method, cachedMethod.takesDataFetcherEnvironmentAsOnlyArgument);", "originalCommit": "18f7217f9f7cb5315d15ef49d8841a7279b84fa0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzk0NDc4Mg==", "url": "https://github.com/graphql-java/graphql-java/pull/2019#discussion_r483944782", "bodyText": "previously we always did this method call - now we cache this knowledge just like the method itself", "author": "bbakerman", "createdAt": "2020-09-05T12:05:17Z", "path": "src/main/java/graphql/schema/PropertyDataFetcherHelper.java", "diffHunk": "@@ -122,22 +135,10 @@ private static Object getPropertyViaGetterMethod(Object object, String propertyN\n \n     private static Object getPropertyViaGetterUsingPrefix(Object object, String propertyName, String prefix, MethodFinder methodFinder, DataFetchingEnvironment environment) throws NoSuchMethodException {\n         String getterName = prefix + propertyName.substring(0, 1).toUpperCase() + propertyName.substring(1);\n-        try {\n-            Method method = methodFinder.apply(object.getClass(), getterName);\n-            if (takesDataFetcherEnvironmentAsOnlyArgument(method)) {", "originalCommit": "18f7217f9f7cb5315d15ef49d8841a7279b84fa0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}