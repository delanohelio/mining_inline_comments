{"pr_number": 1955, "pr_title": "New validation rules about type, field, argument", "pr_createdAt": "2020-06-13T03:14:55Z", "pr_url": "https://github.com/graphql-java/graphql-java/pull/1955", "timeline": [{"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db", "url": "https://github.com/graphql-java/graphql-java/commit/a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db", "message": "add some schema validation rules: type, field, argument.", "committedDate": "2020-06-13T06:54:23Z", "type": "commit"}, {"oid": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db", "url": "https://github.com/graphql-java/graphql-java/commit/a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db", "message": "add some schema validation rules: type, field, argument.", "committedDate": "2020-06-13T06:54:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MDc1Ng==", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442650756", "bodyText": "we should only treat the build-in scalar types (Int, Float, String, Boolean and ID) in a special way. The others are not really special and should be treated as every other custom scalar.\nWe also have a helper method in Scalars (I believe) to determine if the type is a build-in one or not", "author": "andimarek", "createdAt": "2020-06-19T06:14:40Z", "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();\n+        if (memberTypes == null || memberTypes.size() == 0) {\n+            SchemaValidationError validationError =\n+                    new SchemaValidationError(SchemaValidationErrorType.UnionTypeLackOfTypeError, String.format(\"Union type \\\"%s\\\" must include one or more unique member types.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        }\n+\n+        List<String> typeNames = new ArrayList<>();\n+        for (Type memberType : memberTypes) {\n+            String typeName = ((TypeName) memberType).getName();\n+            GraphQLNamedType graphQLNamedType = schemaTypeHolder.get(typeName);\n+            if (!(graphQLNamedType instanceof GraphQLObjectType)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.InvalidUnionMemberTypeError, String.format(\"The member types of a Union type must all be Object base types. member type \\\"%s\\\" in Union \\\"%s\\\" is invalid.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            if (typeNames.contains(typeName)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.RepetitiveElementError, String.format(\"The member types of a Union type must be unique. member type \\\"%s\\\" in Union \\\"%s\\\" is not unique.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            typeNames.add(typeName);\n+        }\n+    }\n+\n+    private void validateScalar(GraphQLScalarType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+    }\n+\n+    private void validateEnum(GraphQLEnumType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLEnumValueDefinition> enumValueDefinitions = type.getValues();\n+        if (enumValueDefinitions == null || enumValueDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.EnumLackOfValueError, String.format(\"Enum type \\\"%s\\\" must define one or more enum values.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        } else {\n+            for (GraphQLEnumValueDefinition enumValueDefinition : enumValueDefinitions) {\n+                assertEnumValueDefinitionName(type.getName(), enumValueDefinition.getName(), errorCollector);\n+            }\n+        }\n+\n+    }\n+\n+    private void validateFieldDefinition(String typeName, GraphQLFieldDefinition fieldDefinition, SchemaValidationErrorCollector errorCollector) {\n+        assertFieldName(typeName, fieldDefinition.getName(), errorCollector);\n+        assertNonNullType(fieldDefinition.getType(), errorCollector);\n+\n+        List<GraphQLArgument> fieldDefinitionArguments = fieldDefinition.getArguments();\n+        if (fieldDefinitionArguments != null || fieldDefinitionArguments.size() != 0) {\n+            for (GraphQLArgument fieldDefinitionArgument : fieldDefinitionArguments) {\n+                validateFieldDefinitionArgument(typeName, fieldDefinition.getName(), fieldDefinitionArgument, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateFieldDefinitionArgument(String typeName, String fieldName, GraphQLArgument argument, SchemaValidationErrorCollector errorCollector) {\n+        assertArgumentName(typeName, fieldName, argument.getName(), errorCollector);\n+        assertNonNullType(argument.getType(), errorCollector);\n+    }\n+\n+    private void assertTypeName(String typeName, SchemaValidationErrorCollector validationErrorCollector) {\n+        if (typeName.length() >= 2 && typeName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", typeName));\n+            validationErrorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertFieldName(String typeName, String fieldName, SchemaValidationErrorCollector errorCollector) {\n+        if (fieldName.length() >= 2 && fieldName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" in \\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", fieldName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertArgumentName(String typeName, String fieldName, String argumentName, SchemaValidationErrorCollector errorCollector) {\n+        if (argumentName.length() >= 2 && argumentName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"Argument name \\\"%s\\\" in \\\"%s-%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", argumentName, typeName, fieldName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertEnumValueDefinitionName(String typeName, String enumValueDefinitionName, SchemaValidationErrorCollector errorCollector) {\n+        if (enumValueDefinitionName.length() >= 2 && enumValueDefinitionName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"EnumValueDefinition \\\"%s\\\" in  \\\"%s\\\"  must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", enumValueDefinitionName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertNonNullType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLNonNull && ((GraphQLNonNull) type).getWrappedType() instanceof GraphQLNonNull) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.NonNullWrapNonNullError,\n+                    String.format(\"Non\u2010Null type \\\"%s\\\" must not wrap another Non\u2010Null type.\", GraphQLTypeUtil.simplePrint(type)));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private List<GraphQLNamedType> filterScalarAndIntrospectionTypes(List<GraphQLNamedType> graphQLNamedTypes) {\n+        if (graphQLNamedTypes == null || graphQLNamedTypes.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        return graphQLNamedTypes.stream().filter(type -> !isScalarOrIntrospectionTypes(type)).collect(Collectors.toList());\n+    }\n+\n+    private boolean isScalarOrIntrospectionTypes(GraphQLNamedType type) {\n+        if (type instanceof GraphQLScalarType && (\n+                type.getName().equals(\"Int\") || type.getName().equals(\"Float\") || type.getName().equals(\"String\") ||", "originalCommit": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk3MjYwMA==", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442972600", "bodyText": "Thanks for your suggestion.", "author": "dugenkui03", "createdAt": "2020-06-19T17:50:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MDc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MTYyMQ==", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442651621", "bodyText": "we should not need to check the AST definition here. Just getting the members of the type should be enough.", "author": "andimarek", "createdAt": "2020-06-19T06:17:37Z", "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();", "originalCommit": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk5MjA0Mg==", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442992042", "bodyText": "types in GraphQLUnionType.Builder is a Map(code link), which will lost the type with duplicated name.\nMaybe it will be better to move unique member check to SchemaTypeChecker.", "author": "dugenkui03", "createdAt": "2020-06-19T18:38:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MTYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk5NTUwNQ==", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442995505", "bodyText": "I will followed your suggestion instead of removed it, because types definied in GraphQLUnionType is list after all.\nThen I will add unique member check to SchemaTypeChecker in another PR.\nIs that appropriate?", "author": "dugenkui03", "createdAt": "2020-06-19T18:47:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MTYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MTk5OA==", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442651998", "bodyText": "can we combine validateObject and validateInterface?\nI would also suggest a more prescriptive name like validateContainsField or so.", "author": "andimarek", "createdAt": "2020-06-19T06:18:48Z", "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {", "originalCommit": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg5ODE3Nw==", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442898177", "bodyText": "Thanks for your suggestion.", "author": "dugenkui03", "createdAt": "2020-06-19T15:14:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MTk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MjE3Ng==", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442652176", "bodyText": "IntrospectionQuery is not a special type at all (it is just a name).", "author": "andimarek", "createdAt": "2020-06-19T06:19:20Z", "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();\n+        if (memberTypes == null || memberTypes.size() == 0) {\n+            SchemaValidationError validationError =\n+                    new SchemaValidationError(SchemaValidationErrorType.UnionTypeLackOfTypeError, String.format(\"Union type \\\"%s\\\" must include one or more unique member types.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        }\n+\n+        List<String> typeNames = new ArrayList<>();\n+        for (Type memberType : memberTypes) {\n+            String typeName = ((TypeName) memberType).getName();\n+            GraphQLNamedType graphQLNamedType = schemaTypeHolder.get(typeName);\n+            if (!(graphQLNamedType instanceof GraphQLObjectType)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.InvalidUnionMemberTypeError, String.format(\"The member types of a Union type must all be Object base types. member type \\\"%s\\\" in Union \\\"%s\\\" is invalid.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            if (typeNames.contains(typeName)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.RepetitiveElementError, String.format(\"The member types of a Union type must be unique. member type \\\"%s\\\" in Union \\\"%s\\\" is not unique.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            typeNames.add(typeName);\n+        }\n+    }\n+\n+    private void validateScalar(GraphQLScalarType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+    }\n+\n+    private void validateEnum(GraphQLEnumType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLEnumValueDefinition> enumValueDefinitions = type.getValues();\n+        if (enumValueDefinitions == null || enumValueDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.EnumLackOfValueError, String.format(\"Enum type \\\"%s\\\" must define one or more enum values.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        } else {\n+            for (GraphQLEnumValueDefinition enumValueDefinition : enumValueDefinitions) {\n+                assertEnumValueDefinitionName(type.getName(), enumValueDefinition.getName(), errorCollector);\n+            }\n+        }\n+\n+    }\n+\n+    private void validateFieldDefinition(String typeName, GraphQLFieldDefinition fieldDefinition, SchemaValidationErrorCollector errorCollector) {\n+        assertFieldName(typeName, fieldDefinition.getName(), errorCollector);\n+        assertNonNullType(fieldDefinition.getType(), errorCollector);\n+\n+        List<GraphQLArgument> fieldDefinitionArguments = fieldDefinition.getArguments();\n+        if (fieldDefinitionArguments != null || fieldDefinitionArguments.size() != 0) {\n+            for (GraphQLArgument fieldDefinitionArgument : fieldDefinitionArguments) {\n+                validateFieldDefinitionArgument(typeName, fieldDefinition.getName(), fieldDefinitionArgument, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateFieldDefinitionArgument(String typeName, String fieldName, GraphQLArgument argument, SchemaValidationErrorCollector errorCollector) {\n+        assertArgumentName(typeName, fieldName, argument.getName(), errorCollector);\n+        assertNonNullType(argument.getType(), errorCollector);\n+    }\n+\n+    private void assertTypeName(String typeName, SchemaValidationErrorCollector validationErrorCollector) {\n+        if (typeName.length() >= 2 && typeName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", typeName));\n+            validationErrorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertFieldName(String typeName, String fieldName, SchemaValidationErrorCollector errorCollector) {\n+        if (fieldName.length() >= 2 && fieldName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" in \\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", fieldName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertArgumentName(String typeName, String fieldName, String argumentName, SchemaValidationErrorCollector errorCollector) {\n+        if (argumentName.length() >= 2 && argumentName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"Argument name \\\"%s\\\" in \\\"%s-%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", argumentName, typeName, fieldName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertEnumValueDefinitionName(String typeName, String enumValueDefinitionName, SchemaValidationErrorCollector errorCollector) {\n+        if (enumValueDefinitionName.length() >= 2 && enumValueDefinitionName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"EnumValueDefinition \\\"%s\\\" in  \\\"%s\\\"  must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", enumValueDefinitionName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertNonNullType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLNonNull && ((GraphQLNonNull) type).getWrappedType() instanceof GraphQLNonNull) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.NonNullWrapNonNullError,\n+                    String.format(\"Non\u2010Null type \\\"%s\\\" must not wrap another Non\u2010Null type.\", GraphQLTypeUtil.simplePrint(type)));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private List<GraphQLNamedType> filterScalarAndIntrospectionTypes(List<GraphQLNamedType> graphQLNamedTypes) {\n+        if (graphQLNamedTypes == null || graphQLNamedTypes.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        return graphQLNamedTypes.stream().filter(type -> !isScalarOrIntrospectionTypes(type)).collect(Collectors.toList());\n+    }\n+\n+    private boolean isScalarOrIntrospectionTypes(GraphQLNamedType type) {\n+        if (type instanceof GraphQLScalarType && (\n+                type.getName().equals(\"Int\") || type.getName().equals(\"Float\") || type.getName().equals(\"String\") ||\n+                        type.getName().equals(\"Boolean\") || type.getName().equals(\"ID\") || type.getName().equals(\"Long\") || type.getName().equals(\"Short\") ||\n+                        type.getName().equals(\"BigInteger\") || type.getName().equals(\"BigDecimal\") || type.getName().equals(\"Char\")\n+        )) {\n+            return true;\n+        }\n+\n+        if (type instanceof GraphQLEnumType && (type.getName().equals(\"__DirectiveLocation\") || type.getName().equals(\"__TypeKind\"))) {\n+            return true;\n+        }\n+\n+        if (type instanceof GraphQLObjectType && (", "originalCommit": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg2NDIzMA==", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442864230", "bodyText": "graphql-java framework contains a type named IntrospectionQuery, which contains fields start with '__', and is used for introspection.\nI add a method named isIntrospectionTypes(), which is used in filterBuiltInTypes(). details in new commit.", "author": "dugenkui03", "createdAt": "2020-06-19T14:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MjE3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MjMxNQ==", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442652315", "bodyText": "could this whole method just check for __ prefix?", "author": "andimarek", "createdAt": "2020-06-19T06:19:51Z", "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();\n+        if (memberTypes == null || memberTypes.size() == 0) {\n+            SchemaValidationError validationError =\n+                    new SchemaValidationError(SchemaValidationErrorType.UnionTypeLackOfTypeError, String.format(\"Union type \\\"%s\\\" must include one or more unique member types.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        }\n+\n+        List<String> typeNames = new ArrayList<>();\n+        for (Type memberType : memberTypes) {\n+            String typeName = ((TypeName) memberType).getName();\n+            GraphQLNamedType graphQLNamedType = schemaTypeHolder.get(typeName);\n+            if (!(graphQLNamedType instanceof GraphQLObjectType)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.InvalidUnionMemberTypeError, String.format(\"The member types of a Union type must all be Object base types. member type \\\"%s\\\" in Union \\\"%s\\\" is invalid.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            if (typeNames.contains(typeName)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.RepetitiveElementError, String.format(\"The member types of a Union type must be unique. member type \\\"%s\\\" in Union \\\"%s\\\" is not unique.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            typeNames.add(typeName);\n+        }\n+    }\n+\n+    private void validateScalar(GraphQLScalarType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+    }\n+\n+    private void validateEnum(GraphQLEnumType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLEnumValueDefinition> enumValueDefinitions = type.getValues();\n+        if (enumValueDefinitions == null || enumValueDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.EnumLackOfValueError, String.format(\"Enum type \\\"%s\\\" must define one or more enum values.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        } else {\n+            for (GraphQLEnumValueDefinition enumValueDefinition : enumValueDefinitions) {\n+                assertEnumValueDefinitionName(type.getName(), enumValueDefinition.getName(), errorCollector);\n+            }\n+        }\n+\n+    }\n+\n+    private void validateFieldDefinition(String typeName, GraphQLFieldDefinition fieldDefinition, SchemaValidationErrorCollector errorCollector) {\n+        assertFieldName(typeName, fieldDefinition.getName(), errorCollector);\n+        assertNonNullType(fieldDefinition.getType(), errorCollector);\n+\n+        List<GraphQLArgument> fieldDefinitionArguments = fieldDefinition.getArguments();\n+        if (fieldDefinitionArguments != null || fieldDefinitionArguments.size() != 0) {\n+            for (GraphQLArgument fieldDefinitionArgument : fieldDefinitionArguments) {\n+                validateFieldDefinitionArgument(typeName, fieldDefinition.getName(), fieldDefinitionArgument, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateFieldDefinitionArgument(String typeName, String fieldName, GraphQLArgument argument, SchemaValidationErrorCollector errorCollector) {\n+        assertArgumentName(typeName, fieldName, argument.getName(), errorCollector);\n+        assertNonNullType(argument.getType(), errorCollector);\n+    }\n+\n+    private void assertTypeName(String typeName, SchemaValidationErrorCollector validationErrorCollector) {\n+        if (typeName.length() >= 2 && typeName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", typeName));\n+            validationErrorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertFieldName(String typeName, String fieldName, SchemaValidationErrorCollector errorCollector) {\n+        if (fieldName.length() >= 2 && fieldName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" in \\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", fieldName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertArgumentName(String typeName, String fieldName, String argumentName, SchemaValidationErrorCollector errorCollector) {\n+        if (argumentName.length() >= 2 && argumentName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"Argument name \\\"%s\\\" in \\\"%s-%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", argumentName, typeName, fieldName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertEnumValueDefinitionName(String typeName, String enumValueDefinitionName, SchemaValidationErrorCollector errorCollector) {\n+        if (enumValueDefinitionName.length() >= 2 && enumValueDefinitionName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"EnumValueDefinition \\\"%s\\\" in  \\\"%s\\\"  must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", enumValueDefinitionName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertNonNullType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLNonNull && ((GraphQLNonNull) type).getWrappedType() instanceof GraphQLNonNull) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.NonNullWrapNonNullError,\n+                    String.format(\"Non\u2010Null type \\\"%s\\\" must not wrap another Non\u2010Null type.\", GraphQLTypeUtil.simplePrint(type)));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private List<GraphQLNamedType> filterScalarAndIntrospectionTypes(List<GraphQLNamedType> graphQLNamedTypes) {\n+        if (graphQLNamedTypes == null || graphQLNamedTypes.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        return graphQLNamedTypes.stream().filter(type -> !isScalarOrIntrospectionTypes(type)).collect(Collectors.toList());\n+    }\n+\n+    private boolean isScalarOrIntrospectionTypes(GraphQLNamedType type) {", "originalCommit": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk5ODEyMQ==", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442998121", "bodyText": "Replace it by filterBuiltInTypes, which aimed to filter Built-In Types.", "author": "dugenkui03", "createdAt": "2020-06-19T18:54:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MjMxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MjczOQ==", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442652739", "bodyText": "We have static util methods  (in FpKit I believe), please use them instead of using directly filter etc.", "author": "andimarek", "createdAt": "2020-06-19T06:21:21Z", "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();\n+        if (memberTypes == null || memberTypes.size() == 0) {\n+            SchemaValidationError validationError =\n+                    new SchemaValidationError(SchemaValidationErrorType.UnionTypeLackOfTypeError, String.format(\"Union type \\\"%s\\\" must include one or more unique member types.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        }\n+\n+        List<String> typeNames = new ArrayList<>();\n+        for (Type memberType : memberTypes) {\n+            String typeName = ((TypeName) memberType).getName();\n+            GraphQLNamedType graphQLNamedType = schemaTypeHolder.get(typeName);\n+            if (!(graphQLNamedType instanceof GraphQLObjectType)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.InvalidUnionMemberTypeError, String.format(\"The member types of a Union type must all be Object base types. member type \\\"%s\\\" in Union \\\"%s\\\" is invalid.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            if (typeNames.contains(typeName)) {\n+                SchemaValidationError validationError =\n+                        new SchemaValidationError(SchemaValidationErrorType.RepetitiveElementError, String.format(\"The member types of a Union type must be unique. member type \\\"%s\\\" in Union \\\"%s\\\" is not unique.\", ((TypeName) memberType).getName(), type.getName()));\n+                errorCollector.addError(validationError);\n+            }\n+            typeNames.add(typeName);\n+        }\n+    }\n+\n+    private void validateScalar(GraphQLScalarType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+    }\n+\n+    private void validateEnum(GraphQLEnumType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLEnumValueDefinition> enumValueDefinitions = type.getValues();\n+        if (enumValueDefinitions == null || enumValueDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.EnumLackOfValueError, String.format(\"Enum type \\\"%s\\\" must define one or more enum values.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        } else {\n+            for (GraphQLEnumValueDefinition enumValueDefinition : enumValueDefinitions) {\n+                assertEnumValueDefinitionName(type.getName(), enumValueDefinition.getName(), errorCollector);\n+            }\n+        }\n+\n+    }\n+\n+    private void validateFieldDefinition(String typeName, GraphQLFieldDefinition fieldDefinition, SchemaValidationErrorCollector errorCollector) {\n+        assertFieldName(typeName, fieldDefinition.getName(), errorCollector);\n+        assertNonNullType(fieldDefinition.getType(), errorCollector);\n+\n+        List<GraphQLArgument> fieldDefinitionArguments = fieldDefinition.getArguments();\n+        if (fieldDefinitionArguments != null || fieldDefinitionArguments.size() != 0) {\n+            for (GraphQLArgument fieldDefinitionArgument : fieldDefinitionArguments) {\n+                validateFieldDefinitionArgument(typeName, fieldDefinition.getName(), fieldDefinitionArgument, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateFieldDefinitionArgument(String typeName, String fieldName, GraphQLArgument argument, SchemaValidationErrorCollector errorCollector) {\n+        assertArgumentName(typeName, fieldName, argument.getName(), errorCollector);\n+        assertNonNullType(argument.getType(), errorCollector);\n+    }\n+\n+    private void assertTypeName(String typeName, SchemaValidationErrorCollector validationErrorCollector) {\n+        if (typeName.length() >= 2 && typeName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", typeName));\n+            validationErrorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertFieldName(String typeName, String fieldName, SchemaValidationErrorCollector errorCollector) {\n+        if (fieldName.length() >= 2 && fieldName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"\\\"%s\\\" in \\\"%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", fieldName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertArgumentName(String typeName, String fieldName, String argumentName, SchemaValidationErrorCollector errorCollector) {\n+        if (argumentName.length() >= 2 && argumentName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"Argument name \\\"%s\\\" in \\\"%s-%s\\\" must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", argumentName, typeName, fieldName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertEnumValueDefinitionName(String typeName, String enumValueDefinitionName, SchemaValidationErrorCollector errorCollector) {\n+        if (enumValueDefinitionName.length() >= 2 && enumValueDefinitionName.startsWith(\"__\")) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.InvalidCustomizedNameError,\n+                    String.format(\"EnumValueDefinition \\\"%s\\\" in  \\\"%s\\\"  must not begin with \\\"__\\\", which is reserved by GraphQL introspection.\", enumValueDefinitionName, typeName));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private void assertNonNullType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLNonNull && ((GraphQLNonNull) type).getWrappedType() instanceof GraphQLNonNull) {\n+            SchemaValidationError schemaValidationError = new SchemaValidationError(SchemaValidationErrorType.NonNullWrapNonNullError,\n+                    String.format(\"Non\u2010Null type \\\"%s\\\" must not wrap another Non\u2010Null type.\", GraphQLTypeUtil.simplePrint(type)));\n+            errorCollector.addError(schemaValidationError);\n+        }\n+    }\n+\n+    private List<GraphQLNamedType> filterScalarAndIntrospectionTypes(List<GraphQLNamedType> graphQLNamedTypes) {\n+        if (graphQLNamedTypes == null || graphQLNamedTypes.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        return graphQLNamedTypes.stream().filter(type -> !isScalarOrIntrospectionTypes(type)).collect(Collectors.toList());", "originalCommit": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjk5ODM2OA==", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442998368", "bodyText": "Thanks for your suggestion.", "author": "dugenkui03", "createdAt": "2020-06-19T18:55:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MjczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MzQxNw==", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442653417", "bodyText": "I think a Set is better here as track just the names we already saw.", "author": "andimarek", "createdAt": "2020-06-19T06:23:37Z", "path": "src/main/java/graphql/schema/validation/TypeAndFieldRule.java", "diffHunk": "@@ -0,0 +1,274 @@\n+package graphql.schema.validation;\n+\n+import graphql.language.Type;\n+import graphql.language.TypeName;\n+import graphql.language.UnionTypeDefinition;\n+import graphql.schema.GraphQLArgument;\n+import graphql.schema.GraphQLFieldDefinition;\n+import graphql.schema.GraphQLNamedType;\n+import graphql.schema.GraphQLInterfaceType;\n+import graphql.schema.GraphQLObjectType;\n+import graphql.schema.GraphQLUnionType;\n+import graphql.schema.GraphQLInputObjectType;\n+import graphql.schema.GraphQLSchema;\n+import graphql.schema.GraphQLType;\n+import graphql.schema.GraphQLEnumType;\n+import graphql.schema.GraphQLScalarType;\n+import graphql.schema.GraphQLEnumValueDefinition;\n+import graphql.schema.GraphQLNonNull;\n+import graphql.schema.GraphQLTypeUtil;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * The validation about GraphQLObjectType, GraphQLInterfaceType, GraphQLUnionType, GraphQLEnumType, GraphQLInputObjectType, GraphQLScalarType.\n+ * <pre>\n+ *     <ur>\n+ *         <li>Types must define one or more fields;</li>\n+ *         <li>Enum type must define one or more enum values;</li>\n+ *         <li>Union type must include one or more unique member types;</li>\n+ *         <li>The member types of a Union type must all be Object base types;</li>\n+ *         <li>Non\u2010Null type must not wrap another Non\u2010Null type;</li>\n+ *         <li>Invalid name begin with \"__\" (two underscores).</li>\n+ *     </ur>\n+ * </pre>\n+ * <p></p>\n+ * details in https://spec.graphql.org/June2018/#sec-Type-System\n+ */\n+public class TypeAndFieldRule implements SchemaValidationRule {\n+\n+    private Map<String, GraphQLNamedType> schemaTypeHolder;\n+\n+    @Override\n+    public void check(GraphQLSchema graphQLSchema, SchemaValidationErrorCollector validationErrorCollector) {\n+\n+        List<GraphQLNamedType> allTypesAsList = graphQLSchema.getAllTypesAsList();\n+\n+        List<GraphQLNamedType> filteredType = filterScalarAndIntrospectionTypes(allTypesAsList);\n+\n+        schemaTypeHolder = graphQLSchema.getTypeMap();\n+\n+        checkTypes(filteredType, validationErrorCollector);\n+    }\n+\n+\n+    private void checkTypes(List<GraphQLNamedType> customizedType, SchemaValidationErrorCollector errorCollector) {\n+        if (customizedType == null || customizedType.isEmpty()) {\n+            return;\n+        }\n+\n+        for (GraphQLType type : customizedType) {\n+            checkType(type, errorCollector);\n+        }\n+    }\n+\n+    private void checkType(GraphQLType type, SchemaValidationErrorCollector errorCollector) {\n+        if (type instanceof GraphQLObjectType) {\n+            validateObject((GraphQLObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLInterfaceType) {\n+            validateInterface((GraphQLInterfaceType) type, errorCollector);\n+        } else if (type instanceof GraphQLUnionType) {\n+            validateUnion((GraphQLUnionType) type, errorCollector);\n+        } else if (type instanceof GraphQLEnumType) {\n+            validateEnum((GraphQLEnumType) type, errorCollector);\n+        } else if (type instanceof GraphQLInputObjectType) {\n+            validateInputObject((GraphQLInputObjectType) type, errorCollector);\n+        } else if (type instanceof GraphQLScalarType) {\n+            validateScalar((GraphQLScalarType) type, errorCollector);\n+        }\n+    }\n+\n+    private void validateObject(GraphQLObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.ObjectTypeLackOfFieldError, String.format(\"\\\"%s\\\" must define one or more fields.\", type.getName()));\n+            errorCollector.addError(validationError);\n+            return;\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInterface(GraphQLInterfaceType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        List<GraphQLFieldDefinition> fieldDefinitions = type.getFieldDefinitions();\n+        if (fieldDefinitions == null || fieldDefinitions.size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InterfaceLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+        if (fieldDefinitions != null && fieldDefinitions.size() != 0) {\n+            for (GraphQLFieldDefinition fieldDefinition : fieldDefinitions) {\n+                validateFieldDefinition(type.getName(), fieldDefinition, errorCollector);\n+            }\n+        }\n+    }\n+\n+    private void validateInputObject(GraphQLInputObjectType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+        if (type.getFieldDefinitions() == null || type.getFieldDefinitions().size() == 0) {\n+            SchemaValidationError validationError = new SchemaValidationError(SchemaValidationErrorType.InputObjectTypeLackOfFieldError, type.getName() + \" must define one or more fields.\");\n+            errorCollector.addError(validationError);\n+        }\n+\n+    }\n+\n+    private void validateUnion(GraphQLUnionType type, SchemaValidationErrorCollector errorCollector) {\n+        assertTypeName(type.getName(), errorCollector);\n+\n+        UnionTypeDefinition definition = type.getDefinition();\n+        if (definition == null) {\n+            return;\n+        }\n+\n+        List<Type> memberTypes = definition.getMemberTypes();\n+        if (memberTypes == null || memberTypes.size() == 0) {\n+            SchemaValidationError validationError =\n+                    new SchemaValidationError(SchemaValidationErrorType.UnionTypeLackOfTypeError, String.format(\"Union type \\\"%s\\\" must include one or more unique member types.\", type.getName()));\n+            errorCollector.addError(validationError);\n+        }\n+\n+        List<String> typeNames = new ArrayList<>();", "originalCommit": "a90e4e3fb4f548b2852d70c7c9e7ab47914bd5db", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Mjg2NDU1Mg==", "url": "https://github.com/graphql-java/graphql-java/pull/1955#discussion_r442864552", "bodyText": "Thanks for your suggestion.", "author": "dugenkui03", "createdAt": "2020-06-19T14:13:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjY1MzQxNw=="}], "type": "inlineReview"}, {"oid": "59a137797e75bee67d54f45c4a9032a09399df14", "url": "https://github.com/graphql-java/graphql-java/commit/59a137797e75bee67d54f45c4a9032a09399df14", "message": "add isIntrospectionTypes method in Introspection.", "committedDate": "2020-06-20T11:54:12Z", "type": "forcePushed"}, {"oid": "9ff53d2ee9f4ad74754540badff1edaa0c7d4983", "url": "https://github.com/graphql-java/graphql-java/commit/9ff53d2ee9f4ad74754540badff1edaa0c7d4983", "message": "add isIntrospectionTypes method in Introspection.", "committedDate": "2020-06-21T04:25:05Z", "type": "commit"}, {"oid": "9ff53d2ee9f4ad74754540badff1edaa0c7d4983", "url": "https://github.com/graphql-java/graphql-java/commit/9ff53d2ee9f4ad74754540badff1edaa0c7d4983", "message": "add isIntrospectionTypes method in Introspection.", "committedDate": "2020-06-21T04:25:05Z", "type": "forcePushed"}, {"oid": "982cd2942f03ae564face2dffa1034b08e9de558", "url": "https://github.com/graphql-java/graphql-java/commit/982cd2942f03ae564face2dffa1034b08e9de558", "message": "rules about input object type", "committedDate": "2020-06-25T07:52:57Z", "type": "commit"}, {"oid": "9365b90193fdb1f5898fd7e0c9eccdb70ac53a8e", "url": "https://github.com/graphql-java/graphql-java/commit/9365b90193fdb1f5898fd7e0c9eccdb70ac53a8e", "message": "merge master and fix conflict; update unit test for GraphQLUnionTypy", "committedDate": "2020-09-08T04:58:13Z", "type": "commit"}]}