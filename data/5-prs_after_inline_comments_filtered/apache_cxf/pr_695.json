{"pr_number": 695, "pr_title": "Enable to pass a bval Validator to BeanValidationProvider (it is more\u2026", "pr_createdAt": "2020-09-18T14:46:13Z", "pr_url": "https://github.com/apache/cxf/pull/695", "timeline": [{"oid": "ee67bbd0ae7eb17602d879ebd2f99935a1764705", "url": "https://github.com/apache/cxf/commit/ee67bbd0ae7eb17602d879ebd2f99935a1764705", "message": "Enable to pass a bval Validator to BeanValidationProvider (it is more than enough and faster than creating validators again and again) + enable to cache the fact no validation is needed", "committedDate": "2020-09-18T14:45:44Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc2MzIxNw==", "url": "https://github.com/apache/cxf/pull/695#discussion_r491763217", "bodyText": "Shouldn't it be !runtimeCache.shouldValidateReturnedValue?", "author": "reta", "createdAt": "2020-09-21T01:47:03Z", "path": "core/src/main/java/org/apache/cxf/validation/BeanValidationProvider.java", "diffHunk": "@@ -111,46 +142,81 @@ private static void initFactoryConfig(Configuration<?> factoryCfg, ValidationCon\n     }\n \n     public< T > void validateParameters(final T instance, final Method method, final Object[] arguments) {\n-\n-        final ExecutableValidator methodValidator = getExecutableValidator();\n-        final Set< ConstraintViolation< T > > violations = methodValidator.validateParameters(instance,\n-            method, arguments);\n-\n-        if (!violations.isEmpty()) {\n-            throw new ConstraintViolationException(violations);\n+        final Validator validator = factory.get();\n+        final ExecutableValidator methodValidator = validator.forExecutables();\n+        if (runtimeCache == null || runtimeCache.shouldValidateParameters(validator, method)) {\n+            final Set<ConstraintViolation<T>> violations = methodValidator.validateParameters(instance,\n+                    method, arguments);\n+            if (!violations.isEmpty()) {\n+                throw new ConstraintViolationException(violations);\n+            }\n         }\n     }\n \n     public< T > void validateReturnValue(final T instance, final Method method, final Object returnValue) {\n-        final ExecutableValidator methodValidator = getExecutableValidator();\n-        final Set<ConstraintViolation< T > > violations = methodValidator.validateReturnValue(instance,\n-            method, returnValue);\n-\n-        if (!violations.isEmpty()) {\n-            throw new ResponseConstraintViolationException(violations);\n+        final Validator validator = factory.get();\n+        final ExecutableValidator methodValidator = validator.forExecutables();\n+        if (runtimeCache == null || runtimeCache.shouldValidateReturnedValue(validator, method)) {\n+            final Set<ConstraintViolation<T>> violations = methodValidator.validateReturnValue(instance,\n+                    method, returnValue);\n+            if (!violations.isEmpty()) {\n+                throw new ResponseConstraintViolationException(violations);\n+            }\n         }\n     }\n \n     public< T > void validateReturnValue(final T bean) {\n-        final Set<ConstraintViolation< T > > violations = doValidateBean(bean);\n+        Validator validator = factory.get();\n+        if (runtimeCache != null && bean != null\n+                && !runtimeCache.shouldValidateBean(validator, bean.getClass())) {", "originalCommit": "ee67bbd0ae7eb17602d879ebd2f99935a1764705", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc2Mzg5NQ==", "url": "https://github.com/apache/cxf/pull/695#discussion_r491763895", "bodyText": "Oh nevermind, there is no method in this call", "author": "reta", "createdAt": "2020-09-21T01:51:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc2MzIxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc2MzM4Nw==", "url": "https://github.com/apache/cxf/pull/695#discussion_r491763387", "bodyText": "Probably call to runtime.shouldValidateBean is needed", "author": "reta", "createdAt": "2020-09-21T01:48:12Z", "path": "core/src/main/java/org/apache/cxf/validation/BeanValidationProvider.java", "diffHunk": "@@ -111,46 +142,81 @@ private static void initFactoryConfig(Configuration<?> factoryCfg, ValidationCon\n     }\n \n     public< T > void validateParameters(final T instance, final Method method, final Object[] arguments) {\n-\n-        final ExecutableValidator methodValidator = getExecutableValidator();\n-        final Set< ConstraintViolation< T > > violations = methodValidator.validateParameters(instance,\n-            method, arguments);\n-\n-        if (!violations.isEmpty()) {\n-            throw new ConstraintViolationException(violations);\n+        final Validator validator = factory.get();\n+        final ExecutableValidator methodValidator = validator.forExecutables();\n+        if (runtimeCache == null || runtimeCache.shouldValidateParameters(validator, method)) {\n+            final Set<ConstraintViolation<T>> violations = methodValidator.validateParameters(instance,\n+                    method, arguments);\n+            if (!violations.isEmpty()) {\n+                throw new ConstraintViolationException(violations);\n+            }\n         }\n     }\n \n     public< T > void validateReturnValue(final T instance, final Method method, final Object returnValue) {\n-        final ExecutableValidator methodValidator = getExecutableValidator();\n-        final Set<ConstraintViolation< T > > violations = methodValidator.validateReturnValue(instance,\n-            method, returnValue);\n-\n-        if (!violations.isEmpty()) {\n-            throw new ResponseConstraintViolationException(violations);\n+        final Validator validator = factory.get();\n+        final ExecutableValidator methodValidator = validator.forExecutables();\n+        if (runtimeCache == null || runtimeCache.shouldValidateReturnedValue(validator, method)) {\n+            final Set<ConstraintViolation<T>> violations = methodValidator.validateReturnValue(instance,\n+                    method, returnValue);\n+            if (!violations.isEmpty()) {\n+                throw new ResponseConstraintViolationException(violations);\n+            }\n         }\n     }\n \n     public< T > void validateReturnValue(final T bean) {\n-        final Set<ConstraintViolation< T > > violations = doValidateBean(bean);\n+        Validator validator = factory.get();\n+        if (runtimeCache != null && bean != null\n+                && !runtimeCache.shouldValidateBean(validator, bean.getClass())) {\n+            return;\n+        }\n+        final Set<ConstraintViolation< T > > violations = doValidateBean(validator, bean);\n         if (!violations.isEmpty()) {\n             throw new ResponseConstraintViolationException(violations);\n         }\n     }\n \n     public< T > void validateBean(final T bean) {\n-        final Set<ConstraintViolation< T > > violations = doValidateBean(bean);\n+        final Set<ConstraintViolation< T > > violations = doValidateBean(factory.get(), bean);\n         if (!violations.isEmpty()) {\n             throw new ConstraintViolationException(violations);\n         }\n     }\n \n-    private< T > Set<ConstraintViolation< T > > doValidateBean(final T bean) {\n-        return factory.getValidator().validate(bean);\n+    private< T > Set<ConstraintViolation< T > > doValidateBean(final Validator validator, final T bean) {\n+        if (validator.getConstraintsForClass(bean.getClass()).isBeanConstrained()) {", "originalCommit": "ee67bbd0ae7eb17602d879ebd2f99935a1764705", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTgwMDY1Mg==", "url": "https://github.com/apache/cxf/pull/695#discussion_r491800652", "bodyText": "think this call is always protected by a public call before which already have the exit condition - at least was the intent", "author": "rmannibucau", "createdAt": "2020-09-21T05:33:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc2MzM4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTc2NDQxMw==", "url": "https://github.com/apache/cxf/pull/695#discussion_r491764413", "bodyText": "Should you also check for isBeanConstrained and cache that?", "author": "reta", "createdAt": "2020-09-21T01:55:05Z", "path": "core/src/main/java/org/apache/cxf/validation/BeanValidationProvider.java", "diffHunk": "@@ -111,46 +142,81 @@ private static void initFactoryConfig(Configuration<?> factoryCfg, ValidationCon\n     }\n \n     public< T > void validateParameters(final T instance, final Method method, final Object[] arguments) {\n-\n-        final ExecutableValidator methodValidator = getExecutableValidator();\n-        final Set< ConstraintViolation< T > > violations = methodValidator.validateParameters(instance,\n-            method, arguments);\n-\n-        if (!violations.isEmpty()) {\n-            throw new ConstraintViolationException(violations);\n+        final Validator validator = factory.get();\n+        final ExecutableValidator methodValidator = validator.forExecutables();\n+        if (runtimeCache == null || runtimeCache.shouldValidateParameters(validator, method)) {\n+            final Set<ConstraintViolation<T>> violations = methodValidator.validateParameters(instance,\n+                    method, arguments);\n+            if (!violations.isEmpty()) {\n+                throw new ConstraintViolationException(violations);\n+            }\n         }\n     }\n \n     public< T > void validateReturnValue(final T instance, final Method method, final Object returnValue) {\n-        final ExecutableValidator methodValidator = getExecutableValidator();\n-        final Set<ConstraintViolation< T > > violations = methodValidator.validateReturnValue(instance,\n-            method, returnValue);\n-\n-        if (!violations.isEmpty()) {\n-            throw new ResponseConstraintViolationException(violations);\n+        final Validator validator = factory.get();\n+        final ExecutableValidator methodValidator = validator.forExecutables();\n+        if (runtimeCache == null || runtimeCache.shouldValidateReturnedValue(validator, method)) {\n+            final Set<ConstraintViolation<T>> violations = methodValidator.validateReturnValue(instance,\n+                    method, returnValue);\n+            if (!violations.isEmpty()) {\n+                throw new ResponseConstraintViolationException(violations);\n+            }\n         }\n     }\n \n     public< T > void validateReturnValue(final T bean) {\n-        final Set<ConstraintViolation< T > > violations = doValidateBean(bean);\n+        Validator validator = factory.get();\n+        if (runtimeCache != null && bean != null\n+                && !runtimeCache.shouldValidateBean(validator, bean.getClass())) {\n+            return;\n+        }\n+        final Set<ConstraintViolation< T > > violations = doValidateBean(validator, bean);\n         if (!violations.isEmpty()) {\n             throw new ResponseConstraintViolationException(violations);\n         }\n     }\n \n     public< T > void validateBean(final T bean) {\n-        final Set<ConstraintViolation< T > > violations = doValidateBean(bean);\n+        final Set<ConstraintViolation< T > > violations = doValidateBean(factory.get(), bean);\n         if (!violations.isEmpty()) {\n             throw new ConstraintViolationException(violations);\n         }\n     }\n \n-    private< T > Set<ConstraintViolation< T > > doValidateBean(final T bean) {\n-        return factory.getValidator().validate(bean);\n+    private< T > Set<ConstraintViolation< T > > doValidateBean(final Validator validator, final T bean) {\n+        if (validator.getConstraintsForClass(bean.getClass()).isBeanConstrained()) {\n+            return validator.validate(bean);\n+        }\n+        return emptySet();\n+    }\n+\n+    @Override\n+    public void close() {\n+        close.run();\n     }\n \n-    private ExecutableValidator getExecutableValidator() {\n+    // only created when there is a single validator/factory so it is safe to cache\n+    // note: the validator is passed as param to avoid to create useless ones\n+    private static class RuntimeCache {\n+        private final ConcurrentMap<Class<?>, Boolean> types = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<Method, Boolean> params = new ConcurrentHashMap<>();\n+        private final ConcurrentMap<Method, Boolean> returnedValues = new ConcurrentHashMap<>();\n+\n+        public boolean shouldValidateParameters(final Validator validator, final Method method) {\n+            return params.computeIfAbsent(method, m -> validator.getConstraintsForClass(m.getDeclaringClass())\n+                    .getConstraintsForMethod(m.getName(), m.getParameterTypes())\n+                    .hasConstrainedParameters());\n+        }\n \n-        return factory.getValidator().forExecutables();\n+        public boolean shouldValidateReturnedValue(final Validator validator, final Method method) {\n+            return returnedValues.computeIfAbsent(method, m -> validator.getConstraintsForClass(m.getDeclaringClass())\n+                    .getConstraintsForMethod(m.getName(), method.getParameterTypes())\n+                    .hasConstrainedReturnValue());\n+        }\n+\n+        public boolean shouldValidateBean(final Validator validator, final Class<?> clazz) {\n+            return types.computeIfAbsent(clazz, it -> validator.getConstraintsForClass(it).hasConstraints());", "originalCommit": "ee67bbd0ae7eb17602d879ebd2f99935a1764705", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ef93d642bd52a5e8e6e0e4147a0296fd8eb8bb88", "url": "https://github.com/apache/cxf/commit/ef93d642bd52a5e8e6e0e4147a0296fd8eb8bb88", "message": "shouldValidateBean must call isBeanConstrained and not hasConstraints, thanks @reta", "committedDate": "2020-09-21T05:35:56Z", "type": "commit"}]}