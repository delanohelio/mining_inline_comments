{"pr_number": 683, "pr_title": "CXF-8303: MP: Context propagation impossible using AsyncInvocationInterceptorFactory", "pr_createdAt": "2020-07-15T02:47:46Z", "pr_url": "https://github.com/apache/cxf/pull/683", "timeline": [{"oid": "1aa9a49a6a1546a741302b6f0f1234eab6b0ba5d", "url": "https://github.com/apache/cxf/commit/1aa9a49a6a1546a741302b6f0f1234eab6b0ba5d", "message": "CXF-8303: MP: Context propagation impossible using AsyncInvocationInterceptorFactory", "committedDate": "2020-07-15T02:36:33Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgwNzA1MA==", "url": "https://github.com/apache/cxf/pull/683#discussion_r454807050", "bodyText": "maybe make it lazy to not create it (forkjoin common pool) if the app does not use it and the client for its lifecycle?", "author": "rmannibucau", "createdAt": "2020-07-15T05:49:23Z", "path": "rt/rs/microprofile-client/src/main/java/org/apache/cxf/microprofile/client/MicroProfileClientFactoryBean.java", "diffHunk": "@@ -63,7 +66,7 @@ public MicroProfileClientFactoryBean(MicroProfileClientConfigurableImpl<RestClie\n         super(new MicroProfileServiceFactoryBean());\n         this.configuration = configuration.getConfiguration();\n         this.comparator = MicroProfileClientProviderFactory.createComparator(this);\n-        this.executorService = executorService;\n+        this.executorService = (executorService == null) ? defaultExecutorService() : executorService; ", "originalCommit": "1aa9a49a6a1546a741302b6f0f1234eab6b0ba5d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTM5MTk3MQ==", "url": "https://github.com/apache/cxf/pull/683#discussion_r455391971", "bodyText": "Thanks for the review! This one is very tricky to make lazy. Essentially, this executorService sets (or unsets) the CXF's EXECUTOR_SERVICE_PROPERTY which basically controls how the async client invocation should be handled (it is used by MP and other clients). If we don't provide executorService upfront, the property won't be set and async callback (MPRestClientCallback) is going to be called in the context of CXF's work queue pool. The common ForkJoinPool is present 99.9% of the time so it is not too expensive to reference it (but lazy would be better for sure).", "author": "reta", "createdAt": "2020-07-15T22:05:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgwNzA1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTUyNTI3MA==", "url": "https://github.com/apache/cxf/pull/683#discussion_r455525270", "bodyText": "es = new LazyExecutor();\nlazyexecutor 100% delegates to common one, it just enables to not create threads until it is done so the pool is async, not the facing instance ;)", "author": "rmannibucau", "createdAt": "2020-07-16T05:52:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgwNzA1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjExODAzMg==", "url": "https://github.com/apache/cxf/pull/683#discussion_r456118032", "bodyText": "Sorry, this part I didn't get. With respect to threads (aka workers), ForkJoinPool is 100% lazy: it does not preallocate threads upfront if there is no work to be done, the ForkJoinPool's threads are created only when work is scheduled.", "author": "reta", "createdAt": "2020-07-16T22:40:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgwNzA1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjIzOTM1Ng==", "url": "https://github.com/apache/cxf/pull/683#discussion_r456239356", "bodyText": "Yep, was not a good phrasing choice. Fact is getting triggers the common (var) instantiation which brings a lot of work - for nothing in some cases and that's what I'd like to avoid.\nHaving a facade enables to just load a class and do a new without dependencies (static init) and speed up the startup.\nWe faced it in openwebbeans and this is why we have that wrapper https://github.com/apache/openwebbeans/blob/9b04c5e906294bcad7c61f30b5c5fcc8956b2f17/webbeans-impl/src/main/java/org/apache/webbeans/event/NotificationManager.java#L954.", "author": "rmannibucau", "createdAt": "2020-07-17T06:14:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgwNzA1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4NTg1MA==", "url": "https://github.com/apache/cxf/pull/683#discussion_r456685850", "bodyText": "\ud83d\udc4d thanks for bearing with me, the concern is clear now, fixed!", "author": "reta", "createdAt": "2020-07-17T21:40:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDgwNzA1MA=="}], "type": "inlineReview"}, {"oid": "38d597f17eb678ccb2277fe9d76c204ac5ab3861", "url": "https://github.com/apache/cxf/commit/38d597f17eb678ccb2277fe9d76c204ac5ab3861", "message": "Switched test cases to use JsonbJaxrsProvider", "committedDate": "2020-07-15T21:58:32Z", "type": "commit"}, {"oid": "b39a34885aa688665e6b43c16f4e13725bbb8b27", "url": "https://github.com/apache/cxf/commit/b39a34885aa688665e6b43c16f4e13725bbb8b27", "message": "Made default executor service lazy", "committedDate": "2020-07-17T21:46:27Z", "type": "forcePushed"}, {"oid": "bff35d21b20c1d35fcbe1fb7e4abd3634041280d", "url": "https://github.com/apache/cxf/commit/bff35d21b20c1d35fcbe1fb7e4abd3634041280d", "message": "Made default executor service lazy", "committedDate": "2020-07-18T00:57:46Z", "type": "commit"}, {"oid": "bff35d21b20c1d35fcbe1fb7e4abd3634041280d", "url": "https://github.com/apache/cxf/commit/bff35d21b20c1d35fcbe1fb7e4abd3634041280d", "message": "Made default executor service lazy", "committedDate": "2020-07-18T00:57:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc1OTQ4NQ==", "url": "https://github.com/apache/cxf/pull/683#discussion_r456759485", "bodyText": "Guess you want to bypass the dopriviledge when there is no security manager\nOtherwise looks good to me now", "author": "rmannibucau", "createdAt": "2020-07-18T07:06:52Z", "path": "rt/rs/microprofile-client/src/main/java/org/apache/cxf/microprofile/client/Utils.java", "diffHunk": "@@ -21,34 +21,109 @@\n \n import java.security.AccessController;\n import java.security.PrivilegedAction;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.ExecutionException;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.ForkJoinPool;\n+import java.util.concurrent.Future;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.TimeoutException;\n \n+import org.apache.cxf.jaxrs.client.AbstractClient;\n import org.apache.cxf.jaxrs.ext.MessageContext;\n-import org.apache.cxf.message.Message;\n \n public final class Utils {\n \n     private Utils() {\n     }\n \n-    public static ExecutorService getExecutorService(Message message) {\n-        ExecutorService es = message.get(ExecutorService.class);\n+    public static ExecutorService getExecutorService(MessageContext mc) {\n+        ExecutorService es = (ExecutorService) mc.get(AbstractClient.EXECUTOR_SERVICE_PROPERTY);\n         if (es == null) {\n-            es = AccessController.doPrivileged((PrivilegedAction<ExecutorService>)() -> {\n-                return ForkJoinPool.commonPool();\n-            });\n+            es = getCommonPool();\n         }\n         return es;\n     }\n+    \n+    public static ExecutorService defaultExecutorService() {\n+        return new LazyForkJoinExecutor();\n+    }\n+    \n+    private static class LazyForkJoinExecutor implements ExecutorService {\n+        @Override\n+        public void execute(Runnable command) {\n+            getCommonPool().execute(command);\n+        }\n \n-    public static ExecutorService getExecutorService(MessageContext mc) {\n-        ExecutorService es = (ExecutorService) mc.get(ExecutorService.class);\n-        if (es == null) {\n-            es = AccessController.doPrivileged((PrivilegedAction<ExecutorService>) () -> {\n-                return ForkJoinPool.commonPool();\n-            });\n+        @Override\n+        public void shutdown() {\n+            getCommonPool().shutdown();\n         }\n-        return es;\n+\n+        @Override\n+        public List<Runnable> shutdownNow() {\n+            return getCommonPool().shutdownNow();\n+        }\n+\n+        @Override\n+        public boolean isShutdown() {\n+            return getCommonPool().isShutdown();\n+        }\n+\n+        @Override\n+        public boolean isTerminated() {\n+            return getCommonPool().isTerminated();\n+        }\n+\n+        @Override\n+        public boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException {\n+            return getCommonPool().awaitTermination(timeout, unit);\n+        }\n+\n+        @Override\n+        public <T> Future<T> submit(Callable<T> task) {\n+            return getCommonPool().submit(task);\n+        }\n+\n+        @Override\n+        public <T> Future<T> submit(Runnable task, T result) {\n+            return getCommonPool().submit(task, result);\n+        }\n+\n+        @Override\n+        public Future<?> submit(Runnable task) {\n+            return getCommonPool().submit(task);\n+        }\n+\n+        @Override\n+        public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) throws InterruptedException {\n+            return getCommonPool().invokeAll(tasks);\n+        }\n+\n+        @Override\n+        public <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, long timeout,\n+                TimeUnit unit) throws InterruptedException {\n+            return getCommonPool().invokeAll(tasks, timeout, unit);\n+        }\n+\n+        @Override\n+        public <T> T invokeAny(Collection<? extends Callable<T>> tasks) \n+                throws InterruptedException, ExecutionException {\n+            return getCommonPool().invokeAny(tasks);\n+        }\n+\n+        @Override\n+        public <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, \n+                TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException {\n+            return getCommonPool().invokeAny(tasks, timeout, unit);\n+        }\n+    }\n+    \n+    private static ExecutorService getCommonPool() {\n+        return AccessController.doPrivileged((PrivilegedAction<ExecutorService>) () -> {", "originalCommit": "bff35d21b20c1d35fcbe1fb7e4abd3634041280d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc5MTgwMw==", "url": "https://github.com/apache/cxf/pull/683#discussion_r456791803", "bodyText": "\ud83d\udc4d done, thanks!", "author": "reta", "createdAt": "2020-07-18T13:47:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Njc1OTQ4NQ=="}], "type": "inlineReview"}, {"oid": "9b0d5ef2056a6b5f58d04d9770bbd468d7448067", "url": "https://github.com/apache/cxf/commit/9b0d5ef2056a6b5f58d04d9770bbd468d7448067", "message": "Explicitly check the presence of security manager", "committedDate": "2020-07-18T13:46:41Z", "type": "commit"}, {"oid": "9b0d5ef2056a6b5f58d04d9770bbd468d7448067", "url": "https://github.com/apache/cxf/commit/9b0d5ef2056a6b5f58d04d9770bbd468d7448067", "message": "Explicitly check the presence of security manager", "committedDate": "2020-07-18T13:46:41Z", "type": "forcePushed"}]}