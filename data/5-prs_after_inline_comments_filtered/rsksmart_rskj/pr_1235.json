{"pr_number": 1235, "pr_title": "Refactor of ECKey signature related methods: signatureToKey / recover\u2026", "pr_createdAt": "2020-05-11T18:39:30Z", "pr_url": "https://github.com/rsksmart/rskj/pull/1235", "timeline": [{"oid": "889b5487a52f798220a2ba1e9151e038b9a0b1df", "url": "https://github.com/rsksmart/rskj/commit/889b5487a52f798220a2ba1e9151e038b9a0b1df", "message": "Refactor of ECKey signature related methods: signatureToKey / recoverFromSignature / verify", "committedDate": "2020-05-13T14:56:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyMDQ5OQ==", "url": "https://github.com/rsksmart/rskj/pull/1235#discussion_r428120499", "bodyText": "I would move this somewhere else because CLI tools don't build the node runner and thus they never execute this line. We would want ideally to have this run in those tools as well.", "author": "nicops", "createdAt": "2020-05-20T15:49:40Z", "path": "rskj-core/src/main/java/co/rsk/RskContext.java", "diffHunk": "@@ -848,6 +849,7 @@ protected NodeRunner buildNodeRunner() {\n                     getRepositoryLocator()\n             ));\n         }\n+        Secp256k1.initialize(getRskSystemProperties());", "originalCommit": "889b5487a52f798220a2ba1e9151e038b9a0b1df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODkzMzkxNA==", "url": "https://github.com/rsksmart/rskj/pull/1235#discussion_r428933914", "bodyText": "I've been thinking about that... Where else would you suggest to put it?\nBecause if you dont initialize, it would take default Bouncy Castle. So CLI tools not taking the config... shouldn\u2019t be actually a problem, plus CLI are still experimental.\nAnd couldn't find any other possible way of running (besides CLI) without building a NodeRunner, Fed Node extends from this, so its safe.", "author": "patogallaiovlabs", "createdAt": "2020-05-21T21:45:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyMDQ5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyMTA5NA==", "url": "https://github.com/rsksmart/rskj/pull/1235#discussion_r428121094", "bodyText": "remove these two methods and point to the actual methods in ECDSASignature", "author": "nicops", "createdAt": "2020-05-20T15:50:31Z", "path": "rskj-core/src/test/java/org/ethereum/crypto/signature/ECDSASignatureTest.java", "diffHunk": "@@ -0,0 +1,163 @@\n+/*\n+ * This file is part of RskJ\n+ * Copyright (C) 2017 RSK Labs Ltd.\n+ * (derived from ethereumJ library, Copyright (c) 2016 <ether.camp>)\n+ *\n+ * This program is free software: you can redistribute it and/or modify\n+ * it under the terms of the GNU Lesser General Public License as published by\n+ * the Free Software Foundation, either version 3 of the License, or\n+ * (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program. If not, see <http://www.gnu.org/licenses/>.\n+ */\n+\n+package org.ethereum.crypto.signature;\n+\n+import org.ethereum.crypto.ECKey;\n+import org.ethereum.crypto.HashUtil;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import java.math.BigInteger;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertTrue;\n+\n+public class ECDSASignatureTest {\n+\n+    private final String exampleMessage = \"This is an example of a signed message.\";\n+    private static final BigInteger SECP256K1N = new BigInteger(\"fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141\", 16);\n+\n+    @Test\n+    public void testValidateComponents() {\n+\n+        // Valid components.\n+        // valid v\n+        assertTrue(new ECDSASignature(BigInteger.ONE, BigInteger.ONE, (byte) 27).validateComponents());\n+        assertTrue(new ECDSASignature(BigInteger.ONE, BigInteger.ONE, (byte) 28).validateComponents());\n+        //valid r\n+        assertTrue(new ECDSASignature(SECP256K1N.subtract(BigInteger.ONE), BigInteger.ONE, (byte) 28).validateComponents());\n+        //valid s\n+        assertTrue(new ECDSASignature(BigInteger.ONE, SECP256K1N.subtract(BigInteger.ONE), (byte) 28).validateComponents());\n+\n+        // Not Valid components.\n+        //invalid \"r\"\n+        assertFalse(new ECDSASignature(BigInteger.ZERO, BigInteger.ONE, (byte) 27).validateComponents());\n+        assertFalse(new ECDSASignature(SECP256K1N, BigInteger.ONE, (byte) 27).validateComponents());\n+\n+        //invalid \"s\"\n+        assertFalse(new ECDSASignature(BigInteger.ONE, BigInteger.ZERO, (byte) 27).validateComponents());\n+        assertFalse(new ECDSASignature(BigInteger.ONE, SECP256K1N, (byte) 27).validateComponents());\n+\n+        //invalid \"v\"\n+        assertFalse(new ECDSASignature(BigInteger.ONE, BigInteger.ONE, (byte) 29).validateComponents());\n+        assertFalse(new ECDSASignature(BigInteger.ONE, BigInteger.ONE, (byte) 26).validateComponents());\n+    }\n+\n+    @Test\n+    public void testEquals() {\n+        ECDSASignature expected = new ECDSASignature(BigInteger.ONE, BigInteger.ONE, (byte) 27);\n+\n+        //same instance\n+        assertTrue(expected.equals(expected));\n+\n+        //same values\n+        assertTrue(expected.equals(new ECDSASignature(expected.getR(), expected.getS(), expected.getV())));\n+\n+        //same values - but diff v\n+        assertTrue(expected.equals(new ECDSASignature(expected.getR(), expected.getS(), (byte) 0)));\n+\n+        // null\n+        assertFalse(expected.equals(null));\n+\n+        //dif classes\n+        assertFalse(expected.equals(BigInteger.ZERO));\n+\n+        //diff r\n+        assertFalse(new ECDSASignature(BigInteger.ONE, BigInteger.ONE, (byte) 27).equals(new ECDSASignature(BigInteger.TEN, BigInteger.ONE, (byte) 27)));\n+\n+        //diff s\n+        assertFalse(new ECDSASignature(BigInteger.ONE, BigInteger.ONE, (byte) 27).equals(new ECDSASignature(BigInteger.ONE, BigInteger.TEN, (byte) 27)));\n+\n+    }\n+\n+    @Test\n+    public void testValidateComponents_SignedMsg() {\n+        ECKey key = new ECKey();\n+        byte[] hash = HashUtil.keccak256(exampleMessage.getBytes());\n+        ECDSASignature signature = ECDSASignature.fromSignature(key.sign(hash));\n+        assertTrue(signature.validateComponents());\n+    }\n+\n+    @Test\n+    public void fromComponentsWithRecoveryCalculation() {\n+        ECKey key = new ECKey();\n+        byte[] hash = HashUtil.randomHash();\n+        ECDSASignature signature = ECDSASignature.fromSignature(key.sign(hash));\n+\n+        // With uncompressed public key\n+        ECDSASignature signatureWithCalculatedV = fromComponentsWithRecoveryCalculation(\n+                signature.getR().toByteArray(),\n+                signature.getS().toByteArray(),\n+                hash,\n+                key.getPubKey(false)\n+        );\n+\n+        Assert.assertEquals(signature.getR(), signatureWithCalculatedV.getR());\n+        Assert.assertEquals(signature.getS(), signatureWithCalculatedV.getS());\n+        Assert.assertEquals(signature.getV(), signatureWithCalculatedV.getV());\n+\n+        // With compressed public key\n+        signatureWithCalculatedV = fromComponentsWithRecoveryCalculation(\n+                signature.getR().toByteArray(),\n+                signature.getS().toByteArray(),\n+                hash,\n+                key.getPubKey(true)\n+        );\n+\n+        Assert.assertEquals(signature.getR(), signatureWithCalculatedV.getR());\n+        Assert.assertEquals(signature.getS(), signatureWithCalculatedV.getS());\n+        Assert.assertEquals(signature.getV(), signatureWithCalculatedV.getV());\n+    }\n+\n+\n+    /**\n+     * @param r    -\n+     * @param s    -\n+     * @param hash - the hash used to compute this signature\n+     * @param pub  - public key bytes, used to calculate the recovery byte 'v'\n+     * @return -\n+     */\n+    public static ECDSASignature fromComponentsWithRecoveryCalculation(byte[] r, byte[] s, byte[] hash, byte[] pub) {", "originalCommit": "889b5487a52f798220a2ba1e9151e038b9a0b1df", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODk0NjQyMQ==", "url": "https://github.com/rsksmart/rskj/pull/1235#discussion_r428946421", "bodyText": "Done", "author": "patogallaiovlabs", "createdAt": "2020-05-21T22:18:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyMTA5NA=="}], "type": "inlineReview"}, {"oid": "68b16d2feed66a06b36d8d9dd0f6b3d26afa4b80", "url": "https://github.com/rsksmart/rskj/commit/68b16d2feed66a06b36d8d9dd0f6b3d26afa4b80", "message": "Refactor of ECKey signature related methods: signatureToKey / recoverFromSignature / verify", "committedDate": "2020-05-21T22:09:06Z", "type": "commit"}, {"oid": "b87a273748a17e5db747378eb88b315a15f723aa", "url": "https://github.com/rsksmart/rskj/commit/b87a273748a17e5db747378eb88b315a15f723aa", "message": "removing duplicate code", "committedDate": "2020-05-21T22:09:06Z", "type": "commit"}, {"oid": "b87a273748a17e5db747378eb88b315a15f723aa", "url": "https://github.com/rsksmart/rskj/commit/b87a273748a17e5db747378eb88b315a15f723aa", "message": "removing duplicate code", "committedDate": "2020-05-21T22:09:06Z", "type": "forcePushed"}, {"oid": "5d9978ca65c992cfc62224b799f6d792575ac898", "url": "https://github.com/rsksmart/rskj/commit/5d9978ca65c992cfc62224b799f6d792575ac898", "message": "fix smells", "committedDate": "2020-05-21T22:27:04Z", "type": "commit"}, {"oid": "0fbf1690bfd4d9e0caaa06d1dc82750e251f2993", "url": "https://github.com/rsksmart/rskj/commit/0fbf1690bfd4d9e0caaa06d1dc82750e251f2993", "message": "Nico comment, on initialization of Singleton. Minor rename refactor", "committedDate": "2020-05-26T19:18:14Z", "type": "commit"}]}