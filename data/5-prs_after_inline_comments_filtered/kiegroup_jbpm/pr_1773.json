{"pr_number": 1773, "pr_title": "[JBPM-9411] Provide a way to access task details in boundary event", "pr_createdAt": "2020-10-08T13:07:53Z", "pr_url": "https://github.com/kiegroup/jbpm/pull/1773", "timeline": [{"oid": "583afd715f43efec0b8a9a164be9b4bac76924ad", "url": "https://github.com/kiegroup/jbpm/commit/583afd715f43efec0b8a9a164be9b4bac76924ad", "message": "[JBPM-9411] Provide a way to access task details in boundary event", "committedDate": "2020-10-08T13:58:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM2Nzc0NA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r513367744", "bodyText": "Empy doc description for the class", "author": "afalhambra", "createdAt": "2020-10-28T11:26:01Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/timer/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.timer;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.manager.audit.VariableInstanceLog;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import junit.framework.Assert;\n+\n+/**\n+ */", "originalCommit": "583afd715f43efec0b8a9a164be9b4bac76924ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MTUzMA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515791530", "bodyText": "removed", "author": "elguardian", "createdAt": "2020-11-02T07:56:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM2Nzc0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM2ODY3OA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r513368678", "bodyText": "small typo\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final static String WORK_ITEM_HANLDER_TASK = \"Human Task\";\n          \n          \n            \n                private final static String WORK_ITEM_HANDLER_TASK = \"Human Task\";", "author": "afalhambra", "createdAt": "2020-10-28T11:27:34Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/timer/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.timer;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.manager.audit.VariableInstanceLog;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import junit.framework.Assert;\n+\n+/**\n+ */\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_FILE_NAME = \"org/jbpm/test/functional/timer/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    private final static String WORK_ITEM_HANLDER_TASK = \"Human Task\";", "originalCommit": "583afd715f43efec0b8a9a164be9b4bac76924ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MTY5OQ==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515791699", "bodyText": "done", "author": "elguardian", "createdAt": "2020-11-02T07:56:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM2ODY3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM3MDg5NA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r513370894", "bodyText": "These properties are not used in the test - I think they should be removed", "author": "afalhambra", "createdAt": "2020-10-28T11:31:32Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/timer/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.timer;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.manager.audit.VariableInstanceLog;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import junit.framework.Assert;\n+\n+/**\n+ */\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_FILE_NAME = \"org/jbpm/test/functional/timer/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    private final static String WORK_ITEM_HANLDER_TASK = \"Human Task\";\n+    \n+    private final static String TIMER_FIRED_PROP = \"timerFired\";\n+    private final static String TIMER_FIRED_TIME_PROP = \"afterTimerTime\";\n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+    \n+    @Before\n+    public void setup() { \n+        System.clearProperty(TIMER_FIRED_PROP);\n+        System.clearProperty(TIMER_FIRED_TIME_PROP);\n+    }", "originalCommit": "583afd715f43efec0b8a9a164be9b4bac76924ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MTc4NQ==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515791785", "bodyText": "removed. don't needed anymore", "author": "elguardian", "createdAt": "2020-11-02T07:56:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM3MDg5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM3MTUxNg==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r513371516", "bodyText": "This private method is not used anywhere in the code - please remove\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private void completeWork(KieSession ksession, HumanTaskMockHandler humanTaskMockHandler) {\n          \n          \n            \n                    assertTrue(\"The work item task handler does not have a work item!\", humanTaskMockHandler.workItem != null);\n          \n          \n            \n                    long workItemId = humanTaskMockHandler.workItem.getId();\n          \n          \n            \n                    assertTrue(\"work item id not saved\", workItemId > 0);\n          \n          \n            \n                    \n          \n          \n            \n                    // The Human Task is completed\n          \n          \n            \n                    Map<String, Object> results = new HashMap<String, Object>();\n          \n          \n            \n                    try {\n          \n          \n            \n                        ksession.getWorkItemManager().completeWorkItem(workItemId, results);\n          \n          \n            \n                    } catch (Exception e) {\n          \n          \n            \n                        logger.warn(\"Work item could not be completed!\");\n          \n          \n            \n                        e.printStackTrace();\n          \n          \n            \n                        fail(e.getClass().getSimpleName() + \" thrown when completing work item: \" + e.getMessage());\n          \n          \n            \n                    }\n          \n          \n            \n                }", "author": "afalhambra", "createdAt": "2020-10-28T11:32:39Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/timer/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.timer;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.manager.audit.VariableInstanceLog;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import junit.framework.Assert;\n+\n+/**\n+ */\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_FILE_NAME = \"org/jbpm/test/functional/timer/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    private final static String WORK_ITEM_HANLDER_TASK = \"Human Task\";\n+    \n+    private final static String TIMER_FIRED_PROP = \"timerFired\";\n+    private final static String TIMER_FIRED_TIME_PROP = \"afterTimerTime\";\n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+    \n+    @Before\n+    public void setup() { \n+        System.clearProperty(TIMER_FIRED_PROP);\n+        System.clearProperty(TIMER_FIRED_TIME_PROP);\n+    }\n+    \n+    @Test\n+    public void boundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        /**\n+         * First we set up everything and start the process\n+         */\n+        createRuntimeManager(PROCESS_FILE_NAME);\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        ProcessInstance process = registerHTHandlerAndStartProcess(ksession, humanTaskMockHandler);\n+        \n+        sleepAndVerifyTimerRuns(process.getState());\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(3, logs.size());\n+    \n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+\n+    private ProcessInstance registerHTHandlerAndStartProcess(KieSession ksession, HumanTaskMockHandler humanTaskMockHandler) { \n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+    \n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+        \n+        return process;\n+    \n+    }\n+\n+    private void completeWork(KieSession ksession, HumanTaskMockHandler humanTaskMockHandler) {\n+        assertTrue(\"The work item task handler does not have a work item!\", humanTaskMockHandler.workItem != null);\n+        long workItemId = humanTaskMockHandler.workItem.getId();\n+        assertTrue(\"work item id not saved\", workItemId > 0);\n+        \n+        // The Human Task is completed\n+        Map<String, Object> results = new HashMap<String, Object>();\n+        try {\n+            ksession.getWorkItemManager().completeWorkItem(workItemId, results);\n+        } catch (Exception e) {\n+            logger.warn(\"Work item could not be completed!\");\n+            e.printStackTrace();\n+            fail(e.getClass().getSimpleName() + \" thrown when completing work item: \" + e.getMessage());\n+        }\n+    }", "originalCommit": "583afd715f43efec0b8a9a164be9b4bac76924ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MTg5MQ==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515791891", "bodyText": "corrected. IT is used.", "author": "elguardian", "createdAt": "2020-11-02T07:56:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM3MTUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM3NDM4Ng==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r513374386", "bodyText": "We should try to use static import as it's already imported\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Assert.assertEquals(3, logs.size());\n          \n          \n            \n                    assertEquals(3, logs.size());", "author": "afalhambra", "createdAt": "2020-10-28T11:37:47Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/timer/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.timer;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.manager.audit.VariableInstanceLog;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import junit.framework.Assert;\n+\n+/**\n+ */\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_FILE_NAME = \"org/jbpm/test/functional/timer/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    private final static String WORK_ITEM_HANLDER_TASK = \"Human Task\";\n+    \n+    private final static String TIMER_FIRED_PROP = \"timerFired\";\n+    private final static String TIMER_FIRED_TIME_PROP = \"afterTimerTime\";\n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+    \n+    @Before\n+    public void setup() { \n+        System.clearProperty(TIMER_FIRED_PROP);\n+        System.clearProperty(TIMER_FIRED_TIME_PROP);\n+    }\n+    \n+    @Test\n+    public void boundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        /**\n+         * First we set up everything and start the process\n+         */\n+        createRuntimeManager(PROCESS_FILE_NAME);\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        ProcessInstance process = registerHTHandlerAndStartProcess(ksession, humanTaskMockHandler);\n+        \n+        sleepAndVerifyTimerRuns(process.getState());\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(3, logs.size());", "originalCommit": "583afd715f43efec0b8a9a164be9b4bac76924ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MzA4Nw==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515793087", "bodyText": "removed", "author": "elguardian", "createdAt": "2020-11-02T07:59:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM3NDM4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM3ODcxMA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r513378710", "bodyText": "Maybe it's a little clearer if we use TimeUnit class instead.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        int sleep = 2000;\n          \n          \n            \n                        logger.debug(\"Sleeping {} seconds\", sleep / 1000);\n          \n          \n            \n                        Thread.sleep(sleep);\n          \n          \n            \n                        logger.debug(\"Sleeping {} seconds\", 2);\n          \n          \n            \n                        TimeUnit.SECONDS.sleep(2);", "author": "afalhambra", "createdAt": "2020-10-28T11:45:37Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/timer/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.timer;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.manager.audit.VariableInstanceLog;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import junit.framework.Assert;\n+\n+/**\n+ */\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_FILE_NAME = \"org/jbpm/test/functional/timer/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    private final static String WORK_ITEM_HANLDER_TASK = \"Human Task\";\n+    \n+    private final static String TIMER_FIRED_PROP = \"timerFired\";\n+    private final static String TIMER_FIRED_TIME_PROP = \"afterTimerTime\";\n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+    \n+    @Before\n+    public void setup() { \n+        System.clearProperty(TIMER_FIRED_PROP);\n+        System.clearProperty(TIMER_FIRED_TIME_PROP);\n+    }\n+    \n+    @Test\n+    public void boundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        /**\n+         * First we set up everything and start the process\n+         */\n+        createRuntimeManager(PROCESS_FILE_NAME);\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        ProcessInstance process = registerHTHandlerAndStartProcess(ksession, humanTaskMockHandler);\n+        \n+        sleepAndVerifyTimerRuns(process.getState());\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(3, logs.size());\n+    \n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+\n+    private ProcessInstance registerHTHandlerAndStartProcess(KieSession ksession, HumanTaskMockHandler humanTaskMockHandler) { \n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+    \n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+        \n+        return process;\n+    \n+    }\n+\n+    private void completeWork(KieSession ksession, HumanTaskMockHandler humanTaskMockHandler) {\n+        assertTrue(\"The work item task handler does not have a work item!\", humanTaskMockHandler.workItem != null);\n+        long workItemId = humanTaskMockHandler.workItem.getId();\n+        assertTrue(\"work item id not saved\", workItemId > 0);\n+        \n+        // The Human Task is completed\n+        Map<String, Object> results = new HashMap<String, Object>();\n+        try {\n+            ksession.getWorkItemManager().completeWorkItem(workItemId, results);\n+        } catch (Exception e) {\n+            logger.warn(\"Work item could not be completed!\");\n+            e.printStackTrace();\n+            fail(e.getClass().getSimpleName() + \" thrown when completing work item: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void sleepAndVerifyTimerRuns(int processState) throws InterruptedException { \n+        // wait 3 seconds to see if the boss is notified\n+        if (processState == ProcessInstance.STATE_ACTIVE) {\n+            int sleep = 2000;\n+            logger.debug(\"Sleeping {} seconds\", sleep / 1000);\n+            Thread.sleep(sleep);", "originalCommit": "583afd715f43efec0b8a9a164be9b4bac76924ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM3OTY1Mg==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r513379652", "bodyText": "Maybe it's worth adding and assertEquals instead?", "author": "afalhambra", "createdAt": "2020-10-28T11:47:20Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/timer/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.timer;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.manager.audit.VariableInstanceLog;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import junit.framework.Assert;\n+\n+/**\n+ */\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_FILE_NAME = \"org/jbpm/test/functional/timer/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    private final static String WORK_ITEM_HANLDER_TASK = \"Human Task\";\n+    \n+    private final static String TIMER_FIRED_PROP = \"timerFired\";\n+    private final static String TIMER_FIRED_TIME_PROP = \"afterTimerTime\";\n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+    \n+    @Before\n+    public void setup() { \n+        System.clearProperty(TIMER_FIRED_PROP);\n+        System.clearProperty(TIMER_FIRED_TIME_PROP);\n+    }\n+    \n+    @Test\n+    public void boundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        /**\n+         * First we set up everything and start the process\n+         */\n+        createRuntimeManager(PROCESS_FILE_NAME);\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        ProcessInstance process = registerHTHandlerAndStartProcess(ksession, humanTaskMockHandler);\n+        \n+        sleepAndVerifyTimerRuns(process.getState());\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(3, logs.size());\n+    \n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+\n+    private ProcessInstance registerHTHandlerAndStartProcess(KieSession ksession, HumanTaskMockHandler humanTaskMockHandler) { \n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+    \n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+        \n+        return process;\n+    \n+    }\n+\n+    private void completeWork(KieSession ksession, HumanTaskMockHandler humanTaskMockHandler) {\n+        assertTrue(\"The work item task handler does not have a work item!\", humanTaskMockHandler.workItem != null);\n+        long workItemId = humanTaskMockHandler.workItem.getId();\n+        assertTrue(\"work item id not saved\", workItemId > 0);\n+        \n+        // The Human Task is completed\n+        Map<String, Object> results = new HashMap<String, Object>();\n+        try {\n+            ksession.getWorkItemManager().completeWorkItem(workItemId, results);\n+        } catch (Exception e) {\n+            logger.warn(\"Work item could not be completed!\");\n+            e.printStackTrace();\n+            fail(e.getClass().getSimpleName() + \" thrown when completing work item: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void sleepAndVerifyTimerRuns(int processState) throws InterruptedException { \n+        // wait 3 seconds to see if the boss is notified\n+        if (processState == ProcessInstance.STATE_ACTIVE) {", "originalCommit": "583afd715f43efec0b8a9a164be9b4bac76924ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM5Mzc0Ng==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r513393746", "bodyText": "I'm missing similar logic or behavior for compensation events at \n  \n    \n      jbpm/jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/BoundaryEventHandler.java\n    \n    \n         Line 294\n      in\n      583afd7\n    \n    \n    \n    \n\n        \n          \n           protected void handleCompensationNode(final Node node, final Element element, final String uri, \n        \n    \n  \n\n\nShouldn't we add the same logic as we agreed in BAPL?", "author": "afalhambra", "createdAt": "2020-10-28T12:12:35Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/BoundaryEventHandler.java", "diffHunk": "@@ -277,6 +280,12 @@ protected void handleTimerNode(final Node node, final Element element, final Str\n                     eventNode.setMetaData(\"TimeDate\", timeDate);\n                 }\n \n+            } else if (\"dataOutput\".equals(nodeName)) {\n+                String id = ((Element) xmlNode).getAttribute(\"id\");\n+                String outputName = ((Element) xmlNode).getAttribute(\"name\");\n+                dataOutputs.put(id, outputName);\n+            } else if (\"dataOutputAssociation\".equals(nodeName)) {\n+                readDataOutputAssociation(xmlNode, eventNode);", "originalCommit": "583afd715f43efec0b8a9a164be9b4bac76924ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzM5NzIyMA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r513397220", "bodyText": "Maybe you can use something like\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    while (it.hasNext()) {\n          \n          \n            \n                        DataAssociation association = it.next();\n          \n          \n            \n                        if (forEachOutVariable.equals(association.getTarget())) {\n          \n          \n            \n                            it.remove();\n          \n          \n            \n                        }\n          \n          \n            \n                    }\n          \n          \n            \n                    outMapping.removeIf(association -> forEachOutVariable.equals(association.getTarget()));", "author": "afalhambra", "createdAt": "2020-10-28T12:18:55Z", "path": "jbpm-flow/src/main/java/org/jbpm/workflow/core/node/BoundaryEventNode.java", "diffHunk": "@@ -32,6 +41,50 @@ public void setAttachedToNodeId(String attachedToNodeId) {\n         this.attachedToNodeId = attachedToNodeId;\n     }\n \n+    \n+    public void addOutMapping(String parameterName, String variableName) {\n+        outMapping.add(new DataAssociation(parameterName, variableName, null, null));\n+    }\n+    \n+    public void adjustOutMapping(String forEachOutVariable) {\n+        Iterator<DataAssociation> it = outMapping.iterator();\n+        while (it.hasNext()) {\n+            DataAssociation association = it.next();\n+            if (forEachOutVariable.equals(association.getTarget())) {\n+                it.remove();\n+            }\n+        }", "originalCommit": "583afd715f43efec0b8a9a164be9b4bac76924ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQyNjUwOQ==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r513426509", "bodyText": "NodeInstanceContainer cast is redundant\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Collection<NodeInstance> nodeInstances = ((NodeInstanceContainer) getNodeInstanceContainer()).getNodeInstances();\n          \n          \n            \n                    Collection<NodeInstance> nodeInstances = getNodeInstanceContainer().getNodeInstances();", "author": "afalhambra", "createdAt": "2020-10-28T13:07:24Z", "path": "jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/BoundaryEventNodeInstance.java", "diffHunk": "@@ -48,8 +49,30 @@ public void signalEvent(String type, Object event) {\n             }\n         }\n     }\n+    \n+    @Override\n+    public BoundaryEventNode getEventNode() {\n+        return (BoundaryEventNode) super.getEventNode();\n+    }\n+    \n+    @Override\n+    public void triggerCompleted(String type, Object event) {\n+        Collection<NodeInstance> nodeInstances = ((NodeInstanceContainer) getNodeInstanceContainer()).getNodeInstances();", "originalCommit": "583afd715f43efec0b8a9a164be9b4bac76924ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1ODkwOQ==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r513458909", "bodyText": "typo\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected void mapOutputSetVariables(NodeInstance nodeInstance, List<DataAssociation> dataOututAssoctiation, Map<String, Object> ouputData) {\n          \n          \n            \n                protected void mapOutputSetVariables(NodeInstance nodeInstance, List<DataAssociation> dataOutputAssociation, Map<String, Object> outputData) {", "author": "afalhambra", "createdAt": "2020-10-28T13:51:05Z", "path": "jbpm-flow/src/main/java/org/jbpm/workflow/instance/impl/ExtendedNodeInstanceImpl.java", "diffHunk": "@@ -57,7 +72,80 @@ protected void triggerEvent(String type) {\n \t\t\t}\n \t\t}\n \t}\n+    protected void mapOutputSetVariables(NodeInstance nodeInstance, List<DataAssociation> dataOututAssoctiation, Map<String, Object> ouputData) {", "originalCommit": "583afd715f43efec0b8a9a164be9b4bac76924ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ1OTE0Nw==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r513459147", "bodyText": "same as above", "author": "afalhambra", "createdAt": "2020-10-28T13:51:19Z", "path": "jbpm-flow/src/main/java/org/jbpm/workflow/instance/impl/ExtendedNodeInstanceImpl.java", "diffHunk": "@@ -57,7 +72,80 @@ protected void triggerEvent(String type) {\n \t\t\t}\n \t\t}\n \t}\n+    protected void mapOutputSetVariables(NodeInstance nodeInstance, List<DataAssociation> dataOututAssoctiation, Map<String, Object> ouputData) {\n+        this.mapOutputSetVariables(nodeInstance, dataOututAssoctiation, ouputData, (target, value) -> {});\n+    }\n+    protected void mapOutputSetVariables(NodeInstance nodeInstance, List<DataAssociation> dataOututAssoctiation, Map<String, Object> ouputData, BiConsumer<String, Object> parameterSet) {", "originalCommit": "583afd715f43efec0b8a9a164be9b4bac76924ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2MjQwMg==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r513462402", "bodyText": "please remove unused imports.", "author": "afalhambra", "createdAt": "2020-10-28T13:55:35Z", "path": "jbpm-flow/src/main/java/org/jbpm/workflow/instance/node/WorkItemNodeInstance.java", "diffHunk": "@@ -55,7 +55,7 @@\n import org.jbpm.workflow.instance.WorkflowProcessInstance;\n import org.jbpm.workflow.instance.WorkflowRuntimeException;\n import org.jbpm.workflow.instance.impl.NodeInstanceResolverFactory;\n-import org.jbpm.workflow.instance.impl.WorkItemResolverFactory;\n+import org.jbpm.workflow.instance.impl.MapResolverFactory;", "originalCommit": "583afd715f43efec0b8a9a164be9b4bac76924ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ2OTUyMg==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r513469522", "bodyText": "Shouldn't be better to create a new internal HashMap for instance? wdyt?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tthis.data = data;\n          \n          \n            \n            \t\tthis.data = new HashMap<>(data);", "author": "afalhambra", "createdAt": "2020-10-28T14:04:38Z", "path": "jbpm-flow/src/main/java/org/jbpm/workflow/instance/impl/MapResolverFactory.java", "diffHunk": "@@ -16,27 +16,28 @@\n \n package org.jbpm.workflow.instance.impl;\n \n-import org.kie.api.runtime.process.WorkItem;\n+import java.util.Map;\n+\n import org.mvel2.integration.VariableResolver;\n import org.mvel2.integration.impl.ImmutableDefaultFactory;\n import org.mvel2.integration.impl.SimpleValueResolver;\n \n-public class WorkItemResolverFactory extends ImmutableDefaultFactory {\n+public class MapResolverFactory extends ImmutableDefaultFactory {\n \n \tprivate static final long serialVersionUID = 510l;\n \t\n-\tprivate WorkItem workItem;\n+\tprivate Map<String, Object> data;\n \t\n-\tpublic WorkItemResolverFactory(WorkItem workItem) {\n-\t\tthis.workItem = workItem;\n+\tpublic MapResolverFactory(Map<String, Object> data) {\n+\t\tthis.data = data;", "originalCommit": "583afd715f43efec0b8a9a164be9b4bac76924ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzQ3MTQ1Mw==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r513471453", "bodyText": "unused imports", "author": "afalhambra", "createdAt": "2020-10-28T14:07:05Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xpath/XPATHAssignmentAction.java", "diffHunk": "@@ -16,16 +16,21 @@\n \n package org.jbpm.bpmn2.xpath;\n \n+import java.util.function.BiFunction;\n+import java.util.function.Function;\n+import java.util.function.Supplier;", "originalCommit": "583afd715f43efec0b8a9a164be9b4bac76924ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyMDczOA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r513520738", "bodyText": "ContextResolver is no longer needed", "author": "afalhambra", "createdAt": "2020-10-28T15:06:15Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xpath/XPATHAssignmentBuilder.java", "diffHunk": "@@ -16,16 +16,30 @@\n \n package org.jbpm.bpmn2.xpath;\n \n+import java.util.function.BiFunction;\n+\n import org.drools.compiler.rule.builder.PackageBuildContext;\n import org.jbpm.process.builder.AssignmentBuilder;\n import org.jbpm.process.core.ContextResolver;\n+import org.jbpm.process.instance.impl.AssignmentProducer;", "originalCommit": "583afd715f43efec0b8a9a164be9b4bac76924ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyMTc5OQ==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r513521799", "bodyText": "Not used", "author": "afalhambra", "createdAt": "2020-10-28T15:07:30Z", "path": "jbpm-flow-builder/src/main/java/org/jbpm/process/builder/WorkItemNodeBuilder.java", "diffHunk": "@@ -19,19 +19,26 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.function.BiConsumer;", "originalCommit": "583afd715f43efec0b8a9a164be9b4bac76924ad", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyMTkwOA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r513521908", "bodyText": "same as above", "author": "afalhambra", "createdAt": "2020-10-28T15:07:38Z", "path": "jbpm-flow-builder/src/main/java/org/jbpm/process/builder/WorkItemNodeBuilder.java", "diffHunk": "@@ -19,19 +19,26 @@\n import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n+import java.util.function.BiConsumer;\n+import java.util.function.BiFunction;\n+import java.util.function.Supplier;", "originalCommit": "583afd715f43efec0b8a9a164be9b4bac76924ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MjEzNg==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515792136", "bodyText": "removed", "author": "elguardian", "createdAt": "2020-11-02T07:57:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzUyMTkwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU4MTExNg==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r513581116", "bodyText": "we're actually waiting for 2 seconds", "author": "afalhambra", "createdAt": "2020-10-28T16:21:03Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/timer/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.timer;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.manager.audit.VariableInstanceLog;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import junit.framework.Assert;\n+\n+/**\n+ */\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_FILE_NAME = \"org/jbpm/test/functional/timer/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    private final static String WORK_ITEM_HANLDER_TASK = \"Human Task\";\n+    \n+    private final static String TIMER_FIRED_PROP = \"timerFired\";\n+    private final static String TIMER_FIRED_TIME_PROP = \"afterTimerTime\";\n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+    \n+    @Before\n+    public void setup() { \n+        System.clearProperty(TIMER_FIRED_PROP);\n+        System.clearProperty(TIMER_FIRED_TIME_PROP);\n+    }\n+    \n+    @Test\n+    public void boundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        /**\n+         * First we set up everything and start the process\n+         */\n+        createRuntimeManager(PROCESS_FILE_NAME);\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        ProcessInstance process = registerHTHandlerAndStartProcess(ksession, humanTaskMockHandler);\n+        \n+        sleepAndVerifyTimerRuns(process.getState());\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(3, logs.size());\n+    \n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+\n+    private ProcessInstance registerHTHandlerAndStartProcess(KieSession ksession, HumanTaskMockHandler humanTaskMockHandler) { \n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+    \n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+        \n+        return process;\n+    \n+    }\n+\n+    private void completeWork(KieSession ksession, HumanTaskMockHandler humanTaskMockHandler) {\n+        assertTrue(\"The work item task handler does not have a work item!\", humanTaskMockHandler.workItem != null);\n+        long workItemId = humanTaskMockHandler.workItem.getId();\n+        assertTrue(\"work item id not saved\", workItemId > 0);\n+        \n+        // The Human Task is completed\n+        Map<String, Object> results = new HashMap<String, Object>();\n+        try {\n+            ksession.getWorkItemManager().completeWorkItem(workItemId, results);\n+        } catch (Exception e) {\n+            logger.warn(\"Work item could not be completed!\");\n+            e.printStackTrace();\n+            fail(e.getClass().getSimpleName() + \" thrown when completing work item: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void sleepAndVerifyTimerRuns(int processState) throws InterruptedException { \n+        // wait 3 seconds to see if the boss is notified", "originalCommit": "583afd715f43efec0b8a9a164be9b4bac76924ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MjU5MA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515792590", "bodyText": "removed", "author": "elguardian", "createdAt": "2020-11-02T07:58:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU4MTExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU4MjE4Mw==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r513582183", "bodyText": "as per interval in timer is set to 500ms###1s and we wait for 2 seconds, expected is 4 instead of 3.\nThough I would try to increase interval period, to avoid having any potential flaky test based on timing, just in case, wdyt?", "author": "afalhambra", "createdAt": "2020-10-28T16:22:27Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/timer/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.timer;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.manager.audit.VariableInstanceLog;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import junit.framework.Assert;\n+\n+/**\n+ */\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_FILE_NAME = \"org/jbpm/test/functional/timer/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    private final static String WORK_ITEM_HANLDER_TASK = \"Human Task\";\n+    \n+    private final static String TIMER_FIRED_PROP = \"timerFired\";\n+    private final static String TIMER_FIRED_TIME_PROP = \"afterTimerTime\";\n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+    \n+    @Before\n+    public void setup() { \n+        System.clearProperty(TIMER_FIRED_PROP);\n+        System.clearProperty(TIMER_FIRED_TIME_PROP);\n+    }\n+    \n+    @Test\n+    public void boundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        /**\n+         * First we set up everything and start the process\n+         */\n+        createRuntimeManager(PROCESS_FILE_NAME);\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        ProcessInstance process = registerHTHandlerAndStartProcess(ksession, humanTaskMockHandler);\n+        \n+        sleepAndVerifyTimerRuns(process.getState());\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(3, logs.size());", "originalCommit": "583afd715f43efec0b8a9a164be9b4bac76924ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5MjUyMA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515792520", "bodyText": "it does not start in 0. but 500. anyway iwe are not testing that anymore. removed.", "author": "elguardian", "createdAt": "2020-11-02T07:58:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU4MjE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU4NTk2NA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r513585964", "bodyText": "This class is registered as a work item handler, but never used afterwards in the test. Shouldn't we try to recover HumanTaskNodeInstance object from here as per requirements in BAPL? wdyt?", "author": "afalhambra", "createdAt": "2020-10-28T16:27:19Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/timer/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,153 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.timer;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.manager.audit.VariableInstanceLog;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import junit.framework.Assert;\n+\n+/**\n+ */\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_FILE_NAME = \"org/jbpm/test/functional/timer/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    private final static String WORK_ITEM_HANLDER_TASK = \"Human Task\";\n+    \n+    private final static String TIMER_FIRED_PROP = \"timerFired\";\n+    private final static String TIMER_FIRED_TIME_PROP = \"afterTimerTime\";\n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+    \n+    @Before\n+    public void setup() { \n+        System.clearProperty(TIMER_FIRED_PROP);\n+        System.clearProperty(TIMER_FIRED_TIME_PROP);\n+    }\n+    \n+    @Test\n+    public void boundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        /**\n+         * First we set up everything and start the process\n+         */\n+        createRuntimeManager(PROCESS_FILE_NAME);\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        ProcessInstance process = registerHTHandlerAndStartProcess(ksession, humanTaskMockHandler);\n+        \n+        sleepAndVerifyTimerRuns(process.getState());\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(3, logs.size());\n+    \n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+\n+    private ProcessInstance registerHTHandlerAndStartProcess(KieSession ksession, HumanTaskMockHandler humanTaskMockHandler) { \n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+    \n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+        \n+        return process;\n+    \n+    }\n+\n+    private void completeWork(KieSession ksession, HumanTaskMockHandler humanTaskMockHandler) {\n+        assertTrue(\"The work item task handler does not have a work item!\", humanTaskMockHandler.workItem != null);\n+        long workItemId = humanTaskMockHandler.workItem.getId();\n+        assertTrue(\"work item id not saved\", workItemId > 0);\n+        \n+        // The Human Task is completed\n+        Map<String, Object> results = new HashMap<String, Object>();\n+        try {\n+            ksession.getWorkItemManager().completeWorkItem(workItemId, results);\n+        } catch (Exception e) {\n+            logger.warn(\"Work item could not be completed!\");\n+            e.printStackTrace();\n+            fail(e.getClass().getSimpleName() + \" thrown when completing work item: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void sleepAndVerifyTimerRuns(int processState) throws InterruptedException { \n+        // wait 3 seconds to see if the boss is notified\n+        if (processState == ProcessInstance.STATE_ACTIVE) {\n+            int sleep = 2000;\n+            logger.debug(\"Sleeping {} seconds\", sleep / 1000);\n+            Thread.sleep(sleep);\n+            logger.debug(\"Awake!\");\n+        }\n+       \n+    }\n+\n+    \n+\n+    private static class HumanTaskMockHandler implements WorkItemHandler {", "originalCommit": "583afd715f43efec0b8a9a164be9b4bac76924ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc5Mjc0NQ==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515792745", "bodyText": "it is used now", "author": "elguardian", "createdAt": "2020-11-02T07:58:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzU4NTk2NA=="}], "type": "inlineReview"}, {"oid": "4251784fdc2fb51b882cba5ec2e2566e2dca7880", "url": "https://github.com/kiegroup/jbpm/commit/4251784fdc2fb51b882cba5ec2e2566e2dca7880", "message": "[JBPM-9411] Provide a way to access task details in boundary event", "committedDate": "2020-10-29T17:45:58Z", "type": "forcePushed"}, {"oid": "8abe5301c328c3f6cc637a761ef7085b74be35e1", "url": "https://github.com/kiegroup/jbpm/commit/8abe5301c328c3f6cc637a761ef7085b74be35e1", "message": "[JBPM-9411] Provide a way to access task details in boundary event", "committedDate": "2020-11-02T07:59:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA3NTc4MA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515075780", "bodyText": "IMHO though class is declared as final it should be good to keep this consistent\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected static final Logger logger = LoggerFactory.getLogger(DataAssociationFactory.class);\n          \n          \n            \n                private static final Logger logger = LoggerFactory.getLogger(DataAssociationFactory.class);", "author": "afalhambra", "createdAt": "2020-10-30T12:53:59Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/elements/DataAssociationFactory.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.bpmn2.xml.elements;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.Transformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class DataAssociationFactory {\n+    \n+    protected static final Logger logger = LoggerFactory.getLogger(DataAssociationFactory.class);", "originalCommit": "4251784fdc2fb51b882cba5ec2e2566e2dca7880", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk5OTA1Mw==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515999053", "bodyText": "done", "author": "elguardian", "createdAt": "2020-11-02T14:14:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA3NTc4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA3NjI1OA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515076258", "bodyText": "Why not declared them as import instead of using fully qualifier name?", "author": "afalhambra", "createdAt": "2020-10-30T12:54:57Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/elements/DataAssociationFactory.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.bpmn2.xml.elements;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.Transformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class DataAssociationFactory {\n+    \n+    protected static final Logger logger = LoggerFactory.getLogger(DataAssociationFactory.class);\n+    \n+    private DataAssociationFactory() {\n+        // do nothing\n+    }\n+\n+    public static DataAssociation readDataOutputAssociation(org.w3c.dom.Node xmlNode, Map<String, String> dataOutputs) {\n+\n+        org.w3c.dom.NodeList nodeList = xmlNode.getChildNodes();", "originalCommit": "4251784fdc2fb51b882cba5ec2e2566e2dca7880", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk5OTk5Ng==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515999996", "bodyText": "removed.", "author": "elguardian", "createdAt": "2020-11-02T14:16:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA3NjI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA3NzM5NQ==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515077395", "bodyText": "might be worth checking xmlNode and dataOutputs are not null", "author": "afalhambra", "createdAt": "2020-10-30T12:56:59Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/elements/DataAssociationFactory.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.bpmn2.xml.elements;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.Transformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class DataAssociationFactory {\n+    \n+    protected static final Logger logger = LoggerFactory.getLogger(DataAssociationFactory.class);\n+    \n+    private DataAssociationFactory() {\n+        // do nothing\n+    }\n+\n+    public static DataAssociation readDataOutputAssociation(org.w3c.dom.Node xmlNode, Map<String, String> dataOutputs) {\n+\n+        org.w3c.dom.NodeList nodeList = xmlNode.getChildNodes();", "originalCommit": "4251784fdc2fb51b882cba5ec2e2566e2dca7880", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTk5OTkxMA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515999910", "bodyText": "none of them can be null as per design of node handler", "author": "elguardian", "createdAt": "2020-11-02T14:16:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA3NzM5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA4MDg2Mw==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515080863", "bodyText": "IMO this should be declared as private as it would be odd to have a DataAssociationFactory class returning an assignment object.", "author": "afalhambra", "createdAt": "2020-10-30T13:03:35Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/elements/DataAssociationFactory.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.bpmn2.xml.elements;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.Transformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class DataAssociationFactory {\n+    \n+    protected static final Logger logger = LoggerFactory.getLogger(DataAssociationFactory.class);\n+    \n+    private DataAssociationFactory() {\n+        // do nothing\n+    }\n+\n+    public static DataAssociation readDataOutputAssociation(org.w3c.dom.Node xmlNode, Map<String, String> dataOutputs) {\n+\n+        org.w3c.dom.NodeList nodeList = xmlNode.getChildNodes();\n+        String source = null;\n+        String target = null;\n+        Transformation transformation = null;\n+        List<Assignment> assignment = new ArrayList<>();\n+        for(int i = 0; i < nodeList.getLength(); i++) {\n+            org.w3c.dom.Node subNode = nodeList.item(i);\n+            switch(subNode.getNodeName()) {\n+                case \"sourceRef\":\n+                {\n+                    source = subNode.getTextContent();\n+                    if(!dataOutputs.containsKey(source)) {\n+                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes().getNamedItem(\"id\"), source);\n+                    }\n+                    // indirection\n+                    source = dataOutputs.get(source);\n+                    break;\n+                }\n+                case \"targetRef\":\n+                {\n+                    target = subNode.getTextContent();\n+                    break;\n+                }\n+                case \"transformation\":\n+                {\n+                    String lang = subNode.getAttributes().getNamedItem(\"language\").getNodeValue();\n+                    String expression = subNode.getTextContent();\n+                    transformation = new Transformation(lang, expression, source);\n+                    break;\n+                }\n+                case \"assignment\":\n+                {\n+                    assignment.add(readAssignment(subNode));\n+                    break;\n+                }\n+            }\n+\n+        }\n+        return new DataAssociation(source, target, assignment, transformation);\n+    }\n+    \n+    public static Assignment readAssignment(org.w3c.dom.Node xmlNode) {", "originalCommit": "4251784fdc2fb51b882cba5ec2e2566e2dca7880", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAwMDcxMw==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r516000713", "bodyText": "it is ok. as assignment can only be within data associations.", "author": "elguardian", "createdAt": "2020-11-02T14:17:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA4MDg2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA4MjcxOA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515082718", "bodyText": "Maybe it's worth adding a default branch statement for the switch and log a warning message", "author": "afalhambra", "createdAt": "2020-10-30T13:06:55Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/elements/DataAssociationFactory.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.bpmn2.xml.elements;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.Transformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class DataAssociationFactory {\n+    \n+    protected static final Logger logger = LoggerFactory.getLogger(DataAssociationFactory.class);\n+    \n+    private DataAssociationFactory() {\n+        // do nothing\n+    }\n+\n+    public static DataAssociation readDataOutputAssociation(org.w3c.dom.Node xmlNode, Map<String, String> dataOutputs) {\n+\n+        org.w3c.dom.NodeList nodeList = xmlNode.getChildNodes();\n+        String source = null;\n+        String target = null;\n+        Transformation transformation = null;\n+        List<Assignment> assignment = new ArrayList<>();\n+        for(int i = 0; i < nodeList.getLength(); i++) {\n+            org.w3c.dom.Node subNode = nodeList.item(i);\n+            switch(subNode.getNodeName()) {\n+                case \"sourceRef\":\n+                {\n+                    source = subNode.getTextContent();\n+                    if(!dataOutputs.containsKey(source)) {\n+                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes().getNamedItem(\"id\"), source);\n+                    }\n+                    // indirection\n+                    source = dataOutputs.get(source);\n+                    break;\n+                }\n+                case \"targetRef\":\n+                {\n+                    target = subNode.getTextContent();\n+                    break;\n+                }\n+                case \"transformation\":\n+                {\n+                    String lang = subNode.getAttributes().getNamedItem(\"language\").getNodeValue();\n+                    String expression = subNode.getTextContent();\n+                    transformation = new Transformation(lang, expression, source);\n+                    break;\n+                }\n+                case \"assignment\":\n+                {\n+                    assignment.add(readAssignment(subNode));\n+                    break;\n+                }\n+            }", "originalCommit": "4251784fdc2fb51b882cba5ec2e2566e2dca7880", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAwMTIyNw==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r516001227", "bodyText": "it is not possible to reach another state as it only can be from or to. Parser is throwing already a warning or error depending of the situation.", "author": "elguardian", "createdAt": "2020-11-02T14:18:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA4MjcxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTA4Mjc4OA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515082788", "bodyText": "Maybe it's worth adding a default branch statement for the switch and log a warning message", "author": "afalhambra", "createdAt": "2020-10-30T13:07:03Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/elements/DataAssociationFactory.java", "diffHunk": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.bpmn2.xml.elements;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.workflow.core.node.Assignment;\n+import org.jbpm.workflow.core.node.DataAssociation;\n+import org.jbpm.workflow.core.node.Transformation;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public final class DataAssociationFactory {\n+    \n+    protected static final Logger logger = LoggerFactory.getLogger(DataAssociationFactory.class);\n+    \n+    private DataAssociationFactory() {\n+        // do nothing\n+    }\n+\n+    public static DataAssociation readDataOutputAssociation(org.w3c.dom.Node xmlNode, Map<String, String> dataOutputs) {\n+\n+        org.w3c.dom.NodeList nodeList = xmlNode.getChildNodes();\n+        String source = null;\n+        String target = null;\n+        Transformation transformation = null;\n+        List<Assignment> assignment = new ArrayList<>();\n+        for(int i = 0; i < nodeList.getLength(); i++) {\n+            org.w3c.dom.Node subNode = nodeList.item(i);\n+            switch(subNode.getNodeName()) {\n+                case \"sourceRef\":\n+                {\n+                    source = subNode.getTextContent();\n+                    if(!dataOutputs.containsKey(source)) {\n+                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes().getNamedItem(\"id\"), source);\n+                    }\n+                    // indirection\n+                    source = dataOutputs.get(source);\n+                    break;\n+                }\n+                case \"targetRef\":\n+                {\n+                    target = subNode.getTextContent();\n+                    break;\n+                }\n+                case \"transformation\":\n+                {\n+                    String lang = subNode.getAttributes().getNamedItem(\"language\").getNodeValue();\n+                    String expression = subNode.getTextContent();\n+                    transformation = new Transformation(lang, expression, source);\n+                    break;\n+                }\n+                case \"assignment\":\n+                {\n+                    assignment.add(readAssignment(subNode));\n+                    break;\n+                }\n+            }\n+\n+        }\n+        return new DataAssociation(source, target, assignment, transformation);\n+    }\n+    \n+    public static Assignment readAssignment(org.w3c.dom.Node xmlNode) {\n+        org.w3c.dom.NodeList nodeList = xmlNode.getChildNodes();\n+        String from = null;\n+        String to = null;\n+        for(int i = 0; i < nodeList.getLength(); i++) {\n+            org.w3c.dom.Node subNode = nodeList.item(i);\n+            switch (subNode.getNodeName()) {\n+                case \"from\":\n+                    from = subNode.getTextContent();\n+                    break;\n+                case \"to\":\n+                    to = subNode.getTextContent();\n+                    break;\n+            }", "originalCommit": "4251784fdc2fb51b882cba5ec2e2566e2dca7880", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE0NzQ0NA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515147444", "bodyText": "typo\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private final static String WORK_ITEM_HANLDER_TASK = \"Human Task\";\n          \n          \n            \n                private final static String WORK_ITEM_HANDLER_TASK = \"Human Task\";", "author": "afalhambra", "createdAt": "2020-10-30T14:42:29Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/event/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.event;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.jbpm.test.entity.Person;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.manager.audit.VariableInstanceLog;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import junit.framework.Assert;\n+\n+\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_TIMER_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    \n+    private final static String PROCESS_MESSAGE_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryMessageProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_MESSAGE_NAME = \"BoundaryMessageEventProcess\";\n+    \n+    private final static String PROCESS_SIGNAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundarySignalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_SIGNAL_NAME = \"BoundarySignalEventProcess\";\n+    \n+    private final static String PROCESS_ERROR_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryErrorProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ERROR_NAME = \"BoundaryErrorEventProcess\";\n+    \n+    private final static String PROCESS_ESCALATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryEscalationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ESCALATION_NAME = \"BoundaryEscalationEventProcess\";\n+    \n+    private final static String PROCESS_COMPENSATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryCompensationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_COMPENSATION_NAME = \"BoundaryCompensationEventProcess\";\n+    \n+    private final static String PROCESS_CONDITIONAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryConditionalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_CONDITIONAL_NAME = \"BoundaryConditionalEventProcess\";\n+    \n+    private final static String WORK_ITEM_HANLDER_TASK = \"Human Task\";", "originalCommit": "4251784fdc2fb51b882cba5ec2e2566e2dca7880", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE5ODM4NQ==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515198385", "bodyText": "You could take advantage of an existing and already registered workItem handler already defined in the parent classes and since some of the functionality is pretty much the same, maybe it's worth reusing it instead.", "author": "afalhambra", "createdAt": "2020-10-30T15:49:42Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/event/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.event;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.jbpm.test.entity.Person;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.manager.audit.VariableInstanceLog;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import junit.framework.Assert;\n+\n+\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_TIMER_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    \n+    private final static String PROCESS_MESSAGE_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryMessageProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_MESSAGE_NAME = \"BoundaryMessageEventProcess\";\n+    \n+    private final static String PROCESS_SIGNAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundarySignalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_SIGNAL_NAME = \"BoundarySignalEventProcess\";\n+    \n+    private final static String PROCESS_ERROR_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryErrorProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ERROR_NAME = \"BoundaryErrorEventProcess\";\n+    \n+    private final static String PROCESS_ESCALATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryEscalationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ESCALATION_NAME = \"BoundaryEscalationEventProcess\";\n+    \n+    private final static String PROCESS_COMPENSATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryCompensationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_COMPENSATION_NAME = \"BoundaryCompensationEventProcess\";\n+    \n+    private final static String PROCESS_CONDITIONAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryConditionalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_CONDITIONAL_NAME = \"BoundaryConditionalEventProcess\";\n+    \n+    private final static String WORK_ITEM_HANLDER_TASK = \"Human Task\";\n+    \n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+        \n+    @Test\n+    public void testBoundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_TIMER_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        sleepAndVerifyTimerRuns();\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(12, logs.size());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+\n+    @Test\n+    public void testBoundaryEventMessageAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_MESSAGE_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_MESSAGE_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"Message-MyMessage\",  new Person());\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(4, logs.size());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+    \n+    @Test\n+    public void testBoundaryEventSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_SIGNAL_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_SIGNAL_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"MySignal\",  new Person());\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(4, logs.size());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+    \n+    @Test\n+    public void testBoundaryErrorSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_ERROR_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler(true);\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_ERROR_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_COMPLETED] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_COMPLETED, processState);\n+\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(5, logs.size());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+    \n+    \n+    @Test\n+    public void testBoundaryEscalationSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_ESCALATION_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler(true);\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_ESCALATION_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_COMPLETED] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_COMPLETED, processState);\n+\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(2, logs.size());\n+        \n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+    \n+    @Test\n+    public void testBoundaryCompensationSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_COMPENSATION_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_COMPENSATION_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        completeWork(ksession, humanTaskMockHandler);\n+        ksession.signalEvent(\"Compensation\", \"_2\");\n+        \n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(4, logs.size());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+    \n+    @Test\n+    public void testBoundaryConditionalSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_CONDITIONAL_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_CONDITIONAL_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        ksession.signalEvent(\"RuleFlowStateEvent-\" + PROCESS_CONDITIONAL_NAME + \"-4-_2\" , new org.jbpm.test.entity.Person(1L, \"john\"));\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(4, logs.size());\n+\n+       \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+    \n+    private void completeWork(KieSession ksession, HumanTaskMockHandler humanTaskMockHandler) {\n+        assertTrue(\"The work item task handler does not have a work item!\", humanTaskMockHandler.workItem != null);\n+        long workItemId = humanTaskMockHandler.workItem.getId();\n+        assertTrue(\"work item id not saved\", workItemId > 0);\n+        \n+        // The Human Task is completed\n+        Map<String, Object> results = new HashMap<String, Object>();\n+        try {\n+            ksession.getWorkItemManager().completeWorkItem(workItemId, results);\n+        } catch (Exception e) {\n+            logger.warn(\"Work item could not be completed!\");\n+            e.printStackTrace();\n+            fail(e.getClass().getSimpleName() + \" thrown when completing work item: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void sleepAndVerifyTimerRuns()  { \n+        try {\n+            int sleep = 3000;\n+            logger.debug(\"Sleeping {} seconds\", sleep / 1000);\n+            Thread.sleep(sleep);\n+            logger.debug(\"Awake!\");\n+        } catch(InterruptedException e) {\n+            logger.error(\"System was interrupted\");\n+            fail(\"Junit was interrupted\");\n+        }\n+\n+    }\n+\n+\n+\n+    private static class HumanTaskMockHandler implements WorkItemHandler {\n+\n+        private org.kie.api.runtime.process.WorkItemManager workItemManager;\n+        private org.kie.api.runtime.process.WorkItem workItem;\n+\n+        private boolean error;\n+        \n+        public HumanTaskMockHandler() {\n+            this(false);\n+        }\n+        \n+        public HumanTaskMockHandler(boolean error) {\n+            this.error = error;\n+        }\n+        \n+        public void executeWorkItem(org.kie.api.runtime.process.WorkItem workItem, org.kie.api.runtime.process.WorkItemManager manager) {\n+            this.workItem = workItem;\n+            this.workItemManager = manager;\n+\n+            if(error) {\n+                throw new RuntimeException(\"this is an error\");\n+            }\n+            logger.debug(\"Work completed!\");\n+        }\n+\n+        public void abortWorkItem(org.kie.api.runtime.process.WorkItem workItem, org.kie.api.runtime.process.WorkItemManager manager) {\n+            this.workItemManager.abortWorkItem(workItem.getId());\n+            logger.debug(\"Work aborted.\");\n+        }\n+        \n+\n+    }", "originalCommit": "4251784fdc2fb51b882cba5ec2e2566e2dca7880", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc4NTA0MA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515785040", "bodyText": "I would set them to log info level so it's easy to know what's going on in the test by just looking at the output", "author": "afalhambra", "createdAt": "2020-11-02T07:40:26Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/event/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.event;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.jbpm.test.entity.Person;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.manager.audit.VariableInstanceLog;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import junit.framework.Assert;\n+\n+\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_TIMER_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    \n+    private final static String PROCESS_MESSAGE_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryMessageProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_MESSAGE_NAME = \"BoundaryMessageEventProcess\";\n+    \n+    private final static String PROCESS_SIGNAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundarySignalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_SIGNAL_NAME = \"BoundarySignalEventProcess\";\n+    \n+    private final static String PROCESS_ERROR_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryErrorProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ERROR_NAME = \"BoundaryErrorEventProcess\";\n+    \n+    private final static String PROCESS_ESCALATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryEscalationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ESCALATION_NAME = \"BoundaryEscalationEventProcess\";\n+    \n+    private final static String PROCESS_COMPENSATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryCompensationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_COMPENSATION_NAME = \"BoundaryCompensationEventProcess\";\n+    \n+    private final static String PROCESS_CONDITIONAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryConditionalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_CONDITIONAL_NAME = \"BoundaryConditionalEventProcess\";\n+    \n+    private final static String WORK_ITEM_HANLDER_TASK = \"Human Task\";\n+    \n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+        \n+    @Test\n+    public void testBoundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_TIMER_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        sleepAndVerifyTimerRuns();\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(12, logs.size());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+\n+    @Test\n+    public void testBoundaryEventMessageAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_MESSAGE_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_MESSAGE_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"Message-MyMessage\",  new Person());\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(4, logs.size());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+    \n+    @Test\n+    public void testBoundaryEventSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_SIGNAL_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_SIGNAL_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"MySignal\",  new Person());\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(4, logs.size());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+    \n+    @Test\n+    public void testBoundaryErrorSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_ERROR_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler(true);\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_ERROR_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_COMPLETED] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_COMPLETED, processState);\n+\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(5, logs.size());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+    \n+    \n+    @Test\n+    public void testBoundaryEscalationSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_ESCALATION_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler(true);\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_ESCALATION_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_COMPLETED] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_COMPLETED, processState);\n+\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(2, logs.size());\n+        \n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+    \n+    @Test\n+    public void testBoundaryCompensationSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_COMPENSATION_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_COMPENSATION_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        completeWork(ksession, humanTaskMockHandler);\n+        ksession.signalEvent(\"Compensation\", \"_2\");\n+        \n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(4, logs.size());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+    \n+    @Test\n+    public void testBoundaryConditionalSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_CONDITIONAL_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_CONDITIONAL_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        ksession.signalEvent(\"RuleFlowStateEvent-\" + PROCESS_CONDITIONAL_NAME + \"-4-_2\" , new org.jbpm.test.entity.Person(1L, \"john\"));\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(4, logs.size());\n+\n+       \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+    \n+    private void completeWork(KieSession ksession, HumanTaskMockHandler humanTaskMockHandler) {\n+        assertTrue(\"The work item task handler does not have a work item!\", humanTaskMockHandler.workItem != null);\n+        long workItemId = humanTaskMockHandler.workItem.getId();\n+        assertTrue(\"work item id not saved\", workItemId > 0);\n+        \n+        // The Human Task is completed\n+        Map<String, Object> results = new HashMap<String, Object>();\n+        try {\n+            ksession.getWorkItemManager().completeWorkItem(workItemId, results);\n+        } catch (Exception e) {\n+            logger.warn(\"Work item could not be completed!\");\n+            e.printStackTrace();\n+            fail(e.getClass().getSimpleName() + \" thrown when completing work item: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void sleepAndVerifyTimerRuns()  { \n+        try {\n+            int sleep = 3000;\n+            logger.debug(\"Sleeping {} seconds\", sleep / 1000);\n+            Thread.sleep(sleep);\n+            logger.debug(\"Awake!\");", "originalCommit": "4251784fdc2fb51b882cba5ec2e2566e2dca7880", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTc4NTQ4Ng==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515785486", "bodyText": "Maybe it's worth passing the exception object to be output in the error log", "author": "afalhambra", "createdAt": "2020-11-02T07:41:30Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/event/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,378 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.event;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.jbpm.test.entity.Person;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.manager.audit.VariableInstanceLog;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import junit.framework.Assert;\n+\n+\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_TIMER_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    \n+    private final static String PROCESS_MESSAGE_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryMessageProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_MESSAGE_NAME = \"BoundaryMessageEventProcess\";\n+    \n+    private final static String PROCESS_SIGNAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundarySignalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_SIGNAL_NAME = \"BoundarySignalEventProcess\";\n+    \n+    private final static String PROCESS_ERROR_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryErrorProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ERROR_NAME = \"BoundaryErrorEventProcess\";\n+    \n+    private final static String PROCESS_ESCALATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryEscalationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ESCALATION_NAME = \"BoundaryEscalationEventProcess\";\n+    \n+    private final static String PROCESS_COMPENSATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryCompensationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_COMPENSATION_NAME = \"BoundaryCompensationEventProcess\";\n+    \n+    private final static String PROCESS_CONDITIONAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryConditionalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_CONDITIONAL_NAME = \"BoundaryConditionalEventProcess\";\n+    \n+    private final static String WORK_ITEM_HANLDER_TASK = \"Human Task\";\n+    \n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+        \n+    @Test\n+    public void testBoundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_TIMER_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        sleepAndVerifyTimerRuns();\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(12, logs.size());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+\n+    @Test\n+    public void testBoundaryEventMessageAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_MESSAGE_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_MESSAGE_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"Message-MyMessage\",  new Person());\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(4, logs.size());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+    \n+    @Test\n+    public void testBoundaryEventSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_SIGNAL_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_SIGNAL_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"MySignal\",  new Person());\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(4, logs.size());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+    \n+    @Test\n+    public void testBoundaryErrorSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_ERROR_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler(true);\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_ERROR_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_COMPLETED] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_COMPLETED, processState);\n+\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(5, logs.size());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+    \n+    \n+    @Test\n+    public void testBoundaryEscalationSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_ESCALATION_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler(true);\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_ESCALATION_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_COMPLETED] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_COMPLETED, processState);\n+\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(2, logs.size());\n+        \n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+    \n+    @Test\n+    public void testBoundaryCompensationSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_COMPENSATION_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_COMPENSATION_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        completeWork(ksession, humanTaskMockHandler);\n+        ksession.signalEvent(\"Compensation\", \"_2\");\n+        \n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(4, logs.size());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+    \n+    @Test\n+    public void testBoundaryConditionalSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_CONDITIONAL_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANLDER_TASK, humanTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_CONDITIONAL_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        ksession.signalEvent(\"RuleFlowStateEvent-\" + PROCESS_CONDITIONAL_NAME + \"-4-_2\" , new org.jbpm.test.entity.Person(1L, \"john\"));\n+        List<? extends VariableInstanceLog> logs = getLogService().findVariableInstances(process.getId());\n+        Assert.assertEquals(4, logs.size());\n+\n+       \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+    }\n+    \n+    private void completeWork(KieSession ksession, HumanTaskMockHandler humanTaskMockHandler) {\n+        assertTrue(\"The work item task handler does not have a work item!\", humanTaskMockHandler.workItem != null);\n+        long workItemId = humanTaskMockHandler.workItem.getId();\n+        assertTrue(\"work item id not saved\", workItemId > 0);\n+        \n+        // The Human Task is completed\n+        Map<String, Object> results = new HashMap<String, Object>();\n+        try {\n+            ksession.getWorkItemManager().completeWorkItem(workItemId, results);\n+        } catch (Exception e) {\n+            logger.warn(\"Work item could not be completed!\");\n+            e.printStackTrace();\n+            fail(e.getClass().getSimpleName() + \" thrown when completing work item: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void sleepAndVerifyTimerRuns()  { \n+        try {\n+            int sleep = 3000;\n+            logger.debug(\"Sleeping {} seconds\", sleep / 1000);\n+            Thread.sleep(sleep);\n+            logger.debug(\"Awake!\");\n+        } catch(InterruptedException e) {\n+            logger.error(\"System was interrupted\");", "originalCommit": "4251784fdc2fb51b882cba5ec2e2566e2dca7880", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgxODEzOA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515818138", "bodyText": "Not thrown within this method\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testBoundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n          \n          \n            \n                public void testBoundaryEventTimerAndCompleteHumanTask() {", "author": "afalhambra", "createdAt": "2020-11-02T08:50:14Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/event/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.event;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.jbpm.test.entity.Person;\n+import org.jbpm.workflow.instance.node.CompositeContextNodeInstance;\n+import org.jbpm.workflow.instance.node.HumanTaskNodeInstance;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_TIMER_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    \n+    private final static String PROCESS_MESSAGE_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryMessageProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_MESSAGE_NAME = \"BoundaryMessageEventProcess\";\n+    \n+    private final static String PROCESS_SIGNAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundarySignalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_SIGNAL_NAME = \"BoundarySignalEventProcess\";\n+    \n+    private final static String PROCESS_ERROR_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryErrorProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ERROR_NAME = \"BoundaryErrorEventProcess\";\n+    \n+    private final static String PROCESS_ESCALATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryEscalationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ESCALATION_NAME = \"BoundaryEscalationEventProcess\";\n+    \n+    private final static String PROCESS_COMPENSATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryCompensationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_COMPENSATION_NAME = \"BoundaryCompensationEventProcess\";\n+    \n+    private final static String PROCESS_CONDITIONAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryConditionalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_CONDITIONAL_NAME = \"BoundaryConditionalEventProcess\";\n+    \n+    private final static String WORK_ITEM_HANDLER_TASK = \"Human Task\";\n+    private final static String WORK_ITEM_HANDLER_DATA = \"DataCaptureTask\";\n+    \n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+        \n+    @Test\n+    public void testBoundaryEventTimerAndCompleteHumanTask() throws InterruptedException {", "originalCommit": "8abe5301c328c3f6cc637a761ef7085b74be35e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgyNzM4NA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515827384", "bodyText": "same as above", "author": "afalhambra", "createdAt": "2020-11-02T09:07:09Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/event/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.event;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.jbpm.test.entity.Person;\n+import org.jbpm.workflow.instance.node.CompositeContextNodeInstance;\n+import org.jbpm.workflow.instance.node.HumanTaskNodeInstance;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_TIMER_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    \n+    private final static String PROCESS_MESSAGE_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryMessageProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_MESSAGE_NAME = \"BoundaryMessageEventProcess\";\n+    \n+    private final static String PROCESS_SIGNAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundarySignalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_SIGNAL_NAME = \"BoundarySignalEventProcess\";\n+    \n+    private final static String PROCESS_ERROR_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryErrorProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ERROR_NAME = \"BoundaryErrorEventProcess\";\n+    \n+    private final static String PROCESS_ESCALATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryEscalationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ESCALATION_NAME = \"BoundaryEscalationEventProcess\";\n+    \n+    private final static String PROCESS_COMPENSATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryCompensationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_COMPENSATION_NAME = \"BoundaryCompensationEventProcess\";\n+    \n+    private final static String PROCESS_CONDITIONAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryConditionalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_CONDITIONAL_NAME = \"BoundaryConditionalEventProcess\";\n+    \n+    private final static String WORK_ITEM_HANDLER_TASK = \"Human Task\";\n+    private final static String WORK_ITEM_HANDLER_DATA = \"DataCaptureTask\";\n+    \n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+        \n+    @Test\n+    public void testBoundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_TIMER_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        sleepAndVerifyTimerRuns();\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"event\"), 1L);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Timer-_2-500ms###1s-4\");\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"workItem\") instanceof WorkItem);\n+    }\n+\n+    @Test\n+    public void testBoundaryEventMessageAndCompleteHumanTask() throws InterruptedException {", "originalCommit": "8abe5301c328c3f6cc637a761ef7085b74be35e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzMTc1NA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515831754", "bodyText": "Shouldn't we add a check for workItem param here as well?", "author": "afalhambra", "createdAt": "2020-11-02T09:15:11Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/event/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.event;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.jbpm.test.entity.Person;\n+import org.jbpm.workflow.instance.node.CompositeContextNodeInstance;\n+import org.jbpm.workflow.instance.node.HumanTaskNodeInstance;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_TIMER_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    \n+    private final static String PROCESS_MESSAGE_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryMessageProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_MESSAGE_NAME = \"BoundaryMessageEventProcess\";\n+    \n+    private final static String PROCESS_SIGNAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundarySignalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_SIGNAL_NAME = \"BoundarySignalEventProcess\";\n+    \n+    private final static String PROCESS_ERROR_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryErrorProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ERROR_NAME = \"BoundaryErrorEventProcess\";\n+    \n+    private final static String PROCESS_ESCALATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryEscalationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ESCALATION_NAME = \"BoundaryEscalationEventProcess\";\n+    \n+    private final static String PROCESS_COMPENSATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryCompensationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_COMPENSATION_NAME = \"BoundaryCompensationEventProcess\";\n+    \n+    private final static String PROCESS_CONDITIONAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryConditionalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_CONDITIONAL_NAME = \"BoundaryConditionalEventProcess\";\n+    \n+    private final static String WORK_ITEM_HANDLER_TASK = \"Human Task\";\n+    private final static String WORK_ITEM_HANDLER_DATA = \"DataCaptureTask\";\n+    \n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+        \n+    @Test\n+    public void testBoundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_TIMER_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        sleepAndVerifyTimerRuns();\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"event\"), 1L);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Timer-_2-500ms###1s-4\");\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"workItem\") instanceof WorkItem);\n+    }\n+\n+    @Test\n+    public void testBoundaryEventMessageAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_MESSAGE_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_MESSAGE_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"Message-MyMessage\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Message-MyMessage\");", "originalCommit": "8abe5301c328c3f6cc637a761ef7085b74be35e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzMTk1Mg==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515831952", "bodyText": "same as above", "author": "afalhambra", "createdAt": "2020-11-02T09:15:30Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/event/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.event;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.jbpm.test.entity.Person;\n+import org.jbpm.workflow.instance.node.CompositeContextNodeInstance;\n+import org.jbpm.workflow.instance.node.HumanTaskNodeInstance;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_TIMER_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    \n+    private final static String PROCESS_MESSAGE_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryMessageProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_MESSAGE_NAME = \"BoundaryMessageEventProcess\";\n+    \n+    private final static String PROCESS_SIGNAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundarySignalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_SIGNAL_NAME = \"BoundarySignalEventProcess\";\n+    \n+    private final static String PROCESS_ERROR_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryErrorProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ERROR_NAME = \"BoundaryErrorEventProcess\";\n+    \n+    private final static String PROCESS_ESCALATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryEscalationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ESCALATION_NAME = \"BoundaryEscalationEventProcess\";\n+    \n+    private final static String PROCESS_COMPENSATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryCompensationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_COMPENSATION_NAME = \"BoundaryCompensationEventProcess\";\n+    \n+    private final static String PROCESS_CONDITIONAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryConditionalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_CONDITIONAL_NAME = \"BoundaryConditionalEventProcess\";\n+    \n+    private final static String WORK_ITEM_HANDLER_TASK = \"Human Task\";\n+    private final static String WORK_ITEM_HANDLER_DATA = \"DataCaptureTask\";\n+    \n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+        \n+    @Test\n+    public void testBoundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_TIMER_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        sleepAndVerifyTimerRuns();\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"event\"), 1L);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Timer-_2-500ms###1s-4\");\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"workItem\") instanceof WorkItem);\n+    }\n+\n+    @Test\n+    public void testBoundaryEventMessageAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_MESSAGE_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_MESSAGE_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"Message-MyMessage\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Message-MyMessage\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryEventSignalAndCompleteHumanTask() throws InterruptedException {", "originalCommit": "8abe5301c328c3f6cc637a761ef7085b74be35e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzMzQ3Nw==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515833477", "bodyText": "Shouldn't we add a check for workItem param here as well?", "author": "afalhambra", "createdAt": "2020-11-02T09:18:10Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/event/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.event;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.jbpm.test.entity.Person;\n+import org.jbpm.workflow.instance.node.CompositeContextNodeInstance;\n+import org.jbpm.workflow.instance.node.HumanTaskNodeInstance;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_TIMER_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    \n+    private final static String PROCESS_MESSAGE_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryMessageProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_MESSAGE_NAME = \"BoundaryMessageEventProcess\";\n+    \n+    private final static String PROCESS_SIGNAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundarySignalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_SIGNAL_NAME = \"BoundarySignalEventProcess\";\n+    \n+    private final static String PROCESS_ERROR_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryErrorProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ERROR_NAME = \"BoundaryErrorEventProcess\";\n+    \n+    private final static String PROCESS_ESCALATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryEscalationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ESCALATION_NAME = \"BoundaryEscalationEventProcess\";\n+    \n+    private final static String PROCESS_COMPENSATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryCompensationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_COMPENSATION_NAME = \"BoundaryCompensationEventProcess\";\n+    \n+    private final static String PROCESS_CONDITIONAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryConditionalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_CONDITIONAL_NAME = \"BoundaryConditionalEventProcess\";\n+    \n+    private final static String WORK_ITEM_HANDLER_TASK = \"Human Task\";\n+    private final static String WORK_ITEM_HANDLER_DATA = \"DataCaptureTask\";\n+    \n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+        \n+    @Test\n+    public void testBoundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_TIMER_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        sleepAndVerifyTimerRuns();\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"event\"), 1L);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Timer-_2-500ms###1s-4\");\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"workItem\") instanceof WorkItem);\n+    }\n+\n+    @Test\n+    public void testBoundaryEventMessageAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_MESSAGE_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_MESSAGE_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"Message-MyMessage\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Message-MyMessage\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryEventSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_SIGNAL_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_SIGNAL_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"MySignal\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"MySignal\");", "originalCommit": "8abe5301c328c3f6cc637a761ef7085b74be35e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTgzOTg3Mg==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515839872", "bodyText": "TimeUnit.SECONDS.sleep(3); is recommended, but up to you, not an issue", "author": "afalhambra", "createdAt": "2020-11-02T09:28:40Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/event/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.event;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.jbpm.test.entity.Person;\n+import org.jbpm.workflow.instance.node.CompositeContextNodeInstance;\n+import org.jbpm.workflow.instance.node.HumanTaskNodeInstance;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_TIMER_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    \n+    private final static String PROCESS_MESSAGE_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryMessageProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_MESSAGE_NAME = \"BoundaryMessageEventProcess\";\n+    \n+    private final static String PROCESS_SIGNAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundarySignalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_SIGNAL_NAME = \"BoundarySignalEventProcess\";\n+    \n+    private final static String PROCESS_ERROR_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryErrorProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ERROR_NAME = \"BoundaryErrorEventProcess\";\n+    \n+    private final static String PROCESS_ESCALATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryEscalationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ESCALATION_NAME = \"BoundaryEscalationEventProcess\";\n+    \n+    private final static String PROCESS_COMPENSATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryCompensationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_COMPENSATION_NAME = \"BoundaryCompensationEventProcess\";\n+    \n+    private final static String PROCESS_CONDITIONAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryConditionalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_CONDITIONAL_NAME = \"BoundaryConditionalEventProcess\";\n+    \n+    private final static String WORK_ITEM_HANDLER_TASK = \"Human Task\";\n+    private final static String WORK_ITEM_HANDLER_DATA = \"DataCaptureTask\";\n+    \n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+        \n+    @Test\n+    public void testBoundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_TIMER_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        sleepAndVerifyTimerRuns();\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"event\"), 1L);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Timer-_2-500ms###1s-4\");\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"workItem\") instanceof WorkItem);\n+    }\n+\n+    @Test\n+    public void testBoundaryEventMessageAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_MESSAGE_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_MESSAGE_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"Message-MyMessage\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Message-MyMessage\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryEventSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_SIGNAL_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_SIGNAL_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"MySignal\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"MySignal\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryErrorSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_ERROR_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler(true);\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_ERROR_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+\n+        ksession.abortProcessInstance(processId);\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof java.lang.RuntimeException);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Error-_2-401\");\n+    }\n+    \n+    \n+    @Test\n+    public void testBoundaryEscalationSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_ESCALATION_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler(true);\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_ESCALATION_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_COMPLETED] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_COMPLETED, processState);\n+\n+        \n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof CompositeContextNodeInstance);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Escalation-_2-201\");\n+        assertNull(dataTaskMockHandler.getInputParameter(\"event\"));\n+    }\n+    \n+    @Test\n+    public void testBoundaryCompensationSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_COMPENSATION_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_COMPENSATION_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        completeWork(ksession, humanTaskMockHandler);\n+        ksession.signalEvent(\"Compensation\", \"_2\");\n+        \n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertNull(dataTaskMockHandler.getInputParameter(\"nodeInstance\"));\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"event\"), \"_2\");\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Compensation\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryConditionalSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_CONDITIONAL_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_CONDITIONAL_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        ksession.signalEvent(\"RuleFlowStateEvent-\" + PROCESS_CONDITIONAL_NAME + \"-4-_2\" , new org.jbpm.test.entity.Person(1L, \"john\"));\n+       \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"RuleFlowStateEvent-BoundaryConditionalEventProcess-4-_2\");\n+    }\n+    \n+    private void completeWork(KieSession ksession, HumanTaskMockHandler humanTaskMockHandler) {\n+        assertTrue(\"The work item task handler does not have a work item!\", humanTaskMockHandler.workItem != null);\n+        long workItemId = humanTaskMockHandler.workItem.getId();\n+        assertTrue(\"work item id not saved\", workItemId > 0);\n+        \n+        // The Human Task is completed\n+        Map<String, Object> results = new HashMap<String, Object>();\n+        try {\n+            ksession.getWorkItemManager().completeWorkItem(workItemId, results);\n+        } catch (Exception e) {\n+            logger.warn(\"Work item could not be completed!\");\n+            e.printStackTrace();\n+            fail(e.getClass().getSimpleName() + \" thrown when completing work item: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void sleepAndVerifyTimerRuns()  { \n+        try {\n+            int sleep = 3000;\n+            logger.debug(\"Sleeping {} seconds\", sleep / 1000);\n+            Thread.sleep(sleep);", "originalCommit": "8abe5301c328c3f6cc637a761ef7085b74be35e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg1ODUwOA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515858508", "bodyText": "same as above", "author": "afalhambra", "createdAt": "2020-11-02T09:59:26Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/event/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.event;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.jbpm.test.entity.Person;\n+import org.jbpm.workflow.instance.node.CompositeContextNodeInstance;\n+import org.jbpm.workflow.instance.node.HumanTaskNodeInstance;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_TIMER_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    \n+    private final static String PROCESS_MESSAGE_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryMessageProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_MESSAGE_NAME = \"BoundaryMessageEventProcess\";\n+    \n+    private final static String PROCESS_SIGNAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundarySignalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_SIGNAL_NAME = \"BoundarySignalEventProcess\";\n+    \n+    private final static String PROCESS_ERROR_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryErrorProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ERROR_NAME = \"BoundaryErrorEventProcess\";\n+    \n+    private final static String PROCESS_ESCALATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryEscalationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ESCALATION_NAME = \"BoundaryEscalationEventProcess\";\n+    \n+    private final static String PROCESS_COMPENSATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryCompensationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_COMPENSATION_NAME = \"BoundaryCompensationEventProcess\";\n+    \n+    private final static String PROCESS_CONDITIONAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryConditionalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_CONDITIONAL_NAME = \"BoundaryConditionalEventProcess\";\n+    \n+    private final static String WORK_ITEM_HANDLER_TASK = \"Human Task\";\n+    private final static String WORK_ITEM_HANDLER_DATA = \"DataCaptureTask\";\n+    \n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+        \n+    @Test\n+    public void testBoundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_TIMER_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        sleepAndVerifyTimerRuns();\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"event\"), 1L);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Timer-_2-500ms###1s-4\");\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"workItem\") instanceof WorkItem);\n+    }\n+\n+    @Test\n+    public void testBoundaryEventMessageAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_MESSAGE_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_MESSAGE_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"Message-MyMessage\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Message-MyMessage\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryEventSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_SIGNAL_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_SIGNAL_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"MySignal\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"MySignal\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryErrorSignalAndCompleteHumanTask() throws InterruptedException {", "originalCommit": "8abe5301c328c3f6cc637a761ef7085b74be35e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg1ODkxMQ==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515858911", "bodyText": "Shouldn't we check for workItem as well?", "author": "afalhambra", "createdAt": "2020-11-02T10:00:03Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/event/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.event;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.jbpm.test.entity.Person;\n+import org.jbpm.workflow.instance.node.CompositeContextNodeInstance;\n+import org.jbpm.workflow.instance.node.HumanTaskNodeInstance;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_TIMER_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    \n+    private final static String PROCESS_MESSAGE_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryMessageProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_MESSAGE_NAME = \"BoundaryMessageEventProcess\";\n+    \n+    private final static String PROCESS_SIGNAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundarySignalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_SIGNAL_NAME = \"BoundarySignalEventProcess\";\n+    \n+    private final static String PROCESS_ERROR_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryErrorProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ERROR_NAME = \"BoundaryErrorEventProcess\";\n+    \n+    private final static String PROCESS_ESCALATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryEscalationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ESCALATION_NAME = \"BoundaryEscalationEventProcess\";\n+    \n+    private final static String PROCESS_COMPENSATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryCompensationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_COMPENSATION_NAME = \"BoundaryCompensationEventProcess\";\n+    \n+    private final static String PROCESS_CONDITIONAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryConditionalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_CONDITIONAL_NAME = \"BoundaryConditionalEventProcess\";\n+    \n+    private final static String WORK_ITEM_HANDLER_TASK = \"Human Task\";\n+    private final static String WORK_ITEM_HANDLER_DATA = \"DataCaptureTask\";\n+    \n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+        \n+    @Test\n+    public void testBoundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_TIMER_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        sleepAndVerifyTimerRuns();\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"event\"), 1L);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Timer-_2-500ms###1s-4\");\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"workItem\") instanceof WorkItem);\n+    }\n+\n+    @Test\n+    public void testBoundaryEventMessageAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_MESSAGE_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_MESSAGE_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"Message-MyMessage\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Message-MyMessage\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryEventSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_SIGNAL_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_SIGNAL_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"MySignal\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"MySignal\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryErrorSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_ERROR_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler(true);\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_ERROR_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+\n+        ksession.abortProcessInstance(processId);\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof java.lang.RuntimeException);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Error-_2-401\");", "originalCommit": "8abe5301c328c3f6cc637a761ef7085b74be35e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg1OTAzMw==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515859033", "bodyText": "same as above", "author": "afalhambra", "createdAt": "2020-11-02T10:00:15Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/event/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.event;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.jbpm.test.entity.Person;\n+import org.jbpm.workflow.instance.node.CompositeContextNodeInstance;\n+import org.jbpm.workflow.instance.node.HumanTaskNodeInstance;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_TIMER_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    \n+    private final static String PROCESS_MESSAGE_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryMessageProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_MESSAGE_NAME = \"BoundaryMessageEventProcess\";\n+    \n+    private final static String PROCESS_SIGNAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundarySignalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_SIGNAL_NAME = \"BoundarySignalEventProcess\";\n+    \n+    private final static String PROCESS_ERROR_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryErrorProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ERROR_NAME = \"BoundaryErrorEventProcess\";\n+    \n+    private final static String PROCESS_ESCALATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryEscalationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ESCALATION_NAME = \"BoundaryEscalationEventProcess\";\n+    \n+    private final static String PROCESS_COMPENSATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryCompensationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_COMPENSATION_NAME = \"BoundaryCompensationEventProcess\";\n+    \n+    private final static String PROCESS_CONDITIONAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryConditionalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_CONDITIONAL_NAME = \"BoundaryConditionalEventProcess\";\n+    \n+    private final static String WORK_ITEM_HANDLER_TASK = \"Human Task\";\n+    private final static String WORK_ITEM_HANDLER_DATA = \"DataCaptureTask\";\n+    \n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+        \n+    @Test\n+    public void testBoundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_TIMER_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        sleepAndVerifyTimerRuns();\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"event\"), 1L);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Timer-_2-500ms###1s-4\");\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"workItem\") instanceof WorkItem);\n+    }\n+\n+    @Test\n+    public void testBoundaryEventMessageAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_MESSAGE_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_MESSAGE_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"Message-MyMessage\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Message-MyMessage\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryEventSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_SIGNAL_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_SIGNAL_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"MySignal\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"MySignal\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryErrorSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_ERROR_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler(true);\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_ERROR_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+\n+        ksession.abortProcessInstance(processId);\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof java.lang.RuntimeException);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Error-_2-401\");\n+    }\n+    \n+    \n+    @Test\n+    public void testBoundaryEscalationSignalAndCompleteHumanTask() throws InterruptedException {", "originalCommit": "8abe5301c328c3f6cc637a761ef7085b74be35e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg2MTgyOA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515861828", "bodyText": "This is not needed for this test", "author": "afalhambra", "createdAt": "2020-11-02T10:05:06Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/event/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.event;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.jbpm.test.entity.Person;\n+import org.jbpm.workflow.instance.node.CompositeContextNodeInstance;\n+import org.jbpm.workflow.instance.node.HumanTaskNodeInstance;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_TIMER_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    \n+    private final static String PROCESS_MESSAGE_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryMessageProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_MESSAGE_NAME = \"BoundaryMessageEventProcess\";\n+    \n+    private final static String PROCESS_SIGNAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundarySignalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_SIGNAL_NAME = \"BoundarySignalEventProcess\";\n+    \n+    private final static String PROCESS_ERROR_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryErrorProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ERROR_NAME = \"BoundaryErrorEventProcess\";\n+    \n+    private final static String PROCESS_ESCALATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryEscalationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ESCALATION_NAME = \"BoundaryEscalationEventProcess\";\n+    \n+    private final static String PROCESS_COMPENSATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryCompensationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_COMPENSATION_NAME = \"BoundaryCompensationEventProcess\";\n+    \n+    private final static String PROCESS_CONDITIONAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryConditionalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_CONDITIONAL_NAME = \"BoundaryConditionalEventProcess\";\n+    \n+    private final static String WORK_ITEM_HANDLER_TASK = \"Human Task\";\n+    private final static String WORK_ITEM_HANDLER_DATA = \"DataCaptureTask\";\n+    \n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+        \n+    @Test\n+    public void testBoundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_TIMER_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        sleepAndVerifyTimerRuns();\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"event\"), 1L);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Timer-_2-500ms###1s-4\");\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"workItem\") instanceof WorkItem);\n+    }\n+\n+    @Test\n+    public void testBoundaryEventMessageAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_MESSAGE_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_MESSAGE_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"Message-MyMessage\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Message-MyMessage\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryEventSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_SIGNAL_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_SIGNAL_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"MySignal\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"MySignal\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryErrorSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_ERROR_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler(true);\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_ERROR_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+\n+        ksession.abortProcessInstance(processId);\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof java.lang.RuntimeException);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Error-_2-401\");\n+    }\n+    \n+    \n+    @Test\n+    public void testBoundaryEscalationSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_ESCALATION_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler(true);", "originalCommit": "8abe5301c328c3f6cc637a761ef7085b74be35e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg2MjA5Ng==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515862096", "bodyText": "Shouldn't we check workItem as well?", "author": "afalhambra", "createdAt": "2020-11-02T10:05:34Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/event/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.event;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.jbpm.test.entity.Person;\n+import org.jbpm.workflow.instance.node.CompositeContextNodeInstance;\n+import org.jbpm.workflow.instance.node.HumanTaskNodeInstance;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_TIMER_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    \n+    private final static String PROCESS_MESSAGE_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryMessageProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_MESSAGE_NAME = \"BoundaryMessageEventProcess\";\n+    \n+    private final static String PROCESS_SIGNAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundarySignalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_SIGNAL_NAME = \"BoundarySignalEventProcess\";\n+    \n+    private final static String PROCESS_ERROR_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryErrorProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ERROR_NAME = \"BoundaryErrorEventProcess\";\n+    \n+    private final static String PROCESS_ESCALATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryEscalationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ESCALATION_NAME = \"BoundaryEscalationEventProcess\";\n+    \n+    private final static String PROCESS_COMPENSATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryCompensationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_COMPENSATION_NAME = \"BoundaryCompensationEventProcess\";\n+    \n+    private final static String PROCESS_CONDITIONAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryConditionalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_CONDITIONAL_NAME = \"BoundaryConditionalEventProcess\";\n+    \n+    private final static String WORK_ITEM_HANDLER_TASK = \"Human Task\";\n+    private final static String WORK_ITEM_HANDLER_DATA = \"DataCaptureTask\";\n+    \n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+        \n+    @Test\n+    public void testBoundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_TIMER_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        sleepAndVerifyTimerRuns();\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"event\"), 1L);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Timer-_2-500ms###1s-4\");\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"workItem\") instanceof WorkItem);\n+    }\n+\n+    @Test\n+    public void testBoundaryEventMessageAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_MESSAGE_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_MESSAGE_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"Message-MyMessage\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Message-MyMessage\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryEventSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_SIGNAL_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_SIGNAL_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"MySignal\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"MySignal\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryErrorSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_ERROR_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler(true);\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_ERROR_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+\n+        ksession.abortProcessInstance(processId);\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof java.lang.RuntimeException);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Error-_2-401\");\n+    }\n+    \n+    \n+    @Test\n+    public void testBoundaryEscalationSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_ESCALATION_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler(true);\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_ESCALATION_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_COMPLETED] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_COMPLETED, processState);\n+\n+        \n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof CompositeContextNodeInstance);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Escalation-_2-201\");\n+        assertNull(dataTaskMockHandler.getInputParameter(\"event\"));", "originalCommit": "8abe5301c328c3f6cc637a761ef7085b74be35e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg2ODI4MA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515868280", "bodyText": "same as above", "author": "afalhambra", "createdAt": "2020-11-02T10:15:33Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/event/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.event;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.jbpm.test.entity.Person;\n+import org.jbpm.workflow.instance.node.CompositeContextNodeInstance;\n+import org.jbpm.workflow.instance.node.HumanTaskNodeInstance;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_TIMER_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    \n+    private final static String PROCESS_MESSAGE_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryMessageProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_MESSAGE_NAME = \"BoundaryMessageEventProcess\";\n+    \n+    private final static String PROCESS_SIGNAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundarySignalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_SIGNAL_NAME = \"BoundarySignalEventProcess\";\n+    \n+    private final static String PROCESS_ERROR_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryErrorProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ERROR_NAME = \"BoundaryErrorEventProcess\";\n+    \n+    private final static String PROCESS_ESCALATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryEscalationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ESCALATION_NAME = \"BoundaryEscalationEventProcess\";\n+    \n+    private final static String PROCESS_COMPENSATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryCompensationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_COMPENSATION_NAME = \"BoundaryCompensationEventProcess\";\n+    \n+    private final static String PROCESS_CONDITIONAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryConditionalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_CONDITIONAL_NAME = \"BoundaryConditionalEventProcess\";\n+    \n+    private final static String WORK_ITEM_HANDLER_TASK = \"Human Task\";\n+    private final static String WORK_ITEM_HANDLER_DATA = \"DataCaptureTask\";\n+    \n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+        \n+    @Test\n+    public void testBoundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_TIMER_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        sleepAndVerifyTimerRuns();\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"event\"), 1L);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Timer-_2-500ms###1s-4\");\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"workItem\") instanceof WorkItem);\n+    }\n+\n+    @Test\n+    public void testBoundaryEventMessageAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_MESSAGE_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_MESSAGE_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"Message-MyMessage\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Message-MyMessage\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryEventSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_SIGNAL_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_SIGNAL_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"MySignal\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"MySignal\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryErrorSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_ERROR_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler(true);\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_ERROR_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+\n+        ksession.abortProcessInstance(processId);\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof java.lang.RuntimeException);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Error-_2-401\");\n+    }\n+    \n+    \n+    @Test\n+    public void testBoundaryEscalationSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_ESCALATION_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler(true);\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_ESCALATION_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_COMPLETED] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_COMPLETED, processState);\n+\n+        \n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof CompositeContextNodeInstance);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Escalation-_2-201\");\n+        assertNull(dataTaskMockHandler.getInputParameter(\"event\"));\n+    }\n+    \n+    @Test\n+    public void testBoundaryCompensationSignalAndCompleteHumanTask() throws InterruptedException {", "originalCommit": "8abe5301c328c3f6cc637a761ef7085b74be35e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg2ODQyMA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515868420", "bodyText": "shouldn't we check workItem as well?", "author": "afalhambra", "createdAt": "2020-11-02T10:15:48Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/event/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.event;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.jbpm.test.entity.Person;\n+import org.jbpm.workflow.instance.node.CompositeContextNodeInstance;\n+import org.jbpm.workflow.instance.node.HumanTaskNodeInstance;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_TIMER_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    \n+    private final static String PROCESS_MESSAGE_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryMessageProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_MESSAGE_NAME = \"BoundaryMessageEventProcess\";\n+    \n+    private final static String PROCESS_SIGNAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundarySignalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_SIGNAL_NAME = \"BoundarySignalEventProcess\";\n+    \n+    private final static String PROCESS_ERROR_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryErrorProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ERROR_NAME = \"BoundaryErrorEventProcess\";\n+    \n+    private final static String PROCESS_ESCALATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryEscalationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ESCALATION_NAME = \"BoundaryEscalationEventProcess\";\n+    \n+    private final static String PROCESS_COMPENSATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryCompensationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_COMPENSATION_NAME = \"BoundaryCompensationEventProcess\";\n+    \n+    private final static String PROCESS_CONDITIONAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryConditionalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_CONDITIONAL_NAME = \"BoundaryConditionalEventProcess\";\n+    \n+    private final static String WORK_ITEM_HANDLER_TASK = \"Human Task\";\n+    private final static String WORK_ITEM_HANDLER_DATA = \"DataCaptureTask\";\n+    \n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+        \n+    @Test\n+    public void testBoundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_TIMER_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        sleepAndVerifyTimerRuns();\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"event\"), 1L);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Timer-_2-500ms###1s-4\");\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"workItem\") instanceof WorkItem);\n+    }\n+\n+    @Test\n+    public void testBoundaryEventMessageAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_MESSAGE_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_MESSAGE_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"Message-MyMessage\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Message-MyMessage\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryEventSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_SIGNAL_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_SIGNAL_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"MySignal\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"MySignal\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryErrorSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_ERROR_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler(true);\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_ERROR_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+\n+        ksession.abortProcessInstance(processId);\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof java.lang.RuntimeException);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Error-_2-401\");\n+    }\n+    \n+    \n+    @Test\n+    public void testBoundaryEscalationSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_ESCALATION_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler(true);\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_ESCALATION_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_COMPLETED] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_COMPLETED, processState);\n+\n+        \n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof CompositeContextNodeInstance);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Escalation-_2-201\");\n+        assertNull(dataTaskMockHandler.getInputParameter(\"event\"));\n+    }\n+    \n+    @Test\n+    public void testBoundaryCompensationSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_COMPENSATION_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_COMPENSATION_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        completeWork(ksession, humanTaskMockHandler);\n+        ksession.signalEvent(\"Compensation\", \"_2\");\n+        \n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertNull(dataTaskMockHandler.getInputParameter(\"nodeInstance\"));\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"event\"), \"_2\");\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Compensation\");", "originalCommit": "8abe5301c328c3f6cc637a761ef7085b74be35e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg2ODU1NQ==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515868555", "bodyText": "same as above", "author": "afalhambra", "createdAt": "2020-11-02T10:15:58Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/event/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.event;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.jbpm.test.entity.Person;\n+import org.jbpm.workflow.instance.node.CompositeContextNodeInstance;\n+import org.jbpm.workflow.instance.node.HumanTaskNodeInstance;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_TIMER_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    \n+    private final static String PROCESS_MESSAGE_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryMessageProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_MESSAGE_NAME = \"BoundaryMessageEventProcess\";\n+    \n+    private final static String PROCESS_SIGNAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundarySignalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_SIGNAL_NAME = \"BoundarySignalEventProcess\";\n+    \n+    private final static String PROCESS_ERROR_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryErrorProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ERROR_NAME = \"BoundaryErrorEventProcess\";\n+    \n+    private final static String PROCESS_ESCALATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryEscalationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ESCALATION_NAME = \"BoundaryEscalationEventProcess\";\n+    \n+    private final static String PROCESS_COMPENSATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryCompensationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_COMPENSATION_NAME = \"BoundaryCompensationEventProcess\";\n+    \n+    private final static String PROCESS_CONDITIONAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryConditionalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_CONDITIONAL_NAME = \"BoundaryConditionalEventProcess\";\n+    \n+    private final static String WORK_ITEM_HANDLER_TASK = \"Human Task\";\n+    private final static String WORK_ITEM_HANDLER_DATA = \"DataCaptureTask\";\n+    \n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+        \n+    @Test\n+    public void testBoundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_TIMER_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        sleepAndVerifyTimerRuns();\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"event\"), 1L);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Timer-_2-500ms###1s-4\");\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"workItem\") instanceof WorkItem);\n+    }\n+\n+    @Test\n+    public void testBoundaryEventMessageAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_MESSAGE_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_MESSAGE_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"Message-MyMessage\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Message-MyMessage\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryEventSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_SIGNAL_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_SIGNAL_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"MySignal\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"MySignal\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryErrorSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_ERROR_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler(true);\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_ERROR_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+\n+        ksession.abortProcessInstance(processId);\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof java.lang.RuntimeException);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Error-_2-401\");\n+    }\n+    \n+    \n+    @Test\n+    public void testBoundaryEscalationSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_ESCALATION_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler(true);\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_ESCALATION_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_COMPLETED] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_COMPLETED, processState);\n+\n+        \n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof CompositeContextNodeInstance);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Escalation-_2-201\");\n+        assertNull(dataTaskMockHandler.getInputParameter(\"event\"));\n+    }\n+    \n+    @Test\n+    public void testBoundaryCompensationSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_COMPENSATION_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_COMPENSATION_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        completeWork(ksession, humanTaskMockHandler);\n+        ksession.signalEvent(\"Compensation\", \"_2\");\n+        \n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertNull(dataTaskMockHandler.getInputParameter(\"nodeInstance\"));\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"event\"), \"_2\");\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Compensation\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryConditionalSignalAndCompleteHumanTask() throws InterruptedException {", "originalCommit": "8abe5301c328c3f6cc637a761ef7085b74be35e1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg3MDM4MA==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515870380", "bodyText": "Shouldn't we check workItem here as well?", "author": "afalhambra", "createdAt": "2020-11-02T10:19:04Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/event/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.event;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.jbpm.test.entity.Person;\n+import org.jbpm.workflow.instance.node.CompositeContextNodeInstance;\n+import org.jbpm.workflow.instance.node.HumanTaskNodeInstance;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_TIMER_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    \n+    private final static String PROCESS_MESSAGE_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryMessageProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_MESSAGE_NAME = \"BoundaryMessageEventProcess\";\n+    \n+    private final static String PROCESS_SIGNAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundarySignalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_SIGNAL_NAME = \"BoundarySignalEventProcess\";\n+    \n+    private final static String PROCESS_ERROR_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryErrorProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ERROR_NAME = \"BoundaryErrorEventProcess\";\n+    \n+    private final static String PROCESS_ESCALATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryEscalationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ESCALATION_NAME = \"BoundaryEscalationEventProcess\";\n+    \n+    private final static String PROCESS_COMPENSATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryCompensationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_COMPENSATION_NAME = \"BoundaryCompensationEventProcess\";\n+    \n+    private final static String PROCESS_CONDITIONAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryConditionalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_CONDITIONAL_NAME = \"BoundaryConditionalEventProcess\";\n+    \n+    private final static String WORK_ITEM_HANDLER_TASK = \"Human Task\";\n+    private final static String WORK_ITEM_HANDLER_DATA = \"DataCaptureTask\";\n+    \n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+        \n+    @Test\n+    public void testBoundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_TIMER_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        sleepAndVerifyTimerRuns();\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"event\"), 1L);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Timer-_2-500ms###1s-4\");\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"workItem\") instanceof WorkItem);\n+    }\n+\n+    @Test\n+    public void testBoundaryEventMessageAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_MESSAGE_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_MESSAGE_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"Message-MyMessage\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Message-MyMessage\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryEventSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_SIGNAL_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_SIGNAL_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"MySignal\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"MySignal\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryErrorSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_ERROR_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler(true);\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_ERROR_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+\n+        ksession.abortProcessInstance(processId);\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof java.lang.RuntimeException);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Error-_2-401\");\n+    }\n+    \n+    \n+    @Test\n+    public void testBoundaryEscalationSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_ESCALATION_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler(true);\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_ESCALATION_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_COMPLETED] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_COMPLETED, processState);\n+\n+        \n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof CompositeContextNodeInstance);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Escalation-_2-201\");\n+        assertNull(dataTaskMockHandler.getInputParameter(\"event\"));\n+    }\n+    \n+    @Test\n+    public void testBoundaryCompensationSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_COMPENSATION_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_COMPENSATION_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        completeWork(ksession, humanTaskMockHandler);\n+        ksession.signalEvent(\"Compensation\", \"_2\");\n+        \n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertNull(dataTaskMockHandler.getInputParameter(\"nodeInstance\"));\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"event\"), \"_2\");\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Compensation\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryConditionalSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_CONDITIONAL_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_CONDITIONAL_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        ksession.signalEvent(\"RuleFlowStateEvent-\" + PROCESS_CONDITIONAL_NAME + \"-4-_2\" , new org.jbpm.test.entity.Person(1L, \"john\"));\n+       \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"RuleFlowStateEvent-BoundaryConditionalEventProcess-4-_2\");", "originalCommit": "8abe5301c328c3f6cc637a761ef7085b74be35e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAwNDMxNg==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r516004316", "bodyText": "done", "author": "elguardian", "createdAt": "2020-11-02T14:22:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg3MDM4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg3MTEwNg==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r515871106", "bodyText": "we don't need to use fully qualified class name for them", "author": "afalhambra", "createdAt": "2020-11-02T10:20:07Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/event/BoundaryEventWithOutputSetPersistenceTest.java", "diffHunk": "@@ -0,0 +1,415 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.test.functional.event;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.junit.Assert.fail;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.drools.core.process.instance.WorkItemHandler;\n+import org.jbpm.test.JbpmTestCase;\n+import org.jbpm.test.entity.Person;\n+import org.jbpm.workflow.instance.node.CompositeContextNodeInstance;\n+import org.jbpm.workflow.instance.node.HumanTaskNodeInstance;\n+import org.junit.Test;\n+import org.kie.api.runtime.KieSession;\n+import org.kie.api.runtime.manager.RuntimeEngine;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.api.runtime.process.WorkItem;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+\n+\n+public class BoundaryEventWithOutputSetPersistenceTest extends JbpmTestCase {\n+\n+    // General setup\n+    private static final Logger logger = LoggerFactory.getLogger(BoundaryEventWithOutputSetPersistenceTest.class);\n+\n+    \n+    private final static String PROCESS_TIMER_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryTimerProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_NAME = \"BoundaryTimerEventProcess\";\n+    \n+    private final static String PROCESS_MESSAGE_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryMessageProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_MESSAGE_NAME = \"BoundaryMessageEventProcess\";\n+    \n+    private final static String PROCESS_SIGNAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundarySignalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_SIGNAL_NAME = \"BoundarySignalEventProcess\";\n+    \n+    private final static String PROCESS_ERROR_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryErrorProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ERROR_NAME = \"BoundaryErrorEventProcess\";\n+    \n+    private final static String PROCESS_ESCALATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryEscalationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_ESCALATION_NAME = \"BoundaryEscalationEventProcess\";\n+    \n+    private final static String PROCESS_COMPENSATION_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryCompensationProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_COMPENSATION_NAME = \"BoundaryCompensationEventProcess\";\n+    \n+    private final static String PROCESS_CONDITIONAL_FILE_NAME = \"org/jbpm/test/functional/event/BoundaryConditionalProcessWithOutputSet.bpmn2\";\n+    private final static String PROCESS_CONDITIONAL_NAME = \"BoundaryConditionalEventProcess\";\n+    \n+    private final static String WORK_ITEM_HANDLER_TASK = \"Human Task\";\n+    private final static String WORK_ITEM_HANDLER_DATA = \"DataCaptureTask\";\n+    \n+\n+    public BoundaryEventWithOutputSetPersistenceTest() { \n+        super(true, true);\n+    }\n+        \n+    @Test\n+    public void testBoundaryEventTimerAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_TIMER_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        sleepAndVerifyTimerRuns();\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"event\"), 1L);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Timer-_2-500ms###1s-4\");\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"workItem\") instanceof WorkItem);\n+    }\n+\n+    @Test\n+    public void testBoundaryEventMessageAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_MESSAGE_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_MESSAGE_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"Message-MyMessage\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Message-MyMessage\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryEventSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_SIGNAL_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_SIGNAL_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        // we signal a boundary event\n+        ksession.signalEvent(\"MySignal\",  new Person());\n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"MySignal\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryErrorSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_ERROR_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler(true);\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_ERROR_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+\n+        ksession.abortProcessInstance(processId);\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof java.lang.RuntimeException);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Error-_2-401\");\n+    }\n+    \n+    \n+    @Test\n+    public void testBoundaryEscalationSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_ESCALATION_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler(true);\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_ESCALATION_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_COMPLETED] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_COMPLETED, processState);\n+\n+        \n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof CompositeContextNodeInstance);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Escalation-_2-201\");\n+        assertNull(dataTaskMockHandler.getInputParameter(\"event\"));\n+    }\n+    \n+    @Test\n+    public void testBoundaryCompensationSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_COMPENSATION_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_COMPENSATION_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        completeWork(ksession, humanTaskMockHandler);\n+        ksession.signalEvent(\"Compensation\", \"_2\");\n+        \n+        \n+        completeWork(ksession, humanTaskMockHandler);\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertNull(dataTaskMockHandler.getInputParameter(\"nodeInstance\"));\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"event\"), \"_2\");\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"Compensation\");\n+    }\n+    \n+    @Test\n+    public void testBoundaryConditionalSignalAndCompleteHumanTask() throws InterruptedException {\n+        \n+        createRuntimeManager(PROCESS_CONDITIONAL_FILE_NAME);\n+\n+        RuntimeEngine runtimeEngine = getRuntimeEngine();\n+        KieSession ksession = runtimeEngine.getKieSession();\n+        long ksessionId = ksession.getIdentifier();\n+        assertTrue(\"session id not saved.\", ksessionId > 0);\n+        \n+        HumanTaskMockHandler humanTaskMockHandler = new HumanTaskMockHandler();\n+        DataTaskMockHandler dataTaskMockHandler = new DataTaskMockHandler();\n+        // Register Human Task Handler\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_TASK, humanTaskMockHandler);\n+        ksession.getWorkItemManager().registerWorkItemHandler(WORK_ITEM_HANDLER_DATA, dataTaskMockHandler);\n+        // Start the process \n+        ProcessInstance process = ksession.startProcess(PROCESS_CONDITIONAL_NAME);\n+        long processId = process.getId();\n+        assertTrue(\"process id not saved\", processId > 0);\n+        \n+        // The process is in the Human Task waiting for its completion\n+        int processState = process.getState();\n+        assertEquals(\"Expected process state to be \" + processStateName[ProcessInstance.STATE_ACTIVE] + \" not \"\n+                + processStateName[processState], ProcessInstance.STATE_ACTIVE, processState);\n+\n+        ksession.signalEvent(\"RuleFlowStateEvent-\" + PROCESS_CONDITIONAL_NAME + \"-4-_2\" , new org.jbpm.test.entity.Person(1L, \"john\"));\n+       \n+        completeWork(ksession, humanTaskMockHandler);\n+\n+        // The process completes\n+        process = ksession.getProcessInstance(process.getId());\n+        assertNull(\"Expected process to have been completed and removed\", process);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"nodeInstance\") instanceof HumanTaskNodeInstance);\n+        assertTrue(dataTaskMockHandler.getInputParameter(\"event\") instanceof Person);\n+        assertEquals(dataTaskMockHandler.getInputParameter(\"signal\"), \"RuleFlowStateEvent-BoundaryConditionalEventProcess-4-_2\");\n+    }\n+    \n+    private void completeWork(KieSession ksession, HumanTaskMockHandler humanTaskMockHandler) {\n+        assertTrue(\"The work item task handler does not have a work item!\", humanTaskMockHandler.workItem != null);\n+        long workItemId = humanTaskMockHandler.workItem.getId();\n+        assertTrue(\"work item id not saved\", workItemId > 0);\n+        \n+        // The Human Task is completed\n+        Map<String, Object> results = new HashMap<String, Object>();\n+        try {\n+            ksession.getWorkItemManager().completeWorkItem(workItemId, results);\n+        } catch (Exception e) {\n+            logger.warn(\"Work item could not be completed!\");\n+            e.printStackTrace();\n+            fail(e.getClass().getSimpleName() + \" thrown when completing work item: \" + e.getMessage());\n+        }\n+    }\n+\n+    private void sleepAndVerifyTimerRuns()  { \n+        try {\n+            int sleep = 3000;\n+            logger.debug(\"Sleeping {} seconds\", sleep / 1000);\n+            Thread.sleep(sleep);\n+            logger.debug(\"Awake!\");\n+        } catch(InterruptedException e) {\n+            logger.error(\"System was interrupted\");\n+            fail(\"Junit was interrupted\");\n+        }\n+\n+    }\n+\n+\n+\n+    private static class HumanTaskMockHandler implements WorkItemHandler {\n+\n+        private org.kie.api.runtime.process.WorkItemManager workItemManager;\n+        private org.kie.api.runtime.process.WorkItem workItem;", "originalCommit": "8abe5301c328c3f6cc637a761ef7085b74be35e1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAwMzc1MQ==", "url": "https://github.com/kiegroup/jbpm/pull/1773#discussion_r516003751", "bodyText": "removed", "author": "elguardian", "createdAt": "2020-11-02T14:21:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTg3MTEwNg=="}], "type": "inlineReview"}, {"oid": "b013cdec804c5f15c530c7c0d0a6d274046aee19", "url": "https://github.com/kiegroup/jbpm/commit/b013cdec804c5f15c530c7c0d0a6d274046aee19", "message": "[JBPM-9411] Provide a way to access task details in boundary event", "committedDate": "2020-11-02T14:25:20Z", "type": "forcePushed"}, {"oid": "e9a54adf39c831ed8cefb9befa6292a37096eed2", "url": "https://github.com/kiegroup/jbpm/commit/e9a54adf39c831ed8cefb9befa6292a37096eed2", "message": "[JBPM-9411] Provide a way to access task details in boundary event", "committedDate": "2020-11-02T14:25:57Z", "type": "commit"}, {"oid": "e9a54adf39c831ed8cefb9befa6292a37096eed2", "url": "https://github.com/kiegroup/jbpm/commit/e9a54adf39c831ed8cefb9befa6292a37096eed2", "message": "[JBPM-9411] Provide a way to access task details in boundary event", "committedDate": "2020-11-02T14:25:57Z", "type": "forcePushed"}]}