{"pr_number": 1615, "pr_title": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.", "pr_createdAt": "2020-03-24T08:40:45Z", "pr_url": "https://github.com/kiegroup/jbpm/pull/1615", "timeline": [{"oid": "f269fe50fc6e2ae61e2ada0c054df0dac5085faa", "url": "https://github.com/kiegroup/jbpm/commit/f269fe50fc6e2ae61e2ada0c054df0dac5085faa", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables", "committedDate": "2020-03-24T09:51:23Z", "type": "forcePushed"}, {"oid": "cdf99a0114e025f440524f9192b93ea1a9b37d02", "url": "https://github.com/kiegroup/jbpm/commit/cdf99a0114e025f440524f9192b93ea1a9b37d02", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables", "committedDate": "2020-03-24T12:25:40Z", "type": "forcePushed"}, {"oid": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "url": "https://github.com/kiegroup/jbpm/commit/1e57dd6f9a77d2e636949457815115ca83acc4dc", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables", "committedDate": "2020-03-30T15:29:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk3Nzg5OA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r400977898", "bodyText": "This process is not referenced or used in this test class", "author": "afalhambra", "createdAt": "2020-03-31T14:52:34Z", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceCaseRuntimeDataServiceImplTest.class);\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        processes.add(\"processes/UserTaskProcess.bpmn2\");", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI0NDA1Nw==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r404244057", "bodyText": "ok", "author": "elguardian", "createdAt": "2020-04-06T16:55:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk3Nzg5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk3OTI5MA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r400979290", "bodyText": "If statement is not needed. Above assertNotNull will make this never happens.", "author": "afalhambra", "createdAt": "2020-03-31T14:54:17Z", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceCaseRuntimeDataServiceImplTest.class);\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        processes.add(\"processes/UserTaskProcess.bpmn2\");\n+        return processes;\n+    }\n+\n+    /*\n+     * Case instance queries\n+     */\n+    @Test\n+    public void testSearchByVariable() {\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, data);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, caseFile);\n+        Map<String, Object> vars = new HashMap<>();\n+        vars.put(\"name\", \"my first case\");\n+        \n+        List<ProcessInstanceWithVarsDesc> process = advanceCaseRuntimeDataService.queryCaseByVariables(emptyMap(), vars, new QueryContext());\n+        assertEquals(process.size(), 1);\n+        assertEquals(process.get(0).getVariables().get(\"name\"), \"my first case\");\n+\n+        assertNotNull(caseId);\n+        assertEquals(FIRST_CASE_ID, caseId);\n+        if (caseId != null) {", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDk3OTU1MQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r400979551", "bodyText": "If statement is not needed. Above assertNotNull will make this never happens.", "author": "afalhambra", "createdAt": "2020-03-31T14:54:37Z", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceCaseRuntimeDataServiceImplTest.class);\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        processes.add(\"processes/UserTaskProcess.bpmn2\");\n+        return processes;\n+    }\n+\n+    /*\n+     * Case instance queries\n+     */\n+    @Test\n+    public void testSearchByVariable() {\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, data);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, caseFile);\n+        Map<String, Object> vars = new HashMap<>();\n+        vars.put(\"name\", \"my first case\");\n+        \n+        List<ProcessInstanceWithVarsDesc> process = advanceCaseRuntimeDataService.queryCaseByVariables(emptyMap(), vars, new QueryContext());\n+        assertEquals(process.size(), 1);\n+        assertEquals(process.get(0).getVariables().get(\"name\"), \"my first case\");\n+\n+        assertNotNull(caseId);\n+        assertEquals(FIRST_CASE_ID, caseId);\n+        if (caseId != null) {\n+            caseService.cancelCase(caseId);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testSearchUserByVariable() {\n+        Map<String, OrganizationalEntity> roleAssignments = new HashMap<>();\n+        roleAssignments.put(\"owner\", new UserImpl(USER));\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, data, roleAssignments);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, caseFile);\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> process = advanceCaseRuntimeDataService.queryUserTasksByVariables(emptyMap(), emptyMap(), emptyMap(), emptyList(), new QueryContext());\n+        assertEquals(1, process.size());\n+        assertEquals(process.get(0).getExtraData().get(\"name\"), \"my first case\");\n+\n+        assertNotNull(caseId);\n+        assertEquals(HR_CASE_ID, caseId);\n+        if (caseId != null) {", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY0Mzg5NA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401643894", "bodyText": "Expected and actual values should be swapped.", "author": "afalhambra", "createdAt": "2020-04-01T14:08:22Z", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceCaseRuntimeDataServiceImplTest.class);\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        processes.add(\"processes/UserTaskProcess.bpmn2\");\n+        return processes;\n+    }\n+\n+    /*\n+     * Case instance queries\n+     */\n+    @Test\n+    public void testSearchByVariable() {\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, data);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, caseFile);\n+        Map<String, Object> vars = new HashMap<>();\n+        vars.put(\"name\", \"my first case\");\n+        \n+        List<ProcessInstanceWithVarsDesc> process = advanceCaseRuntimeDataService.queryCaseByVariables(emptyMap(), vars, new QueryContext());\n+        assertEquals(process.size(), 1);", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY0NDI2Ng==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401644266", "bodyText": "Expected and actual values should be swapped", "author": "afalhambra", "createdAt": "2020-04-01T14:08:53Z", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceCaseRuntimeDataServiceImplTest.class);\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        processes.add(\"processes/UserTaskProcess.bpmn2\");\n+        return processes;\n+    }\n+\n+    /*\n+     * Case instance queries\n+     */\n+    @Test\n+    public void testSearchByVariable() {\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, data);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, caseFile);\n+        Map<String, Object> vars = new HashMap<>();\n+        vars.put(\"name\", \"my first case\");\n+        \n+        List<ProcessInstanceWithVarsDesc> process = advanceCaseRuntimeDataService.queryCaseByVariables(emptyMap(), vars, new QueryContext());\n+        assertEquals(process.size(), 1);\n+        assertEquals(process.get(0).getVariables().get(\"name\"), \"my first case\");\n+\n+        assertNotNull(caseId);\n+        assertEquals(FIRST_CASE_ID, caseId);\n+        if (caseId != null) {\n+            caseService.cancelCase(caseId);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testSearchUserByVariable() {\n+        Map<String, OrganizationalEntity> roleAssignments = new HashMap<>();\n+        roleAssignments.put(\"owner\", new UserImpl(USER));\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, data, roleAssignments);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, caseFile);\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> process = advanceCaseRuntimeDataService.queryUserTasksByVariables(emptyMap(), emptyMap(), emptyMap(), emptyList(), new QueryContext());\n+        assertEquals(1, process.size());\n+        assertEquals(process.get(0).getExtraData().get(\"name\"), \"my first case\");", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTY2ODIwNA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401668204", "bodyText": "As we are querying user tasks by variable I would also add \"USER\" as parameter in the method call by using something like Collections.singletonList(USER) along with the data variable.", "author": "afalhambra", "createdAt": "2020-04-01T14:40:32Z", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceCaseRuntimeDataServiceImplTest.class);\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        processes.add(\"processes/UserTaskProcess.bpmn2\");\n+        return processes;\n+    }\n+\n+    /*\n+     * Case instance queries\n+     */\n+    @Test\n+    public void testSearchByVariable() {\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, data);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, caseFile);\n+        Map<String, Object> vars = new HashMap<>();\n+        vars.put(\"name\", \"my first case\");\n+        \n+        List<ProcessInstanceWithVarsDesc> process = advanceCaseRuntimeDataService.queryCaseByVariables(emptyMap(), vars, new QueryContext());\n+        assertEquals(process.size(), 1);\n+        assertEquals(process.get(0).getVariables().get(\"name\"), \"my first case\");\n+\n+        assertNotNull(caseId);\n+        assertEquals(FIRST_CASE_ID, caseId);\n+        if (caseId != null) {\n+            caseService.cancelCase(caseId);\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testSearchUserByVariable() {\n+        Map<String, OrganizationalEntity> roleAssignments = new HashMap<>();\n+        roleAssignments.put(\"owner\", new UserImpl(USER));\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, data, roleAssignments);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, caseFile);\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> process = advanceCaseRuntimeDataService.queryUserTasksByVariables(emptyMap(), emptyMap(), emptyMap(), emptyList(), new QueryContext());", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxNTY5OQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401715699", "bodyText": "Potential security issue when concatenating strings for a query. Though all the query parameters are properly set below these lines. do you see any risk here?", "author": "afalhambra", "createdAt": "2020-04-01T15:43:14Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :NAME_\" + varName + \" AND \" + alias + \".VALUE= :VALUE_\" + varName + \"\\n\");\n+        }\n+\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" pil.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT pil.processInstanceId FROM ProcessInstanceLog pil \\n \" + derivedTables + where + \" ORDER BY pil.processInstanceId ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \" \\n\" : \"\";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            query.setParameter(\"NAME_\" + var.getKey(), varPrefix + var.getKey());\n+            query.setParameter(\"VALUE_\" + var.getKey(), var.getValue());\n+        }\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            query.setParameter(\"ATTR_\" + entry.getKey(), entry.getValue());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeProcessInstanceByIdList\", singletonMap(\"idList\", ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeVariablesByProcessInstanceIdList\", singletonMap(\"idList\", ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (name.startsWith(varPrefix)) {\n+                    vars.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+    private void addWhereExpression(StringBuilder where) {\n+        where.append(where.length() == 0 ? \"WHERE \" : \" AND \");\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(Map<String, Object> attributes,\n+                                                                                                        Map<String, Object> variables,\n+                                                                                                        Map<String, Object> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"V_TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                  \"SELECT taskId, name, value \\n\" +\n+                                  \"FROM TaskVariableImpl \\n\" +\n+                                  \"WHERE type = 0\\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".taskId = task.id  \\n\");\n+\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :V_NAME_\" + varName + \" AND \" + alias + \".VALUE= :V_VALUE_\" + varName + \"\\n\");\n+        }\n+\n+        for (Map.Entry<String, Object> var : processVariables.entrySet()) {\n+            String alias = \"P_TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :P_NAME_\" + varName + \" AND \" + alias + \".VALUE= :P_VALUE_\" + varName + \"\\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") AS pot ON pot.task_id = task.id \");\n+        }\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" task.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT task.id FROM Task task INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" + derivedTables + where + \" ORDER BY id ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \"\\n\" : \"\";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxNjQ2Mw==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401716463", "bodyText": "I would add some java doc to the method.", "author": "afalhambra", "createdAt": "2020-04-01T15:44:15Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxNjY0NA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401716644", "bodyText": "I would add some java doc to the method.", "author": "afalhambra", "createdAt": "2020-04-01T15:44:30Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :NAME_\" + varName + \" AND \" + alias + \".VALUE= :VALUE_\" + varName + \"\\n\");\n+        }\n+\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" pil.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT pil.processInstanceId FROM ProcessInstanceLog pil \\n \" + derivedTables + where + \" ORDER BY pil.processInstanceId ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \" \\n\" : \"\";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            query.setParameter(\"NAME_\" + var.getKey(), varPrefix + var.getKey());\n+            query.setParameter(\"VALUE_\" + var.getKey(), var.getValue());\n+        }\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            query.setParameter(\"ATTR_\" + entry.getKey(), entry.getValue());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeProcessInstanceByIdList\", singletonMap(\"idList\", ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeVariablesByProcessInstanceIdList\", singletonMap(\"idList\", ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (name.startsWith(varPrefix)) {\n+                    vars.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+    private void addWhereExpression(StringBuilder where) {\n+        where.append(where.length() == 0 ? \"WHERE \" : \" AND \");\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(Map<String, Object> attributes,", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTcxOTIzNw==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401719237", "bodyText": "We will need to check if there is any performance issue as there are several calls to DB.", "author": "afalhambra", "createdAt": "2020-04-01T15:47:54Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :NAME_\" + varName + \" AND \" + alias + \".VALUE= :VALUE_\" + varName + \"\\n\");\n+        }\n+\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" pil.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT pil.processInstanceId FROM ProcessInstanceLog pil \\n \" + derivedTables + where + \" ORDER BY pil.processInstanceId ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \" \\n\" : \"\";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            query.setParameter(\"NAME_\" + var.getKey(), varPrefix + var.getKey());\n+            query.setParameter(\"VALUE_\" + var.getKey(), var.getValue());\n+        }\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            query.setParameter(\"ATTR_\" + entry.getKey(), entry.getValue());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeProcessInstanceByIdList\", singletonMap(\"idList\", ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeVariablesByProcessInstanceIdList\", singletonMap(\"idList\", ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (name.startsWith(varPrefix)) {\n+                    vars.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+    private void addWhereExpression(StringBuilder where) {\n+        where.append(where.length() == 0 ? \"WHERE \" : \" AND \");\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(Map<String, Object> attributes,\n+                                                                                                        Map<String, Object> variables,\n+                                                                                                        Map<String, Object> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"V_TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                  \"SELECT taskId, name, value \\n\" +\n+                                  \"FROM TaskVariableImpl \\n\" +\n+                                  \"WHERE type = 0\\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".taskId = task.id  \\n\");\n+\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :V_NAME_\" + varName + \" AND \" + alias + \".VALUE= :V_VALUE_\" + varName + \"\\n\");\n+        }\n+\n+        for (Map.Entry<String, Object> var : processVariables.entrySet()) {\n+            String alias = \"P_TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :P_NAME_\" + varName + \" AND \" + alias + \".VALUE= :P_VALUE_\" + varName + \"\\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") AS pot ON pot.task_id = task.id \");\n+        }\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" task.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT task.id FROM Task task INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" + derivedTables + where + \" ORDER BY id ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \"\\n\" : \"\";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            query.setParameter(\"V_NAME_\" + var.getKey(), var.getKey());\n+            query.setParameter(\"V_VALUE_\" + var.getKey(), var.getValue());\n+        }\n+        for (Map.Entry<String, Object> var : processVariables.entrySet()) {\n+            query.setParameter(\"P_NAME_\" + var.getKey(), varPrefix + var.getKey());\n+            query.setParameter(\"P_VALUE_\" + var.getKey(), var.getValue());\n+        }\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            query.setParameter(\"ATTR_\" + entry.getKey(), entry.getValue());\n+        }\n+        if (!owners.isEmpty()) {\n+            query.setParameter(\"num_owners\", owners.size());\n+            query.setParameter(\"owners\", owners);\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+\n+        // query data\n+        List<Object[]> taskRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetTasksByIdList\", singletonMap(\"idList\", ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetTaskVariablesByTaskIdList\", singletonMap(\"idList\", ids)));\n+        List<Object[]> potRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetPotentialOwnersByTaskIdList\", singletonMap(\"idList\", ids)));\n+        List<Object[]> varProcSQLRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeProcessVariablesByTaskIdList\", singletonMap(\"idList\", ids)));", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc0MTcxNg==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401741716", "bodyText": "Shouldn't we have some kind of control about offset and count? A wrong combination of these might not return any results found in the query when for instance offset is greater than count (bear in mind that default count in a querycontext object is 10)", "author": "afalhambra", "createdAt": "2020-04-01T16:19:47Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :NAME_\" + varName + \" AND \" + alias + \".VALUE= :VALUE_\" + varName + \"\\n\");\n+        }\n+\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" pil.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT pil.processInstanceId FROM ProcessInstanceLog pil \\n \" + derivedTables + where + \" ORDER BY pil.processInstanceId ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \" \\n\" : \"\";", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMTc0NDU3NQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r401744575", "bodyText": "I would use VariableType.INPUT instead of hardcoding values in the query.", "author": "afalhambra", "createdAt": "2020-04-01T16:23:55Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :NAME_\" + varName + \" AND \" + alias + \".VALUE= :VALUE_\" + varName + \"\\n\");\n+        }\n+\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" pil.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT pil.processInstanceId FROM ProcessInstanceLog pil \\n \" + derivedTables + where + \" ORDER BY pil.processInstanceId ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \" \\n\" : \"\";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            query.setParameter(\"NAME_\" + var.getKey(), varPrefix + var.getKey());\n+            query.setParameter(\"VALUE_\" + var.getKey(), var.getValue());\n+        }\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            query.setParameter(\"ATTR_\" + entry.getKey(), entry.getValue());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeProcessInstanceByIdList\", singletonMap(\"idList\", ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeVariablesByProcessInstanceIdList\", singletonMap(\"idList\", ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (name.startsWith(varPrefix)) {\n+                    vars.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+    private void addWhereExpression(StringBuilder where) {\n+        where.append(where.length() == 0 ? \"WHERE \" : \" AND \");\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(Map<String, Object> attributes,\n+                                                                                                        Map<String, Object> variables,\n+                                                                                                        Map<String, Object> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"V_TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                  \"SELECT taskId, name, value \\n\" +\n+                                  \"FROM TaskVariableImpl \\n\" +\n+                                  \"WHERE type = 0\\n\" +", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2MzM4OA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402263388", "bodyText": "<String, Object> not needed.", "author": "afalhambra", "createdAt": "2020-04-02T12:10:23Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/model/UserTaskInstanceWithPotOwnerDesc.java", "diffHunk": "@@ -156,5 +158,37 @@ public String getProcessInstanceDescription() {\n     public void setProcessInstanceDescription(String processInstanceDescription) {\n         this.processInstanceDescription = processInstanceDescription;\n     }\n+\n+    public void addProcessVariable(String variable, Object variableValue) {\n+        if (this.processVariables == null) {\n+            this.processVariables = new HashMap<String, Object>();\n+        }\n+        this.processVariables.put(variable, variableValue);\n+    }\n+\n+    @Override\n+    public Map<String, Object> getProcessVariables() {\n+        return processVariables;\n+    }\n+\n+    public void setProcessVariables(Map<String, Object> processVariables) {\n+        this.processVariables = processVariables;\n+    }\n+\n+    public void addExtraData(String variable, Object variableValue) {\n+        if (this.data == null) {\n+            this.data = new HashMap<String, Object>();", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2MzQ5NQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402263495", "bodyText": "<String, Object> not needed.", "author": "afalhambra", "createdAt": "2020-04-02T12:10:34Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/model/UserTaskInstanceWithPotOwnerDesc.java", "diffHunk": "@@ -156,5 +158,37 @@ public String getProcessInstanceDescription() {\n     public void setProcessInstanceDescription(String processInstanceDescription) {\n         this.processInstanceDescription = processInstanceDescription;\n     }\n+\n+    public void addProcessVariable(String variable, Object variableValue) {\n+        if (this.processVariables == null) {\n+            this.processVariables = new HashMap<String, Object>();", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2NDYyMw==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402264623", "bodyText": "Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap", "author": "afalhambra", "createdAt": "2020-04-02T12:12:50Z", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2NDc2OQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402264769", "bodyText": "Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap", "author": "afalhambra", "createdAt": "2020-04-02T12:13:06Z", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2NDgzOQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402264839", "bodyText": "Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap", "author": "afalhambra", "createdAt": "2020-04-02T12:13:12Z", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjI2NDg5Mw==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402264893", "bodyText": "Collections.<String, Object> singletonMap can be replaced with just Collections.singletonMap", "author": "afalhambra", "createdAt": "2020-04-02T12:13:20Z", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM3MDY5NA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402370694", "bodyText": "Why not just use emptyList() as input parameter for the queryUserTaskByVariables rather than creating a non-used variable potOwners?", "author": "afalhambra", "createdAt": "2020-04-02T14:45:33Z", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM3MTMzNQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402371335", "bodyText": "Why not just use emptyList() as input parameter for the queryUserTaskByVariables rather than creating a non-used variable potOwners?", "author": "afalhambra", "createdAt": "2020-04-02T14:46:22Z", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM3NjU1MA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402376550", "bodyText": "How do we iterate through batches of a particular query with some pagination?", "author": "afalhambra", "createdAt": "2020-04-02T14:52:45Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :NAME_\" + varName + \" AND \" + alias + \".VALUE= :VALUE_\" + varName + \"\\n\");\n+        }\n+\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" pil.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT pil.processInstanceId FROM ProcessInstanceLog pil \\n \" + derivedTables + where + \" ORDER BY pil.processInstanceId ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \" \\n\" : \"\";", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM3OTIzMw==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402379233", "bodyText": "We're already passing processVariables as emptyMap*) in call, why not do the same for these?", "author": "afalhambra", "createdAt": "2020-04-02T14:56:00Z", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM4NDc4OA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402384788", "bodyText": "How would you get the next batch for pagination?", "author": "afalhambra", "createdAt": "2020-04-02T15:02:50Z", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Collections.singletonList(\"katy\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjM5MzEzNA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402393134", "bodyText": "Is \"deploymentId\" part of the requirements? I don't see it listed on the filters table.", "author": "afalhambra", "createdAt": "2020-04-02T15:13:41Z", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwMDI0NQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402400245", "bodyText": "Shouldn't return any record that matches with one of the owners? If I set potOwners as \"katy\" and \"nobody\", I would expect to get all the records concerning to the potential owner for the task. In this case it would be all the tasks for \"katy\" - data.size()=10?", "author": "afalhambra", "createdAt": "2020-04-02T15:23:07Z", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Collections.singletonList(\"katy\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertTrue(p.getPotentialOwners().contains(\"katy\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithAllOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Arrays.asList(\"katy\", \"nobody\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(0, data.size());", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQwMTIwNA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402401204", "bodyText": "I would probably not use pagination to avoid any confusion in the test. I would create a separate test for pagination.", "author": "afalhambra", "createdAt": "2020-04-02T15:24:21Z", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Collections.singletonList(\"katy\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertTrue(p.getPotentialOwners().contains(\"katy\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithAllOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Arrays.asList(\"katy\", \"nobody\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQxNjc0Mg==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402416742", "bodyText": "Number of instances matching search criteria ( processVariable = \"var_a\", \"a1\" ) are 3, or am I missing something?.\nIf I change it to the following below, I get data size = 3 (which I presume it is correct):\nMap<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a1\");", "author": "afalhambra", "createdAt": "2020-04-02T15:45:28Z", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Collections.singletonList(\"katy\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertTrue(p.getPotentialOwners().contains(\"katy\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithAllOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Arrays.asList(\"katy\", \"nobody\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(0, data.size());\n+\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithByProcessVar() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        Map<String, Object> processVariables = Collections.singletonMap(\"var_a\", \"a1\");\n+        List<String> potOwners = Collections.emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, processVariables, potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI0NjM3NQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r404246375", "bodyText": "pagination... only two returned.", "author": "elguardian", "createdAt": "2020-04-06T16:59:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQxNjc0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQyMDk0NA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r402420944", "bodyText": "I think it would be good to add at least one test for each of the different filters we agreed on the jira ticket.\nAnd I'm missing some tests regarding:\nActual task owner | \u2718 | \u2718 | \u2713 | \u2713 | Filters by task actual owner\nCorrelation key | \u2713 | \u2713 | \u2713 | \u2713 | Filters by correlation key name\nTask name | \u2718 | \u2718 | \u2713 | \u2713 | Filters by task name\nProcess definition id | \u2718 | \u2713 | \u2718 | \u2713 | Filters by process definition id\nMaybe a test containing a combination of them with some pagination would be nice too, but maybe it is too much, wdyt?", "author": "afalhambra", "createdAt": "2020-04-02T15:51:18Z", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static java.util.Collections.emptyMap;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext());\n+        Assert.assertEquals(3, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"var_a\", \"a1\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"processId\", \"test.test_A\");\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext());\n+        Assert.assertEquals(4, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithPagination() {\n+        Map<String, Object> variables = Collections.<String, Object> singletonMap(\"task_in_a1\", \"a0\");\n+        Map<String, Object> attributes = Collections.<String, Object> singletonMap(\"deploymentId\", \"org.jbpm.test:test-module:1.0.0\");\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Collections.singletonList(\"katy\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertTrue(p.getPotentialOwners().contains(\"katy\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithAllOwners() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        List<String> potOwners = Arrays.asList(\"katy\", \"nobody\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyMap(), potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(0, data.size());\n+\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithByProcessVar() {\n+        Map<String, Object> variables = emptyMap();\n+        Map<String, Object> attributes = emptyMap();\n+        Map<String, Object> processVariables = Collections.singletonMap(\"var_a\", \"a1\");\n+        List<String> potOwners = Collections.emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, processVariables, potOwners, new QueryContext(0, 2));\n+        Assert.assertEquals(2, data.size());\n+\n+    }\n+\n+}", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDU4NjQ1OQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r404586459", "bodyText": "done", "author": "elguardian", "createdAt": "2020-04-07T07:15:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQyMDk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkxMTk3Nw==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r403911977", "bodyText": "Do not use log_date, but id, for ordering, as log_date may be the same.\nInvert the order to pick up the current value", "author": "gmunozfe", "createdAt": "2020-04-06T08:24:59Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkzOTcyOQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r403939729", "bodyText": "This native query is failing when using an Oracle database: ORA-00933: SQL command not properly ended\nSeems it could be related to the pagination part of the SQL statement.", "author": "afalhambra", "createdAt": "2020-04-06T09:09:49Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :NAME_\" + varName + \" AND \" + alias + \".VALUE= :VALUE_\" + varName + \"\\n\");\n+        }\n+\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" pil.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT pil.processInstanceId FROM ProcessInstanceLog pil \\n \" + derivedTables + where + \" ORDER BY pil.processInstanceId ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \" \\n\" : \"\";", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzkzOTkwNQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r403939905", "bodyText": "This native query is failing when using an Oracle database: ORA-00933: SQL command not properly ended\nSeems it could be related to the pagination part of the SQL statement.", "author": "afalhambra", "createdAt": "2020-04-06T09:10:08Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,306 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(Map<String, Object> attributes,\n+                                                                                                 Map<String, Object> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :NAME_\" + varName + \" AND \" + alias + \".VALUE= :VALUE_\" + varName + \"\\n\");\n+        }\n+\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" pil.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT pil.processInstanceId FROM ProcessInstanceLog pil \\n \" + derivedTables + where + \" ORDER BY pil.processInstanceId ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \" \\n\" : \"\";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            query.setParameter(\"NAME_\" + var.getKey(), varPrefix + var.getKey());\n+            query.setParameter(\"VALUE_\" + var.getKey(), var.getValue());\n+        }\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            query.setParameter(\"ATTR_\" + entry.getKey(), entry.getValue());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeProcessInstanceByIdList\", singletonMap(\"idList\", ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GeVariablesByProcessInstanceIdList\", singletonMap(\"idList\", ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (name.startsWith(varPrefix)) {\n+                    vars.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+    private void addWhereExpression(StringBuilder where) {\n+        where.append(where.length() == 0 ? \"WHERE \" : \" AND \");\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(Map<String, Object> attributes,\n+                                                                                                        Map<String, Object> variables,\n+                                                                                                        Map<String, Object> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        StringBuilder where = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        for (Map.Entry<String, Object> var : variables.entrySet()) {\n+            String alias = \"V_TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                  \"SELECT taskId, name, value \\n\" +\n+                                  \"FROM TaskVariableImpl \\n\" +\n+                                  \"WHERE type = 0\\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".taskId = task.id  \\n\");\n+\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :V_NAME_\" + varName + \" AND \" + alias + \".VALUE= :V_VALUE_\" + varName + \"\\n\");\n+        }\n+\n+        for (Map.Entry<String, Object> var : processVariables.entrySet()) {\n+            String alias = \"P_TABLE_\" + var.getKey();\n+            String varName = var.getKey();\n+\n+            derivedTables.append(\"LEFT JOIN (\" +\n+                                 \"SELECT A1.processId, A1.processInstanceId, A1.variableId AS NAME, A1.value AS VALUE \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.log_date < A1.log_date  \\n\" +\n+                                 \"WHERE A2.log_date IS NULL \\n\" +\n+                                 \") \" + alias + \" ON \" + alias + \".processId = pil.processId AND \" + alias + \".processInstanceId = pil.processInstanceId \\n\");\n+\n+            addWhereExpression(where);\n+            where.append(alias + \".NAME = :P_NAME_\" + varName + \" AND \" + alias + \".VALUE= :P_VALUE_\" + varName + \"\\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") AS pot ON pot.task_id = task.id \");\n+        }\n+\n+        for (Map.Entry<String, Object> entry : attributes.entrySet()) {\n+            addWhereExpression(where);\n+            where.append(\" task.\" + entry.getKey() + \" = :ATTR_\" + entry.getKey() + \" \");\n+        }\n+\n+        addWhereExpression(where);\n+        where.append(\" pil.processType = :processType \");\n+\n+        String procSQLString = \"SELECT DISTINCT task.id FROM Task task INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" + derivedTables + where + \" ORDER BY id ASC \";\n+        procSQLString += (queryContext.getCount() > 0) ? \" LIMIT \" + queryContext.getCount() + \" OFFSET \" + queryContext.getOffset() + \"\\n\" : \"\";", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDAzMjg0Nw==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r404032847", "bodyText": "Not sure whether it makes sense to have a \"ProcessInstanceWithVarDes\" as a class and another class for cases something like \"CaseInstanceWithVarDes\"? wdyt?. Only to make it a little more clear.", "author": "afalhambra", "createdAt": "2020-04-06T11:55:08Z", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,52 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.AdvanceCaseRuntimeDataService;\n+import org.jbpm.kie.services.impl.AbstractAdvanceRuntimeDataServiceImpl;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static org.jbpm.process.core.context.variable.VariableScope.CASE_FILE_PREFIX;\n+import static org.jbpm.workflow.core.WorkflowProcess.CASE_TYPE;\n+\n+public class AdvanceCaseRuntimeDataServiceImpl extends AbstractAdvanceRuntimeDataServiceImpl implements AdvanceCaseRuntimeDataService {\n+\n+\n+    @Override\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryCaseByVariables(Map<String, Object> attributes,", "originalCommit": "1e57dd6f9a77d2e636949457815115ca83acc4dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDI1MjM1OQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r404252359", "bodyText": "Yeah I did have that in my mind and you are right I did it because they are different concepts.", "author": "elguardian", "createdAt": "2020-04-06T17:08:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDAzMjg0Nw=="}], "type": "inlineReview"}, {"oid": "dff54f99161103a3aa333b880692a15f1e9f4e62", "url": "https://github.com/kiegroup/jbpm/commit/dff54f99161103a3aa333b880692a15f1e9f4e62", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables", "committedDate": "2020-04-07T07:15:02Z", "type": "forcePushed"}, {"oid": "6fd45ee7d05cde3ff61064aea2bb498a4f24cf13", "url": "https://github.com/kiegroup/jbpm/commit/6fd45ee7d05cde3ff61064aea2bb498a4f24cf13", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables", "committedDate": "2020-04-08T15:25:44Z", "type": "forcePushed"}, {"oid": "8f6dc5c29e4b25d899d77449a7cc8f582ecb6cec", "url": "https://github.com/kiegroup/jbpm/commit/8f6dc5c29e4b25d899d77449a7cc8f582ecb6cec", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables", "committedDate": "2020-04-08T18:45:00Z", "type": "forcePushed"}, {"oid": "a85cc9afbb1d98d23d4755b7dfd572a6a6cc360e", "url": "https://github.com/kiegroup/jbpm/commit/a85cc9afbb1d98d23d4755b7dfd572a6a6cc360e", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables", "committedDate": "2020-04-09T15:18:45Z", "type": "forcePushed"}, {"oid": "be7638ebf3d5375b391afebd158bc99a5008f0c7", "url": "https://github.com/kiegroup/jbpm/commit/be7638ebf3d5375b391afebd158bc99a5008f0c7", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables", "committedDate": "2020-04-09T15:25:46Z", "type": "forcePushed"}, {"oid": "7254bbd4405c29a3f8eb4f1b3967ee8c78cfd26a", "url": "https://github.com/kiegroup/jbpm/commit/7254bbd4405c29a3f8eb4f1b3967ee8c78cfd26a", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables", "committedDate": "2020-04-12T16:59:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM4NTEyMA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r407385120", "bodyText": "These 3 operators can be grouped", "author": "gmunozfe", "createdAt": "2020-04-13T08:53:33Z", "path": "jbpm-services/jbpm-services-api/src/main/java/org/jbpm/services/api/query/model/QueryParam.java", "diffHunk": "@@ -303,6 +313,67 @@ public void setValue(List<?> value) {\n         this.value = value;\n     }\n \n+    public Object getObjectValue() {\n+        if (value == null || value.isEmpty()) {\n+            return null;\n+        }\n+        switch (type()) {\n+            case BINARY_OPERAND:\n+                return value.get(0);\n+            case RANGE_OPERAND:\n+                return value.subList(0, 2);\n+            case UNARY_OPERAND:\n+            case AGGREGATE:\n+                return null;\n+            case LIST_OPERAND:\n+            default:\n+                return value;\n+        }\n+\n+    }\n+\n+    private enum Type {\n+        DEFAULT,\n+        AGGREGATE,\n+        UNARY_OPERAND,\n+        BINARY_OPERAND,\n+        RANGE_OPERAND,\n+        LIST_OPERAND\n+    }\n+\n+    private Type type() {\n+        switch (operator) {\n+            case \"IS_NULL\":\n+            case \"NOT_NULL\":\n+            case \"DISTINCT\":\n+                return Type.UNARY_OPERAND;\n+            case \"MIN\":\n+            case \"MAX\":\n+            case \"SUM\":\n+            case \"AVERAGE\":\n+            case \"COUNT\":\n+                return Type.AGGREGATE;\n+            case \"EQUALS_TO\":\n+            case \"NOT_EQUALS_TO\":\n+            case \"LIKE_TO\":\n+            case \"GREATER_THAN\":\n+            case \"LESS_THAN\":\n+            case \"GREATER_OR_EQUALS_TO\":\n+            case \"LESS_OR_EQUALS_TO\":\n+                return Type.BINARY_OPERAND;\n+            case \"BETWEEN\":\n+                return Type.LIST_OPERAND;\n+            case \"IN\":\n+            case \"NOT_IN\":", "originalCommit": "7254bbd4405c29a3f8eb4f1b3967ee8c78cfd26a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg5NjgzNg==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r407896836", "bodyText": "should be range operand.", "author": "elguardian", "createdAt": "2020-04-14T06:32:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzM4NTEyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQyODUxMw==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r407428513", "bodyText": "Change the test name as it is testing isNotNull operator\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testQueryIsNullOperator() {\n          \n          \n            \n                public void testQueryIsNotNullOperator() {", "author": "gmunozfe", "createdAt": "2020-04-13T11:02:40Z", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,348 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_CORRELATION_KEY;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEFINITION_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEPLOYMENT_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_NAME;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_OWNER;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.in;\n+import static org.jbpm.services.api.query.model.QueryParam.isNotNull;\n+import static org.jbpm.services.api.query.model.QueryParam.likeTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.jbpm.services.api.query.model.QueryParam.notEqualsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.notIn;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+@RunWith(Parameterized.class)\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    @Parameters(name = \"Pagination {0}\")\n+    public static Iterable<? extends Object> data() {\n+        return Arrays.asList(0, 2);\n+    }\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+    private QueryContext queryContext;\n+\n+    public AdvanceRuntimeDataServiceImplTest(Integer count) {\n+        this.queryContext = new QueryContext(0, count);\n+    }\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        List<QueryParam> variables = list(equalsTo(\"var_a\", \"a1\"), equalsTo(\"var_b\", \"1\"));\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"1\", p.getVariables().get(\"var_b\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryInOperator() {\n+\n+        List<QueryParam> variables = list(in(\"var_a\", \"a1\", \"a2\"));\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        List<String> values = Arrays.asList(\"a1\", \"a2\");\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertTrue(values.contains(p.getVariables().get(\"var_a\")));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryLikeToOperator() {\n+\n+        List<QueryParam> variables = list(likeTo(\"var_a\", false, \"a%\"));\n+        List<QueryParam> attributes = list(likeTo(PROCESS_ATTR_DEFINITION_ID, false, \"%test_A%\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertTrue(((String) p.getVariables().get(\"var_a\")).startsWith(\"a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryIsNullOperator() {", "originalCommit": "7254bbd4405c29a3f8eb4f1b3967ee8c78cfd26a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzg5NzYzOQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r407897639", "bodyText": "done", "author": "elguardian", "createdAt": "2020-04-14T06:35:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNzQyODUxMw=="}], "type": "inlineReview"}, {"oid": "f04f50355ec285330b3467d42754a036a04b1db3", "url": "https://github.com/kiegroup/jbpm/commit/f04f50355ec285330b3467d42754a036a04b1db3", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables", "committedDate": "2020-04-14T06:53:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc1Nzc2Ng==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r404757766", "bodyText": "\"public static\" are redundant for an interface. Please remove them.", "author": "afalhambra", "createdAt": "2020-04-07T12:09:32Z", "path": "jbpm-case-mgmt/jbpm-case-mgmt-api/src/main/java/org/jbpm/casemgmt/api/AdvanceCaseRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.api;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceCaseRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String CASE_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String CASE_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String CASE_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String CASE_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";", "originalCommit": "dff54f99161103a3aa333b880692a15f1e9f4e62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAyOTM2MQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r410029361", "bodyText": "done", "author": "elguardian", "createdAt": "2020-04-17T07:02:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDc1Nzc2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg3MTY4Nw==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r404871687", "bodyText": "\"public static\" are redundant for an interface. Please remove them.", "author": "afalhambra", "createdAt": "2020-04-07T14:51:46Z", "path": "jbpm-services/jbpm-services-api/src/main/java/org/jbpm/services/api/AdvanceRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.services.api;\n+\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String PROCESS_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String PROCESS_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String PROCESS_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String PROCESS_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";", "originalCommit": "dff54f99161103a3aa333b880692a15f1e9f4e62", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAyOTU3Mw==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r410029573", "bodyText": "done", "author": "elguardian", "createdAt": "2020-04-17T07:02:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDg3MTY4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA3NTczOQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408075739", "bodyText": "Deployment ID is not specified in the jira ticket. We should either update jira ticket or remove this field. What do you think @elguardian?", "author": "afalhambra", "createdAt": "2020-04-14T11:51:38Z", "path": "jbpm-services/jbpm-services-api/src/main/java/org/jbpm/services/api/AdvanceRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.services.api;\n+\n+import java.util.List;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String PROCESS_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String PROCESS_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String PROCESS_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String PROCESS_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAyOTc4Nw==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r410029787", "bodyText": "nope. It is convenient to shrink the results (performance)", "author": "elguardian", "createdAt": "2020-04-17T07:03:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA3NTczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4NTg3MA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408085870", "bodyText": "Would it make sense to rename it to caseVariables rather than processVariables?", "author": "afalhambra", "createdAt": "2020-04-14T12:10:39Z", "path": "jbpm-case-mgmt/jbpm-case-mgmt-api/src/main/java/org/jbpm/casemgmt/api/AdvanceCaseRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.api;\n+\n+import java.util.List;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceCaseRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String CASE_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String CASE_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String CASE_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String CASE_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";\n+\n+    List<ProcessInstanceWithVarsDesc> queryCaseByVariables(List<QueryParam> attributes,\n+                                                           List<QueryParam> variables,\n+                                                           QueryContext queryContext);\n+\n+    List<UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                     List<QueryParam> variables,\n+                                                                     List<QueryParam> processVariables,", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAzMDAwOA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r410030008", "bodyText": "well the main entity here is the user tasks not really the process.", "author": "elguardian", "createdAt": "2020-04-17T07:03:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4NTg3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4NzE0MA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408087140", "bodyText": "Deployment ID is not specified in the jira ticket. We should either update jira ticket or remove this field. What do you think @elguardian?", "author": "afalhambra", "createdAt": "2020-04-14T12:12:56Z", "path": "jbpm-case-mgmt/jbpm-case-mgmt-api/src/main/java/org/jbpm/casemgmt/api/AdvanceCaseRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.api;\n+\n+import java.util.List;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceCaseRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String CASE_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String CASE_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String CASE_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String CASE_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAzMDExOQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r410030119", "bodyText": "it is convenient.", "author": "elguardian", "createdAt": "2020-04-17T07:03:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4NzE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4NzkyNA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408087924", "bodyText": "Would it make sense to declare translateTable as final?", "author": "afalhambra", "createdAt": "2020-04-14T12:14:25Z", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.AdvanceCaseRuntimeDataService;\n+import org.jbpm.kie.services.impl.AbstractAdvanceRuntimeDataServiceImpl;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static org.jbpm.process.core.context.variable.VariableScope.CASE_FILE_PREFIX;\n+import static org.jbpm.workflow.core.WorkflowProcess.CASE_TYPE;\n+\n+public class AdvanceCaseRuntimeDataServiceImpl extends AbstractAdvanceRuntimeDataServiceImpl implements AdvanceCaseRuntimeDataService {\n+\n+    private Map<String, String> translateTable = new HashMap<>();", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMDYzMg==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r411210632", "bodyText": "ok", "author": "elguardian", "createdAt": "2020-04-20T08:58:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4NzkyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4ODQ0Ng==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408088446", "bodyText": "Would it make sense to rename it to caseVariables rather than processVariables?", "author": "afalhambra", "createdAt": "2020-04-14T12:15:23Z", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.AdvanceCaseRuntimeDataService;\n+import org.jbpm.kie.services.impl.AbstractAdvanceRuntimeDataServiceImpl;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static org.jbpm.process.core.context.variable.VariableScope.CASE_FILE_PREFIX;\n+import static org.jbpm.workflow.core.WorkflowProcess.CASE_TYPE;\n+\n+public class AdvanceCaseRuntimeDataServiceImpl extends AbstractAdvanceRuntimeDataServiceImpl implements AdvanceCaseRuntimeDataService {\n+\n+    private Map<String, String> translateTable = new HashMap<>();\n+\n+    public AdvanceCaseRuntimeDataServiceImpl() {\n+        translateTable.put(CASE_ATTR_CORRELATION_KEY, \"pil.correlationKey\");\n+        translateTable.put(CASE_ATTR_DEFINITION_ID, \"pil.processId\");\n+        translateTable.put(CASE_ATTR_INSTANCE_ID, \"pil.processInstanceId\");\n+        translateTable.put(CASE_ATTR_DEPLOYMENT_ID, \"pil.externalId\");\n+        translateTable.put(TASK_ATTR_NAME, \"task.name\");\n+        translateTable.put(TASK_ATTR_OWNER, \"task.actualOwner_id\");\n+\n+    }\n+\n+    @Override\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryCaseByVariables(List<QueryParam> attributes,\n+                                                                                              List<QueryParam> variables,\n+                                                                                              QueryContext queryContext) {\n+        return queryProcessByVariables(translate(translateTable, attributes), variables, CASE_TYPE, CASE_FILE_PREFIX, queryContext);\n+\n+    }\n+\n+\n+    @Override\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMTE4MA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r411211180", "bodyText": "ok", "author": "elguardian", "createdAt": "2020-04-20T08:59:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODA4ODQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEyNzQ1OA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408127458", "bodyText": "I would expect to pass variable data and owners as part of the query criteria in this call.", "author": "afalhambra", "createdAt": "2020-04-14T13:16:52Z", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+\n+import static java.util.Collections.emptyList;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        return processes;\n+    }\n+\n+    /*\n+     * Case instance queries\n+     */\n+    @Test\n+    public void testSearchByVariable() {\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, data);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, caseFile);\n+\n+        List<QueryParam> vars = list(equalsTo(\"name\", \"my first case\"));\n+\n+        List<ProcessInstanceWithVarsDesc> process = advanceCaseRuntimeDataService.queryCaseByVariables(emptyList(), vars, new QueryContext());\n+        assertEquals(1, process.size());\n+        assertEquals(\"my first case\", process.get(0).getExtraData().get(\"name\"));\n+\n+        assertNotNull(caseId);\n+        assertEquals(FIRST_CASE_ID, caseId);\n+        caseService.cancelCase(caseId);\n+\n+    }\n+\n+    @Test\n+    public void testSearchUserByVariable() {\n+        Map<String, OrganizationalEntity> roleAssignments = new HashMap<>();\n+        roleAssignments.put(\"owner\", new UserImpl(USER));\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, data, roleAssignments);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, caseFile);\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> process = advanceCaseRuntimeDataService.queryUserTasksByVariables(emptyList(), emptyList(), emptyList(), emptyList(), new QueryContext());", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMjAwNw==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r411212007", "bodyText": "well that is test already in other integration test.", "author": "elguardian", "createdAt": "2020-04-20T09:00:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEyNzQ1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEyODQwMQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408128401", "bodyText": "For case and casetasks I would be missing some tests regarding to the requirements we have. So far we are currently testing:\nPotential owner\t\u2718\t\u2718\t\u2713\t\u2713\tFilters by task potential owner (in case of more than one, all must match)\nCase File Var\t\u2713\t\u2718\t\u2713\t\u2718\tFilter by case var name=value\nAnd I'm missing:\nActual task owner | \u2718 | \u2718 | \u2713 | \u2713 | Filters by task actual owner\nCorrelation key | \u2713 | \u2713 | \u2713 | \u2713 | Filters by correlation key name\nTask name | \u2718 | \u2718 | \u2713 | \u2713 | Filters by task name\nCase definition id | \u2713 | \u2718 | \u2713 | \u2718 | Filters by case definition id\nCase instance id | \u2713 | \u2718 | \u2713 | \u2718 | Filters by case instance id\nTask Variables | \u2718 | \u2718 | \u2713 | \u2713 | Filter by task variable name=value\nAlso, would be nice to have some pagination test along with the use of the operator (equal, not_equal, etc). Let me know, if not I can add some to it afterwards. What do you think?", "author": "afalhambra", "createdAt": "2020-04-14T13:18:15Z", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/test/java/org/jbpm/casemgmt/impl/AdvanceCaseRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.impl;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.casemgmt.api.model.instance.CaseFileInstance;\n+import org.jbpm.casemgmt.impl.util.AbstractCaseServicesBaseTest;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.services.task.impl.model.UserImpl;\n+import org.junit.Test;\n+import org.kie.api.runtime.query.QueryContext;\n+import org.kie.api.task.model.OrganizationalEntity;\n+\n+import static java.util.Collections.emptyList;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotNull;\n+\n+public class AdvanceCaseRuntimeDataServiceImplTest extends AbstractCaseServicesBaseTest {\n+\n+\n+    @Override\n+    protected List<String> getProcessDefinitionFiles() {\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"cases/EmptyCase.bpmn2\");\n+        processes.add(\"cases/UserTaskCase.bpmn2\");\n+        return processes;\n+    }\n+\n+    /*\n+     * Case instance queries\n+     */\n+    @Test\n+    public void testSearchByVariable() {\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, data);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), EMPTY_CASE_P_ID, caseFile);\n+\n+        List<QueryParam> vars = list(equalsTo(\"name\", \"my first case\"));\n+\n+        List<ProcessInstanceWithVarsDesc> process = advanceCaseRuntimeDataService.queryCaseByVariables(emptyList(), vars, new QueryContext());\n+        assertEquals(1, process.size());\n+        assertEquals(\"my first case\", process.get(0).getExtraData().get(\"name\"));\n+\n+        assertNotNull(caseId);\n+        assertEquals(FIRST_CASE_ID, caseId);\n+        caseService.cancelCase(caseId);\n+\n+    }\n+\n+    @Test\n+    public void testSearchUserByVariable() {\n+        Map<String, OrganizationalEntity> roleAssignments = new HashMap<>();\n+        roleAssignments.put(\"owner\", new UserImpl(USER));\n+\n+        Map<String, Object> data = new HashMap<>();\n+        data.put(\"name\", \"my first case\");\n+        CaseFileInstance caseFile = caseService.newCaseFileInstance(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, data, roleAssignments);\n+\n+        String caseId = caseService.startCase(deploymentUnit.getIdentifier(), USER_TASK_CASE_P_ID, caseFile);\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> process = advanceCaseRuntimeDataService.queryUserTasksByVariables(emptyList(), emptyList(), emptyList(), emptyList(), new QueryContext());\n+        assertEquals(1, process.size());\n+        assertEquals(\"my first case\", process.get(0).getExtraData().get(\"name\"));\n+\n+        assertNotNull(caseId);\n+        assertEquals(HR_CASE_ID, caseId);\n+        caseService.cancelCase(caseId);\n+\n+    }\n+\n+}", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMjQxNg==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r411212416", "bodyText": "all those are test. keep in mind that is reusing things from the abstract class.", "author": "elguardian", "createdAt": "2020-04-20T09:01:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEyODQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEyOTExNQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408129115", "bodyText": "QueryContext has ordering asc or desc capabilities but it is not used in the query. Should we take this into account?", "author": "afalhambra", "createdAt": "2020-04-14T13:19:14Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODEzNTg0MA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408135840", "bodyText": "I would rename it to \"uwv\" (UserTaskInstanceWithPotOwnerDesc) instead of \"pwv\" (ProcessInstanceWithVarsDesc)", "author": "afalhambra", "createdAt": "2020-04-14T13:28:38Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_PROCVARS \" +\n+                                 \") TABLE_PROC_VAR ON TABLE_PROC_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") pot ON pot.task_id = task.id \");\n+        }\n+\n+        attributes.stream().forEach((expr) -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString = \"SELECT DISTINCT task.id \" +\n+                               \" FROM Task task \" +\n+                               \" INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" +\n+                               derivedTables +\n+                               \" WHERE  pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY task.id ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"V_NAME_\" + var.getColumn(), var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"V_VALUE_\" + var.getColumn(), var.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_TASKVARS\", variables.size());\n+        }\n+\n+        processVariables.stream().forEach(var -> query.setParameter(\"P_NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        processVariables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"P_VALUE_\" + var.getColumn(), var.getObjectValue()));\n+\n+        if (!processVariables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_PROCVARS\", processVariables.size());\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            query.setParameter(\"num_owners\", owners.size());\n+            query.setParameter(\"owners\", owners);\n+        }\n+\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach(entry -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        entityManager.close();\n+        return collectData(ids, varPrefix);\n+\n+    }\n+\n+    private List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> collectData(List<Number> ids, String varPrefix) {\n+        // query data\n+        List<Object[]> taskRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetTasksByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetTaskVariablesByTaskIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> potRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetPotentialOwnersByTaskIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varProcSQLRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessVariablesByTaskIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        int currentPotIdx = 0;\n+        int currentVarProcIdx = 0;\n+        List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> data = new ArrayList<>();\n+        for (Object[] row : taskRows) {\n+            UserTaskInstanceWithPotOwnerDesc pwv = toUserTaskInstanceWithPotOwnerDesc(row);", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI1NzM5NQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408257395", "bodyText": "I would use TaskVariable.VariableType.INPUT instead of hardcoding values in the query.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                             \"WHERE type = 0 AND (\" + where + \")\\n\" +\n          \n          \n            \n                                             \"WHERE type = :type AND (\" + where + \")\\n\" +\n          \n          \n            \n                                             ...\n          \n          \n            \n                                             query.setParameter(type, TaskVariable.VariableType.INPUT)", "author": "afalhambra", "createdAt": "2020-04-14T16:07:18Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5Mzg1Nw==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408293857", "bodyText": "a list can contain duplicate values. It is not supposed to happen but it could and if so, this query wouldn't work - wdyt?", "author": "afalhambra", "createdAt": "2020-04-14T17:01:06Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODI5NDc3MA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408294770", "bodyText": "I think it would nice to have some of these important method with some java documentation. wdyt?", "author": "afalhambra", "createdAt": "2020-04-14T17:02:33Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYyNzQ5NA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408627494", "bodyText": "Why \"owners\" is only matching those with \"IN\" statement condition? Shouldn't be like the others? I mean, should it not depend on the operator condition like \"EQUALS\", \"NOT_EQUALS\", etc? I know it's in the jira ticket, but not really sure why this different behavior for \"owners\"?", "author": "afalhambra", "createdAt": "2020-04-15T07:12:55Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_PROCVARS \" +\n+                                 \") TABLE_PROC_VAR ON TABLE_PROC_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzNTc4Mw==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408635783", "bodyText": "Should we not close entityManager after fetching data in the collectData method?", "author": "afalhambra", "createdAt": "2020-04-15T07:29:00Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_PROCVARS \" +\n+                                 \") TABLE_PROC_VAR ON TABLE_PROC_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") pot ON pot.task_id = task.id \");\n+        }\n+\n+        attributes.stream().forEach((expr) -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString = \"SELECT DISTINCT task.id \" +\n+                               \" FROM Task task \" +\n+                               \" INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" +\n+                               derivedTables +\n+                               \" WHERE  pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY task.id ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"V_NAME_\" + var.getColumn(), var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"V_VALUE_\" + var.getColumn(), var.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_TASKVARS\", variables.size());\n+        }\n+\n+        processVariables.stream().forEach(var -> query.setParameter(\"P_NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        processVariables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"P_VALUE_\" + var.getColumn(), var.getObjectValue()));\n+\n+        if (!processVariables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_PROCVARS\", processVariables.size());\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            query.setParameter(\"num_owners\", owners.size());\n+            query.setParameter(\"owners\", owners);\n+        }\n+\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach(entry -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        entityManager.close();\n+        return collectData(ids, varPrefix);", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODYzODM5Mw==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408638393", "bodyText": "Would it not be better to use TaskVariable.VariableType.INPUT here instead of \"0\"?", "author": "afalhambra", "createdAt": "2020-04-15T07:33:46Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_PROCVARS \" +\n+                                 \") TABLE_PROC_VAR ON TABLE_PROC_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") pot ON pot.task_id = task.id \");\n+        }\n+\n+        attributes.stream().forEach((expr) -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString = \"SELECT DISTINCT task.id \" +\n+                               \" FROM Task task \" +\n+                               \" INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" +\n+                               derivedTables +\n+                               \" WHERE  pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY task.id ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"V_NAME_\" + var.getColumn(), var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"V_VALUE_\" + var.getColumn(), var.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_TASKVARS\", variables.size());\n+        }\n+\n+        processVariables.stream().forEach(var -> query.setParameter(\"P_NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        processVariables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"P_VALUE_\" + var.getColumn(), var.getObjectValue()));\n+\n+        if (!processVariables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_PROCVARS\", processVariables.size());\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            query.setParameter(\"num_owners\", owners.size());\n+            query.setParameter(\"owners\", owners);\n+        }\n+\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach(entry -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        entityManager.close();\n+        return collectData(ids, varPrefix);\n+\n+    }\n+\n+    private List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> collectData(List<Number> ids, String varPrefix) {\n+        // query data\n+        List<Object[]> taskRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetTasksByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetTaskVariablesByTaskIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> potRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetPotentialOwnersByTaskIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varProcSQLRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessVariablesByTaskIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        int currentPotIdx = 0;\n+        int currentVarProcIdx = 0;\n+        List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> data = new ArrayList<>();\n+        for (Object[] row : taskRows) {\n+            UserTaskInstanceWithPotOwnerDesc pwv = toUserTaskInstanceWithPotOwnerDesc(row);\n+\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                if (((Number) varRows.get(currentVarIdx)[1]).intValue() == 0) {", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MjYwOQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408642609", "bodyText": "Would it make sense to declare translateTable as final?", "author": "afalhambra", "createdAt": "2020-04-15T07:41:36Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jbpm.services.api.AdvanceRuntimeDataService;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static org.jbpm.workflow.core.WorkflowProcess.PROCESS_TYPE;\n+\n+public class AdvanceRuntimeDataServiceImpl extends AbstractAdvanceRuntimeDataServiceImpl implements AdvanceRuntimeDataService {\n+\n+    private Map<String, String> translateTable = new HashMap<>();", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMjU0NA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r411212544", "bodyText": "ok", "author": "elguardian", "createdAt": "2020-04-20T09:01:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0MjYwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0NDQzMQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408644431", "bodyText": "Map is not serializable (same as inputdata and outputdata members). I guess it won't be an issue? It could cause some issues when serializing/deserializing these. Should we use HashMap instead or should we leave it as is? wdyt?", "author": "afalhambra", "createdAt": "2020-04-15T07:44:41Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/model/UserTaskInstanceWithPotOwnerDesc.java", "diffHunk": "@@ -36,6 +36,8 @@\n     private Map<String,Object> inputdata;\n     private Map<String,Object> outputdata;\n     private String processInstanceDescription;\n+    private Map<String, Object> processVariables;\n+    private Map<String, Object> data;", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMjg1NQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r411212855", "bodyText": "leave it. just silly thing from sonar. It cannot detect runtime statff.", "author": "elguardian", "createdAt": "2020-04-20T09:01:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY0NDQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1ODU5NQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408658595", "bodyText": "ArrayList < String > is redundant. ArrayList<> should be enough", "author": "afalhambra", "createdAt": "2020-04-15T08:09:54Z", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_CORRELATION_KEY;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEFINITION_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEPLOYMENT_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_NAME;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_OWNER;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.in;\n+import static org.jbpm.services.api.query.model.QueryParam.isNotNull;\n+import static org.jbpm.services.api.query.model.QueryParam.isNull;\n+import static org.jbpm.services.api.query.model.QueryParam.likeTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.jbpm.services.api.query.model.QueryParam.notEqualsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.notIn;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+@RunWith(Parameterized.class)\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    @Parameters(name = \"Pagination {0}\")\n+    public static Iterable<? extends Object> data() {\n+        return Arrays.asList(0, 2);\n+    }\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+    private QueryContext queryContext;\n+\n+    public AdvanceRuntimeDataServiceImplTest(Integer count) {\n+        this.queryContext = new QueryContext(0, count);\n+    }\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNDA2Ng==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r411214066", "bodyText": "ok", "author": "elguardian", "createdAt": "2020-04-20T09:03:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1ODU5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1ODk4Mg==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408658982", "bodyText": "These members are not used. Please remove them.", "author": "afalhambra", "createdAt": "2020-04-15T08:10:38Z", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_CORRELATION_KEY;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEFINITION_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEPLOYMENT_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_NAME;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_OWNER;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.in;\n+import static org.jbpm.services.api.query.model.QueryParam.isNotNull;\n+import static org.jbpm.services.api.query.model.QueryParam.isNull;\n+import static org.jbpm.services.api.query.model.QueryParam.likeTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.jbpm.services.api.query.model.QueryParam.notEqualsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.notIn;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+@RunWith(Parameterized.class)\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    @Parameters(name = \"Pagination {0}\")\n+    public static Iterable<? extends Object> data() {\n+        return Arrays.asList(0, 2);\n+    }\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMzc5Mg==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r411213792", "bodyText": "ok", "author": "elguardian", "createdAt": "2020-04-20T09:03:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1ODk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1OTMwNw==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408659307", "bodyText": "ArrayList < DeploymentUnit > is redundant. ArrayList<> should be enough", "author": "afalhambra", "createdAt": "2020-04-15T08:11:17Z", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_CORRELATION_KEY;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEFINITION_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEPLOYMENT_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_NAME;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_OWNER;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.in;\n+import static org.jbpm.services.api.query.model.QueryParam.isNotNull;\n+import static org.jbpm.services.api.query.model.QueryParam.isNull;\n+import static org.jbpm.services.api.query.model.QueryParam.likeTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.jbpm.services.api.query.model.QueryParam.notEqualsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.notIn;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+@RunWith(Parameterized.class)\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    @Parameters(name = \"Pagination {0}\")\n+    public static Iterable<? extends Object> data() {\n+        return Arrays.asList(0, 2);\n+    }\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxMzIyOA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r411213228", "bodyText": "ok", "author": "elguardian", "createdAt": "2020-04-20T09:02:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY1OTMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4Mjk2Nw==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408682967", "bodyText": "I see that pagination has been set at the test class level, but I'm missing a specific test method for testing this in combination with the offset and fetch the next batch of results/records. wdyt?", "author": "afalhambra", "createdAt": "2020-04-15T08:50:51Z", "path": "jbpm-services/jbpm-kie-services/src/test/java/org/jbpm/kie/services/test/AdvanceRuntimeDataServiceImplTest.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.test;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.drools.compiler.kie.builder.impl.InternalKieModule;\n+import org.jbpm.kie.services.impl.KModuleDeploymentUnit;\n+import org.jbpm.kie.test.util.AbstractKieServicesBaseTest;\n+import org.jbpm.services.api.ProcessInstanceNotFoundException;\n+import org.jbpm.services.api.model.DeploymentUnit;\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.Parameterized;\n+import org.junit.runners.Parameterized.Parameters;\n+import org.kie.api.KieServices;\n+import org.kie.api.builder.ReleaseId;\n+import org.kie.api.runtime.process.ProcessInstance;\n+import org.kie.internal.query.QueryContext;\n+import org.kie.scanner.KieMavenRepository;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import static java.util.Collections.emptyList;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_CORRELATION_KEY;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEFINITION_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.PROCESS_ATTR_DEPLOYMENT_ID;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_NAME;\n+import static org.jbpm.services.api.AdvanceRuntimeDataService.TASK_ATTR_OWNER;\n+import static org.jbpm.services.api.query.model.QueryParam.equalsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.in;\n+import static org.jbpm.services.api.query.model.QueryParam.isNotNull;\n+import static org.jbpm.services.api.query.model.QueryParam.isNull;\n+import static org.jbpm.services.api.query.model.QueryParam.likeTo;\n+import static org.jbpm.services.api.query.model.QueryParam.list;\n+import static org.jbpm.services.api.query.model.QueryParam.notEqualsTo;\n+import static org.jbpm.services.api.query.model.QueryParam.notIn;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.kie.scanner.KieMavenRepository.getKieMavenRepository;\n+\n+@RunWith(Parameterized.class)\n+public class AdvanceRuntimeDataServiceImplTest extends AbstractKieServicesBaseTest {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(AdvanceRuntimeDataServiceImplTest.class);\n+\n+    @Parameters(name = \"Pagination {0}\")\n+    public static Iterable<? extends Object> data() {\n+        return Arrays.asList(0, 2);\n+    }\n+\n+    private List<DeploymentUnit> units = new ArrayList<DeploymentUnit>();\n+    protected String correctUser = \"testUser\";\n+    protected String wrongUser = \"wrongUser\";\n+\n+    private List<Long> processIds;\n+    private KModuleDeploymentUnit deploymentUnit = null;\n+    private QueryContext queryContext;\n+\n+    public AdvanceRuntimeDataServiceImplTest(Integer count) {\n+        this.queryContext = new QueryContext(0, count);\n+    }\n+\n+    @Before\n+    public void prepare() {\n+\n+        configureServices();\n+        logger.debug(\"Preparing kjar\");\n+        KieServices ks = KieServices.Factory.get();\n+        ReleaseId releaseId = ks.newReleaseId(GROUP_ID, ARTIFACT_ID, VERSION);\n+        List<String> processes = new ArrayList<String>();\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsA.bpmn2\");\n+        processes.add(\"repo/processes/general/SingleHumanTaskWithVarsB.bpmn2\");\n+\n+        InternalKieModule kJar1 = createKieJar(ks, releaseId, processes);\n+        File pom = new File(\"target/kmodule\", \"pom.xml\");\n+        pom.getParentFile().mkdir();\n+        try (FileOutputStream fs = new FileOutputStream(pom);) {\n+            fs.write(getPom(releaseId).getBytes());\n+        } catch (Exception e) {\n+\n+        }\n+        KieMavenRepository repository = getKieMavenRepository();\n+        repository.deployArtifact(releaseId, kJar1, pom);\n+\n+        assertNotNull(deploymentService);\n+\n+        deploymentUnit = new KModuleDeploymentUnit(GROUP_ID, ARTIFACT_ID, VERSION);\n+\n+        deploymentService.deploy(deploymentUnit);\n+        units.add(deploymentUnit);\n+        assertNotNull(processService);\n+\n+        processIds = new ArrayList<>();\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsA1 = new HashMap<>();\n+            inputsA1.put(\"var_a\", \"a\" + (i % 3));\n+            inputsA1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_A\", inputsA1));\n+        }\n+        for (int i = 0; i < 10; i++) {\n+            Map<String, Object> inputsB1 = new HashMap<>();\n+            inputsB1.put(\"var_a\", \"b\" + (i % 3));\n+            inputsB1.put(\"var_b\", (i % 3));\n+            processIds.add(processService.startProcess(deploymentUnit.getIdentifier(), \"test.test_B\", inputsB1));\n+        }\n+    }\n+\n+    @After\n+    public void cleanup() {\n+        for (Long processInstanceId : processIds) {\n+            try {\n+                // let's abort process instance to leave the system in clear state\n+                processService.abortProcessInstance(processInstanceId);\n+\n+                ProcessInstance pi = processService.getProcessInstance(processInstanceId);\n+                assertNull(pi);\n+            } catch (ProcessInstanceNotFoundException e) {\n+                // ignore it as it was already completed/aborted\n+            }\n+        }\n+        cleanupSingletonSessionId();\n+        if (units != null && !units.isEmpty()) {\n+            for (DeploymentUnit unit : units) {\n+                try {\n+                    deploymentService.undeploy(unit);\n+                } catch (Exception e) {\n+                    // do nothing in case of some failed tests to avoid next test to fail as well\n+                }\n+            }\n+            units.clear();\n+        }\n+        close();\n+    }\n+\n+    @Test\n+    public void testQueryProcessByVariables() {\n+        List<QueryParam> variables = list(equalsTo(\"var_a\", \"a1\"), equalsTo(\"var_b\", \"1\"));\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertEquals(\"a1\", p.getVariables().get(\"var_a\"));\n+            Assert.assertEquals(\"1\", p.getVariables().get(\"var_b\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryInOperator() {\n+\n+        List<QueryParam> variables = list(in(\"var_a\", \"a1\", \"a2\"));\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        List<String> values = Arrays.asList(\"a1\", \"a2\");\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertTrue(values.contains(p.getVariables().get(\"var_a\")));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryLikeToOperator() {\n+\n+        List<QueryParam> variables = list(likeTo(\"var_a\", false, \"a%\"));\n+        List<QueryParam> attributes = list(likeTo(PROCESS_ATTR_DEFINITION_ID, false, \"%test_A%\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertTrue(((String) p.getVariables().get(\"var_a\")).startsWith(\"a\"));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryIsNotNullOperator() {\n+\n+        List<QueryParam> attributes = list(isNotNull(TASK_ATTR_OWNER));\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, emptyList(), emptyList(), emptyList(), queryContext);\n+        Assert.assertThat(data.size(), is(0));\n+\n+    }\n+\n+    @Test\n+    public void testQueryIsNullOperator() {\n+\n+        List<QueryParam> attributes = list(isNull(TASK_ATTR_OWNER));\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, emptyList(), emptyList(), emptyList(), queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertNull(p.getActualOwner());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryNotInOperator() {\n+\n+        List<QueryParam> variables = list(notIn(\"var_a\", \"a1\", \"a2\"));\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, variables, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        List<String> values = Arrays.asList(\"a1\", \"a2\");\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertTrue(!values.contains(p.getVariables().get(\"var_a\")));\n+            Assert.assertEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryNotEqualsOperator() {\n+        List<QueryParam> attributes = list(notEqualsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, emptyList(), queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+\n+        for (ProcessInstanceWithVarsDesc p : data) {\n+            Assert.assertNotEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryProcessByAttributes() {\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"), equalsTo(PROCESS_ATTR_CORRELATION_KEY, \"1\"));\n+\n+        List<ProcessInstanceWithVarsDesc> data = advanceVariableDataService.queryProcessByVariables(attributes, emptyList(), queryContext);\n+        Assert.assertThat(data.size(), is(1));\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariables() {\n+        List<QueryParam> variables = list(equalsTo(\"task_in_a1\", \"a0\"));\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEPLOYMENT_ID, \"org.jbpm.test:test-module:1.0.0\"));\n+\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, variables, emptyList(), potOwners, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertEquals(\"a0\", p.getInputdata().get(\"task_in_a1\"));\n+            Assert.assertEquals(\"org.jbpm.test:test-module:1.0.0\", p.getDeploymentId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskNotEqualsByVariables() {\n+        List<QueryParam> attributes = list(notEqualsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"));\n+\n+        List<String> potOwners = emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, emptyList(), emptyList(), potOwners, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertNotEquals(\"test.test_A\", p.getProcessId());\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithOwners() {\n+\n+        List<String> potOwners = Collections.singletonList(\"katy\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(emptyList(), emptyList(), emptyList(), potOwners, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        }\n+\n+        for (UserTaskInstanceWithPotOwnerDesc p : data) {\n+            Assert.assertTrue(p.getPotentialOwners().contains(\"katy\"));\n+        }\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithAllOwners() {\n+        List<String> potOwners = Arrays.asList(\"katy\", \"nobody\");\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(emptyList(), emptyList(), emptyList(), potOwners, queryContext);\n+        Assert.assertEquals(0, data.size());\n+\n+    }\n+\n+    @Test\n+    public void testQueryTaskByVariablesWithByProcessVar() {\n+        List<QueryParam> processVariables = list(equalsTo(\"var_a\", \"a1\"));\n+\n+        List<String> potOwners = Collections.emptyList();\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(emptyList(), emptyList(), processVariables, potOwners, queryContext);\n+        if (queryContext.getCount() > 0) {\n+            Assert.assertThat(data.size(), is(queryContext.getCount()));\n+        } else {\n+            Assert.assertThat(data.size(), is(3));\n+        }\n+\n+    }\n+\n+    @Test\n+    public void testQueryTaskByAttributes() {\n+        List<QueryParam> attributes = list(equalsTo(PROCESS_ATTR_DEFINITION_ID, \"test.test_A\"), equalsTo(PROCESS_ATTR_CORRELATION_KEY, \"1\"), equalsTo(TASK_ATTR_NAME, \"Task\"));\n+\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, emptyList(), emptyList(), emptyList(), queryContext);\n+        Assert.assertThat(data.size(), is(1));\n+    }\n+\n+    @Test\n+    public void testQueryTaskByAttributesOwner() {\n+        List<QueryParam> attributes = list(equalsTo(TASK_ATTR_OWNER, \"Error\"));\n+        List<UserTaskInstanceWithPotOwnerDesc> data = advanceVariableDataService.queryUserTasksByVariables(attributes, emptyList(), emptyList(), emptyList(), queryContext);\n+        Assert.assertThat(data.size(), is(0));\n+    }\n+\n+}", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTIxNTE1Nw==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r411215157", "bodyText": "code coverage covers this scenario. so it is the same to tests 0 - 2 than 2 - 4.", "author": "elguardian", "createdAt": "2020-04-20T09:05:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4Mjk2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4NzExNg==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408687116", "bodyText": "Please remove extra parentheses here around \"entry\"\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n          \n          \n            \n                    attributes.stream().filter(e -> e.getObjectValue() != null).forEach(entry -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));", "author": "afalhambra", "createdAt": "2020-04-15T08:57:38Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4Nzg1Mg==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408687852", "bodyText": "Please remove the extra parentheses around \"expr\"\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n          \n          \n            \n                        variables.stream().forEach(expr -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));", "author": "afalhambra", "createdAt": "2020-04-15T08:58:47Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4ODM3Ng==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408688376", "bodyText": "Please remove the extra parentheses around \"expr\"\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n          \n          \n            \n                        processVariables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));", "author": "afalhambra", "createdAt": "2020-04-15T08:59:37Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4ODc2NQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408688765", "bodyText": "Please remove extra parentheses around \"expr\"\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    attributes.stream().forEach((expr) -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n          \n          \n            \n                    attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));", "author": "afalhambra", "createdAt": "2020-04-15T09:00:15Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_PROCVARS \" +\n+                                 \") TABLE_PROC_VAR ON TABLE_PROC_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") pot ON pot.task_id = task.id \");\n+        }\n+\n+        attributes.stream().forEach((expr) -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4OTE3Mg==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408689172", "bodyText": "Please remove the extra parentheses around \"var\"\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    variables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"V_VALUE_\" + var.getColumn(), var.getObjectValue()));\n          \n          \n            \n                    variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"V_VALUE_\" + var.getColumn(), var.getObjectValue()));", "author": "afalhambra", "createdAt": "2020-04-15T09:00:56Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_PROCVARS \" +\n+                                 \") TABLE_PROC_VAR ON TABLE_PROC_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") pot ON pot.task_id = task.id \");\n+        }\n+\n+        attributes.stream().forEach((expr) -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString = \"SELECT DISTINCT task.id \" +\n+                               \" FROM Task task \" +\n+                               \" INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" +\n+                               derivedTables +\n+                               \" WHERE  pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY task.id ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"V_NAME_\" + var.getColumn(), var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"V_VALUE_\" + var.getColumn(), var.getObjectValue()));", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4OTQ2NA==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408689464", "bodyText": "Please remove the extra parentheses around \"var\"\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    processVariables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"P_VALUE_\" + var.getColumn(), var.getObjectValue()));\n          \n          \n            \n                    processVariables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"P_VALUE_\" + var.getColumn(), var.getObjectValue()));", "author": "afalhambra", "createdAt": "2020-04-15T09:01:23Z", "path": "jbpm-services/jbpm-kie-services/src/main/java/org/jbpm/kie/services/impl/AbstractAdvanceRuntimeDataServiceImpl.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.kie.services.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.persistence.EntityManager;\n+import javax.persistence.EntityManagerFactory;\n+import javax.persistence.Query;\n+\n+import org.dashbuilder.dataset.filter.CoreFunctionType;\n+import org.jbpm.kie.services.impl.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.kie.services.impl.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.jbpm.shared.services.impl.QueryManager;\n+import org.jbpm.shared.services.impl.TransactionalCommandService;\n+import org.jbpm.shared.services.impl.commands.QueryNameCommand;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+import static java.util.Collections.singletonMap;\n+\n+public abstract class AbstractAdvanceRuntimeDataServiceImpl {\n+\n+    private static final String ID_LIST = \"idList\";\n+    private EntityManagerFactory emf;\n+    private TransactionalCommandService commandService;\n+\n+    public AbstractAdvanceRuntimeDataServiceImpl() {\n+        QueryManager.get().addNamedQueries(\"META-INF/Servicesorm.xml\");\n+    }\n+    public void setCommandService(TransactionalCommandService commandService) {\n+        this.commandService = commandService;\n+    }\n+\n+    public void setEmf(EntityManagerFactory emf) {\n+        this.emf = emf;\n+    }\n+\n+\n+    public List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> queryProcessByVariables(List<QueryParam> attributes,\n+                                                                                                 List<QueryParam> variables,\n+                                                                                                 int processType,\n+                                                                                                 String varPrefix,\n+                                                                                                 QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+\n+        // first step is to filter the data creating a derived tables and pivoting var - rows to columns (only the variables we are interested to filter)\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach(expr -> conditions.add(\"(A1.variableId = :NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_VARS \" +\n+                                 \") TABLE_VAR ON TABLE_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        StringBuilder globalWhere = new StringBuilder();\n+        attributes.stream().forEach(expr -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString =\n+                \" SELECT DISTINCT pil.processInstanceId \" +\n+                               \" FROM ProcessInstanceLog pil \\n \" +\n+                               derivedTables +\n+                               \" WHERE pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY pil.processInstanceId ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach(var -> query.setParameter(\"VALUE_\" + var.getColumn(), var.getObjectValue()));\n+        attributes.stream().filter(e -> e.getObjectValue() != null).forEach((entry) -> query.setParameter(\"ATTR_\" + entry.getColumn(), entry.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_VARS\", variables.size());\n+        }\n+        query.setParameter(\"processType\", processType);\n+\n+        addPagination(query, queryContext);\n+        List<Number> ids = query.getResultList();\n+        if (ids.isEmpty()) {\n+            return Collections.emptyList();\n+        }\n+\n+        // now we get the information\n+\n+        List<Object[]> procRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetProcessInstanceByIdList\", singletonMap(ID_LIST, ids)));\n+        List<Object[]> varRows = commandService.execute(new QueryNameCommand<List<Object[]>>(\"GetVariablesByProcessInstanceIdList\", singletonMap(ID_LIST, ids)));\n+\n+        int currentVarIdx = 0;\n+        List<org.jbpm.services.api.model.ProcessInstanceWithVarsDesc> data = new ArrayList<>();\n+        for (Object[] row : procRows) {\n+            ProcessInstanceWithVarsDesc pwv = toProcessInstanceWithVarsDesc(row);\n+\n+            Map<String, Object> vars = new HashMap<>();\n+            pwv.setVariables(vars);\n+\n+            Map<String, Object> extra = new HashMap<>();\n+            pwv.setExtraData(extra);\n+            while (currentVarIdx < varRows.size() && row[0].equals(varRows.get(currentVarIdx)[0])) {\n+                String name = (String) varRows.get(currentVarIdx)[1];\n+                if (!varPrefix.isEmpty() && name.startsWith(varPrefix)) {\n+                    extra.put(name.substring(varPrefix.length()), varRows.get(currentVarIdx)[2]);\n+                } else {\n+                    vars.put(name, varRows.get(currentVarIdx)[2]);\n+                }\n+                currentVarIdx++;\n+            }\n+            data.add(pwv);\n+        }\n+\n+        entityManager.close();\n+        return data;\n+    }\n+\n+    private String computeExpression(QueryParam expr, String leftOperand, String rightOperand) {\n+        CoreFunctionType type = CoreFunctionType.getByName(expr.getOperator());\n+        switch (type) {\n+            case IS_NULL:\n+                return leftOperand + \" IS NULL \";\n+            case NOT_NULL:\n+                return leftOperand + \" IS NOT NULL \";\n+            case IN:\n+                return leftOperand + \" IN (\" + rightOperand + \") \";\n+            case NOT_IN:\n+                return leftOperand + \" NOT IN (\" + rightOperand + \") \";\n+            case EQUALS_TO:\n+                return leftOperand + \" = \" + rightOperand + \" \";\n+            case NOT_EQUALS_TO:\n+                return leftOperand + \" <> \" + rightOperand + \" \";\n+            case LIKE_TO:\n+                return leftOperand + \" LIKE \" + rightOperand + \" \";\n+            default:\n+                throw new UnsupportedOperationException(\"Queryparam: \" + expr + \" not supported\");\n+        }\n+    }\n+    private ProcessInstanceWithVarsDesc toProcessInstanceWithVarsDesc(Object[] row) {\n+        return new ProcessInstanceWithVarsDesc(((Number) row[0]).longValue(),\n+                                               (String) row[1],\n+                                               (String) row[2],\n+                                               (String) row[3],\n+                                               ((Number) row[4]).intValue(),\n+                                               (String) row[5],\n+                                               (Date) row[6],\n+                                               (String) row[7],\n+                                               (String) row[8]);\n+    }\n+\n+    private void addPagination(Query query, QueryContext context) {\n+        if (context.getCount() > 0) {\n+            query.setFirstResult(context.getOffset());\n+            query.setMaxResults(context.getCount());\n+        }\n+    }\n+\n+    public List<org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc> queryUserTasksByVariables(List<QueryParam> attributes,\n+                                                                                                        List<QueryParam> variables,\n+                                                                                                        List<QueryParam> processVariables,\n+                                                                                                        List<String> owners,\n+                                                                                                        int processType,\n+                                                                                                        String varPrefix,\n+                                                                                                        QueryContext queryContext) {\n+        EntityManager entityManager = emf.createEntityManager();\n+        StringBuilder globalWhere = new StringBuilder();\n+        StringBuilder derivedTables = new StringBuilder();\n+        if (!variables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            variables.stream().forEach((expr) -> conditions.add(\"(name = :V_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"value\", \":V_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\\n\" +\n+                                 \"SELECT taskId \\n\" +\n+                                 \"FROM TaskVariableImpl \\n\" +\n+                                 \"WHERE type = 0 AND (\" + where + \")\\n\" +\n+                                 \"GROUP BY taskId \\n\" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_TASKVARS \\n\" +\n+                                 \") TABLE_TASK_VAR ON TABLE_TASK_VAR.taskId = task.id  \\n\");\n+        }\n+\n+        if (!processVariables.isEmpty()) {\n+            List<String> conditions = new ArrayList<>();\n+            processVariables.stream().forEach((expr) -> conditions.add(\"(A1.variableId = :P_NAME_\" + expr.getColumn() + \" AND \" + computeExpression(expr, \"A1.value\", \":P_VALUE_\" + expr.getColumn()) + \")\\n\"));\n+            String where = String.join(\" OR \", conditions);\n+            derivedTables.append(\"INNER JOIN (\" +\n+                                 \"SELECT A1.processInstanceId \\n\" +\n+                                 \"FROM VariableInstanceLog A1 \\n\" +\n+                                 \"LEFT JOIN VariableInstanceLog A2 ON A1.processId = A2.processId AND A1.processInstanceId = A2.processInstanceId AND A1.variableInstanceId = A2.variableInstanceId AND A2.id > A1.id  \\n\" +\n+                                 \"WHERE A2.id IS NULL AND (\" + where + \") \" +\n+                                 \"GROUP BY A1.processInstanceId \" +\n+                                 \"HAVING COUNT(*) = :NUMBER_OF_PROCVARS \" +\n+                                 \") TABLE_PROC_VAR ON TABLE_PROC_VAR.processInstanceId = pil.processInstanceId \\n\");\n+        }\n+\n+        if (!owners.isEmpty()) {\n+            derivedTables.append(\"INNER JOIN ( \\n\" +\n+                             \"           SELECT DISTINCT po.task_id \\n\" +\n+                             \"           FROM PeopleAssignments_PotOwners po \\n\" +\n+                             \"           WHERE po.entity_id IN (:owners) \\n\" +\n+                             \"           GROUP BY po.task_id \\n\" +\n+                             \"           HAVING COUNT(po.entity_id) = :num_owners \\n\" +\n+                                 \") pot ON pot.task_id = task.id \");\n+        }\n+\n+        attributes.stream().forEach((expr) -> globalWhere.append(\" AND \" + computeExpression(expr, expr.getColumn(), \":ATTR_\" + expr.getColumn())));\n+\n+        String procSQLString = \"SELECT DISTINCT task.id \" +\n+                               \" FROM Task task \" +\n+                               \" INNER JOIN ProcessInstanceLog pil ON pil.processInstanceId = task.processInstanceId \\n \" +\n+                               derivedTables +\n+                               \" WHERE  pil.processType = :processType \" + globalWhere +\n+                               \" ORDER BY task.id ASC \";\n+\n+        Query query = entityManager.createNativeQuery(procSQLString);\n+        variables.stream().forEach(var -> query.setParameter(\"V_NAME_\" + var.getColumn(), var.getColumn()));\n+        variables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"V_VALUE_\" + var.getColumn(), var.getObjectValue()));\n+\n+        if (!variables.isEmpty()) {\n+            query.setParameter(\"NUMBER_OF_TASKVARS\", variables.size());\n+        }\n+\n+        processVariables.stream().forEach(var -> query.setParameter(\"P_NAME_\" + var.getColumn(), varPrefix + var.getColumn()));\n+        processVariables.stream().filter(e -> e.getObjectValue() != null).forEach((var) -> query.setParameter(\"P_VALUE_\" + var.getColumn(), var.getObjectValue()));", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAzMDYxMw==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r410030613", "bodyText": "done", "author": "elguardian", "createdAt": "2020-04-17T07:04:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY4OTQ2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5MTg4Ng==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408691886", "bodyText": "Would it not be better to have an Enum for these constants?", "author": "afalhambra", "createdAt": "2020-04-15T09:05:20Z", "path": "jbpm-services/jbpm-services-api/src/main/java/org/jbpm/services/api/AdvanceRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.services.api;\n+\n+import java.util.List;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String PROCESS_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String PROCESS_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String PROCESS_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String PROCESS_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAzMTUzMQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r410031531", "bodyText": "keep in mind that this comes for rest service. It would require a conversion causing more problems than anything. Also this is consistent with other approach in the app. Look into QueryParameterIdentifiers.", "author": "elguardian", "createdAt": "2020-04-17T07:06:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5MTg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5MjExNQ==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r408692115", "bodyText": "Would it not be better to have an Enum for these constants?", "author": "afalhambra", "createdAt": "2020-04-15T09:05:42Z", "path": "jbpm-case-mgmt/jbpm-case-mgmt-api/src/main/java/org/jbpm/casemgmt/api/AdvanceCaseRuntimeDataService.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.jbpm.casemgmt.api;\n+\n+import java.util.List;\n+\n+import org.jbpm.services.api.model.ProcessInstanceWithVarsDesc;\n+import org.jbpm.services.api.model.UserTaskInstanceWithPotOwnerDesc;\n+import org.jbpm.services.api.query.model.QueryParam;\n+import org.kie.api.runtime.query.QueryContext;\n+\n+public interface AdvanceCaseRuntimeDataService {\n+\n+    public static String TASK_ATTR_NAME = \"TASK_NAME\";\n+    public static String TASK_ATTR_OWNER = \"TASK_OWNER\";\n+    public static String CASE_ATTR_INSTANCE_ID = \"PROCESS_INSTANCE_ID\";\n+    public static String CASE_ATTR_CORRELATION_KEY = \"PROCESS_CORRELATION_KEY\";\n+    public static String CASE_ATTR_DEFINITION_ID = \"PROCESS_DEFINITION_ID\";\n+    public static String CASE_ATTR_DEPLOYMENT_ID = \"PROCESS_DEPLOYMENT_ID\";", "originalCommit": "f04f50355ec285330b3467d42754a036a04b1db3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDAzMTQ4Nw==", "url": "https://github.com/kiegroup/jbpm/pull/1615#discussion_r410031487", "bodyText": "keep in mind that this comes for rest service. It would require a conversion causing more problems than anything. Also this is consistent with other approach in the app. Look into QueryParameterIdentifiers.", "author": "elguardian", "createdAt": "2020-04-17T07:06:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwODY5MjExNQ=="}], "type": "inlineReview"}, {"oid": "17c40137da86b2cb4604496e634e2a7a623784ec", "url": "https://github.com/kiegroup/jbpm/commit/17c40137da86b2cb4604496e634e2a7a623784ec", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables", "committedDate": "2020-04-17T07:07:13Z", "type": "forcePushed"}, {"oid": "ec84d965517b278f53051e64acf8230e885957a3", "url": "https://github.com/kiegroup/jbpm/commit/ec84d965517b278f53051e64acf8230e885957a3", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables", "committedDate": "2020-04-20T09:06:02Z", "type": "commit"}, {"oid": "ec84d965517b278f53051e64acf8230e885957a3", "url": "https://github.com/kiegroup/jbpm/commit/ec84d965517b278f53051e64acf8230e885957a3", "message": "[RHPAM-2552] Ability to Search for tasks by multiple task variables a nd / or process variables via the kie-server api.\n\nadded the possibility to query process/cases by variables", "committedDate": "2020-04-20T09:06:02Z", "type": "forcePushed"}]}