{"pr_number": 1742, "pr_title": "[RHPAM-3132] Adjust link behavior to bpmn specification", "pr_createdAt": "2020-08-26T16:42:40Z", "pr_url": "https://github.com/kiegroup/jbpm/pull/1742", "timeline": [{"oid": "a8482684cc810a089b2f5146faf5db1fc60c2f21", "url": "https://github.com/kiegroup/jbpm/commit/a8482684cc810a089b2f5146faf5db1fc60c2f21", "message": "[RPHAM-3132] Adjust link behavior to bpmn specification\n\nThere can be multiple throw links per a catch link, but not the other\nway around", "committedDate": "2020-08-26T16:53:09Z", "type": "forcePushed"}, {"oid": "cc4df1ce3dd1ab099ba8a932ffd7df4e36c37f1b", "url": "https://github.com/kiegroup/jbpm/commit/cc4df1ce3dd1ab099ba8a932ffd7df4e36c37f1b", "message": "[RPHAM-3132] Adjust link behavior to bpmn specification\n\nThere can be multiple throw links per a catch link, but not the other\nway around", "committedDate": "2020-08-26T17:03:13Z", "type": "forcePushed"}, {"oid": "4a976619dbdf7d52a1c2625a5197faea96409a81", "url": "https://github.com/kiegroup/jbpm/commit/4a976619dbdf7d52a1c2625a5197faea96409a81", "message": "[RPHAM-3132] Adjust link behavior to bpmn specification\n\nThere can be multiple throw links per a catch link, but not the other\nway around", "committedDate": "2020-08-26T17:16:35Z", "type": "forcePushed"}, {"oid": "5bb415761d5b798520e128f3510e294bf0f96301", "url": "https://github.com/kiegroup/jbpm/commit/5bb415761d5b798520e128f3510e294bf0f96301", "message": "[RPHAM-3132] Adjust link behavior to bpmn specification\n\nThere can be multiple throw links per a catch link, but not the other\nway around", "committedDate": "2020-08-26T17:21:07Z", "type": "forcePushed"}, {"oid": "f074cf209b43f328b658ee1f5d2598e9cfcd6a98", "url": "https://github.com/kiegroup/jbpm/commit/f074cf209b43f328b658ee1f5d2598e9cfcd6a98", "message": "[RPHAM-3132] Adjust link behavior to bpmn specification\n\nThere can be multiple throw links per a catch link, but not the other\nway around", "committedDate": "2020-08-27T10:28:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwNjYxNg==", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478206616", "bodyText": "String concatenation should be done using append method instead. And I would add a delimiter character to show a cleaner message when more than link is wrong, otherwise it may be confusing.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        errors.append(\"\\nThere is not connection from any throw link to these catch links \"+unconnectedTarget.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));\n          \n          \n            \n                        errors.append(\"\\nThere is not connection from any throw link to these catch links \").append(unconnectedTarget.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining(\", \"))));", "author": "afalhambra", "createdAt": "2020-08-27T07:15:41Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "diffHunk": "@@ -201,73 +202,83 @@ public Object end(final String uri, final String localName,\n \t\treturn process;\n \t}\n \t\n-\t public static void linkIntermediateLinks(NodeContainer process,\n-\t            List<IntermediateLink> links) {\n-\n \n-        if (null != links) {\n-            List<IntermediateLink> errors = links.stream().filter(l -> l.getName() == null || l.getName().isEmpty()).collect(toList());\n-            if (!errors.isEmpty()) {\n-                StringBuilder builder = new StringBuilder();\n-                for (IntermediateLink l : errors) {\n-                    builder.append(\"\\tIntermediate Link: \" + l.getUniqueId() + \"\\n\");\n+    public static void linkIntermediateLinks(NodeContainer process,List<IntermediateLink> links) {\n+        if (links == null) { \n+            return;\n+        }\n+        Map<String,IntermediateLink> catchLinks = new HashMap<>();\n+        Map<String,Collection<IntermediateLink>> throwLinks = new HashMap<>();\n+        Collection<IntermediateLink> notNameLinks = new ArrayList<>();\n+        Collection<IntermediateLink> duplicatedTarget = new LinkedHashSet<>();\n+        Collection<IntermediateLink> unconnectedTarget = new ArrayList<>();\n+        \n+        // collect errors and nodes in first loop\n+        for (IntermediateLink link : links) {\n+            if (link.getName() == null || link.getName().isEmpty()) {\n+                notNameLinks.add(link);\n+            }\n+            else if (link.isThrowLink()) {\n+                throwLinks.computeIfAbsent(link.getName(), s -> new ArrayList<>()).add(link);\n+            }\n+            else {\n+                IntermediateLink duplicateLink = catchLinks.putIfAbsent(link.getName(),link);\n+                if (duplicateLink != null) {\n+                    duplicatedTarget.add(duplicateLink);\n+                    duplicatedTarget.add(link);\n                 }\n-                throw new IllegalArgumentException(\"There are \" + errors.size() + \" links that does not have a name.\\n\" + builder.toString());\n             }\n-\t            // Search throw links\n-\t            ArrayList<IntermediateLink> throwLinks = new ArrayList<IntermediateLink>();\n-\t            for (IntermediateLink aLinks : links) {\n-\t                if (aLinks.isThrowLink()) {\n-\t                    throwLinks.add(aLinks);\n-\t                }\n-\t            }\n-\n-\t            // Look for catch links for a throw link\n-\t            for (IntermediateLink throwLink : throwLinks) {\n-\n-\t                ArrayList<IntermediateLink> linksWithSharedNames = new ArrayList<IntermediateLink>();\n-\t                for (IntermediateLink aLink : links) {\n-\t                    if (throwLink.getName().equals(aLink.getName())) {\n-\t                        linksWithSharedNames.add(aLink);\n-\t                    }\n-\t                }\n-\n-\t                if (linksWithSharedNames.size() < 2) {\n-\t                    throw new IllegalArgumentException(\n-\t                            \"There should be at least 2 link events to make a connection\");\n-\t                }\n-\n-\t                linksWithSharedNames.remove(throwLink);\n-\n-\t                // Make the connections\n-\t                Node t = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                        throwLink.getUniqueId());\n-\n-\t                // connect throw to catch\n-\t                for (IntermediateLink catchLink : linksWithSharedNames) {\n-\n-\t                    Node c = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                            catchLink.getUniqueId());\n-\t                    if (t != null && c != null) {\n-\t                        Connection result = new ConnectionImpl(t,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE, c,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n-\t                        result.setMetaData(\"linkNodeHidden\", \"yes\");\n-\t                    }\n-\t                }\n-\n-\t                // Remove processed links\n-\t                links.remove(throwLink);\n-\t                links.removeAll(linksWithSharedNames);\n-\t            }\n-\n-\t            if (links.size() > 0) {\n-\t                throw new IllegalArgumentException(links.size()\n-\t                        + \" links were not processed\");\n-\t            }\n+        }\n \n-\t        }\n-\t }\n+        // second loop for connection\n+        for (IntermediateLink catchLink : catchLinks.values()) {\n+            Collection<IntermediateLink> associatedLinks = throwLinks.remove(catchLink.getName());\n+            if (associatedLinks != null) {\n+                // connect throw to catch\n+                Node catchNode = findNodeByIdOrUniqueIdInMetadata(process,catchLink.getUniqueId());\n+                if (catchNode != null) {\n+                    for (IntermediateLink throwLink : associatedLinks) {\n+                        Node throwNode = findNodeByIdOrUniqueIdInMetadata(process,\n+                            throwLink.getUniqueId());\n+                        if (throwNode != null) {\n+                            Connection result = new ConnectionImpl(throwNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE, catchNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n+                            result.setMetaData(\"linkNodeHidden\", \"yes\");\n+                        }\n+                    }\n+                }\n+            }\n+            else {\n+                unconnectedTarget.add(catchLink);\n+            }\n+        }\n+        \n+        // throw exception if any error (this is done late in the process to show the user as much errors as possible) \n+        StringBuilder errors = new StringBuilder();\n+        if (!notNameLinks.isEmpty()) {\n+            errors.append(\"These nodes do not have a name \"+notNameLinks.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));\n+        }\n+        if (!duplicatedTarget.isEmpty()) {\n+            errors.append(\"\\nThere are multiple catch nodes with the same name \"+duplicatedTarget.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));\n+        }\n+        if (!unconnectedTarget.isEmpty()) {\n+            errors.append(\"\\nThere is not connection from any throw link to these catch links \"+unconnectedTarget.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));", "originalCommit": "5bb415761d5b798520e128f3510e294bf0f96301", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwNjY1Mg==", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478206652", "bodyText": "String concatenation should be done using append method instead. And I would add a delimiter character to show a cleaner message when more than link is wrong, otherwise it may be confusing.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        errors.append(\"\\nThere are multiple catch nodes with the same name \"+duplicatedTarget.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));\n          \n          \n            \n                        errors.append(\"\\nThere are multiple catch nodes with the same name \").append(duplicatedTarget.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining(\", \"))));", "author": "afalhambra", "createdAt": "2020-08-27T07:15:46Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "diffHunk": "@@ -201,73 +202,83 @@ public Object end(final String uri, final String localName,\n \t\treturn process;\n \t}\n \t\n-\t public static void linkIntermediateLinks(NodeContainer process,\n-\t            List<IntermediateLink> links) {\n-\n \n-        if (null != links) {\n-            List<IntermediateLink> errors = links.stream().filter(l -> l.getName() == null || l.getName().isEmpty()).collect(toList());\n-            if (!errors.isEmpty()) {\n-                StringBuilder builder = new StringBuilder();\n-                for (IntermediateLink l : errors) {\n-                    builder.append(\"\\tIntermediate Link: \" + l.getUniqueId() + \"\\n\");\n+    public static void linkIntermediateLinks(NodeContainer process,List<IntermediateLink> links) {\n+        if (links == null) { \n+            return;\n+        }\n+        Map<String,IntermediateLink> catchLinks = new HashMap<>();\n+        Map<String,Collection<IntermediateLink>> throwLinks = new HashMap<>();\n+        Collection<IntermediateLink> notNameLinks = new ArrayList<>();\n+        Collection<IntermediateLink> duplicatedTarget = new LinkedHashSet<>();\n+        Collection<IntermediateLink> unconnectedTarget = new ArrayList<>();\n+        \n+        // collect errors and nodes in first loop\n+        for (IntermediateLink link : links) {\n+            if (link.getName() == null || link.getName().isEmpty()) {\n+                notNameLinks.add(link);\n+            }\n+            else if (link.isThrowLink()) {\n+                throwLinks.computeIfAbsent(link.getName(), s -> new ArrayList<>()).add(link);\n+            }\n+            else {\n+                IntermediateLink duplicateLink = catchLinks.putIfAbsent(link.getName(),link);\n+                if (duplicateLink != null) {\n+                    duplicatedTarget.add(duplicateLink);\n+                    duplicatedTarget.add(link);\n                 }\n-                throw new IllegalArgumentException(\"There are \" + errors.size() + \" links that does not have a name.\\n\" + builder.toString());\n             }\n-\t            // Search throw links\n-\t            ArrayList<IntermediateLink> throwLinks = new ArrayList<IntermediateLink>();\n-\t            for (IntermediateLink aLinks : links) {\n-\t                if (aLinks.isThrowLink()) {\n-\t                    throwLinks.add(aLinks);\n-\t                }\n-\t            }\n-\n-\t            // Look for catch links for a throw link\n-\t            for (IntermediateLink throwLink : throwLinks) {\n-\n-\t                ArrayList<IntermediateLink> linksWithSharedNames = new ArrayList<IntermediateLink>();\n-\t                for (IntermediateLink aLink : links) {\n-\t                    if (throwLink.getName().equals(aLink.getName())) {\n-\t                        linksWithSharedNames.add(aLink);\n-\t                    }\n-\t                }\n-\n-\t                if (linksWithSharedNames.size() < 2) {\n-\t                    throw new IllegalArgumentException(\n-\t                            \"There should be at least 2 link events to make a connection\");\n-\t                }\n-\n-\t                linksWithSharedNames.remove(throwLink);\n-\n-\t                // Make the connections\n-\t                Node t = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                        throwLink.getUniqueId());\n-\n-\t                // connect throw to catch\n-\t                for (IntermediateLink catchLink : linksWithSharedNames) {\n-\n-\t                    Node c = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                            catchLink.getUniqueId());\n-\t                    if (t != null && c != null) {\n-\t                        Connection result = new ConnectionImpl(t,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE, c,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n-\t                        result.setMetaData(\"linkNodeHidden\", \"yes\");\n-\t                    }\n-\t                }\n-\n-\t                // Remove processed links\n-\t                links.remove(throwLink);\n-\t                links.removeAll(linksWithSharedNames);\n-\t            }\n-\n-\t            if (links.size() > 0) {\n-\t                throw new IllegalArgumentException(links.size()\n-\t                        + \" links were not processed\");\n-\t            }\n+        }\n \n-\t        }\n-\t }\n+        // second loop for connection\n+        for (IntermediateLink catchLink : catchLinks.values()) {\n+            Collection<IntermediateLink> associatedLinks = throwLinks.remove(catchLink.getName());\n+            if (associatedLinks != null) {\n+                // connect throw to catch\n+                Node catchNode = findNodeByIdOrUniqueIdInMetadata(process,catchLink.getUniqueId());\n+                if (catchNode != null) {\n+                    for (IntermediateLink throwLink : associatedLinks) {\n+                        Node throwNode = findNodeByIdOrUniqueIdInMetadata(process,\n+                            throwLink.getUniqueId());\n+                        if (throwNode != null) {\n+                            Connection result = new ConnectionImpl(throwNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE, catchNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n+                            result.setMetaData(\"linkNodeHidden\", \"yes\");\n+                        }\n+                    }\n+                }\n+            }\n+            else {\n+                unconnectedTarget.add(catchLink);\n+            }\n+        }\n+        \n+        // throw exception if any error (this is done late in the process to show the user as much errors as possible) \n+        StringBuilder errors = new StringBuilder();\n+        if (!notNameLinks.isEmpty()) {\n+            errors.append(\"These nodes do not have a name \"+notNameLinks.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));\n+        }\n+        if (!duplicatedTarget.isEmpty()) {\n+            errors.append(\"\\nThere are multiple catch nodes with the same name \"+duplicatedTarget.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));", "originalCommit": "5bb415761d5b798520e128f3510e294bf0f96301", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODIwNjY3Nw==", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478206677", "bodyText": "String concatenation should be done using append method instead. And I would add a delimiter character to show a cleaner message when more than link is wrong, otherwise it may be confusing.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        errors.append(\"These nodes do not have a name \"+notNameLinks.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));\n          \n          \n            \n                        errors.append(\"These nodes do not have a name \").append(notNameLinks.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining(\", \"))));", "author": "afalhambra", "createdAt": "2020-08-27T07:15:50Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "diffHunk": "@@ -201,73 +202,83 @@ public Object end(final String uri, final String localName,\n \t\treturn process;\n \t}\n \t\n-\t public static void linkIntermediateLinks(NodeContainer process,\n-\t            List<IntermediateLink> links) {\n-\n \n-        if (null != links) {\n-            List<IntermediateLink> errors = links.stream().filter(l -> l.getName() == null || l.getName().isEmpty()).collect(toList());\n-            if (!errors.isEmpty()) {\n-                StringBuilder builder = new StringBuilder();\n-                for (IntermediateLink l : errors) {\n-                    builder.append(\"\\tIntermediate Link: \" + l.getUniqueId() + \"\\n\");\n+    public static void linkIntermediateLinks(NodeContainer process,List<IntermediateLink> links) {\n+        if (links == null) { \n+            return;\n+        }\n+        Map<String,IntermediateLink> catchLinks = new HashMap<>();\n+        Map<String,Collection<IntermediateLink>> throwLinks = new HashMap<>();\n+        Collection<IntermediateLink> notNameLinks = new ArrayList<>();\n+        Collection<IntermediateLink> duplicatedTarget = new LinkedHashSet<>();\n+        Collection<IntermediateLink> unconnectedTarget = new ArrayList<>();\n+        \n+        // collect errors and nodes in first loop\n+        for (IntermediateLink link : links) {\n+            if (link.getName() == null || link.getName().isEmpty()) {\n+                notNameLinks.add(link);\n+            }\n+            else if (link.isThrowLink()) {\n+                throwLinks.computeIfAbsent(link.getName(), s -> new ArrayList<>()).add(link);\n+            }\n+            else {\n+                IntermediateLink duplicateLink = catchLinks.putIfAbsent(link.getName(),link);\n+                if (duplicateLink != null) {\n+                    duplicatedTarget.add(duplicateLink);\n+                    duplicatedTarget.add(link);\n                 }\n-                throw new IllegalArgumentException(\"There are \" + errors.size() + \" links that does not have a name.\\n\" + builder.toString());\n             }\n-\t            // Search throw links\n-\t            ArrayList<IntermediateLink> throwLinks = new ArrayList<IntermediateLink>();\n-\t            for (IntermediateLink aLinks : links) {\n-\t                if (aLinks.isThrowLink()) {\n-\t                    throwLinks.add(aLinks);\n-\t                }\n-\t            }\n-\n-\t            // Look for catch links for a throw link\n-\t            for (IntermediateLink throwLink : throwLinks) {\n-\n-\t                ArrayList<IntermediateLink> linksWithSharedNames = new ArrayList<IntermediateLink>();\n-\t                for (IntermediateLink aLink : links) {\n-\t                    if (throwLink.getName().equals(aLink.getName())) {\n-\t                        linksWithSharedNames.add(aLink);\n-\t                    }\n-\t                }\n-\n-\t                if (linksWithSharedNames.size() < 2) {\n-\t                    throw new IllegalArgumentException(\n-\t                            \"There should be at least 2 link events to make a connection\");\n-\t                }\n-\n-\t                linksWithSharedNames.remove(throwLink);\n-\n-\t                // Make the connections\n-\t                Node t = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                        throwLink.getUniqueId());\n-\n-\t                // connect throw to catch\n-\t                for (IntermediateLink catchLink : linksWithSharedNames) {\n-\n-\t                    Node c = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                            catchLink.getUniqueId());\n-\t                    if (t != null && c != null) {\n-\t                        Connection result = new ConnectionImpl(t,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE, c,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n-\t                        result.setMetaData(\"linkNodeHidden\", \"yes\");\n-\t                    }\n-\t                }\n-\n-\t                // Remove processed links\n-\t                links.remove(throwLink);\n-\t                links.removeAll(linksWithSharedNames);\n-\t            }\n-\n-\t            if (links.size() > 0) {\n-\t                throw new IllegalArgumentException(links.size()\n-\t                        + \" links were not processed\");\n-\t            }\n+        }\n \n-\t        }\n-\t }\n+        // second loop for connection\n+        for (IntermediateLink catchLink : catchLinks.values()) {\n+            Collection<IntermediateLink> associatedLinks = throwLinks.remove(catchLink.getName());\n+            if (associatedLinks != null) {\n+                // connect throw to catch\n+                Node catchNode = findNodeByIdOrUniqueIdInMetadata(process,catchLink.getUniqueId());\n+                if (catchNode != null) {\n+                    for (IntermediateLink throwLink : associatedLinks) {\n+                        Node throwNode = findNodeByIdOrUniqueIdInMetadata(process,\n+                            throwLink.getUniqueId());\n+                        if (throwNode != null) {\n+                            Connection result = new ConnectionImpl(throwNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE, catchNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n+                            result.setMetaData(\"linkNodeHidden\", \"yes\");\n+                        }\n+                    }\n+                }\n+            }\n+            else {\n+                unconnectedTarget.add(catchLink);\n+            }\n+        }\n+        \n+        // throw exception if any error (this is done late in the process to show the user as much errors as possible) \n+        StringBuilder errors = new StringBuilder();\n+        if (!notNameLinks.isEmpty()) {\n+            errors.append(\"These nodes do not have a name \"+notNameLinks.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));", "originalCommit": "5bb415761d5b798520e128f3510e294bf0f96301", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1NjM3MQ==", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478256371", "bodyText": "typo\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Collection<IntermediateLink> notNameLinks = new ArrayList<>();\n          \n          \n            \n                    Collection<IntermediateLink> noNameLinks = new ArrayList<>();", "author": "afalhambra", "createdAt": "2020-08-27T08:44:31Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "diffHunk": "@@ -201,73 +202,83 @@ public Object end(final String uri, final String localName,\n \t\treturn process;\n \t}\n \t\n-\t public static void linkIntermediateLinks(NodeContainer process,\n-\t            List<IntermediateLink> links) {\n-\n \n-        if (null != links) {\n-            List<IntermediateLink> errors = links.stream().filter(l -> l.getName() == null || l.getName().isEmpty()).collect(toList());\n-            if (!errors.isEmpty()) {\n-                StringBuilder builder = new StringBuilder();\n-                for (IntermediateLink l : errors) {\n-                    builder.append(\"\\tIntermediate Link: \" + l.getUniqueId() + \"\\n\");\n+    public static void linkIntermediateLinks(NodeContainer process,List<IntermediateLink> links) {\n+        if (links == null) { \n+            return;\n+        }\n+        Map<String,IntermediateLink> catchLinks = new HashMap<>();\n+        Map<String,Collection<IntermediateLink>> throwLinks = new HashMap<>();\n+        Collection<IntermediateLink> notNameLinks = new ArrayList<>();", "originalCommit": "5bb415761d5b798520e128f3510e294bf0f96301", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1NDMwOA==", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478354308", "bodyText": "Ok", "author": "fjtirado", "createdAt": "2020-08-27T11:44:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1NjM3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1NzAyNg==", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478257026", "bodyText": "typo\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    // throw exception if any error (this is done late in the process to show the user as much errors as possible) \n          \n          \n            \n                    // throw exception if any error (this is done later in the process to show the user as much errors as possible)", "author": "afalhambra", "createdAt": "2020-08-27T08:45:30Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "diffHunk": "@@ -201,73 +202,83 @@ public Object end(final String uri, final String localName,\n \t\treturn process;\n \t}\n \t\n-\t public static void linkIntermediateLinks(NodeContainer process,\n-\t            List<IntermediateLink> links) {\n-\n \n-        if (null != links) {\n-            List<IntermediateLink> errors = links.stream().filter(l -> l.getName() == null || l.getName().isEmpty()).collect(toList());\n-            if (!errors.isEmpty()) {\n-                StringBuilder builder = new StringBuilder();\n-                for (IntermediateLink l : errors) {\n-                    builder.append(\"\\tIntermediate Link: \" + l.getUniqueId() + \"\\n\");\n+    public static void linkIntermediateLinks(NodeContainer process,List<IntermediateLink> links) {\n+        if (links == null) { \n+            return;\n+        }\n+        Map<String,IntermediateLink> catchLinks = new HashMap<>();\n+        Map<String,Collection<IntermediateLink>> throwLinks = new HashMap<>();\n+        Collection<IntermediateLink> notNameLinks = new ArrayList<>();\n+        Collection<IntermediateLink> duplicatedTarget = new LinkedHashSet<>();\n+        Collection<IntermediateLink> unconnectedTarget = new ArrayList<>();\n+        \n+        // collect errors and nodes in first loop\n+        for (IntermediateLink link : links) {\n+            if (link.getName() == null || link.getName().isEmpty()) {\n+                notNameLinks.add(link);\n+            }\n+            else if (link.isThrowLink()) {\n+                throwLinks.computeIfAbsent(link.getName(), s -> new ArrayList<>()).add(link);\n+            }\n+            else {\n+                IntermediateLink duplicateLink = catchLinks.putIfAbsent(link.getName(),link);\n+                if (duplicateLink != null) {\n+                    duplicatedTarget.add(duplicateLink);\n+                    duplicatedTarget.add(link);\n                 }\n-                throw new IllegalArgumentException(\"There are \" + errors.size() + \" links that does not have a name.\\n\" + builder.toString());\n             }\n-\t            // Search throw links\n-\t            ArrayList<IntermediateLink> throwLinks = new ArrayList<IntermediateLink>();\n-\t            for (IntermediateLink aLinks : links) {\n-\t                if (aLinks.isThrowLink()) {\n-\t                    throwLinks.add(aLinks);\n-\t                }\n-\t            }\n-\n-\t            // Look for catch links for a throw link\n-\t            for (IntermediateLink throwLink : throwLinks) {\n-\n-\t                ArrayList<IntermediateLink> linksWithSharedNames = new ArrayList<IntermediateLink>();\n-\t                for (IntermediateLink aLink : links) {\n-\t                    if (throwLink.getName().equals(aLink.getName())) {\n-\t                        linksWithSharedNames.add(aLink);\n-\t                    }\n-\t                }\n-\n-\t                if (linksWithSharedNames.size() < 2) {\n-\t                    throw new IllegalArgumentException(\n-\t                            \"There should be at least 2 link events to make a connection\");\n-\t                }\n-\n-\t                linksWithSharedNames.remove(throwLink);\n-\n-\t                // Make the connections\n-\t                Node t = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                        throwLink.getUniqueId());\n-\n-\t                // connect throw to catch\n-\t                for (IntermediateLink catchLink : linksWithSharedNames) {\n-\n-\t                    Node c = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                            catchLink.getUniqueId());\n-\t                    if (t != null && c != null) {\n-\t                        Connection result = new ConnectionImpl(t,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE, c,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n-\t                        result.setMetaData(\"linkNodeHidden\", \"yes\");\n-\t                    }\n-\t                }\n-\n-\t                // Remove processed links\n-\t                links.remove(throwLink);\n-\t                links.removeAll(linksWithSharedNames);\n-\t            }\n-\n-\t            if (links.size() > 0) {\n-\t                throw new IllegalArgumentException(links.size()\n-\t                        + \" links were not processed\");\n-\t            }\n+        }\n \n-\t        }\n-\t }\n+        // second loop for connection\n+        for (IntermediateLink catchLink : catchLinks.values()) {\n+            Collection<IntermediateLink> associatedLinks = throwLinks.remove(catchLink.getName());\n+            if (associatedLinks != null) {\n+                // connect throw to catch\n+                Node catchNode = findNodeByIdOrUniqueIdInMetadata(process,catchLink.getUniqueId());\n+                if (catchNode != null) {\n+                    for (IntermediateLink throwLink : associatedLinks) {\n+                        Node throwNode = findNodeByIdOrUniqueIdInMetadata(process,\n+                            throwLink.getUniqueId());\n+                        if (throwNode != null) {\n+                            Connection result = new ConnectionImpl(throwNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE, catchNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n+                            result.setMetaData(\"linkNodeHidden\", \"yes\");\n+                        }\n+                    }\n+                }\n+            }\n+            else {\n+                unconnectedTarget.add(catchLink);\n+            }\n+        }\n+        \n+        // throw exception if any error (this is done late in the process to show the user as much errors as possible) ", "originalCommit": "5bb415761d5b798520e128f3510e294bf0f96301", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0ODExOQ==", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478348119", "bodyText": "I think late here is properly used, Im not doing it later, it is done late (meaning at the end)", "author": "fjtirado", "createdAt": "2020-08-27T11:32:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1NzAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1NDQ0MQ==", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478354441", "bodyText": "I changed to \" at the end\"", "author": "fjtirado", "createdAt": "2020-08-27T11:44:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI1NzAyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI2MTQ5MA==", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478261490", "bodyText": "I think this is not needed. wdyt?", "author": "afalhambra", "createdAt": "2020-08-27T08:52:54Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "diffHunk": "@@ -201,73 +202,83 @@ public Object end(final String uri, final String localName,\n \t\treturn process;\n \t}\n \t\n-\t public static void linkIntermediateLinks(NodeContainer process,\n-\t            List<IntermediateLink> links) {\n-\n \n-        if (null != links) {\n-            List<IntermediateLink> errors = links.stream().filter(l -> l.getName() == null || l.getName().isEmpty()).collect(toList());\n-            if (!errors.isEmpty()) {\n-                StringBuilder builder = new StringBuilder();\n-                for (IntermediateLink l : errors) {\n-                    builder.append(\"\\tIntermediate Link: \" + l.getUniqueId() + \"\\n\");\n+    public static void linkIntermediateLinks(NodeContainer process,List<IntermediateLink> links) {\n+        if (links == null) { \n+            return;\n+        }\n+        Map<String,IntermediateLink> catchLinks = new HashMap<>();\n+        Map<String,Collection<IntermediateLink>> throwLinks = new HashMap<>();\n+        Collection<IntermediateLink> notNameLinks = new ArrayList<>();\n+        Collection<IntermediateLink> duplicatedTarget = new LinkedHashSet<>();\n+        Collection<IntermediateLink> unconnectedTarget = new ArrayList<>();\n+        \n+        // collect errors and nodes in first loop\n+        for (IntermediateLink link : links) {\n+            if (link.getName() == null || link.getName().isEmpty()) {\n+                notNameLinks.add(link);\n+            }\n+            else if (link.isThrowLink()) {\n+                throwLinks.computeIfAbsent(link.getName(), s -> new ArrayList<>()).add(link);\n+            }\n+            else {\n+                IntermediateLink duplicateLink = catchLinks.putIfAbsent(link.getName(),link);\n+                if (duplicateLink != null) {\n+                    duplicatedTarget.add(duplicateLink);\n+                    duplicatedTarget.add(link);", "originalCommit": "5bb415761d5b798520e128f3510e294bf0f96301", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1NjAxMA==", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478356010", "bodyText": "yes,  we need to add the ids of the links with the same names for the error message, if not, only one id will appear", "author": "fjtirado", "createdAt": "2020-08-27T11:47:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODI2MTQ5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMwNDc1Nw==", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478304757", "bodyText": "String concatenation should be done using append method instead. And I would add a delimiter character to show a cleaner message when more than link is wrong, otherwise it may be confusing.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        errors.append(\"\\nThere is not connection from any catch link to these throw links \"+throwLinks\n          \n          \n            \n                                                           .values()\n          \n          \n            \n                                                           .stream()\n          \n          \n            \n                                                           .flatMap(Collection::stream)\n          \n          \n            \n                                                           .map(IntermediateLink::getUniqueId)\n          \n          \n            \n                                                           .collect(Collectors.joining()));\n          \n          \n            \n                        errors.append(\"\\nThere is not connection from any catch link to these throw links \").append(throwLinks\n          \n          \n            \n                                                           .values()\n          \n          \n            \n                                                           .stream()\n          \n          \n            \n                                                           .flatMap(Collection::stream)\n          \n          \n            \n                                                           .map(IntermediateLink::getUniqueId)\n          \n          \n            \n                                                           .collect(Collectors.joining(\", \"))));", "author": "afalhambra", "createdAt": "2020-08-27T10:05:58Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/ProcessHandler.java", "diffHunk": "@@ -201,73 +202,83 @@ public Object end(final String uri, final String localName,\n \t\treturn process;\n \t}\n \t\n-\t public static void linkIntermediateLinks(NodeContainer process,\n-\t            List<IntermediateLink> links) {\n-\n \n-        if (null != links) {\n-            List<IntermediateLink> errors = links.stream().filter(l -> l.getName() == null || l.getName().isEmpty()).collect(toList());\n-            if (!errors.isEmpty()) {\n-                StringBuilder builder = new StringBuilder();\n-                for (IntermediateLink l : errors) {\n-                    builder.append(\"\\tIntermediate Link: \" + l.getUniqueId() + \"\\n\");\n+    public static void linkIntermediateLinks(NodeContainer process,List<IntermediateLink> links) {\n+        if (links == null) { \n+            return;\n+        }\n+        Map<String,IntermediateLink> catchLinks = new HashMap<>();\n+        Map<String,Collection<IntermediateLink>> throwLinks = new HashMap<>();\n+        Collection<IntermediateLink> notNameLinks = new ArrayList<>();\n+        Collection<IntermediateLink> duplicatedTarget = new LinkedHashSet<>();\n+        Collection<IntermediateLink> unconnectedTarget = new ArrayList<>();\n+        \n+        // collect errors and nodes in first loop\n+        for (IntermediateLink link : links) {\n+            if (link.getName() == null || link.getName().isEmpty()) {\n+                notNameLinks.add(link);\n+            }\n+            else if (link.isThrowLink()) {\n+                throwLinks.computeIfAbsent(link.getName(), s -> new ArrayList<>()).add(link);\n+            }\n+            else {\n+                IntermediateLink duplicateLink = catchLinks.putIfAbsent(link.getName(),link);\n+                if (duplicateLink != null) {\n+                    duplicatedTarget.add(duplicateLink);\n+                    duplicatedTarget.add(link);\n                 }\n-                throw new IllegalArgumentException(\"There are \" + errors.size() + \" links that does not have a name.\\n\" + builder.toString());\n             }\n-\t            // Search throw links\n-\t            ArrayList<IntermediateLink> throwLinks = new ArrayList<IntermediateLink>();\n-\t            for (IntermediateLink aLinks : links) {\n-\t                if (aLinks.isThrowLink()) {\n-\t                    throwLinks.add(aLinks);\n-\t                }\n-\t            }\n-\n-\t            // Look for catch links for a throw link\n-\t            for (IntermediateLink throwLink : throwLinks) {\n-\n-\t                ArrayList<IntermediateLink> linksWithSharedNames = new ArrayList<IntermediateLink>();\n-\t                for (IntermediateLink aLink : links) {\n-\t                    if (throwLink.getName().equals(aLink.getName())) {\n-\t                        linksWithSharedNames.add(aLink);\n-\t                    }\n-\t                }\n-\n-\t                if (linksWithSharedNames.size() < 2) {\n-\t                    throw new IllegalArgumentException(\n-\t                            \"There should be at least 2 link events to make a connection\");\n-\t                }\n-\n-\t                linksWithSharedNames.remove(throwLink);\n-\n-\t                // Make the connections\n-\t                Node t = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                        throwLink.getUniqueId());\n-\n-\t                // connect throw to catch\n-\t                for (IntermediateLink catchLink : linksWithSharedNames) {\n-\n-\t                    Node c = findNodeByIdOrUniqueIdInMetadata(process,\n-\t                            catchLink.getUniqueId());\n-\t                    if (t != null && c != null) {\n-\t                        Connection result = new ConnectionImpl(t,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE, c,\n-\t                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n-\t                        result.setMetaData(\"linkNodeHidden\", \"yes\");\n-\t                    }\n-\t                }\n-\n-\t                // Remove processed links\n-\t                links.remove(throwLink);\n-\t                links.removeAll(linksWithSharedNames);\n-\t            }\n-\n-\t            if (links.size() > 0) {\n-\t                throw new IllegalArgumentException(links.size()\n-\t                        + \" links were not processed\");\n-\t            }\n+        }\n \n-\t        }\n-\t }\n+        // second loop for connection\n+        for (IntermediateLink catchLink : catchLinks.values()) {\n+            Collection<IntermediateLink> associatedLinks = throwLinks.remove(catchLink.getName());\n+            if (associatedLinks != null) {\n+                // connect throw to catch\n+                Node catchNode = findNodeByIdOrUniqueIdInMetadata(process,catchLink.getUniqueId());\n+                if (catchNode != null) {\n+                    for (IntermediateLink throwLink : associatedLinks) {\n+                        Node throwNode = findNodeByIdOrUniqueIdInMetadata(process,\n+                            throwLink.getUniqueId());\n+                        if (throwNode != null) {\n+                            Connection result = new ConnectionImpl(throwNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE, catchNode,\n+                                NodeImpl.CONNECTION_DEFAULT_TYPE);\n+                            result.setMetaData(\"linkNodeHidden\", \"yes\");\n+                        }\n+                    }\n+                }\n+            }\n+            else {\n+                unconnectedTarget.add(catchLink);\n+            }\n+        }\n+        \n+        // throw exception if any error (this is done late in the process to show the user as much errors as possible) \n+        StringBuilder errors = new StringBuilder();\n+        if (!notNameLinks.isEmpty()) {\n+            errors.append(\"These nodes do not have a name \"+notNameLinks.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));\n+        }\n+        if (!duplicatedTarget.isEmpty()) {\n+            errors.append(\"\\nThere are multiple catch nodes with the same name \"+duplicatedTarget.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));\n+        }\n+        if (!unconnectedTarget.isEmpty()) {\n+            errors.append(\"\\nThere is not connection from any throw link to these catch links \"+unconnectedTarget.stream().map(IntermediateLink::getUniqueId).collect(Collectors.joining()));\n+        }\n+        if (!throwLinks.isEmpty()) {\n+            errors.append(\"\\nThere is not connection from any catch link to these throw links \"+throwLinks\n+                                               .values()\n+                                               .stream()\n+                                               .flatMap(Collection::stream)\n+                                               .map(IntermediateLink::getUniqueId)\n+                                               .collect(Collectors.joining()));", "originalCommit": "5bb415761d5b798520e128f3510e294bf0f96301", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1NDg1Mg==", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478354852", "bodyText": "code refactor to move error formatting to private method", "author": "fjtirado", "createdAt": "2020-08-27T11:45:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMwNDc1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMzMDU5OA==", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478330598", "bodyText": "I don't think we really need to set a timeout for any of these tests - wdyt?", "author": "afalhambra", "createdAt": "2020-08-27T10:56:11Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/ErrorLinkProcessTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2017 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/*\n+ * To change this template, choose Tools | Templates\n+ * and open the template in the editor.\n+ */\n+package org.jbpm.test.functional;\n+\n+import org.jbpm.test.JbpmTestCase;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.kie.api.runtime.KieSession;\n+\n+import static org.junit.Assert.assertNotNull;\n+\n+/**\n+ */\n+public class ErrorLinkProcessTest extends JbpmTestCase {\n+\n+    @Rule\n+    public ExpectedException exceptionRule = ExpectedException.none();\n+\n+    public static final String PROCESS_EMPTY = \"org/jbpm/test/functional/common/EmptyLinkProcess.bpmn2\";\n+    public static final String PROCESS_EMPTY_ID = \"org.jbpm.test.functional.common.EmptyLinkProcess\";\n+    \n+    public static final String PROCESS_MULTI_THROW = \"org/jbpm/test/functional/common/MultipleThrowLinkProcess.bpmn2\";\n+    public static final String PROCESS_MULTI_THROW_ID = \"org.jbpm.test.functional.common.MultipleThrowLinkProcess\";\n+    \n+    public static final String PROCESS_MULTI_CATCH = \"org/jbpm/test/functional/common/MultipleCatchLinkProcess.bpmn2\";\n+    public static final String PROCESS_MULTI_CATCH_ID = \"org.jbpm.test.functional.common.MultipleCatchLinkProcess\";\n+    \n+    public static final String PROCESS_UNCONNECTED = \"org/jbpm/test/functional/common/UnconnectedLinkProcess.bpmn2\";\n+    public static final String PROCESS_UNCONNECTED_ID = \"org.jbpm.test.functional.common.UnconnectedLinkProcess\";\n+\n+    public ErrorLinkProcessTest() {\n+        super(false);\n+    }\n+\n+    @Test(timeout = 30000)", "originalCommit": "f074cf209b43f328b658ee1f5d2598e9cfcd6a98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1NTAxNA==", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478355014", "bodyText": "no, not really, I was keeping the original just in case, removing", "author": "fjtirado", "createdAt": "2020-08-27T11:45:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMzMDU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMzNjgzMw==", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478336833", "bodyText": "2020", "author": "afalhambra", "createdAt": "2020-08-27T11:09:22Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/ErrorLinkProcessTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2017 Red Hat, Inc. and/or its affiliates.", "originalCommit": "f074cf209b43f328b658ee1f5d2598e9cfcd6a98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1NTE5Nw==", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478355197", "bodyText": "\"donde va la gente\" ;)", "author": "fjtirado", "createdAt": "2020-08-27T11:45:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMzNjgzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMzNjkyOQ==", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478336929", "bodyText": "Please remove", "author": "afalhambra", "createdAt": "2020-08-27T11:09:33Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/ErrorLinkProcessTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2017 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/*\n+ * To change this template, choose Tools | Templates\n+ * and open the template in the editor.\n+ */\n+package org.jbpm.test.functional;\n+\n+import org.jbpm.test.JbpmTestCase;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.kie.api.runtime.KieSession;\n+\n+import static org.junit.Assert.assertNotNull;\n+\n+/**\n+ */", "originalCommit": "f074cf209b43f328b658ee1f5d2598e9cfcd6a98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1NTQ0NQ==", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478355445", "bodyText": "Done", "author": "fjtirado", "createdAt": "2020-08-27T11:46:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMzNjkyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODMzODQ1NQ==", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478338455", "bodyText": "We don't really need to start any process for any of these tests as in case of any exceptions/errors these will be thrown while creating Kie session.", "author": "afalhambra", "createdAt": "2020-08-27T11:12:38Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/ErrorLinkProcessTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2017 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/*\n+ * To change this template, choose Tools | Templates\n+ * and open the template in the editor.\n+ */\n+package org.jbpm.test.functional;\n+\n+import org.jbpm.test.JbpmTestCase;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.kie.api.runtime.KieSession;\n+\n+import static org.junit.Assert.assertNotNull;\n+\n+/**\n+ */\n+public class ErrorLinkProcessTest extends JbpmTestCase {\n+\n+    @Rule\n+    public ExpectedException exceptionRule = ExpectedException.none();\n+\n+    public static final String PROCESS_EMPTY = \"org/jbpm/test/functional/common/EmptyLinkProcess.bpmn2\";\n+    public static final String PROCESS_EMPTY_ID = \"org.jbpm.test.functional.common.EmptyLinkProcess\";\n+    \n+    public static final String PROCESS_MULTI_THROW = \"org/jbpm/test/functional/common/MultipleThrowLinkProcess.bpmn2\";\n+    public static final String PROCESS_MULTI_THROW_ID = \"org.jbpm.test.functional.common.MultipleThrowLinkProcess\";\n+    \n+    public static final String PROCESS_MULTI_CATCH = \"org/jbpm/test/functional/common/MultipleCatchLinkProcess.bpmn2\";\n+    public static final String PROCESS_MULTI_CATCH_ID = \"org.jbpm.test.functional.common.MultipleCatchLinkProcess\";\n+    \n+    public static final String PROCESS_UNCONNECTED = \"org/jbpm/test/functional/common/UnconnectedLinkProcess.bpmn2\";\n+    public static final String PROCESS_UNCONNECTED_ID = \"org.jbpm.test.functional.common.UnconnectedLinkProcess\";\n+\n+    public ErrorLinkProcessTest() {\n+        super(false);\n+    }\n+\n+    @Test(timeout = 30000)\n+    public void testEmptyLinkEvents() {\n+        exceptionRule.expect(IllegalArgumentException.class);\n+        exceptionRule.expectMessage(\"nodes do not have a name\");\n+        KieSession ksession = createKSession(PROCESS_EMPTY);\n+        ksession.startProcess(PROCESS_EMPTY_ID);", "originalCommit": "f074cf209b43f328b658ee1f5d2598e9cfcd6a98", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0MDQ4NA==", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478340484", "bodyText": "Sorry forgot to add a comment about this. This needs to be removed.", "author": "afalhambra", "createdAt": "2020-08-27T11:16:59Z", "path": "jbpm-test-coverage/src/test/java/org/jbpm/test/functional/ErrorLinkProcessTest.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2017 Red Hat, Inc. and/or its affiliates.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/*\n+ * To change this template, choose Tools | Templates\n+ * and open the template in the editor.\n+ */", "originalCommit": "f074cf209b43f328b658ee1f5d2598e9cfcd6a98", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM1NTU4NQ==", "url": "https://github.com/kiegroup/jbpm/pull/1742#discussion_r478355585", "bodyText": "Yes, now I see it, removed too", "author": "fjtirado", "createdAt": "2020-08-27T11:46:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODM0MDQ4NA=="}], "type": "inlineReview"}, {"oid": "5fed292793dcb6c98a76d5d61845f025ae4dff7f", "url": "https://github.com/kiegroup/jbpm/commit/5fed292793dcb6c98a76d5d61845f025ae4dff7f", "message": "[RPHAM-3132] Adjust link behavior to bpmn specification\n\nThere can be multiple throw links per a catch link, but not the other\nway around", "committedDate": "2020-08-27T11:43:52Z", "type": "forcePushed"}, {"oid": "c5482a0cf733125530651ca1fc2d188fd5476c37", "url": "https://github.com/kiegroup/jbpm/commit/c5482a0cf733125530651ca1fc2d188fd5476c37", "message": "[RPHAM-3132] Adjust link behavior to bpmn specification\n\nThere can be multiple throw links per a catch link, but not the other\nway around", "committedDate": "2020-08-27T11:48:39Z", "type": "commit"}, {"oid": "c5482a0cf733125530651ca1fc2d188fd5476c37", "url": "https://github.com/kiegroup/jbpm/commit/c5482a0cf733125530651ca1fc2d188fd5476c37", "message": "[RPHAM-3132] Adjust link behavior to bpmn specification\n\nThere can be multiple throw links per a catch link, but not the other\nway around", "committedDate": "2020-08-27T11:48:39Z", "type": "forcePushed"}]}