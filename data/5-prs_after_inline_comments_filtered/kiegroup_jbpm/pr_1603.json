{"pr_number": 1603, "pr_title": "[RHPAM-2774] AchievedAtDate for milestone is not preserved when case is reopen", "pr_createdAt": "2020-03-09T08:33:47Z", "pr_url": "https://github.com/kiegroup/jbpm/pull/1603", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwNzIwMw==", "url": "https://github.com/kiegroup/jbpm/pull/1603#discussion_r389607203", "bodyText": "The map contains lists with one element, so ordering is applying to that list and therefore not working.\nPerhaps you can order after generating the list of CaseMilestoneInstance.\nmilestones.sort(Comparator.comparing(CaseMilestoneInstance::getAchievedAt));", "author": "gmunozfe", "createdAt": "2020-03-09T11:39:43Z", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/CaseRuntimeDataServiceImpl.java", "diffHunk": "@@ -340,43 +340,36 @@ public CaseDefinition getCase(String deploymentId, String caseDefinitionId) {\n \n     @Override\n     public Collection<CaseMilestoneInstance> getCaseInstanceMilestones(String caseId, boolean achievedOnly, QueryContext queryContext) {\n-        ProcessInstanceDesc pi = runtimeDataService.getProcessInstanceByCorrelationKey(correlationKeyFactory.newCorrelationKey(caseId));        \n+        ProcessInstanceDesc pi = runtimeDataService.getProcessInstanceByCorrelationKey(correlationKeyFactory.newCorrelationKey(caseId));\n         if (pi == null || !pi.getState().equals(ProcessInstance.STATE_ACTIVE)) {\n             throw new CaseNotFoundException(\"No case instance found with id \" + caseId + \" or it's not active anymore\");\n         }\n         CorrelationKey correlationKey = correlationKeyFactory.newCorrelationKey(caseId);\n-        \n-        Collection<org.jbpm.services.api.model.NodeInstanceDesc> nodes = runtimeDataService.getNodeInstancesByCorrelationKeyNodeType(correlationKey, \n-                                                                                                Arrays.asList(ProcessInstance.STATE_ACTIVE), \n-                                                                                                Arrays.asList(\"MilestoneNode\"), \n-                                                                                                queryContext);\n-        \n-        Collection<Long> completedNodes = nodes.stream().filter(n -> ((NodeInstanceDesc)n).getType() == 1).map(n -> n.getId()).collect(toList());\n-        Predicate<org.jbpm.services.api.model.NodeInstanceDesc> filterNodes = null;\n-        if (achievedOnly) {            \n-            filterNodes = n -> ((NodeInstanceDesc)n).getType() == 1;             \n-        } else {\n-            filterNodes = n -> ((NodeInstanceDesc)n).getType() == 0;\n-        }\n-        List<String> foundMilestones = new ArrayList<>();\n-        \n-        List<CaseMilestoneInstance> milestones = nodes.stream()\n-        .filter(filterNodes)\n-        .map(n -> {\n-            foundMilestones.add(n.getName());\n-            return new CaseMilestoneInstanceImpl(String.valueOf(n.getId()), n.getName(), completedNodes.contains(n.getId()), n.getDataTimeStamp());        \n-        })\n-        .collect(toList());\n-        \n+\n+        Collection<org.jbpm.services.api.model.NodeInstanceDesc> nodes = runtimeDataService.getNodeInstancesByCorrelationKeyNodeType(correlationKey,\n+                                                                                                                                     Arrays.asList(ProcessInstance.STATE_ACTIVE, ProcessInstance.STATE_ABORTED),\n+                                                                                                                                     Arrays.asList(\"MilestoneNode\"),\n+                                                                                                                                     queryContext);\n+\n+        // achieved milestones\n+        Map<String, List<CaseMilestoneInstance>> milestonesGroup = nodes.stream()\n+                                                                        .map(n -> (NodeInstanceDesc) n)\n+                                                                        .filter(n -> n.getType() == 1)\n+                                                                        .map(n -> new CaseMilestoneInstanceImpl(String.valueOf(n.getId()), n.getName(), true, n.getDataTimeStamp()))\n+                                                                        .collect(Collectors.groupingBy(CaseMilestoneInstance::getName));\n+\n+        List<CaseMilestoneInstance> milestones = milestonesGroup.values().stream().map(e -> e.stream().min((o1, o2) -> o1.getAchievedAt().compareTo(o2.getAchievedAt())).get()).collect(toList());", "originalCommit": "ab35c2b1f9ae9bdde151d414c5017aa31b9febe4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY2NTI0MA==", "url": "https://github.com/kiegroup/jbpm/pull/1603#discussion_r389665240", "bodyText": "Not really sure I understand your comments. If a case is cancelled and then reopen it should contain at least two elements and so on ?... do you mind to check again ?", "author": "elguardian", "createdAt": "2020-03-09T13:30:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwNzIwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY5ODMyNw==", "url": "https://github.com/kiegroup/jbpm/pull/1603#discussion_r389698327", "bodyText": "I meant for the failing test, which contained only one element per key, and the list obtained from the map was not ordered. Now, it's working fine, thanks!", "author": "gmunozfe", "createdAt": "2020-03-09T13:58:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTYwNzIwMw=="}], "type": "inlineReview"}, {"oid": "5503483e27a310e097d8211b1ec54b9d4b3d61b1", "url": "https://github.com/kiegroup/jbpm/commit/5503483e27a310e097d8211b1ec54b9d4b3d61b1", "message": "[RHPAM-2774] chievedAtDate for milestone is not preserved when case is reopen\n\nmodify query for milestones as a plain value object", "committedDate": "2020-03-09T13:29:15Z", "type": "forcePushed"}, {"oid": "91c7d043d1320f3d92e5273d175329f3237fac3d", "url": "https://github.com/kiegroup/jbpm/commit/91c7d043d1320f3d92e5273d175329f3237fac3d", "message": "[RHPAM-2774] AchievedAtDate for milestone is not preserved when case is reopen\n\nmodify query for milestones as a plain value object", "committedDate": "2020-03-11T15:57:41Z", "type": "forcePushed"}, {"oid": "7ac30e55062b2b5f650c74368ed59bd4054f41dc", "url": "https://github.com/kiegroup/jbpm/commit/7ac30e55062b2b5f650c74368ed59bd4054f41dc", "message": "[RHPAM-2774] AchievedAtDate for milestone is not preserved when case is reopen\n\nmodify query for milestones as a plain value object", "committedDate": "2020-03-12T07:39:52Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUzMDEwNQ==", "url": "https://github.com/kiegroup/jbpm/pull/1603#discussion_r391530105", "bodyText": "if both are null, shouldn't it return 0?", "author": "gmunozfe", "createdAt": "2020-03-12T10:33:25Z", "path": "jbpm-case-mgmt/jbpm-case-mgmt-impl/src/main/java/org/jbpm/casemgmt/impl/CaseRuntimeDataServiceImpl.java", "diffHunk": "@@ -340,44 +340,47 @@ public CaseDefinition getCase(String deploymentId, String caseDefinitionId) {\n \n     @Override\n     public Collection<CaseMilestoneInstance> getCaseInstanceMilestones(String caseId, boolean achievedOnly, QueryContext queryContext) {\n-        ProcessInstanceDesc pi = runtimeDataService.getProcessInstanceByCorrelationKey(correlationKeyFactory.newCorrelationKey(caseId));        \n+        ProcessInstanceDesc pi = runtimeDataService.getProcessInstanceByCorrelationKey(correlationKeyFactory.newCorrelationKey(caseId));\n         if (pi == null || !pi.getState().equals(ProcessInstance.STATE_ACTIVE)) {\n             throw new CaseNotFoundException(\"No case instance found with id \" + caseId + \" or it's not active anymore\");\n         }\n         CorrelationKey correlationKey = correlationKeyFactory.newCorrelationKey(caseId);\n-        \n-        Collection<org.jbpm.services.api.model.NodeInstanceDesc> nodes = runtimeDataService.getNodeInstancesByCorrelationKeyNodeType(correlationKey, \n-                                                                                                Arrays.asList(ProcessInstance.STATE_ACTIVE), \n-                                                                                                Arrays.asList(\"MilestoneNode\"), \n-                                                                                                queryContext);\n-        \n-        Collection<Long> completedNodes = nodes.stream().filter(n -> ((NodeInstanceDesc)n).getType() == 1).map(n -> n.getId()).collect(toList());\n-        Predicate<org.jbpm.services.api.model.NodeInstanceDesc> filterNodes = null;\n-        if (achievedOnly) {            \n-            filterNodes = n -> ((NodeInstanceDesc)n).getType() == 1;             \n-        } else {\n-            filterNodes = n -> ((NodeInstanceDesc)n).getType() == 0;\n-        }\n-        List<String> foundMilestones = new ArrayList<>();\n-        \n-        List<CaseMilestoneInstance> milestones = nodes.stream()\n-        .filter(filterNodes)\n-        .map(n -> {\n-            foundMilestones.add(n.getName());\n-            return new CaseMilestoneInstanceImpl(String.valueOf(n.getId()), n.getName(), completedNodes.contains(n.getId()), n.getDataTimeStamp());        \n-        })\n-        .collect(toList());\n-        \n+\n+        Collection<org.jbpm.services.api.model.NodeInstanceDesc> nodes = runtimeDataService.getValidNodeInstancesByCorrelationKeyNodeType(correlationKey,\n+                                                                                                                                     Arrays.asList(ProcessInstance.STATE_ACTIVE, ProcessInstance.STATE_ABORTED),\n+                                                                                                                                     Arrays.asList(\"MilestoneNode\"),\n+                                                                                                                                     queryContext);\n+\n+        // achieved milestones\n+        Map<String, List<CaseMilestoneInstance>> milestonesGroup = nodes.stream()\n+                                                                        .map(n -> (NodeInstanceDesc) n)\n+                                                                        .filter(n -> n.getType() == 1)\n+                                                                        .map(n -> new CaseMilestoneInstanceImpl(String.valueOf(n.getId()), n.getName(), true, n.getDataTimeStamp()))\n+                                                                        .collect(Collectors.groupingBy(CaseMilestoneInstance::getName));\n+\n+        List<CaseMilestoneInstance> milestones = milestonesGroup.values().stream().map(e -> e.stream().min(this::compareMilestones).get()).collect(toList());\n+        List<String> foundMilestones = milestones.stream().map(e -> e.getName()).collect(toList());\n+\n         if (!achievedOnly) {\n             // add other milestones that are present in the definition\n             CaseDefinition caseDef = getCase(pi.getDeploymentId(), pi.getProcessId());\n             caseDef.getCaseMilestones().stream()\n-            .filter(cm -> !foundMilestones.contains(cm.getName()))\n-            .map(cm -> new CaseMilestoneInstanceImpl(cm.getId(), cm.getName(), false, null))\n-            .forEach(cmi -> milestones.add(cmi));\n+                   .filter(cm -> !foundMilestones.contains(cm.getName()))\n+                   .map(cm -> new CaseMilestoneInstanceImpl(cm.getId(), cm.getName(), false, null))\n+                   .forEach(cmi -> milestones.add(cmi));\n         }\n-        \n-        return applyPagination(milestones, queryContext);\n+\n+        List<CaseMilestoneInstance> sortedMilestones = milestones.stream().sorted(this::compareMilestones).collect(toList());\n+        return applyPagination(sortedMilestones, queryContext);\n+    }\n+\n+    private int compareMilestones(CaseMilestoneInstance o1, CaseMilestoneInstance o2) {\n+        if (o1.getAchievedAt() == null) {\n+            return -1;", "originalCommit": "7ac30e55062b2b5f650c74368ed59bd4054f41dc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTY2ODExNg==", "url": "https://github.com/kiegroup/jbpm/pull/1603#discussion_r391668116", "bodyText": "null <> null = true... null == null = false... depends on our view.", "author": "elguardian", "createdAt": "2020-03-12T14:40:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTUzMDEwNQ=="}], "type": "inlineReview"}, {"oid": "6c384139deb628c178f8b051e4b474d920fb183c", "url": "https://github.com/kiegroup/jbpm/commit/6c384139deb628c178f8b051e4b474d920fb183c", "message": "[RHPAM-2774] AchievedAtDate for milestone is not preserved when case is reopen\n\nadded a new event log for node instance to be able to tell the different when\na node is left or aborted", "committedDate": "2020-03-16T08:48:45Z", "type": "forcePushed"}, {"oid": "4798825109900bef994b10064863666a4dd9ae18", "url": "https://github.com/kiegroup/jbpm/commit/4798825109900bef994b10064863666a4dd9ae18", "message": "[RHPAM-2774] AchievedAtDate for milestone is not preserved when case is reopen\n\nadded a new event log for node instance to be able to tell the different when\na node is left or aborted", "committedDate": "2020-03-16T15:13:10Z", "type": "commit"}, {"oid": "4798825109900bef994b10064863666a4dd9ae18", "url": "https://github.com/kiegroup/jbpm/commit/4798825109900bef994b10064863666a4dd9ae18", "message": "[RHPAM-2774] AchievedAtDate for milestone is not preserved when case is reopen\n\nadded a new event log for node instance to be able to tell the different when\na node is left or aborted", "committedDate": "2020-03-16T15:13:10Z", "type": "forcePushed"}]}