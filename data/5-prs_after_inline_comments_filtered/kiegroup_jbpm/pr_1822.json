{"pr_number": 1822, "pr_title": "[JBPM-9507] Align DataAssociation behavior with kogito", "pr_createdAt": "2020-12-11T13:52:48Z", "pr_url": "https://github.com/kiegroup/jbpm/pull/1822", "timeline": [{"oid": "27c6569ff1c061584b8e14b3c5837ae1b3cd6162", "url": "https://github.com/kiegroup/jbpm/commit/27c6569ff1c061584b8e14b3c5837ae1b3cd6162", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior", "committedDate": "2020-12-11T16:25:28Z", "type": "forcePushed"}, {"oid": "85fca05f7f72af2e73f27a72b25c882b00e70e69", "url": "https://github.com/kiegroup/jbpm/commit/85fca05f7f72af2e73f27a72b25c882b00e70e69", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior", "committedDate": "2020-12-11T16:47:18Z", "type": "forcePushed"}, {"oid": "439fa0ec68474e97e86003de1a879f88e20f284f", "url": "https://github.com/kiegroup/jbpm/commit/439fa0ec68474e97e86003de1a879f88e20f284f", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior", "committedDate": "2020-12-11T17:05:54Z", "type": "forcePushed"}, {"oid": "9f271d537d84be0aafab5545f62c59f9aae0b67b", "url": "https://github.com/kiegroup/jbpm/commit/9f271d537d84be0aafab5545f62c59f9aae0b67b", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior", "committedDate": "2020-12-11T17:18:06Z", "type": "forcePushed"}, {"oid": "8f451ed5064e5f1c4819568153515cc5f2c8212a", "url": "https://github.com/kiegroup/jbpm/commit/8f451ed5064e5f1c4819568153515cc5f2c8212a", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior", "committedDate": "2020-12-11T17:20:45Z", "type": "forcePushed"}, {"oid": "9ea31f0debf0032104f736a28e8a4b2fc5a7a748", "url": "https://github.com/kiegroup/jbpm/commit/9ea31f0debf0032104f736a28e8a4b2fc5a7a748", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior", "committedDate": "2020-12-14T10:49:42Z", "type": "forcePushed"}, {"oid": "51c65b810e66e0e23eedcf03abca9c08d167cd1f", "url": "https://github.com/kiegroup/jbpm/commit/51c65b810e66e0e23eedcf03abca9c08d167cd1f", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior", "committedDate": "2020-12-14T11:42:42Z", "type": "forcePushed"}, {"oid": "ff06d823ef343533eb7d6db57b1a3facbd1316cc", "url": "https://github.com/kiegroup/jbpm/commit/ff06d823ef343533eb7d6db57b1a3facbd1316cc", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior", "committedDate": "2020-12-14T11:50:50Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzEzNDg5NA==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543134894", "bodyText": "small typo\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static boolean isLegacyAssigment(String source, List<Assignment> assignments) {\n          \n          \n            \n                public static boolean isLegacyAssignment(String source, List<Assignment> assignments) {", "author": "afalhambra", "createdAt": "2020-12-15T08:18:57Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/elements/DataAssociationFactory.java", "diffHunk": "@@ -33,84 +37,181 @@\n import org.slf4j.LoggerFactory;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n+import org.w3c.dom.Text;\n \n public final class DataAssociationFactory {\n-    \n+\n     protected static final String LANG_EXPRESSION_ATTR = \"language\";\n     protected static final String DEFAULT_DIALECT = \"XPath\";\n     protected static final String USE_DEFINITION_LANGUAGE_PROPERTY = \"org.kie.jbpm.bpmn2.useDefinitionLanguage\";\n+    private static final String SOURCE_REF = \"sourceRef\";\n+    private static final String TARGET_REF = \"targetRef\";\n+    private static final String TRANSFORMATION = \"transformation\";\n+    private static final String ASSIGNMENT = \"assignment\";\n     private static final Logger logger = LoggerFactory.getLogger(DataAssociationFactory.class);\n-    \n     private static Map<String, Pattern> dialectPatterns = buildDialectPatterns(ProcessDialectRegistry.getDialects());\n \n-    private DataAssociationFactory() {\n-        // do nothing\n-    }\n+    private DataAssociationFactory() {}\n \n     public static DataAssociation readDataOutputAssociation(Node xmlNode, Map<String, String> dataOutputs) {\n-\n         NodeList nodeList = xmlNode.getChildNodes();\n         String source = null;\n         String target = null;\n         Transformation transformation = null;\n         List<Assignment> assignment = new ArrayList<>();\n-        for(int i = 0; i < nodeList.getLength(); i++) {\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n             Node subNode = nodeList.item(i);\n-            switch(subNode.getNodeName()) {\n-                case \"sourceRef\":\n-                {\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n                     source = subNode.getTextContent();\n-                    if(!dataOutputs.containsKey(source)) {\n-                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes().getNamedItem(\"id\"), source);\n+                    String mapped = dataOutputs.get(source);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), source);\n+                    }\n+                    else {\n+                        source = mapped;\n                     }\n-                    // indirection\n-                    source = dataOutputs.get(source);\n                     break;\n-                }\n-                case \"targetRef\":\n-                {\n+                case TARGET_REF:\n                     target = subNode.getTextContent();\n                     break;\n-                }\n-                case \"transformation\":\n-                {\n+                case TRANSFORMATION:\n                     String lang = subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR).getNodeValue();\n                     String expression = subNode.getTextContent();\n                     transformation = new Transformation(lang, expression, source);\n                     break;\n-                }\n-                case \"assignment\":\n-                {\n-                    assignment.add(readAssignment(subNode));\n+                case ASSIGNMENT:\n+                    assignment.add(readAssignment(subNode, dataOutputs));\n                     break;\n-                }\n             }\n-\n         }\n         return new DataAssociation(source, target, assignment, transformation);\n     }\n-    \n+\n+    public static void readDataInputAssociation(Node xmlNode,\n+                                                Map<String, String> dataInputs,\n+                                                BiPredicate<String, List<Assignment>> isLegacy,\n+                                                Consumer<DataAssociation> addAssigment,\n+                                                BiConsumer<String, Object> legacyAssigment) {\n+        NodeList nodeList = xmlNode.getChildNodes();\n+        String source = null;\n+        String target = null;\n+        Transformation transformation = null;\n+        List<Assignment> assignments = new ArrayList<>();\n+        Node assignmentNode = null;\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n+            Node subNode = nodeList.item(i);\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n+                    source = subNode.getTextContent();\n+                    break;\n+                case TARGET_REF:\n+                    target = subNode.getTextContent();\n+                    String mapped = dataInputs.get(target);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data inputs in this node {} does not contain target {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), target);\n+                    }\n+                    else {\n+                        target = mapped;\n+                    }\n+                    break;\n+                case TRANSFORMATION:\n+                    transformation = new Transformation(subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR)\n+                            .getNodeValue(), subNode.getTextContent());\n+                    break;\n+                case ASSIGNMENT:\n+                    assignmentNode = subNode;\n+                    assignments.add(readAssignment(subNode, dataInputs));\n+                    break;\n+            }\n+        }\n+        if (isLegacy.test(source, assignments))\n+        {\n+            Object value = getValue(assignmentNode);\n+            if (value != null) {\n+                legacyAssigment.accept(target, value);\n+            }\n+        } else {\n+            addAssigment.accept(new DataAssociation(source, target, assignments, transformation));\n+        }\n+    }\n+\n+    public static boolean isLegacyAssigment(String source, List<Assignment> assignments) {", "originalCommit": "ff06d823ef343533eb7d6db57b1a3facbd1316cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0NTc0Mg==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543145742", "bodyText": "!assignments.isEmpty() when reached is always false. Expression can be simplified to\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    return source == null && assignments.isEmpty() || source == null && !assignments.isEmpty() && assignments.get(0)\n          \n          \n            \n                            .getDialect().equals(DEFAULT_DIALECT);\n          \n          \n            \n                    return source == null && assignments.isEmpty() || source == null && assignments.get(0)\n          \n          \n            \n                            .getDialect().equals(DEFAULT_DIALECT);\n          \n      \n    \n    \n  \n\nAlso, as this is declared as a public static method, just for safety - wouldn't be worth checking a non-empty source and a non-null assignment? wdyt?", "author": "afalhambra", "createdAt": "2020-12-15T08:35:40Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/elements/DataAssociationFactory.java", "diffHunk": "@@ -33,84 +37,181 @@\n import org.slf4j.LoggerFactory;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n+import org.w3c.dom.Text;\n \n public final class DataAssociationFactory {\n-    \n+\n     protected static final String LANG_EXPRESSION_ATTR = \"language\";\n     protected static final String DEFAULT_DIALECT = \"XPath\";\n     protected static final String USE_DEFINITION_LANGUAGE_PROPERTY = \"org.kie.jbpm.bpmn2.useDefinitionLanguage\";\n+    private static final String SOURCE_REF = \"sourceRef\";\n+    private static final String TARGET_REF = \"targetRef\";\n+    private static final String TRANSFORMATION = \"transformation\";\n+    private static final String ASSIGNMENT = \"assignment\";\n     private static final Logger logger = LoggerFactory.getLogger(DataAssociationFactory.class);\n-    \n     private static Map<String, Pattern> dialectPatterns = buildDialectPatterns(ProcessDialectRegistry.getDialects());\n \n-    private DataAssociationFactory() {\n-        // do nothing\n-    }\n+    private DataAssociationFactory() {}\n \n     public static DataAssociation readDataOutputAssociation(Node xmlNode, Map<String, String> dataOutputs) {\n-\n         NodeList nodeList = xmlNode.getChildNodes();\n         String source = null;\n         String target = null;\n         Transformation transformation = null;\n         List<Assignment> assignment = new ArrayList<>();\n-        for(int i = 0; i < nodeList.getLength(); i++) {\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n             Node subNode = nodeList.item(i);\n-            switch(subNode.getNodeName()) {\n-                case \"sourceRef\":\n-                {\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n                     source = subNode.getTextContent();\n-                    if(!dataOutputs.containsKey(source)) {\n-                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes().getNamedItem(\"id\"), source);\n+                    String mapped = dataOutputs.get(source);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), source);\n+                    }\n+                    else {\n+                        source = mapped;\n                     }\n-                    // indirection\n-                    source = dataOutputs.get(source);\n                     break;\n-                }\n-                case \"targetRef\":\n-                {\n+                case TARGET_REF:\n                     target = subNode.getTextContent();\n                     break;\n-                }\n-                case \"transformation\":\n-                {\n+                case TRANSFORMATION:\n                     String lang = subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR).getNodeValue();\n                     String expression = subNode.getTextContent();\n                     transformation = new Transformation(lang, expression, source);\n                     break;\n-                }\n-                case \"assignment\":\n-                {\n-                    assignment.add(readAssignment(subNode));\n+                case ASSIGNMENT:\n+                    assignment.add(readAssignment(subNode, dataOutputs));\n                     break;\n-                }\n             }\n-\n         }\n         return new DataAssociation(source, target, assignment, transformation);\n     }\n-    \n+\n+    public static void readDataInputAssociation(Node xmlNode,\n+                                                Map<String, String> dataInputs,\n+                                                BiPredicate<String, List<Assignment>> isLegacy,\n+                                                Consumer<DataAssociation> addAssigment,\n+                                                BiConsumer<String, Object> legacyAssigment) {\n+        NodeList nodeList = xmlNode.getChildNodes();\n+        String source = null;\n+        String target = null;\n+        Transformation transformation = null;\n+        List<Assignment> assignments = new ArrayList<>();\n+        Node assignmentNode = null;\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n+            Node subNode = nodeList.item(i);\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n+                    source = subNode.getTextContent();\n+                    break;\n+                case TARGET_REF:\n+                    target = subNode.getTextContent();\n+                    String mapped = dataInputs.get(target);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data inputs in this node {} does not contain target {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), target);\n+                    }\n+                    else {\n+                        target = mapped;\n+                    }\n+                    break;\n+                case TRANSFORMATION:\n+                    transformation = new Transformation(subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR)\n+                            .getNodeValue(), subNode.getTextContent());\n+                    break;\n+                case ASSIGNMENT:\n+                    assignmentNode = subNode;\n+                    assignments.add(readAssignment(subNode, dataInputs));\n+                    break;\n+            }\n+        }\n+        if (isLegacy.test(source, assignments))\n+        {\n+            Object value = getValue(assignmentNode);\n+            if (value != null) {\n+                legacyAssigment.accept(target, value);\n+            }\n+        } else {\n+            addAssigment.accept(new DataAssociation(source, target, assignments, transformation));\n+        }\n+    }\n+\n+    public static boolean isLegacyAssigment(String source, List<Assignment> assignments) {\n+        return source == null && assignments.isEmpty() || source == null && !assignments.isEmpty() && assignments.get(0)\n+                .getDialect().equals(DEFAULT_DIALECT);", "originalCommit": "ff06d823ef343533eb7d6db57b1a3facbd1316cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ1NTYwMQ==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543455601", "bodyText": "Ill simplify the expression (although I think is difficult to read simplified).\nRegarding the cases you mention,  source is already checked (part of the logic) and assigments should never be null there (so it is fine to throw Runtime in that case)", "author": "fjtirado", "createdAt": "2020-12-15T15:41:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0NTc0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE0NjE1OQ==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543146159", "bodyText": "typo\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                                            Consumer<DataAssociation> addAssigment,\n          \n          \n            \n                                                            BiConsumer<String, Object> legacyAssigment) {\n          \n          \n            \n                                                            Consumer<DataAssociation> addAssignment,\n          \n          \n            \n                                                            BiConsumer<String, Object> legacyAssignment) {", "author": "afalhambra", "createdAt": "2020-12-15T08:36:23Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/elements/DataAssociationFactory.java", "diffHunk": "@@ -33,84 +37,181 @@\n import org.slf4j.LoggerFactory;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n+import org.w3c.dom.Text;\n \n public final class DataAssociationFactory {\n-    \n+\n     protected static final String LANG_EXPRESSION_ATTR = \"language\";\n     protected static final String DEFAULT_DIALECT = \"XPath\";\n     protected static final String USE_DEFINITION_LANGUAGE_PROPERTY = \"org.kie.jbpm.bpmn2.useDefinitionLanguage\";\n+    private static final String SOURCE_REF = \"sourceRef\";\n+    private static final String TARGET_REF = \"targetRef\";\n+    private static final String TRANSFORMATION = \"transformation\";\n+    private static final String ASSIGNMENT = \"assignment\";\n     private static final Logger logger = LoggerFactory.getLogger(DataAssociationFactory.class);\n-    \n     private static Map<String, Pattern> dialectPatterns = buildDialectPatterns(ProcessDialectRegistry.getDialects());\n \n-    private DataAssociationFactory() {\n-        // do nothing\n-    }\n+    private DataAssociationFactory() {}\n \n     public static DataAssociation readDataOutputAssociation(Node xmlNode, Map<String, String> dataOutputs) {\n-\n         NodeList nodeList = xmlNode.getChildNodes();\n         String source = null;\n         String target = null;\n         Transformation transformation = null;\n         List<Assignment> assignment = new ArrayList<>();\n-        for(int i = 0; i < nodeList.getLength(); i++) {\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n             Node subNode = nodeList.item(i);\n-            switch(subNode.getNodeName()) {\n-                case \"sourceRef\":\n-                {\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n                     source = subNode.getTextContent();\n-                    if(!dataOutputs.containsKey(source)) {\n-                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes().getNamedItem(\"id\"), source);\n+                    String mapped = dataOutputs.get(source);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), source);\n+                    }\n+                    else {\n+                        source = mapped;\n                     }\n-                    // indirection\n-                    source = dataOutputs.get(source);\n                     break;\n-                }\n-                case \"targetRef\":\n-                {\n+                case TARGET_REF:\n                     target = subNode.getTextContent();\n                     break;\n-                }\n-                case \"transformation\":\n-                {\n+                case TRANSFORMATION:\n                     String lang = subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR).getNodeValue();\n                     String expression = subNode.getTextContent();\n                     transformation = new Transformation(lang, expression, source);\n                     break;\n-                }\n-                case \"assignment\":\n-                {\n-                    assignment.add(readAssignment(subNode));\n+                case ASSIGNMENT:\n+                    assignment.add(readAssignment(subNode, dataOutputs));\n                     break;\n-                }\n             }\n-\n         }\n         return new DataAssociation(source, target, assignment, transformation);\n     }\n-    \n+\n+    public static void readDataInputAssociation(Node xmlNode,\n+                                                Map<String, String> dataInputs,\n+                                                BiPredicate<String, List<Assignment>> isLegacy,\n+                                                Consumer<DataAssociation> addAssigment,\n+                                                BiConsumer<String, Object> legacyAssigment) {", "originalCommit": "ff06d823ef343533eb7d6db57b1a3facbd1316cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE3MDY3OA==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543170678", "bodyText": "class member transformerRegistry is now no longer used - please remove\n\n  \n    \n      jbpm/jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/BusinessRuleTaskHandler.java\n    \n    \n         Line 37\n      in\n      ff06d82\n    \n    \n    \n    \n\n        \n          \n           private DataTransformerRegistry transformerRegistry = DataTransformerRegistry.get();", "author": "afalhambra", "createdAt": "2020-12-15T09:13:00Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/BusinessRuleTaskHandler.java", "diffHunk": "@@ -99,87 +94,18 @@ public void writeNode(Node node, StringBuilder xmlDump, int metaDataType) {\n \t\tendNode(\"businessRuleTask\", xmlDump);\n \t}\n \t\n-\tprotected void readDataInputAssociation(org.w3c.dom.Node xmlNode, RuleSetNode ruleSetNode, Map<String, String> dataInputs) {", "originalCommit": "ff06d823ef343533eb7d6db57b1a3facbd1316cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE3MTE5OA==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543171198", "bodyText": "class member transformerRegistry is now no longer used - please remove\n\n  \n    \n      jbpm/jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/TaskHandler.java\n    \n    \n         Line 41\n      in\n      ff06d82\n    \n    \n    \n    \n\n        \n          \n           private DataTransformerRegistry transformerRegistry = DataTransformerRegistry.get();", "author": "afalhambra", "createdAt": "2020-12-15T09:13:49Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/TaskHandler.java", "diffHunk": "@@ -150,86 +145,12 @@ protected void readIoSpecification(org.w3c.dom.Node xmlNode, Map<String, String>\n     }\n \n     protected void readDataInputAssociation(org.w3c.dom.Node xmlNode, WorkItemNode workItemNode, Map<String, String> dataInputs) {", "originalCommit": "ff06d823ef343533eb7d6db57b1a3facbd1316cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE3Mjg5Ng==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543172896", "bodyText": "I can't find this check in new change. Not sure if this is still applicable. Let me know.", "author": "afalhambra", "createdAt": "2020-12-15T09:16:15Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/BusinessRuleTaskHandler.java", "diffHunk": "@@ -99,87 +94,18 @@ public void writeNode(Node node, StringBuilder xmlDump, int metaDataType) {\n \t\tendNode(\"businessRuleTask\", xmlDump);\n \t}\n \t\n-\tprotected void readDataInputAssociation(org.w3c.dom.Node xmlNode, RuleSetNode ruleSetNode, Map<String, String> dataInputs) {\n-        // sourceRef\n-        org.w3c.dom.Node subNode = xmlNode.getFirstChild();\n-        if (\"sourceRef\".equals(subNode.getNodeName())) {\n-            String source = subNode.getTextContent();\n-            // targetRef\n-            subNode = subNode.getNextSibling();\n-            String target = subNode.getTextContent();\n-            // transformation\n-    \t\tTransformation transformation = null;\n-    \t\tsubNode = subNode.getNextSibling();\n-    \t\tif (subNode != null && \"transformation\".equals(subNode.getNodeName())) {\n-    \t\t\tString lang = subNode.getAttributes().getNamedItem(\"language\").getNodeValue();\n-    \t\t\tString expression = subNode.getTextContent();\n-    \t\t\t\n-    \t\t\tDataTransformer transformer = transformerRegistry.find(lang);\n-    \t\t\tif (transformer == null) {\n-    \t\t\t\tthrow new IllegalArgumentException(\"No transformer registered for language \" + lang);\n-    \t\t\t}    \t\t\t", "originalCommit": "ff06d823ef343533eb7d6db57b1a3facbd1316cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ2MjgxMQ==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543462811", "bodyText": "This was checking if the language of the transformation is registered. This is done later when the transformation is applied, so I bet it it not needed and according to test results is not, so I vote for removing", "author": "fjtirado", "createdAt": "2020-12-15T15:50:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE3Mjg5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE3MzIxNw==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543173217", "bodyText": "I can't find this check in new change. Not sure if this is still applicable. Let me know.", "author": "afalhambra", "createdAt": "2020-12-15T09:16:43Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/BusinessRuleTaskHandler.java", "diffHunk": "@@ -99,87 +94,18 @@ public void writeNode(Node node, StringBuilder xmlDump, int metaDataType) {\n \t\tendNode(\"businessRuleTask\", xmlDump);\n \t}\n \t\n-\tprotected void readDataInputAssociation(org.w3c.dom.Node xmlNode, RuleSetNode ruleSetNode, Map<String, String> dataInputs) {\n-        // sourceRef\n-        org.w3c.dom.Node subNode = xmlNode.getFirstChild();\n-        if (\"sourceRef\".equals(subNode.getNodeName())) {\n-            String source = subNode.getTextContent();\n-            // targetRef\n-            subNode = subNode.getNextSibling();\n-            String target = subNode.getTextContent();\n-            // transformation\n-    \t\tTransformation transformation = null;\n-    \t\tsubNode = subNode.getNextSibling();\n-    \t\tif (subNode != null && \"transformation\".equals(subNode.getNodeName())) {\n-    \t\t\tString lang = subNode.getAttributes().getNamedItem(\"language\").getNodeValue();\n-    \t\t\tString expression = subNode.getTextContent();\n-    \t\t\t\n-    \t\t\tDataTransformer transformer = transformerRegistry.find(lang);\n-    \t\t\tif (transformer == null) {\n-    \t\t\t\tthrow new IllegalArgumentException(\"No transformer registered for language \" + lang);\n-    \t\t\t}    \t\t\t\n-    \t\t\ttransformation = new Transformation(lang, expression);    \t\t\t\n-    \t\t\t\n-    \t\t\tsubNode = subNode.getNextSibling();\n-    \t\t}\n-    \t\t// assignments  \n-            ruleSetNode.addInAssociation(new DataAssociation(source, dataInputs.get(target), DataAssociationFactory\n-                    .readAssignments(subNode), transformation));\n-        } else {\n-            // targetRef\n-            String to = subNode.getTextContent();\n-            // assignment\n-            subNode = subNode.getNextSibling();\n-            if (subNode != null) {\n-                org.w3c.dom.Node subSubNode = subNode.getFirstChild();\n-                NodeList nl = subSubNode.getChildNodes();\n-                if (nl.getLength() > 1) {\n-                    // not supported ?\n-                    ruleSetNode.setParameter(dataInputs.get(to), subSubNode.getTextContent());\n-                    return;\n-                } else if (nl.getLength() == 0) {\n-                    return;\n-                }\n-                Object result = null;\n-                Object from = nl.item(0);\n-                if (from instanceof Text) {\n-                    String text = ((Text) from).getTextContent();\n-                    if (text.startsWith(\"\\\"\") && text.endsWith(\"\\\"\")) {\n-                        result = text.substring(1, text.length() -1);\n-                    } else {\n-                        result = text;\n-                    }\n-                } else {\n-                    result = nl.item(0);\n-                }\n-                ruleSetNode.setParameter(dataInputs.get(to), result);\n-            }\n-        }\n+    protected void readDataInputAssociation(org.w3c.dom.Node xmlNode,\n+                                            RuleSetNode ruleSetNode,\n+                                            Map<String, String> dataInputs) {\n+        DataAssociationFactory.readDataInputAssociation(xmlNode, dataInputs, (s, a) -> s == null,\n+                ruleSetNode::addInAssociation,\n+                ruleSetNode::setParameter);\n     }\n-    \n-    protected void readDataOutputAssociation(org.w3c.dom.Node xmlNode, RuleSetNode ruleSetNode, Map<String, String> dataOutputs) {\n-        // sourceRef\n-        org.w3c.dom.Node subNode = xmlNode.getFirstChild();\n-        String source = subNode.getTextContent();\n-        // targetRef\n-        subNode = subNode.getNextSibling();\n-        String target = subNode.getTextContent();\n-        // transformation\n- \t\tTransformation transformation = null;\n- \t\tsubNode = subNode.getNextSibling();\n- \t\tif (subNode != null && \"transformation\".equals(subNode.getNodeName())) {\n- \t\t\tString lang = subNode.getAttributes().getNamedItem(\"language\").getNodeValue();\n- \t\t\tString expression = subNode.getTextContent();\n- \t\t\tDataTransformer transformer = transformerRegistry.find(lang);\n- \t\t\tif (transformer == null) {\n- \t\t\t\tthrow new IllegalArgumentException(\"No transformer registered for language \" + lang);\n- \t\t\t}    \t\t\t", "originalCommit": "ff06d823ef343533eb7d6db57b1a3facbd1316cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ2Mjg5Ng==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543462896", "bodyText": "This was checking if the language of the transformation is registered. This is done later when the transformation is applied, so I bet it it not needed and according to test results is not.", "author": "fjtirado", "createdAt": "2020-12-15T15:50:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE3MzIxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE3MzUyNw==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543173527", "bodyText": "Same comment regarding this check", "author": "afalhambra", "createdAt": "2020-12-15T09:17:10Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/TaskHandler.java", "diffHunk": "@@ -150,86 +145,12 @@ protected void readIoSpecification(org.w3c.dom.Node xmlNode, Map<String, String>\n     }\n \n     protected void readDataInputAssociation(org.w3c.dom.Node xmlNode, WorkItemNode workItemNode, Map<String, String> dataInputs) {\n-\t\t// sourceRef\n-\t\torg.w3c.dom.Node subNode = xmlNode.getFirstChild();\n-\t\tif (\"sourceRef\".equals(subNode.getNodeName())) {\n-    \t\tString source = subNode.getTextContent();    \t\t\n-    \t\t// targetRef\n-    \t\tsubNode = subNode.getNextSibling();\n-    \t\tString target = subNode.getTextContent();\n-    \t\t// transformation\n-    \t\tTransformation transformation = null;\n-    \t\tsubNode = subNode.getNextSibling();\n-    \t\tif (subNode != null && \"transformation\".equals(subNode.getNodeName())) {\n-    \t\t\tString lang = subNode.getAttributes().getNamedItem(\"language\").getNodeValue();\n-    \t\t\tString expression = subNode.getTextContent();\n-    \t\t\t\n-    \t\t\tDataTransformer transformer = transformerRegistry.find(lang);\n-    \t\t\tif (transformer == null) {\n-    \t\t\t\tthrow new IllegalArgumentException(\"No transformer registered for language \" + lang);\n-    \t\t\t}    \t\t\t", "originalCommit": "ff06d823ef343533eb7d6db57b1a3facbd1316cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ2MzE1MQ==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543463151", "bodyText": "This was checking if the language of the transformation is registered. This is done later when the transformation is applied, so I bet it it not needed and according to test results is not.", "author": "fjtirado", "createdAt": "2020-12-15T15:50:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE3MzUyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE3MzgyMw==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543173823", "bodyText": "same comment with regards to this check", "author": "afalhambra", "createdAt": "2020-12-15T09:17:33Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/TaskHandler.java", "diffHunk": "@@ -150,86 +145,12 @@ protected void readIoSpecification(org.w3c.dom.Node xmlNode, Map<String, String>\n     }\n \n     protected void readDataInputAssociation(org.w3c.dom.Node xmlNode, WorkItemNode workItemNode, Map<String, String> dataInputs) {\n-\t\t// sourceRef\n-\t\torg.w3c.dom.Node subNode = xmlNode.getFirstChild();\n-\t\tif (\"sourceRef\".equals(subNode.getNodeName())) {\n-    \t\tString source = subNode.getTextContent();    \t\t\n-    \t\t// targetRef\n-    \t\tsubNode = subNode.getNextSibling();\n-    \t\tString target = subNode.getTextContent();\n-    \t\t// transformation\n-    \t\tTransformation transformation = null;\n-    \t\tsubNode = subNode.getNextSibling();\n-    \t\tif (subNode != null && \"transformation\".equals(subNode.getNodeName())) {\n-    \t\t\tString lang = subNode.getAttributes().getNamedItem(\"language\").getNodeValue();\n-    \t\t\tString expression = subNode.getTextContent();\n-    \t\t\t\n-    \t\t\tDataTransformer transformer = transformerRegistry.find(lang);\n-    \t\t\tif (transformer == null) {\n-    \t\t\t\tthrow new IllegalArgumentException(\"No transformer registered for language \" + lang);\n-    \t\t\t}    \t\t\t\n-    \t\t\ttransformation = new Transformation(lang, expression);\n-//    \t\t\ttransformation.setCompiledExpression(transformer.compile(expression));\n-    \t\t\t\n-    \t\t\tsubNode = subNode.getNextSibling();\n-    \t\t}\n-            workItemNode.addInAssociation(new DataAssociation(source, dataInputs.get(target), DataAssociationFactory\n-                    .readAssignments(subNode), transformation));\n-\t\t} else {\n-\t\t\t// targetRef\n-\t\t\tString to = subNode.getTextContent();\n-\t\t\t// assignment\n-\t\t\tsubNode = subNode.getNextSibling();\n-\t\t\tif (subNode != null) {\n-\t    \t\torg.w3c.dom.Node subSubNode = subNode.getFirstChild();\n-\t    \t\tNodeList nl = subSubNode.getChildNodes();\n-\t    \t\tif (nl.getLength() > 1) {\n-\t    \t\t    // not supported ?\n-\t    \t\t    workItemNode.getWork().setParameter(dataInputs.get(to), subSubNode.getTextContent());\n-\t    \t\t    return;\n-\t    \t\t} else if (nl.getLength() == 0) {\n-\t    \t\t    return;\n-\t    \t\t}\n-\t    \t\tObject result = null;\n-\t    \t\tObject from = nl.item(0);\n-\t    \t\tif (from instanceof Text) {\n-\t    \t\t    String text = ((Text) from).getTextContent();\n-\t    \t\t    if (text.startsWith(\"\\\"\") && text.endsWith(\"\\\"\")) {\n-\t                    result = text.substring(1, text.length() -1);\n-\t    \t\t    } else {\n-\t    \t\t        result = text;\n-\t    \t\t    }\n-\t\t\t\t} else {\n-\t\t\t\t    result = nl.item(0);\n-\t\t\t\t}\n-\t    \t\tworkItemNode.getWork().setParameter(dataInputs.get(to), result);\n-\t\t\t}\n-\t\t}\n+        DataAssociationFactory.readDataInputAssociation(xmlNode, dataInputs, DataAssociationFactory::isLegacyAssigment,\n+                workItemNode::addInAssociation, (name, value) -> workItemNode.getWork().setParameter(name, value));\n     }\n-    \n+\n     protected void readDataOutputAssociation(org.w3c.dom.Node xmlNode, WorkItemNode workItemNode, Map<String, String> dataOutputs) {\n-\t\t// sourceRef\n-\t\torg.w3c.dom.Node subNode = xmlNode.getFirstChild();\n-\t\tString source = subNode.getTextContent();\n-\t\t// targetRef\n-\t\tsubNode = subNode.getNextSibling();\n-\t\tString target = subNode.getTextContent();\n-\t\t// transformation\n-\t\tTransformation transformation = null;\n-\t\tsubNode = subNode.getNextSibling();\n-\t\tif (subNode != null && \"transformation\".equals(subNode.getNodeName())) {\n-\t\t\tString lang = subNode.getAttributes().getNamedItem(\"language\").getNodeValue();\n-\t\t\tString expression = subNode.getTextContent();\n-\t\t\tDataTransformer transformer = transformerRegistry.find(lang);\n-\t\t\tif (transformer == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"No transformer registered for language \" + lang);\n-\t\t\t}    \t\t\t", "originalCommit": "ff06d823ef343533eb7d6db57b1a3facbd1316cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ2MzUzNg==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543463536", "bodyText": "This was checking if the language of the transformation is registered. This is done later when the transformation is applied, so I bet it it not needed and according to test results is not.", "author": "fjtirado", "createdAt": "2020-12-15T15:51:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE3MzgyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE5MTE1NQ==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543191155", "bodyText": "full package name is not needed\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        org.w3c.dom.Node fromNode = assignmentNode.getFirstChild();\n          \n          \n            \n                        Node fromNode = assignmentNode.getFirstChild();", "author": "afalhambra", "createdAt": "2020-12-15T09:41:31Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/elements/DataAssociationFactory.java", "diffHunk": "@@ -33,84 +37,181 @@\n import org.slf4j.LoggerFactory;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n+import org.w3c.dom.Text;\n \n public final class DataAssociationFactory {\n-    \n+\n     protected static final String LANG_EXPRESSION_ATTR = \"language\";\n     protected static final String DEFAULT_DIALECT = \"XPath\";\n     protected static final String USE_DEFINITION_LANGUAGE_PROPERTY = \"org.kie.jbpm.bpmn2.useDefinitionLanguage\";\n+    private static final String SOURCE_REF = \"sourceRef\";\n+    private static final String TARGET_REF = \"targetRef\";\n+    private static final String TRANSFORMATION = \"transformation\";\n+    private static final String ASSIGNMENT = \"assignment\";\n     private static final Logger logger = LoggerFactory.getLogger(DataAssociationFactory.class);\n-    \n     private static Map<String, Pattern> dialectPatterns = buildDialectPatterns(ProcessDialectRegistry.getDialects());\n \n-    private DataAssociationFactory() {\n-        // do nothing\n-    }\n+    private DataAssociationFactory() {}\n \n     public static DataAssociation readDataOutputAssociation(Node xmlNode, Map<String, String> dataOutputs) {\n-\n         NodeList nodeList = xmlNode.getChildNodes();\n         String source = null;\n         String target = null;\n         Transformation transformation = null;\n         List<Assignment> assignment = new ArrayList<>();\n-        for(int i = 0; i < nodeList.getLength(); i++) {\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n             Node subNode = nodeList.item(i);\n-            switch(subNode.getNodeName()) {\n-                case \"sourceRef\":\n-                {\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n                     source = subNode.getTextContent();\n-                    if(!dataOutputs.containsKey(source)) {\n-                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes().getNamedItem(\"id\"), source);\n+                    String mapped = dataOutputs.get(source);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), source);\n+                    }\n+                    else {\n+                        source = mapped;\n                     }\n-                    // indirection\n-                    source = dataOutputs.get(source);\n                     break;\n-                }\n-                case \"targetRef\":\n-                {\n+                case TARGET_REF:\n                     target = subNode.getTextContent();\n                     break;\n-                }\n-                case \"transformation\":\n-                {\n+                case TRANSFORMATION:\n                     String lang = subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR).getNodeValue();\n                     String expression = subNode.getTextContent();\n                     transformation = new Transformation(lang, expression, source);\n                     break;\n-                }\n-                case \"assignment\":\n-                {\n-                    assignment.add(readAssignment(subNode));\n+                case ASSIGNMENT:\n+                    assignment.add(readAssignment(subNode, dataOutputs));\n                     break;\n-                }\n             }\n-\n         }\n         return new DataAssociation(source, target, assignment, transformation);\n     }\n-    \n+\n+    public static void readDataInputAssociation(Node xmlNode,\n+                                                Map<String, String> dataInputs,\n+                                                BiPredicate<String, List<Assignment>> isLegacy,\n+                                                Consumer<DataAssociation> addAssigment,\n+                                                BiConsumer<String, Object> legacyAssigment) {\n+        NodeList nodeList = xmlNode.getChildNodes();\n+        String source = null;\n+        String target = null;\n+        Transformation transformation = null;\n+        List<Assignment> assignments = new ArrayList<>();\n+        Node assignmentNode = null;\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n+            Node subNode = nodeList.item(i);\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n+                    source = subNode.getTextContent();\n+                    break;\n+                case TARGET_REF:\n+                    target = subNode.getTextContent();\n+                    String mapped = dataInputs.get(target);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data inputs in this node {} does not contain target {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), target);\n+                    }\n+                    else {\n+                        target = mapped;\n+                    }\n+                    break;\n+                case TRANSFORMATION:\n+                    transformation = new Transformation(subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR)\n+                            .getNodeValue(), subNode.getTextContent());\n+                    break;\n+                case ASSIGNMENT:\n+                    assignmentNode = subNode;\n+                    assignments.add(readAssignment(subNode, dataInputs));\n+                    break;\n+            }\n+        }\n+        if (isLegacy.test(source, assignments))\n+        {\n+            Object value = getValue(assignmentNode);\n+            if (value != null) {\n+                legacyAssigment.accept(target, value);\n+            }\n+        } else {\n+            addAssigment.accept(new DataAssociation(source, target, assignments, transformation));\n+        }\n+    }\n+\n+    public static boolean isLegacyAssigment(String source, List<Assignment> assignments) {\n+        return source == null && assignments.isEmpty() || source == null && !assignments.isEmpty() && assignments.get(0)\n+                .getDialect().equals(DEFAULT_DIALECT);\n+    }\n+\n+    private static Object getValue(Node assignmentNode) {\n+        Object value = null;\n+        if (assignmentNode != null) {\n+            org.w3c.dom.Node fromNode = assignmentNode.getFirstChild();", "originalCommit": "ff06d823ef343533eb7d6db57b1a3facbd1316cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE5MjkzNA==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543192934", "bodyText": "method name is quite generic, though argument name is not. So seems a little weird. Maybe you can rename either assignmentNode or method name getValue - but it's only just a suggestion, up to you. Same is applicable to fromNode variable in this method.", "author": "afalhambra", "createdAt": "2020-12-15T09:44:00Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/elements/DataAssociationFactory.java", "diffHunk": "@@ -33,84 +37,181 @@\n import org.slf4j.LoggerFactory;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n+import org.w3c.dom.Text;\n \n public final class DataAssociationFactory {\n-    \n+\n     protected static final String LANG_EXPRESSION_ATTR = \"language\";\n     protected static final String DEFAULT_DIALECT = \"XPath\";\n     protected static final String USE_DEFINITION_LANGUAGE_PROPERTY = \"org.kie.jbpm.bpmn2.useDefinitionLanguage\";\n+    private static final String SOURCE_REF = \"sourceRef\";\n+    private static final String TARGET_REF = \"targetRef\";\n+    private static final String TRANSFORMATION = \"transformation\";\n+    private static final String ASSIGNMENT = \"assignment\";\n     private static final Logger logger = LoggerFactory.getLogger(DataAssociationFactory.class);\n-    \n     private static Map<String, Pattern> dialectPatterns = buildDialectPatterns(ProcessDialectRegistry.getDialects());\n \n-    private DataAssociationFactory() {\n-        // do nothing\n-    }\n+    private DataAssociationFactory() {}\n \n     public static DataAssociation readDataOutputAssociation(Node xmlNode, Map<String, String> dataOutputs) {\n-\n         NodeList nodeList = xmlNode.getChildNodes();\n         String source = null;\n         String target = null;\n         Transformation transformation = null;\n         List<Assignment> assignment = new ArrayList<>();\n-        for(int i = 0; i < nodeList.getLength(); i++) {\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n             Node subNode = nodeList.item(i);\n-            switch(subNode.getNodeName()) {\n-                case \"sourceRef\":\n-                {\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n                     source = subNode.getTextContent();\n-                    if(!dataOutputs.containsKey(source)) {\n-                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes().getNamedItem(\"id\"), source);\n+                    String mapped = dataOutputs.get(source);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), source);\n+                    }\n+                    else {\n+                        source = mapped;\n                     }\n-                    // indirection\n-                    source = dataOutputs.get(source);\n                     break;\n-                }\n-                case \"targetRef\":\n-                {\n+                case TARGET_REF:\n                     target = subNode.getTextContent();\n                     break;\n-                }\n-                case \"transformation\":\n-                {\n+                case TRANSFORMATION:\n                     String lang = subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR).getNodeValue();\n                     String expression = subNode.getTextContent();\n                     transformation = new Transformation(lang, expression, source);\n                     break;\n-                }\n-                case \"assignment\":\n-                {\n-                    assignment.add(readAssignment(subNode));\n+                case ASSIGNMENT:\n+                    assignment.add(readAssignment(subNode, dataOutputs));\n                     break;\n-                }\n             }\n-\n         }\n         return new DataAssociation(source, target, assignment, transformation);\n     }\n-    \n+\n+    public static void readDataInputAssociation(Node xmlNode,\n+                                                Map<String, String> dataInputs,\n+                                                BiPredicate<String, List<Assignment>> isLegacy,\n+                                                Consumer<DataAssociation> addAssigment,\n+                                                BiConsumer<String, Object> legacyAssigment) {\n+        NodeList nodeList = xmlNode.getChildNodes();\n+        String source = null;\n+        String target = null;\n+        Transformation transformation = null;\n+        List<Assignment> assignments = new ArrayList<>();\n+        Node assignmentNode = null;\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n+            Node subNode = nodeList.item(i);\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n+                    source = subNode.getTextContent();\n+                    break;\n+                case TARGET_REF:\n+                    target = subNode.getTextContent();\n+                    String mapped = dataInputs.get(target);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data inputs in this node {} does not contain target {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), target);\n+                    }\n+                    else {\n+                        target = mapped;\n+                    }\n+                    break;\n+                case TRANSFORMATION:\n+                    transformation = new Transformation(subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR)\n+                            .getNodeValue(), subNode.getTextContent());\n+                    break;\n+                case ASSIGNMENT:\n+                    assignmentNode = subNode;\n+                    assignments.add(readAssignment(subNode, dataInputs));\n+                    break;\n+            }\n+        }\n+        if (isLegacy.test(source, assignments))\n+        {\n+            Object value = getValue(assignmentNode);\n+            if (value != null) {\n+                legacyAssigment.accept(target, value);\n+            }\n+        } else {\n+            addAssigment.accept(new DataAssociation(source, target, assignments, transformation));\n+        }\n+    }\n+\n+    public static boolean isLegacyAssigment(String source, List<Assignment> assignments) {\n+        return source == null && assignments.isEmpty() || source == null && !assignments.isEmpty() && assignments.get(0)\n+                .getDialect().equals(DEFAULT_DIALECT);\n+    }\n+\n+    private static Object getValue(Node assignmentNode) {", "originalCommit": "ff06d823ef343533eb7d6db57b1a3facbd1316cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ2NTgzNg==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543465836", "bodyText": "Thats the point, the generic name is specialized by the particular attribute, thas valid for a private method if we want to keep name short without losing information", "author": "fjtirado", "createdAt": "2020-12-15T15:53:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzE5MjkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIwNTQ3MQ==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543205471", "bodyText": "it can be either dataOutputs or dataInputs\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public static Assignment readAssignment(Node xmlNode, Map<String, String> dataOutputs) {\n          \n          \n            \n                public static Assignment readAssignment(Node xmlNode, Map<String, String> data) {", "author": "afalhambra", "createdAt": "2020-12-15T10:01:05Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/elements/DataAssociationFactory.java", "diffHunk": "@@ -33,84 +37,181 @@\n import org.slf4j.LoggerFactory;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n+import org.w3c.dom.Text;\n \n public final class DataAssociationFactory {\n-    \n+\n     protected static final String LANG_EXPRESSION_ATTR = \"language\";\n     protected static final String DEFAULT_DIALECT = \"XPath\";\n     protected static final String USE_DEFINITION_LANGUAGE_PROPERTY = \"org.kie.jbpm.bpmn2.useDefinitionLanguage\";\n+    private static final String SOURCE_REF = \"sourceRef\";\n+    private static final String TARGET_REF = \"targetRef\";\n+    private static final String TRANSFORMATION = \"transformation\";\n+    private static final String ASSIGNMENT = \"assignment\";\n     private static final Logger logger = LoggerFactory.getLogger(DataAssociationFactory.class);\n-    \n     private static Map<String, Pattern> dialectPatterns = buildDialectPatterns(ProcessDialectRegistry.getDialects());\n \n-    private DataAssociationFactory() {\n-        // do nothing\n-    }\n+    private DataAssociationFactory() {}\n \n     public static DataAssociation readDataOutputAssociation(Node xmlNode, Map<String, String> dataOutputs) {\n-\n         NodeList nodeList = xmlNode.getChildNodes();\n         String source = null;\n         String target = null;\n         Transformation transformation = null;\n         List<Assignment> assignment = new ArrayList<>();\n-        for(int i = 0; i < nodeList.getLength(); i++) {\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n             Node subNode = nodeList.item(i);\n-            switch(subNode.getNodeName()) {\n-                case \"sourceRef\":\n-                {\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n                     source = subNode.getTextContent();\n-                    if(!dataOutputs.containsKey(source)) {\n-                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes().getNamedItem(\"id\"), source);\n+                    String mapped = dataOutputs.get(source);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), source);\n+                    }\n+                    else {\n+                        source = mapped;\n                     }\n-                    // indirection\n-                    source = dataOutputs.get(source);\n                     break;\n-                }\n-                case \"targetRef\":\n-                {\n+                case TARGET_REF:\n                     target = subNode.getTextContent();\n                     break;\n-                }\n-                case \"transformation\":\n-                {\n+                case TRANSFORMATION:\n                     String lang = subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR).getNodeValue();\n                     String expression = subNode.getTextContent();\n                     transformation = new Transformation(lang, expression, source);\n                     break;\n-                }\n-                case \"assignment\":\n-                {\n-                    assignment.add(readAssignment(subNode));\n+                case ASSIGNMENT:\n+                    assignment.add(readAssignment(subNode, dataOutputs));\n                     break;\n-                }\n             }\n-\n         }\n         return new DataAssociation(source, target, assignment, transformation);\n     }\n-    \n+\n+    public static void readDataInputAssociation(Node xmlNode,\n+                                                Map<String, String> dataInputs,\n+                                                BiPredicate<String, List<Assignment>> isLegacy,\n+                                                Consumer<DataAssociation> addAssigment,\n+                                                BiConsumer<String, Object> legacyAssigment) {\n+        NodeList nodeList = xmlNode.getChildNodes();\n+        String source = null;\n+        String target = null;\n+        Transformation transformation = null;\n+        List<Assignment> assignments = new ArrayList<>();\n+        Node assignmentNode = null;\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n+            Node subNode = nodeList.item(i);\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n+                    source = subNode.getTextContent();\n+                    break;\n+                case TARGET_REF:\n+                    target = subNode.getTextContent();\n+                    String mapped = dataInputs.get(target);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data inputs in this node {} does not contain target {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), target);\n+                    }\n+                    else {\n+                        target = mapped;\n+                    }\n+                    break;\n+                case TRANSFORMATION:\n+                    transformation = new Transformation(subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR)\n+                            .getNodeValue(), subNode.getTextContent());\n+                    break;\n+                case ASSIGNMENT:\n+                    assignmentNode = subNode;\n+                    assignments.add(readAssignment(subNode, dataInputs));\n+                    break;\n+            }\n+        }\n+        if (isLegacy.test(source, assignments))\n+        {\n+            Object value = getValue(assignmentNode);\n+            if (value != null) {\n+                legacyAssigment.accept(target, value);\n+            }\n+        } else {\n+            addAssigment.accept(new DataAssociation(source, target, assignments, transformation));\n+        }\n+    }\n+\n+    public static boolean isLegacyAssigment(String source, List<Assignment> assignments) {\n+        return source == null && assignments.isEmpty() || source == null && !assignments.isEmpty() && assignments.get(0)\n+                .getDialect().equals(DEFAULT_DIALECT);\n+    }\n+\n+    private static Object getValue(Node assignmentNode) {\n+        Object value = null;\n+        if (assignmentNode != null) {\n+            org.w3c.dom.Node fromNode = assignmentNode.getFirstChild();\n+            NodeList nl = fromNode.getChildNodes();\n+            if (nl.getLength() > 1) {\n+                value = fromNode.getNodeValue();\n+            } else if (nl.getLength() == 1) {\n+                value = nl.item(0);\n+                if (value instanceof Text) {\n+                    String text = ((Text) value).getTextContent();\n+                    value = text.startsWith(\"\\\"\") && text.endsWith(\"\\\"\") ? text.substring(1, text.length() - 1)\n+                            : text;\n+                }\n+            }\n+        }\n+        return value;\n+    }\n+\n+\n     public static List<Assignment> readAssignments(Node subNode) {\n         List<Assignment> assignments = new LinkedList<>();\n         while (subNode != null) {\n-            assignments.add(DataAssociationFactory.readAssignment(subNode));\n+            assignments.add(readAssignment(subNode));\n             subNode = subNode.getNextSibling();\n         }\n         return assignments;\n     }\n \n     public static Assignment readAssignment(Node xmlNode) {\n-        Node from = xmlNode.getFirstChild();\n-        if (from == null) {\n-            throw new IllegalArgumentException(\"missing from for assignment\");\n+        return readAssignment(xmlNode, Collections.emptyMap());\n+    }\n+\n+    public static Assignment readAssignment(Node xmlNode, Map<String, String> dataOutputs) {", "originalCommit": "ff06d823ef343533eb7d6db57b1a3facbd1316cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIwNjk2Mw==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543206963", "bodyText": "same - it can be either output or input\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private static String resolveContent(Node node, Map<String, String> dataOutputs) {\n          \n          \n            \n                private static String resolveContent(Node node, Map<String, String> data) {", "author": "afalhambra", "createdAt": "2020-12-15T10:03:06Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/elements/DataAssociationFactory.java", "diffHunk": "@@ -33,84 +37,181 @@\n import org.slf4j.LoggerFactory;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n+import org.w3c.dom.Text;\n \n public final class DataAssociationFactory {\n-    \n+\n     protected static final String LANG_EXPRESSION_ATTR = \"language\";\n     protected static final String DEFAULT_DIALECT = \"XPath\";\n     protected static final String USE_DEFINITION_LANGUAGE_PROPERTY = \"org.kie.jbpm.bpmn2.useDefinitionLanguage\";\n+    private static final String SOURCE_REF = \"sourceRef\";\n+    private static final String TARGET_REF = \"targetRef\";\n+    private static final String TRANSFORMATION = \"transformation\";\n+    private static final String ASSIGNMENT = \"assignment\";\n     private static final Logger logger = LoggerFactory.getLogger(DataAssociationFactory.class);\n-    \n     private static Map<String, Pattern> dialectPatterns = buildDialectPatterns(ProcessDialectRegistry.getDialects());\n \n-    private DataAssociationFactory() {\n-        // do nothing\n-    }\n+    private DataAssociationFactory() {}\n \n     public static DataAssociation readDataOutputAssociation(Node xmlNode, Map<String, String> dataOutputs) {\n-\n         NodeList nodeList = xmlNode.getChildNodes();\n         String source = null;\n         String target = null;\n         Transformation transformation = null;\n         List<Assignment> assignment = new ArrayList<>();\n-        for(int i = 0; i < nodeList.getLength(); i++) {\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n             Node subNode = nodeList.item(i);\n-            switch(subNode.getNodeName()) {\n-                case \"sourceRef\":\n-                {\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n                     source = subNode.getTextContent();\n-                    if(!dataOutputs.containsKey(source)) {\n-                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes().getNamedItem(\"id\"), source);\n+                    String mapped = dataOutputs.get(source);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), source);\n+                    }\n+                    else {\n+                        source = mapped;\n                     }\n-                    // indirection\n-                    source = dataOutputs.get(source);\n                     break;\n-                }\n-                case \"targetRef\":\n-                {\n+                case TARGET_REF:\n                     target = subNode.getTextContent();\n                     break;\n-                }\n-                case \"transformation\":\n-                {\n+                case TRANSFORMATION:\n                     String lang = subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR).getNodeValue();\n                     String expression = subNode.getTextContent();\n                     transformation = new Transformation(lang, expression, source);\n                     break;\n-                }\n-                case \"assignment\":\n-                {\n-                    assignment.add(readAssignment(subNode));\n+                case ASSIGNMENT:\n+                    assignment.add(readAssignment(subNode, dataOutputs));\n                     break;\n-                }\n             }\n-\n         }\n         return new DataAssociation(source, target, assignment, transformation);\n     }\n-    \n+\n+    public static void readDataInputAssociation(Node xmlNode,\n+                                                Map<String, String> dataInputs,\n+                                                BiPredicate<String, List<Assignment>> isLegacy,\n+                                                Consumer<DataAssociation> addAssigment,\n+                                                BiConsumer<String, Object> legacyAssigment) {\n+        NodeList nodeList = xmlNode.getChildNodes();\n+        String source = null;\n+        String target = null;\n+        Transformation transformation = null;\n+        List<Assignment> assignments = new ArrayList<>();\n+        Node assignmentNode = null;\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n+            Node subNode = nodeList.item(i);\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n+                    source = subNode.getTextContent();\n+                    break;\n+                case TARGET_REF:\n+                    target = subNode.getTextContent();\n+                    String mapped = dataInputs.get(target);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data inputs in this node {} does not contain target {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), target);\n+                    }\n+                    else {\n+                        target = mapped;\n+                    }\n+                    break;\n+                case TRANSFORMATION:\n+                    transformation = new Transformation(subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR)\n+                            .getNodeValue(), subNode.getTextContent());\n+                    break;\n+                case ASSIGNMENT:\n+                    assignmentNode = subNode;\n+                    assignments.add(readAssignment(subNode, dataInputs));\n+                    break;\n+            }\n+        }\n+        if (isLegacy.test(source, assignments))\n+        {\n+            Object value = getValue(assignmentNode);\n+            if (value != null) {\n+                legacyAssigment.accept(target, value);\n+            }\n+        } else {\n+            addAssigment.accept(new DataAssociation(source, target, assignments, transformation));\n+        }\n+    }\n+\n+    public static boolean isLegacyAssigment(String source, List<Assignment> assignments) {\n+        return source == null && assignments.isEmpty() || source == null && !assignments.isEmpty() && assignments.get(0)\n+                .getDialect().equals(DEFAULT_DIALECT);\n+    }\n+\n+    private static Object getValue(Node assignmentNode) {\n+        Object value = null;\n+        if (assignmentNode != null) {\n+            org.w3c.dom.Node fromNode = assignmentNode.getFirstChild();\n+            NodeList nl = fromNode.getChildNodes();\n+            if (nl.getLength() > 1) {\n+                value = fromNode.getNodeValue();\n+            } else if (nl.getLength() == 1) {\n+                value = nl.item(0);\n+                if (value instanceof Text) {\n+                    String text = ((Text) value).getTextContent();\n+                    value = text.startsWith(\"\\\"\") && text.endsWith(\"\\\"\") ? text.substring(1, text.length() - 1)\n+                            : text;\n+                }\n+            }\n+        }\n+        return value;\n+    }\n+\n+\n     public static List<Assignment> readAssignments(Node subNode) {\n         List<Assignment> assignments = new LinkedList<>();\n         while (subNode != null) {\n-            assignments.add(DataAssociationFactory.readAssignment(subNode));\n+            assignments.add(readAssignment(subNode));\n             subNode = subNode.getNextSibling();\n         }\n         return assignments;\n     }\n \n     public static Assignment readAssignment(Node xmlNode) {\n-        Node from = xmlNode.getFirstChild();\n-        if (from == null) {\n-            throw new IllegalArgumentException(\"missing from for assignment\");\n+        return readAssignment(xmlNode, Collections.emptyMap());\n+    }\n+\n+    public static Assignment readAssignment(Node xmlNode, Map<String, String> dataOutputs) {\n+\n+        NodeList nodeList = xmlNode.getChildNodes();\n+        Node from = null;\n+        Node to = null;\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n+            Node subNode = nodeList.item(i);\n+            switch (subNode.getNodeName()) {\n+                case \"from\":\n+                    from = subNode;\n+                    break;\n+                case \"to\":\n+                    to = subNode;\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unrecognized node name \" + subNode.getNodeName() +\n+                                                       \" in assigment \" + xmlNode.getAttributes().getNamedItem(\"id\")\n+                                                               .getNodeValue());\n+            }\n         }\n-        Node to = from.getNextSibling();\n-        if (to == null) {\n-            throw new IllegalArgumentException(\"missing to for assignment\");\n+        if (to == null && from == null) {\n+            throw new IllegalArgumentException(\" Assigment \" + xmlNode.getAttributes().getNamedItem(\"id\")\n+                    .getNodeValue() + \" should have at least from or to subnode\");\n         }\n-        return new Assignment(getDialect(xmlNode, from, to), from.getTextContent(), to.getTextContent());\n+        return new Assignment(getDialect(xmlNode, from, to), resolveContent(from, dataOutputs), resolveContent(to,\n+                dataOutputs));\n     }\n \n+    private static String resolveContent(Node node, Map<String, String> dataOutputs) {", "originalCommit": "ff06d823ef343533eb7d6db57b1a3facbd1316cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIxNTkxMw==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543215913", "bodyText": "typo\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        throw new IllegalArgumentException(\" Assigment \" + xmlNode.getAttributes().getNamedItem(\"id\")\n          \n          \n            \n                        throw new IllegalArgumentException(\" Assignment \" + xmlNode.getAttributes().getNamedItem(\"id\")", "author": "afalhambra", "createdAt": "2020-12-15T10:15:41Z", "path": "jbpm-bpmn2/src/main/java/org/jbpm/bpmn2/xml/elements/DataAssociationFactory.java", "diffHunk": "@@ -33,84 +37,181 @@\n import org.slf4j.LoggerFactory;\n import org.w3c.dom.Node;\n import org.w3c.dom.NodeList;\n+import org.w3c.dom.Text;\n \n public final class DataAssociationFactory {\n-    \n+\n     protected static final String LANG_EXPRESSION_ATTR = \"language\";\n     protected static final String DEFAULT_DIALECT = \"XPath\";\n     protected static final String USE_DEFINITION_LANGUAGE_PROPERTY = \"org.kie.jbpm.bpmn2.useDefinitionLanguage\";\n+    private static final String SOURCE_REF = \"sourceRef\";\n+    private static final String TARGET_REF = \"targetRef\";\n+    private static final String TRANSFORMATION = \"transformation\";\n+    private static final String ASSIGNMENT = \"assignment\";\n     private static final Logger logger = LoggerFactory.getLogger(DataAssociationFactory.class);\n-    \n     private static Map<String, Pattern> dialectPatterns = buildDialectPatterns(ProcessDialectRegistry.getDialects());\n \n-    private DataAssociationFactory() {\n-        // do nothing\n-    }\n+    private DataAssociationFactory() {}\n \n     public static DataAssociation readDataOutputAssociation(Node xmlNode, Map<String, String> dataOutputs) {\n-\n         NodeList nodeList = xmlNode.getChildNodes();\n         String source = null;\n         String target = null;\n         Transformation transformation = null;\n         List<Assignment> assignment = new ArrayList<>();\n-        for(int i = 0; i < nodeList.getLength(); i++) {\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n             Node subNode = nodeList.item(i);\n-            switch(subNode.getNodeName()) {\n-                case \"sourceRef\":\n-                {\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n                     source = subNode.getTextContent();\n-                    if(!dataOutputs.containsKey(source)) {\n-                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes().getNamedItem(\"id\"), source);\n+                    String mapped = dataOutputs.get(source);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data outputs in this node {} does not contain source {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), source);\n+                    }\n+                    else {\n+                        source = mapped;\n                     }\n-                    // indirection\n-                    source = dataOutputs.get(source);\n                     break;\n-                }\n-                case \"targetRef\":\n-                {\n+                case TARGET_REF:\n                     target = subNode.getTextContent();\n                     break;\n-                }\n-                case \"transformation\":\n-                {\n+                case TRANSFORMATION:\n                     String lang = subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR).getNodeValue();\n                     String expression = subNode.getTextContent();\n                     transformation = new Transformation(lang, expression, source);\n                     break;\n-                }\n-                case \"assignment\":\n-                {\n-                    assignment.add(readAssignment(subNode));\n+                case ASSIGNMENT:\n+                    assignment.add(readAssignment(subNode, dataOutputs));\n                     break;\n-                }\n             }\n-\n         }\n         return new DataAssociation(source, target, assignment, transformation);\n     }\n-    \n+\n+    public static void readDataInputAssociation(Node xmlNode,\n+                                                Map<String, String> dataInputs,\n+                                                BiPredicate<String, List<Assignment>> isLegacy,\n+                                                Consumer<DataAssociation> addAssigment,\n+                                                BiConsumer<String, Object> legacyAssigment) {\n+        NodeList nodeList = xmlNode.getChildNodes();\n+        String source = null;\n+        String target = null;\n+        Transformation transformation = null;\n+        List<Assignment> assignments = new ArrayList<>();\n+        Node assignmentNode = null;\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n+            Node subNode = nodeList.item(i);\n+            switch (subNode.getNodeName()) {\n+                case SOURCE_REF:\n+                    source = subNode.getTextContent();\n+                    break;\n+                case TARGET_REF:\n+                    target = subNode.getTextContent();\n+                    String mapped = dataInputs.get(target);\n+                    if (mapped == null) {\n+                        logger.warn(\"Data inputs in this node {} does not contain target {}\", xmlNode.getAttributes()\n+                                .getNamedItem(\"id\"), target);\n+                    }\n+                    else {\n+                        target = mapped;\n+                    }\n+                    break;\n+                case TRANSFORMATION:\n+                    transformation = new Transformation(subNode.getAttributes().getNamedItem(LANG_EXPRESSION_ATTR)\n+                            .getNodeValue(), subNode.getTextContent());\n+                    break;\n+                case ASSIGNMENT:\n+                    assignmentNode = subNode;\n+                    assignments.add(readAssignment(subNode, dataInputs));\n+                    break;\n+            }\n+        }\n+        if (isLegacy.test(source, assignments))\n+        {\n+            Object value = getValue(assignmentNode);\n+            if (value != null) {\n+                legacyAssigment.accept(target, value);\n+            }\n+        } else {\n+            addAssigment.accept(new DataAssociation(source, target, assignments, transformation));\n+        }\n+    }\n+\n+    public static boolean isLegacyAssigment(String source, List<Assignment> assignments) {\n+        return source == null && assignments.isEmpty() || source == null && !assignments.isEmpty() && assignments.get(0)\n+                .getDialect().equals(DEFAULT_DIALECT);\n+    }\n+\n+    private static Object getValue(Node assignmentNode) {\n+        Object value = null;\n+        if (assignmentNode != null) {\n+            org.w3c.dom.Node fromNode = assignmentNode.getFirstChild();\n+            NodeList nl = fromNode.getChildNodes();\n+            if (nl.getLength() > 1) {\n+                value = fromNode.getNodeValue();\n+            } else if (nl.getLength() == 1) {\n+                value = nl.item(0);\n+                if (value instanceof Text) {\n+                    String text = ((Text) value).getTextContent();\n+                    value = text.startsWith(\"\\\"\") && text.endsWith(\"\\\"\") ? text.substring(1, text.length() - 1)\n+                            : text;\n+                }\n+            }\n+        }\n+        return value;\n+    }\n+\n+\n     public static List<Assignment> readAssignments(Node subNode) {\n         List<Assignment> assignments = new LinkedList<>();\n         while (subNode != null) {\n-            assignments.add(DataAssociationFactory.readAssignment(subNode));\n+            assignments.add(readAssignment(subNode));\n             subNode = subNode.getNextSibling();\n         }\n         return assignments;\n     }\n \n     public static Assignment readAssignment(Node xmlNode) {\n-        Node from = xmlNode.getFirstChild();\n-        if (from == null) {\n-            throw new IllegalArgumentException(\"missing from for assignment\");\n+        return readAssignment(xmlNode, Collections.emptyMap());\n+    }\n+\n+    public static Assignment readAssignment(Node xmlNode, Map<String, String> dataOutputs) {\n+\n+        NodeList nodeList = xmlNode.getChildNodes();\n+        Node from = null;\n+        Node to = null;\n+        for (int i = 0; i < nodeList.getLength(); i++) {\n+            Node subNode = nodeList.item(i);\n+            switch (subNode.getNodeName()) {\n+                case \"from\":\n+                    from = subNode;\n+                    break;\n+                case \"to\":\n+                    to = subNode;\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unrecognized node name \" + subNode.getNodeName() +\n+                                                       \" in assigment \" + xmlNode.getAttributes().getNamedItem(\"id\")\n+                                                               .getNodeValue());\n+            }\n         }\n-        Node to = from.getNextSibling();\n-        if (to == null) {\n-            throw new IllegalArgumentException(\"missing to for assignment\");\n+        if (to == null && from == null) {\n+            throw new IllegalArgumentException(\" Assigment \" + xmlNode.getAttributes().getNamedItem(\"id\")", "originalCommit": "ff06d823ef343533eb7d6db57b1a3facbd1316cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzIyOTMyNA==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543229324", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void testDataInputAssociationsWithPojoWithoutsource() throws Exception {\n          \n          \n            \n                public void testDataInputAssociationsWithPojoWithoutSource() throws Exception {", "author": "afalhambra", "createdAt": "2020-12-15T10:34:37Z", "path": "jbpm-bpmn2/src/test/java/org/jbpm/bpmn2/DataTest.java", "diffHunk": "@@ -329,6 +329,11 @@ public void testDataInputAssociationsWithPojoPartial() throws Exception {\n         internalTestDataInputAssociationWithPojo(\"BPMN2-DataInputAssociations-Pojo.bpmn2\");\n     }\n \n+    @Test\n+    public void testDataInputAssociationsWithPojoWithoutsource() throws Exception {", "originalCommit": "ff06d823ef343533eb7d6db57b1a3facbd1316cc", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI3MjEwOA==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543272108", "bodyText": "I think it would be good to add another similar test case to check dataInputsAssociations work when only sourceRef is defined.\nSame for dataOutputAssociations.", "author": "afalhambra", "createdAt": "2020-12-15T11:41:21Z", "path": "jbpm-bpmn2/src/test/java/org/jbpm/bpmn2/DataTest.java", "diffHunk": "@@ -329,6 +329,11 @@ public void testDataInputAssociationsWithPojoPartial() throws Exception {\n         internalTestDataInputAssociationWithPojo(\"BPMN2-DataInputAssociations-Pojo.bpmn2\");\n     }\n \n+    @Test\n+    public void testDataInputAssociationsWithPojoWithoutsource() throws Exception {", "originalCommit": "ff06d823ef343533eb7d6db57b1a3facbd1316cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzQ2MDk2NQ==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r543460965", "bodyText": "These scenarios are covered by testDataInputAssociationsStunnerWithPojo and testDataOutputAssociationsStunnerWithPojo", "author": "fjtirado", "createdAt": "2020-12-15T15:47:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI3MjEwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDA2OTE0Mg==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r544069142", "bodyText": "I can't find these scenarios in the test cases you mention.\n\nFor dataInputAssociations I don't see any association having only sourceRef element. All of them are coming with targetRef\nFor dataOutputAssociations I don't see any association having only targetRef element. There is only one with sourceRef only.\n\nhttps://github.com/kiegroup/jbpm/blob/f805920c306411ae6385357cc81e0045af272a0b/jbpm-bpmn2/src/test/resources/BPMN2-DataInputAssociationStunner.bpmn2\nhttps://github.com/kiegroup/jbpm/blob/f805920c306411ae6385357cc81e0045af272a0b/jbpm-bpmn2/src/test/resources/BPMN2-DataOutputAssociationStunner.bpmn2", "author": "afalhambra", "createdAt": "2020-12-16T07:24:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI3MjEwOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDEzNzM0NA==", "url": "https://github.com/kiegroup/jbpm/pull/1822#discussion_r544137344", "bodyText": "Ok, I misunderstood your comment. You are right, there are not, but it is ok, since stunner only supports the ones that are tested. Think that this change \"breaks\" BPMN assumption that both sourceRef and targetRef are going to be present for assignments and we are just covering the cases where stunner does not obey that rule", "author": "fjtirado", "createdAt": "2020-12-16T09:20:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzI3MjEwOA=="}], "type": "inlineReview"}, {"oid": "f805920c306411ae6385357cc81e0045af272a0b", "url": "https://github.com/kiegroup/jbpm/commit/f805920c306411ae6385357cc81e0045af272a0b", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior", "committedDate": "2020-12-15T15:51:40Z", "type": "commit"}, {"oid": "f805920c306411ae6385357cc81e0045af272a0b", "url": "https://github.com/kiegroup/jbpm/commit/f805920c306411ae6385357cc81e0045af272a0b", "message": "[JBPM-9507] Align DataAssociation behavior with kogito\n\nChanges in parser and evaluator to align with non standard behavior", "committedDate": "2020-12-15T15:51:40Z", "type": "forcePushed"}]}