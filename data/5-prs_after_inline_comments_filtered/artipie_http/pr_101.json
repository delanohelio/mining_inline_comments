{"pr_number": 101, "pr_title": "#100 - Added RsHasHeaders matcher", "pr_createdAt": "2020-03-30T12:06:04Z", "pr_url": "https://github.com/artipie/http/pull/101", "timeline": [{"oid": "ae3a8f13f29ed29f4953dd0e5c2c7b2a893e6b8d", "url": "https://github.com/artipie/http/commit/ae3a8f13f29ed29f4953dd0e5c2c7b2a893e6b8d", "message": "#100 - Added RsHasHeaders matcher", "committedDate": "2020-03-30T12:04:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxNzE2MQ==", "url": "https://github.com/artipie/http/pull/101#discussion_r400417161", "bodyText": "@olegmoz Why test RsHasBody?", "author": "Vatavuk", "createdAt": "2020-03-30T18:50:09Z", "path": "src/test/java/com/artipie/http/hm/RsHasHeadersTest.java", "diffHunk": "@@ -0,0 +1,101 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+package com.artipie.http.hm;\n+\n+import com.artipie.http.Response;\n+import com.artipie.http.rs.RsStatus;\n+import com.artipie.http.rs.RsWithBody;\n+import com.artipie.http.rs.RsWithHeaders;\n+import com.artipie.http.rs.RsWithStatus;\n+import io.reactivex.Flowable;\n+import java.nio.ByteBuffer;\n+import java.util.Arrays;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.cactoos.map.MapEntry;\n+import org.hamcrest.MatcherAssert;\n+import org.hamcrest.Matchers;\n+import org.hamcrest.core.IsEqual;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.ValueSource;\n+\n+/**\n+ * Tests for {@link RsHasHeaders}.\n+ *\n+ * @since 0.8\n+ */\n+class RsHasHeadersTest {\n+\n+    @Test\n+    void shouldMatchHeaders() {\n+        final MapEntry<String, String> type = new MapEntry<>(\n+            \"Content-Type\", \"application/json\"\n+        );\n+        final MapEntry<String, String> length = new MapEntry<>(\n+            \"Content-Length\", \"123\"\n+        );\n+        final Response response = new RsWithHeaders(\n+            new RsWithStatus(RsStatus.OK),\n+            Arrays.asList(type, length)\n+        );\n+        final RsHasHeaders matcher = new RsHasHeaders(Arrays.asList(length, type));\n+        MatcherAssert.assertThat(\n+            matcher.matches(response),\n+            new IsEqual<>(true)\n+        );\n+    }\n+\n+    @Test\n+    void shouldNotMatchNotMatchingHeaders() {\n+        final Response response = new RsWithStatus(RsStatus.OK);\n+        final RsHasHeaders matcher = new RsHasHeaders(\n+            Matchers.containsInAnyOrder(new MapEntry<>(\"X-My-Header\", \"value\"))\n+        );\n+        MatcherAssert.assertThat(\n+            matcher.matches(response),\n+            new IsEqual<>(false)\n+        );\n+    }\n+\n+    @ParameterizedTest\n+    @ValueSource(strings = {\"data\", \"chunk1,chunk2\"})\n+    void shouldMatchResponseTwice(final String chunks) {\n+        final String[] elements = chunks.split(\",\");\n+        final byte[] data = String.join(\"\", elements).getBytes();\n+        final Response response = new RsWithBody(\n+            Flowable.fromIterable(\n+                Stream.of(elements)\n+                    .map(String::getBytes)\n+                    .map(ByteBuffer::wrap)\n+                    .collect(Collectors.toList())\n+            )\n+        );\n+        new RsHasBody(data).matches(response);\n+        MatcherAssert.assertThat(\n+            new RsHasBody(data).matches(response),", "originalCommit": "ae3a8f13f29ed29f4953dd0e5c2c7b2a893e6b8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcyODUwMw==", "url": "https://github.com/artipie/http/pull/101#discussion_r400728503", "bodyText": "@Vatavuk oops, forgot to delete this piece, thanks!", "author": "olegmoz", "createdAt": "2020-03-31T08:22:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQxNzE2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQzNzIzMg==", "url": "https://github.com/artipie/http/pull/101#discussion_r400437232", "bodyText": "@olegmoz This wont work for every implementation of Entry interface because it depends on equals implementation.\nThis test fails:\nMap.Entry<String, String> hdr = new Map.Entry<String, String>() {\n\n            @Override\n            public String getKey() {\n                return \"h\";\n            }\n\n            @Override\n            public String getValue() {\n                return \"v\";\n            }\n\n            @Override\n            public String setValue(final String value) {\n                throw new UnsupportedOperationException(\"#setValue()\");\n            }\n        };\n        Map.Entry<String, String> hdr2 = new Map.Entry<String, String>() {\n\n            @Override\n            public String getKey() {\n                return \"h\";\n            }\n\n            @Override\n            public String getValue() {\n                return \"v\";\n            }\n\n            @Override\n            public String setValue(final String value) {\n                throw new UnsupportedOperationException(\"#setValue()\");\n            }\n        };\n\n        final Response response = new RsWithHeaders(\n            new RsWithStatus(RsStatus.OK),\n            Arrays.asList(hdr)\n        );\n        final RsHasHeaders matcher = new RsHasHeaders(\n            Arrays.asList(hdr2));\n        MatcherAssert.assertThat(\n            matcher.matches(response),\n            new IsEqual<>(true)\n        );", "author": "Vatavuk", "createdAt": "2020-03-30T19:22:39Z", "path": "src/main/java/com/artipie/http/hm/RsHasHeaders.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+\n+package com.artipie.http.hm;\n+\n+import com.artipie.http.Connection;\n+import com.artipie.http.Response;\n+import com.artipie.http.rs.RsStatus;\n+import com.google.common.collect.ImmutableList;\n+import java.nio.ByteBuffer;\n+import java.util.Collection;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n+import org.hamcrest.Matchers;\n+import org.hamcrest.TypeSafeMatcher;\n+import org.hamcrest.core.IsEqual;\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * Matcher to verify response headers.\n+ *\n+ * @since 0.8\n+ */\n+public final class RsHasHeaders extends TypeSafeMatcher<Response> {\n+\n+    /**\n+     * Headers matcher.\n+     */\n+    private final Matcher<Iterable<? extends Entry<String, String>>> headers;\n+\n+    /**\n+     * Ctor.\n+     *\n+     * @param headers Code to match\n+     */\n+    public RsHasHeaders(final Collection<Entry<String, String>> headers) {\n+        this(\n+            Matchers.containsInAnyOrder(\n+                headers.stream().map(IsEqual::new).collect(Collectors.toList())", "originalCommit": "ae3a8f13f29ed29f4953dd0e5c2c7b2a893e6b8d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDcyOTgxMA==", "url": "https://github.com/artipie/http/pull/101#discussion_r400729810", "bodyText": "@Vatavuk good point, makes me sad that we use Map.Entry here and not some special class for Header. I think I'll just copy both actual and expected entries to comparable Map.Entry instances and add a test for it", "author": "olegmoz", "createdAt": "2020-03-31T08:24:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQzNzIzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDQzODM5Mw==", "url": "https://github.com/artipie/http/pull/101#discussion_r400438393", "bodyText": "@olegmoz 0.8", "author": "Vatavuk", "createdAt": "2020-03-30T19:24:37Z", "path": "src/main/java/com/artipie/http/hm/RsHasHeaders.java", "diffHunk": "@@ -0,0 +1,124 @@\n+/*\n+ * MIT License\n+ *\n+ * Copyright (c) 2020 Artipie\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a copy\n+ * of this software and associated documentation files (the \"Software\"), to deal\n+ * in the Software without restriction, including without limitation the rights\n+ * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+ * copies of the Software, and to permit persons to whom the Software is\n+ * furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included in all\n+ * copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+ * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n+ * SOFTWARE.\n+ */\n+\n+package com.artipie.http.hm;\n+\n+import com.artipie.http.Connection;\n+import com.artipie.http.Response;\n+import com.artipie.http.rs.RsStatus;\n+import com.google.common.collect.ImmutableList;\n+import java.nio.ByteBuffer;\n+import java.util.Collection;\n+import java.util.Map.Entry;\n+import java.util.concurrent.CompletableFuture;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+import org.hamcrest.Description;\n+import org.hamcrest.Matcher;\n+import org.hamcrest.Matchers;\n+import org.hamcrest.TypeSafeMatcher;\n+import org.hamcrest.core.IsEqual;\n+import org.reactivestreams.Publisher;\n+\n+/**\n+ * Matcher to verify response headers.\n+ *\n+ * @since 0.8\n+ */\n+public final class RsHasHeaders extends TypeSafeMatcher<Response> {\n+\n+    /**\n+     * Headers matcher.\n+     */\n+    private final Matcher<Iterable<? extends Entry<String, String>>> headers;\n+\n+    /**\n+     * Ctor.\n+     *\n+     * @param headers Code to match\n+     */\n+    public RsHasHeaders(final Collection<Entry<String, String>> headers) {\n+        this(\n+            Matchers.containsInAnyOrder(\n+                headers.stream().map(IsEqual::new).collect(Collectors.toList())\n+            )\n+        );\n+    }\n+\n+    /**\n+     * Ctor.\n+     *\n+     * @param headers Code matcher\n+     */\n+    public RsHasHeaders(final Matcher<Iterable<? extends Entry<String, String>>> headers) {\n+        this.headers = headers;\n+    }\n+\n+    @Override\n+    public void describeTo(final Description description) {\n+        description.appendDescriptionOf(this.headers);\n+    }\n+\n+    @Override\n+    public boolean matchesSafely(final Response item) {\n+        final AtomicReference<Iterable<Entry<String, String>>> out = new AtomicReference<>();\n+        item.send(new FakeConnection(out)).toCompletableFuture().join();\n+        return this.headers.matches(out.get());\n+    }\n+\n+    /**\n+     * Fake connection.\n+     *\n+     * @since 0.1", "originalCommit": "ae3a8f13f29ed29f4953dd0e5c2c7b2a893e6b8d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6dcc677248b684af822f1c33f9041cc7dd3db011", "url": "https://github.com/artipie/http/commit/6dcc677248b684af822f1c33f9041cc7dd3db011", "message": "#100 - Changes by review", "committedDate": "2020-03-31T08:43:08Z", "type": "commit"}]}