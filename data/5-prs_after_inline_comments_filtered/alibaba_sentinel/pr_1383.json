{"pr_number": 1383, "pr_title": "Refactor SpiLoader and enhance its SPI functions", "pr_createdAt": "2020-04-05T14:47:20Z", "pr_url": "https://github.com/alibaba/Sentinel/pull/1383", "timeline": [{"oid": "47953f0e9f817fdeb4c42acc1f6edd4557aecff9", "url": "https://github.com/alibaba/Sentinel/commit/47953f0e9f817fdeb4c42acc1f6edd4557aecff9", "message": "Refactor SpiLoader and enhance its SPI functions.", "committedDate": "2020-04-28T15:24:45Z", "type": "commit"}, {"oid": "800eb762cdb5228a619604f12c30e3cc0d51f897", "url": "https://github.com/alibaba/Sentinel/commit/800eb762cdb5228a619604f12c30e3cc0d51f897", "message": "Add isDefault in @Spi, add loadDefaultInstance and improve loadFirstInstanceOrDefault method, improve test cases", "committedDate": "2020-04-28T15:24:45Z", "type": "commit"}, {"oid": "d5cc3e766932e6a17b94a4731d21ac21e934bec0", "url": "https://github.com/alibaba/Sentinel/commit/d5cc3e766932e6a17b94a4731d21ac21e934bec0", "message": "Fix no SPI file scene and test cases", "committedDate": "2020-04-28T15:24:45Z", "type": "commit"}, {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e", "url": "https://github.com/alibaba/Sentinel/commit/d3926c4a78df8f1f8e9c2721968450d4f222f59e", "message": "Improve init and fix comment", "committedDate": "2020-04-28T15:24:45Z", "type": "commit"}, {"oid": "d3926c4a78df8f1f8e9c2721968450d4f222f59e", "url": "https://github.com/alibaba/Sentinel/commit/d3926c4a78df8f1f8e9c2721968450d4f222f59e", "message": "Improve init and fix comment", "committedDate": "2020-04-28T15:24:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0OTcwMA==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465449700", "bodyText": "Use constant?", "author": "jasonjoo2010", "createdAt": "2020-08-05T03:26:58Z", "path": "sentinel-adapter/sentinel-api-gateway-adapter-common/src/main/java/com/alibaba/csp/sentinel/adapter/gateway/common/slot/GatewayFlowSlot.java", "diffHunk": "@@ -27,13 +27,13 @@\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowException;\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParamFlowRule;\n import com.alibaba.csp.sentinel.slots.block.flow.param.ParameterMetricStorage;\n-import com.alibaba.csp.sentinel.spi.SpiOrder;\n+import com.alibaba.csp.sentinel.spi.Spi;\n \n /**\n  * @author Eric Zhao\n  * @since 1.6.1\n  */\n-@SpiOrder(-4000)\n+@Spi(order = -4000)", "originalCommit": "d3926c4a78df8f1f8e9c2721968450d4f222f59e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1MDI1MQ==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465450251", "bodyText": "And some slots are stateless while others are stateful. Maybe isSingleton should be specified obviously.", "author": "jasonjoo2010", "createdAt": "2020-08-05T03:29:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0OTcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5NjAzMw==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465796033", "bodyText": "I'm a little confused here,  not very sure and use -4000 temporarily.\nThere are some constants of slot order definitions In Constants class of sentinel-core module:\n/**\n* Order of default processor slots\n*/\npublic static final int ORDER_NODE_SELECTOR_SLOT = -10000;\npublic static final int ORDER_CLUSTER_BUILDER_SLOT = -9000;\npublic static final int ORDER_LOG_SLOT = -8000;\npublic static final int ORDER_STATISTIC_SLOT = -7000;\npublic static final int ORDER_AUTHORITY_SLOT = -6000;\npublic static final int ORDER_SYSTEM_SLOT = -5000;\n// order of GatewayFlowSlot -4000\n// order of ParamFlowSlot   -3000\npublic static final int ORDER_FLOW_SLOT = -2000;\npublic static final int ORDER_DEGRADE_SLOT = -1000;\nIf use constant, which is better?\n\n\n\npublic static final int ORDER_GATEWAY_FLOW_SLOT = -4000;\npublic static final int ORDER_PARAM_FLOW_SLOT = -3000;\n\n@Spi(order = Constants.ORDER_SYSTEM_SLOT)\npublic class GatewayFlowSlot {\n\n\n\nNo constant for ORDER_GATEWAY_FLOW_SLOT, ORDER_PARAM_FLOW_SLOT\n@Spi(order = Constants.ORDER_SYSTEM_SLOT + 1000)\npublic class GatewayFlowSlot {", "author": "cdfive", "createdAt": "2020-08-05T15:05:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0OTcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwMzkyMg==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465803922", "bodyText": "Constants.ORDER_SYSTEM_SLOT\n\nYeah whatever you want.\nIf you want to make it reference-able just replace it with a constant in gateway package;\nIf you want to express some kinds of relationship with existing slots just use relative calculation to existed constants;\nIf you insist on pure definition just leave it unchanged.", "author": "jasonjoo2010", "createdAt": "2020-08-05T15:16:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0OTcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxOTM4Mw==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465819383", "bodyText": "These three ways speak my heart. I've been struggling with this for a long time.\nNow I think the third way is not very good. Maybe one or two is better.\nFor a selection difficulty person, could you please help to make a good choice?", "author": "cdfive", "createdAt": "2020-08-05T15:39:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0OTcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgyMTkyMA==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465821920", "bodyText": "These three ways speak my heart. I've been struggling with this for a long time.\nNow I think the third way is not very good. Maybe one or two is better.\nFor a selection difficulty person, could you please help to make a good choice?\n\nGo write a random test and make result confirmed.", "author": "jasonjoo2010", "createdAt": "2020-08-05T15:42:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0OTcwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU0NDc3OQ==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r467544779", "bodyText": "Got it! Using the first way, since it expresses the order of all default slot of sentinel clearly. Maybe the second way is a good choice for user custom slot.", "author": "cdfive", "createdAt": "2020-08-09T06:45:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ0OTcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NTA2MQ==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465455061", "bodyText": "I didn't look backward carefully. What is the reason that we don't use ServiceProvider but load them manually here?", "author": "jasonjoo2010", "createdAt": "2020-08-05T03:48:11Z", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();", "originalCommit": "d3926c4a78df8f1f8e9c2721968450d4f222f59e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwMDI4OA==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465800288", "bodyText": "JDK's ServiceProvider is convenient to use, since we here want to enrich its functions, support our custom Spi annotation, so load them manually. This implementation refers to ServerProvider.", "author": "cdfive", "createdAt": "2020-08-05T15:11:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NTA2MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwNDk3Ng==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465804976", "bodyText": "JDK's ServiceProvider is convenient to use, since we here want to enrich its functions, support our custom Spi annotation, so load them manually. This implementation refers to ServerProvider.\n\nOk i get it. It's ok then.", "author": "jasonjoo2010", "createdAt": "2020-08-05T15:18:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NTA2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NTc3OQ==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465455779", "bodyText": "private or package default scope is suggested.", "author": "jasonjoo2010", "createdAt": "2020-08-05T03:51:08Z", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {", "originalCommit": "d3926c4a78df8f1f8e9c2721968450d4f222f59e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc4NjU5Nw==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465786597", "bodyText": "This method is intend to provide another method to create SpiLoader instance, and inside it just call of method.\nHow about remove it? Maybe of method is enough.\nJust now, I found that in JDK's Optional, apache commons's Pair, they only have of method to create its instance.", "author": "cdfive", "createdAt": "2020-08-05T14:53:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NTc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTc5ODg3Mg==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465798872", "bodyText": "Yeah i think this scaffold class should be shorter so just don't be limited by legacy design.", "author": "jasonjoo2010", "createdAt": "2020-08-05T15:10:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NTc3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY3MzY3NQ==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r491673675", "bodyText": "This unused method has been removed, only of method is remained.", "author": "cdfive", "createdAt": "2020-09-20T09:40:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NTc3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NzA5MQ==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465457091", "bodyText": "Maybe we should also sychronize it?", "author": "jasonjoo2010", "createdAt": "2020-08-05T03:56:39Z", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();", "originalCommit": "d3926c4a78df8f1f8e9c2721968450d4f222f59e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NzI0OQ==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465457249", "bodyText": "And it looks more like resetAndClear()", "author": "jasonjoo2010", "createdAt": "2020-08-05T03:57:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NzA5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2ODU1Ng==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465468556", "bodyText": "Are reset*() only used in unit tests?\nIf so i suggest to comment them obviously and make them package scope is better.", "author": "jasonjoo2010", "createdAt": "2020-08-05T04:42:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NzA5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY3MzgwOA==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r491673808", "bodyText": "They have been improved, please check.", "author": "cdfive", "createdAt": "2020-09-20T09:42:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NzA5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NzQyNA==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465457424", "bodyText": "serviceClass or providerClass is better?", "author": "jasonjoo2010", "createdAt": "2020-08-05T03:58:00Z", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;", "originalCommit": "d3926c4a78df8f1f8e9c2721968450d4f222f59e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NzYxMQ==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465457611", "bodyText": "Useless?", "author": "jasonjoo2010", "createdAt": "2020-08-05T03:58:53Z", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {", "originalCommit": "d3926c4a78df8f1f8e9c2721968450d4f222f59e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxNTMxOA==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465815318", "bodyText": "Yes, it's not used, I'll remove it.", "author": "cdfive", "createdAt": "2020-08-05T15:33:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1NzYxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ1ODU5Ng==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465458596", "bodyText": "Better to be List load() for short access?\nAnd why we don't invoke internal load()(which is called init() maybe better) in constructor? For lazy load?\nBut i don't think it's a good design here if we target it as lazy load.  Because it has nearly 100% possibility to be initialized.", "author": "jasonjoo2010", "createdAt": "2020-08-05T04:02:49Z", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();", "originalCommit": "d3926c4a78df8f1f8e9c2721968450d4f222f59e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2MTEyMQ==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465461121", "bodyText": "Just a suggestion and not a forced request.\nLogics is a bit long. Is it necessary storing both unordered and ordered list? If no only sorted is necessary i think(Maybe loadSorted should be new load()).", "author": "jasonjoo2010", "createdAt": "2020-08-05T04:13:14Z", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {", "originalCommit": "d3926c4a78df8f1f8e9c2721968450d4f222f59e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzcwMzU5Mw==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r547703593", "bodyText": "And this one? Remain it this time?", "author": "jasonjoo2010", "createdAt": "2020-12-23T06:26:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2MTEyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2MjMxOQ==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465462319", "bodyText": "I suggest to cache all the meta data. For example you can use a more complicated structure in your pre-stored class list.", "author": "jasonjoo2010", "createdAt": "2020-08-05T04:18:23Z", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);", "originalCommit": "d3926c4a78df8f1f8e9c2721968450d4f222f59e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NzcwMTU4Mw==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r547701583", "bodyText": "Will it remain for future improvement? About meta caching.", "author": "jasonjoo2010", "createdAt": "2020-12-23T06:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2MjMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NDQ4Ng==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465464486", "bodyText": "Maybe len=0 should also be added here for more obvious.", "author": "jasonjoo2010", "createdAt": "2020-08-05T04:26:55Z", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {\n+                        instance = service.cast(clazz.newInstance());\n+                        singletonMap.put(clazz.getName(), instance);\n+                    }\n+                }\n+            } else {\n+                instance = service.cast(clazz.newInstance());\n+            }\n+        } catch (Throwable e) {\n+            fail(clazz.getName() + \" could not be instantiated\");\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * Close all resources\n+     *\n+     * @param closeables {@link Closeable} resources\n+     */\n+    private void closeResources(Closeable... closeables) {\n+        if (closeables == null) {", "originalCommit": "d3926c4a78df8f1f8e9c2721968450d4f222f59e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzU0NDgwOQ==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r467544809", "bodyText": "Good idea, it has been added.", "author": "cdfive", "createdAt": "2020-08-09T06:46:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NDQ4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY3MjI0OA==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r491672248", "bodyText": "It has been improved.", "author": "cdfive", "createdAt": "2020-09-20T09:22:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NDQ4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NDYxMg==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465464612", "bodyText": "SPI -> resource ?", "author": "jasonjoo2010", "createdAt": "2020-08-05T04:27:26Z", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {\n+                        instance = service.cast(clazz.newInstance());\n+                        singletonMap.put(clazz.getName(), instance);\n+                    }\n+                }\n+            } else {\n+                instance = service.cast(clazz.newInstance());\n+            }\n+        } catch (Throwable e) {\n+            fail(clazz.getName() + \" could not be instantiated\");\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * Close all resources\n+     *\n+     * @param closeables {@link Closeable} resources\n+     */\n+    private void closeResources(Closeable... closeables) {\n+        if (closeables == null) {\n+            return;\n+        }\n+\n+        for (Closeable closeable : closeables) {\n+            try {\n+                closeable.close();\n+            } catch (Exception e) {\n+                fail(\"error closing SPI file\", e);", "originalCommit": "d3926c4a78df8f1f8e9c2721968450d4f222f59e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwNDY5NQ==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465804695", "bodyText": "Oh, SPI file may be confusing.\nMay I use error closing SPI resource file or error closing SPI configuration file?\nThis method is used for close InputStream and BufferedReader after reading and parsing configuration file.\nSPI is used to emphasize the operation.", "author": "cdfive", "createdAt": "2020-08-05T15:17:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NDYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMzU5MQ==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465813591", "bodyText": "Oh, SPI file may be confusing.\nMay I use error closing SPI resource file or error closing SPI configuration file?\nThis method is used for close InputStream and BufferedReader after reading and parsing configuration file.\nSPI is used to emphasize the operation.\n\nFile is already a kind of resource. Or do you mean you implemented a method which is more like closeFiles(...)?", "author": "jasonjoo2010", "createdAt": "2020-08-05T15:30:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NDYxMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY3Mjg3NA==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r491672874", "bodyText": "The prompt message changed to error closing SPI configuration file, and the exception in closeResources method seems rarely happen.", "author": "cdfive", "createdAt": "2020-09-20T09:29:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NDYxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NTE0MA==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465465140", "bodyText": "Maybe logAndRaise or other names can be accurately.", "author": "jasonjoo2010", "createdAt": "2020-08-05T04:29:39Z", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset all fields of current SpiLoader instance\n+     */\n+    public synchronized void reset() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI filename=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI filename=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {\n+                        instance = service.cast(clazz.newInstance());\n+                        singletonMap.put(clazz.getName(), instance);\n+                    }\n+                }\n+            } else {\n+                instance = service.cast(clazz.newInstance());\n+            }\n+        } catch (Throwable e) {\n+            fail(clazz.getName() + \" could not be instantiated\");\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * Close all resources\n+     *\n+     * @param closeables {@link Closeable} resources\n+     */\n+    private void closeResources(Closeable... closeables) {\n+        if (closeables == null) {\n+            return;\n+        }\n+\n+        for (Closeable closeable : closeables) {\n+            try {\n+                closeable.close();\n+            } catch (Exception e) {\n+                fail(\"error closing SPI file\", e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Throw {@link SpiLoaderException} with message\n+     *\n+     * @param msg error message\n+     */\n+    private void fail(String msg) {", "originalCommit": "d3926c4a78df8f1f8e9c2721968450d4f222f59e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgwODc4NQ==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465808785", "bodyText": "I think fail is concise, while logAndRaise is more accurately.\nThe naming way is copy from ServiceLoader#fail(), besides throw Exception, add a RecordLog.error operation.", "author": "cdfive", "createdAt": "2020-08-05T15:23:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NTE0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTgxMjU1MA==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465812550", "bodyText": "I think fail is concise, while logAndRaise is more accurately.\nThe naming way is copy from ServiceLoader#fail(), besides throw Exception, add a RecordLog.error operation.\n\nBecause fail will throw unchecked exception which may lead actual workflow unexpected.\nWhatever just a suggestion it's not required request of change. So you can make the final decision about it.", "author": "jasonjoo2010", "createdAt": "2020-08-05T15:29:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NTE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NTgwMg==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r465465802", "bodyText": "Maybe loadOne for short. Is there any other way to get target instance? And surely i am curious that why we need loadLowestPriorityInstance or loadFirstInstance. And talk to isDefault in SPI annotation we can make the default service implementation as lowest priority. Then we can use loadOne() instead of something like loadFirstInstanceOrDefault.\nThus loadInstance loadDefault also don't have any scenario to be applied.", "author": "jasonjoo2010", "createdAt": "2020-08-05T04:32:10Z", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,541 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Same as {@link SpiLoader#of} method\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> getSpiLoader(Class<T> service) {\n+        return SpiLoader.of(service);\n+    }\n+\n+    /**\n+     * Reset all SpiLoader instances\n+     */\n+    public static void resetAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.reset();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    // Private access\n+    private SpiLoader() {\n+\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {", "originalCommit": "d3926c4a78df8f1f8e9c2721968450d4f222f59e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY3MzQ0Ng==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r491673446", "bodyText": "The loadHighestPriorityInstance,loadFirstInstance keeps same with previous version.\nIn SlotChainProvider, we have DefaultSlotChainBuilder has default implementation.\nslotChainBuilder = SpiLoader.of(SlotChainBuilder.class).loadFirstInstanceOrDefault();\nIn TokenClientProvider, the difference is no default SPI implementation.\n`ClusterTokenClient resolvedClient = SpiLoader.of(ClusterTokenClient.class).loadFirstInstance();`\nDistinguish them may be more flexible.", "author": "cdfive", "createdAt": "2020-09-20T09:37:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NTgwMg=="}], "type": "inlineReview"}, {"oid": "974bf09414df4c4e16b07235e9bfa853830e4bcd", "url": "https://github.com/alibaba/Sentinel/commit/974bf09414df4c4e16b07235e9bfa853830e4bcd", "message": "Using constant for the order of GatewayFlowSlot and ParamFlowSlot,improve the log info,remove unused code in SpiLoader", "committedDate": "2020-08-09T06:38:29Z", "type": "commit"}, {"oid": "95097bf7314371d2942b9c177bd5506b80f173a8", "url": "https://github.com/alibaba/Sentinel/commit/95097bf7314371d2942b9c177bd5506b80f173a8", "message": "Make reset method package privilege", "committedDate": "2020-08-09T06:50:20Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYwMTc0Nw==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r467601747", "bodyText": "It's not a good practice setting unrelated constant here. You'd better put it in gateway adapter package. If you feel a little unsure to decide the value of it in separated package you can take it as a user-defined implementation out of sentinel-core.", "author": "jasonjoo2010", "createdAt": "2020-08-09T16:17:09Z", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/Constants.java", "diffHunk": "@@ -70,5 +70,19 @@\n      */\n     public static volatile boolean ON = true;\n \n+    /**\n+     * Order of default processor slots\n+     */\n+    public static final int ORDER_NODE_SELECTOR_SLOT = -10000;\n+    public static final int ORDER_CLUSTER_BUILDER_SLOT = -9000;\n+    public static final int ORDER_LOG_SLOT = -8000;\n+    public static final int ORDER_STATISTIC_SLOT = -7000;\n+    public static final int ORDER_AUTHORITY_SLOT = -6000;\n+    public static final int ORDER_SYSTEM_SLOT = -5000;\n+    public static final int ORDER_GATEWAY_FLOW_SLOT = -4000;", "originalCommit": "95097bf7314371d2942b9c177bd5506b80f173a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTY3MjU4NQ==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r491672585", "bodyText": "The two constant ORDER_GATEWAY_FLOW_SLOT,ORDER_PARAM_FLOW_SLOT have been removed here.", "author": "cdfive", "createdAt": "2020-09-20T09:26:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NzYwMTc0Nw=="}], "type": "inlineReview"}, {"oid": "6b4c8ea6e2f9fc9bcc13dfc3e10ccd1729bcc603", "url": "https://github.com/alibaba/Sentinel/commit/6b4c8ea6e2f9fc9bcc13dfc3e10ccd1729bcc603", "message": "Merge remote-tracking branch 'Sentinel/master' into spiloader_enhancement\n\n# Conflicts:\n#\tsentinel-core/src/main/java/com/alibaba/csp/sentinel/init/InitExecutor.java\n#\tsentinel-core/src/main/java/com/alibaba/csp/sentinel/metric/extension/MetricExtensionProvider.java\n#\tsentinel-core/src/main/java/com/alibaba/csp/sentinel/slotchain/SlotChainProvider.java\n#\tsentinel-core/src/main/java/com/alibaba/csp/sentinel/slots/block/degrade/DegradeSlot.java", "committedDate": "2020-09-20T07:27:48Z", "type": "commit"}, {"oid": "f3ed6387d90b0ec7a4ce02941ed2335a5b3b6fa3", "url": "https://github.com/alibaba/Sentinel/commit/f3ed6387d90b0ec7a4ce02941ed2335a5b3b6fa3", "message": "Merge from master and improve code based on review", "committedDate": "2020-09-20T07:36:55Z", "type": "commit"}, {"oid": "da43f37927c0ff7d1a4a2a115b5b743cb7aa6af8", "url": "https://github.com/alibaba/Sentinel/commit/da43f37927c0ff7d1a4a2a115b5b743cb7aa6af8", "message": "Fix merge compile error", "committedDate": "2020-09-20T08:38:43Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg0MTc4NQ==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r491841785", "bodyText": "double check instance = map.get(...) may necessary, avoid class.newInstance() twice or more.", "author": "nickChenyx", "createdAt": "2020-09-21T07:35:50Z", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Reset and clear all SpiLoader instances.\n+     * Package privilege, used only in test cases.\n+     */\n+    synchronized static void resetAndClearAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.resetAndClear();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI configuration file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset and clear all fields of current SpiLoader instance and remove instance in SPI_LOADER_MAP\n+     */\n+    synchronized void resetAndClear() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI configuration file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI configuration file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI configuration file=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI configuration file=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI configuration file=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI configuration file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {", "originalCommit": "da43f37927c0ff7d1a4a2a115b5b743cb7aa6af8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYwMDg3MQ==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r498600871", "bodyText": "Yes, thanks for pointing it out!", "author": "cdfive", "createdAt": "2020-10-02T03:01:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg0MTc4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYyMDA5NQ==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r498620095", "bodyText": "It has been fixed, please check.", "author": "cdfive", "createdAt": "2020-10-02T05:06:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg0MTc4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg0NzUxNQ==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r491847515", "bodyText": "here i find usage only close one stream one time, so this may change for close one.\nif u want to close more, i think for loop should catch each fail and finish all close task, and then return fail message.\nwant your opinion, plz.", "author": "nickChenyx", "createdAt": "2020-09-21T07:47:10Z", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/spi/SpiLoader.java", "diffHunk": "@@ -0,0 +1,525 @@\n+/*\n+ * Copyright 1999-2018 Alibaba Group Holding Ltd.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.alibaba.csp.sentinel.spi;\n+\n+import com.alibaba.csp.sentinel.config.SentinelConfig;\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.util.AssertUtil;\n+import com.alibaba.csp.sentinel.util.StringUtil;\n+\n+import java.io.*;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+/**\n+ * A simple SPI loading facility.\n+ *\n+ * <p>SPI is short for Service Provider Interface.</p>\n+ *\n+ * <p>\n+ * Service is represented by a single type, that is, a single interface or an abstract class.\n+ * Provider is implementations of Service, that is, some classes which implement the interface or extends the abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Service type:\n+ * Must interface or abstract class.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider class:\n+ * Must have a zero-argument constructor so that they can be instantiated during loading.\n+ * </p>\n+ *\n+ * <p>\n+ * For Provider configuration file:\n+ * 1. The file contains a list of fully-qualified binary names of concrete provider classes, one per line.\n+ * 2. Space and tab characters surrounding each name, as well as blank lines, are ignored.\n+ * 3. The comment line character is #, all characters following it are ignored.\n+ * </p>\n+ *\n+ * <p>\n+ * Provide common functions, such as:\n+ * Load all Provider instance unsorted/sorted list.\n+ * Load highest/lowest order priority instance.\n+ * Load first-found or default instance.\n+ * Load instance by aliasname or provider class.\n+ * </p>\n+ *\n+ * @author Eric Zhao\n+ * @author cdfive\n+ * @since 1.4.0\n+ * @see com.alibaba.csp.sentinel.spi.Spi\n+ * @see java.util.ServiceLoader\n+ */\n+public final class SpiLoader<S> {\n+\n+    // Default path for the folder of Provider configuration file\n+    private static final String SPI_FILE_PREFIX = \"META-INF/services/\";\n+\n+    // Cache the SpiLoader instances, key: classname of Service, value: SpiLoader instance\n+    private static final ConcurrentHashMap<String, SpiLoader> SPI_LOADER_MAP = new ConcurrentHashMap<>();\n+\n+    // Cache the classes of Provider\n+    private final List<Class<? extends S>> classList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    // Cache the sorted classes of Provider\n+    private final List<Class<? extends S>> sortedClassList = Collections.synchronizedList(new ArrayList<Class<? extends S>>());\n+\n+    /**\n+     * Cache the classes of Provider, key: aliasName, value: class of Provider.\n+     * Note: aliasName is the value of {@link Spi} when the Provider class has {@link Spi} annotation and value is not empty,\n+     * otherwise use classname of the Provider.\n+     */\n+    private final ConcurrentHashMap<String, Class<? extends S>> classMap = new ConcurrentHashMap<>();\n+\n+    // Cache the singleton instance of Provider, key: classname of Provider, value: Provider instance\n+    private final ConcurrentHashMap<String, S> singletonMap = new ConcurrentHashMap<>();\n+\n+    // Whether this SpiLoader has beend loaded, that is, loaded the Provider configuration file\n+    private final AtomicBoolean loaded = new AtomicBoolean(false);\n+\n+    // Default provider class\n+    private Class<? extends S> defaultClass = null;\n+\n+    // The Service class, must be interface or abstract class\n+    private Class<S> service;\n+\n+    /**\n+     * Create SpiLoader instance via Service class\n+     * Cached by className, and load from cache first\n+     *\n+     * @param service Service class\n+     * @param <T>     Service type\n+     * @return SpiLoader instance\n+     */\n+    public static <T> SpiLoader<T> of(Class<T> service) {\n+        AssertUtil.notNull(service, \"SPI class cannot be null\");\n+        AssertUtil.isTrue(service.isInterface() || Modifier.isAbstract(service.getModifiers()),\n+                \"SPI class[\" + service.getName() + \"] must be interface or abstract class\");\n+\n+        String className = service.getName();\n+        SpiLoader<T> spiLoader = SPI_LOADER_MAP.get(className);\n+        if (spiLoader == null) {\n+            synchronized (SpiLoader.class) {\n+                spiLoader = SPI_LOADER_MAP.get(className);\n+                if (spiLoader == null) {\n+                    SPI_LOADER_MAP.putIfAbsent(className, new SpiLoader<>(service));\n+                    spiLoader = SPI_LOADER_MAP.get(className);\n+                }\n+            }\n+        }\n+\n+        return spiLoader;\n+    }\n+\n+    /**\n+     * Reset and clear all SpiLoader instances.\n+     * Package privilege, used only in test cases.\n+     */\n+    synchronized static void resetAndClearAll() {\n+        Set<Map.Entry<String, SpiLoader>> entries = SPI_LOADER_MAP.entrySet();\n+        for (Map.Entry<String, SpiLoader> entry : entries) {\n+            SpiLoader spiLoader = entry.getValue();\n+            spiLoader.resetAndClear();\n+        }\n+        SPI_LOADER_MAP.clear();\n+    }\n+\n+    // Private access\n+    private SpiLoader(Class<S> service) {\n+        this.service = service;\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service\n+     *\n+     * @return Provider instances list\n+     */\n+    public List<S> loadInstanceList() {\n+        load();\n+\n+        return createInstanceList(classList);\n+    }\n+\n+    /**\n+     * Load all Provider instances of the specified Service, sorted by order value in class's {@link Spi} annotation\n+     *\n+     * @return Sorted Provider instances list\n+     */\n+    public List<S> loadInstanceListSorted() {\n+        load();\n+\n+        return createInstanceList(sortedClassList);\n+    }\n+\n+    /**\n+     * Load highest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of highest order priority\n+     */\n+    public S loadHighestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> highestClass = sortedClassList.get(0);\n+        return createInstance(highestClass);\n+    }\n+\n+    /**\n+     * Load lowest order priority instance, order value is defined in class's {@link Spi} annotation\n+     *\n+     * @return Provider instance of lowest order priority\n+     */\n+    public S loadLowestPriorityInstance() {\n+        load();\n+\n+        if (sortedClassList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> lowestClass = sortedClassList.get(sortedClassList.size() - 1);\n+        return createInstance(lowestClass);\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance\n+     *\n+     * @return Provider instance of first-found specific\n+     */\n+    public S loadFirstInstance() {\n+        load();\n+\n+        if (classList.size() == 0) {\n+            return null;\n+        }\n+\n+        Class<? extends S> serviceClass = classList.get(0);\n+        S instance = createInstance(serviceClass);\n+        return instance;\n+    }\n+\n+    /**\n+     * Load the first-found Provider instance,if not found, return default Provider instance\n+     *\n+     * @return Provider instance\n+     */\n+    public S loadFirstInstanceOrDefault() {\n+        load();\n+\n+        for (Class<? extends S> clazz : classList) {\n+            if (defaultClass == null || clazz != defaultClass) {\n+                return createInstance(clazz);\n+            }\n+        }\n+\n+        return loadDefaultInstance();\n+    }\n+\n+    /**\n+     * Load default Provider instance\n+     * Provider class with @Spi(isDefault = true)\n+     *\n+     * @return default Provider instance\n+     */\n+    public S loadDefaultInstance() {\n+        load();\n+\n+        if (defaultClass == null) {\n+            return null;\n+        }\n+\n+        return createInstance(defaultClass);\n+    }\n+\n+    /**\n+     * Load instance by specific class type\n+     *\n+     * @param clazz class type\n+     * @return Provider instance\n+     */\n+    public S loadInstance(Class<? extends S> clazz) {\n+        AssertUtil.notNull(clazz, \"SPI class cannot be null\");\n+\n+        if (clazz.equals(service)) {\n+            fail(clazz.getName() + \" is not subtype of \" + service.getName());\n+        }\n+\n+        load();\n+\n+        if (!classMap.containsValue(clazz)) {\n+            fail(clazz.getName() + \" is not Provider class of \" + service.getName() + \",check if it is in the SPI configuration file?\");\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Load instance by aliasName of Provider class\n+     *\n+     * @param aliasName aliasName of Provider class\n+     * @return Provider instance\n+     */\n+    public S loadInstance(String aliasName) {\n+        AssertUtil.notEmpty(aliasName, \"aliasName cannot be empty\");\n+\n+        load();\n+\n+        Class<? extends S> clazz = classMap.get(aliasName);\n+        if (clazz == null) {\n+            fail(\"no Provider class's aliasName is \" + aliasName);\n+        }\n+\n+        return createInstance(clazz);\n+    }\n+\n+    /**\n+     * Reset and clear all fields of current SpiLoader instance and remove instance in SPI_LOADER_MAP\n+     */\n+    synchronized void resetAndClear() {\n+        SPI_LOADER_MAP.remove(service.getName());\n+        classList.clear();\n+        sortedClassList.clear();\n+        classMap.clear();\n+        singletonMap.clear();\n+        defaultClass = null;\n+        loaded.set(false);\n+    }\n+\n+    /**\n+     * Load the Provider class from Provider configuration file\n+     */\n+    public void load() {\n+        if (!loaded.compareAndSet(false, true)) {\n+            return;\n+        }\n+\n+        String fullFileName = SPI_FILE_PREFIX + service.getName();\n+        ClassLoader classLoader;\n+        if (SentinelConfig.shouldUseContextClassloader()) {\n+            classLoader = Thread.currentThread().getContextClassLoader();\n+        } else {\n+            classLoader = service.getClassLoader();\n+        }\n+        if (classLoader == null) {\n+            classLoader = ClassLoader.getSystemClassLoader();\n+        }\n+        Enumeration<URL> urls = null;\n+        try {\n+            urls = classLoader.getResources(fullFileName);\n+        } catch (IOException e) {\n+            fail(\"Error locating SPI configuration file,filename=\" + fullFileName + \",classloader=\" + classLoader, e);\n+        }\n+\n+        if (urls == null || !urls.hasMoreElements()) {\n+            RecordLog.warn(\"No SPI configuration file,filename=\" + fullFileName + \",classloader=\" + classLoader);\n+            return;\n+        }\n+\n+        while (urls.hasMoreElements()) {\n+            URL url = urls.nextElement();\n+\n+            InputStream in = null;\n+            BufferedReader br = null;\n+            try {\n+                in = url.openStream();\n+                br = new BufferedReader(new InputStreamReader(in, \"utf-8\"));\n+                String line;\n+                while ((line = br.readLine()) != null) {\n+                    if (StringUtil.isBlank(line)) {\n+                        // Skip blank line\n+                        continue;\n+                    }\n+\n+                    line = line.trim();\n+                    int commentIndex = line.indexOf(\"#\");\n+                    if (commentIndex == 0) {\n+                        // Skip comment line\n+                        continue;\n+                    }\n+\n+                    if (commentIndex > 0) {\n+                        line = line.substring(0, commentIndex);\n+                    }\n+                    line = line.trim();\n+\n+                    Class<S> clazz = null;\n+                    try {\n+                        clazz = (Class<S>) Class.forName(line, false, classLoader);\n+                    } catch (ClassNotFoundException e) {\n+                        fail(\"class \" + line + \" not found\", e);\n+                    }\n+\n+                    if (!service.isAssignableFrom(clazz)) {\n+                        fail(\"class \" + clazz.getName() + \"is not subtype of \" + service.getName() + \",SPI configuration file=\" + fullFileName);\n+                    }\n+\n+                    classList.add(clazz);\n+                    Spi spi = clazz.getAnnotation(Spi.class);\n+                    String aliasName = spi == null || \"\".equals(spi.value()) ? clazz.getName() : spi.value();\n+                    if (classMap.containsKey(aliasName)) {\n+                        Class<? extends S> existClass = classMap.get(aliasName);\n+                        fail(\"Found repeat aliasname for \" + clazz.getName() + \" and \"\n+                                + existClass.getName() + \",SPI configuration file=\" + fullFileName);\n+                    }\n+                    classMap.put(aliasName, clazz);\n+\n+                    if (spi != null && spi.isDefault()) {\n+                        if (defaultClass != null) {\n+                            fail(\"Found more than one default Provider,SPI configuration file=\" + fullFileName);\n+                        }\n+                        defaultClass = clazz;\n+                    }\n+\n+                    RecordLog.info(\"[SpiLoader]Found SPI,Service={},Provider={},aliasname={},isSingleton={},isDefault={},order={}\",\n+                        service.getName(), line, aliasName\n+                            , spi == null ? true : spi.isSingleton()\n+                            , spi == null ? false : spi.isDefault()\n+                            , spi == null ? 0 : spi.order());\n+                }\n+\n+                sortedClassList.addAll(classList);\n+                Collections.sort(sortedClassList, new Comparator<Class<? extends S>>() {\n+                    @Override\n+                    public int compare(Class<? extends S> o1, Class<? extends S> o2) {\n+                        Spi spi1 = o1.getAnnotation(Spi.class);\n+                        int order1 = spi1 == null ? 0 : spi1.order();\n+\n+                        Spi spi2 = o2.getAnnotation(Spi.class);\n+                        int order2 = spi2 == null ? 0 : spi2.order();\n+\n+                        return Integer.compare(order1, order2);\n+                    }\n+                });\n+            } catch (IOException e) {\n+                fail(\"error reading SPI configuration file\", e);\n+            } finally {\n+                closeResources(in, br);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"com.alibaba.csp.sentinel.spi.SpiLoader[\" + service.getName() + \"]\";\n+    }\n+\n+    /**\n+     * Create Provider instance list\n+     *\n+     * @param clazzList class types of Providers\n+     * @return Provider instance list\n+     */\n+    private List<S> createInstanceList(List<Class<? extends S>> clazzList) {\n+        if (clazzList == null || clazzList.size() == 0) {\n+            return Collections.emptyList();\n+        }\n+\n+        List<S> instances = new ArrayList<>(clazzList.size());\n+        for (Class<? extends S> clazz : clazzList) {\n+            S instance = createInstance(clazz);\n+            instances.add(instance);\n+        }\n+        return instances;\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz class type of Provider\n+     * @return Provider class\n+     */\n+    private S createInstance(Class<? extends S> clazz) {\n+        Spi spi = clazz.getAnnotation(Spi.class);\n+        boolean singleton = true;\n+        if (spi != null) {\n+            singleton = spi.isSingleton();\n+        }\n+        return createInstance(clazz, singleton);\n+    }\n+\n+    /**\n+     * Create Provider instance\n+     *\n+     * @param clazz     class type of Provider\n+     * @param singleton if instance is singleton or prototype\n+     * @return Provider instance\n+     */\n+    private S createInstance(Class<? extends S> clazz, boolean singleton) {\n+        S instance = null;\n+        try {\n+            if (singleton) {\n+                instance = singletonMap.get(clazz.getName());\n+                if (instance == null) {\n+                    synchronized (this) {\n+                        instance = service.cast(clazz.newInstance());\n+                        singletonMap.put(clazz.getName(), instance);\n+                    }\n+                }\n+            } else {\n+                instance = service.cast(clazz.newInstance());\n+            }\n+        } catch (Throwable e) {\n+            fail(clazz.getName() + \" could not be instantiated\");\n+        }\n+        return instance;\n+    }\n+\n+    /**\n+     * Close all resources\n+     *\n+     * @param closeables {@link Closeable} resources\n+     */\n+    private void closeResources(Closeable... closeables) {", "originalCommit": "da43f37927c0ff7d1a4a2a115b5b743cb7aa6af8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODYyMDU1MQ==", "url": "https://github.com/alibaba/Sentinel/pull/1383#discussion_r498620551", "bodyText": "Now it has been changed, record the first exception during close resources, to make it can finish all close task, and then throw exception with fail message. Thanks for your careful review.", "author": "cdfive", "createdAt": "2020-10-02T05:09:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTg0NzUxNQ=="}], "type": "inlineReview"}, {"oid": "e312d8adcb753c1ab4f485db01a4b1c2fe44ab09", "url": "https://github.com/alibaba/Sentinel/commit/e312d8adcb753c1ab4f485db01a4b1c2fe44ab09", "message": "Fix double check when create instance,and fix close resources when exception occurs.", "committedDate": "2020-10-02T03:07:19Z", "type": "commit"}, {"oid": "ffa8d0ce946f96aec32187bdd5c8dbb9a9c18719", "url": "https://github.com/alibaba/Sentinel/commit/ffa8d0ce946f96aec32187bdd5c8dbb9a9c18719", "message": "Fix sortedClassList added more than once which cause CI error when running test cases.", "committedDate": "2020-10-02T03:47:52Z", "type": "commit"}, {"oid": "d23617169eb1be3d6c104ccf175b1105c8f61cfa", "url": "https://github.com/alibaba/Sentinel/commit/d23617169eb1be3d6c104ccf175b1105c8f61cfa", "message": "Fix double check when create new instance in SpiLoader", "committedDate": "2020-10-08T06:27:41Z", "type": "commit"}]}