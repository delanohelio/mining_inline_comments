{"pr_number": 1746, "pr_title": "Improve performance of TimeUtil in different load conditions", "pr_createdAt": "2020-09-18T06:22:24Z", "pr_url": "https://github.com/alibaba/Sentinel/pull/1746", "timeline": [{"oid": "33fd8445f1106072d9c0e3b4d0cca107a1e65bf2", "url": "https://github.com/alibaba/Sentinel/commit/33fd8445f1106072d9c0e3b4d0cca107a1e65bf2", "message": "Make TimeUtil have multiple running states:\n\n- IDLE: Direct invocation state for idle conditions.\n- RUNNING: Legacy mode for busy conditions.\n- REQUEST: Temporary state from IDLE to RUNNING.\n\nThough this design TimeUtil won't cost much in idle systems any more.\n\nSigned-off-by: Jason Joo <hblzxsj@163.com>", "committedDate": "2020-09-18T08:55:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA2NTk3MA==", "url": "https://github.com/alibaba/Sentinel/pull/1746#discussion_r492065970", "bodyText": "I think state should be a volatile variable.", "author": "liqiangz", "createdAt": "2020-09-21T13:57:43Z", "path": "sentinel-core/src/main/java/com/alibaba/csp/sentinel/util/TimeUtil.java", "diffHunk": "@@ -15,38 +15,199 @@\n  */\n package com.alibaba.csp.sentinel.util;\n \n+import java.util.List;\n import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import com.alibaba.csp.sentinel.log.RecordLog;\n+import com.alibaba.csp.sentinel.slots.statistic.base.LeapArray;\n+import com.alibaba.csp.sentinel.slots.statistic.base.LongAdder;\n+import com.alibaba.csp.sentinel.slots.statistic.base.WindowWrap;\n+import com.alibaba.csp.sentinel.util.function.Tuple2;\n \n /**\n  * Provides millisecond-level time of OS.\n+ * <p>\n+ * Here we should see that not all the time TimeUtil should \n+ * keep looping 1_000 times every second (Actually about 800/s due to some losses).\n+ * <pre>\n+ * * In idle conditions it just acts as System.currentTimeMillis();\n+ * * In busy conditions (significantly more than 1_000/s) it keeps loop to reduce costs.\n+ * </pre>\n+ * For detail design and proposals please goto \n+ * <a href=\"https://github.com/alibaba/Sentinel/issues/1702#issuecomment-692151160\">https://github.com/alibaba/Sentinel/issues/1702</a>\n  *\n  * @author qinan.qn\n+ * @author jason\n  */\n-public final class TimeUtil {\n+public final class TimeUtil implements Runnable {\n+    private static final long CHECK_INTERVAL = 3000;\n+    \n+    public static enum STATE {\n+        IDLE, PREPARE, RUNNING;\n+    }\n+    private static class Statistic {\n+        private LongAdder writes = new LongAdder();\n+        private LongAdder reads = new LongAdder();\n+        public LongAdder getWrites() {\n+            return writes;\n+        }\n+        public LongAdder getReads() {\n+            return reads;\n+        }\n+    }\n+    private static TimeUtil INSTANCE;\n \n-    private static volatile long currentTimeMillis;\n+    private volatile long currentTimeMillis;\n+    private AtomicLong lastCheck = new AtomicLong();\n+    private LeapArray<Statistic> statistics;\n+    private STATE state = STATE.IDLE;", "originalCommit": "33fd8445f1106072d9c0e3b4d0cca107a1e65bf2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE5MTMzNA==", "url": "https://github.com/alibaba/Sentinel/pull/1746#discussion_r492191334", "bodyText": "Hi, liqiangz\nHere to use modifiers without a volatile is because following considerations:\n\nLow frequency of switching is assumed.\nAll writings to it only occurred in same thread (which maybe we should consider to remove the unnecessary CAS operation)\nUse L1/L2 cache to get better performance\n\nSo should it still be volatile? Is there any other branch I maybe lack of consideration?", "author": "jasonjoo2010", "createdAt": "2020-09-21T16:26:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA2NTk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ0MDg5Nw==", "url": "https://github.com/alibaba/Sentinel/pull/1746#discussion_r492440897", "bodyText": "Thanks for your reply, but I still have a confusion.\nWhen state in the daemon thread switch to IDLE, currentTimeMillis will not be updated. But when calling currentTime function  in another thread, state may still be RUNNING.  The getTime()  result will always be the old currentTimeMillis.", "author": "liqiangz", "createdAt": "2020-09-22T02:13:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA2NTk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ0MjgzMg==", "url": "https://github.com/alibaba/Sentinel/pull/1746#discussion_r492442832", "bodyText": "Hi, liqiangz\nBoth IDLE and PREPARE are treated as IDLE in getTime() while daemon will only switch PREPARE to RUNNING when it actually started to update currentTimeMillis.\nI will remove the CAS operation which is a kind of legacy after several iterations of design. And I also will consider whether it's necessary to make it volatile in java for not strictly reordering forbidden scenario. As we know in rare condition codes like below in c++:\nbool cond = true;\nwhile (cond);\nmay be \"optimized\" to be\nif (cond) {\nwhile(true){}\n}\nBut I am not sure it will occur in JVM's byte codes. Because it more like a bug which it's common in CPP compilers. (aha)\nWhat do you think about the visibility latency in practice?", "author": "jasonjoo2010", "createdAt": "2020-09-22T02:22:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA2NTk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjQ1MzAxNA==", "url": "https://github.com/alibaba/Sentinel/pull/1746#discussion_r492453014", "bodyText": "CAS operation has been removed and state is taken as volatile now.\nIn unit test concurrency has been raised more too.", "author": "jasonjoo2010", "createdAt": "2020-09-22T03:13:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA2NTk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgxMzIzNA==", "url": "https://github.com/alibaba/Sentinel/pull/1746#discussion_r492813234", "bodyText": "I think we should be very careful about variables shared by multiple threads. If you want to do some concurrency optimization,  you must really understand what you do.\nFor programs that are not synchronized, if you want to judge the execution order of memory operations, it is almost impossible to get a correct conclusion . A simple way is to synchronize all variables shared by multiple threads.This is the view of the book \u300ajava concurrency in practice\u300b  \ud83d\ude04\nIn this scenario, the value of state modified by one thread may never be seen by another thread, because we don\u2019t know what kind of optimization the compiler and processor will perform. But because currentTimeMillis is volatile(Unlike c++, after JDK 5, JMM strictly restricts the rearrangement of volatile variables and ordinary variables by the compiler and processor), There may be no problems in this program.", "author": "liqiangz", "createdAt": "2020-09-22T15:08:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA2NTk3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyNzEyOA==", "url": "https://github.com/alibaba/Sentinel/pull/1746#discussion_r492827128", "bodyText": "Yeah totally agree with you. So CAS has been removed and volatile is marked on state while lastCheck is still a private and local variable.", "author": "jasonjoo2010", "createdAt": "2020-09-22T15:24:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjA2NTk3MA=="}], "type": "inlineReview"}, {"oid": "7b4acdacdca67ced8a3ee5df2b3b20fc938ba8b3", "url": "https://github.com/alibaba/Sentinel/commit/7b4acdacdca67ced8a3ee5df2b3b20fc938ba8b3", "message": "Make TimeUtil have multiple running states:\n\n- IDLE: Direct invocation state for idle conditions.\n- RUNNING: Legacy mode for busy conditions.\n- REQUEST: Temporary state from IDLE to RUNNING.\n\nThrough this design TimeUtil won't cost much in idle systems any more.\n\nSigned-off-by: Jason Joo <hblzxsj@163.com>", "committedDate": "2020-09-22T02:59:41Z", "type": "commit"}, {"oid": "7b4acdacdca67ced8a3ee5df2b3b20fc938ba8b3", "url": "https://github.com/alibaba/Sentinel/commit/7b4acdacdca67ced8a3ee5df2b3b20fc938ba8b3", "message": "Make TimeUtil have multiple running states:\n\n- IDLE: Direct invocation state for idle conditions.\n- RUNNING: Legacy mode for busy conditions.\n- REQUEST: Temporary state from IDLE to RUNNING.\n\nThrough this design TimeUtil won't cost much in idle systems any more.\n\nSigned-off-by: Jason Joo <hblzxsj@163.com>", "committedDate": "2020-09-22T02:59:41Z", "type": "forcePushed"}]}