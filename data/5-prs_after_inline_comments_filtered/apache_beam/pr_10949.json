{"pr_number": 10949, "pr_title": "[BEAM-9371] Add SideInputLoadTest to Java SDK", "pr_createdAt": "2020-02-24T15:02:17Z", "pr_url": "https://github.com/apache/beam/pull/10949", "timeline": [{"oid": "befbd2361fbdf26e495eeb440f9fffdd93cb928c", "url": "https://github.com/apache/beam/commit/befbd2361fbdf26e495eeb440f9fffdd93cb928c", "message": "[BEAM-9731] Add SideInputLoadTest implementation", "committedDate": "2020-02-24T15:01:36Z", "type": "commit"}, {"oid": "6cec849858f313c81c3332650a810b2e401fbed8", "url": "https://github.com/apache/beam/commit/6cec849858f313c81c3332650a810b2e401fbed8", "message": "Fix spotbugs", "committedDate": "2020-02-24T16:20:47Z", "type": "commit"}, {"oid": "0cc55d5151584ca6c5aa1e2fb0249eab543657e3", "url": "https://github.com/apache/beam/commit/0cc55d5151584ca6c5aa1e2fb0249eab543657e3", "message": "Fix code style error", "committedDate": "2020-02-25T07:51:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQzNDUyOA==", "url": "https://github.com/apache/beam/pull/10949#discussion_r386434528", "bodyText": "Is there a specific reason we do windowing only for iterable case?", "author": "Ardagan", "createdAt": "2020-03-02T14:46:04Z", "path": "sdks/java/testing/load-tests/src/main/java/org/apache/beam/sdk/loadtests/SideInputLoadTest.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.loadtests;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import org.apache.beam.sdk.io.synthetic.SyntheticStep;\n+import org.apache.beam.sdk.options.Default;\n+import org.apache.beam.sdk.options.Description;\n+import org.apache.beam.sdk.options.Validation;\n+import org.apache.beam.sdk.testutils.metrics.ByteMonitor;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.View;\n+import org.apache.beam.sdk.transforms.windowing.FixedWindows;\n+import org.apache.beam.sdk.transforms.windowing.Window;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionView;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+\n+/**\n+ * Load test for operations involving side inputs.\n+ *\n+ * <p>The purpose of this test is to measure cost of materialization or lookup of side inputs. It\n+ * uses synthetic sources and {@link SyntheticStep} which can be parametrized to generate records\n+ * with various sizes of keys and values, impose delays in the pipeline and simulate other\n+ * performance challenges.\n+ *\n+ * <p>To run the test manually, use the following command:\n+ *\n+ * <pre>\n+ *   ./gradlew :sdks:java:testing:load-tests:run -PloadTest.args='\n+ *    --sourceOptions={\"numRecords\":2000, ...}\n+ *    --sideInputType=ITERABLE\n+ *    --accessPercentage=1\n+ *    --windowCount=200\n+ * </pre>\n+ */\n+public class SideInputLoadTest extends LoadTest<SideInputLoadTest.Options> {\n+\n+  private static final String METRICS_NAMESPACE = \"sideinput\";\n+  private static final Instant TIME = new Instant();\n+\n+  public SideInputLoadTest(String[] args) throws IOException {\n+    super(args, Options.class, METRICS_NAMESPACE);\n+  }\n+\n+  @Override\n+  void loadTest() throws IOException {\n+    Optional<SyntheticStep> syntheticStep = createStep(options.getStepOptions());\n+    PCollection<KV<byte[], byte[]>> input =\n+        pipeline\n+            .apply(readFromSource(sourceOptions))\n+            .apply(ParDo.of(new AddTimestamps()))\n+            .apply(\"Collect start time metrics\", ParDo.of(runtimeMonitor))\n+            .apply(ParDo.of(new ByteMonitor(METRICS_NAMESPACE, \"totalBytes.count\")));\n+\n+    performTestWithSideInput(\n+        input, SideInputMaterializationType.valueOf(options.getSideInputType()), syntheticStep);\n+  }\n+\n+  private void performTestWithSideInput(\n+      PCollection<KV<byte[], byte[]>> input,\n+      SideInputMaterializationType sideInputType,\n+      Optional<SyntheticStep> syntheticStep) {\n+    switch (sideInputType) {\n+      case ITERABLE:\n+        performTestWithIterable(input, syntheticStep);\n+        break;\n+      case HASHMAP:\n+        performTestWithHashMap(input, syntheticStep);\n+        break;\n+      case LIST:\n+        performTestWithList(input, syntheticStep);\n+        break;\n+    }\n+  }\n+\n+  private void performTestWithList(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<List<KV<byte[], byte[]>>> sideInput = input.apply(View.asList());\n+    input\n+        .apply(ParDo.of(new SideInputTestWithList(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private void performTestWithHashMap(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<Map<byte[], byte[]>> sideInput = input.apply(View.asMap());\n+    input\n+        .apply(ParDo.of(new SideInputTestWithHashMap(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private void performTestWithIterable(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<Iterable<KV<byte[], byte[]>>> sideInput;\n+    if (options.getWindowCount() != 0) {\n+      long windowDurationMilis = sourceOptions.numRecords / options.getWindowCount();", "originalCommit": "0cc55d5151584ca6c5aa1e2fb0249eab543657e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU3MzM4Mw==", "url": "https://github.com/apache/beam/pull/10949#discussion_r387573383", "bodyText": "As I understand it, all SideInput types except for Iterable are cached, so windowing shouldn't change much in other scenarios. I can add it to other cases anyway", "author": "mwalenia", "createdAt": "2020-03-04T10:23:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjQzNDUyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MDY0NA==", "url": "https://github.com/apache/beam/pull/10949#discussion_r386740644", "bodyText": "What are the metrics? Should they be described in the Javadoc? I read the superclass and did not see much explanation there either.\nThe code here makes OK sense but is not enough information to use it. So I am just wondering what the experience is for someone who wants to use the class to build a new load test.", "author": "kennknowles", "createdAt": "2020-03-03T00:55:01Z", "path": "sdks/java/testing/load-tests/src/main/java/org/apache/beam/sdk/loadtests/SideInputLoadTest.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.loadtests;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import org.apache.beam.sdk.io.synthetic.SyntheticStep;\n+import org.apache.beam.sdk.options.Default;\n+import org.apache.beam.sdk.options.Description;\n+import org.apache.beam.sdk.options.Validation;\n+import org.apache.beam.sdk.testutils.metrics.ByteMonitor;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.View;\n+import org.apache.beam.sdk.transforms.windowing.FixedWindows;\n+import org.apache.beam.sdk.transforms.windowing.Window;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionView;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+\n+/**\n+ * Load test for operations involving side inputs.\n+ *\n+ * <p>The purpose of this test is to measure cost of materialization or lookup of side inputs. It\n+ * uses synthetic sources and {@link SyntheticStep} which can be parametrized to generate records\n+ * with various sizes of keys and values, impose delays in the pipeline and simulate other\n+ * performance challenges.\n+ *\n+ * <p>To run the test manually, use the following command:\n+ *\n+ * <pre>\n+ *   ./gradlew :sdks:java:testing:load-tests:run -PloadTest.args='\n+ *    --sourceOptions={\"numRecords\":2000, ...}\n+ *    --sideInputType=ITERABLE\n+ *    --accessPercentage=1\n+ *    --windowCount=200\n+ * </pre>\n+ */\n+public class SideInputLoadTest extends LoadTest<SideInputLoadTest.Options> {\n+\n+  private static final String METRICS_NAMESPACE = \"sideinput\";", "originalCommit": "0cc55d5151584ca6c5aa1e2fb0249eab543657e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU3NDExOQ==", "url": "https://github.com/apache/beam/pull/10949#discussion_r387574119", "bodyText": "The metrics are runtime and dataset size. I can document the LoadTest class a bit better in another PR if you think current state is not helpful enough", "author": "mwalenia", "createdAt": "2020-03-04T10:24:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MDY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MzMwMA==", "url": "https://github.com/apache/beam/pull/10949#discussion_r386743300", "bodyText": "I just noticed runtimeMonitor is a protected field. It seems there are actually a few, and you have built enough on top that it may be getting hard to change. But even though I am late, I offer a suggestion for refactor: make LoadTest parameterized instead of a base class.\nEach subclass of LoadTest is really just the main loadTest function and really that function is about the same as writing a PTransform. If you eliminate subclassing you can have LoadTest own the pipeline setup with so it will never be possible to forget or mess up readSourceFromOptions and ParDo.of(runtimeMonitor). It will be less repeat boilerplate. Also you won't have to reference variables defined in another file as protected fields.", "author": "kennknowles", "createdAt": "2020-03-03T01:04:08Z", "path": "sdks/java/testing/load-tests/src/main/java/org/apache/beam/sdk/loadtests/SideInputLoadTest.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.loadtests;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import org.apache.beam.sdk.io.synthetic.SyntheticStep;\n+import org.apache.beam.sdk.options.Default;\n+import org.apache.beam.sdk.options.Description;\n+import org.apache.beam.sdk.options.Validation;\n+import org.apache.beam.sdk.testutils.metrics.ByteMonitor;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.View;\n+import org.apache.beam.sdk.transforms.windowing.FixedWindows;\n+import org.apache.beam.sdk.transforms.windowing.Window;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionView;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+\n+/**\n+ * Load test for operations involving side inputs.\n+ *\n+ * <p>The purpose of this test is to measure cost of materialization or lookup of side inputs. It\n+ * uses synthetic sources and {@link SyntheticStep} which can be parametrized to generate records\n+ * with various sizes of keys and values, impose delays in the pipeline and simulate other\n+ * performance challenges.\n+ *\n+ * <p>To run the test manually, use the following command:\n+ *\n+ * <pre>\n+ *   ./gradlew :sdks:java:testing:load-tests:run -PloadTest.args='\n+ *    --sourceOptions={\"numRecords\":2000, ...}\n+ *    --sideInputType=ITERABLE\n+ *    --accessPercentage=1\n+ *    --windowCount=200\n+ * </pre>\n+ */\n+public class SideInputLoadTest extends LoadTest<SideInputLoadTest.Options> {\n+\n+  private static final String METRICS_NAMESPACE = \"sideinput\";\n+  private static final Instant TIME = new Instant();\n+\n+  public SideInputLoadTest(String[] args) throws IOException {\n+    super(args, Options.class, METRICS_NAMESPACE);\n+  }\n+\n+  @Override\n+  void loadTest() throws IOException {\n+    Optional<SyntheticStep> syntheticStep = createStep(options.getStepOptions());\n+    PCollection<KV<byte[], byte[]>> input =\n+        pipeline\n+            .apply(readFromSource(sourceOptions))\n+            .apply(ParDo.of(new AddTimestamps()))\n+            .apply(\"Collect start time metrics\", ParDo.of(runtimeMonitor))\n+            .apply(ParDo.of(new ByteMonitor(METRICS_NAMESPACE, \"totalBytes.count\")));\n+\n+    performTestWithSideInput(\n+        input, SideInputMaterializationType.valueOf(options.getSideInputType()), syntheticStep);\n+  }\n+\n+  private void performTestWithSideInput(\n+      PCollection<KV<byte[], byte[]>> input,\n+      SideInputMaterializationType sideInputType,\n+      Optional<SyntheticStep> syntheticStep) {\n+    switch (sideInputType) {\n+      case ITERABLE:\n+        performTestWithIterable(input, syntheticStep);\n+        break;\n+      case HASHMAP:\n+        performTestWithHashMap(input, syntheticStep);\n+        break;\n+      case LIST:\n+        performTestWithList(input, syntheticStep);\n+        break;\n+    }\n+  }\n+\n+  private void performTestWithList(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<List<KV<byte[], byte[]>>> sideInput = input.apply(View.asList());\n+    input\n+        .apply(ParDo.of(new SideInputTestWithList(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private void performTestWithHashMap(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<Map<byte[], byte[]>> sideInput = input.apply(View.asMap());\n+    input\n+        .apply(ParDo.of(new SideInputTestWithHashMap(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private void performTestWithIterable(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<Iterable<KV<byte[], byte[]>>> sideInput;\n+    if (options.getWindowCount() != 0) {\n+      long windowDurationMilis = sourceOptions.numRecords / options.getWindowCount();\n+      sideInput =\n+          input\n+              .apply(Window.into(FixedWindows.of(Duration.millis(windowDurationMilis))))\n+              .apply(View.asIterable());\n+    } else {\n+      sideInput = input.apply(View.asIterable());\n+    }\n+\n+    input\n+        .apply(ParDo.of(new SideInputTestWithIterable(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));", "originalCommit": "0cc55d5151584ca6c5aa1e2fb0249eab543657e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTY4MzExNg==", "url": "https://github.com/apache/beam/pull/10949#discussion_r389683116", "bodyText": "I think we can talk about refactoring of the load tests in another context, let's keep this PR focused on the load test. WDYT?", "author": "mwalenia", "createdAt": "2020-03-09T13:45:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MzMwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTExOTE4NQ==", "url": "https://github.com/apache/beam/pull/10949#discussion_r391119185", "bodyText": "I see that one option is to create Jira with list of improvements and work on it in next PR. This will make it easier to review both cases.", "author": "Ardagan", "createdAt": "2020-03-11T16:56:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MzMwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjMzMDE2Mw==", "url": "https://github.com/apache/beam/pull/10949#discussion_r396330163", "bodyText": "@kennknowles how do you envision this refactor? I don't see how we can parametrize the LoadTest further (it's already parametrized with options class). What we can do is move some of the boilerplate up to the LoadTest class, so that some of source reading is done automatically.\nI will be grateful for your input in this matter.", "author": "mwalenia", "createdAt": "2020-03-23T09:56:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MzMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MzY2OQ==", "url": "https://github.com/apache/beam/pull/10949#discussion_r386743669", "bodyText": "This tests Map, not HashMap. The runner (or SDK harness in portability) can choose whatever kind of Map it wants.", "author": "kennknowles", "createdAt": "2020-03-03T01:05:31Z", "path": "sdks/java/testing/load-tests/src/main/java/org/apache/beam/sdk/loadtests/SideInputLoadTest.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.loadtests;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import org.apache.beam.sdk.io.synthetic.SyntheticStep;\n+import org.apache.beam.sdk.options.Default;\n+import org.apache.beam.sdk.options.Description;\n+import org.apache.beam.sdk.options.Validation;\n+import org.apache.beam.sdk.testutils.metrics.ByteMonitor;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.View;\n+import org.apache.beam.sdk.transforms.windowing.FixedWindows;\n+import org.apache.beam.sdk.transforms.windowing.Window;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionView;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+\n+/**\n+ * Load test for operations involving side inputs.\n+ *\n+ * <p>The purpose of this test is to measure cost of materialization or lookup of side inputs. It\n+ * uses synthetic sources and {@link SyntheticStep} which can be parametrized to generate records\n+ * with various sizes of keys and values, impose delays in the pipeline and simulate other\n+ * performance challenges.\n+ *\n+ * <p>To run the test manually, use the following command:\n+ *\n+ * <pre>\n+ *   ./gradlew :sdks:java:testing:load-tests:run -PloadTest.args='\n+ *    --sourceOptions={\"numRecords\":2000, ...}\n+ *    --sideInputType=ITERABLE\n+ *    --accessPercentage=1\n+ *    --windowCount=200\n+ * </pre>\n+ */\n+public class SideInputLoadTest extends LoadTest<SideInputLoadTest.Options> {\n+\n+  private static final String METRICS_NAMESPACE = \"sideinput\";\n+  private static final Instant TIME = new Instant();\n+\n+  public SideInputLoadTest(String[] args) throws IOException {\n+    super(args, Options.class, METRICS_NAMESPACE);\n+  }\n+\n+  @Override\n+  void loadTest() throws IOException {\n+    Optional<SyntheticStep> syntheticStep = createStep(options.getStepOptions());\n+    PCollection<KV<byte[], byte[]>> input =\n+        pipeline\n+            .apply(readFromSource(sourceOptions))\n+            .apply(ParDo.of(new AddTimestamps()))\n+            .apply(\"Collect start time metrics\", ParDo.of(runtimeMonitor))\n+            .apply(ParDo.of(new ByteMonitor(METRICS_NAMESPACE, \"totalBytes.count\")));\n+\n+    performTestWithSideInput(\n+        input, SideInputMaterializationType.valueOf(options.getSideInputType()), syntheticStep);\n+  }\n+\n+  private void performTestWithSideInput(\n+      PCollection<KV<byte[], byte[]>> input,\n+      SideInputMaterializationType sideInputType,\n+      Optional<SyntheticStep> syntheticStep) {\n+    switch (sideInputType) {\n+      case ITERABLE:\n+        performTestWithIterable(input, syntheticStep);\n+        break;\n+      case HASHMAP:\n+        performTestWithHashMap(input, syntheticStep);\n+        break;\n+      case LIST:\n+        performTestWithList(input, syntheticStep);\n+        break;\n+    }\n+  }\n+\n+  private void performTestWithList(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<List<KV<byte[], byte[]>>> sideInput = input.apply(View.asList());\n+    input\n+        .apply(ParDo.of(new SideInputTestWithList(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private void performTestWithHashMap(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<Map<byte[], byte[]>> sideInput = input.apply(View.asMap());\n+    input\n+        .apply(ParDo.of(new SideInputTestWithHashMap(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private void performTestWithIterable(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<Iterable<KV<byte[], byte[]>>> sideInput;\n+    if (options.getWindowCount() != 0) {\n+      long windowDurationMilis = sourceOptions.numRecords / options.getWindowCount();\n+      sideInput =\n+          input\n+              .apply(Window.into(FixedWindows.of(Duration.millis(windowDurationMilis))))\n+              .apply(View.asIterable());\n+    } else {\n+      sideInput = input.apply(View.asIterable());\n+    }\n+\n+    input\n+        .apply(ParDo.of(new SideInputTestWithIterable(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private static class AddTimestamps extends DoFn<KV<byte[], byte[]>, KV<byte[], byte[]>> {\n+    private static Instant timestamp = TIME;\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext c) {\n+      timestamp = TIME.plus(1L);\n+      c.outputWithTimestamp(c.element(), timestamp);\n+    }\n+  }\n+\n+  private static class SideInputTestWithList extends DoFn<KV<byte[], byte[]>, KV<byte[], byte[]>> {\n+\n+    private final PCollectionView<List<KV<byte[], byte[]>>> sideInput;\n+\n+    public SideInputTestWithList(PCollectionView<List<KV<byte[], byte[]>>> sideInput) {\n+      this.sideInput = sideInput;\n+    }\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext c) {\n+      List<KV<byte[], byte[]>> si = c.sideInput(sideInput);\n+\n+      for (KV<byte[], byte[]> sideInputElement : si) {\n+        // for every _input_ element iterate over all _sideInput_ elements\n+        // count consumed bytes, examine memory usage, etc (Metrics API).\n+        byte[] key = sideInputElement.getKey();\n+      }\n+    }\n+  }\n+\n+  private class SideInputTestWithHashMap extends DoFn<KV<byte[], byte[]>, KV<byte[], byte[]>> {", "originalCommit": "0cc55d5151584ca6c5aa1e2fb0249eab543657e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU3NDU2OQ==", "url": "https://github.com/apache/beam/pull/10949#discussion_r387574569", "bodyText": "Right, I'll rename it", "author": "mwalenia", "createdAt": "2020-03-04T10:25:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0MzY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NDg0OA==", "url": "https://github.com/apache/beam/pull/10949#discussion_r386744848", "bodyText": "It is worth documenting that the whole point of View.asList is to force it all to be read into memory so it is fast to iterate multiple times or access a given index. You could test these, too. If you don't need either of those, then View.asIterable will access lazily so it will often perform better and scale larger.", "author": "kennknowles", "createdAt": "2020-03-03T01:09:11Z", "path": "sdks/java/testing/load-tests/src/main/java/org/apache/beam/sdk/loadtests/SideInputLoadTest.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.loadtests;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import org.apache.beam.sdk.io.synthetic.SyntheticStep;\n+import org.apache.beam.sdk.options.Default;\n+import org.apache.beam.sdk.options.Description;\n+import org.apache.beam.sdk.options.Validation;\n+import org.apache.beam.sdk.testutils.metrics.ByteMonitor;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.View;\n+import org.apache.beam.sdk.transforms.windowing.FixedWindows;\n+import org.apache.beam.sdk.transforms.windowing.Window;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionView;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+\n+/**\n+ * Load test for operations involving side inputs.\n+ *\n+ * <p>The purpose of this test is to measure cost of materialization or lookup of side inputs. It\n+ * uses synthetic sources and {@link SyntheticStep} which can be parametrized to generate records\n+ * with various sizes of keys and values, impose delays in the pipeline and simulate other\n+ * performance challenges.\n+ *\n+ * <p>To run the test manually, use the following command:\n+ *\n+ * <pre>\n+ *   ./gradlew :sdks:java:testing:load-tests:run -PloadTest.args='\n+ *    --sourceOptions={\"numRecords\":2000, ...}\n+ *    --sideInputType=ITERABLE\n+ *    --accessPercentage=1\n+ *    --windowCount=200\n+ * </pre>\n+ */\n+public class SideInputLoadTest extends LoadTest<SideInputLoadTest.Options> {\n+\n+  private static final String METRICS_NAMESPACE = \"sideinput\";\n+  private static final Instant TIME = new Instant();\n+\n+  public SideInputLoadTest(String[] args) throws IOException {\n+    super(args, Options.class, METRICS_NAMESPACE);\n+  }\n+\n+  @Override\n+  void loadTest() throws IOException {\n+    Optional<SyntheticStep> syntheticStep = createStep(options.getStepOptions());\n+    PCollection<KV<byte[], byte[]>> input =\n+        pipeline\n+            .apply(readFromSource(sourceOptions))\n+            .apply(ParDo.of(new AddTimestamps()))\n+            .apply(\"Collect start time metrics\", ParDo.of(runtimeMonitor))\n+            .apply(ParDo.of(new ByteMonitor(METRICS_NAMESPACE, \"totalBytes.count\")));\n+\n+    performTestWithSideInput(\n+        input, SideInputMaterializationType.valueOf(options.getSideInputType()), syntheticStep);\n+  }\n+\n+  private void performTestWithSideInput(\n+      PCollection<KV<byte[], byte[]>> input,\n+      SideInputMaterializationType sideInputType,\n+      Optional<SyntheticStep> syntheticStep) {\n+    switch (sideInputType) {\n+      case ITERABLE:\n+        performTestWithIterable(input, syntheticStep);\n+        break;\n+      case HASHMAP:\n+        performTestWithHashMap(input, syntheticStep);\n+        break;\n+      case LIST:\n+        performTestWithList(input, syntheticStep);\n+        break;\n+    }\n+  }\n+\n+  private void performTestWithList(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<List<KV<byte[], byte[]>>> sideInput = input.apply(View.asList());\n+    input\n+        .apply(ParDo.of(new SideInputTestWithList(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private void performTestWithHashMap(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<Map<byte[], byte[]>> sideInput = input.apply(View.asMap());\n+    input\n+        .apply(ParDo.of(new SideInputTestWithHashMap(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private void performTestWithIterable(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<Iterable<KV<byte[], byte[]>>> sideInput;\n+    if (options.getWindowCount() != 0) {\n+      long windowDurationMilis = sourceOptions.numRecords / options.getWindowCount();\n+      sideInput =\n+          input\n+              .apply(Window.into(FixedWindows.of(Duration.millis(windowDurationMilis))))\n+              .apply(View.asIterable());\n+    } else {\n+      sideInput = input.apply(View.asIterable());\n+    }\n+\n+    input\n+        .apply(ParDo.of(new SideInputTestWithIterable(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private static class AddTimestamps extends DoFn<KV<byte[], byte[]>, KV<byte[], byte[]>> {\n+    private static Instant timestamp = TIME;\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext c) {\n+      timestamp = TIME.plus(1L);\n+      c.outputWithTimestamp(c.element(), timestamp);\n+    }\n+  }\n+\n+  private static class SideInputTestWithList extends DoFn<KV<byte[], byte[]>, KV<byte[], byte[]>> {\n+\n+    private final PCollectionView<List<KV<byte[], byte[]>>> sideInput;\n+\n+    public SideInputTestWithList(PCollectionView<List<KV<byte[], byte[]>>> sideInput) {\n+      this.sideInput = sideInput;\n+    }\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext c) {\n+      List<KV<byte[], byte[]>> si = c.sideInput(sideInput);\n+\n+      for (KV<byte[], byte[]> sideInputElement : si) {", "originalCommit": "0cc55d5151584ca6c5aa1e2fb0249eab543657e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NTI3MA==", "url": "https://github.com/apache/beam/pull/10949#discussion_r386745270", "bodyText": "For View.asIterable it makes the most sense to scan a random distance into the iterable. The most important use case is when you cannot read it all into a list, I think. Both cases are interesting: reading the whole iterable and reading just a prefix.", "author": "kennknowles", "createdAt": "2020-03-03T01:10:45Z", "path": "sdks/java/testing/load-tests/src/main/java/org/apache/beam/sdk/loadtests/SideInputLoadTest.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.loadtests;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import org.apache.beam.sdk.io.synthetic.SyntheticStep;\n+import org.apache.beam.sdk.options.Default;\n+import org.apache.beam.sdk.options.Description;\n+import org.apache.beam.sdk.options.Validation;\n+import org.apache.beam.sdk.testutils.metrics.ByteMonitor;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.View;\n+import org.apache.beam.sdk.transforms.windowing.FixedWindows;\n+import org.apache.beam.sdk.transforms.windowing.Window;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionView;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+\n+/**\n+ * Load test for operations involving side inputs.\n+ *\n+ * <p>The purpose of this test is to measure cost of materialization or lookup of side inputs. It\n+ * uses synthetic sources and {@link SyntheticStep} which can be parametrized to generate records\n+ * with various sizes of keys and values, impose delays in the pipeline and simulate other\n+ * performance challenges.\n+ *\n+ * <p>To run the test manually, use the following command:\n+ *\n+ * <pre>\n+ *   ./gradlew :sdks:java:testing:load-tests:run -PloadTest.args='\n+ *    --sourceOptions={\"numRecords\":2000, ...}\n+ *    --sideInputType=ITERABLE\n+ *    --accessPercentage=1\n+ *    --windowCount=200\n+ * </pre>\n+ */\n+public class SideInputLoadTest extends LoadTest<SideInputLoadTest.Options> {\n+\n+  private static final String METRICS_NAMESPACE = \"sideinput\";\n+  private static final Instant TIME = new Instant();\n+\n+  public SideInputLoadTest(String[] args) throws IOException {\n+    super(args, Options.class, METRICS_NAMESPACE);\n+  }\n+\n+  @Override\n+  void loadTest() throws IOException {\n+    Optional<SyntheticStep> syntheticStep = createStep(options.getStepOptions());\n+    PCollection<KV<byte[], byte[]>> input =\n+        pipeline\n+            .apply(readFromSource(sourceOptions))\n+            .apply(ParDo.of(new AddTimestamps()))\n+            .apply(\"Collect start time metrics\", ParDo.of(runtimeMonitor))\n+            .apply(ParDo.of(new ByteMonitor(METRICS_NAMESPACE, \"totalBytes.count\")));\n+\n+    performTestWithSideInput(\n+        input, SideInputMaterializationType.valueOf(options.getSideInputType()), syntheticStep);\n+  }\n+\n+  private void performTestWithSideInput(\n+      PCollection<KV<byte[], byte[]>> input,\n+      SideInputMaterializationType sideInputType,\n+      Optional<SyntheticStep> syntheticStep) {\n+    switch (sideInputType) {\n+      case ITERABLE:\n+        performTestWithIterable(input, syntheticStep);\n+        break;\n+      case HASHMAP:\n+        performTestWithHashMap(input, syntheticStep);\n+        break;\n+      case LIST:\n+        performTestWithList(input, syntheticStep);\n+        break;\n+    }\n+  }\n+\n+  private void performTestWithList(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<List<KV<byte[], byte[]>>> sideInput = input.apply(View.asList());\n+    input\n+        .apply(ParDo.of(new SideInputTestWithList(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private void performTestWithHashMap(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<Map<byte[], byte[]>> sideInput = input.apply(View.asMap());\n+    input\n+        .apply(ParDo.of(new SideInputTestWithHashMap(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private void performTestWithIterable(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<Iterable<KV<byte[], byte[]>>> sideInput;\n+    if (options.getWindowCount() != 0) {\n+      long windowDurationMilis = sourceOptions.numRecords / options.getWindowCount();\n+      sideInput =\n+          input\n+              .apply(Window.into(FixedWindows.of(Duration.millis(windowDurationMilis))))\n+              .apply(View.asIterable());\n+    } else {\n+      sideInput = input.apply(View.asIterable());\n+    }\n+\n+    input\n+        .apply(ParDo.of(new SideInputTestWithIterable(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private static class AddTimestamps extends DoFn<KV<byte[], byte[]>, KV<byte[], byte[]>> {\n+    private static Instant timestamp = TIME;\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext c) {\n+      timestamp = TIME.plus(1L);\n+      c.outputWithTimestamp(c.element(), timestamp);\n+    }\n+  }\n+\n+  private static class SideInputTestWithList extends DoFn<KV<byte[], byte[]>, KV<byte[], byte[]>> {\n+\n+    private final PCollectionView<List<KV<byte[], byte[]>>> sideInput;\n+\n+    public SideInputTestWithList(PCollectionView<List<KV<byte[], byte[]>>> sideInput) {\n+      this.sideInput = sideInput;\n+    }\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext c) {\n+      List<KV<byte[], byte[]>> si = c.sideInput(sideInput);\n+\n+      for (KV<byte[], byte[]> sideInputElement : si) {\n+        // for every _input_ element iterate over all _sideInput_ elements\n+        // count consumed bytes, examine memory usage, etc (Metrics API).\n+        byte[] key = sideInputElement.getKey();\n+      }\n+    }\n+  }\n+\n+  private class SideInputTestWithHashMap extends DoFn<KV<byte[], byte[]>, KV<byte[], byte[]>> {\n+\n+    private final PCollectionView<Map<byte[], byte[]>> sideInput;\n+\n+    public SideInputTestWithHashMap(PCollectionView<Map<byte[], byte[]>> sideInput) {\n+      this.sideInput = sideInput;\n+    }\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext c) {\n+      Map<byte[], byte[]> si = c.sideInput(sideInput);\n+      // access Map elements according to options - % of random access\n+      ArrayList<byte[]> keyList = new ArrayList<>(si.keySet());\n+      int size = keyList.size();\n+      int elementCount = size / options.getAccessPercentage() * 100;\n+      Random gen = new Random();\n+      for (int i = 0; i < elementCount; i++) {\n+        byte[] value = si.get(keyList.get(gen.nextInt(elementCount)));\n+      }\n+    }\n+  }\n+\n+  private class SideInputTestWithIterable extends DoFn<KV<byte[], byte[]>, KV<byte[], byte[]>> {\n+\n+    private final PCollectionView<Iterable<KV<byte[], byte[]>>> sideInput;\n+\n+    public SideInputTestWithIterable(PCollectionView<Iterable<KV<byte[], byte[]>>> sideInput) {\n+      this.sideInput = sideInput;\n+    }\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext c) {\n+      Iterable<KV<byte[], byte[]>> si = c.sideInput(sideInput);\n+      Integer accessPercentage = options.getAccessPercentage();\n+      int elementCount = (int) (sourceOptions.numRecords * accessPercentage / 100);\n+      for (KV<byte[], byte[]> sideInputElement : si) {", "originalCommit": "0cc55d5151584ca6c5aa1e2fb0249eab543657e3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NTc0Mg==", "url": "https://github.com/apache/beam/pull/10949#discussion_r386745742", "bodyText": "This part doesn't work well at high scale for some map implementations. An important use case is accessing just some keys and not others. A runner/SDK may have a separate place where they write the keySet so that you can make this call efficiently. But they may not. We don't want to make this test so sensitive to that (you could separate test efficiency of keySet). Can you calculate random keys in advance based on sourceOptions?", "author": "kennknowles", "createdAt": "2020-03-03T01:12:06Z", "path": "sdks/java/testing/load-tests/src/main/java/org/apache/beam/sdk/loadtests/SideInputLoadTest.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.loadtests;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Random;\n+import org.apache.beam.sdk.io.synthetic.SyntheticStep;\n+import org.apache.beam.sdk.options.Default;\n+import org.apache.beam.sdk.options.Description;\n+import org.apache.beam.sdk.options.Validation;\n+import org.apache.beam.sdk.testutils.metrics.ByteMonitor;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.transforms.View;\n+import org.apache.beam.sdk.transforms.windowing.FixedWindows;\n+import org.apache.beam.sdk.transforms.windowing.Window;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionView;\n+import org.joda.time.Duration;\n+import org.joda.time.Instant;\n+\n+/**\n+ * Load test for operations involving side inputs.\n+ *\n+ * <p>The purpose of this test is to measure cost of materialization or lookup of side inputs. It\n+ * uses synthetic sources and {@link SyntheticStep} which can be parametrized to generate records\n+ * with various sizes of keys and values, impose delays in the pipeline and simulate other\n+ * performance challenges.\n+ *\n+ * <p>To run the test manually, use the following command:\n+ *\n+ * <pre>\n+ *   ./gradlew :sdks:java:testing:load-tests:run -PloadTest.args='\n+ *    --sourceOptions={\"numRecords\":2000, ...}\n+ *    --sideInputType=ITERABLE\n+ *    --accessPercentage=1\n+ *    --windowCount=200\n+ * </pre>\n+ */\n+public class SideInputLoadTest extends LoadTest<SideInputLoadTest.Options> {\n+\n+  private static final String METRICS_NAMESPACE = \"sideinput\";\n+  private static final Instant TIME = new Instant();\n+\n+  public SideInputLoadTest(String[] args) throws IOException {\n+    super(args, Options.class, METRICS_NAMESPACE);\n+  }\n+\n+  @Override\n+  void loadTest() throws IOException {\n+    Optional<SyntheticStep> syntheticStep = createStep(options.getStepOptions());\n+    PCollection<KV<byte[], byte[]>> input =\n+        pipeline\n+            .apply(readFromSource(sourceOptions))\n+            .apply(ParDo.of(new AddTimestamps()))\n+            .apply(\"Collect start time metrics\", ParDo.of(runtimeMonitor))\n+            .apply(ParDo.of(new ByteMonitor(METRICS_NAMESPACE, \"totalBytes.count\")));\n+\n+    performTestWithSideInput(\n+        input, SideInputMaterializationType.valueOf(options.getSideInputType()), syntheticStep);\n+  }\n+\n+  private void performTestWithSideInput(\n+      PCollection<KV<byte[], byte[]>> input,\n+      SideInputMaterializationType sideInputType,\n+      Optional<SyntheticStep> syntheticStep) {\n+    switch (sideInputType) {\n+      case ITERABLE:\n+        performTestWithIterable(input, syntheticStep);\n+        break;\n+      case HASHMAP:\n+        performTestWithHashMap(input, syntheticStep);\n+        break;\n+      case LIST:\n+        performTestWithList(input, syntheticStep);\n+        break;\n+    }\n+  }\n+\n+  private void performTestWithList(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<List<KV<byte[], byte[]>>> sideInput = input.apply(View.asList());\n+    input\n+        .apply(ParDo.of(new SideInputTestWithList(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private void performTestWithHashMap(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<Map<byte[], byte[]>> sideInput = input.apply(View.asMap());\n+    input\n+        .apply(ParDo.of(new SideInputTestWithHashMap(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private void performTestWithIterable(\n+      PCollection<KV<byte[], byte[]>> input, Optional<SyntheticStep> syntheticStep) {\n+    applyStepIfPresent(input, \"Synthetic step\", syntheticStep);\n+    PCollectionView<Iterable<KV<byte[], byte[]>>> sideInput;\n+    if (options.getWindowCount() != 0) {\n+      long windowDurationMilis = sourceOptions.numRecords / options.getWindowCount();\n+      sideInput =\n+          input\n+              .apply(Window.into(FixedWindows.of(Duration.millis(windowDurationMilis))))\n+              .apply(View.asIterable());\n+    } else {\n+      sideInput = input.apply(View.asIterable());\n+    }\n+\n+    input\n+        .apply(ParDo.of(new SideInputTestWithIterable(sideInput)).withSideInputs(sideInput))\n+        .apply(\"Collect end time metrics\", ParDo.of(runtimeMonitor));\n+  }\n+\n+  private static class AddTimestamps extends DoFn<KV<byte[], byte[]>, KV<byte[], byte[]>> {\n+    private static Instant timestamp = TIME;\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext c) {\n+      timestamp = TIME.plus(1L);\n+      c.outputWithTimestamp(c.element(), timestamp);\n+    }\n+  }\n+\n+  private static class SideInputTestWithList extends DoFn<KV<byte[], byte[]>, KV<byte[], byte[]>> {\n+\n+    private final PCollectionView<List<KV<byte[], byte[]>>> sideInput;\n+\n+    public SideInputTestWithList(PCollectionView<List<KV<byte[], byte[]>>> sideInput) {\n+      this.sideInput = sideInput;\n+    }\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext c) {\n+      List<KV<byte[], byte[]>> si = c.sideInput(sideInput);\n+\n+      for (KV<byte[], byte[]> sideInputElement : si) {\n+        // for every _input_ element iterate over all _sideInput_ elements\n+        // count consumed bytes, examine memory usage, etc (Metrics API).\n+        byte[] key = sideInputElement.getKey();\n+      }\n+    }\n+  }\n+\n+  private class SideInputTestWithHashMap extends DoFn<KV<byte[], byte[]>, KV<byte[], byte[]>> {\n+\n+    private final PCollectionView<Map<byte[], byte[]>> sideInput;\n+\n+    public SideInputTestWithHashMap(PCollectionView<Map<byte[], byte[]>> sideInput) {\n+      this.sideInput = sideInput;\n+    }\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext c) {\n+      Map<byte[], byte[]> si = c.sideInput(sideInput);\n+      // access Map elements according to options - % of random access\n+      ArrayList<byte[]> keyList = new ArrayList<>(si.keySet());", "originalCommit": "0cc55d5151584ca6c5aa1e2fb0249eab543657e3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzU5Njg3Mw==", "url": "https://github.com/apache/beam/pull/10949#discussion_r387596873", "bodyText": "I don't know if it's possible - I'll look into it", "author": "mwalenia", "createdAt": "2020-03-04T11:07:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NTc0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTU4NjI5OQ==", "url": "https://github.com/apache/beam/pull/10949#discussion_r389586299", "bodyText": "I think calculating the keys beforehand would add a huge code overhead to the tests. I'm also still unsure how would I go about that. If you really think it would be worth it - can you give me some pointers regarding the approach to this issue?", "author": "mwalenia", "createdAt": "2020-03-09T10:52:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njc0NTc0Mg=="}], "type": "inlineReview"}, {"oid": "952392ed25f9e14309b3a49bab9468bb262d69ae", "url": "https://github.com/apache/beam/commit/952392ed25f9e14309b3a49bab9468bb262d69ae", "message": "Add windowing to all cases", "committedDate": "2020-03-05T14:12:54Z", "type": "commit"}, {"oid": "1cb172d19c9b76bc83f745bd72680dc4b152bb87", "url": "https://github.com/apache/beam/commit/1cb172d19c9b76bc83f745bd72680dc4b152bb87", "message": "Make code spotless", "committedDate": "2020-03-10T08:20:30Z", "type": "commit"}, {"oid": "8c8b51195808db5c934d32dd385aa3b61129b08b", "url": "https://github.com/apache/beam/commit/8c8b51195808db5c934d32dd385aa3b61129b08b", "message": "Calculate random keys in advance", "committedDate": "2020-03-12T15:26:47Z", "type": "commit"}, {"oid": "8c8b51195808db5c934d32dd385aa3b61129b08b", "url": "https://github.com/apache/beam/commit/8c8b51195808db5c934d32dd385aa3b61129b08b", "message": "Calculate random keys in advance", "committedDate": "2020-03-12T15:26:47Z", "type": "forcePushed"}]}