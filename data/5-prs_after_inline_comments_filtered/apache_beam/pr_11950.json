{"pr_number": 11950, "pr_title": "[BEAM-8596]: Add SplunkIO transform to write messages to Splunk", "pr_createdAt": "2020-06-08T20:22:25Z", "pr_url": "https://github.com/apache/beam/pull/11950", "timeline": [{"oid": "71e805e1fac82d234bcec32d50871e213d60fad4", "url": "https://github.com/apache/beam/commit/71e805e1fac82d234bcec32d50871e213d60fad4", "message": "[BEAM-8596]: Add SplunkIO transform to write messages to Splunk", "committedDate": "2020-06-08T19:58:58Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk5MjQ4NQ==", "url": "https://github.com/apache/beam/pull/11950#discussion_r436992485", "bodyText": "I recommend you use @DefaultSchema(AutoValueSchema.class) for this class instead of writing a custom coder.", "author": "pabloem", "createdAt": "2020-06-08T20:50:05Z", "path": "sdks/java/io/splunk/src/main/java/org/apache/beam/sdk/io/splunk/SplunkEvent.java", "diffHunk": "@@ -0,0 +1,159 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.splunk;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.auto.value.AutoValue;\n+import com.google.gson.annotations.SerializedName;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * A {@link SplunkEvent} describes a single payload sent to Splunk's Http Event Collector (HEC)\n+ * endpoint.\n+ *\n+ * <p>Each object represents a single event and related metadata elements such as:\n+ *\n+ * <ul>\n+ *   <li>time\n+ *   <li>host\n+ *   <li>source\n+ *   <li>sourceType\n+ *   <li>index\n+ * </ul>\n+ */\n+@AutoValue\n+public abstract class SplunkEvent {", "originalCommit": "71e805e1fac82d234bcec32d50871e213d60fad4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAxMTM1OA==", "url": "https://github.com/apache/beam/pull/11950#discussion_r437011358", "bodyText": "see the AutoValue section of https://beam.apache.org/documentation/programming-guide/#creating-schemas - there's also a way to provide a Builder annotation", "author": "pabloem", "createdAt": "2020-06-08T21:27:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk5MjQ4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzYwNjU5OA==", "url": "https://github.com/apache/beam/pull/11950#discussion_r437606598", "bodyText": "Thank for the pointer @pabloem\nI have switched from using custom coders to DefaultSchema with AutoValueSchema.\nI noticed that in AutoValueUtils that the build method should literally be called 'build'. This required me to change some of my method names.", "author": "sabhyankar", "createdAt": "2020-06-09T17:41:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk5MjQ4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwNzk1Nw==", "url": "https://github.com/apache/beam/pull/11950#discussion_r437007957", "bodyText": "In Beam, these PTransform builders are not really used as such. Do you think it makes sense to have a fluent, factory-type class that doesn't require a builder?\ne.g.\n *                 SplunkIO.write()\n *                     .withToken(token)\n *                     .withUrl(url)\n *                     .withBatchCount(batchCount)\n *                     .withParallelism(parallelism)\n *                     .withDisableCertificateValidation(true)", "author": "pabloem", "createdAt": "2020-06-08T21:20:08Z", "path": "sdks/java/io/splunk/src/main/java/org/apache/beam/sdk/io/splunk/SplunkIO.java", "diffHunk": "@@ -0,0 +1,359 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.splunk;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.auto.value.AutoValue;\n+import java.util.concurrent.ThreadLocalRandom;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.annotations.Experimental.Kind;\n+import org.apache.beam.sdk.coders.BigEndianIntegerCoder;\n+import org.apache.beam.sdk.coders.KvCoder;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ParDo;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.MoreObjects;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * An unbounded sink for Splunk's Http Event Collector (HEC).\n+ *\n+ * <p>For more information, see the online documentation at <a\n+ * href=\"https://dev.splunk.com/enterprise/docs/dataapps/httpeventcollector/\">Splunk HEC</a>.\n+ *\n+ * <h3>Writing to Splunk's HEC</h3>\n+ *\n+ * <p>The {@link SplunkIO} class provides a {@link PTransform} that allows writing {@link\n+ * SplunkEvent} messages into a Splunk HEC end point.\n+ *\n+ * <p>It takes as an input a {@link PCollection PCollection&lt;SplunkEvent&gt;}, where each {@link\n+ * SplunkEvent} represents an event to be published to HEC.\n+ *\n+ * <p>To configure a {@link SplunkIO}, you must provide at a minimum:\n+ *\n+ * <ul>\n+ *   <li>url - HEC endpoint URL.\n+ *   <li>token - HEC endpoint token.\n+ * </ul>\n+ *\n+ * <p>The {@link SplunkIO} transform can be customized further by optionally specifying:\n+ *\n+ * <ul>\n+ *   <li>parallelism - Number of parallel requests to the HEC.\n+ *   <li>batchCount - Number of events in a single batch.\n+ *   <li>disableCertificateValidation - Whether to disable ssl validation (useful for self-signed\n+ *       certificates)\n+ * </ul>\n+ *\n+ * <p>This transform will return any non-transient write failures via a {@link PCollection\n+ * PCollection&lt;SplunkWriteError&gt;}, where each {@link SplunkWriteError} captures the error that\n+ * occurred while attempting to write to HEC. These can be published to a dead-letter sink or\n+ * reprocessed.\n+ *\n+ * <p>For example:\n+ *\n+ * <pre>{@code\n+ * PCollection<SplunkEvent> events = ...;\n+ *\n+ * PCollection<SplunkWriteError> errors =\n+ *         events.apply(\"WriteToSplunk\",\n+ *              SplunkIO.writeBuilder()", "originalCommit": "71e805e1fac82d234bcec32d50871e213d60fad4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwOTAxNQ==", "url": "https://github.com/apache/beam/pull/11950#discussion_r437009015", "bodyText": "note the example of PubsubIO, where the builder is used internally as part of the implementation, but externally, the built transform is passed around: https://github.com/apache/beam/blob/master/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubIO.java#L931-L965", "author": "pabloem", "createdAt": "2020-06-08T21:22:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwNzk1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzY0MDk4Mg==", "url": "https://github.com/apache/beam/pull/11950#discussion_r437640982", "bodyText": "Thanks for that input! Switched to a fluent factory pattern for the SplunkIO transform.", "author": "sabhyankar", "createdAt": "2020-06-09T18:40:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwNzk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAxMzg2MQ==", "url": "https://github.com/apache/beam/pull/11950#discussion_r437013861", "bodyText": "TODO(pablo) - review http event publisher", "author": "pabloem", "createdAt": "2020-06-08T21:33:08Z", "path": "sdks/java/io/splunk/src/main/java/org/apache/beam/sdk/io/splunk/SplunkEventWriter.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.splunk;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.api.client.http.HttpResponse;\n+import com.google.api.client.http.HttpResponseException;\n+import com.google.auto.value.AutoValue;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.state.BagState;\n+import org.apache.beam.sdk.state.StateSpec;\n+import org.apache.beam.sdk.state.StateSpecs;\n+import org.apache.beam.sdk.state.TimeDomain;\n+import org.apache.beam.sdk.state.Timer;\n+import org.apache.beam.sdk.state.TimerSpec;\n+import org.apache.beam.sdk.state.TimerSpecs;\n+import org.apache.beam.sdk.state.ValueState;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.MoreObjects;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.joda.time.Duration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** A {@link DoFn} to write {@link SplunkEvent}s to Splunk's HEC endpoint. */\n+@AutoValue\n+abstract class SplunkEventWriter extends DoFn<KV<Integer, SplunkEvent>, SplunkWriteError> {\n+\n+  private static final Integer DEFAULT_BATCH_COUNT = 1;\n+  private static final Boolean DEFAULT_DISABLE_CERTIFICATE_VALIDATION = false;\n+  private static final Logger LOG = LoggerFactory.getLogger(SplunkEventWriter.class);\n+  private static final long DEFAULT_FLUSH_DELAY = 2;\n+  private static final Counter INPUT_COUNTER =\n+      Metrics.counter(SplunkEventWriter.class, \"inbound-events\");\n+  private static final Counter SUCCESS_WRITES =\n+      Metrics.counter(SplunkEventWriter.class, \"outbound-successful-events\");\n+  private static final Counter FAILED_WRITES =\n+      Metrics.counter(SplunkEventWriter.class, \"outbound-failed-events\");\n+  private static final String BUFFER_STATE_NAME = \"buffer\";\n+  private static final String COUNT_STATE_NAME = \"count\";\n+  private static final String TIME_ID_NAME = \"expiry\";\n+\n+  @StateId(BUFFER_STATE_NAME)\n+  private final StateSpec<BagState<SplunkEvent>> buffer = StateSpecs.bag();\n+\n+  @StateId(COUNT_STATE_NAME)\n+  private final StateSpec<ValueState<Long>> count = StateSpecs.value();\n+\n+  @TimerId(TIME_ID_NAME)\n+  private final TimerSpec expirySpec = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+  private Integer batchCount;\n+  private Boolean disableValidation;\n+  private HttpEventPublisher publisher;\n+\n+  private static final Gson GSON =\n+      new GsonBuilder().setFieldNamingStrategy(f -> f.getName().toLowerCase()).create();\n+\n+  /** A builder class for creating a {@link SplunkEventWriter}. */\n+  static Builder newBuilder() {\n+    return new AutoValue_SplunkEventWriter.Builder();\n+  }\n+\n+  @Nullable\n+  abstract ValueProvider<String> url();\n+\n+  @Nullable\n+  abstract ValueProvider<String> token();\n+\n+  @Nullable\n+  abstract ValueProvider<Boolean> disableCertificateValidation();\n+\n+  @Nullable\n+  abstract ValueProvider<Integer> inputBatchCount();\n+\n+  @Setup\n+  public void setup() {\n+\n+    checkArgument(url().isAccessible(), \"url is required for writing events.\");\n+    checkArgument(token().isAccessible(), \"Access token is required for writing events.\");\n+\n+    // Either user supplied or default batchCount.\n+    if (batchCount == null) {\n+\n+      if (inputBatchCount() != null) {\n+        batchCount = inputBatchCount().get();\n+      }\n+\n+      batchCount = MoreObjects.firstNonNull(batchCount, DEFAULT_BATCH_COUNT);\n+      LOG.info(\"Batch count set to: {}\", batchCount);\n+    }\n+\n+    // Either user supplied or default disableValidation.\n+    if (disableValidation == null) {\n+\n+      if (disableCertificateValidation() != null) {\n+        disableValidation = disableCertificateValidation().get();\n+      }\n+\n+      disableValidation =\n+          MoreObjects.firstNonNull(disableValidation, DEFAULT_DISABLE_CERTIFICATE_VALIDATION);\n+      LOG.info(\"Disable certificate validation set to: {}\", disableValidation);\n+    }\n+\n+    try {\n+      HttpEventPublisher.Builder builder =", "originalCommit": "71e805e1fac82d234bcec32d50871e213d60fad4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9f9ef7a039676ccfaa2d8e2f3edfa5eeff83aea5", "url": "https://github.com/apache/beam/commit/9f9ef7a039676ccfaa2d8e2f3edfa5eeff83aea5", "message": "Use AutoValueSchema instead of custom Coder", "committedDate": "2020-06-09T17:37:51Z", "type": "commit"}, {"oid": "332a896b57aacf47d739b9f8d8b71ed5714fb16e", "url": "https://github.com/apache/beam/commit/332a896b57aacf47d739b9f8d8b71ed5714fb16e", "message": "SplunkIO switch from builder to fluent factory pattern", "committedDate": "2020-06-09T18:39:39Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc0NzAyMg==", "url": "https://github.com/apache/beam/pull/11950#discussion_r437747022", "bodyText": "Is it possible to not need an auth token? If so, should the token be added in a factory method instead? Or perhaps with a second constructor?\nUp to you. You know this better.", "author": "pabloem", "createdAt": "2020-06-09T22:01:01Z", "path": "sdks/java/io/splunk/src/main/java/org/apache/beam/sdk/io/splunk/SplunkIO.java", "diffHunk": "@@ -77,32 +78,48 @@\n  *\n  * PCollection<SplunkWriteError> errors =\n  *         events.apply(\"WriteToSplunk\",\n- *              SplunkIO.writeBuilder()\n- *                     .withToken(token)\n- *                     .withUrl(url)\n- *                     .withBatchCount(batchCount)\n- *                     .withParallelism(parallelism)\n- *                     .withDisableCertificateValidation(true)\n- *                     .build());\n+ *              SplunkIO.write(url, token)\n+ *                  .withBatchCount(batchCount)\n+ *                  .withParallelism(parallelism)\n+ *                  .withDisableCertificateValidation(true));\n  * }</pre>\n  */\n @Experimental(Kind.SOURCE_SINK)\n public class SplunkIO {\n \n+  /**\n+   * Write to Splunk's Http Event Collector (HEC).\n+   *\n+   * @param url splunk hec url\n+   * @param token splunk hec authentication token", "originalCommit": "332a896b57aacf47d739b9f8d8b71ed5714fb16e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3NDMxOQ==", "url": "https://github.com/apache/beam/pull/11950#discussion_r438774319", "bodyText": "A token is required in order to use HEC and each end point has at-least one token. So this would be a required param. (See: Using http event collector)", "author": "sabhyankar", "createdAt": "2020-06-11T13:18:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc0NzAyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4NDg0Mw==", "url": "https://github.com/apache/beam/pull/11950#discussion_r438284843", "bodyText": "I wonder if this should be processing time, to avoid getting stuck when the watermark slows down?", "author": "pabloem", "createdAt": "2020-06-10T17:16:01Z", "path": "sdks/java/io/splunk/src/main/java/org/apache/beam/sdk/io/splunk/SplunkEventWriter.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.splunk;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.api.client.http.HttpResponse;\n+import com.google.api.client.http.HttpResponseException;\n+import com.google.auto.value.AutoValue;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.state.BagState;\n+import org.apache.beam.sdk.state.StateSpec;\n+import org.apache.beam.sdk.state.StateSpecs;\n+import org.apache.beam.sdk.state.TimeDomain;\n+import org.apache.beam.sdk.state.Timer;\n+import org.apache.beam.sdk.state.TimerSpec;\n+import org.apache.beam.sdk.state.TimerSpecs;\n+import org.apache.beam.sdk.state.ValueState;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.MoreObjects;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.joda.time.Duration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** A {@link DoFn} to write {@link SplunkEvent}s to Splunk's HEC endpoint. */\n+@AutoValue\n+abstract class SplunkEventWriter extends DoFn<KV<Integer, SplunkEvent>, SplunkWriteError> {\n+\n+  private static final Integer DEFAULT_BATCH_COUNT = 1;\n+  private static final Boolean DEFAULT_DISABLE_CERTIFICATE_VALIDATION = false;\n+  private static final Logger LOG = LoggerFactory.getLogger(SplunkEventWriter.class);\n+  private static final long DEFAULT_FLUSH_DELAY = 2;\n+  private static final Counter INPUT_COUNTER =\n+      Metrics.counter(SplunkEventWriter.class, \"inbound-events\");\n+  private static final Counter SUCCESS_WRITES =\n+      Metrics.counter(SplunkEventWriter.class, \"outbound-successful-events\");\n+  private static final Counter FAILED_WRITES =\n+      Metrics.counter(SplunkEventWriter.class, \"outbound-failed-events\");\n+  private static final String BUFFER_STATE_NAME = \"buffer\";\n+  private static final String COUNT_STATE_NAME = \"count\";\n+  private static final String TIME_ID_NAME = \"expiry\";\n+\n+  @StateId(BUFFER_STATE_NAME)\n+  private final StateSpec<BagState<SplunkEvent>> buffer = StateSpecs.bag();\n+\n+  @StateId(COUNT_STATE_NAME)\n+  private final StateSpec<ValueState<Long>> count = StateSpecs.value();\n+\n+  @TimerId(TIME_ID_NAME)\n+  private final TimerSpec expirySpec = TimerSpecs.timer(TimeDomain.EVENT_TIME);", "originalCommit": "332a896b57aacf47d739b9f8d8b71ed5714fb16e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgyOTA4OQ==", "url": "https://github.com/apache/beam/pull/11950#discussion_r438829089", "bodyText": "Good catch! Done!", "author": "sabhyankar", "createdAt": "2020-06-11T14:29:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4NDg0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4NjY1MQ==", "url": "https://github.com/apache/beam/pull/11950#discussion_r438286651", "bodyText": "I guess in this case you don't need the StateId annotations, as the state handles are passed when you call this function, and are not filled in by Beam", "author": "pabloem", "createdAt": "2020-06-10T17:19:10Z", "path": "sdks/java/io/splunk/src/main/java/org/apache/beam/sdk/io/splunk/SplunkEventWriter.java", "diffHunk": "@@ -0,0 +1,395 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.splunk;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.api.client.http.HttpResponse;\n+import com.google.api.client.http.HttpResponseException;\n+import com.google.auto.value.AutoValue;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+import org.apache.beam.sdk.metrics.Counter;\n+import org.apache.beam.sdk.metrics.Metrics;\n+import org.apache.beam.sdk.options.ValueProvider;\n+import org.apache.beam.sdk.state.BagState;\n+import org.apache.beam.sdk.state.StateSpec;\n+import org.apache.beam.sdk.state.StateSpecs;\n+import org.apache.beam.sdk.state.TimeDomain;\n+import org.apache.beam.sdk.state.Timer;\n+import org.apache.beam.sdk.state.TimerSpec;\n+import org.apache.beam.sdk.state.TimerSpecs;\n+import org.apache.beam.sdk.state.ValueState;\n+import org.apache.beam.sdk.transforms.DoFn;\n+import org.apache.beam.sdk.transforms.windowing.BoundedWindow;\n+import org.apache.beam.sdk.values.KV;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.MoreObjects;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.joda.time.Duration;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/** A {@link DoFn} to write {@link SplunkEvent}s to Splunk's HEC endpoint. */\n+@AutoValue\n+abstract class SplunkEventWriter extends DoFn<KV<Integer, SplunkEvent>, SplunkWriteError> {\n+\n+  private static final Integer DEFAULT_BATCH_COUNT = 1;\n+  private static final Boolean DEFAULT_DISABLE_CERTIFICATE_VALIDATION = false;\n+  private static final Logger LOG = LoggerFactory.getLogger(SplunkEventWriter.class);\n+  private static final long DEFAULT_FLUSH_DELAY = 2;\n+  private static final Counter INPUT_COUNTER =\n+      Metrics.counter(SplunkEventWriter.class, \"inbound-events\");\n+  private static final Counter SUCCESS_WRITES =\n+      Metrics.counter(SplunkEventWriter.class, \"outbound-successful-events\");\n+  private static final Counter FAILED_WRITES =\n+      Metrics.counter(SplunkEventWriter.class, \"outbound-failed-events\");\n+  private static final String BUFFER_STATE_NAME = \"buffer\";\n+  private static final String COUNT_STATE_NAME = \"count\";\n+  private static final String TIME_ID_NAME = \"expiry\";\n+\n+  @StateId(BUFFER_STATE_NAME)\n+  private final StateSpec<BagState<SplunkEvent>> buffer = StateSpecs.bag();\n+\n+  @StateId(COUNT_STATE_NAME)\n+  private final StateSpec<ValueState<Long>> count = StateSpecs.value();\n+\n+  @TimerId(TIME_ID_NAME)\n+  private final TimerSpec expirySpec = TimerSpecs.timer(TimeDomain.EVENT_TIME);\n+\n+  private Integer batchCount;\n+  private Boolean disableValidation;\n+  private HttpEventPublisher publisher;\n+\n+  private static final Gson GSON =\n+      new GsonBuilder().setFieldNamingStrategy(f -> f.getName().toLowerCase()).create();\n+\n+  /** A builder class for creating a {@link SplunkEventWriter}. */\n+  static Builder newBuilder() {\n+    return new AutoValue_SplunkEventWriter.Builder();\n+  }\n+\n+  @Nullable\n+  abstract ValueProvider<String> url();\n+\n+  @Nullable\n+  abstract ValueProvider<String> token();\n+\n+  @Nullable\n+  abstract ValueProvider<Boolean> disableCertificateValidation();\n+\n+  @Nullable\n+  abstract ValueProvider<Integer> inputBatchCount();\n+\n+  @Setup\n+  public void setup() {\n+\n+    checkArgument(url().isAccessible(), \"url is required for writing events.\");\n+    checkArgument(token().isAccessible(), \"Access token is required for writing events.\");\n+\n+    // Either user supplied or default batchCount.\n+    if (batchCount == null) {\n+\n+      if (inputBatchCount() != null) {\n+        batchCount = inputBatchCount().get();\n+      }\n+\n+      batchCount = MoreObjects.firstNonNull(batchCount, DEFAULT_BATCH_COUNT);\n+      LOG.info(\"Batch count set to: {}\", batchCount);\n+    }\n+\n+    // Either user supplied or default disableValidation.\n+    if (disableValidation == null) {\n+\n+      if (disableCertificateValidation() != null) {\n+        disableValidation = disableCertificateValidation().get();\n+      }\n+\n+      disableValidation =\n+          MoreObjects.firstNonNull(disableValidation, DEFAULT_DISABLE_CERTIFICATE_VALIDATION);\n+      LOG.info(\"Disable certificate validation set to: {}\", disableValidation);\n+    }\n+\n+    try {\n+      HttpEventPublisher.Builder builder =\n+          HttpEventPublisher.newBuilder()\n+              .withUrl(url().get())\n+              .withToken(token().get())\n+              .withDisableCertificateValidation(disableValidation);\n+\n+      publisher = builder.build();\n+      LOG.info(\"Successfully created HttpEventPublisher\");\n+\n+    } catch (NoSuchAlgorithmException\n+        | KeyStoreException\n+        | KeyManagementException\n+        | UnsupportedEncodingException e) {\n+      LOG.error(\"Error creating HttpEventPublisher: {}\", e.getMessage());\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  @ProcessElement\n+  public void processElement(\n+      @Element KV<Integer, SplunkEvent> input,\n+      OutputReceiver<SplunkWriteError> receiver,\n+      BoundedWindow window,\n+      @StateId(BUFFER_STATE_NAME) BagState<SplunkEvent> bufferState,\n+      @StateId(COUNT_STATE_NAME) ValueState<Long> countState,\n+      @TimerId(TIME_ID_NAME) Timer timer)\n+      throws IOException {\n+\n+    Long count = MoreObjects.<Long>firstNonNull(countState.read(), 0L);\n+    SplunkEvent event = input.getValue();\n+    INPUT_COUNTER.inc();\n+    bufferState.add(event);\n+    count += 1;\n+    countState.write(count);\n+    timer.offset(Duration.standardSeconds(DEFAULT_FLUSH_DELAY)).setRelative();\n+\n+    if (count >= batchCount) {\n+\n+      LOG.info(\"Flushing batch of {} events\", count);\n+      flush(receiver, bufferState, countState);\n+    }\n+  }\n+\n+  @OnTimer(TIME_ID_NAME)\n+  public void onExpiry(\n+      OutputReceiver<SplunkWriteError> receiver,\n+      @StateId(BUFFER_STATE_NAME) BagState<SplunkEvent> bufferState,\n+      @StateId(COUNT_STATE_NAME) ValueState<Long> countState)\n+      throws IOException {\n+\n+    if (MoreObjects.<Long>firstNonNull(countState.read(), 0L) > 0) {\n+      LOG.info(\"Flushing window with {} events\", countState.read());\n+      flush(receiver, bufferState, countState);\n+    }\n+  }\n+\n+  @Teardown\n+  public void tearDown() {\n+    if (this.publisher != null) {\n+      try {\n+        this.publisher.close();\n+        LOG.info(\"Successfully closed HttpEventPublisher\");\n+\n+      } catch (IOException e) {\n+        LOG.warn(\"Received exception while closing HttpEventPublisher: {}\", e.getMessage());\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Flushes a batch of requests via {@link HttpEventPublisher}.\n+   *\n+   * @param receiver Receiver to write {@link SplunkWriteError}s to\n+   */\n+  private void flush(\n+      OutputReceiver<SplunkWriteError> receiver,\n+      @StateId(BUFFER_STATE_NAME) BagState<SplunkEvent> bufferState,\n+      @StateId(COUNT_STATE_NAME) ValueState<Long> countState)", "originalCommit": "332a896b57aacf47d739b9f8d8b71ed5714fb16e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODgyOTMwOA==", "url": "https://github.com/apache/beam/pull/11950#discussion_r438829308", "bodyText": "Done", "author": "sabhyankar", "createdAt": "2020-06-11T14:29:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4NjY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2NTY3Ng==", "url": "https://github.com/apache/beam/pull/11950#discussion_r438365676", "bodyText": "Does this add newline characters or some other way to separate JSON objects? Is this not necessary?", "author": "pabloem", "createdAt": "2020-06-10T19:42:04Z", "path": "sdks/java/io/splunk/src/main/java/org/apache/beam/sdk/io/splunk/HttpEventPublisher.java", "diffHunk": "@@ -0,0 +1,346 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.splunk;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import com.google.api.client.http.ByteArrayContent;\n+import com.google.api.client.http.GenericUrl;\n+import com.google.api.client.http.HttpBackOffUnsuccessfulResponseHandler;\n+import com.google.api.client.http.HttpBackOffUnsuccessfulResponseHandler.BackOffRequired;\n+import com.google.api.client.http.HttpContent;\n+import com.google.api.client.http.HttpMediaType;\n+import com.google.api.client.http.HttpRequest;\n+import com.google.api.client.http.HttpRequestFactory;\n+import com.google.api.client.http.HttpResponse;\n+import com.google.api.client.http.apache.v2.ApacheHttpTransport;\n+import com.google.api.client.util.ExponentialBackOff;\n+import com.google.auto.value.AutoValue;\n+import com.google.gson.Gson;\n+import com.google.gson.GsonBuilder;\n+import java.io.IOException;\n+import java.io.UnsupportedEncodingException;\n+import java.security.KeyManagementException;\n+import java.security.KeyStoreException;\n+import java.security.NoSuchAlgorithmException;\n+import java.util.List;\n+import javax.annotation.Nullable;\n+import javax.net.ssl.HostnameVerifier;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.annotations.VisibleForTesting;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Joiner;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.http.client.config.CookieSpecs;\n+import org.apache.http.client.config.RequestConfig;\n+import org.apache.http.conn.ssl.DefaultHostnameVerifier;\n+import org.apache.http.conn.ssl.NoopHostnameVerifier;\n+import org.apache.http.conn.ssl.SSLConnectionSocketFactory;\n+import org.apache.http.conn.ssl.TrustStrategy;\n+import org.apache.http.impl.client.CloseableHttpClient;\n+import org.apache.http.impl.client.HttpClientBuilder;\n+import org.apache.http.ssl.SSLContextBuilder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * A utility class that helps write {@link SplunkEvent} records to Splunk's Http Event Collector\n+ * (HEC) endpoint.\n+ */\n+@AutoValue\n+abstract class HttpEventPublisher {\n+\n+  private static final Logger LOG = LoggerFactory.getLogger(HttpEventPublisher.class);\n+\n+  private static final int DEFAULT_MAX_CONNECTIONS = 1;\n+\n+  private static final boolean DEFAULT_DISABLE_CERTIFICATE_VALIDATION = false;\n+\n+  private static final Gson GSON =\n+      new GsonBuilder().setFieldNamingStrategy(f -> f.getName().toLowerCase()).create();\n+\n+  @VisibleForTesting static final String HEC_URL_PATH = \"services/collector/event\";\n+\n+  private static final HttpMediaType MEDIA_TYPE =\n+      new HttpMediaType(\"application/json;profile=urn:splunk:event:1.0;charset=utf-8\");\n+\n+  private static final String CONTENT_TYPE =\n+      Joiner.on('/').join(MEDIA_TYPE.getType(), MEDIA_TYPE.getSubType());\n+\n+  private static final String AUTHORIZATION_SCHEME = \"Splunk %s\";\n+\n+  private static final String HTTPS_PROTOCOL_PREFIX = \"https\";\n+\n+  /** Provides a builder for creating a {@link HttpEventPublisher}. */\n+  static Builder newBuilder() {\n+    return new AutoValue_HttpEventPublisher.Builder();\n+  }\n+\n+  abstract ApacheHttpTransport transport();\n+\n+  abstract HttpRequestFactory requestFactory();\n+\n+  abstract GenericUrl genericUrl();\n+\n+  abstract String token();\n+\n+  @Nullable\n+  abstract Integer maxElapsedMillis();\n+\n+  abstract Boolean disableCertificateValidation();\n+\n+  /**\n+   * Executes a POST for the list of {@link SplunkEvent} objects into Splunk's Http Event Collector\n+   * endpoint.\n+   *\n+   * @param events list of {@link SplunkEvent}s\n+   * @return {@link HttpResponse} for the POST\n+   */\n+  HttpResponse execute(List<SplunkEvent> events) throws IOException {\n+\n+    HttpContent content = getContent(events);\n+    HttpRequest request = requestFactory().buildPostRequest(genericUrl(), content);\n+\n+    HttpBackOffUnsuccessfulResponseHandler responseHandler =\n+        new HttpBackOffUnsuccessfulResponseHandler(getConfiguredBackOff());\n+\n+    responseHandler.setBackOffRequired(BackOffRequired.ON_SERVER_ERROR);\n+\n+    request.setUnsuccessfulResponseHandler(responseHandler);\n+    setHeaders(request, token());\n+\n+    return request.execute();\n+  }\n+\n+  /**\n+   * Same as {@link HttpEventPublisher#execute(List)} but with a single {@link SplunkEvent}.\n+   *\n+   * @param event {@link SplunkEvent} object\n+   */\n+  HttpResponse execute(SplunkEvent event) throws IOException {\n+    return this.execute(ImmutableList.of(event));\n+  }\n+\n+  /**\n+   * Returns an {@link ExponentialBackOff} with the right settings.\n+   *\n+   * @return {@link ExponentialBackOff} object\n+   */\n+  @VisibleForTesting\n+  ExponentialBackOff getConfiguredBackOff() {\n+    return new ExponentialBackOff.Builder().setMaxElapsedTimeMillis(maxElapsedMillis()).build();\n+  }\n+\n+  /** Shutsdown connection manager and releases all resources. */\n+  void close() throws IOException {\n+    if (transport() != null) {\n+      LOG.info(\"Closing publisher transport.\");\n+      transport().shutdown();\n+    }\n+  }\n+\n+  /**\n+   * Utility method to set Authorization and other relevant http headers into the {@link\n+   * HttpRequest}.\n+   *\n+   * @param request {@link HttpRequest} object to add headers to\n+   * @param token Splunk's HEC authorization token\n+   */\n+  private void setHeaders(HttpRequest request, String token) {\n+    request.getHeaders().setAuthorization(String.format(AUTHORIZATION_SCHEME, token));\n+  }\n+\n+  /**\n+   * Marshals a list of {@link SplunkEvent}s into an {@link HttpContent} object that can be used to\n+   * create an {@link HttpRequest}.\n+   *\n+   * @param events list of {@link SplunkEvent}s\n+   * @return {@link HttpContent} that can be used to create an {@link HttpRequest}.\n+   */\n+  @VisibleForTesting\n+  HttpContent getContent(List<SplunkEvent> events) {\n+    String payload = getStringPayload(events);\n+    LOG.debug(\"Payload content: {}\", payload);\n+    return ByteArrayContent.fromString(CONTENT_TYPE, payload);\n+  }\n+\n+  /** Extracts the payload string from a list of {@link SplunkEvent}s. */\n+  @VisibleForTesting\n+  String getStringPayload(List<SplunkEvent> events) {\n+    StringBuilder sb = new StringBuilder();\n+    events.forEach(event -> sb.append(GSON.toJson(event)));", "originalCommit": "332a896b57aacf47d739b9f8d8b71ed5714fb16e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODc3NzE4Nw==", "url": "https://github.com/apache/beam/pull/11950#discussion_r438777187", "bodyText": "Its not necessary to have newlines or separators as the batch protocol for Splunk's HEC is simple event objects stacked one after the other and not necessarily in a JSON array.", "author": "sabhyankar", "createdAt": "2020-06-11T13:23:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODM2NTY3Ng=="}], "type": "inlineReview"}, {"oid": "4ee027f53657c748799c49b110c06d4239763c4d", "url": "https://github.com/apache/beam/commit/4ee027f53657c748799c49b110c06d4239763c4d", "message": "Build file change and switch to TimeDomain.PROCESSING_TIME", "committedDate": "2020-06-11T14:28:47Z", "type": "commit"}]}