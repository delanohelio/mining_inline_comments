{"pr_number": 11096, "pr_title": "[BEAM-9399] Change the redirection of System.err to be a custom PrintStream", "pr_createdAt": "2020-03-11T00:14:16Z", "pr_url": "https://github.com/apache/beam/pull/11096", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA3MTMzOQ==", "url": "https://github.com/apache/beam/pull/11096#discussion_r391071339", "bodyText": "Would it be an issue for multi-byte wide characters that have been split?", "author": "lukecwik", "createdAt": "2020-03-11T15:48:19Z", "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/logging/JulHandlerPrintStreamAdapterFactory.java", "diffHunk": "@@ -37,114 +37,272 @@\n class JulHandlerPrintStreamAdapterFactory {\n   private static final AtomicBoolean outputWarning = new AtomicBoolean(false);\n \n-  /**\n-   * Creates a {@link PrintStream} which redirects all output to the JUL {@link Handler} with the\n-   * specified {@code loggerName} and {@code level}.\n-   */\n-  static PrintStream create(Handler handler, String loggerName, Level messageLevel) {\n-    try {\n-      return new PrintStream(\n-          new JulHandlerAdapterOutputStream(handler, loggerName, messageLevel),\n-          false,\n-          StandardCharsets.UTF_8.name());\n-    } catch (UnsupportedEncodingException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n-\n-  /**\n-   * An output stream adapter which is able to take a stream of UTF-8 data and output to a named JUL\n-   * log handler. The log messages will be buffered until the system dependent new line separator is\n-   * seen, at which point the buffered string will be output.\n-   */\n-  private static class JulHandlerAdapterOutputStream extends OutputStream {\n+  private static class JulHandlerPrintStream extends PrintStream {\n     private static final String LOGGING_DISCLAIMER =\n         String.format(\n             \"Please use a logger instead of System.out or System.err.%n\"\n                 + \"Please switch to using org.slf4j.Logger.%n\"\n                 + \"See: https://cloud.google.com/dataflow/pipelines/logging\");\n-    // This limits the number of bytes which we buffer in case we don't see a newline character.\n-    private static final int BUFFER_LIMIT = 1 << 14; // 16384 bytes\n-    private static final byte[] NEW_LINE = System.lineSeparator().getBytes(StandardCharsets.UTF_8);\n+    // This limits the number of bytes which we buffer in case we don't have a flush.\n+    private static final int BUFFER_LIMIT = 1 << 10; // 1024 chars\n \n     /** Hold reference of named logger to check configured {@link Level}. */\n     private Logger logger;\n \n     private Handler handler;\n     private String loggerName;\n-    private ByteArrayOutputStream baos;\n+    private StringBuilder buffer;\n     private Level messageLevel;\n-    private int matched = 0;\n \n-    private JulHandlerAdapterOutputStream(Handler handler, String loggerName, Level logLevel) {\n+    private JulHandlerPrintStream(Handler handler, String loggerName, Level logLevel) {\n+      super(\n+          new OutputStream() {\n+            @Override\n+            public void write(int i) throws IOException {\n+              throw new RuntimeException(\"All methods should be overwritten so this is unused\");\n+            }\n+          });\n       this.handler = handler;\n       this.loggerName = loggerName;\n       this.messageLevel = logLevel;\n       this.logger = Logger.getLogger(loggerName);\n-      this.baos = new ByteArrayOutputStream(BUFFER_LIMIT);\n+      this.buffer = new StringBuilder(BUFFER_LIMIT);\n     }\n \n     @Override\n-    public void write(int b) {\n-      if (outputWarning.compareAndSet(false, true)) {\n-        publish(Level.WARNING, LOGGING_DISCLAIMER);\n+    public void flush() {\n+      publish(flushToString());\n+    }\n+\n+    private synchronized String flushToString() {\n+      if (buffer.length() > 0 && buffer.charAt(buffer.length() - 1) == '\\n') {\n+        buffer.setLength(buffer.length() - 1);\n       }\n+      String result = buffer.toString();\n+      buffer.setLength(0);\n+      return result;\n+    }\n \n-      baos.write(b);\n-      // Check to see if the next byte matches further into new line string.\n-      if (NEW_LINE[matched] == b) {\n-        matched += 1;\n-        // If we have matched the entire new line, output the contents of the buffer.\n-        if (matched == NEW_LINE.length) {\n-          output();\n-        }\n-      } else {\n-        // Reset the match\n-        matched = 0;\n+    @Override\n+    public void close() {\n+      flush();\n+    }\n+\n+    @Override\n+    public boolean checkError() {\n+      return false;\n+    }\n+\n+    @Override\n+    public synchronized void write(int i) {\n+      buffer.append(i);\n+    }\n+\n+    @Override\n+    public void write(byte[] a, int start, int limit) {\n+      // XXX this enforces decoding on boundaries where before it didn't, does that matter?", "originalCommit": "08bfb704ff0aa68cf4f6d5f1a0505092f646cf41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIxMDY3Ng==", "url": "https://github.com/apache/beam/pull/11096#discussion_r391210676", "bodyText": "Added a CharsetDecoder that is used for this method", "author": "scwhittle", "createdAt": "2020-03-11T19:28:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA3MTMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA3NTI2Mg==", "url": "https://github.com/apache/beam/pull/11096#discussion_r391075262", "bodyText": "Either use assert !Thread.holdsLock(this) : \"BEAM-9399: This thread should never hold this lock\"; or checkState(!Thread.holdsLock(this), \"BEAM-9399: This thread should never hold this lock\"); to guard against this case.\nhttps://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html#holdsLock%28java.lang.Object%29", "author": "lukecwik", "createdAt": "2020-03-11T15:53:18Z", "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/logging/JulHandlerPrintStreamAdapterFactory.java", "diffHunk": "@@ -37,114 +37,272 @@\n class JulHandlerPrintStreamAdapterFactory {\n   private static final AtomicBoolean outputWarning = new AtomicBoolean(false);\n \n-  /**\n-   * Creates a {@link PrintStream} which redirects all output to the JUL {@link Handler} with the\n-   * specified {@code loggerName} and {@code level}.\n-   */\n-  static PrintStream create(Handler handler, String loggerName, Level messageLevel) {\n-    try {\n-      return new PrintStream(\n-          new JulHandlerAdapterOutputStream(handler, loggerName, messageLevel),\n-          false,\n-          StandardCharsets.UTF_8.name());\n-    } catch (UnsupportedEncodingException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n-\n-  /**\n-   * An output stream adapter which is able to take a stream of UTF-8 data and output to a named JUL\n-   * log handler. The log messages will be buffered until the system dependent new line separator is\n-   * seen, at which point the buffered string will be output.\n-   */\n-  private static class JulHandlerAdapterOutputStream extends OutputStream {\n+  private static class JulHandlerPrintStream extends PrintStream {\n     private static final String LOGGING_DISCLAIMER =\n         String.format(\n             \"Please use a logger instead of System.out or System.err.%n\"\n                 + \"Please switch to using org.slf4j.Logger.%n\"\n                 + \"See: https://cloud.google.com/dataflow/pipelines/logging\");\n-    // This limits the number of bytes which we buffer in case we don't see a newline character.\n-    private static final int BUFFER_LIMIT = 1 << 14; // 16384 bytes\n-    private static final byte[] NEW_LINE = System.lineSeparator().getBytes(StandardCharsets.UTF_8);\n+    // This limits the number of bytes which we buffer in case we don't have a flush.\n+    private static final int BUFFER_LIMIT = 1 << 10; // 1024 chars\n \n     /** Hold reference of named logger to check configured {@link Level}. */\n     private Logger logger;\n \n     private Handler handler;\n     private String loggerName;\n-    private ByteArrayOutputStream baos;\n+    private StringBuilder buffer;\n     private Level messageLevel;\n-    private int matched = 0;\n \n-    private JulHandlerAdapterOutputStream(Handler handler, String loggerName, Level logLevel) {\n+    private JulHandlerPrintStream(Handler handler, String loggerName, Level logLevel) {\n+      super(\n+          new OutputStream() {\n+            @Override\n+            public void write(int i) throws IOException {\n+              throw new RuntimeException(\"All methods should be overwritten so this is unused\");\n+            }\n+          });\n       this.handler = handler;\n       this.loggerName = loggerName;\n       this.messageLevel = logLevel;\n       this.logger = Logger.getLogger(loggerName);\n-      this.baos = new ByteArrayOutputStream(BUFFER_LIMIT);\n+      this.buffer = new StringBuilder(BUFFER_LIMIT);\n     }\n \n     @Override\n-    public void write(int b) {\n-      if (outputWarning.compareAndSet(false, true)) {\n-        publish(Level.WARNING, LOGGING_DISCLAIMER);\n+    public void flush() {\n+      publish(flushToString());\n+    }\n+\n+    private synchronized String flushToString() {\n+      if (buffer.length() > 0 && buffer.charAt(buffer.length() - 1) == '\\n') {\n+        buffer.setLength(buffer.length() - 1);\n       }\n+      String result = buffer.toString();\n+      buffer.setLength(0);\n+      return result;\n+    }\n \n-      baos.write(b);\n-      // Check to see if the next byte matches further into new line string.\n-      if (NEW_LINE[matched] == b) {\n-        matched += 1;\n-        // If we have matched the entire new line, output the contents of the buffer.\n-        if (matched == NEW_LINE.length) {\n-          output();\n-        }\n-      } else {\n-        // Reset the match\n-        matched = 0;\n+    @Override\n+    public void close() {\n+      flush();\n+    }\n+\n+    @Override\n+    public boolean checkError() {\n+      return false;\n+    }\n+\n+    @Override\n+    public synchronized void write(int i) {\n+      buffer.append(i);\n+    }\n+\n+    @Override\n+    public void write(byte[] a, int start, int limit) {\n+      // XXX this enforces decoding on boundaries where before it didn't, does that matter?\n+      print(new String(a, start, limit, Charset.defaultCharset()));\n+    }\n+\n+    @Override\n+    public synchronized void print(boolean b) {\n+      buffer.append(b ? \"true\" : \"false\");\n+    }\n+\n+    @Override\n+    public synchronized void print(char c) {\n+      buffer.append(c);\n+    }\n+\n+    @Override\n+    public synchronized void print(int i) {\n+      buffer.append(i);\n+    }\n+\n+    @Override\n+    public synchronized void print(long l) {\n+      buffer.append(l);\n+    }\n+\n+    @Override\n+    public synchronized void print(float f) {\n+      buffer.append(f);\n+    }\n+\n+    @Override\n+    public synchronized void print(double d) {\n+      buffer.append(d);\n+    }\n+\n+    @Override\n+    public synchronized void print(char[] a) {\n+      buffer.append(a);\n+    }\n+\n+    @Override\n+    public synchronized void print(String s) {\n+      buffer.append(s);\n+    }\n+\n+    @Override\n+    public synchronized void print(Object o) {\n+      buffer.append(o);\n+    }\n+\n+    @Override\n+    public void println() {\n+      flush();\n+    }\n+\n+    @Override\n+    public void println(boolean b) {\n+      String msg;\n+      synchronized (this) {\n+        buffer.append(b);\n+        msg = flushToString();\n       }\n-      if (baos.size() == BUFFER_LIMIT) {\n-        output();\n+      publish(msg);\n+    }\n+\n+    @Override\n+    public void println(char c) {\n+      String msg;\n+      synchronized (this) {\n+        buffer.append(c);\n+        msg = flushToString();\n       }\n+      publish(msg);\n     }\n \n     @Override\n-    public void flush() throws IOException {\n-      output();\n+    public void println(int i) {\n+      String msg;\n+      synchronized (this) {\n+        buffer.append(i);\n+        msg = flushToString();\n+      }\n+      publish(msg);\n     }\n \n     @Override\n-    public void close() throws IOException {\n-      output();\n+    public void println(long l) {\n+      String msg;\n+      synchronized (this) {\n+        buffer.append(l);\n+        msg = flushToString();\n+      }\n+      publish(msg);\n     }\n \n-    private void output() {\n-      // If nothing was output, do not log anything\n-      if (baos.size() == 0) {\n-        return;\n+    @Override\n+    public void println(float f) {\n+      String msg;\n+      synchronized (this) {\n+        buffer.append(f);\n+        msg = flushToString();\n       }\n-      try {\n-        String message = baos.toString(StandardCharsets.UTF_8.name());\n-        // Strip the new line if it exists\n-        if (message.endsWith(System.lineSeparator())) {\n-          message = message.substring(0, message.length() - System.lineSeparator().length());\n-        }\n+      publish(msg);\n+    }\n+\n+    @Override\n+    public void println(double d) {\n+      String msg;\n+      synchronized (this) {\n+        buffer.append(d);\n+        msg = flushToString();\n+      }\n+      publish(msg);\n+    }\n+\n+    @Override\n+    public void println(char[] a) {\n+      String msg;\n+      synchronized (this) {\n+        buffer.append(a);\n+        msg = flushToString();\n+      }\n+      publish(msg);\n+    }\n+\n+    @Override\n+    public void println(String s) {\n+      String msg;\n+      synchronized (this) {\n+        buffer.append(s);\n+        msg = flushToString();\n+      }\n+      publish(msg);\n+    }\n \n-        publish(messageLevel, message);\n-      } catch (UnsupportedEncodingException e) {\n-        publish(\n-            Level.SEVERE, String.format(\"Unable to decode string output to stdout/stderr %s\", e));\n+    @Override\n+    public void println(Object o) {\n+      String msg;\n+      synchronized (this) {\n+        buffer.append(o);\n+        msg = flushToString();\n       }\n-      matched = 0;\n-      baos.reset();\n+      publish(msg);\n     }\n \n-    private void publish(Level level, String message) {\n-      if (logger.isLoggable(level)) {\n-        LogRecord log = new LogRecord(level, message);\n+    @Override\n+    public PrintStream format(String format, Object... args) {\n+      return format(Locale.getDefault(), format, args);\n+    }\n+\n+    @Override\n+    public PrintStream format(Locale locale, String format, Object... args) {\n+      String flushed;\n+      int newlineIndex;\n+      synchronized (this) {\n+        int startLength = buffer.length();\n+        Formatter formatter = new Formatter(buffer, locale);\n+        formatter.format(format, args);\n+        newlineIndex = buffer.indexOf(\"\\n\", startLength);\n+        if (newlineIndex < 0) {\n+          return this;\n+        }\n+        flushed = flushToString();\n+      }\n+      while (newlineIndex > 0) {\n+        publish(flushed.substring(0, newlineIndex));\n+        flushed = flushed.substring(newlineIndex + 1);\n+        newlineIndex = flushed.indexOf('\\n');\n+      }\n+      publish(flushed);\n+      return this;\n+    }\n+\n+    @Override\n+    public synchronized PrintStream append(CharSequence cs, int start, int limit) {\n+      buffer.append(cs.subSequence(start, limit));\n+      return this;\n+    }\n+\n+    // Note to avoid a deadlock, publish may never be called synchronized. See BEAM-9399.\n+    private void publish(Level messageLevel, String message) {\n+      if (logger.isLoggable(messageLevel)) {", "originalCommit": "08bfb704ff0aa68cf4f6d5f1a0505092f646cf41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIxMDUwMQ==", "url": "https://github.com/apache/beam/pull/11096#discussion_r391210501", "bodyText": "Done", "author": "scwhittle", "createdAt": "2020-03-11T19:28:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA3NTI2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA4NjAzNw==", "url": "https://github.com/apache/beam/pull/11096#discussion_r391086037", "bodyText": "It makes a lot more sense to move all the newline handling into publish and for it to check for new lines. If you want to avoid the cost of indexOf/substring call, you could create an internal method that publishWithNewLines that does all the substring/indexOf work and only use publish for the trivial println methods", "author": "lukecwik", "createdAt": "2020-03-11T16:07:56Z", "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/logging/JulHandlerPrintStreamAdapterFactory.java", "diffHunk": "@@ -37,114 +37,272 @@\n class JulHandlerPrintStreamAdapterFactory {\n   private static final AtomicBoolean outputWarning = new AtomicBoolean(false);\n \n-  /**\n-   * Creates a {@link PrintStream} which redirects all output to the JUL {@link Handler} with the\n-   * specified {@code loggerName} and {@code level}.\n-   */\n-  static PrintStream create(Handler handler, String loggerName, Level messageLevel) {\n-    try {\n-      return new PrintStream(\n-          new JulHandlerAdapterOutputStream(handler, loggerName, messageLevel),\n-          false,\n-          StandardCharsets.UTF_8.name());\n-    } catch (UnsupportedEncodingException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n-\n-  /**\n-   * An output stream adapter which is able to take a stream of UTF-8 data and output to a named JUL\n-   * log handler. The log messages will be buffered until the system dependent new line separator is\n-   * seen, at which point the buffered string will be output.\n-   */\n-  private static class JulHandlerAdapterOutputStream extends OutputStream {\n+  private static class JulHandlerPrintStream extends PrintStream {\n     private static final String LOGGING_DISCLAIMER =\n         String.format(\n             \"Please use a logger instead of System.out or System.err.%n\"\n                 + \"Please switch to using org.slf4j.Logger.%n\"\n                 + \"See: https://cloud.google.com/dataflow/pipelines/logging\");\n-    // This limits the number of bytes which we buffer in case we don't see a newline character.\n-    private static final int BUFFER_LIMIT = 1 << 14; // 16384 bytes\n-    private static final byte[] NEW_LINE = System.lineSeparator().getBytes(StandardCharsets.UTF_8);\n+    // This limits the number of bytes which we buffer in case we don't have a flush.\n+    private static final int BUFFER_LIMIT = 1 << 10; // 1024 chars\n \n     /** Hold reference of named logger to check configured {@link Level}. */\n     private Logger logger;\n \n     private Handler handler;\n     private String loggerName;\n-    private ByteArrayOutputStream baos;\n+    private StringBuilder buffer;\n     private Level messageLevel;\n-    private int matched = 0;\n \n-    private JulHandlerAdapterOutputStream(Handler handler, String loggerName, Level logLevel) {\n+    private JulHandlerPrintStream(Handler handler, String loggerName, Level logLevel) {\n+      super(\n+          new OutputStream() {\n+            @Override\n+            public void write(int i) throws IOException {\n+              throw new RuntimeException(\"All methods should be overwritten so this is unused\");\n+            }\n+          });\n       this.handler = handler;\n       this.loggerName = loggerName;\n       this.messageLevel = logLevel;\n       this.logger = Logger.getLogger(loggerName);\n-      this.baos = new ByteArrayOutputStream(BUFFER_LIMIT);\n+      this.buffer = new StringBuilder(BUFFER_LIMIT);\n     }\n \n     @Override\n-    public void write(int b) {\n-      if (outputWarning.compareAndSet(false, true)) {\n-        publish(Level.WARNING, LOGGING_DISCLAIMER);\n+    public void flush() {\n+      publish(flushToString());\n+    }\n+\n+    private synchronized String flushToString() {\n+      if (buffer.length() > 0 && buffer.charAt(buffer.length() - 1) == '\\n') {", "originalCommit": "08bfb704ff0aa68cf4f6d5f1a0505092f646cf41", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTIxMjM0Mw==", "url": "https://github.com/apache/beam/pull/11096#discussion_r391212343", "bodyText": "The previous code removed trailing newlines when publishing, which makes sense to me since we don't need them in the final log message.\nIs there a reason not to do it here? This is a single callsite and avoids making a substring.\nThe checking for newlines for flushing seems like it needs to be in each function since otherwise we wouldn't be calling publish.", "author": "scwhittle", "createdAt": "2020-03-11T19:32:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTA4NjAzNw=="}], "type": "inlineReview"}, {"oid": "abf4d7b10f5a6d6cd44f67b0571eef5f083a10f2", "url": "https://github.com/apache/beam/commit/abf4d7b10f5a6d6cd44f67b0571eef5f083a10f2", "message": "Change the redirection of System.err to be a custom PrintStream\ninstead of a custom output stream wrapped by standard PrintStream.", "committedDate": "2020-03-11T19:25:12Z", "type": "forcePushed"}, {"oid": "fd4beaf93b25a49e72e3f342479d502cda507b02", "url": "https://github.com/apache/beam/commit/fd4beaf93b25a49e72e3f342479d502cda507b02", "message": "[BEAM-9399] Change the redirection of System.err to be a custom PrintStream\ninstead of a custom output stream wrapped by standard PrintStream.", "committedDate": "2020-03-11T20:25:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkyOTA1Mg==", "url": "https://github.com/apache/beam/pull/11096#discussion_r391929052", "bodyText": "You need to use the stateful version of the CharsetDecoder.decode since this method assumes that the byte[] range represents a whole valid String.\nIn the other methods you would need to finish the decoding if there is a partial decoding in flight.", "author": "lukecwik", "createdAt": "2020-03-12T21:59:10Z", "path": "runners/google-cloud-dataflow-java/worker/src/main/java/org/apache/beam/runners/dataflow/worker/logging/JulHandlerPrintStreamAdapterFactory.java", "diffHunk": "@@ -37,114 +43,328 @@\n class JulHandlerPrintStreamAdapterFactory {\n   private static final AtomicBoolean outputWarning = new AtomicBoolean(false);\n \n-  /**\n-   * Creates a {@link PrintStream} which redirects all output to the JUL {@link Handler} with the\n-   * specified {@code loggerName} and {@code level}.\n-   */\n-  static PrintStream create(Handler handler, String loggerName, Level messageLevel) {\n-    try {\n-      return new PrintStream(\n-          new JulHandlerAdapterOutputStream(handler, loggerName, messageLevel),\n-          false,\n-          StandardCharsets.UTF_8.name());\n-    } catch (UnsupportedEncodingException e) {\n-      throw new RuntimeException(e);\n-    }\n-  }\n-\n-  /**\n-   * An output stream adapter which is able to take a stream of UTF-8 data and output to a named JUL\n-   * log handler. The log messages will be buffered until the system dependent new line separator is\n-   * seen, at which point the buffered string will be output.\n-   */\n-  private static class JulHandlerAdapterOutputStream extends OutputStream {\n+  private static class JulHandlerPrintStream extends PrintStream {\n     private static final String LOGGING_DISCLAIMER =\n         String.format(\n             \"Please use a logger instead of System.out or System.err.%n\"\n                 + \"Please switch to using org.slf4j.Logger.%n\"\n                 + \"See: https://cloud.google.com/dataflow/pipelines/logging\");\n-    // This limits the number of bytes which we buffer in case we don't see a newline character.\n-    private static final int BUFFER_LIMIT = 1 << 14; // 16384 bytes\n-    private static final byte[] NEW_LINE = System.lineSeparator().getBytes(StandardCharsets.UTF_8);\n+    // This limits the number of bytes which we buffer in case we don't have a flush.\n+    private static final int BUFFER_LIMIT = 1 << 10; // 1024 chars\n \n     /** Hold reference of named logger to check configured {@link Level}. */\n-    private Logger logger;\n+    private final Logger logger;\n \n-    private Handler handler;\n-    private String loggerName;\n-    private ByteArrayOutputStream baos;\n-    private Level messageLevel;\n-    private int matched = 0;\n+    private final Handler handler;\n+    private final String loggerName;\n+    private final StringBuilder buffer;\n+    private final Level messageLevel;\n+    private final CharsetDecoder decoder;\n \n-    private JulHandlerAdapterOutputStream(Handler handler, String loggerName, Level logLevel) {\n+\n+    private JulHandlerPrintStream(Handler handler, String loggerName, Level logLevel) {\n+      super(\n+          new OutputStream() {\n+            @Override\n+            public void write(int i) throws IOException {\n+              throw new RuntimeException(\"All methods should be overwritten so this is unused\");\n+            }\n+          });\n       this.handler = handler;\n       this.loggerName = loggerName;\n       this.messageLevel = logLevel;\n       this.logger = Logger.getLogger(loggerName);\n-      this.baos = new ByteArrayOutputStream(BUFFER_LIMIT);\n+      this.buffer = new StringBuilder(BUFFER_LIMIT);\n+      this.decoder = Charset.defaultCharset().newDecoder();\n+    }\n+\n+    @Override\n+    public void flush() {\n+      publish(flushToString());\n+    }\n+\n+    private synchronized String flushToString() {\n+      if (buffer.length() > 0 && buffer.charAt(buffer.length() - 1) == '\\n') {\n+        buffer.setLength(buffer.length() - 1);\n+      }\n+      String result = buffer.toString();\n+      buffer.setLength(0);\n+      return result;\n+    }\n+\n+    @Override\n+    public void close() {\n+      flush();\n+    }\n+\n+    @Override\n+    public boolean checkError() {\n+      return false;\n+    }\n+\n+    @Override\n+    public synchronized void write(int i) {\n+      buffer.append(i);\n+    }\n+\n+    @Override\n+    public void write(byte[] a, int start, int limit) {\n+      CharBuffer decoded;\n+      synchronized (decoder) {\n+        try {\n+          decoded = decoder.decode(ByteBuffer.wrap(a, start, limit));", "originalCommit": "fd4beaf93b25a49e72e3f342479d502cda507b02", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNTgxMA==", "url": "https://github.com/apache/beam/pull/11096#discussion_r395335810", "bodyText": "Thanks for catching. I added a unit test for raw bytes and fixed to keep a buffer of remainders.", "author": "scwhittle", "createdAt": "2020-03-19T21:41:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MTkyOTA1Mg=="}], "type": "inlineReview"}, {"oid": "d0b54ab1d0cf2145a9e49f7d1f86013219326382", "url": "https://github.com/apache/beam/commit/d0b54ab1d0cf2145a9e49f7d1f86013219326382", "message": "[BEAM-9399] Change the redirection of System.err to be a custom PrintStream\ninstead of a custom output stream wrapped by standard PrintStream.", "committedDate": "2020-03-19T20:00:57Z", "type": "forcePushed"}, {"oid": "9651178f2fb72961aa81ddbb2d4ea289afc3c3ad", "url": "https://github.com/apache/beam/commit/9651178f2fb72961aa81ddbb2d4ea289afc3c3ad", "message": "[BEAM-9399] Change the redirection of System.err to be a custom PrintStream\ninstead of a custom output stream wrapped by standard PrintStream.", "committedDate": "2020-03-19T21:40:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUwNzgyNA==", "url": "https://github.com/apache/beam/pull/11096#discussion_r400507824", "bodyText": "You have to use the default charset for getBytes since you use the default charset in the CharsetDecoder.", "author": "lukecwik", "createdAt": "2020-03-30T21:33:33Z", "path": "runners/google-cloud-dataflow-java/worker/src/test/java/org/apache/beam/runners/dataflow/worker/logging/JulHandlerPrintStreamAdapterFactoryTest.java", "diffHunk": "@@ -115,6 +116,22 @@ public void testLogOnClose() {\n     assertThat(handler.getLogs(), hasLogItem(\"blah\"));\n   }\n \n+  @Test\n+  public void testLogRawBytes() {\n+    PrintStream printStream = createPrintStreamAdapter();\n+    String msg = \"\u2660 \u2661 \u2662 \u2663 \u2664 \u2665 \u2666 \u2667\";\n+    byte[] bytes = msg.getBytes(UTF_8);", "originalCommit": "9651178f2fb72961aa81ddbb2d4ea289afc3c3ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDU0MTcwOA==", "url": "https://github.com/apache/beam/pull/11096#discussion_r400541708", "bodyText": "good catch, done.", "author": "scwhittle", "createdAt": "2020-03-30T22:51:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMDUwNzgyNA=="}], "type": "inlineReview"}, {"oid": "072ddc01bca5f97541957634355a2e3bc367d120", "url": "https://github.com/apache/beam/commit/072ddc01bca5f97541957634355a2e3bc367d120", "message": "[BEAM-9399] Change the redirection of System.err to be a custom PrintStream\ninstead of a custom output stream wrapped by standard PrintStream.", "committedDate": "2020-03-30T22:50:15Z", "type": "commit"}, {"oid": "072ddc01bca5f97541957634355a2e3bc367d120", "url": "https://github.com/apache/beam/commit/072ddc01bca5f97541957634355a2e3bc367d120", "message": "[BEAM-9399] Change the redirection of System.err to be a custom PrintStream\ninstead of a custom output stream wrapped by standard PrintStream.", "committedDate": "2020-03-30T22:50:15Z", "type": "forcePushed"}, {"oid": "e2e8b62ea57af30daa279cd1c42409eb437a3900", "url": "https://github.com/apache/beam/commit/e2e8b62ea57af30daa279cd1c42409eb437a3900", "message": "Fix missing test import", "committedDate": "2020-03-31T17:02:24Z", "type": "commit"}]}