{"pr_number": 11448, "pr_title": "[BEAM-3836] Enable dynamic splitting/checkpointing within the Java SDK harness.", "pr_createdAt": "2020-04-17T18:50:33Z", "pr_url": "https://github.com/apache/beam/pull/11448", "timeline": [{"oid": "ef51a63678f73ffaa419b8d711156e863def69d2", "url": "https://github.com/apache/beam/commit/ef51a63678f73ffaa419b8d711156e863def69d2", "message": "[BEAM-3836] Enable dynamic splitting/checkpointing within the Java SDK harness.", "committedDate": "2020-04-17T18:49:21Z", "type": "commit"}, {"oid": "7e65952a39b037eeef5dc16b82010483e3fa1e5f", "url": "https://github.com/apache/beam/commit/7e65952a39b037eeef5dc16b82010483e3fa1e5f", "message": "fixup! Spotless", "committedDate": "2020-04-17T19:54:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyODgxMg==", "url": "https://github.com/apache/beam/pull/11448#discussion_r410528812", "bodyText": "Can we force a split at element by only feeding in WAIT_TILL_SPLIT ?", "author": "boyuanzz", "createdAt": "2020-04-18T00:59:12Z", "path": "runners/java-fn-execution/src/test/java/org/apache/beam/runners/fnexecution/control/RemoteExecutionTest.java", "diffHunk": "@@ -1246,16 +1249,230 @@ public void process(ProcessContext c) {\n               StateRequestHandler.unsupported(),\n               BundleProgressHandler.ignored())) {\n         Iterables.getOnlyElement(bundle.getInputReceivers().values())\n-            .accept(\n-                WindowedValue.valueInGlobalWindow(\n-                    CoderUtils.encodeToByteArray(StringUtf8Coder.of(), \"X\")));\n+            .accept(valueInGlobalWindow(CoderUtils.encodeToByteArray(StringUtf8Coder.of(), \"X\")));\n       }\n     }\n     assertThat(\n         outputValues,\n         containsInAnyOrder(\n-            WindowedValue.valueInGlobalWindow(KV.of(\"stream1X\", \"\")),\n-            WindowedValue.valueInGlobalWindow(KV.of(\"stream2X\", \"\"))));\n+            valueInGlobalWindow(KV.of(\"stream1X\", \"\")),\n+            valueInGlobalWindow(KV.of(\"stream2X\", \"\"))));\n+  }\n+\n+  /**\n+   * A restriction tracker that will block making progress on {@link #WAIT_TILL_SPLIT} until a try\n+   * split is invoked.\n+   */\n+  private static class WaitingTillSplitRestrictionTracker extends RestrictionTracker<String, Void> {\n+    private static final String WAIT_TILL_SPLIT = \"WaitTillSplit\";\n+    private static final String PRIMARY = \"Primary\";\n+    private static final String RESIDUAL = \"Residual\";\n+\n+    private String currentRestriction;\n+\n+    private WaitingTillSplitRestrictionTracker(String restriction) {\n+      this.currentRestriction = restriction;\n+    }\n+\n+    @Override\n+    public boolean tryClaim(Void position) {\n+      return needsSplitting();\n+    }\n+\n+    @Override\n+    public String currentRestriction() {\n+      return currentRestriction;\n+    }\n+\n+    @Override\n+    public SplitResult<String> trySplit(double fractionOfRemainder) {\n+      if (!needsSplitting()) {\n+        return null;\n+      }\n+      this.currentRestriction = PRIMARY;\n+      return SplitResult.of(currentRestriction, RESIDUAL);\n+    }\n+\n+    private boolean needsSplitting() {\n+      return WAIT_TILL_SPLIT.equals(currentRestriction);\n+    }\n+\n+    @Override\n+    public void checkDone() throws IllegalStateException {\n+      checkState(!needsSplitting(), \"Expected for this restriction to have been split.\");\n+    }\n+  }\n+\n+  @Test(timeout = 60000L)\n+  public void testSplit() throws Exception {\n+    Pipeline p = Pipeline.create();\n+    p.apply(\"impulse\", Impulse.create())\n+        .apply(\n+            \"create\",\n+            ParDo.of(\n+                new DoFn<byte[], String>() {\n+                  @ProcessElement\n+                  public void process(ProcessContext ctxt) {\n+                    ctxt.output(\"zero\");\n+                    ctxt.output(WaitingTillSplitRestrictionTracker.WAIT_TILL_SPLIT);\n+                    ctxt.output(\"two\");\n+                  }\n+                }))\n+        .apply(\n+            \"forceSplit\",\n+            ParDo.of(\n+                new DoFn<String, String>() {\n+                  @GetInitialRestriction\n+                  public String getInitialRestriction(@Element String element) {\n+                    return element;\n+                  }\n+\n+                  @NewTracker\n+                  public WaitingTillSplitRestrictionTracker newTracker(\n+                      @Restriction String restriction) {\n+                    return new WaitingTillSplitRestrictionTracker(restriction);\n+                  }\n+\n+                  @ProcessElement\n+                  public void process(\n+                      RestrictionTracker<String, Void> tracker, ProcessContext context) {\n+                    while (tracker.tryClaim(null)) {}\n+                    context.output(tracker.currentRestriction());\n+                  }\n+                }))\n+        .apply(\"addKeys\", WithKeys.of(\"foo\"))\n+        // Use some unknown coders\n+        .setCoder(KvCoder.of(StringUtf8Coder.of(), StringUtf8Coder.of()))\n+        // Force the output to be materialized\n+        .apply(\"gbk\", GroupByKey.create());\n+\n+    RunnerApi.Pipeline pipeline = PipelineTranslation.toProto(p);\n+    // Expand any splittable DoFns within the graph to enable sizing and splitting of bundles.\n+    RunnerApi.Pipeline pipelineWithSdfExpanded =\n+        ProtoOverrides.updateTransform(\n+            PTransformTranslation.PAR_DO_TRANSFORM_URN,\n+            pipeline,\n+            SplittableParDoExpander.createSizedReplacement());\n+    FusedPipeline fused = GreedyPipelineFuser.fuse(pipelineWithSdfExpanded);\n+\n+    // Find the fused stage with the SDF ProcessSizedElementAndRestriction transform\n+    Optional<ExecutableStage> optionalStage =\n+        Iterables.tryFind(\n+            fused.getFusedStages(),\n+            (ExecutableStage stage) ->\n+                Iterables.filter(\n+                        stage.getTransforms(),\n+                        (PTransformNode node) ->\n+                            PTransformTranslation\n+                                .SPLITTABLE_PROCESS_SIZED_ELEMENTS_AND_RESTRICTIONS_URN\n+                                .equals(node.getTransform().getSpec().getUrn()))\n+                    .iterator()\n+                    .hasNext());\n+    checkState(\n+        optionalStage.isPresent(), \"Expected a stage with SDF ProcessSizedElementAndRestriction.\");\n+    ExecutableStage stage = optionalStage.get();\n+\n+    ExecutableProcessBundleDescriptor descriptor =\n+        ProcessBundleDescriptors.fromExecutableStage(\n+            \"my_stage\", stage, dataServer.getApiServiceDescriptor());\n+\n+    BundleProcessor processor =\n+        controlClient.getProcessor(\n+            descriptor.getProcessBundleDescriptor(), descriptor.getRemoteInputDestinations());\n+    Map<String, ? super Coder<WindowedValue<?>>> remoteOutputCoders =\n+        descriptor.getRemoteOutputCoders();\n+    Map<String, Collection<? super WindowedValue<?>>> outputValues = new HashMap<>();\n+    Map<String, RemoteOutputReceiver<?>> outputReceivers = new HashMap<>();\n+    for (Entry<String, ? super Coder<WindowedValue<?>>> remoteOutputCoder :\n+        remoteOutputCoders.entrySet()) {\n+      List<? super WindowedValue<?>> outputContents =\n+          Collections.synchronizedList(new ArrayList<>());\n+      outputValues.put(remoteOutputCoder.getKey(), outputContents);\n+      outputReceivers.put(\n+          remoteOutputCoder.getKey(),\n+          RemoteOutputReceiver.of(\n+              (Coder) remoteOutputCoder.getValue(),\n+              (FnDataReceiver<? super WindowedValue<?>>) outputContents::add));\n+    }\n+\n+    List<ProcessBundleSplitResponse> splitResponses = new ArrayList<>();\n+    List<ProcessBundleResponse> checkpointResponses = new ArrayList<>();\n+    List<String> requestsFinalization = new ArrayList<>();\n+\n+    ScheduledExecutorService executor = Executors.newSingleThreadScheduledExecutor();\n+    ScheduledFuture<Object> future;\n+\n+    // Execute the remote bundle.\n+    try (RemoteBundle bundle =\n+        processor.newBundle(\n+            outputReceivers,\n+            Collections.emptyMap(),\n+            StateRequestHandler.unsupported(),\n+            BundleProgressHandler.ignored(),\n+            splitResponses::add,\n+            checkpointResponses::add,\n+            requestsFinalization::add)) {\n+      Iterables.getOnlyElement(bundle.getInputReceivers().values())\n+          .accept(valueInGlobalWindow(sdfSizedElementAndRestrictionForTest(\"zero\")));\n+      Iterables.getOnlyElement(bundle.getInputReceivers().values())\n+          .accept(\n+              valueInGlobalWindow(\n+                  sdfSizedElementAndRestrictionForTest(\n+                      WaitingTillSplitRestrictionTracker.WAIT_TILL_SPLIT)));\n+      Iterables.getOnlyElement(bundle.getInputReceivers().values())\n+          .accept(valueInGlobalWindow(sdfSizedElementAndRestrictionForTest(\"two\")));\n+      // Keep sending splits until the bundle terminates, we specifically use 0.5 so that we will\n+      // choose a split point before the end of WAIT_TILL_SPLIT regardless of where we are during\n+      // processing.\n+      future =\n+          (ScheduledFuture)\n+              executor.scheduleWithFixedDelay(\n+                  () -> bundle.split(0.5), 0L, 100L, TimeUnit.MILLISECONDS);\n+    }\n+    future.cancel(false);\n+    executor.shutdown();\n+\n+    assertTrue(requestsFinalization.isEmpty());\n+    assertTrue(checkpointResponses.isEmpty());\n+\n+    List<WindowedValue<KV<String, String>>> expectedOutputs = new ArrayList<>();\n+\n+    // We only validate the last split response since it is the only one that could possibly\n+    // contain the SDF split, all others will be a reduction in the ChannelSplit\n+    assertFalse(splitResponses.isEmpty());\n+    ProcessBundleSplitResponse splitResponse = splitResponses.get(splitResponses.size() - 1);\n+    ChannelSplit channelSplit = Iterables.getOnlyElement(splitResponse.getChannelSplitsList());\n+\n+    // There are only a few outcomes that could happen with splitting due to timing:", "originalCommit": "7e65952a39b037eeef5dc16b82010483e3fa1e5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU1NjkyNg==", "url": "https://github.com/apache/beam/pull/11448#discussion_r410556926", "bodyText": "Thats a good idea. Updated the PR to reflect it.", "author": "lukecwik", "createdAt": "2020-04-18T02:12:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUyODgxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUzNjQyNA==", "url": "https://github.com/apache/beam/pull/11448#discussion_r410536424", "bodyText": "Is it intended that all roots process the same split request?", "author": "boyuanzz", "createdAt": "2020-04-18T01:24:40Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/control/ProcessBundleHandler.java", "diffHunk": "@@ -340,7 +347,12 @@ private void createRunnerAndConsumersForPTransformRecursively(\n               \"Unable to find active bundle for instruction id %s.\",\n               request.getProcessBundleSplit().getInstructionId()));\n     }\n-    throw new UnsupportedOperationException(\"TODO: BEAM-3836, support splitting within SDK.\");\n+    BeamFnApi.ProcessBundleSplitResponse.Builder response =\n+        BeamFnApi.ProcessBundleSplitResponse.newBuilder();\n+    for (BeamFnDataReadRunner channelRoot : bundleProcessor.getChannelRoots()) {\n+      channelRoot.trySplit(request.getProcessBundleSplit(), response);", "originalCommit": "7e65952a39b037eeef5dc16b82010483e3fa1e5f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDU1Mzg5OQ==", "url": "https://github.com/apache/beam/pull/11448#discussion_r410553899", "bodyText": "Yes, each root gets the full split request and extracts out the desiredsplit information for itself if there is any specific to it.", "author": "lukecwik", "createdAt": "2020-04-18T02:04:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMDUzNjQyNA=="}], "type": "inlineReview"}, {"oid": "6f2542e4993cc738f762311e5c995f1123b3718e", "url": "https://github.com/apache/beam/commit/6f2542e4993cc738f762311e5c995f1123b3718e", "message": "fixup! Address PR comments.", "committedDate": "2020-04-18T02:11:26Z", "type": "commit"}]}