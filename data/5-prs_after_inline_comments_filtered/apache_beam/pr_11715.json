{"pr_number": 11715, "pr_title": "[BEAM-9977] Implement GrowableOffsetRangeTracker", "pr_createdAt": "2020-05-15T00:52:58Z", "pr_url": "https://github.com/apache/beam/pull/11715", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1MzQxOA==", "url": "https://github.com/apache/beam/pull/11715#discussion_r425553418", "bodyText": "Currently I take Long.MAX_VALUE as a numeric end offset. But we may also need a notion  to say that the OffsetPoller doesn't have a good estimate and still want to keep current range as infinite.  Long.MAX_VALUE is not suitable because it's possible that the actual end is Long.MAX_VALUE. Do we want to provide a notion here? Like null?", "author": "boyuanzz", "createdAt": "2020-05-15T03:59:57Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/GrowableOffsetRangeTracker.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms.splittabledofn;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.annotations.Experimental.Kind;\n+import org.apache.beam.sdk.io.range.OffsetRange;\n+\n+/**\n+ * A special {@link OffsetRangeTracker} for tracking a growable offset range. The Long.MAX_VALUE is\n+ * used as end range to indicate the possibility of infinity.\n+ *\n+ * <p>A offset range is considered as growable when the end offset could grow(or change) during\n+ * execution time(e.g., Kafka backlog, appended file).\n+ */\n+@Experimental(Kind.SPLITTABLE_DO_FN)\n+public class GrowableOffsetRangeTracker extends OffsetRangeTracker {\n+  /**\n+   * An interface that should be implemented to fetch estimated end offset of range.\n+   *\n+   * <p>{@code estimateRangeEnd} is called to give te end offset when {@code trySplit} or {@code\n+   * getProgress} is invoked. The end offset is exclusive for the range. It's not necessary to\n+   * increase monotonically but it's only taken into computation when it's larger than the current\n+   * position. When returning Long.MAX_VALUE as estimate, it means the largest possible position for\n+   * the range is Long.MAX_VALUE - 1. Having a good estimate is important for providing a good", "originalCommit": "2aedee9a63b22655de8b7f23f2127db8640c0fd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg5MDY2Mw==", "url": "https://github.com/apache/beam/pull/11715#discussion_r425890663", "bodyText": "The user should return Long.MIN_VALUE and then we will use the current position and the estimate will not take into effect.", "author": "lukecwik", "createdAt": "2020-05-15T15:47:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTU1MzQxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4NTkxNA==", "url": "https://github.com/apache/beam/pull/11715#discussion_r425885914", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public interface OffsetPoller {\n          \n          \n            \n                long estimateRangeEnd();\n          \n          \n            \n              }\n          \n          \n            \n              @FunctionalInterface\n          \n          \n            \n              public interface RangeEndEstimator {\n          \n          \n            \n                long estimate();\n          \n          \n            \n              }", "author": "lukecwik", "createdAt": "2020-05-15T15:39:20Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/GrowableOffsetRangeTracker.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms.splittabledofn;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.annotations.Experimental.Kind;\n+import org.apache.beam.sdk.io.range.OffsetRange;\n+\n+/**\n+ * A special {@link OffsetRangeTracker} for tracking a growable offset range. The Long.MAX_VALUE is\n+ * used as end range to indicate the possibility of infinity.\n+ *\n+ * <p>A offset range is considered as growable when the end offset could grow(or change) during\n+ * execution time(e.g., Kafka backlog, appended file).\n+ */\n+@Experimental(Kind.SPLITTABLE_DO_FN)\n+public class GrowableOffsetRangeTracker extends OffsetRangeTracker {\n+  /**\n+   * An interface that should be implemented to fetch estimated end offset of range.\n+   *\n+   * <p>{@code estimateRangeEnd} is called to give te end offset when {@code trySplit} or {@code\n+   * getProgress} is invoked. The end offset is exclusive for the range. It's not necessary to\n+   * increase monotonically but it's only taken into computation when it's larger than the current\n+   * position. When returning Long.MAX_VALUE as estimate, it means the largest possible position for\n+   * the range is Long.MAX_VALUE - 1. Having a good estimate is important for providing a good\n+   * signal of progress and splitting at a proper position.\n+   */\n+  public interface OffsetPoller {\n+    long estimateRangeEnd();\n+  }", "originalCommit": "2aedee9a63b22655de8b7f23f2127db8640c0fd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg5NzM2Mw==", "url": "https://github.com/apache/beam/pull/11715#discussion_r425897363", "bodyText": "We might want to suggest people wrap their estimator with https://guava.dev/releases/19.0/api/docs/com/google/common/base/Suppliers.html#memoizeWithExpiration(com.google.common.base.Supplier,%20long,%20java.util.concurrent.TimeUnit) if calling the estimator is expensive.", "author": "lukecwik", "createdAt": "2020-05-15T15:58:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4NTkxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4NzU5Ng==", "url": "https://github.com/apache/beam/pull/11715#discussion_r425887596", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * A special {@link OffsetRangeTracker} for tracking a growable offset range. The Long.MAX_VALUE is\n          \n          \n            \n             * used as end range to indicate the possibility of infinity.\n          \n          \n            \n             *\n          \n          \n            \n             * <p>A offset range is considered as growable when the end offset could grow(or change) during\n          \n          \n            \n             * execution time(e.g., Kafka backlog, appended file).\n          \n          \n            \n             * An {@link OffsetRangeTracker} for tracking a growable offset range. {@code Long.MAX_VALUE} is\n          \n          \n            \n             * used as end range to indicate the possibility of infinity.\n          \n          \n            \n             *\n          \n          \n            \n             * <p>An offset range is considered growable when the end offset could grow (or change) during\n          \n          \n            \n             * execution time (e.g., Kafka topic partition offset, appended file, ...).", "author": "lukecwik", "createdAt": "2020-05-15T15:42:07Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/GrowableOffsetRangeTracker.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms.splittabledofn;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.annotations.Experimental.Kind;\n+import org.apache.beam.sdk.io.range.OffsetRange;\n+\n+/**\n+ * A special {@link OffsetRangeTracker} for tracking a growable offset range. The Long.MAX_VALUE is\n+ * used as end range to indicate the possibility of infinity.\n+ *\n+ * <p>A offset range is considered as growable when the end offset could grow(or change) during\n+ * execution time(e.g., Kafka backlog, appended file).", "originalCommit": "2aedee9a63b22655de8b7f23f2127db8640c0fd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg4ODYxNw==", "url": "https://github.com/apache/beam/pull/11715#discussion_r425888617", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * <p>{@code estimateRangeEnd} is called to give te end offset when {@code trySplit} or {@code\n          \n          \n            \n               * getProgress} is invoked. The end offset is exclusive for the range. It's not necessary to\n          \n          \n            \n               * increase monotonically but it's only taken into computation when it's larger than the current\n          \n          \n            \n               * position. When returning Long.MAX_VALUE as estimate, it means the largest possible position for\n          \n          \n            \n               * the range is Long.MAX_VALUE - 1. Having a good estimate is important for providing a good\n          \n          \n            \n               * signal of progress and splitting at a proper position.\n          \n          \n            \n               * <p>{@code estimateRangeEnd} is called to give the end offset when {@code trySplit} or {@code\n          \n          \n            \n               * getProgress} is invoked. The end offset is exclusive for the range. It is not necessary to\n          \n          \n            \n               * increase monotonically as its only taken into consideration when it is larger than the current\n          \n          \n            \n               * position. When returning {@code Long.MAX_VALUE} as estimate, it means the largest possible position for\n          \n          \n            \n               * the range is {@code Long.MAX_VALUE - 1}. Having a good estimate is important for providing a good\n          \n          \n            \n               * signal of progress and splitting at a proper position.", "author": "lukecwik", "createdAt": "2020-05-15T15:43:52Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/GrowableOffsetRangeTracker.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms.splittabledofn;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.annotations.Experimental.Kind;\n+import org.apache.beam.sdk.io.range.OffsetRange;\n+\n+/**\n+ * A special {@link OffsetRangeTracker} for tracking a growable offset range. The Long.MAX_VALUE is\n+ * used as end range to indicate the possibility of infinity.\n+ *\n+ * <p>A offset range is considered as growable when the end offset could grow(or change) during\n+ * execution time(e.g., Kafka backlog, appended file).\n+ */\n+@Experimental(Kind.SPLITTABLE_DO_FN)\n+public class GrowableOffsetRangeTracker extends OffsetRangeTracker {\n+  /**\n+   * An interface that should be implemented to fetch estimated end offset of range.\n+   *\n+   * <p>{@code estimateRangeEnd} is called to give te end offset when {@code trySplit} or {@code\n+   * getProgress} is invoked. The end offset is exclusive for the range. It's not necessary to\n+   * increase monotonically but it's only taken into computation when it's larger than the current\n+   * position. When returning Long.MAX_VALUE as estimate, it means the largest possible position for\n+   * the range is Long.MAX_VALUE - 1. Having a good estimate is important for providing a good\n+   * signal of progress and splitting at a proper position.", "originalCommit": "2aedee9a63b22655de8b7f23f2127db8640c0fd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg5MTU2Ng==", "url": "https://github.com/apache/beam/pull/11715#discussion_r425891566", "bodyText": "It might be worthwhile to add this comment to OffsetRangeTracker that the largest position is Long.MAX_VALUE - 1.", "author": "lukecwik", "createdAt": "2020-05-15T15:48:59Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/GrowableOffsetRangeTracker.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms.splittabledofn;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.annotations.Experimental.Kind;\n+import org.apache.beam.sdk.io.range.OffsetRange;\n+\n+/**\n+ * A special {@link OffsetRangeTracker} for tracking a growable offset range. The Long.MAX_VALUE is\n+ * used as end range to indicate the possibility of infinity.\n+ *\n+ * <p>A offset range is considered as growable when the end offset could grow(or change) during\n+ * execution time(e.g., Kafka backlog, appended file).\n+ */\n+@Experimental(Kind.SPLITTABLE_DO_FN)\n+public class GrowableOffsetRangeTracker extends OffsetRangeTracker {\n+  /**\n+   * An interface that should be implemented to fetch estimated end offset of range.\n+   *\n+   * <p>{@code estimateRangeEnd} is called to give te end offset when {@code trySplit} or {@code\n+   * getProgress} is invoked. The end offset is exclusive for the range. It's not necessary to\n+   * increase monotonically but it's only taken into computation when it's larger than the current\n+   * position. When returning Long.MAX_VALUE as estimate, it means the largest possible position for\n+   * the range is Long.MAX_VALUE - 1. Having a good estimate is important for providing a good", "originalCommit": "2aedee9a63b22655de8b7f23f2127db8640c0fd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg5Mjk3NA==", "url": "https://github.com/apache/beam/pull/11715#discussion_r425892974", "bodyText": "nit: Doesn't super.trySplit handle the to == from case already?", "author": "lukecwik", "createdAt": "2020-05-15T15:51:20Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/GrowableOffsetRangeTracker.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms.splittabledofn;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.annotations.Experimental.Kind;\n+import org.apache.beam.sdk.io.range.OffsetRange;\n+\n+/**\n+ * A special {@link OffsetRangeTracker} for tracking a growable offset range. The Long.MAX_VALUE is\n+ * used as end range to indicate the possibility of infinity.\n+ *\n+ * <p>A offset range is considered as growable when the end offset could grow(or change) during\n+ * execution time(e.g., Kafka backlog, appended file).\n+ */\n+@Experimental(Kind.SPLITTABLE_DO_FN)\n+public class GrowableOffsetRangeTracker extends OffsetRangeTracker {\n+  /**\n+   * An interface that should be implemented to fetch estimated end offset of range.\n+   *\n+   * <p>{@code estimateRangeEnd} is called to give te end offset when {@code trySplit} or {@code\n+   * getProgress} is invoked. The end offset is exclusive for the range. It's not necessary to\n+   * increase monotonically but it's only taken into computation when it's larger than the current\n+   * position. When returning Long.MAX_VALUE as estimate, it means the largest possible position for\n+   * the range is Long.MAX_VALUE - 1. Having a good estimate is important for providing a good\n+   * signal of progress and splitting at a proper position.\n+   */\n+  public interface OffsetPoller {\n+    long estimateRangeEnd();\n+  }\n+\n+  private final OffsetPoller poller;\n+\n+  public GrowableOffsetRangeTracker(long start, OffsetPoller offsetPoller) {\n+    super(new OffsetRange(start, Long.MAX_VALUE));\n+    this.poller = checkNotNull(offsetPoller);\n+  }\n+\n+  @Override\n+  public SplitResult<OffsetRange> trySplit(double fractionOfRemainder) {\n+    // If current tracking range is no longer growable, split it as a normal range.\n+    if (range.getTo() != Long.MAX_VALUE || range.getTo() == range.getFrom()) {", "originalCommit": "2aedee9a63b22655de8b7f23f2127db8640c0fd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk4NjM3MA==", "url": "https://github.com/apache/beam/pull/11715#discussion_r425986370", "bodyText": "Yes super.trySplit() handles empty range. The special case here is to handle range.getTo() == range.getFrom == Long.MAX_VALUE.", "author": "boyuanzz", "createdAt": "2020-05-15T18:49:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg5Mjk3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQwODI3NQ==", "url": "https://github.com/apache/beam/pull/11715#discussion_r427408275", "bodyText": "Sorry for the confusion, I misread the if statement earlier.", "author": "lukecwik", "createdAt": "2020-05-19T15:48:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg5Mjk3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg5NDAwNg==", "url": "https://github.com/apache/beam/pull/11715#discussion_r425894006", "bodyText": "We should mention in this class comment that the user marks the growable offset range tracker as done by claiming Long.MAX_VALUE when they detect \"end of stream\"", "author": "lukecwik", "createdAt": "2020-05-15T15:53:02Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/GrowableOffsetRangeTracker.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms.splittabledofn;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.annotations.Experimental.Kind;\n+import org.apache.beam.sdk.io.range.OffsetRange;\n+\n+/**\n+ * A special {@link OffsetRangeTracker} for tracking a growable offset range. The Long.MAX_VALUE is\n+ * used as end range to indicate the possibility of infinity.\n+ *\n+ * <p>A offset range is considered as growable when the end offset could grow(or change) during\n+ * execution time(e.g., Kafka backlog, appended file).\n+ */\n+@Experimental(Kind.SPLITTABLE_DO_FN)\n+public class GrowableOffsetRangeTracker extends OffsetRangeTracker {", "originalCommit": "2aedee9a63b22655de8b7f23f2127db8640c0fd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg5ODIxOA==", "url": "https://github.com/apache/beam/pull/11715#discussion_r425898218", "bodyText": "Why not construct a new OffsetRangeTracker over [cur, estimateLatestOffset) and call trySplit on it?", "author": "lukecwik", "createdAt": "2020-05-15T16:00:06Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/GrowableOffsetRangeTracker.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms.splittabledofn;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.annotations.Experimental.Kind;\n+import org.apache.beam.sdk.io.range.OffsetRange;\n+\n+/**\n+ * A special {@link OffsetRangeTracker} for tracking a growable offset range. The Long.MAX_VALUE is\n+ * used as end range to indicate the possibility of infinity.\n+ *\n+ * <p>A offset range is considered as growable when the end offset could grow(or change) during\n+ * execution time(e.g., Kafka backlog, appended file).\n+ */\n+@Experimental(Kind.SPLITTABLE_DO_FN)\n+public class GrowableOffsetRangeTracker extends OffsetRangeTracker {\n+  /**\n+   * An interface that should be implemented to fetch estimated end offset of range.\n+   *\n+   * <p>{@code estimateRangeEnd} is called to give te end offset when {@code trySplit} or {@code\n+   * getProgress} is invoked. The end offset is exclusive for the range. It's not necessary to\n+   * increase monotonically but it's only taken into computation when it's larger than the current\n+   * position. When returning Long.MAX_VALUE as estimate, it means the largest possible position for\n+   * the range is Long.MAX_VALUE - 1. Having a good estimate is important for providing a good\n+   * signal of progress and splitting at a proper position.\n+   */\n+  public interface OffsetPoller {\n+    long estimateRangeEnd();\n+  }\n+\n+  private final OffsetPoller poller;\n+\n+  public GrowableOffsetRangeTracker(long start, OffsetPoller offsetPoller) {\n+    super(new OffsetRange(start, Long.MAX_VALUE));\n+    this.poller = checkNotNull(offsetPoller);\n+  }\n+\n+  @Override\n+  public SplitResult<OffsetRange> trySplit(double fractionOfRemainder) {\n+    // If current tracking range is no longer growable, split it as a normal range.\n+    if (range.getTo() != Long.MAX_VALUE || range.getTo() == range.getFrom()) {\n+      return super.trySplit(fractionOfRemainder);\n+    }\n+    long cur = (lastAttemptedOffset == null) ? range.getFrom() - 1 : lastAttemptedOffset;\n+\n+    // If current range has been done, there is no more space to split.\n+    if (cur == Long.MAX_VALUE) {\n+      return null;\n+    }\n+    // Fetch the estimated end offset. If the estimated end is smaller than the next offset, use\n+    // the next offset as end.\n+    long estimateLatestOffset = Long.max(poller.estimateRangeEnd(), cur + 1);\n+    long splitPos =\n+        cur\n+            + Math.max(\n+                1L,\n+                (Double.valueOf((estimateLatestOffset - cur) * fractionOfRemainder)).longValue());\n+\n+    if (splitPos > estimateLatestOffset) {\n+      return null;\n+    }\n+    OffsetRange res = new OffsetRange(splitPos, range.getTo());\n+    this.range = new OffsetRange(range.getFrom(), splitPos);\n+    return SplitResult.of(range, res);", "originalCommit": "2aedee9a63b22655de8b7f23f2127db8640c0fd7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk4NjM1MA==", "url": "https://github.com/apache/beam/pull/11715#discussion_r425986350", "bodyText": "There is a slight difference around comparison of splitPos and end.  GrowableOffsetTracker allows split when splitPos <= end but OffsetRangeTracker allows split when splitPos < end. The purpose of OffsetRangeTracker is to reduce resuming from an empty range. The purpose of GrowableOffsetRangeTracker is to handle split at cur + 1.", "author": "boyuanzz", "createdAt": "2020-05-15T18:49:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg5ODIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTk5NTk2MQ==", "url": "https://github.com/apache/beam/pull/11715#discussion_r425995961", "bodyText": "btw we will also loss lastAttemptedOffset by creating a new tracker.", "author": "boyuanzz", "createdAt": "2020-05-15T19:07:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTg5ODIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkwMDg0Nw==", "url": "https://github.com/apache/beam/pull/11715#discussion_r425900847", "bodyText": "nit: poller -> estimator", "author": "lukecwik", "createdAt": "2020-05-15T16:04:53Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/GrowableOffsetRangeTracker.java", "diffHunk": "@@ -0,0 +1,103 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms.splittabledofn;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.annotations.Experimental.Kind;\n+import org.apache.beam.sdk.io.range.OffsetRange;\n+\n+/**\n+ * A special {@link OffsetRangeTracker} for tracking a growable offset range. The Long.MAX_VALUE is\n+ * used as end range to indicate the possibility of infinity.\n+ *\n+ * <p>A offset range is considered as growable when the end offset could grow(or change) during\n+ * execution time(e.g., Kafka backlog, appended file).\n+ */\n+@Experimental(Kind.SPLITTABLE_DO_FN)\n+public class GrowableOffsetRangeTracker extends OffsetRangeTracker {\n+  /**\n+   * An interface that should be implemented to fetch estimated end offset of range.\n+   *\n+   * <p>{@code estimateRangeEnd} is called to give te end offset when {@code trySplit} or {@code\n+   * getProgress} is invoked. The end offset is exclusive for the range. It's not necessary to\n+   * increase monotonically but it's only taken into computation when it's larger than the current\n+   * position. When returning Long.MAX_VALUE as estimate, it means the largest possible position for\n+   * the range is Long.MAX_VALUE - 1. Having a good estimate is important for providing a good\n+   * signal of progress and splitting at a proper position.\n+   */\n+  public interface OffsetPoller {\n+    long estimateRangeEnd();\n+  }\n+\n+  private final OffsetPoller poller;", "originalCommit": "2aedee9a63b22655de8b7f23f2127db8640c0fd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTkwMTE4Mw==", "url": "https://github.com/apache/beam/pull/11715#discussion_r425901183", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              public void testCheckpointJustStar() throws Exception {\n          \n          \n            \n              public void testCheckpointJustStarted() throws Exception {", "author": "lukecwik", "createdAt": "2020-05-15T16:05:29Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/GrowableOffsetRangeTrackerTest.java", "diffHunk": "@@ -0,0 +1,212 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms.splittabledofn;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.apache.beam.sdk.io.range.OffsetRange;\n+import org.apache.beam.sdk.transforms.splittabledofn.RestrictionTracker.Progress;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Tests for {@link GrowableOffsetRangeTracker}. */\n+@RunWith(JUnit4.class)\n+public class GrowableOffsetRangeTrackerTest {\n+  private static class SimplePoller implements GrowableOffsetRangeTracker.OffsetPoller {\n+    private long estimateRangeEnd = 0;\n+\n+    @Override\n+    public long estimateRangeEnd() {\n+      return estimateRangeEnd;\n+    }\n+\n+    public void setEstimateRangeEnd(long offset) {\n+      estimateRangeEnd = offset;\n+    }\n+  }\n+\n+  @Rule public final ExpectedException expected = ExpectedException.none();\n+\n+  @Test\n+  public void testIllegalInitialization() throws Exception {\n+    expected.expect(NullPointerException.class);\n+    GrowableOffsetRangeTracker tracker = new GrowableOffsetRangeTracker(0L, null);\n+  }\n+\n+  @Test\n+  public void testTryClaim() throws Exception {\n+    GrowableOffsetRangeTracker tracker = new GrowableOffsetRangeTracker(0L, new SimplePoller());\n+    assertTrue(tracker.tryClaim(10L));\n+    assertTrue(tracker.tryClaim(100L));\n+    assertFalse(tracker.tryClaim(Long.MAX_VALUE));\n+    tracker.checkDone();\n+  }\n+\n+  @Test\n+  public void testCheckpointBeforeStart() throws Exception {\n+    SimplePoller poller = new SimplePoller();\n+    GrowableOffsetRangeTracker tracker = new GrowableOffsetRangeTracker(0L, poller);\n+    poller.setEstimateRangeEnd(10);\n+    SplitResult res = tracker.trySplit(0);\n+    tracker.checkDone();\n+    assertEquals(new OffsetRange(0, 0), res.getPrimary());\n+    assertEquals(new OffsetRange(0, 0), tracker.currentRestriction());\n+    assertEquals(new OffsetRange(0, Long.MAX_VALUE), res.getResidual());\n+  }\n+\n+  @Test\n+  public void testCheckpointJustStar() throws Exception {", "originalCommit": "2aedee9a63b22655de8b7f23f2127db8640c0fd7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2f44b7c32d5692c477338a0e4992199db93f7933", "url": "https://github.com/apache/beam/commit/2f44b7c32d5692c477338a0e4992199db93f7933", "message": "Use double during computation to avoid overflow in long.", "committedDate": "2020-05-15T21:54:47Z", "type": "forcePushed"}, {"oid": "f75a7b3b2ae6bba6cb53911606f9c87c6018ac73", "url": "https://github.com/apache/beam/commit/f75a7b3b2ae6bba6cb53911606f9c87c6018ac73", "message": "Fix test", "committedDate": "2020-05-15T23:16:10Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM5ODM1OQ==", "url": "https://github.com/apache/beam/pull/11715#discussion_r427398359", "bodyText": "nit: SimplePoller -> SimpleEstimator", "author": "lukecwik", "createdAt": "2020-05-19T15:34:25Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/GrowableOffsetRangeTrackerTest.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms.splittabledofn;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.apache.beam.sdk.io.range.OffsetRange;\n+import org.apache.beam.sdk.transforms.splittabledofn.RestrictionTracker.Progress;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Tests for {@link GrowableOffsetRangeTracker}. */\n+@RunWith(JUnit4.class)\n+public class GrowableOffsetRangeTrackerTest {\n+  private static class SimplePoller implements GrowableOffsetRangeTracker.RangeEndEstimator {", "originalCommit": "f75a7b3b2ae6bba6cb53911606f9c87c6018ac73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzM5OTM1OQ==", "url": "https://github.com/apache/beam/pull/11715#discussion_r427399359", "bodyText": "nit: poller -> estimator\nhere and elsewhere in this test", "author": "lukecwik", "createdAt": "2020-05-19T15:35:46Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/GrowableOffsetRangeTrackerTest.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms.splittabledofn;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.apache.beam.sdk.io.range.OffsetRange;\n+import org.apache.beam.sdk.transforms.splittabledofn.RestrictionTracker.Progress;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Tests for {@link GrowableOffsetRangeTracker}. */\n+@RunWith(JUnit4.class)\n+public class GrowableOffsetRangeTrackerTest {\n+  private static class SimplePoller implements GrowableOffsetRangeTracker.RangeEndEstimator {\n+    private long estimateRangeEnd = 0;\n+\n+    @Override\n+    public long estimate() {\n+      return estimateRangeEnd;\n+    }\n+\n+    public void setEstimateRangeEnd(long offset) {\n+      estimateRangeEnd = offset;\n+    }\n+  }\n+\n+  @Rule public final ExpectedException expected = ExpectedException.none();\n+\n+  @Test\n+  public void testIllegalInitialization() throws Exception {\n+    expected.expect(NullPointerException.class);\n+    GrowableOffsetRangeTracker tracker = new GrowableOffsetRangeTracker(0L, null);\n+  }\n+\n+  @Test\n+  public void testTryClaim() throws Exception {\n+    GrowableOffsetRangeTracker tracker = new GrowableOffsetRangeTracker(0L, new SimplePoller());\n+    assertTrue(tracker.tryClaim(10L));\n+    assertTrue(tracker.tryClaim(100L));\n+    assertFalse(tracker.tryClaim(Long.MAX_VALUE));\n+    tracker.checkDone();\n+  }\n+\n+  @Test\n+  public void testCheckpointBeforeStart() throws Exception {\n+    SimplePoller poller = new SimplePoller();", "originalCommit": "f75a7b3b2ae6bba6cb53911606f9c87c6018ac73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQwMDAxMQ==", "url": "https://github.com/apache/beam/pull/11715#discussion_r427400011", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // The split of infinite range results in one finite range and on infinite range.\n          \n          \n            \n                // The split of infinite range results in one finite range and one infinite range.", "author": "lukecwik", "createdAt": "2020-05-19T15:36:50Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/transforms/splittabledofn/GrowableOffsetRangeTrackerTest.java", "diffHunk": "@@ -0,0 +1,231 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms.splittabledofn;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+\n+import org.apache.beam.sdk.io.range.OffsetRange;\n+import org.apache.beam.sdk.transforms.splittabledofn.RestrictionTracker.Progress;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.junit.rules.ExpectedException;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Tests for {@link GrowableOffsetRangeTracker}. */\n+@RunWith(JUnit4.class)\n+public class GrowableOffsetRangeTrackerTest {\n+  private static class SimplePoller implements GrowableOffsetRangeTracker.RangeEndEstimator {\n+    private long estimateRangeEnd = 0;\n+\n+    @Override\n+    public long estimate() {\n+      return estimateRangeEnd;\n+    }\n+\n+    public void setEstimateRangeEnd(long offset) {\n+      estimateRangeEnd = offset;\n+    }\n+  }\n+\n+  @Rule public final ExpectedException expected = ExpectedException.none();\n+\n+  @Test\n+  public void testIllegalInitialization() throws Exception {\n+    expected.expect(NullPointerException.class);\n+    GrowableOffsetRangeTracker tracker = new GrowableOffsetRangeTracker(0L, null);\n+  }\n+\n+  @Test\n+  public void testTryClaim() throws Exception {\n+    GrowableOffsetRangeTracker tracker = new GrowableOffsetRangeTracker(0L, new SimplePoller());\n+    assertTrue(tracker.tryClaim(10L));\n+    assertTrue(tracker.tryClaim(100L));\n+    assertFalse(tracker.tryClaim(Long.MAX_VALUE));\n+    tracker.checkDone();\n+  }\n+\n+  @Test\n+  public void testCheckpointBeforeStart() throws Exception {\n+    SimplePoller poller = new SimplePoller();\n+    GrowableOffsetRangeTracker tracker = new GrowableOffsetRangeTracker(0L, poller);\n+    poller.setEstimateRangeEnd(10);\n+    SplitResult res = tracker.trySplit(0);\n+    tracker.checkDone();\n+    assertEquals(new OffsetRange(0, 0), res.getPrimary());\n+    assertEquals(new OffsetRange(0, 0), tracker.currentRestriction());\n+    assertEquals(new OffsetRange(0, Long.MAX_VALUE), res.getResidual());\n+  }\n+\n+  @Test\n+  public void testCheckpointJustStarted() throws Exception {\n+    SimplePoller poller = new SimplePoller();\n+    GrowableOffsetRangeTracker tracker = new GrowableOffsetRangeTracker(0L, poller);\n+    assertTrue(tracker.tryClaim(5L));\n+    poller.setEstimateRangeEnd(0L);\n+    SplitResult res = tracker.trySplit(0);\n+    tracker.checkDone();\n+    assertEquals(new OffsetRange(0, 6), res.getPrimary());\n+    assertEquals(new OffsetRange(0, 6), tracker.currentRestriction());\n+    assertEquals(new OffsetRange(6, Long.MAX_VALUE), res.getResidual());\n+\n+    tracker = new GrowableOffsetRangeTracker(0L, poller);\n+    assertTrue(tracker.tryClaim(5L));\n+    poller.setEstimateRangeEnd(20L);\n+    res = tracker.trySplit(0);\n+    tracker.checkDone();\n+    assertEquals(new OffsetRange(0, 6), res.getPrimary());\n+    assertEquals(new OffsetRange(6, Long.MAX_VALUE), res.getResidual());\n+  }\n+\n+  @Test\n+  public void testCheckpointAfterAllProcessed() throws Exception {\n+    SimplePoller poller = new SimplePoller();\n+    GrowableOffsetRangeTracker tracker = new GrowableOffsetRangeTracker(0L, poller);\n+    assertFalse(tracker.tryClaim(Long.MAX_VALUE));\n+    tracker.checkDone();\n+    assertNull(tracker.trySplit(0));\n+  }\n+\n+  @Test\n+  public void testCheckpointAtEmptyRange() throws Exception {\n+    GrowableOffsetRangeTracker tracker =\n+        new GrowableOffsetRangeTracker(Long.MAX_VALUE, new SimplePoller());\n+    tracker.checkDone();\n+    assertNull(tracker.trySplit(0));\n+  }\n+\n+  @Test\n+  public void testSplit() throws Exception {\n+    SimplePoller poller = new SimplePoller();\n+    GrowableOffsetRangeTracker tracker = new GrowableOffsetRangeTracker(0L, poller);\n+    assertTrue(tracker.tryClaim(0L));\n+\n+    poller.setEstimateRangeEnd(16L);\n+    // The split of infinite range results in one finite range and on infinite range.", "originalCommit": "f75a7b3b2ae6bba6cb53911606f9c87c6018ac73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQwMjE0MQ==", "url": "https://github.com/apache/beam/pull/11715#discussion_r427402141", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * used as end range to indicate the possibility of infinity.\n          \n          \n            \n             * used as the end of the range to indicate infinity.", "author": "lukecwik", "createdAt": "2020-05-19T15:39:54Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/GrowableOffsetRangeTracker.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms.splittabledofn;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.annotations.Experimental.Kind;\n+import org.apache.beam.sdk.io.range.OffsetRange;\n+\n+/**\n+ * An {@link OffsetRangeTracker} for tracking a growable offset range. {@code Long.MAX_VALUE} is\n+ * used as end range to indicate the possibility of infinity.", "originalCommit": "f75a7b3b2ae6bba6cb53911606f9c87c6018ac73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQwNjczNQ==", "url": "https://github.com/apache/beam/pull/11715#discussion_r427406735", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n               * An interface that should be implemented to fetch estimated end offset of the range.\n          \n          \n            \n               *\n          \n          \n            \n               * <p>{@code estimateRangeEnd} is called to give the end offset when {@code trySplit} or {@code\n          \n          \n            \n               * getProgress} is invoked. The end offset is exclusive for the range. The estimated end is not\n          \n          \n            \n               * necessary to increase monotonically as it will only be taken into computation when the estimate\n          \n          \n            \n               * end is larger than the current position. When returning {@code Long.MAX_VALUE} as estimate, it\n          \n          \n            \n               * means the largest possible position for the range is {@code Long.MAX_VALUE - 1}. If there is\n          \n          \n            \n               * not an estimate yet, {@code Long.MIN_VALUE} should be returned, where estimated end will not\n          \n          \n            \n               * effect progress and split.\n          \n          \n            \n               *\n          \n          \n            \n               * <p>Having a good estimate is important for providing a good signal of progress and splitting at\n          \n          \n            \n               * a proper position.\n          \n          \n            \n               *\n          \n          \n            \n               * <p>If {@code estimate()} is expensive to call, please consider wrapping the implementation with\n          \n          \n            \n               * {@code Suppliers.memoizeWithExpiration} as an optimization.\n          \n          \n            \n               * Provides the estimated end offset of the range.\n          \n          \n            \n               *\n          \n          \n            \n               * <p>{@link #estimate} is called to give the end offset when {@link #trySplit} or {@link\n          \n          \n            \n               * #getProgress} is invoked. The end offset is exclusive for the range. The estimated end is not\n          \n          \n            \n               * required to monotonically increase as it will only be taken into consideration when the estimated\n          \n          \n            \n               * end offset is larger than the current position. Returning {@code Long.MAX_VALUE} as the estimate\n          \n          \n            \n               * implies the largest possible position for the range is {@code Long.MAX_VALUE - 1}. Return {@code Long.MIN_VALUE} if an estimate can not be provided.\n          \n          \n            \n               *\n          \n          \n            \n               * <p>Providing a good estimate is important for an accurate progress signal and will impact splitting decisions by\n          \n          \n            \n               * the runner.\n          \n          \n            \n               *\n          \n          \n            \n               * <p>If {@link #estimate} is expensive to compute, consider wrapping the implementation with\n          \n          \n            \n               * {@link Suppliers.memoizeWithExpiration} or equivalent as an optimization.", "author": "lukecwik", "createdAt": "2020-05-19T15:46:08Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/GrowableOffsetRangeTracker.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms.splittabledofn;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.annotations.Experimental.Kind;\n+import org.apache.beam.sdk.io.range.OffsetRange;\n+\n+/**\n+ * An {@link OffsetRangeTracker} for tracking a growable offset range. {@code Long.MAX_VALUE} is\n+ * used as end range to indicate the possibility of infinity.\n+ *\n+ * <p>An offset range is considered growable when the end offset could grow (or change) during\n+ * execution time (e.g., Kafka topic partition offset, appended file, ...).\n+ *\n+ * <p>The growable range is marked as done by claiming {@code Long.MAX_VALUE}.\n+ */\n+@Experimental(Kind.SPLITTABLE_DO_FN)\n+public class GrowableOffsetRangeTracker extends OffsetRangeTracker {\n+  /**\n+   * An interface that should be implemented to fetch estimated end offset of the range.\n+   *\n+   * <p>{@code estimateRangeEnd} is called to give the end offset when {@code trySplit} or {@code\n+   * getProgress} is invoked. The end offset is exclusive for the range. The estimated end is not\n+   * necessary to increase monotonically as it will only be taken into computation when the estimate\n+   * end is larger than the current position. When returning {@code Long.MAX_VALUE} as estimate, it\n+   * means the largest possible position for the range is {@code Long.MAX_VALUE - 1}. If there is\n+   * not an estimate yet, {@code Long.MIN_VALUE} should be returned, where estimated end will not\n+   * effect progress and split.\n+   *\n+   * <p>Having a good estimate is important for providing a good signal of progress and splitting at\n+   * a proper position.\n+   *\n+   * <p>If {@code estimate()} is expensive to call, please consider wrapping the implementation with\n+   * {@code Suppliers.memoizeWithExpiration} as an optimization.", "originalCommit": "f75a7b3b2ae6bba6cb53911606f9c87c6018ac73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxMDc1NQ==", "url": "https://github.com/apache/beam/pull/11715#discussion_r427410755", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Convert to double in computation to prevent overflow, which may result in lost of some\n          \n          \n            \n                // accuracy.\n          \n          \n            \n                // Convert to double in computation to prevent overflow, which may result in loss of\n          \n          \n            \n                // precision.", "author": "lukecwik", "createdAt": "2020-05-19T15:51:50Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/GrowableOffsetRangeTracker.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms.splittabledofn;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.annotations.Experimental.Kind;\n+import org.apache.beam.sdk.io.range.OffsetRange;\n+\n+/**\n+ * An {@link OffsetRangeTracker} for tracking a growable offset range. {@code Long.MAX_VALUE} is\n+ * used as end range to indicate the possibility of infinity.\n+ *\n+ * <p>An offset range is considered growable when the end offset could grow (or change) during\n+ * execution time (e.g., Kafka topic partition offset, appended file, ...).\n+ *\n+ * <p>The growable range is marked as done by claiming {@code Long.MAX_VALUE}.\n+ */\n+@Experimental(Kind.SPLITTABLE_DO_FN)\n+public class GrowableOffsetRangeTracker extends OffsetRangeTracker {\n+  /**\n+   * An interface that should be implemented to fetch estimated end offset of the range.\n+   *\n+   * <p>{@code estimateRangeEnd} is called to give the end offset when {@code trySplit} or {@code\n+   * getProgress} is invoked. The end offset is exclusive for the range. The estimated end is not\n+   * necessary to increase monotonically as it will only be taken into computation when the estimate\n+   * end is larger than the current position. When returning {@code Long.MAX_VALUE} as estimate, it\n+   * means the largest possible position for the range is {@code Long.MAX_VALUE - 1}. If there is\n+   * not an estimate yet, {@code Long.MIN_VALUE} should be returned, where estimated end will not\n+   * effect progress and split.\n+   *\n+   * <p>Having a good estimate is important for providing a good signal of progress and splitting at\n+   * a proper position.\n+   *\n+   * <p>If {@code estimate()} is expensive to call, please consider wrapping the implementation with\n+   * {@code Suppliers.memoizeWithExpiration} as an optimization.\n+   */\n+  @FunctionalInterface\n+  public interface RangeEndEstimator {\n+    long estimate();\n+  }\n+\n+  private final RangeEndEstimator rangeEndEstimator;\n+\n+  public GrowableOffsetRangeTracker(long start, RangeEndEstimator rangeEndEstimator) {\n+    super(new OffsetRange(start, Long.MAX_VALUE));\n+    this.rangeEndEstimator = checkNotNull(rangeEndEstimator);\n+  }\n+\n+  @Override\n+  public SplitResult<OffsetRange> trySplit(double fractionOfRemainder) {\n+    // If current tracking range is no longer growable, split it as a normal range.\n+    if (range.getTo() != Long.MAX_VALUE || range.getTo() == range.getFrom()) {\n+      return super.trySplit(fractionOfRemainder);\n+    }\n+    // If current range has been done, there is no more space to split.\n+    if (lastAttemptedOffset != null && lastAttemptedOffset == Long.MAX_VALUE) {\n+      return null;\n+    }\n+    double cur =\n+        (lastAttemptedOffset == null) ? (double) range.getFrom() - 1 : (double) lastAttemptedOffset;\n+\n+    // Fetch the estimated end offset. If the estimated end is smaller than the next offset, use\n+    // the next offset as end.\n+    double estimateRangeEnd = Math.max(rangeEndEstimator.estimate(), cur + 1);\n+\n+    // Convert to double in computation to prevent overflow, which may result in lost of some\n+    // accuracy.", "originalCommit": "f75a7b3b2ae6bba6cb53911606f9c87c6018ac73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxMTA2Mg==", "url": "https://github.com/apache/beam/pull/11715#discussion_r427411062", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Convert to double in computation to prevent overflow, which may result in lost of some\n          \n          \n            \n                // accuracy.\n          \n          \n            \n                // Convert to double in computation to prevent overflow, which may result in loss of\n          \n          \n            \n                // precision.", "author": "lukecwik", "createdAt": "2020-05-19T15:52:17Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/OffsetRangeTracker.java", "diffHunk": "@@ -50,16 +53,17 @@ public OffsetRange currentRestriction() {\n \n   @Override\n   public SplitResult<OffsetRange> trySplit(double fractionOfRemainder) {\n-    long cur = (lastAttemptedOffset == null) ? range.getFrom() - 1 : lastAttemptedOffset;\n-    long splitPos =\n-        cur\n-            + Math.max(\n-                1L, (Double.valueOf((range.getTo() - cur) * fractionOfRemainder)).longValue());\n-    if (splitPos >= range.getTo()) {\n+    // Convert to double in computation to prevent overflow, which may result in lost of some\n+    // accuracy.", "originalCommit": "f75a7b3b2ae6bba6cb53911606f9c87c6018ac73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxMTMxNQ==", "url": "https://github.com/apache/beam/pull/11715#discussion_r427411315", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Convert to double in computation to prevent overflow, which may result in lost of some\n          \n          \n            \n                // accuracy.\n          \n          \n            \n                // Convert to double in computation to prevent overflow, which may result in loss of\n          \n          \n            \n                // precision.", "author": "lukecwik", "createdAt": "2020-05-19T15:52:34Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/OffsetRangeTracker.java", "diffHunk": "@@ -120,13 +124,16 @@ public String toString() {\n   public Progress getProgress() {\n     // If we have never attempted an offset, we return the length of the entire range as work\n     // remaining.\n+    // Convert to double in computation to prevent overflow, which may result in lost of some\n+    // accuracy.", "originalCommit": "f75a7b3b2ae6bba6cb53911606f9c87c6018ac73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQxMzQ3MA==", "url": "https://github.com/apache/beam/pull/11715#discussion_r427413470", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // Convert to double in computation to prevent overflow, which may result in lost of some\n          \n          \n            \n                // accuracy.\n          \n          \n            \n                // Convert to double in computation to prevent overflow, which may result in lost of\n          \n          \n            \n                // precision.", "author": "lukecwik", "createdAt": "2020-05-19T15:55:34Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/GrowableOffsetRangeTracker.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms.splittabledofn;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.annotations.Experimental.Kind;\n+import org.apache.beam.sdk.io.range.OffsetRange;\n+\n+/**\n+ * An {@link OffsetRangeTracker} for tracking a growable offset range. {@code Long.MAX_VALUE} is\n+ * used as end range to indicate the possibility of infinity.\n+ *\n+ * <p>An offset range is considered growable when the end offset could grow (or change) during\n+ * execution time (e.g., Kafka topic partition offset, appended file, ...).\n+ *\n+ * <p>The growable range is marked as done by claiming {@code Long.MAX_VALUE}.\n+ */\n+@Experimental(Kind.SPLITTABLE_DO_FN)\n+public class GrowableOffsetRangeTracker extends OffsetRangeTracker {\n+  /**\n+   * An interface that should be implemented to fetch estimated end offset of the range.\n+   *\n+   * <p>{@code estimateRangeEnd} is called to give the end offset when {@code trySplit} or {@code\n+   * getProgress} is invoked. The end offset is exclusive for the range. The estimated end is not\n+   * necessary to increase monotonically as it will only be taken into computation when the estimate\n+   * end is larger than the current position. When returning {@code Long.MAX_VALUE} as estimate, it\n+   * means the largest possible position for the range is {@code Long.MAX_VALUE - 1}. If there is\n+   * not an estimate yet, {@code Long.MIN_VALUE} should be returned, where estimated end will not\n+   * effect progress and split.\n+   *\n+   * <p>Having a good estimate is important for providing a good signal of progress and splitting at\n+   * a proper position.\n+   *\n+   * <p>If {@code estimate()} is expensive to call, please consider wrapping the implementation with\n+   * {@code Suppliers.memoizeWithExpiration} as an optimization.\n+   */\n+  @FunctionalInterface\n+  public interface RangeEndEstimator {\n+    long estimate();\n+  }\n+\n+  private final RangeEndEstimator rangeEndEstimator;\n+\n+  public GrowableOffsetRangeTracker(long start, RangeEndEstimator rangeEndEstimator) {\n+    super(new OffsetRange(start, Long.MAX_VALUE));\n+    this.rangeEndEstimator = checkNotNull(rangeEndEstimator);\n+  }\n+\n+  @Override\n+  public SplitResult<OffsetRange> trySplit(double fractionOfRemainder) {\n+    // If current tracking range is no longer growable, split it as a normal range.\n+    if (range.getTo() != Long.MAX_VALUE || range.getTo() == range.getFrom()) {\n+      return super.trySplit(fractionOfRemainder);\n+    }\n+    // If current range has been done, there is no more space to split.\n+    if (lastAttemptedOffset != null && lastAttemptedOffset == Long.MAX_VALUE) {\n+      return null;\n+    }\n+    double cur =\n+        (lastAttemptedOffset == null) ? (double) range.getFrom() - 1 : (double) lastAttemptedOffset;\n+\n+    // Fetch the estimated end offset. If the estimated end is smaller than the next offset, use\n+    // the next offset as end.\n+    double estimateRangeEnd = Math.max(rangeEndEstimator.estimate(), cur + 1);\n+\n+    // Convert to double in computation to prevent overflow, which may result in lost of some\n+    // accuracy.\n+    double splitPos = cur + Math.max(1L, (estimateRangeEnd - cur) * fractionOfRemainder);\n+    long split = Double.valueOf(splitPos).longValue();\n+    if (split > Double.valueOf(estimateRangeEnd).longValue()) {\n+      return null;\n+    }\n+    OffsetRange res = new OffsetRange(split, range.getTo());\n+    this.range = new OffsetRange(range.getFrom(), split);\n+    return SplitResult.of(range, res);\n+  }\n+\n+  @Override\n+  public Progress getProgress() {\n+    // If current tracking range is no longer growable, get progress as a normal range.\n+    if (range.getTo() != Long.MAX_VALUE || range.getTo() == range.getFrom()) {\n+      return super.getProgress();\n+    }\n+\n+    // Convert to double in computation to prevent overflow, which may result in lost of some\n+    // accuracy.", "originalCommit": "f75a7b3b2ae6bba6cb53911606f9c87c6018ac73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQzMTE0MA==", "url": "https://github.com/apache/beam/pull/11715#discussion_r427431140", "bodyText": "We should only use doubles if there would be an issue with overflow. For really large long values we can have the math be incorrect which can lead to the splitPos being before from or after to even though with higher precision we would get something that works. For example:\n    long a = 123456789012345677L;\n    long b = 123456789012345679L;\n    long c = 123456789012345680L;\n    double ad = a;\n    double bd = b;\n    double cd = c;\n    System.out.println((long)ad + \" \" + (long)bd + \" \" + (long)cd);\n\nprints\n123456789012345680 123456789012345680 123456789012345680\n\nWorthwhile to have a test which exercises a case where from = 123456789012345677L and to = 123456789012345679L and we can have a split in between. Also worthwhile to test from = 123456789012345681L and to = 123456789012345683L. All these values (and the values in between) when converted to double and back to long round to 123456789012345680L.\nWe can solve this by having two ways to calculate this or using BigDecimal. The two ways to calculate method would use longs when (estimateRangeEnd - cur) won't overflow and doubles otherwise. Using BigDecimal with a MathContext with enough precision wouldn't run into this either and would only require one implemention (I believe DECIMAL128 should have enough precision to not run into this issue).", "author": "lukecwik", "createdAt": "2020-05-19T16:20:33Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/GrowableOffsetRangeTracker.java", "diffHunk": "@@ -0,0 +1,115 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms.splittabledofn;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.annotations.Experimental.Kind;\n+import org.apache.beam.sdk.io.range.OffsetRange;\n+\n+/**\n+ * An {@link OffsetRangeTracker} for tracking a growable offset range. {@code Long.MAX_VALUE} is\n+ * used as end range to indicate the possibility of infinity.\n+ *\n+ * <p>An offset range is considered growable when the end offset could grow (or change) during\n+ * execution time (e.g., Kafka topic partition offset, appended file, ...).\n+ *\n+ * <p>The growable range is marked as done by claiming {@code Long.MAX_VALUE}.\n+ */\n+@Experimental(Kind.SPLITTABLE_DO_FN)\n+public class GrowableOffsetRangeTracker extends OffsetRangeTracker {\n+  /**\n+   * An interface that should be implemented to fetch estimated end offset of the range.\n+   *\n+   * <p>{@code estimateRangeEnd} is called to give the end offset when {@code trySplit} or {@code\n+   * getProgress} is invoked. The end offset is exclusive for the range. The estimated end is not\n+   * necessary to increase monotonically as it will only be taken into computation when the estimate\n+   * end is larger than the current position. When returning {@code Long.MAX_VALUE} as estimate, it\n+   * means the largest possible position for the range is {@code Long.MAX_VALUE - 1}. If there is\n+   * not an estimate yet, {@code Long.MIN_VALUE} should be returned, where estimated end will not\n+   * effect progress and split.\n+   *\n+   * <p>Having a good estimate is important for providing a good signal of progress and splitting at\n+   * a proper position.\n+   *\n+   * <p>If {@code estimate()} is expensive to call, please consider wrapping the implementation with\n+   * {@code Suppliers.memoizeWithExpiration} as an optimization.\n+   */\n+  @FunctionalInterface\n+  public interface RangeEndEstimator {\n+    long estimate();\n+  }\n+\n+  private final RangeEndEstimator rangeEndEstimator;\n+\n+  public GrowableOffsetRangeTracker(long start, RangeEndEstimator rangeEndEstimator) {\n+    super(new OffsetRange(start, Long.MAX_VALUE));\n+    this.rangeEndEstimator = checkNotNull(rangeEndEstimator);\n+  }\n+\n+  @Override\n+  public SplitResult<OffsetRange> trySplit(double fractionOfRemainder) {\n+    // If current tracking range is no longer growable, split it as a normal range.\n+    if (range.getTo() != Long.MAX_VALUE || range.getTo() == range.getFrom()) {\n+      return super.trySplit(fractionOfRemainder);\n+    }\n+    // If current range has been done, there is no more space to split.\n+    if (lastAttemptedOffset != null && lastAttemptedOffset == Long.MAX_VALUE) {\n+      return null;\n+    }\n+    double cur =", "originalCommit": "f75a7b3b2ae6bba6cb53911606f9c87c6018ac73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzY1NDExNQ==", "url": "https://github.com/apache/beam/pull/11715#discussion_r427654115", "bodyText": "Using BigDecimal in the latest revision. Thanks for your help!", "author": "boyuanzz", "createdAt": "2020-05-19T23:21:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQzMTE0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNDcyMw==", "url": "https://github.com/apache/beam/pull/11715#discussion_r428304723", "bodyText": "Doesn't this subtract need the DECIMAL128 math context?", "author": "lukecwik", "createdAt": "2020-05-20T21:00:45Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/GrowableOffsetRangeTracker.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.transforms.splittabledofn;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull;\n+\n+import java.math.BigDecimal;\n+import java.math.MathContext;\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.annotations.Experimental.Kind;\n+import org.apache.beam.sdk.io.range.OffsetRange;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Suppliers;\n+\n+/**\n+ * An {@link OffsetRangeTracker} for tracking a growable offset range. {@code Long.MAX_VALUE} is\n+ * used as the end of the range to indicate infinity.\n+ *\n+ * <p>An offset range is considered growable when the end offset could grow (or change) during\n+ * execution time (e.g., Kafka topic partition offset, appended file, ...).\n+ *\n+ * <p>The growable range is marked as done by claiming {@code Long.MAX_VALUE}.\n+ */\n+@Experimental(Kind.SPLITTABLE_DO_FN)\n+public class GrowableOffsetRangeTracker extends OffsetRangeTracker {\n+  /**\n+   * Provides the estimated end offset of the range.\n+   *\n+   * <p>{@link #estimate} is called to give the end offset when {@link #trySplit} or {@link\n+   * #getProgress} is invoked. The end offset is exclusive for the range. The estimated end is not\n+   * required to monotonically increase as it will only be taken into consideration when the\n+   * estimated end offset is larger than the current position. Returning {@code Long.MAX_VALUE} as\n+   * the estimate implies the largest possible position for the range is {@code Long.MAX_VALUE - 1}.\n+   * Return {@code Long.MIN_VALUE} if an estimate can not be provided.\n+   *\n+   * <p>Providing a good estimate is important for an accurate progress signal and will impact\n+   * splitting decisions by the runner.\n+   *\n+   * <p>If {@link #estimate} is expensive to compute, consider wrapping the implementation with\n+   * {@link Suppliers#memoizeWithExpiration} or equivalent as an optimization.\n+   *\n+   * <p>TODO(BEAM-10032): Also consider using {@link RangeEndEstimator} when the range is not ended\n+   * with {@code Long.MAX_VALUE}.\n+   */\n+  @FunctionalInterface\n+  public interface RangeEndEstimator {\n+    long estimate();\n+  }\n+\n+  private final RangeEndEstimator rangeEndEstimator;\n+\n+  public GrowableOffsetRangeTracker(long start, RangeEndEstimator rangeEndEstimator) {\n+    super(new OffsetRange(start, Long.MAX_VALUE));\n+    this.rangeEndEstimator = checkNotNull(rangeEndEstimator);\n+  }\n+\n+  @Override\n+  public SplitResult<OffsetRange> trySplit(double fractionOfRemainder) {\n+    // If current tracking range is no longer growable, split it as a normal range.\n+    if (range.getTo() != Long.MAX_VALUE || range.getTo() == range.getFrom()) {\n+      return super.trySplit(fractionOfRemainder);\n+    }\n+    // If current range has been done, there is no more space to split.\n+    if (lastAttemptedOffset != null && lastAttemptedOffset == Long.MAX_VALUE) {\n+      return null;\n+    }\n+    BigDecimal cur =\n+        (lastAttemptedOffset == null)\n+            ? BigDecimal.valueOf(range.getFrom()).subtract(BigDecimal.ONE, MathContext.DECIMAL128)\n+            : BigDecimal.valueOf(lastAttemptedOffset);\n+\n+    // Fetch the estimated end offset. If the estimated end is smaller than the next offset, use\n+    // the next offset as end.\n+    BigDecimal estimateRangeEnd =\n+        BigDecimal.valueOf(rangeEndEstimator.estimate())\n+            .max(cur.add(BigDecimal.ONE, MathContext.DECIMAL128));\n+\n+    // Convert to BigDecimal in computation to prevent overflow, which may result in loss of\n+    // precision.\n+    // split = cur + max(1, (estimateRangeEnd - cur) * fractionOfRemainder)\n+    BigDecimal splitPos =\n+        cur.add(\n+            estimateRangeEnd\n+                .subtract(cur, MathContext.DECIMAL128)\n+                .multiply(BigDecimal.valueOf(fractionOfRemainder), MathContext.DECIMAL128)\n+                .max(BigDecimal.ONE),\n+            MathContext.DECIMAL128);\n+    long split = splitPos.longValue();\n+    if (split > estimateRangeEnd.longValue()) {\n+      return null;\n+    }\n+    OffsetRange res = new OffsetRange(split, range.getTo());\n+    this.range = new OffsetRange(range.getFrom(), split);\n+    return SplitResult.of(range, res);\n+  }\n+\n+  @Override\n+  public Progress getProgress() {\n+    // If current tracking range is no longer growable, get progress as a normal range.\n+    if (range.getTo() != Long.MAX_VALUE || range.getTo() == range.getFrom()) {\n+      return super.getProgress();\n+    }\n+\n+    // Convert to BigDecimal in computation to prevent overflow, which may result in lost of\n+    // precision.\n+    BigDecimal estimateRangeEnd = BigDecimal.valueOf(rangeEndEstimator.estimate());\n+\n+    if (lastAttemptedOffset == null) {\n+      return Progress.from(\n+          0,\n+          estimateRangeEnd\n+              .subtract(BigDecimal.valueOf(range.getFrom()), MathContext.DECIMAL128)\n+              .max(BigDecimal.ZERO)\n+              .doubleValue());\n+    }\n+\n+    BigDecimal workRemaining =\n+        estimateRangeEnd\n+            .subtract(BigDecimal.valueOf(lastAttemptedOffset), MathContext.DECIMAL128)\n+            .max(BigDecimal.ZERO);\n+    BigDecimal totalWork =\n+        estimateRangeEnd\n+            .max(BigDecimal.valueOf(lastAttemptedOffset))\n+            .subtract(BigDecimal.valueOf(range.getFrom()));", "originalCommit": "c932a3191a7b830dd41ddab4a9a34243adcaf840", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM0Mzc1Mg==", "url": "https://github.com/apache/beam/pull/11715#discussion_r428343752", "bodyText": "It's needed as well.", "author": "boyuanzz", "createdAt": "2020-05-20T22:28:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNDcyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNTY3Mg==", "url": "https://github.com/apache/beam/pull/11715#discussion_r428305672", "bodyText": "nit: wholeWork -> totalWork", "author": "lukecwik", "createdAt": "2020-05-20T21:02:44Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/splittabledofn/OffsetRangeTracker.java", "diffHunk": "@@ -120,13 +136,27 @@ public String toString() {\n   public Progress getProgress() {\n     // If we have never attempted an offset, we return the length of the entire range as work\n     // remaining.\n+    // Convert to BigDecimal in computation to prevent overflow, which may result in loss of\n+    // precision.\n     if (lastAttemptedOffset == null) {\n-      return Progress.from(0, range.getTo() - range.getFrom());\n+      return Progress.from(\n+          0,\n+          BigDecimal.valueOf(range.getTo())\n+              .subtract(BigDecimal.valueOf(range.getFrom()), MathContext.DECIMAL128)\n+              .doubleValue());\n     }\n \n     // Compute the amount of work remaining from where we are to where we are attempting to get to\n     // with a minimum of zero in case we have claimed beyond the end of the range.\n-    long workRemaining = Math.max(range.getTo() - lastAttemptedOffset, 0);\n-    return Progress.from(range.getTo() - range.getFrom() - workRemaining, workRemaining);\n+    BigDecimal workRemaining =\n+        BigDecimal.valueOf(range.getTo())\n+            .subtract(BigDecimal.valueOf(lastAttemptedOffset), MathContext.DECIMAL128)\n+            .max(BigDecimal.ZERO);\n+    BigDecimal wholeWork =", "originalCommit": "c932a3191a7b830dd41ddab4a9a34243adcaf840", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODM0MzgxMw==", "url": "https://github.com/apache/beam/pull/11715#discussion_r428343813", "bodyText": "Done. Thanks!", "author": "boyuanzz", "createdAt": "2020-05-20T22:28:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMwNTY3Mg=="}], "type": "inlineReview"}, {"oid": "e1b148bf1f2e735ee082c06e1097fe72bb152365", "url": "https://github.com/apache/beam/commit/e1b148bf1f2e735ee082c06e1097fe72bb152365", "message": "Implement GrowableOffsetRangeTracker", "committedDate": "2020-05-20T22:22:14Z", "type": "commit"}, {"oid": "e1b148bf1f2e735ee082c06e1097fe72bb152365", "url": "https://github.com/apache/beam/commit/e1b148bf1f2e735ee082c06e1097fe72bb152365", "message": "Implement GrowableOffsetRangeTracker", "committedDate": "2020-05-20T22:22:14Z", "type": "forcePushed"}]}