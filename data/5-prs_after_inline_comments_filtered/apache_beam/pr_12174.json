{"pr_number": 12174, "pr_title": "[BEAM-10239] Support ZetaSQL NUMERIC type in BeamSQL", "pr_createdAt": "2020-07-05T03:54:01Z", "pr_url": "https://github.com/apache/beam/pull/12174", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk1ODg4NQ==", "url": "https://github.com/apache/beam/pull/12174#discussion_r453958885", "bodyText": "new BigDecimal(\"some string\").setScale(9) is used a lot of times in this file and the test file. I would create a utility function for better style.\nHow about we create a new file ZetaSqlTypesUtils.java in /main and make a BigDecimal bigDecimalAsNumeric(String s)?", "author": "robinyqiu", "createdAt": "2020-07-13T21:56:00Z", "path": "sdks/java/extensions/sql/zetasql/src/test/java/org/apache/beam/sdk/extensions/sql/zetasql/TestInput.java", "diffHunk": "@@ -258,6 +259,14 @@\n           .addRows(LocalTime.of(15, 30, 0), \"s\")\n           .addRows(LocalTime.of(23, 35, 59), \"s\");\n \n+  private static final Schema TABLE_WTH_NUMERIC_SCHEMA =\n+      Schema.builder().addDecimalField(\"numeric_field\").addStringField(\"str_field\").build();\n+  public static final TestBoundedTable TABLE_WITH_NUMERIC =\n+      TestBoundedTable.of(TABLE_WTH_NUMERIC_SCHEMA)\n+          .addRows(new BigDecimal(\"123.4567\").setScale(9), \"str1\")", "originalCommit": "f80e89b617b64c7a97c58df806bda6550adbbffd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA3OTY0NQ==", "url": "https://github.com/apache/beam/pull/12174#discussion_r454079645", "bodyText": "Seems a great idea. Done.", "author": "ZijieSong946", "createdAt": "2020-07-14T03:39:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk1ODg4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2MDc1Ng==", "url": "https://github.com/apache/beam/pull/12174#discussion_r453960756", "bodyText": "Nit: move this below testNumericLiteral() as we did in other places?", "author": "robinyqiu", "createdAt": "2020-07-13T21:58:40Z", "path": "sdks/java/extensions/sql/zetasql/src/test/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSqlDialectSpecTest.java", "diffHunk": "@@ -2174,6 +2175,246 @@ public void testZetaSQLNestedQueryFive() {\n     pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n   }\n \n+  /////////////////////////////////////////////////////////////////////////////\n+  // NUMERIC type tests\n+  /////////////////////////////////////////////////////////////////////////////\n+\n+  @Test\n+  public void testNumericLiteral() {\n+    String sql =\n+        \"SELECT NUMERIC '0', \"\n+            + \"NUMERIC '123456', \"\n+            + \"NUMERIC '-3.14', \"\n+            + \"NUMERIC '-0.54321', \"\n+            + \"NUMERIC '1.23456e05', \"\n+            + \"NUMERIC '-9.876e-3', \"\n+            + \"NUMERIC '-99999999999999999999999999999.999999999', \"\n+            + \"NUMERIC '99999999999999999999999999999.999999999'\";\n+    ;\n+\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    BeamRelNode beamRelNode = zetaSQLQueryPlanner.convertToBeamRel(sql);\n+    PCollection<Row> stream = BeamSqlRelUtils.toPCollection(pipeline, beamRelNode);\n+\n+    PAssert.that(stream)\n+        .containsInAnyOrder(\n+            Row.withSchema(\n+                    Schema.builder()\n+                        .addDecimalField(\"f_numeric1\")\n+                        .addDecimalField(\"f_numeric2\")\n+                        .addDecimalField(\"f_numeric3\")\n+                        .addDecimalField(\"f_numeric4\")\n+                        .addDecimalField(\"f_numeric5\")\n+                        .addDecimalField(\"f_numeric6\")\n+                        .addDecimalField(\"f_numeric7\")\n+                        .addDecimalField(\"f_numeric8\")\n+                        .build())\n+                .addValues(new BigDecimal(\"0\").setScale(9))\n+                .addValues(new BigDecimal(\"123456\").setScale(9))\n+                .addValues(new BigDecimal(\"-3.14\").setScale(9))\n+                .addValues(new BigDecimal(\"-0.54321\").setScale(9))\n+                .addValues(new BigDecimal(\"123456\").setScale(9))\n+                .addValues(new BigDecimal(\"-0.009876\").setScale(9))\n+                .addValues(new BigDecimal(\"-99999999999999999999999999999.999999999\"))\n+                .addValues(new BigDecimal(\"99999999999999999999999999999.999999999\"))\n+                .build());\n+    pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n+  }\n+\n+  @Test\n+  public void testUnaryMinusNumeric() {\n+    String sql = \"SELECT - NUMERIC '1.23456e05'\";\n+\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    BeamRelNode beamRelNode = zetaSQLQueryPlanner.convertToBeamRel(sql);\n+    PCollection<Row> stream = BeamSqlRelUtils.toPCollection(pipeline, beamRelNode);\n+\n+    PAssert.that(stream)\n+        .containsInAnyOrder(\n+            Row.withSchema(Schema.builder().addDecimalField(\"f_numeric\").build())\n+                .addValues(new BigDecimal(\"-123456\").setScale(9))\n+                .build());\n+    pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n+  }\n+\n+  @Test\n+  public void testAddNumeric() {\n+    String sql = \"SELECT NUMERIC '1.23456e05' + NUMERIC '9.876e-3'\";\n+\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    BeamRelNode beamRelNode = zetaSQLQueryPlanner.convertToBeamRel(sql);\n+    PCollection<Row> stream = BeamSqlRelUtils.toPCollection(pipeline, beamRelNode);\n+\n+    PAssert.that(stream)\n+        .containsInAnyOrder(\n+            Row.withSchema(Schema.builder().addDecimalField(\"f_numeric\").build())\n+                .addValues(new BigDecimal(\"123456.009876\").setScale(9))\n+                .build());\n+    pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n+  }\n+\n+  @Test\n+  public void testSubNumeric() {\n+    String sql = \"SELECT NUMERIC '1.23456e05' - NUMERIC '-9.876e-3'\";\n+\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    BeamRelNode beamRelNode = zetaSQLQueryPlanner.convertToBeamRel(sql);\n+    PCollection<Row> stream = BeamSqlRelUtils.toPCollection(pipeline, beamRelNode);\n+\n+    PAssert.that(stream)\n+        .containsInAnyOrder(\n+            Row.withSchema(Schema.builder().addDecimalField(\"f_numeric\").build())\n+                .addValues(new BigDecimal(\"123456.009876\").setScale(9))\n+                .build());\n+    pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n+  }\n+\n+  @Test\n+  public void testMultiNumeric() {\n+    String sql = \"SELECT NUMERIC '1.23e02' * NUMERIC '-1.001e-3'\";\n+\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    BeamRelNode beamRelNode = zetaSQLQueryPlanner.convertToBeamRel(sql);\n+    PCollection<Row> stream = BeamSqlRelUtils.toPCollection(pipeline, beamRelNode);\n+\n+    PAssert.that(stream)\n+        .containsInAnyOrder(\n+            Row.withSchema(Schema.builder().addDecimalField(\"f_numeric\").build())\n+                .addValues(new BigDecimal(\"-0.123123\").setScale(9))\n+                .build());\n+    pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n+  }\n+\n+  @Test\n+  public void testDivNumeric() {\n+    String sql = \"SELECT NUMERIC '-1.23123e-1' / NUMERIC '-1.001e-3'\";\n+\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    BeamRelNode beamRelNode = zetaSQLQueryPlanner.convertToBeamRel(sql);\n+    PCollection<Row> stream = BeamSqlRelUtils.toPCollection(pipeline, beamRelNode);\n+\n+    PAssert.that(stream)\n+        .containsInAnyOrder(\n+            Row.withSchema(Schema.builder().addDecimalField(\"f_numeric\").build())\n+                .addValues(new BigDecimal(\"123\").setScale(9))\n+                .build());\n+    pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n+  }\n+\n+  @Test\n+  public void testModNumeric() {\n+    String sql = \"SELECT MOD(NUMERIC '1.23456e05', NUMERIC '5')\";\n+\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    BeamRelNode beamRelNode = zetaSQLQueryPlanner.convertToBeamRel(sql);\n+    PCollection<Row> stream = BeamSqlRelUtils.toPCollection(pipeline, beamRelNode);\n+\n+    PAssert.that(stream)\n+        .containsInAnyOrder(\n+            Row.withSchema(Schema.builder().addDecimalField(\"f_numeric\").build())\n+                .addValues(new BigDecimal(\"1\").setScale(9))\n+                .build());\n+    pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n+  }\n+\n+  @Test\n+  public void testFloorNumeric() {\n+    String sql = \"SELECT FLOOR(NUMERIC '1.23456e04'), FLOOR(NUMERIC '-1.23456e04')\";\n+\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    BeamRelNode beamRelNode = zetaSQLQueryPlanner.convertToBeamRel(sql);\n+    PCollection<Row> stream = BeamSqlRelUtils.toPCollection(pipeline, beamRelNode);\n+\n+    PAssert.that(stream)\n+        .containsInAnyOrder(\n+            Row.withSchema(\n+                    Schema.builder()\n+                        .addDecimalField(\"f_numeric1\")\n+                        .addDecimalField(\"f_numeric2\")\n+                        .build())\n+                .addValues(new BigDecimal(\"12345\").setScale(9))\n+                .addValues(new BigDecimal(\"-12346\").setScale(9))\n+                .build());\n+    pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n+  }\n+\n+  @Test\n+  public void testCeilNumeric() {\n+    String sql = \"SELECT CEIL(NUMERIC '1.23456e04'), CEIL(NUMERIC '-1.23456e04')\";\n+\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    BeamRelNode beamRelNode = zetaSQLQueryPlanner.convertToBeamRel(sql);\n+    PCollection<Row> stream = BeamSqlRelUtils.toPCollection(pipeline, beamRelNode);\n+\n+    PAssert.that(stream)\n+        .containsInAnyOrder(\n+            Row.withSchema(\n+                    Schema.builder()\n+                        .addDecimalField(\"f_numeric1\")\n+                        .addDecimalField(\"f_numeric2\")\n+                        .build())\n+                .addValues(new BigDecimal(\"12346\").setScale(9))\n+                .addValues(new BigDecimal(\"-12345\").setScale(9))\n+                .build());\n+    pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n+  }\n+\n+  @Test\n+  public void testNumericColumn() {", "originalCommit": "f80e89b617b64c7a97c58df806bda6550adbbffd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA0NDYxOA==", "url": "https://github.com/apache/beam/pull/12174#discussion_r454044618", "bodyText": "Done.", "author": "ZijieSong946", "createdAt": "2020-07-14T01:32:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2MDc1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4MDM4MQ==", "url": "https://github.com/apache/beam/pull/12174#discussion_r453980381", "bodyText": "Technically speaking, it is not \"unparsed as DOUBLE\". Also, I would update the comment to be more descriptive, like:\nCannot simply call makeExactLiteral() because later it will be unparsed to the string representation of the BigDecimal itself (e.g. \"SELECT NUMERIC '0'\" will be unparsed to \"SELECT 0E-9\"), and Calcite does not allow customize unparsing of SqlNumericLiteral. So we create a wrapper function here such that we can later recognize it and customize its unparsing in BeamBigQuerySqlDialect.", "author": "robinyqiu", "createdAt": "2020-07-13T22:28:07Z", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -805,6 +807,22 @@ private RexNode convertSimpleValueToRexNode(TypeKind kind, Value value) {\n                 .makeLiteral(\n                     value.getStringValue(), typeFactory().createSqlType(SqlTypeName.VARCHAR), true);\n         break;\n+      case TYPE_NUMERIC:\n+        // As ZetaSQL NUMERIC literal would be unparsed as DOUBLE through Calcite makeExactLiteral", "originalCommit": "f80e89b617b64c7a97c58df806bda6550adbbffd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA0NTE2OA==", "url": "https://github.com/apache/beam/pull/12174#discussion_r454045168", "bodyText": "OK. That's make sense.", "author": "ZijieSong946", "createdAt": "2020-07-14T01:34:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4MDM4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4Mjk5Ng==", "url": "https://github.com/apache/beam/pull/12174#discussion_r453982996", "bodyText": "Add comment on these are the min/max values that can be represented as ZetaSQL NUMERIC?", "author": "robinyqiu", "createdAt": "2020-07-13T22:31:45Z", "path": "sdks/java/extensions/sql/zetasql/src/test/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSqlDialectSpecTest.java", "diffHunk": "@@ -2174,6 +2175,246 @@ public void testZetaSQLNestedQueryFive() {\n     pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n   }\n \n+  /////////////////////////////////////////////////////////////////////////////\n+  // NUMERIC type tests\n+  /////////////////////////////////////////////////////////////////////////////\n+\n+  @Test\n+  public void testNumericLiteral() {\n+    String sql =\n+        \"SELECT NUMERIC '0', \"\n+            + \"NUMERIC '123456', \"\n+            + \"NUMERIC '-3.14', \"\n+            + \"NUMERIC '-0.54321', \"\n+            + \"NUMERIC '1.23456e05', \"\n+            + \"NUMERIC '-9.876e-3', \"\n+            + \"NUMERIC '-99999999999999999999999999999.999999999', \"", "originalCommit": "f80e89b617b64c7a97c58df806bda6550adbbffd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA0NDk3OQ==", "url": "https://github.com/apache/beam/pull/12174#discussion_r454044979", "bodyText": "OK. Done.", "author": "ZijieSong946", "createdAt": "2020-07-14T01:34:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk4Mjk5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk5NTk5Ng==", "url": "https://github.com/apache/beam/pull/12174#discussion_r453995996", "bodyText": "Also, could you move this logic to a function unparseNumericLiteralWrapperFunction() like we do in other branches?", "author": "robinyqiu", "createdAt": "2020-07-13T23:04:06Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/bigquery/BeamBigQuerySqlDialect.java", "diffHunk": "@@ -156,7 +156,14 @@ public void unparseCall(\n         break;\n       case OTHER_FUNCTION:\n         String funName = call.getOperator().getName();\n-        if (FUNCTIONS_USING_INTERVAL.contains(funName)) {\n+        if (funName.equals(\"numeric_literal\")) {\n+          // self-designed function", "originalCommit": "f80e89b617b64c7a97c58df806bda6550adbbffd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDA1MzE3MQ==", "url": "https://github.com/apache/beam/pull/12174#discussion_r454053171", "bodyText": "Done. Thanks for your opinion.", "author": "ZijieSong946", "createdAt": "2020-07-14T02:02:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk5NTk5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUyNjcwNQ==", "url": "https://github.com/apache/beam/pull/12174#discussion_r454526705", "bodyText": "Typo here NUMERIC", "author": "robinyqiu", "createdAt": "2020-07-14T17:35:30Z", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -808,9 +808,11 @@ private RexNode convertSimpleValueToRexNode(TypeKind kind, Value value) {\n                     value.getStringValue(), typeFactory().createSqlType(SqlTypeName.VARCHAR), true);\n         break;\n       case TYPE_NUMERIC:\n-        // As ZetaSQL NUMERIC literal would be unparsed as DOUBLE through Calcite makeExactLiteral\n-        // method, we design a function call specifically associate with ZetaSQL NUMERIC literal\n-        // unparsing\n+        // Cannot simply call makeExactLiteral() for ZetaSQL NUMERICE type because later it will be", "originalCommit": "2aa74a2aa8a71eb3682392b7ed88687d8ed76bb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU1NDgwMQ==", "url": "https://github.com/apache/beam/pull/12174#discussion_r454554801", "bodyText": "Fixed. Thanks.", "author": "ZijieSong946", "createdAt": "2020-07-14T18:21:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUyNjcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUzNzg2Mg==", "url": "https://github.com/apache/beam/pull/12174#discussion_r454537862", "bodyText": "I hope the comment to include some information that people cannot get from reading the function. For example, ZetaSQL NUMERIC type definition. How about we add:\nCreate a ZetaSQL NUMERIC value represented as BigDecimal.\nZetaSQL NUMERIC type is an exact numeric value with 38 digits of precision and 9 decimal digits of scale. Precision is the number of digits that the number contains. Scale is how many of these digits appear after the decimal point.", "author": "robinyqiu", "createdAt": "2020-07-14T17:53:25Z", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSqlTypesUtils.java", "diffHunk": "@@ -0,0 +1,35 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.zetasql;\n+\n+import java.math.BigDecimal;\n+import org.apache.beam.sdk.annotations.Internal;\n+\n+/** Utils to deal with ZetaSQL type generation. */\n+@Internal\n+public class ZetaSqlTypesUtils {\n+\n+  private ZetaSqlTypesUtils() {}\n+\n+  /**\n+   * Creating a ZetaSQL NUMERIC value, which is java.math.BigDecimal with scale 9, from a string.", "originalCommit": "2aa74a2aa8a71eb3682392b7ed88687d8ed76bb2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDU1NTUxMw==", "url": "https://github.com/apache/beam/pull/12174#discussion_r454555513", "bodyText": "Make sense. Done.", "author": "ZijieSong946", "createdAt": "2020-07-14T18:22:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDUzNzg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxNTA0OA==", "url": "https://github.com/apache/beam/pull/12174#discussion_r454615048", "bodyText": "Reverse the order here (\"numeric_literal\".equals(funName)) to avoid potential issues if funName is null. Also consider making \"numeric_literal\" a constant like the others.", "author": "apilloud", "createdAt": "2020-07-14T20:10:57Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/bigquery/BeamBigQuerySqlDialect.java", "diffHunk": "@@ -156,7 +156,11 @@ public void unparseCall(\n         break;\n       case OTHER_FUNCTION:\n         String funName = call.getOperator().getName();\n-        if (FUNCTIONS_USING_INTERVAL.contains(funName)) {\n+        if (funName.equals(\"numeric_literal\")) {", "originalCommit": "e6f6aa72cb357ed863973589d194a5e9fc74aaa8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1MzY2Mw==", "url": "https://github.com/apache/beam/pull/12174#discussion_r454653663", "bodyText": "Done. Thanks.", "author": "ZijieSong946", "createdAt": "2020-07-14T21:23:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxNTA0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxODgzMA==", "url": "https://github.com/apache/beam/pull/12174#discussion_r454618830", "bodyText": "This class looks to be for tests only. Move it to '/src/test/' instead of '/src/main/'?", "author": "apilloud", "createdAt": "2020-07-14T20:18:24Z", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSqlTypesUtils.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.sql.zetasql;\n+\n+import java.math.BigDecimal;\n+import org.apache.beam.sdk.annotations.Internal;\n+\n+/** Utils to deal with ZetaSQL type generation. */\n+@Internal\n+public class ZetaSqlTypesUtils {", "originalCommit": "e6f6aa72cb357ed863973589d194a5e9fc74aaa8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY1MzU1Mg==", "url": "https://github.com/apache/beam/pull/12174#discussion_r454653552", "bodyText": "I got it. Done.", "author": "ZijieSong946", "createdAt": "2020-07-14T21:23:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxODgzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIzMTYxMA==", "url": "https://github.com/apache/beam/pull/12174#discussion_r455231610", "bodyText": "I was thinking of moving some other util functions to this file later. But for now it is only used for test, so I am fine with it in test.", "author": "robinyqiu", "createdAt": "2020-07-15T17:48:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxODgzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxOTM4Mg==", "url": "https://github.com/apache/beam/pull/12174#discussion_r454619382", "bodyText": "I've seen this constant numeric_literal before somewhere...", "author": "apilloud", "createdAt": "2020-07-14T20:19:26Z", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -805,6 +807,24 @@ private RexNode convertSimpleValueToRexNode(TypeKind kind, Value value) {\n                 .makeLiteral(\n                     value.getStringValue(), typeFactory().createSqlType(SqlTypeName.VARCHAR), true);\n         break;\n+      case TYPE_NUMERIC:\n+        // Cannot simply call makeExactLiteral() for ZetaSQL NUMERIC type because later it will be\n+        // unparsed to the string representation of the BigDecimal itself (e.g. \"SELECT NUMERIC '0'\"\n+        // will be unparsed to \"SELECT 0E-9\"), and Calcite does not allow customize unparsing of\n+        // SqlNumericLiteral. So we create a wrapper function here such that we can later recognize\n+        // it and customize its unparsing in BeamBigQuerySqlDialect.\n+        ret =\n+            rexBuilder()\n+                .makeCall(\n+                    SqlOperators.createSimpleSqlFunction(\n+                        \"numeric_literal\", ZetaSqlCalciteTranslationUtils.toCalciteTypeName(kind)),", "originalCommit": "e6f6aa72cb357ed863973589d194a5e9fc74aaa8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIzMzM5NA==", "url": "https://github.com/apache/beam/pull/12174#discussion_r455233394", "bodyText": "Zijie, here you can refer to NUMERIC_LITERAL_FUNCTION (of course you need to make it public) you defined in the other file.", "author": "robinyqiu", "createdAt": "2020-07-15T17:51:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxOTM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIzNDg2MA==", "url": "https://github.com/apache/beam/pull/12174#discussion_r455234860", "bodyText": "OK. Done.", "author": "ZijieSong946", "createdAt": "2020-07-15T17:53:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYxOTM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYyMjM5Mg==", "url": "https://github.com/apache/beam/pull/12174#discussion_r454622392", "bodyText": "This is a somewhat interesting approach. It might be worth writing up a mini design doc on why this approach was chosen and literals didn't work (but ask @robinyqiu first). I suspect this could also fix the Infinity and NaN issues I told you about (which are actually in Double, not Numeric BEAM-8057).", "author": "apilloud", "createdAt": "2020-07-14T20:24:44Z", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -805,6 +807,24 @@ private RexNode convertSimpleValueToRexNode(TypeKind kind, Value value) {\n                 .makeLiteral(\n                     value.getStringValue(), typeFactory().createSqlType(SqlTypeName.VARCHAR), true);\n         break;\n+      case TYPE_NUMERIC:\n+        // Cannot simply call makeExactLiteral() for ZetaSQL NUMERIC type because later it will be", "originalCommit": "e6f6aa72cb357ed863973589d194a5e9fc74aaa8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDY2MzY5OQ==", "url": "https://github.com/apache/beam/pull/12174#discussion_r454663699", "bodyText": "Make sense. Maybe a design doc is needed for detailed illustration. And Now I am working on this.", "author": "ZijieSong946", "createdAt": "2020-07-14T21:44:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYyMjM5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTIzNTg3NA==", "url": "https://github.com/apache/beam/pull/12174#discussion_r455235874", "bodyText": "It might be worth writing up a mini design doc...\n\nThat's a great idea!\n\nI suspect this could also fix the Infinity and NaN issues...\n\nYes, I agree. We have discussed that a bit offline and we believe this approach could fix that problem (and other similar problems, if any, due to different value representation between ZetaSQL and Calcite). I think Zijie will talk about that in more details in his design doc.", "author": "robinyqiu", "createdAt": "2020-07-15T17:55:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDYyMjM5Mg=="}], "type": "inlineReview"}, {"oid": "e28bd32cba30bb2ee7941ea63bdeb3af79ab4ab9", "url": "https://github.com/apache/beam/commit/e28bd32cba30bb2ee7941ea63bdeb3af79ab4ab9", "message": "Support ZetaSQL NUMERIC type.", "committedDate": "2020-07-15T21:44:24Z", "type": "commit"}, {"oid": "e28bd32cba30bb2ee7941ea63bdeb3af79ab4ab9", "url": "https://github.com/apache/beam/commit/e28bd32cba30bb2ee7941ea63bdeb3af79ab4ab9", "message": "Support ZetaSQL NUMERIC type.", "committedDate": "2020-07-15T21:44:24Z", "type": "forcePushed"}]}