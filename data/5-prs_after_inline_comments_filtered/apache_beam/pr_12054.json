{"pr_number": 12054, "pr_title": "[BEAM-10219] Support ZetaSQL TIME functions in BeamSQL", "pr_createdAt": "2020-06-22T21:05:30Z", "pr_url": "https://github.com/apache/beam/pull/12054", "timeline": [{"oid": "ff89cce57ddc51fc4618a75d01df0580e9e2586a", "url": "https://github.com/apache/beam/commit/ff89cce57ddc51fc4618a75d01df0580e9e2586a", "message": "[Work in progress] TIME type", "committedDate": "2020-06-22T21:03:40Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkwNDk5NA==", "url": "https://github.com/apache/beam/pull/12054#discussion_r443904994", "bodyText": "All the current failing tests are due to the code below (TIME case). Note the comment says \"convert to millis\", which indicates the values are in milliseconds. Previously it will hit this code path: Expressions.new_(Instant.class, valueDateTime);, which corresponds to calling new Instant(long), which takes milliseconds as a long as the input parameter. Now you have updated the code so it will hit calling LocalTime.ofNanoOfDay() which takes nanosecond. The fix will be adding 1 LOC: valueDateTime = Expressions.multiply(valueDateTime, Expressions.constant(1000000L)).", "author": "robinyqiu", "createdAt": "2020-06-23T01:05:35Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamCalcRel.java", "diffHunk": "@@ -315,7 +315,7 @@ private static Expression castOutput(Expression value, FieldType toType) {\n   private static Expression castOutputTime(Expression value, FieldType toType) {\n     Expression valueDateTime = value;\n \n-    // First, convert to millis (except for DATE type)\n+    // First, convert to millis (except for DATE/TIME type)", "originalCommit": "ff89cce57ddc51fc4618a75d01df0580e9e2586a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkwNjEzMQ==", "url": "https://github.com/apache/beam/pull/12054#discussion_r443906131", "bodyText": "Another problem is that LocalTime.ofNanoOfDay() takes a long instead of Long. So when the valueDateTime is of type Long the expression cannot be resolved. The fix is to add:\nif (value.getType() == Long.class) {\n  valueDateTime = Expressions.unbox(valueDateTime);\n}\n\n(The same fix should probably be added to DATE case as well. It has not failed simply because no test has hit that case.)", "author": "robinyqiu", "createdAt": "2020-06-23T01:10:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkwNDk5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDM4MjQ5MA==", "url": "https://github.com/apache/beam/pull/12054#discussion_r444382490", "bodyText": "Got it. Thanks for figuring it out.", "author": "ZijieSong946", "createdAt": "2020-06-23T17:16:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzkwNDk5NA=="}], "type": "inlineReview"}, {"oid": "e0ad9d95c2775df8ffcc6ccfff7ffb1f93506fbf", "url": "https://github.com/apache/beam/commit/e0ad9d95c2775df8ffcc6ccfff7ffb1f93506fbf", "message": "Still one test case failed. CheckStyle and SpotlessCheck done.", "committedDate": "2020-06-23T21:57:32Z", "type": "commit"}, {"oid": "0ea3e53ea452178398c5b62b497f1d73df7b4809", "url": "https://github.com/apache/beam/commit/0ea3e53ea452178398c5b62b497f1d73df7b4809", "message": "Bug related to Beam/Calcite time value translation fixed.", "committedDate": "2020-06-24T21:51:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0ODQ2MA==", "url": "https://github.com/apache/beam/pull/12054#discussion_r444548460", "bodyText": "Please add class-level javadoc for this (see DATE for example.)", "author": "robinyqiu", "createdAt": "2020-06-23T22:44:07Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/logicaltypes/Time.java", "diffHunk": "@@ -0,0 +1,56 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.schemas.logicaltypes;\n+\n+import java.time.LocalTime;\n+import org.apache.beam.sdk.schemas.Schema;\n+\n+public class Time implements Schema.LogicalType<LocalTime, Long> {", "originalCommit": "e0ad9d95c2775df8ffcc6ccfff7ffb1f93506fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY0NTg1Mw==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445645853", "bodyText": "Done.", "author": "ZijieSong946", "createdAt": "2020-06-25T15:28:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU0ODQ2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU4MTMwNw==", "url": "https://github.com/apache/beam/pull/12054#discussion_r444581307", "bodyText": "Please update ZetaSqlUtilsTest.java for the new TIME type. Also we should rename that file as well. We forgot to do that in the last PR.", "author": "robinyqiu", "createdAt": "2020-06-24T00:37:22Z", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSqlBeamTranslationUtils.java", "diffHunk": "@@ -19,18 +19,19 @@\n \n import com.google.protobuf.ByteString;\n import com.google.zetasql.ArrayType;\n+import com.google.zetasql.CivilTimeEncoder;\n import com.google.zetasql.StructType;\n import com.google.zetasql.StructType.StructField;\n import com.google.zetasql.Type;\n import com.google.zetasql.TypeFactory;\n import com.google.zetasql.Value;\n import com.google.zetasql.ZetaSQLType.TypeKind;\n import java.time.LocalDate;\n+import java.time.LocalTime;", "originalCommit": "e0ad9d95c2775df8ffcc6ccfff7ffb1f93506fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1NjY0Mg==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445656642", "bodyText": "Done.", "author": "ZijieSong946", "createdAt": "2020-06-25T15:45:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDU4MTMwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MTEyNw==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445161127", "bodyText": "Please clean up the test a bit more. Unused local variables can be removed. I would also like to add an additional field for like, dateTypeFileld + INTERVAL 1 day.", "author": "robinyqiu", "createdAt": "2020-06-24T20:45:04Z", "path": "sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamComplexTypeTest.java", "diffHunk": "@@ -375,38 +376,6 @@ public void testNullInnerRow() {\n     pipeline.run().waitUntilFinish(Duration.standardMinutes(2));\n   }\n \n-  private static class DummySqlTimeType implements Schema.LogicalType<Long, Instant> {\n-    @Override\n-    public String getIdentifier() {\n-      return \"SqlTimeType\";\n-    }\n-\n-    @Override\n-    public FieldType getArgumentType() {\n-      return FieldType.STRING;\n-    }\n-\n-    @Override\n-    public String getArgument() {\n-      return \"\";\n-    }\n-\n-    @Override\n-    public Schema.FieldType getBaseType() {\n-      return Schema.FieldType.DATETIME;\n-    }\n-\n-    @Override\n-    public Instant toBaseType(Long input) {\n-      return (input == null ? null : new Instant((long) input));\n-    }\n-\n-    @Override\n-    public Long toInputType(Instant base) {\n-      return (base == null ? null : base.getMillis());\n-    }\n-  }\n-\n   @Test\n   public void testNullDatetimeFields() {", "originalCommit": "e0ad9d95c2775df8ffcc6ccfff7ffb1f93506fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYyNzc0Mg==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445627742", "bodyText": "Done.", "author": "ZijieSong946", "createdAt": "2020-06-25T15:03:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2MTEyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2Mzk3Nw==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445163977", "bodyText": "Could you add a field for DATE as well? Thanks.", "author": "robinyqiu", "createdAt": "2020-06-24T20:50:39Z", "path": "sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/impl/schema/BeamSqlRowCoderTest.java", "diffHunk": "@@ -65,7 +66,7 @@ public void encodeAndDecode() throws Exception {\n                 1.1,\n                 BigDecimal.ZERO,\n                 \"hello\",\n-                DateTime.now().toInstant(),\n+                LocalTime.now(),", "originalCommit": "e0ad9d95c2775df8ffcc6ccfff7ffb1f93506fbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYxODYzNw==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445618637", "bodyText": "Done.", "author": "ZijieSong946", "createdAt": "2020-06-25T14:51:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE2Mzk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE4MjEzMw==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445182133", "bodyText": "For TIME it should be nullOr(value, Expressions.divide(value, 1000000L));", "author": "robinyqiu", "createdAt": "2020-06-24T21:28:40Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamCalcRel.java", "diffHunk": "@@ -431,11 +443,9 @@ private static Expression value(\n     private static Expression value(Expression value, Schema.FieldType type) {\n       if (type.getTypeName().isLogicalType()) {\n         String logicalId = type.getLogicalType().getIdentifier();\n-        if (TimeType.IDENTIFIER.equals(logicalId)) {\n-          return nullOr(\n-              value, Expressions.convert_(Expressions.call(value, \"getMillis\"), int.class));\n-        } else if (SqlTypes.DATE.getIdentifier().equals(logicalId)) {\n-          value = nullOr(value, value);\n+        if (SqlTypes.TIME.getIdentifier().equals(logicalId)\n+            || SqlTypes.DATE.getIdentifier().equals(logicalId)) {\n+          return value;", "originalCommit": "e0ad9d95c2775df8ffcc6ccfff7ffb1f93506fbf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5ODQzOQ==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445198439", "bodyText": "Seems we can combine the first and second step now (and update the comments). The code will look much simpler that way.", "author": "robinyqiu", "createdAt": "2020-06-24T22:06:18Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamCalcRel.java", "diffHunk": "@@ -315,7 +317,7 @@ private static Expression castOutput(Expression value, FieldType toType) {\n   private static Expression castOutputTime(Expression value, FieldType toType) {\n     Expression valueDateTime = value;\n \n-    // First, convert to millis (except for DATE type)\n+    // First, convert to millis (except for DATE/TIME type)", "originalCommit": "0ea3e53ea452178398c5b62b497f1d73df7b4809", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTYxNDg1Mg==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445614852", "bodyText": "Done. Thanks.", "author": "ZijieSong946", "createdAt": "2020-06-25T14:46:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE5ODQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwMTQ3Ng==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445201476", "bodyText": "Could we test extracting from a time that actually have a microsecond sub component, like '15;30:35.123456789'?", "author": "robinyqiu", "createdAt": "2020-06-24T22:14:49Z", "path": "sdks/java/extensions/sql/zetasql/src/test/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSQLDialectSpecTest.java", "diffHunk": "@@ -2457,6 +2458,256 @@ public void testDateFromUnixInt64() {\n     pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n   }\n \n+  /////////////////////////////////////////////////////////////////////////////\n+  // TIME type tests\n+  /////////////////////////////////////////////////////////////////////////////\n+\n+  @Test\n+  public void testTimeLiteral() {\n+    String sql = \"SELECT TIME '15:30:00'\";\n+\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    BeamRelNode beamRelNode = zetaSQLQueryPlanner.convertToBeamRel(sql);\n+    PCollection<Row> stream = BeamSqlRelUtils.toPCollection(pipeline, beamRelNode);\n+\n+    PAssert.that(stream)\n+        .containsInAnyOrder(\n+            Row.withSchema(Schema.builder().addLogicalTypeField(\"f_time\", SqlTypes.TIME).build())\n+                .addValues(LocalTime.of(15, 30, 0, 0))\n+                .build());\n+    pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n+  }\n+\n+  @Test\n+  public void testTimeColumn() {\n+    String sql = \"SELECT FORMAT_TIME('%T', time_field) FROM table_with_time\";\n+\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    BeamRelNode beamRelNode = zetaSQLQueryPlanner.convertToBeamRel(sql);\n+    PCollection<Row> stream = BeamSqlRelUtils.toPCollection(pipeline, beamRelNode);\n+\n+    PAssert.that(stream)\n+        .containsInAnyOrder(\n+            Row.withSchema(Schema.builder().addStringField(\"f_time_str\").build())\n+                .addValues(\"15:30:00\")\n+                .build(),\n+            Row.withSchema(Schema.builder().addStringField(\"f_time_str\").build())\n+                .addValues(\"23:35:59\")\n+                .build());\n+    pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n+  }\n+\n+  // TODO[BEAM-9166]: Add a test for CURRENT_TIME function (\"SELECT CURRENT_TIME()\")\n+\n+  @Test\n+  public void testExtractTime() {\n+    String sql =\n+        \"SELECT \"\n+            + \"EXTRACT(HOUR FROM TIME '15:30:35') as hour, \"\n+            + \"EXTRACT(MINUTE FROM TIME '15:30:35') as minute, \"\n+            + \"EXTRACT(SECOND FROM TIME '15:30:35') as second, \"\n+            + \"EXTRACT(MILLISECOND FROM TIME '15:30:35') as millisecond, \"\n+            + \"EXTRACT(MICROSECOND FROM TIME '15:30:35') as microsecond \";", "originalCommit": "0ea3e53ea452178398c5b62b497f1d73df7b4809", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwMjAzMA==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445202030", "bodyText": "Also, does EXTRACT(NANOSECOND ...) work?", "author": "robinyqiu", "createdAt": "2020-06-24T22:16:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwMTQ3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTY1ODYzOQ==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445658639", "bodyText": "Extract for millisecond precision works, but tests for microsecond and nanosecond precision not works because of TIME literal function.", "author": "ZijieSong946", "createdAt": "2020-06-25T15:47:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwMTQ3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk3MjEzNw==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445972137", "bodyText": "Extract for millisecond and microsecond precision tests added. Nanosecond precision are not supported at this point.", "author": "ZijieSong946", "createdAt": "2020-06-26T05:18:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwMTQ3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM0NjUzMA==", "url": "https://github.com/apache/beam/pull/12054#discussion_r446346530", "bodyText": "That looks good. We don't need to support nanosecond.", "author": "robinyqiu", "createdAt": "2020-06-26T18:33:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwMTQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwMjQyMw==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445202423", "bodyText": "Can we test on a time having sub-second components? I wonder if TIME literal with microsecond precision works, because it needs to go through the \"ZetaSQL -> Calcite -> Beam\" code path.", "author": "robinyqiu", "createdAt": "2020-06-24T22:17:24Z", "path": "sdks/java/extensions/sql/zetasql/src/test/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSQLDialectSpecTest.java", "diffHunk": "@@ -2457,6 +2458,256 @@ public void testDateFromUnixInt64() {\n     pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n   }\n \n+  /////////////////////////////////////////////////////////////////////////////\n+  // TIME type tests\n+  /////////////////////////////////////////////////////////////////////////////\n+\n+  @Test\n+  public void testTimeLiteral() {\n+    String sql = \"SELECT TIME '15:30:00'\";", "originalCommit": "0ea3e53ea452178398c5b62b497f1d73df7b4809", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU4ODY5MQ==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445588691", "bodyText": "It seems that TIME literal only works with millisecond precision.\n\nTIME '15:30:00.123456' will be converted to '15:30:00.123'\nTIME '15:30:00.123456789' seems invalid for TIME literal function.", "author": "ZijieSong946", "createdAt": "2020-06-25T14:11:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwMjQyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk3MTI3Mw==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445971273", "bodyText": "TIME literal for millisecond and microsecond precision tests added. Nanosecond precision are not supported at this point.", "author": "ZijieSong946", "createdAt": "2020-06-26T05:14:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwMjQyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjM0NzM4MQ==", "url": "https://github.com/apache/beam/pull/12054#discussion_r446347381", "bodyText": "Nanosecond not supported is expected. The ZetaSQL parser itself is not supporting it by default.", "author": "robinyqiu", "createdAt": "2020-06-26T18:35:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwMjQyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwMjY0NA==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445202644", "bodyText": "Nit: you can omit the last 0 parameter (same below)", "author": "robinyqiu", "createdAt": "2020-06-24T22:17:58Z", "path": "sdks/java/extensions/sql/zetasql/src/test/java/org/apache/beam/sdk/extensions/sql/zetasql/ZetaSQLDialectSpecTest.java", "diffHunk": "@@ -2457,6 +2458,256 @@ public void testDateFromUnixInt64() {\n     pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n   }\n \n+  /////////////////////////////////////////////////////////////////////////////\n+  // TIME type tests\n+  /////////////////////////////////////////////////////////////////////////////\n+\n+  @Test\n+  public void testTimeLiteral() {\n+    String sql = \"SELECT TIME '15:30:00'\";\n+\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    BeamRelNode beamRelNode = zetaSQLQueryPlanner.convertToBeamRel(sql);\n+    PCollection<Row> stream = BeamSqlRelUtils.toPCollection(pipeline, beamRelNode);\n+\n+    PAssert.that(stream)\n+        .containsInAnyOrder(\n+            Row.withSchema(Schema.builder().addLogicalTypeField(\"f_time\", SqlTypes.TIME).build())\n+                .addValues(LocalTime.of(15, 30, 0, 0))\n+                .build());\n+    pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n+  }\n+\n+  @Test\n+  public void testTimeColumn() {\n+    String sql = \"SELECT FORMAT_TIME('%T', time_field) FROM table_with_time\";\n+\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    BeamRelNode beamRelNode = zetaSQLQueryPlanner.convertToBeamRel(sql);\n+    PCollection<Row> stream = BeamSqlRelUtils.toPCollection(pipeline, beamRelNode);\n+\n+    PAssert.that(stream)\n+        .containsInAnyOrder(\n+            Row.withSchema(Schema.builder().addStringField(\"f_time_str\").build())\n+                .addValues(\"15:30:00\")\n+                .build(),\n+            Row.withSchema(Schema.builder().addStringField(\"f_time_str\").build())\n+                .addValues(\"23:35:59\")\n+                .build());\n+    pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n+  }\n+\n+  // TODO[BEAM-9166]: Add a test for CURRENT_TIME function (\"SELECT CURRENT_TIME()\")\n+\n+  @Test\n+  public void testExtractTime() {\n+    String sql =\n+        \"SELECT \"\n+            + \"EXTRACT(HOUR FROM TIME '15:30:35') as hour, \"\n+            + \"EXTRACT(MINUTE FROM TIME '15:30:35') as minute, \"\n+            + \"EXTRACT(SECOND FROM TIME '15:30:35') as second, \"\n+            + \"EXTRACT(MILLISECOND FROM TIME '15:30:35') as millisecond, \"\n+            + \"EXTRACT(MICROSECOND FROM TIME '15:30:35') as microsecond \";\n+\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    BeamRelNode beamRelNode = zetaSQLQueryPlanner.convertToBeamRel(sql);\n+    PCollection<Row> stream = BeamSqlRelUtils.toPCollection(pipeline, beamRelNode);\n+\n+    final Schema schema =\n+        Schema.builder()\n+            .addField(\"hour\", FieldType.INT64)\n+            .addField(\"minute\", FieldType.INT64)\n+            .addField(\"second\", FieldType.INT64)\n+            .addField(\"millisecond\", FieldType.INT64)\n+            .addField(\"microsecond\", FieldType.INT64)\n+            .build();\n+    PAssert.that(stream)\n+        .containsInAnyOrder(Row.withSchema(schema).addValues(15L, 30L, 35L, 0L, 0L).build());\n+\n+    pipeline.run().waitUntilFinish(Duration.standardMinutes(PIPELINE_EXECUTION_WAITTIME_MINUTES));\n+  }\n+\n+  @Test\n+  public void testTimeFromHourMinuteSecond() {\n+    String sql = \"SELECT TIME(15, 30, 0)\";\n+\n+    ZetaSQLQueryPlanner zetaSQLQueryPlanner = new ZetaSQLQueryPlanner(config);\n+    BeamRelNode beamRelNode = zetaSQLQueryPlanner.convertToBeamRel(sql);\n+    PCollection<Row> stream = BeamSqlRelUtils.toPCollection(pipeline, beamRelNode);\n+\n+    PAssert.that(stream)\n+        .containsInAnyOrder(\n+            Row.withSchema(Schema.builder().addLogicalTypeField(\"f_time\", SqlTypes.TIME).build())\n+                .addValues(LocalTime.of(15, 30, 0, 0))", "originalCommit": "0ea3e53ea452178398c5b62b497f1d73df7b4809", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTU4MDcyOQ==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445580729", "bodyText": "Done.", "author": "ZijieSong946", "createdAt": "2020-06-25T14:00:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTIwMjY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI0NDYwMg==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445244602", "bodyText": "This is the most important line of this CL for correctness, wanted to get attention on it early.\nZetaSQL uses a very specific format for this, which roughly matches the struct in LocalTime: https://github.com/google/zetasql/blob/79adcd0fe227173e68ed7aa88f580a691ebe82c2/zetasql/public/civil_time.h#L85\nIt appears the Long base type is an offset in Nanoseconds. Is that conversion lossless? Is it expensive?", "author": "apilloud", "createdAt": "2020-06-25T00:34:01Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/logicaltypes/SqlTypes.java", "diffHunk": "@@ -27,4 +28,7 @@ private SqlTypes() {}\n \n   /** Beam LogicalType corresponding to ZetaSQL/CalciteSQL DATE type. */\n   public static final LogicalType<LocalDate, Long> DATE = new Date();\n+\n+  /** Beam LogicalType corresponding to ZetaSQL/CalciteSQL TIME type. */\n+  public static final LogicalType<LocalTime, Long> TIME = new Time();", "originalCommit": "0ea3e53ea452178398c5b62b497f1d73df7b4809", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI3OTEwMw==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445279103", "bodyText": "Now the internal build passes.\nThanks for the question. Conversion is lossless. Actually it is done by calling ZetaSQL code: CivilTimeEncoder.decodePacked64TimeNanosAsJavaTime() and encodePacked64TimeNanos(). See conversion code in ZetaSqlBeamTranslationUtils.java. I looked at the code and it seems to be purely bit manipulation, so I guess it's not very expensive.", "author": "robinyqiu", "createdAt": "2020-06-25T02:53:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI0NDYwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTcyNzAxOA==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445727018", "bodyText": "Great! Bitshifting for java.time.LocalTime is lossless and fast. Looks like the conversion to/from Long is done by LocalTime.ofNanoOfDay and LocalTime.toNanoOfDay and those do math with a few constants that is also lossless and fast.", "author": "apilloud", "createdAt": "2020-06-25T17:38:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI0NDYwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc2OTE1OQ==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445769159", "bodyText": "It looks like one or more of the conversions (at very least LocalTime to Long) is not lossless, it corrupts leap seconds. Here is a set of trivial identity test cases that needs to pass any type conversion:\nSELECT\n    CAST(CAST(TIME \"00:00:00\" as STRING) as TIME),\n    CAST(CAST(TIME \"23:59:59.999999\" as STRING) as TIME),\n    CAST(CAST(TIME \"01:02:03.123456\" as STRING) as TIME),\n    CAST(CAST(TIME \"01:02:03.12345\" as STRING) as TIME),\n    CAST(CAST(TIME \"01:02:03.120000\" as STRING) as TIME),\n    CAST(CAST(TIME \"01:02:3\" as STRING) as TIME),\n    CAST(CAST(TIME \"01:2:03\" as STRING) as TIME),\n    CAST(CAST(TIME \"1:02:03\" as STRING) as TIME),\n    #Leap second cases\n    CAST(CAST(TIME \"23:59:60\" as STRING) as TIME),\n    CAST(CAST(TIME \"12:59:60\" as STRING) as TIME),\n    CAST(CAST(TIME \"12:59:60.123456\" as STRING) as TIME),\n\n    CAST(CAST(\"00:00:00\" as TIME) as STRING),\n    CAST(CAST(\"23:59:59.999999\" as TIME) as STRING),\n    CAST(CAST(\"01:02:03.123456\" as TIME) as STRING),\n    CAST(CAST(\"01:02:03.12345\" as TIME) as STRING),\n    CAST(CAST(\"01:02:03.120000\" as TIME) as STRING),\n    CAST(CAST(\"01:02:3\" as TIME) as STRING),\n    CAST(CAST(\"01:2:03\" as TIME) as STRING),\n    CAST(CAST(\"1:02:03\" as TIME) as STRING),\n    #Leap second cases\n    CAST(CAST(\"23:59:60\" as TIME) as STRING),\n    CAST(CAST(\"12:59:60\" as TIME) as STRING),\n    CAST(CAST(\"12:59:60.123456\" as TIME) as STRING)", "author": "apilloud", "createdAt": "2020-06-25T18:49:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI0NDYwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc3NDc3Nw==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445774777", "bodyText": "Actually, the ZetaSQL standard calls for those lossy conversions. The test is failing due to truncation of precision to millisecond. Expected right answers for this test case:\n  {\n    \"f0_\": \"00:00:00\",\n    \"f1_\": \"23:59:59.999999\",\n    \"f2_\": \"01:02:03.123456\",\n    \"f3_\": \"01:02:03.123450\",\n    \"f4_\": \"01:02:03.120000\",\n    \"f5_\": \"01:02:03\",\n    \"f6_\": \"01:02:03\",\n    \"f7_\": \"01:02:03\",\n    \"f8_\": \"00:00:00\",\n    \"f9_\": \"13:00:00\",\n    \"f10_\": \"13:00:00\",\n    \"f11_\": \"00:00:00\",\n    \"f12_\": \"23:59:59.999999\",\n    \"f13_\": \"01:02:03.123456\",\n    \"f14_\": \"01:02:03.123450\",\n    \"f15_\": \"01:02:03.120\",\n    \"f16_\": \"01:02:03\",\n    \"f17_\": \"01:02:03\",\n    \"f18_\": \"01:02:03\",\n    \"f19_\": \"00:00:00\",\n    \"f20_\": \"13:00:00\",\n    \"f21_\": \"13:00:00\"\n  }", "author": "apilloud", "createdAt": "2020-06-25T18:59:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI0NDYwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQyOTY3OA==", "url": "https://github.com/apache/beam/pull/12054#discussion_r446429678", "bodyText": "Thanks for the pointer. This test is passing now!", "author": "robinyqiu", "createdAt": "2020-06-26T22:01:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTI0NDYwMg=="}], "type": "inlineReview"}, {"oid": "47caac91fd2e1041815487e5c5d40f503260188a", "url": "https://github.com/apache/beam/commit/47caac91fd2e1041815487e5c5d40f503260188a", "message": "All improvements done. Two testcases fail because of TIME literal precision.", "committedDate": "2020-06-25T15:56:52Z", "type": "commit"}, {"oid": "1b53eaa3d359ebb59a2a775008e0d7db13a6a036", "url": "https://github.com/apache/beam/commit/1b53eaa3d359ebb59a2a775008e0d7db13a6a036", "message": "checkstyle fixed.", "committedDate": "2020-06-25T16:02:28Z", "type": "commit"}, {"oid": "c998549fe901ce40e55059df519a4160198680ed", "url": "https://github.com/apache/beam/commit/c998549fe901ce40e55059df519a4160198680ed", "message": "spotlessCheck fixed.", "committedDate": "2020-06-25T16:06:13Z", "type": "commit"}, {"oid": "e8f4a2565e5c9fb7443376bd710cea5b949c5592", "url": "https://github.com/apache/beam/commit/e8f4a2565e5c9fb7443376bd710cea5b949c5592", "message": "checkstyle fixed.", "committedDate": "2020-06-25T16:26:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc4Mjg4Mg==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445782882", "bodyText": "nit: Can you move each of these comments into the appropriate if block?", "author": "apilloud", "createdAt": "2020-06-25T19:15:30Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamCalcRel.java", "diffHunk": "@@ -315,34 +317,38 @@ private static Expression castOutput(Expression value, FieldType toType) {\n   private static Expression castOutputTime(Expression value, FieldType toType) {\n     Expression valueDateTime = value;\n \n-    // First, convert to millis (except for DATE type)\n+    // Convert TIMESTAMP to joda Instant", "originalCommit": "e8f4a2565e5c9fb7443376bd710cea5b949c5592", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk2NTgyOA==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445965828", "bodyText": "Done. Thanks.", "author": "ZijieSong946", "createdAt": "2020-06-26T04:50:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTc4Mjg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgzMjg1Ng==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445832856", "bodyText": "If I remember right, FieldType.DATETIME is the SQL type of TIMESTAMP. Looks like all the test cases for TIMESTAMP have been dropped?", "author": "apilloud", "createdAt": "2020-06-25T20:55:27Z", "path": "sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/extensions/sql/BeamComplexTypeTest.java", "diffHunk": "@@ -452,21 +412,32 @@ public void testNullDatetimeFields() {\n             .addNullableField(\"year_with_null\", FieldType.INT64)\n             .addField(\"mm\", FieldType.INT64)\n             .addNullableField(\"month_with_null\", FieldType.INT64)\n-            .addField(\"time_with_hour_added\", FieldType.DATETIME)", "originalCommit": "e8f4a2565e5c9fb7443376bd710cea5b949c5592", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk3NDU5Mw==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445974593", "bodyText": "Yeah. But it seems nothing wrong with these test cases. I think we could just leave it here right now and update them when we implementing TIMESTAMP type translation.", "author": "ZijieSong946", "createdAt": "2020-06-26T05:28:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgzMjg1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI2NDI1NA==", "url": "https://github.com/apache/beam/pull/12054#discussion_r446264254", "bodyText": "TIMESTAMP is already supported. Please leave the existing test cases, but feel free to add new ones.", "author": "apilloud", "createdAt": "2020-06-26T15:47:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgzMjg1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgzNTY3Mg==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445835672", "bodyText": "nit: There is no test case for this.", "author": "apilloud", "createdAt": "2020-06-25T21:01:09Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamCalcRel.java", "diffHunk": "@@ -315,34 +317,38 @@ private static Expression castOutput(Expression value, FieldType toType) {\n   private static Expression castOutputTime(Expression value, FieldType toType) {\n     Expression valueDateTime = value;\n \n-    // First, convert to millis (except for DATE type)\n+    // Convert TIMESTAMP to joda Instant\n+    // Convert DATE to LocalDate\n+    // Convert TIME to LocalTime\n     if (CalciteUtils.TIMESTAMP.typesEqual(toType)\n         || CalciteUtils.NULLABLE_TIMESTAMP.typesEqual(toType)) {\n       if (value.getType() == java.sql.Timestamp.class) {\n         valueDateTime = Expressions.call(BuiltInMethod.TIMESTAMP_TO_LONG.method, valueDateTime);\n       }\n+      valueDateTime = Expressions.new_(Instant.class, valueDateTime);\n     } else if (CalciteUtils.TIME.typesEqual(toType)\n         || CalciteUtils.NULLABLE_TIME.typesEqual(toType)) {\n       if (value.getType() == java.sql.Time.class) {\n         valueDateTime = Expressions.call(BuiltInMethod.TIME_TO_INT.method, valueDateTime);\n+      } else if (value.getType() == Long.class) {", "originalCommit": "e8f4a2565e5c9fb7443376bd710cea5b949c5592", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgzOTI1Ng==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445839256", "bodyText": "This is going to generate the code value == null ? null : value, which does nothing. drop it all together?", "author": "apilloud", "createdAt": "2020-06-25T21:08:38Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/impl/rel/BeamCalcRel.java", "diffHunk": "@@ -431,11 +437,11 @@ private static Expression value(\n     private static Expression value(Expression value, Schema.FieldType type) {\n       if (type.getTypeName().isLogicalType()) {\n         String logicalId = type.getLogicalType().getIdentifier();\n-        if (TimeType.IDENTIFIER.equals(logicalId)) {\n+        if (SqlTypes.TIME.getIdentifier().equals(logicalId)) {\n           return nullOr(\n-              value, Expressions.convert_(Expressions.call(value, \"getMillis\"), int.class));\n+              value, Expressions.divide(value, Expressions.constant(NANOS_PER_MILLISECOND)));\n         } else if (SqlTypes.DATE.getIdentifier().equals(logicalId)) {\n-          value = nullOr(value, value);\n+          return nullOr(value, value);", "originalCommit": "e8f4a2565e5c9fb7443376bd710cea5b949c5592", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTg5Nzg0OQ==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445897849", "bodyText": "nullOr() also does boxing for value if it is not null. Is it necessary in this case? I tried to remove the call to nullOr() and it works fine as well.", "author": "robinyqiu", "createdAt": "2020-06-25T23:49:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgzOTI1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk2NTEwOQ==", "url": "https://github.com/apache/beam/pull/12054#discussion_r445965109", "bodyText": "Yeah. It works if we just return value here. So I have changed it to make it simpler.", "author": "ZijieSong946", "createdAt": "2020-06-26T04:46:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTgzOTI1Ng=="}], "type": "inlineReview"}, {"oid": "c6c7a304538e545606c67eec8a8f230f09c603a4", "url": "https://github.com/apache/beam/commit/c6c7a304538e545606c67eec8a8f230f09c603a4", "message": "Failed test cases fixed.", "committedDate": "2020-06-26T06:12:45Z", "type": "commit"}, {"oid": "e182e7c6ba5c13f2279ea8ee377899fb21fd1813", "url": "https://github.com/apache/beam/commit/e182e7c6ba5c13f2279ea8ee377899fb21fd1813", "message": "new test added for time casting", "committedDate": "2020-06-26T21:50:15Z", "type": "commit"}]}