{"pr_number": 10502, "pr_title": "[BEAM-7274] Add DynamicMessage Schema support", "pr_createdAt": "2020-01-04T09:00:16Z", "pr_url": "https://github.com/apache/beam/pull/10502", "timeline": [{"oid": "3a6ca71ca00b3545712a2b6f8d38a0f90bc373a5", "url": "https://github.com/apache/beam/commit/3a6ca71ca00b3545712a2b6f8d38a0f90bc373a5", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages.", "committedDate": "2020-01-04T18:39:08Z", "type": "forcePushed"}, {"oid": "04a8580fb7d9e2874f96e22360072ec46873712a", "url": "https://github.com/apache/beam/commit/04a8580fb7d9e2874f96e22360072ec46873712a", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages.", "committedDate": "2020-01-07T20:57:33Z", "type": "forcePushed"}, {"oid": "058a636713473cc67b2440377fcba8e10c4f37e2", "url": "https://github.com/apache/beam/commit/058a636713473cc67b2440377fcba8e10c4f37e2", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages.", "committedDate": "2020-01-08T07:57:48Z", "type": "forcePushed"}, {"oid": "97414c64dd4dc617c67c4593ee5d18f058c374d7", "url": "https://github.com/apache/beam/commit/97414c64dd4dc617c67c4593ee5d18f058c374d7", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages.", "committedDate": "2020-01-08T09:32:46Z", "type": "forcePushed"}, {"oid": "e352ff4d0f1914a8da75e641c585e4c84322df7c", "url": "https://github.com/apache/beam/commit/e352ff4d0f1914a8da75e641c585e4c84322df7c", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages.", "committedDate": "2020-01-10T16:06:00Z", "type": "forcePushed"}, {"oid": "9145d754ac9f6765343c3f98276701dfc8dbfcc7", "url": "https://github.com/apache/beam/commit/9145d754ac9f6765343c3f98276701dfc8dbfcc7", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages.", "committedDate": "2020-02-06T07:00:48Z", "type": "forcePushed"}, {"oid": "51f9c9df56fb7f3ffe8960c2ee07a8153926c0fc", "url": "https://github.com/apache/beam/commit/51f9c9df56fb7f3ffe8960c2ee07a8153926c0fc", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages.", "committedDate": "2020-02-08T15:32:08Z", "type": "forcePushed"}, {"oid": "a83d80349d9eeda6cd7f58386c5ab4308803a3a5", "url": "https://github.com/apache/beam/commit/a83d80349d9eeda6cd7f58386c5ab4308803a3a5", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages.", "committedDate": "2020-02-08T21:40:26Z", "type": "forcePushed"}, {"oid": "602869aeaf884b2ef34835db82f3b5066c75b284", "url": "https://github.com/apache/beam/commit/602869aeaf884b2ef34835db82f3b5066c75b284", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages.", "committedDate": "2020-02-10T19:36:11Z", "type": "forcePushed"}, {"oid": "7e57a3995947127ffaaf9fa623c94f453702f864", "url": "https://github.com/apache/beam/commit/7e57a3995947127ffaaf9fa623c94f453702f864", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages.", "committedDate": "2020-02-12T16:36:20Z", "type": "forcePushed"}, {"oid": "9a13256b40799af257a826ba2a06bed5bd0c7c48", "url": "https://github.com/apache/beam/commit/9a13256b40799af257a826ba2a06bed5bd0c7c48", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages.", "committedDate": "2020-02-18T13:49:27Z", "type": "forcePushed"}, {"oid": "0edacbb42c74a4cebaa1b454a6897afc3684c0e7", "url": "https://github.com/apache/beam/commit/0edacbb42c74a4cebaa1b454a6897afc3684c0e7", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages.", "committedDate": "2020-02-18T23:47:53Z", "type": "forcePushed"}, {"oid": "012c45a8174f61d47ba31b2d47f03deb86c77fa5", "url": "https://github.com/apache/beam/commit/012c45a8174f61d47ba31b2d47f03deb86c77fa5", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages.", "committedDate": "2020-02-20T12:28:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3MDA1MA==", "url": "https://github.com/apache/beam/pull/10502#discussion_r383070050", "bodyText": "I think you can replace the lambda with this::indexDescriptor", "author": "reuvenlax", "createdAt": "2020-02-24T02:52:10Z", "path": "sdks/java/extensions/protobuf/src/main/java/org/apache/beam/sdk/extensions/protobuf/ProtoDomain.java", "diffHunk": "@@ -163,15 +163,15 @@ private void indexDescriptorByName() {\n         .values()\n         .forEach(\n             fileDescriptor -> {\n-              fileDescriptor\n-                  .getMessageTypes()\n-                  .forEach(\n-                      descriptor -> {\n-                        descriptorMap.put(descriptor.getFullName(), descriptor);\n-                      });\n+              fileDescriptor.getMessageTypes().forEach(descriptor -> indexDescriptor(descriptor));", "originalCommit": "012c45a8174f61d47ba31b2d47f03deb86c77fa5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ5NjE5Mg==", "url": "https://github.com/apache/beam/pull/10502#discussion_r383496192", "bodyText": "fixed", "author": "alexvanboxel", "createdAt": "2020-02-24T20:27:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3MDA1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3MDEyNA==", "url": "https://github.com/apache/beam/pull/10502#discussion_r383070124", "bodyText": "you can do the same here - forEach(this::indexDescriptor)", "author": "reuvenlax", "createdAt": "2020-02-24T02:52:56Z", "path": "sdks/java/extensions/protobuf/src/main/java/org/apache/beam/sdk/extensions/protobuf/ProtoDomain.java", "diffHunk": "@@ -163,15 +163,15 @@ private void indexDescriptorByName() {\n         .values()\n         .forEach(\n             fileDescriptor -> {\n-              fileDescriptor\n-                  .getMessageTypes()\n-                  .forEach(\n-                      descriptor -> {\n-                        descriptorMap.put(descriptor.getFullName(), descriptor);\n-                      });\n+              fileDescriptor.getMessageTypes().forEach(descriptor -> indexDescriptor(descriptor));\n             });\n   }\n \n+  private void indexDescriptor(Descriptors.Descriptor descriptor) {\n+    descriptorMap.put(descriptor.getFullName(), descriptor);\n+    descriptor.getNestedTypes().forEach(nested -> indexDescriptor(nested));", "originalCommit": "012c45a8174f61d47ba31b2d47f03deb86c77fa5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzQ5NjI2MA==", "url": "https://github.com/apache/beam/pull/10502#discussion_r383496260", "bodyText": "fixed", "author": "alexvanboxel", "createdAt": "2020-02-24T20:28:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3MDEyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3MTE1Mg==", "url": "https://github.com/apache/beam/pull/10502#discussion_r383071152", "bodyText": "I don't think we should be storing SchemaCoder objects around here. I think preferable to store schema and to/from row functions separately.", "author": "reuvenlax", "createdAt": "2020-02-24T03:01:16Z", "path": "sdks/java/extensions/protobuf/src/main/java/org/apache/beam/sdk/extensions/protobuf/ProtoDynamicMessageSchema.java", "diffHunk": "@@ -0,0 +1,852 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.protobuf;\n+\n+import static org.apache.beam.sdk.extensions.protobuf.ProtoSchemaTranslator.getFieldNumber;\n+import static org.apache.beam.sdk.extensions.protobuf.ProtoSchemaTranslator.getMapKeyMessageName;\n+import static org.apache.beam.sdk.extensions.protobuf.ProtoSchemaTranslator.getMapValueMessageName;\n+import static org.apache.beam.sdk.extensions.protobuf.ProtoSchemaTranslator.getMessageName;\n+import static org.apache.beam.sdk.extensions.protobuf.ProtoSchemaTranslator.withFieldNumber;\n+import static org.apache.beam.sdk.extensions.protobuf.ProtoSchemaTranslator.withMessageName;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.Descriptors;\n+import com.google.protobuf.Descriptors.FieldDescriptor;\n+import com.google.protobuf.DynamicMessage;\n+import com.google.protobuf.Message;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.schemas.SchemaCoder;\n+import org.apache.beam.sdk.schemas.logicaltypes.EnumerationType;\n+import org.apache.beam.sdk.schemas.logicaltypes.NanosDuration;\n+import org.apache.beam.sdk.schemas.logicaltypes.NanosInstant;\n+import org.apache.beam.sdk.schemas.logicaltypes.OneOfType;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.sdk.values.TypeDescriptor;\n+\n+@Experimental(Experimental.Kind.SCHEMAS)\n+public class ProtoDynamicMessageSchema<T> implements Serializable {\n+  public static final long serialVersionUID = 1L;\n+\n+  /**\n+   * Context of the schema, the context can be generated from a source schema or descriptors. The\n+   * ability of converting back from Row to proto depends on the type of context.\n+   */\n+  private final Context context;\n+\n+  /** THe SchemaCoder holds the resolved schema and to/fromRow functions. */\n+  private transient SchemaCoder schemaCoder;\n+\n+  /** List of field converters for each field in the row. */\n+  private transient List<Convert> converters;\n+\n+  private ProtoDynamicMessageSchema(String messageName, ProtoDomain domain) {\n+    this.context = new DescriptorContext(messageName, domain);\n+    readResolve();\n+  }\n+\n+  private ProtoDynamicMessageSchema(Context context) {\n+    this.context = context;\n+    readResolve();\n+  }\n+\n+  /**\n+   * Create a new ProtoDynamicMessageSchema from a {@link ProtoDomain} and for a message. The\n+   * message need to be in the domain and needs to be the fully qualified name.\n+   */\n+  public static ProtoDynamicMessageSchema forDescriptor(ProtoDomain domain, String messageName) {\n+    return new ProtoDynamicMessageSchema(messageName, domain);\n+  }\n+\n+  /**\n+   * Create a new ProtoDynamicMessageSchema from a {@link ProtoDomain} and for a descriptor. The\n+   * descriptor is only used for it's name, that name will be used for a search in the domain.\n+   */\n+  public static ProtoDynamicMessageSchema<DynamicMessage> forDescriptor(\n+      ProtoDomain domain, Descriptors.Descriptor descriptor) {\n+    return new ProtoDynamicMessageSchema<>(descriptor.getFullName(), domain);\n+  }\n+\n+  static ProtoDynamicMessageSchema<?> forContext(Context context, Schema.Field field) {\n+    return new ProtoDynamicMessageSchema<>(context.getSubContext(field));\n+  }\n+\n+  static ProtoDynamicMessageSchema<Message> forSchema(Schema schema) {\n+    return new ProtoDynamicMessageSchema<>(new Context(schema, Message.class));\n+  }\n+\n+  /** Initialize the transient fields after deserialization or construction. */\n+  private Object readResolve() {\n+    converters = createConverters(context.getSchema());\n+    schemaCoder =\n+        SchemaCoder.of(\n+            context.getSchema(),\n+            TypeDescriptor.of(context.getBaseClass()),\n+            new MessageToRowFunction(),\n+            new RowToMessageFunction());\n+    return this;\n+  }\n+\n+  Convert createConverter(Schema.Field field) {\n+    Schema.FieldType fieldType = field.getType();\n+    String messageName = getMessageName(fieldType);\n+    if (messageName != null && messageName.length() > 0) {\n+      Schema.Field valueField =\n+          Schema.Field.of(\"value\", withFieldNumber(Schema.FieldType.BOOLEAN, 1));\n+      switch (messageName) {\n+        case \"google.protobuf.StringValue\":\n+        case \"google.protobuf.DoubleValue\":\n+        case \"google.protobuf.FloatValue\":\n+        case \"google.protobuf.BoolValue\":\n+        case \"google.protobuf.Int64Value\":\n+        case \"google.protobuf.Int32Value\":\n+        case \"google.protobuf.UInt64Value\":\n+        case \"google.protobuf.UInt32Value\":\n+          return new WrapperConvert(field, new PrimitiveConvert(valueField));\n+        case \"google.protobuf.BytesValue\":\n+          return new WrapperConvert(field, new BytesConvert(valueField));\n+        case \"google.protobuf.Timestamp\":\n+        case \"google.protobuf.Duration\":\n+          // handled by logical type case\n+          break;\n+      }\n+    }\n+    switch (fieldType.getTypeName()) {\n+      case BYTE:\n+      case INT16:\n+      case INT32:\n+      case INT64:\n+      case FLOAT:\n+      case DOUBLE:\n+      case STRING:\n+      case BOOLEAN:\n+        return new PrimitiveConvert(field);\n+      case BYTES:\n+        return new BytesConvert(field);\n+      case ARRAY:\n+      case ITERABLE:\n+        return new ArrayConvert(this, field);\n+      case MAP:\n+        return new MapConvert(this, field);\n+      case LOGICAL_TYPE:\n+        String identifier = field.getType().getLogicalType().getIdentifier();\n+        switch (identifier) {\n+          case ProtoSchemaLogicalTypes.Fixed32.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.Fixed64.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.SFixed32.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.SFixed64.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.SInt32.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.SInt64.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.UInt32.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.UInt64.IDENTIFIER:\n+            return new LogicalTypeConvert(field, fieldType.getLogicalType());\n+          case NanosInstant.IDENTIFIER:\n+            return new TimestampConvert(field);\n+          case NanosDuration.IDENTIFIER:\n+            return new DurationConvert(field);\n+          case EnumerationType.IDENTIFIER:\n+            return new EnumConvert(field, fieldType.getLogicalType());\n+          case OneOfType.IDENTIFIER:\n+            return new OneOfConvert(this, field, fieldType.getLogicalType());\n+          default:\n+            throw new IllegalStateException(\"Unexpected logical type : \" + identifier);\n+        }\n+      case ROW:\n+        return new MessageConvert(this, field);\n+      default:\n+        throw new IllegalStateException(\"Unexpected value: \" + fieldType);\n+    }\n+  }\n+\n+  private List<Convert> createConverters(Schema schema) {\n+    List<Convert> fieldOverlays = new ArrayList<>();\n+    for (Schema.Field field : schema.getFields()) {\n+      fieldOverlays.add(createConverter(field));\n+    }\n+    return fieldOverlays;\n+  }\n+\n+  public Schema getSchema() {\n+    return this.schemaCoder.getSchema();\n+  }\n+\n+  public SchemaCoder<T> getSchemaCoder() {\n+    return schemaCoder;\n+  }\n+\n+  public SerializableFunction<T, Row> getToRowFunction() {\n+    return schemaCoder.getToRowFunction();\n+  }\n+\n+  public SerializableFunction<Row, T> getFromRowFunction() {\n+    return schemaCoder.getFromRowFunction();\n+  }\n+\n+  /**\n+   * Context that only has enough information to convert a proto message to a Row. This can be used\n+   * for arbitrary conventions, like decoding messages in proto options.\n+   */\n+  static class Context<T> implements Serializable {\n+    private final Schema schema;\n+\n+    /**\n+     * Base class for the protobuf message. Normally this is DynamicMessage, but as this schema\n+     * class is also used to decode protobuf options this can be normal Message instances.\n+     */\n+    private Class<T> baseClass;\n+\n+    Context(Schema schema, Class<T> baseClass) {\n+      this.schema = schema;\n+      this.baseClass = baseClass;\n+    }\n+\n+    public Schema getSchema() {\n+      return schema;\n+    }\n+\n+    public Class<T> getBaseClass() {\n+      return baseClass;\n+    }\n+\n+    public DynamicMessage.Builder invokeNewBuilder() {\n+      throw new IllegalStateException(\"Should not be calling invokeNewBuilder\");\n+    }\n+\n+    public Context getSubContext(Schema.Field field) {\n+      return new Context(field.getType().getRowSchema(), Message.class);\n+    }\n+  }\n+\n+  /**\n+   * Context the contains the full {@link ProtoDomain} and a reference to the message name. The full\n+   * domain is needed for creating Rows back to the original proto messages.\n+   */\n+  static class DescriptorContext extends Context<DynamicMessage> {\n+    private final String messageName;\n+    private final ProtoDomain domain;\n+    private transient Descriptors.Descriptor descriptor;\n+\n+    DescriptorContext(String messageName, ProtoDomain domain) {\n+      super(\n+          ProtoSchemaTranslator.getSchema(domain.getDescriptor(messageName)), DynamicMessage.class);\n+      this.messageName = messageName;\n+      this.domain = domain;\n+    }\n+\n+    @Override\n+    public DynamicMessage.Builder invokeNewBuilder() {\n+      if (descriptor == null) {\n+        descriptor = domain.getDescriptor(messageName);\n+      }\n+      return DynamicMessage.newBuilder(descriptor);\n+    }\n+\n+    @Override\n+    public Context getSubContext(Schema.Field field) {\n+      String messageName = getMessageName(field.getType());\n+      return new DescriptorContext(messageName, domain);\n+    }\n+  }\n+\n+  /**\n+   * Base converter class for converting from proto values to row values. The converter mainly works\n+   * on fields in proto messages but also has methods to convert individual elements (example, for\n+   * elements in Lists or Maps).\n+   */\n+  abstract static class Convert<ValueT, InT> {\n+    private int number;\n+\n+    Convert(Schema.Field field) {\n+      try {\n+        this.number = getFieldNumber(field.getType());\n+      } catch (NumberFormatException e) {\n+        this.number = -1;\n+      }\n+    }\n+\n+    FieldDescriptor getFieldDescriptor(Message message) {\n+      return message.getDescriptorForType().findFieldByNumber(number);\n+    }\n+\n+    FieldDescriptor getFieldDescriptor(Message.Builder message) {\n+      return message.getDescriptorForType().findFieldByNumber(number);\n+    }\n+\n+    /** Get a proto field and convert it into a row value. */\n+    abstract Object getFromProtoMessage(Message message);\n+\n+    /** Convert a proto value into a row value. */\n+    abstract ValueT convertFromProtoValue(Object object);\n+\n+    /** Convert a row value and set it on a proto message. */\n+    abstract void setOnProtoMessage(Message.Builder object, InT value);\n+\n+    /** Convert a row value into a proto value. */\n+    abstract Object convertToProtoValue(FieldDescriptor fieldDescriptor, Object value);\n+  }\n+\n+  /** Converter for primitive proto values. */\n+  static class PrimitiveConvert extends Convert<Object, Object> {\n+    PrimitiveConvert(Schema.Field field) {\n+      super(field);\n+    }\n+\n+    @Override\n+    Object getFromProtoMessage(Message message) {\n+      FieldDescriptor fieldDescriptor = getFieldDescriptor(message);\n+      return convertFromProtoValue(message.getField(fieldDescriptor));\n+    }\n+\n+    @Override\n+    Object convertFromProtoValue(Object object) {\n+      return object;\n+    }\n+\n+    @Override\n+    void setOnProtoMessage(Message.Builder message, Object value) {\n+      message.setField(getFieldDescriptor(message), value);\n+    }\n+\n+    @Override\n+    Object convertToProtoValue(FieldDescriptor fieldDescriptor, Object value) {\n+      return value;\n+    }\n+  }\n+\n+  /**\n+   * Converter for Bytes. Protobuf Bytes are natively represented as ByteStrings that requires\n+   * special handling for byte[] of size 0.\n+   */\n+  static class BytesConvert extends PrimitiveConvert {\n+    BytesConvert(Schema.Field field) {\n+      super(field);\n+    }\n+\n+    @Override\n+    Object convertFromProtoValue(Object object) {\n+      // return object;\n+      return ((ByteString) object).toByteArray();\n+    }\n+\n+    @Override\n+    void setOnProtoMessage(Message.Builder message, Object value) {\n+      if (value != null && ((byte[]) value).length > 0) {\n+        // Protobuf messages BYTES doesn't like empty bytes?!\n+        FieldDescriptor fieldDescriptor = getFieldDescriptor(message);\n+        message.setField(fieldDescriptor, convertToProtoValue(fieldDescriptor, value));\n+      }\n+    }\n+\n+    @Override\n+    Object convertToProtoValue(FieldDescriptor fieldDescriptor, Object value) {\n+      if (value != null) {\n+        return ByteString.copyFrom((byte[]) value);\n+      }\n+      return null;\n+    }\n+  }\n+\n+  /**\n+   * Specific converter for Proto Wrapper values as they are translated into nullable row values.\n+   */\n+  static class WrapperConvert extends Convert<Object, Object> {\n+    private Convert valueConvert;\n+\n+    WrapperConvert(Schema.Field field, Convert valueConvert) {\n+      super(field);\n+      this.valueConvert = valueConvert;\n+    }\n+\n+    @Override\n+    Object getFromProtoMessage(Message message) {\n+      if (message.hasField(getFieldDescriptor(message))) {\n+        Message wrapper = (Message) message.getField(getFieldDescriptor(message));\n+        return valueConvert.getFromProtoMessage(wrapper);\n+      }\n+      return null;\n+    }\n+\n+    @Override\n+    Object convertFromProtoValue(Object object) {\n+      return object;\n+    }\n+\n+    @Override\n+    void setOnProtoMessage(Message.Builder message, Object value) {\n+      if (value != null) {\n+        DynamicMessage.Builder builder =\n+            DynamicMessage.newBuilder(getFieldDescriptor(message).getMessageType());\n+        valueConvert.setOnProtoMessage(builder, value);\n+        message.setField(getFieldDescriptor(message), builder.build());\n+      }\n+    }\n+\n+    @Override\n+    Object convertToProtoValue(FieldDescriptor fieldDescriptor, Object value) {\n+      return value;\n+    }\n+  }\n+\n+  static class TimestampConvert extends Convert<Object, Object> {\n+\n+    TimestampConvert(Schema.Field field) {\n+      super(field);\n+    }\n+\n+    @Override\n+    Object getFromProtoMessage(Message message) {\n+      FieldDescriptor fieldDescriptor = getFieldDescriptor(message);\n+      if (message.hasField(fieldDescriptor)) {\n+        Message wrapper = (Message) message.getField(fieldDescriptor);\n+        return convertFromProtoValue(wrapper);\n+      }\n+      return null;\n+    }\n+\n+    @Override\n+    Object convertFromProtoValue(Object object) {\n+      Message timestamp = (Message) object;\n+      Descriptors.Descriptor timestampDescriptor = timestamp.getDescriptorForType();\n+      FieldDescriptor secondField = timestampDescriptor.findFieldByNumber(1);\n+      FieldDescriptor nanoField = timestampDescriptor.findFieldByNumber(2);\n+      long second = (long) timestamp.getField(secondField);\n+      int nano = (int) timestamp.getField(nanoField);\n+      return Instant.ofEpochSecond(second, nano);\n+    }\n+\n+    @Override\n+    void setOnProtoMessage(Message.Builder message, Object value) {\n+      if (value != null) {\n+        FieldDescriptor fieldDescriptor = getFieldDescriptor(message);\n+        message.setField(fieldDescriptor, convertToProtoValue(fieldDescriptor, value));\n+      }\n+    }\n+\n+    @Override\n+    Object convertToProtoValue(FieldDescriptor fieldDescriptor, Object value) {\n+      Row row = (Row) value;\n+      return com.google.protobuf.Timestamp.newBuilder()\n+          .setSeconds(row.getInt64(0))\n+          .setNanos(row.getInt32(1))\n+          .build();\n+    }\n+  }\n+\n+  static class DurationConvert extends Convert<Object, Object> {\n+\n+    DurationConvert(Schema.Field field) {\n+      super(field);\n+    }\n+\n+    @Override\n+    Object getFromProtoMessage(Message message) {\n+      FieldDescriptor fieldDescriptor = getFieldDescriptor(message);\n+      if (message.hasField(fieldDescriptor)) {\n+        Message wrapper = (Message) message.getField(fieldDescriptor);\n+        return convertFromProtoValue(wrapper);\n+      }\n+      return null;\n+    }\n+\n+    @Override\n+    Duration convertFromProtoValue(Object object) {\n+      Message timestamp = (Message) object;\n+      Descriptors.Descriptor timestampDescriptor = timestamp.getDescriptorForType();\n+      FieldDescriptor secondField = timestampDescriptor.findFieldByNumber(1);\n+      FieldDescriptor nanoField = timestampDescriptor.findFieldByNumber(2);\n+      long second = (long) timestamp.getField(secondField);\n+      int nano = (int) timestamp.getField(nanoField);\n+      return Duration.ofSeconds(second, nano);\n+    }\n+\n+    @Override\n+    void setOnProtoMessage(Message.Builder message, Object value) {\n+      if (value != null) {\n+        FieldDescriptor fieldDescriptor = getFieldDescriptor(message);\n+        message.setField(fieldDescriptor, convertToProtoValue(fieldDescriptor, value));\n+      }\n+    }\n+\n+    @Override\n+    Object convertToProtoValue(FieldDescriptor fieldDescriptor, Object value) {\n+      Row row = (Row) value;\n+      return com.google.protobuf.Duration.newBuilder()\n+          .setSeconds(row.getInt64(0))\n+          .setNanos(row.getInt32(1))\n+          .build();\n+    }\n+  }\n+\n+  static class MessageConvert extends Convert<Object, Object> {\n+    private final SerializableFunction fromRowFunction;\n+    private final SerializableFunction toRowFunction;\n+\n+    MessageConvert(ProtoDynamicMessageSchema rootProtoSchema, Schema.Field field) {\n+      super(field);\n+      ProtoDynamicMessageSchema protoSchema =\n+          ProtoDynamicMessageSchema.forContext(rootProtoSchema.context, field);\n+      SchemaCoder<DynamicMessage> schemaCoder = protoSchema.getSchemaCoder();", "originalCommit": "012c45a8174f61d47ba31b2d47f03deb86c77fa5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUwOTY1NA==", "url": "https://github.com/apache/beam/pull/10502#discussion_r383509654", "bodyText": "I've changed the accesses here, but iI still think that it's ok to use SchemaCoder as a transient container for the trio: Schema, ToRow and FromRow.\nIf it's a blocker, I can spit it up in 3 different transient fields.", "author": "alexvanboxel", "createdAt": "2020-02-24T20:56:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3MTE1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzYzNzU1OQ==", "url": "https://github.com/apache/beam/pull/10502#discussion_r383637559", "bodyText": "I would prefer 3 fields. SchemaCoder is not a container object - it just happens to contain those fields. In fact I would prefer to make SchemaCoder private (so that users of Schemas don't have to ever deal with coders at all), however that would require more major changes to Beam.", "author": "reuvenlax", "createdAt": "2020-02-25T03:15:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3MTE1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY5MTYxOQ==", "url": "https://github.com/apache/beam/pull/10502#discussion_r383691619", "bodyText": "Removed coder as container.", "author": "alexvanboxel", "createdAt": "2020-02-25T07:05:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA3MTE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAwNDI3NA==", "url": "https://github.com/apache/beam/pull/10502#discussion_r384004274", "bodyText": "I don't see this function being used anywhere. Remove?", "author": "reuvenlax", "createdAt": "2020-02-25T17:04:21Z", "path": "sdks/java/extensions/protobuf/src/main/java/org/apache/beam/sdk/extensions/protobuf/ProtoDynamicMessageSchema.java", "diffHunk": "@@ -0,0 +1,854 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.extensions.protobuf;\n+\n+import static org.apache.beam.sdk.extensions.protobuf.ProtoSchemaTranslator.getFieldNumber;\n+import static org.apache.beam.sdk.extensions.protobuf.ProtoSchemaTranslator.getMapKeyMessageName;\n+import static org.apache.beam.sdk.extensions.protobuf.ProtoSchemaTranslator.getMapValueMessageName;\n+import static org.apache.beam.sdk.extensions.protobuf.ProtoSchemaTranslator.getMessageName;\n+import static org.apache.beam.sdk.extensions.protobuf.ProtoSchemaTranslator.withFieldNumber;\n+import static org.apache.beam.sdk.extensions.protobuf.ProtoSchemaTranslator.withMessageName;\n+\n+import com.google.protobuf.ByteString;\n+import com.google.protobuf.Descriptors;\n+import com.google.protobuf.Descriptors.FieldDescriptor;\n+import com.google.protobuf.DynamicMessage;\n+import com.google.protobuf.Message;\n+import java.io.Serializable;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.schemas.SchemaCoder;\n+import org.apache.beam.sdk.schemas.logicaltypes.EnumerationType;\n+import org.apache.beam.sdk.schemas.logicaltypes.NanosDuration;\n+import org.apache.beam.sdk.schemas.logicaltypes.NanosInstant;\n+import org.apache.beam.sdk.schemas.logicaltypes.OneOfType;\n+import org.apache.beam.sdk.transforms.SerializableFunction;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.sdk.values.TypeDescriptor;\n+\n+@Experimental(Experimental.Kind.SCHEMAS)\n+public class ProtoDynamicMessageSchema<T> implements Serializable {\n+  public static final long serialVersionUID = 1L;\n+\n+  /**\n+   * Context of the schema, the context can be generated from a source schema or descriptors. The\n+   * ability of converting back from Row to proto depends on the type of context.\n+   */\n+  private final Context context;\n+\n+  /** The toRow function to convert the Message to a Row. */\n+  private transient SerializableFunction<T, Row> toRowFunction;\n+\n+  /** The fromRow function to convert the Row to a Message. */\n+  private transient SerializableFunction<Row, T> fromRowFunction;\n+\n+  /** List of field converters for each field in the row. */\n+  private transient List<Convert> converters;\n+\n+  private ProtoDynamicMessageSchema(String messageName, ProtoDomain domain) {\n+    this.context = new DescriptorContext(messageName, domain);\n+    readResolve();\n+  }\n+\n+  private ProtoDynamicMessageSchema(Context context) {\n+    this.context = context;\n+    readResolve();\n+  }\n+\n+  /**\n+   * Create a new ProtoDynamicMessageSchema from a {@link ProtoDomain} and for a message. The\n+   * message need to be in the domain and needs to be the fully qualified name.\n+   */\n+  public static ProtoDynamicMessageSchema forDescriptor(ProtoDomain domain, String messageName) {\n+    return new ProtoDynamicMessageSchema(messageName, domain);\n+  }\n+\n+  /**\n+   * Create a new ProtoDynamicMessageSchema from a {@link ProtoDomain} and for a descriptor. The\n+   * descriptor is only used for it's name, that name will be used for a search in the domain.\n+   */\n+  public static ProtoDynamicMessageSchema<DynamicMessage> forDescriptor(\n+      ProtoDomain domain, Descriptors.Descriptor descriptor) {\n+    return new ProtoDynamicMessageSchema<>(descriptor.getFullName(), domain);\n+  }\n+\n+  static ProtoDynamicMessageSchema<?> forContext(Context context, Schema.Field field) {\n+    return new ProtoDynamicMessageSchema<>(context.getSubContext(field));\n+  }\n+\n+  static ProtoDynamicMessageSchema<Message> forSchema(Schema schema) {\n+    return new ProtoDynamicMessageSchema<>(new Context(schema, Message.class));\n+  }\n+\n+  /** Initialize the transient fields after deserialization or construction. */\n+  private Object readResolve() {\n+    converters = createConverters(context.getSchema());\n+    toRowFunction = new MessageToRowFunction();\n+    fromRowFunction = new RowToMessageFunction();\n+    return this;\n+  }\n+\n+  Convert createConverter(Schema.Field field) {\n+    Schema.FieldType fieldType = field.getType();\n+    String messageName = getMessageName(fieldType);\n+    if (messageName != null && messageName.length() > 0) {\n+      Schema.Field valueField =\n+          Schema.Field.of(\"value\", withFieldNumber(Schema.FieldType.BOOLEAN, 1));\n+      switch (messageName) {\n+        case \"google.protobuf.StringValue\":\n+        case \"google.protobuf.DoubleValue\":\n+        case \"google.protobuf.FloatValue\":\n+        case \"google.protobuf.BoolValue\":\n+        case \"google.protobuf.Int64Value\":\n+        case \"google.protobuf.Int32Value\":\n+        case \"google.protobuf.UInt64Value\":\n+        case \"google.protobuf.UInt32Value\":\n+          return new WrapperConvert(field, new PrimitiveConvert(valueField));\n+        case \"google.protobuf.BytesValue\":\n+          return new WrapperConvert(field, new BytesConvert(valueField));\n+        case \"google.protobuf.Timestamp\":\n+        case \"google.protobuf.Duration\":\n+          // handled by logical type case\n+          break;\n+      }\n+    }\n+    switch (fieldType.getTypeName()) {\n+      case BYTE:\n+      case INT16:\n+      case INT32:\n+      case INT64:\n+      case FLOAT:\n+      case DOUBLE:\n+      case STRING:\n+      case BOOLEAN:\n+        return new PrimitiveConvert(field);\n+      case BYTES:\n+        return new BytesConvert(field);\n+      case ARRAY:\n+      case ITERABLE:\n+        return new ArrayConvert(this, field);\n+      case MAP:\n+        return new MapConvert(this, field);\n+      case LOGICAL_TYPE:\n+        String identifier = field.getType().getLogicalType().getIdentifier();\n+        switch (identifier) {\n+          case ProtoSchemaLogicalTypes.Fixed32.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.Fixed64.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.SFixed32.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.SFixed64.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.SInt32.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.SInt64.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.UInt32.IDENTIFIER:\n+          case ProtoSchemaLogicalTypes.UInt64.IDENTIFIER:\n+            return new LogicalTypeConvert(field, fieldType.getLogicalType());\n+          case NanosInstant.IDENTIFIER:\n+            return new TimestampConvert(field);\n+          case NanosDuration.IDENTIFIER:\n+            return new DurationConvert(field);\n+          case EnumerationType.IDENTIFIER:\n+            return new EnumConvert(field, fieldType.getLogicalType());\n+          case OneOfType.IDENTIFIER:\n+            return new OneOfConvert(this, field, fieldType.getLogicalType());\n+          default:\n+            throw new IllegalStateException(\"Unexpected logical type : \" + identifier);\n+        }\n+      case ROW:\n+        return new MessageConvert(this, field);\n+      default:\n+        throw new IllegalStateException(\"Unexpected value: \" + fieldType);\n+    }\n+  }\n+\n+  private List<Convert> createConverters(Schema schema) {\n+    List<Convert> fieldOverlays = new ArrayList<>();\n+    for (Schema.Field field : schema.getFields()) {\n+      fieldOverlays.add(createConverter(field));\n+    }\n+    return fieldOverlays;\n+  }\n+\n+  public Schema getSchema() {\n+    return context.getSchema();\n+  }\n+\n+  public SchemaCoder<T> getSchemaCoder() {\n+    return SchemaCoder.of(\n+        context.getSchema(),\n+        TypeDescriptor.of(context.getBaseClass()),\n+        toRowFunction,\n+        fromRowFunction);\n+  }", "originalCommit": "036b831635cf0e6ec57338bd081a3684f3c9b566", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE5MjgwNg==", "url": "https://github.com/apache/beam/pull/10502#discussion_r384192806", "bodyText": "I used it in a production pipeline, but as it's not available in the other providers I removed it, (squashed and rebased).", "author": "alexvanboxel", "createdAt": "2020-02-25T23:36:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAwNDI3NA=="}], "type": "inlineReview"}, {"oid": "7a0fe93b2bd28d96a43583e123b09ccd4d0ca033", "url": "https://github.com/apache/beam/commit/7a0fe93b2bd28d96a43583e123b09ccd4d0ca033", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages.", "committedDate": "2020-02-25T23:24:49Z", "type": "commit"}, {"oid": "7a0fe93b2bd28d96a43583e123b09ccd4d0ca033", "url": "https://github.com/apache/beam/commit/7a0fe93b2bd28d96a43583e123b09ccd4d0ca033", "message": "[BEAM-7274] Add DynamicMessage Schema support\n\nAdd DynamicMessage schema support. This is different from\ngenerated classes as it uses the proto descriptors. It uses\nthe ProtoDomain as an index for searching embedded messages.", "committedDate": "2020-02-25T23:24:49Z", "type": "forcePushed"}]}