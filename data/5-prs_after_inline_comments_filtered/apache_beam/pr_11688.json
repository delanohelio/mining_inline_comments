{"pr_number": 11688, "pr_title": "[BEAM-9935, BEAM-3836] Respect allowed split points in Java", "pr_createdAt": "2020-05-12T21:53:59Z", "pr_url": "https://github.com/apache/beam/pull/11688", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NDc0Ng==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424084746", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // 8 should be the split but it's not in the allowedSplitPoints list. Then 8 is the closet one.\n          \n          \n            \n                // 8 should be the split but it's not in the allowedSplitPoints list. 9 is the closest one.", "author": "lukecwik", "createdAt": "2020-05-12T23:10:00Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java", "diffHunk": "@@ -405,51 +371,140 @@ public void testSplittingDownstreamReceiver() throws Exception {\n     SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n     when(splittingReceiver.getProgress()).thenReturn(0.3);\n     when(splittingReceiver.trySplit(anyDouble())).thenReturn(splitResult);\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.05)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n+    String pTransformId = \"pTransformId\";\n+    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver, pTransformId);\n \n     // We will be \"processing\" the 'C' element, aka 2nd index\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.trySplit(request, responseBuilder);\n+    assertEquals(\n+        elementSplitResult(2, splitResult),\n+        executeSplit(\n+            readRunner,\n+            pTransformId,\n+            10,\n+            ImmutableList.of(\"A\", \"B\", \"C\"),\n+            0.05,\n+            Collections.EMPTY_LIST));\n+  }\n \n-    ProcessBundleSplitResponse expected =\n-        ProcessBundleSplitResponse.newBuilder()\n-            .addPrimaryRoots(splitResult.getPrimaryRoot())\n-            .addResidualRoots(splitResult.getResidualRoot())\n-            .addChannelSplits(\n-                ChannelSplit.newBuilder()\n-                    .setLastPrimaryElement(1)\n-                    .setFirstResidualElement(3)\n-                    .build())\n-            .build();\n-    assertEquals(expected, responseBuilder.build());\n+  @Test\n+  public void testChannelSplittingWithAllowedSplitPoints() throws Exception {\n+\n+    List<WindowedValue<String>> outputValues = new ArrayList<>();\n+    String pTransformId = \"pTransformId\";\n+    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add, pTransformId);\n+    // 16 is the desired split point.\n+    assertEquals(\n+        channelSplitResult(16),\n+        executeSplit(\n+            readRunner,\n+            pTransformId,\n+            32,\n+            Collections.EMPTY_LIST,\n+            0.5,\n+            ImmutableList.of(10L, 13L, 16L, 20L)));\n+\n+    // 8 should be the split but it's not in the allowedSplitPoints list. Then 8 is the closet one.", "originalCommit": "a0d270c71a0a3ed51742cd8254e2831907be6c9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NDgzMw==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424084833", "bodyText": "Suggested change", "author": "lukecwik", "createdAt": "2020-05-12T23:10:10Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java", "diffHunk": "@@ -405,51 +371,140 @@ public void testSplittingDownstreamReceiver() throws Exception {\n     SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n     when(splittingReceiver.getProgress()).thenReturn(0.3);\n     when(splittingReceiver.trySplit(anyDouble())).thenReturn(splitResult);\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.05)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n+    String pTransformId = \"pTransformId\";\n+    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver, pTransformId);\n \n     // We will be \"processing\" the 'C' element, aka 2nd index\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.trySplit(request, responseBuilder);\n+    assertEquals(\n+        elementSplitResult(2, splitResult),\n+        executeSplit(\n+            readRunner,\n+            pTransformId,\n+            10,\n+            ImmutableList.of(\"A\", \"B\", \"C\"),\n+            0.05,\n+            Collections.EMPTY_LIST));\n+  }\n \n-    ProcessBundleSplitResponse expected =\n-        ProcessBundleSplitResponse.newBuilder()\n-            .addPrimaryRoots(splitResult.getPrimaryRoot())\n-            .addResidualRoots(splitResult.getResidualRoot())\n-            .addChannelSplits(\n-                ChannelSplit.newBuilder()\n-                    .setLastPrimaryElement(1)\n-                    .setFirstResidualElement(3)\n-                    .build())\n-            .build();\n-    assertEquals(expected, responseBuilder.build());\n+  @Test\n+  public void testChannelSplittingWithAllowedSplitPoints() throws Exception {\n+", "originalCommit": "a0d270c71a0a3ed51742cd8254e2831907be6c9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NTgxMA==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424085810", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // The ideal split should at 2(\"C\") but 3 is not a split point. So the closet split is 4.\n          \n          \n            \n                // The ideal split should at 2(\"C\") but 3 is not a split point. So the closest split is 4.", "author": "lukecwik", "createdAt": "2020-05-12T23:13:11Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java", "diffHunk": "@@ -405,51 +371,140 @@ public void testSplittingDownstreamReceiver() throws Exception {\n     SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n     when(splittingReceiver.getProgress()).thenReturn(0.3);\n     when(splittingReceiver.trySplit(anyDouble())).thenReturn(splitResult);\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.05)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n+    String pTransformId = \"pTransformId\";\n+    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver, pTransformId);\n \n     // We will be \"processing\" the 'C' element, aka 2nd index\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.trySplit(request, responseBuilder);\n+    assertEquals(\n+        elementSplitResult(2, splitResult),\n+        executeSplit(\n+            readRunner,\n+            pTransformId,\n+            10,\n+            ImmutableList.of(\"A\", \"B\", \"C\"),\n+            0.05,\n+            Collections.EMPTY_LIST));\n+  }\n \n-    ProcessBundleSplitResponse expected =\n-        ProcessBundleSplitResponse.newBuilder()\n-            .addPrimaryRoots(splitResult.getPrimaryRoot())\n-            .addResidualRoots(splitResult.getResidualRoot())\n-            .addChannelSplits(\n-                ChannelSplit.newBuilder()\n-                    .setLastPrimaryElement(1)\n-                    .setFirstResidualElement(3)\n-                    .build())\n-            .build();\n-    assertEquals(expected, responseBuilder.build());\n+  @Test\n+  public void testChannelSplittingWithAllowedSplitPoints() throws Exception {\n+\n+    List<WindowedValue<String>> outputValues = new ArrayList<>();\n+    String pTransformId = \"pTransformId\";\n+    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add, pTransformId);\n+    // 16 is the desired split point.\n+    assertEquals(\n+        channelSplitResult(16),\n+        executeSplit(\n+            readRunner,\n+            pTransformId,\n+            32,\n+            Collections.EMPTY_LIST,\n+            0.5,\n+            ImmutableList.of(10L, 13L, 16L, 20L)));\n+\n+    // 8 should be the split but it's not in the allowedSplitPoints list. Then 8 is the closet one.\n+    assertEquals(\n+        channelSplitResult(9),\n+        executeSplit(\n+            readRunner,\n+            pTransformId,\n+            16,\n+            Collections.EMPTY_LIST,\n+            0.5,\n+            ImmutableList.of(5L, 7L, 9L, 10L)));\n+\n+    // 4 is the computed result but it's not in the allowedSplitPoints list. 5 is the closet one.\n+    assertEquals(\n+        channelSplitResult(5),\n+        executeSplit(\n+            readRunner, pTransformId, 7, Collections.EMPTY_LIST, 0.5, ImmutableList.of(2L, 5L)));\n+\n+    // The desired split point is not in the range of the allowed list.\n+    assertEquals(\n+        channelSplitResult(4),\n+        executeSplit(\n+            readRunner, pTransformId, 4, Collections.EMPTY_LIST, 0.5, ImmutableList.of(4L, 5L)));\n+\n+    assertEquals(\n+        channelSplitResult(2),\n+        executeSplit(\n+            readRunner, pTransformId, 4, Collections.EMPTY_LIST, 0.9, ImmutableList.of(1L, 2L)));\n+\n+    // All possible split points have been passed. So there is no split.\n+    assertEquals(\n+        ProcessBundleSplitResponse.getDefaultInstance(),\n+        executeSplit(\n+            readRunner, pTransformId, 2, ImmutableList.of(\"A\"), 0.5, ImmutableList.of(0L)));\n+  }\n+\n+  @Test\n+  public void testElementSplittingWithAllowedSplitPoints() throws Exception {\n+    SplitResult splitResult =\n+        SplitResult.of(\n+            BundleApplication.newBuilder().setInputId(\"primary\").build(),\n+            DelayedBundleApplication.newBuilder()\n+                .setApplication(BundleApplication.newBuilder().setInputId(\"residual\").build())\n+                .build());\n+    SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+    when(splittingReceiver.getProgress()).thenReturn(0.0);\n+    when(splittingReceiver.trySplit(anyDouble())).thenReturn(splitResult);\n+    String pTransformId = \"pTransformId\";\n+    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver, pTransformId);\n+    // The ideal split should at 2(\"C\") but 3 is not a split point. So split at 5.\n+    assertEquals(\n+        channelSplitResult(5),\n+        executeSplit(\n+            readRunner,\n+            pTransformId,\n+            5,\n+            ImmutableList.of(\"A\", \"B\", \"C\"),\n+            0.2,\n+            ImmutableList.of(1L, 2L, 5L)));\n+    // The ideal split should at 2(\"C\") but 3 is not a split point. So the closet split is 4.", "originalCommit": "a0d270c71a0a3ed51742cd8254e2831907be6c9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NjgzMg==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424086832", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  long newStopIndex =\n          \n          \n            \n                      Ints.checkedCast(index + Math.max(1, Math.round(currentElementProgress + keep)));\n          \n          \n            \n                  long newStopIndex = index + Math.max(1, Math.round(currentElementProgress + keep));", "author": "lukecwik", "createdAt": "2020-05-12T23:16:41Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "diffHunk": "@@ -256,10 +258,28 @@ public void trySplit(\n         }\n       }\n \n-      // Otherwise, split at the closest element boundary.\n-      int newStopIndex =\n+      // Otherwise, split at the closest allowed element boundary.\n+      long newStopIndex =\n           Ints.checkedCast(index + Math.max(1, Math.round(currentElementProgress + keep)));", "originalCommit": "a0d270c71a0a3ed51742cd8254e2831907be6c9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NzUwMw==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424087503", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    Collections.sort(allowedSplitPoints);\n          \n          \n            \n                    // Choose the closest allowed split point.\n          \n          \n            \n                    Collections.sort(allowedSplitPoints);", "author": "lukecwik", "createdAt": "2020-05-12T23:19:01Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "diffHunk": "@@ -256,10 +258,28 @@ public void trySplit(\n         }\n       }\n \n-      // Otherwise, split at the closest element boundary.\n-      int newStopIndex =\n+      // Otherwise, split at the closest allowed element boundary.\n+      long newStopIndex =\n           Ints.checkedCast(index + Math.max(1, Math.round(currentElementProgress + keep)));\n-      if (newStopIndex < stopIndex) {\n+      if (!isValidSplitPoint(allowedSplitPoints, newStopIndex)) {\n+        Collections.sort(allowedSplitPoints);", "originalCommit": "a0d270c71a0a3ed51742cd8254e2831907be6c9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4NzU4OA==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424087588", "bodyText": "nit: closetSplitPointIndex -> closestSplitPointIndex", "author": "lukecwik", "createdAt": "2020-05-12T23:19:17Z", "path": "sdks/java/harness/src/main/java/org/apache/beam/fn/harness/BeamFnDataReadRunner.java", "diffHunk": "@@ -256,10 +258,28 @@ public void trySplit(\n         }\n       }\n \n-      // Otherwise, split at the closest element boundary.\n-      int newStopIndex =\n+      // Otherwise, split at the closest allowed element boundary.\n+      long newStopIndex =\n           Ints.checkedCast(index + Math.max(1, Math.round(currentElementProgress + keep)));\n-      if (newStopIndex < stopIndex) {\n+      if (!isValidSplitPoint(allowedSplitPoints, newStopIndex)) {\n+        Collections.sort(allowedSplitPoints);\n+        int closetSplitPointIndex =", "originalCommit": "a0d270c71a0a3ed51742cd8254e2831907be6c9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDA4OTg5Mg==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424089892", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                // 4 is the computed result but it's not in the allowedSplitPoints list. 5 is the closet one.\n          \n          \n            \n                // 4 is the computed result but it's not in the allowedSplitPoints list. 5 is the closest one.", "author": "lukecwik", "createdAt": "2020-05-12T23:26:28Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java", "diffHunk": "@@ -405,51 +371,140 @@ public void testSplittingDownstreamReceiver() throws Exception {\n     SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n     when(splittingReceiver.getProgress()).thenReturn(0.3);\n     when(splittingReceiver.trySplit(anyDouble())).thenReturn(splitResult);\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.05)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n+    String pTransformId = \"pTransformId\";\n+    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver, pTransformId);\n \n     // We will be \"processing\" the 'C' element, aka 2nd index\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.trySplit(request, responseBuilder);\n+    assertEquals(\n+        elementSplitResult(2, splitResult),\n+        executeSplit(\n+            readRunner,\n+            pTransformId,\n+            10,\n+            ImmutableList.of(\"A\", \"B\", \"C\"),\n+            0.05,\n+            Collections.EMPTY_LIST));\n+  }\n \n-    ProcessBundleSplitResponse expected =\n-        ProcessBundleSplitResponse.newBuilder()\n-            .addPrimaryRoots(splitResult.getPrimaryRoot())\n-            .addResidualRoots(splitResult.getResidualRoot())\n-            .addChannelSplits(\n-                ChannelSplit.newBuilder()\n-                    .setLastPrimaryElement(1)\n-                    .setFirstResidualElement(3)\n-                    .build())\n-            .build();\n-    assertEquals(expected, responseBuilder.build());\n+  @Test\n+  public void testChannelSplittingWithAllowedSplitPoints() throws Exception {\n+\n+    List<WindowedValue<String>> outputValues = new ArrayList<>();\n+    String pTransformId = \"pTransformId\";\n+    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add, pTransformId);\n+    // 16 is the desired split point.\n+    assertEquals(\n+        channelSplitResult(16),\n+        executeSplit(\n+            readRunner,\n+            pTransformId,\n+            32,\n+            Collections.EMPTY_LIST,\n+            0.5,\n+            ImmutableList.of(10L, 13L, 16L, 20L)));\n+\n+    // 8 should be the split but it's not in the allowedSplitPoints list. Then 8 is the closet one.\n+    assertEquals(\n+        channelSplitResult(9),\n+        executeSplit(\n+            readRunner,\n+            pTransformId,\n+            16,\n+            Collections.EMPTY_LIST,\n+            0.5,\n+            ImmutableList.of(5L, 7L, 9L, 10L)));\n+\n+    // 4 is the computed result but it's not in the allowedSplitPoints list. 5 is the closet one.", "originalCommit": "a0d270c71a0a3ed51742cd8254e2831907be6c9b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4NzY0MQ==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424187641", "bodyText": "This test is the same to test_simple_split + test_split_with_element_progress", "author": "boyuanzz", "createdAt": "2020-05-13T05:52:49Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java", "diffHunk": "@@ -122,334 +129,579 @@\n \n   private static final String INPUT_TRANSFORM_ID = \"1\";\n \n-  @Rule public TestExecutorService executor = TestExecutors.from(Executors::newCachedThreadPool);\n-  @Mock private BeamFnDataClient mockBeamFnDataClient;\n-  @Captor private ArgumentCaptor<FnDataReceiver<WindowedValue<String>>> consumerCaptor;\n-\n-  @Before\n-  public void setUp() {\n-    MockitoAnnotations.initMocks(this);\n-  }\n-\n-  @Test\n-  public void testCreatingAndProcessingBeamFnDataReadRunner() throws Exception {\n-    String bundleId = \"57\";\n+  private static final String PTRANSFORM_ID = \"ptransform_id\";\n \n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n+  // Test basic executions of BeamFnDataReadRunner.\n+  @RunWith(JUnit4.class)\n+  public static class BeamFnDataReadRunnerExecutionTest {\n+    @Rule public TestExecutorService executor = TestExecutors.from(Executors::newCachedThreadPool);\n+    @Mock private BeamFnDataClient mockBeamFnDataClient;\n+    @Captor private ArgumentCaptor<FnDataReceiver<WindowedValue<String>>> consumerCaptor;\n \n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    String localOutputId = \"outputPC\";\n-    String pTransformId = \"pTransformId\";\n-    consumers.register(\n-        localOutputId,\n-        pTransformId,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) outputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    RunnerApi.PTransform pTransform =\n-        RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n-\n-    new BeamFnDataReadRunner.Factory<String>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            mockBeamFnDataClient,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            pTransformId,\n-            pTransform,\n-            Suppliers.ofInstance(bundleId)::get,\n-            ImmutableMap.of(\n-                localOutputId,\n-                RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n-            COMPONENTS.getCodersMap(),\n-            COMPONENTS.getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertThat(teardownFunctions, empty());\n-\n-    verifyZeroInteractions(mockBeamFnDataClient);\n+    @Before\n+    public void setUp() {\n+      MockitoAnnotations.initMocks(this);\n+    }\n \n-    InboundDataClient completionFuture = CompletableFutureInboundDataClient.create();\n-    when(mockBeamFnDataClient.receive(any(), any(), any(), any())).thenReturn(completionFuture);\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId, pTransformId)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n+    @Test\n+    public void testCreatingAndProcessingBeamFnDataReadRunner() throws Exception {\n+      String bundleId = \"57\";\n+\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      String localOutputId = \"outputPC\";\n+      String pTransformId = \"pTransformId\";\n+      consumers.register(\n+          localOutputId,\n+          pTransformId,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) outputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      RunnerApi.PTransform pTransform =\n+          RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n+\n+      new BeamFnDataReadRunner.Factory<String>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              mockBeamFnDataClient,\n+              null /* beamFnStateClient */,\n+              null /* beamFnTimerClient */,\n+              pTransformId,\n+              pTransform,\n+              Suppliers.ofInstance(bundleId)::get,\n+              ImmutableMap.of(\n+                  localOutputId,\n+                  RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n+              COMPONENTS.getCodersMap(),\n+              COMPONENTS.getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertThat(teardownFunctions, empty());\n+\n+      verifyZeroInteractions(mockBeamFnDataClient);\n+\n+      InboundDataClient completionFuture = CompletableFutureInboundDataClient.create();\n+      when(mockBeamFnDataClient.receive(any(), any(), any(), any())).thenReturn(completionFuture);\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId, pTransformId)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      consumerCaptor.getValue().accept(valueInGlobalWindow(\"TestValue\"));\n+      assertThat(outputValues, contains(valueInGlobalWindow(\"TestValue\")));\n+      outputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(localOutputId));\n+\n+      completionFuture.complete();\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-    consumerCaptor.getValue().accept(valueInGlobalWindow(\"TestValue\"));\n-    assertThat(outputValues, contains(valueInGlobalWindow(\"TestValue\")));\n-    outputValues.clear();\n+    @Test\n+    public void testReuseForMultipleBundles() throws Exception {\n+      InboundDataClient bundle1Future = CompletableFutureInboundDataClient.create();\n+      InboundDataClient bundle2Future = CompletableFutureInboundDataClient.create();\n+      when(mockBeamFnDataClient.receive(any(), any(), any(), any()))\n+          .thenReturn(bundle1Future)\n+          .thenReturn(bundle2Future);\n+      List<WindowedValue<String>> values = new ArrayList<>();\n+      FnDataReceiver<WindowedValue<String>> consumers = values::add;\n+      AtomicReference<String> bundleId = new AtomicReference<>(\"0\");\n+      BeamFnDataReadRunner<String> readRunner =\n+          new BeamFnDataReadRunner<>(\n+              INPUT_TRANSFORM_ID,\n+              RemoteGrpcPortRead.readFromPort(PORT_SPEC, \"localOutput\").toPTransform(),\n+              bundleId::get,\n+              COMPONENTS.getCodersMap(),\n+              mockBeamFnDataClient,\n+              consumers);\n+\n+      // Process for bundle id 0\n+      readRunner.registerInputLocation();\n+\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      Future<?> future =\n+          executor.submit(\n+              () -> {\n+                // Sleep for some small amount of time simulating the parent blocking\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+                try {\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"ABC\"));\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"DEF\"));\n+                } catch (Exception e) {\n+                  bundle1Future.fail(e);\n+                } finally {\n+                  bundle1Future.complete();\n+                }\n+              });\n+\n+      readRunner.blockTillReadFinishes();\n+      future.get();\n+      assertThat(values, contains(valueInGlobalWindow(\"ABC\"), valueInGlobalWindow(\"DEF\")));\n+\n+      // Process for bundle id 1\n+      bundleId.set(\"1\");\n+      values.clear();\n+      readRunner.registerInputLocation();\n+\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      future =\n+          executor.submit(\n+              () -> {\n+                // Sleep for some small amount of time simulating the parent blocking\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+                try {\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"GHI\"));\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"JKL\"));\n+                } catch (Exception e) {\n+                  bundle2Future.fail(e);\n+                } finally {\n+                  bundle2Future.complete();\n+                }\n+              });\n+\n+      readRunner.blockTillReadFinishes();\n+      future.get();\n+      assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n+\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-    assertThat(consumers.keySet(), containsInAnyOrder(localOutputId));\n+    @Test\n+    public void testRegistration() {\n+      for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n+        if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n+          assertThat(\n+              registrar.getPTransformRunnerFactories(),\n+              IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n+          return;\n+        }\n+      }\n+      fail(\"Expected registrar not found.\");\n+    }\n \n-    completionFuture.complete();\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+    @Test\n+    public void testSplittingWhenNoElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      // The split should happen at 5 since the allowedSplitPoints is empty.\n+      assertEquals(\n+          channelSplitResult(5),\n+          executeSplit(\n+              readRunner, PTRANSFORM_ID, 10, Collections.EMPTY_LIST, 0.5, Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\")));\n+    }\n \n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n+    @Test\n+    public void testSplittingWhenSomeElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          channelSplitResult(6),\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              10,\n+              ImmutableList.of(\"A\", \"B\"),\n+              0.5,\n+              Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\"),\n+              valueInGlobalWindow(\"F\")));\n+    }\n   }\n \n-  @Test\n-  public void testReuseForMultipleBundles() throws Exception {\n-    InboundDataClient bundle1Future = CompletableFutureInboundDataClient.create();\n-    InboundDataClient bundle2Future = CompletableFutureInboundDataClient.create();\n-    when(mockBeamFnDataClient.receive(any(), any(), any(), any()))\n-        .thenReturn(bundle1Future)\n-        .thenReturn(bundle2Future);\n-    List<WindowedValue<String>> values = new ArrayList<>();\n-    FnDataReceiver<WindowedValue<String>> consumers = values::add;\n-    AtomicReference<String> bundleId = new AtomicReference<>(\"0\");\n-    BeamFnDataReadRunner<String> readRunner =\n-        new BeamFnDataReadRunner<>(\n-            INPUT_TRANSFORM_ID,\n-            RemoteGrpcPortRead.readFromPort(PORT_SPEC, \"localOutput\").toPTransform(),\n-            bundleId::get,\n-            COMPONENTS.getCodersMap(),\n-            mockBeamFnDataClient,\n-            consumers);\n-\n-    // Process for bundle id 0\n-    readRunner.registerInputLocation();\n-\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n-\n-    Future<?> future =\n-        executor.submit(\n-            () -> {\n-              // Sleep for some small amount of time simulating the parent blocking\n-              Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-              try {\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"ABC\"));\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"DEF\"));\n-              } catch (Exception e) {\n-                bundle1Future.fail(e);\n-              } finally {\n-                bundle1Future.complete();\n-              }\n-            });\n-\n-    readRunner.blockTillReadFinishes();\n-    future.get();\n-    assertThat(values, contains(valueInGlobalWindow(\"ABC\"), valueInGlobalWindow(\"DEF\")));\n-\n-    // Process for bundle id 1\n-    bundleId.set(\"1\");\n-    values.clear();\n-    readRunner.registerInputLocation();\n-\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n-\n-    future =\n-        executor.submit(\n-            () -> {\n-              // Sleep for some small amount of time simulating the parent blocking\n-              Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-              try {\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"GHI\"));\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"JKL\"));\n-              } catch (Exception e) {\n-                bundle2Future.fail(e);\n-              } finally {\n-                bundle2Future.complete();\n-              }\n-            });\n-\n-    readRunner.blockTillReadFinishes();\n-    future.get();\n-    assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n-\n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n-  }\n+  // Test different cases of chan nel split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitTest {", "originalCommit": "e68fe093b7d654148ef0392e8ba4f7c1c127a10d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4NzgxNw==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424187817", "bodyText": "The same to test_split_with_element_allowed_splits", "author": "boyuanzz", "createdAt": "2020-05-13T05:53:25Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java", "diffHunk": "@@ -122,334 +129,579 @@\n \n   private static final String INPUT_TRANSFORM_ID = \"1\";\n \n-  @Rule public TestExecutorService executor = TestExecutors.from(Executors::newCachedThreadPool);\n-  @Mock private BeamFnDataClient mockBeamFnDataClient;\n-  @Captor private ArgumentCaptor<FnDataReceiver<WindowedValue<String>>> consumerCaptor;\n-\n-  @Before\n-  public void setUp() {\n-    MockitoAnnotations.initMocks(this);\n-  }\n-\n-  @Test\n-  public void testCreatingAndProcessingBeamFnDataReadRunner() throws Exception {\n-    String bundleId = \"57\";\n+  private static final String PTRANSFORM_ID = \"ptransform_id\";\n \n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n+  // Test basic executions of BeamFnDataReadRunner.\n+  @RunWith(JUnit4.class)\n+  public static class BeamFnDataReadRunnerExecutionTest {\n+    @Rule public TestExecutorService executor = TestExecutors.from(Executors::newCachedThreadPool);\n+    @Mock private BeamFnDataClient mockBeamFnDataClient;\n+    @Captor private ArgumentCaptor<FnDataReceiver<WindowedValue<String>>> consumerCaptor;\n \n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    String localOutputId = \"outputPC\";\n-    String pTransformId = \"pTransformId\";\n-    consumers.register(\n-        localOutputId,\n-        pTransformId,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) outputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    RunnerApi.PTransform pTransform =\n-        RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n-\n-    new BeamFnDataReadRunner.Factory<String>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            mockBeamFnDataClient,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            pTransformId,\n-            pTransform,\n-            Suppliers.ofInstance(bundleId)::get,\n-            ImmutableMap.of(\n-                localOutputId,\n-                RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n-            COMPONENTS.getCodersMap(),\n-            COMPONENTS.getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertThat(teardownFunctions, empty());\n-\n-    verifyZeroInteractions(mockBeamFnDataClient);\n+    @Before\n+    public void setUp() {\n+      MockitoAnnotations.initMocks(this);\n+    }\n \n-    InboundDataClient completionFuture = CompletableFutureInboundDataClient.create();\n-    when(mockBeamFnDataClient.receive(any(), any(), any(), any())).thenReturn(completionFuture);\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId, pTransformId)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n+    @Test\n+    public void testCreatingAndProcessingBeamFnDataReadRunner() throws Exception {\n+      String bundleId = \"57\";\n+\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      String localOutputId = \"outputPC\";\n+      String pTransformId = \"pTransformId\";\n+      consumers.register(\n+          localOutputId,\n+          pTransformId,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) outputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      RunnerApi.PTransform pTransform =\n+          RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n+\n+      new BeamFnDataReadRunner.Factory<String>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              mockBeamFnDataClient,\n+              null /* beamFnStateClient */,\n+              null /* beamFnTimerClient */,\n+              pTransformId,\n+              pTransform,\n+              Suppliers.ofInstance(bundleId)::get,\n+              ImmutableMap.of(\n+                  localOutputId,\n+                  RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n+              COMPONENTS.getCodersMap(),\n+              COMPONENTS.getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertThat(teardownFunctions, empty());\n+\n+      verifyZeroInteractions(mockBeamFnDataClient);\n+\n+      InboundDataClient completionFuture = CompletableFutureInboundDataClient.create();\n+      when(mockBeamFnDataClient.receive(any(), any(), any(), any())).thenReturn(completionFuture);\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId, pTransformId)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      consumerCaptor.getValue().accept(valueInGlobalWindow(\"TestValue\"));\n+      assertThat(outputValues, contains(valueInGlobalWindow(\"TestValue\")));\n+      outputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(localOutputId));\n+\n+      completionFuture.complete();\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-    consumerCaptor.getValue().accept(valueInGlobalWindow(\"TestValue\"));\n-    assertThat(outputValues, contains(valueInGlobalWindow(\"TestValue\")));\n-    outputValues.clear();\n+    @Test\n+    public void testReuseForMultipleBundles() throws Exception {\n+      InboundDataClient bundle1Future = CompletableFutureInboundDataClient.create();\n+      InboundDataClient bundle2Future = CompletableFutureInboundDataClient.create();\n+      when(mockBeamFnDataClient.receive(any(), any(), any(), any()))\n+          .thenReturn(bundle1Future)\n+          .thenReturn(bundle2Future);\n+      List<WindowedValue<String>> values = new ArrayList<>();\n+      FnDataReceiver<WindowedValue<String>> consumers = values::add;\n+      AtomicReference<String> bundleId = new AtomicReference<>(\"0\");\n+      BeamFnDataReadRunner<String> readRunner =\n+          new BeamFnDataReadRunner<>(\n+              INPUT_TRANSFORM_ID,\n+              RemoteGrpcPortRead.readFromPort(PORT_SPEC, \"localOutput\").toPTransform(),\n+              bundleId::get,\n+              COMPONENTS.getCodersMap(),\n+              mockBeamFnDataClient,\n+              consumers);\n+\n+      // Process for bundle id 0\n+      readRunner.registerInputLocation();\n+\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      Future<?> future =\n+          executor.submit(\n+              () -> {\n+                // Sleep for some small amount of time simulating the parent blocking\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+                try {\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"ABC\"));\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"DEF\"));\n+                } catch (Exception e) {\n+                  bundle1Future.fail(e);\n+                } finally {\n+                  bundle1Future.complete();\n+                }\n+              });\n+\n+      readRunner.blockTillReadFinishes();\n+      future.get();\n+      assertThat(values, contains(valueInGlobalWindow(\"ABC\"), valueInGlobalWindow(\"DEF\")));\n+\n+      // Process for bundle id 1\n+      bundleId.set(\"1\");\n+      values.clear();\n+      readRunner.registerInputLocation();\n+\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      future =\n+          executor.submit(\n+              () -> {\n+                // Sleep for some small amount of time simulating the parent blocking\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+                try {\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"GHI\"));\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"JKL\"));\n+                } catch (Exception e) {\n+                  bundle2Future.fail(e);\n+                } finally {\n+                  bundle2Future.complete();\n+                }\n+              });\n+\n+      readRunner.blockTillReadFinishes();\n+      future.get();\n+      assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n+\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-    assertThat(consumers.keySet(), containsInAnyOrder(localOutputId));\n+    @Test\n+    public void testRegistration() {\n+      for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n+        if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n+          assertThat(\n+              registrar.getPTransformRunnerFactories(),\n+              IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n+          return;\n+        }\n+      }\n+      fail(\"Expected registrar not found.\");\n+    }\n \n-    completionFuture.complete();\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+    @Test\n+    public void testSplittingWhenNoElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      // The split should happen at 5 since the allowedSplitPoints is empty.\n+      assertEquals(\n+          channelSplitResult(5),\n+          executeSplit(\n+              readRunner, PTRANSFORM_ID, 10, Collections.EMPTY_LIST, 0.5, Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\")));\n+    }\n \n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n+    @Test\n+    public void testSplittingWhenSomeElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          channelSplitResult(6),\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              10,\n+              ImmutableList.of(\"A\", \"B\"),\n+              0.5,\n+              Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\"),\n+              valueInGlobalWindow(\"F\")));\n+    }\n   }\n \n-  @Test\n-  public void testReuseForMultipleBundles() throws Exception {\n-    InboundDataClient bundle1Future = CompletableFutureInboundDataClient.create();\n-    InboundDataClient bundle2Future = CompletableFutureInboundDataClient.create();\n-    when(mockBeamFnDataClient.receive(any(), any(), any(), any()))\n-        .thenReturn(bundle1Future)\n-        .thenReturn(bundle2Future);\n-    List<WindowedValue<String>> values = new ArrayList<>();\n-    FnDataReceiver<WindowedValue<String>> consumers = values::add;\n-    AtomicReference<String> bundleId = new AtomicReference<>(\"0\");\n-    BeamFnDataReadRunner<String> readRunner =\n-        new BeamFnDataReadRunner<>(\n-            INPUT_TRANSFORM_ID,\n-            RemoteGrpcPortRead.readFromPort(PORT_SPEC, \"localOutput\").toPTransform(),\n-            bundleId::get,\n-            COMPONENTS.getCodersMap(),\n-            mockBeamFnDataClient,\n-            consumers);\n-\n-    // Process for bundle id 0\n-    readRunner.registerInputLocation();\n-\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n-\n-    Future<?> future =\n-        executor.submit(\n-            () -> {\n-              // Sleep for some small amount of time simulating the parent blocking\n-              Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-              try {\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"ABC\"));\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"DEF\"));\n-              } catch (Exception e) {\n-                bundle1Future.fail(e);\n-              } finally {\n-                bundle1Future.complete();\n-              }\n-            });\n-\n-    readRunner.blockTillReadFinishes();\n-    future.get();\n-    assertThat(values, contains(valueInGlobalWindow(\"ABC\"), valueInGlobalWindow(\"DEF\")));\n-\n-    // Process for bundle id 1\n-    bundleId.set(\"1\");\n-    values.clear();\n-    readRunner.registerInputLocation();\n-\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n-\n-    future =\n-        executor.submit(\n-            () -> {\n-              // Sleep for some small amount of time simulating the parent blocking\n-              Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-              try {\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"GHI\"));\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"JKL\"));\n-              } catch (Exception e) {\n-                bundle2Future.fail(e);\n-              } finally {\n-                bundle2Future.complete();\n-              }\n-            });\n-\n-    readRunner.blockTillReadFinishes();\n-    future.get();\n-    assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n-\n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n-  }\n+  // Test different cases of chan nel split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitTest {\n+\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // Split as close to the beginning as possible.\n+          .add(new Object[] {channelSplitResult(1L), 16L, ImmutableList.of(\"A\"), 0, 0})\n+          // The closest split is at 4, even when just above or below it.\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.24, 0})\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.25, 0})\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.26, 0})\n+          // Split the *remainder* in half.\n+          .add(new Object[] {channelSplitResult(8L), 16L, ImmutableList.of(\"A\"), 0.5, 0})\n+          .add(new Object[] {channelSplitResult(9L), 16L, ImmutableList.of(\"A\", \"B\", \"C\"), 0.5, 0})\n+          .add(\n+              new Object[] {\n+                channelSplitResult(11L),\n+                16L,\n+                ImmutableList.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"),\n+                0.5,\n+                0\n+              })\n+          // Progress into the active element influences where the split of the remainder falls.\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.25, 0.5})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\"), 0.25, 0.9})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\", \"B\"), 0.25, 0.0})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\", \"B\"), 0.25, 0.1})\n+          .build();\n+    }\n \n-  @Test\n-  public void testRegistration() {\n-    for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n-      if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n-        assertThat(\n-            registrar.getPTransformRunnerFactories(),\n-            IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n-        return;\n-      }\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long inputElements;\n+\n+    @Parameterized.Parameter(2)\n+    public List<String> processedElements;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public double elementProgress;\n+\n+    @Test\n+    public void testChannelSplit() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              inputElements,\n+              processedElements,\n+              fractionOfRemainder,\n+              Collections.EMPTY_LIST));\n     }\n-    fail(\"Expected registrar not found.\");\n   }\n \n-  @Test\n-  public void testSplittingWhenNoElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.5)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n-    readRunner.trySplit(request, responseBuilder);\n+  // Test different cases of channel split with non-empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitWithAllowedSplitPointsTest {", "originalCommit": "e68fe093b7d654148ef0392e8ba4f7c1c127a10d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4ODA3OA==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424188078", "bodyText": "The same to test_sdf_split", "author": "boyuanzz", "createdAt": "2020-05-13T05:54:16Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java", "diffHunk": "@@ -122,334 +129,579 @@\n \n   private static final String INPUT_TRANSFORM_ID = \"1\";\n \n-  @Rule public TestExecutorService executor = TestExecutors.from(Executors::newCachedThreadPool);\n-  @Mock private BeamFnDataClient mockBeamFnDataClient;\n-  @Captor private ArgumentCaptor<FnDataReceiver<WindowedValue<String>>> consumerCaptor;\n-\n-  @Before\n-  public void setUp() {\n-    MockitoAnnotations.initMocks(this);\n-  }\n-\n-  @Test\n-  public void testCreatingAndProcessingBeamFnDataReadRunner() throws Exception {\n-    String bundleId = \"57\";\n+  private static final String PTRANSFORM_ID = \"ptransform_id\";\n \n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n+  // Test basic executions of BeamFnDataReadRunner.\n+  @RunWith(JUnit4.class)\n+  public static class BeamFnDataReadRunnerExecutionTest {\n+    @Rule public TestExecutorService executor = TestExecutors.from(Executors::newCachedThreadPool);\n+    @Mock private BeamFnDataClient mockBeamFnDataClient;\n+    @Captor private ArgumentCaptor<FnDataReceiver<WindowedValue<String>>> consumerCaptor;\n \n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    String localOutputId = \"outputPC\";\n-    String pTransformId = \"pTransformId\";\n-    consumers.register(\n-        localOutputId,\n-        pTransformId,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) outputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    RunnerApi.PTransform pTransform =\n-        RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n-\n-    new BeamFnDataReadRunner.Factory<String>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            mockBeamFnDataClient,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            pTransformId,\n-            pTransform,\n-            Suppliers.ofInstance(bundleId)::get,\n-            ImmutableMap.of(\n-                localOutputId,\n-                RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n-            COMPONENTS.getCodersMap(),\n-            COMPONENTS.getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertThat(teardownFunctions, empty());\n-\n-    verifyZeroInteractions(mockBeamFnDataClient);\n+    @Before\n+    public void setUp() {\n+      MockitoAnnotations.initMocks(this);\n+    }\n \n-    InboundDataClient completionFuture = CompletableFutureInboundDataClient.create();\n-    when(mockBeamFnDataClient.receive(any(), any(), any(), any())).thenReturn(completionFuture);\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId, pTransformId)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n+    @Test\n+    public void testCreatingAndProcessingBeamFnDataReadRunner() throws Exception {\n+      String bundleId = \"57\";\n+\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      String localOutputId = \"outputPC\";\n+      String pTransformId = \"pTransformId\";\n+      consumers.register(\n+          localOutputId,\n+          pTransformId,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) outputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      RunnerApi.PTransform pTransform =\n+          RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n+\n+      new BeamFnDataReadRunner.Factory<String>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              mockBeamFnDataClient,\n+              null /* beamFnStateClient */,\n+              null /* beamFnTimerClient */,\n+              pTransformId,\n+              pTransform,\n+              Suppliers.ofInstance(bundleId)::get,\n+              ImmutableMap.of(\n+                  localOutputId,\n+                  RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n+              COMPONENTS.getCodersMap(),\n+              COMPONENTS.getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertThat(teardownFunctions, empty());\n+\n+      verifyZeroInteractions(mockBeamFnDataClient);\n+\n+      InboundDataClient completionFuture = CompletableFutureInboundDataClient.create();\n+      when(mockBeamFnDataClient.receive(any(), any(), any(), any())).thenReturn(completionFuture);\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId, pTransformId)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      consumerCaptor.getValue().accept(valueInGlobalWindow(\"TestValue\"));\n+      assertThat(outputValues, contains(valueInGlobalWindow(\"TestValue\")));\n+      outputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(localOutputId));\n+\n+      completionFuture.complete();\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-    consumerCaptor.getValue().accept(valueInGlobalWindow(\"TestValue\"));\n-    assertThat(outputValues, contains(valueInGlobalWindow(\"TestValue\")));\n-    outputValues.clear();\n+    @Test\n+    public void testReuseForMultipleBundles() throws Exception {\n+      InboundDataClient bundle1Future = CompletableFutureInboundDataClient.create();\n+      InboundDataClient bundle2Future = CompletableFutureInboundDataClient.create();\n+      when(mockBeamFnDataClient.receive(any(), any(), any(), any()))\n+          .thenReturn(bundle1Future)\n+          .thenReturn(bundle2Future);\n+      List<WindowedValue<String>> values = new ArrayList<>();\n+      FnDataReceiver<WindowedValue<String>> consumers = values::add;\n+      AtomicReference<String> bundleId = new AtomicReference<>(\"0\");\n+      BeamFnDataReadRunner<String> readRunner =\n+          new BeamFnDataReadRunner<>(\n+              INPUT_TRANSFORM_ID,\n+              RemoteGrpcPortRead.readFromPort(PORT_SPEC, \"localOutput\").toPTransform(),\n+              bundleId::get,\n+              COMPONENTS.getCodersMap(),\n+              mockBeamFnDataClient,\n+              consumers);\n+\n+      // Process for bundle id 0\n+      readRunner.registerInputLocation();\n+\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      Future<?> future =\n+          executor.submit(\n+              () -> {\n+                // Sleep for some small amount of time simulating the parent blocking\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+                try {\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"ABC\"));\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"DEF\"));\n+                } catch (Exception e) {\n+                  bundle1Future.fail(e);\n+                } finally {\n+                  bundle1Future.complete();\n+                }\n+              });\n+\n+      readRunner.blockTillReadFinishes();\n+      future.get();\n+      assertThat(values, contains(valueInGlobalWindow(\"ABC\"), valueInGlobalWindow(\"DEF\")));\n+\n+      // Process for bundle id 1\n+      bundleId.set(\"1\");\n+      values.clear();\n+      readRunner.registerInputLocation();\n+\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      future =\n+          executor.submit(\n+              () -> {\n+                // Sleep for some small amount of time simulating the parent blocking\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+                try {\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"GHI\"));\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"JKL\"));\n+                } catch (Exception e) {\n+                  bundle2Future.fail(e);\n+                } finally {\n+                  bundle2Future.complete();\n+                }\n+              });\n+\n+      readRunner.blockTillReadFinishes();\n+      future.get();\n+      assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n+\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-    assertThat(consumers.keySet(), containsInAnyOrder(localOutputId));\n+    @Test\n+    public void testRegistration() {\n+      for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n+        if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n+          assertThat(\n+              registrar.getPTransformRunnerFactories(),\n+              IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n+          return;\n+        }\n+      }\n+      fail(\"Expected registrar not found.\");\n+    }\n \n-    completionFuture.complete();\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+    @Test\n+    public void testSplittingWhenNoElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      // The split should happen at 5 since the allowedSplitPoints is empty.\n+      assertEquals(\n+          channelSplitResult(5),\n+          executeSplit(\n+              readRunner, PTRANSFORM_ID, 10, Collections.EMPTY_LIST, 0.5, Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\")));\n+    }\n \n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n+    @Test\n+    public void testSplittingWhenSomeElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          channelSplitResult(6),\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              10,\n+              ImmutableList.of(\"A\", \"B\"),\n+              0.5,\n+              Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\"),\n+              valueInGlobalWindow(\"F\")));\n+    }\n   }\n \n-  @Test\n-  public void testReuseForMultipleBundles() throws Exception {\n-    InboundDataClient bundle1Future = CompletableFutureInboundDataClient.create();\n-    InboundDataClient bundle2Future = CompletableFutureInboundDataClient.create();\n-    when(mockBeamFnDataClient.receive(any(), any(), any(), any()))\n-        .thenReturn(bundle1Future)\n-        .thenReturn(bundle2Future);\n-    List<WindowedValue<String>> values = new ArrayList<>();\n-    FnDataReceiver<WindowedValue<String>> consumers = values::add;\n-    AtomicReference<String> bundleId = new AtomicReference<>(\"0\");\n-    BeamFnDataReadRunner<String> readRunner =\n-        new BeamFnDataReadRunner<>(\n-            INPUT_TRANSFORM_ID,\n-            RemoteGrpcPortRead.readFromPort(PORT_SPEC, \"localOutput\").toPTransform(),\n-            bundleId::get,\n-            COMPONENTS.getCodersMap(),\n-            mockBeamFnDataClient,\n-            consumers);\n-\n-    // Process for bundle id 0\n-    readRunner.registerInputLocation();\n-\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n-\n-    Future<?> future =\n-        executor.submit(\n-            () -> {\n-              // Sleep for some small amount of time simulating the parent blocking\n-              Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-              try {\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"ABC\"));\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"DEF\"));\n-              } catch (Exception e) {\n-                bundle1Future.fail(e);\n-              } finally {\n-                bundle1Future.complete();\n-              }\n-            });\n-\n-    readRunner.blockTillReadFinishes();\n-    future.get();\n-    assertThat(values, contains(valueInGlobalWindow(\"ABC\"), valueInGlobalWindow(\"DEF\")));\n-\n-    // Process for bundle id 1\n-    bundleId.set(\"1\");\n-    values.clear();\n-    readRunner.registerInputLocation();\n-\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n-\n-    future =\n-        executor.submit(\n-            () -> {\n-              // Sleep for some small amount of time simulating the parent blocking\n-              Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-              try {\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"GHI\"));\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"JKL\"));\n-              } catch (Exception e) {\n-                bundle2Future.fail(e);\n-              } finally {\n-                bundle2Future.complete();\n-              }\n-            });\n-\n-    readRunner.blockTillReadFinishes();\n-    future.get();\n-    assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n-\n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n-  }\n+  // Test different cases of chan nel split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitTest {\n+\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // Split as close to the beginning as possible.\n+          .add(new Object[] {channelSplitResult(1L), 16L, ImmutableList.of(\"A\"), 0, 0})\n+          // The closest split is at 4, even when just above or below it.\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.24, 0})\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.25, 0})\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.26, 0})\n+          // Split the *remainder* in half.\n+          .add(new Object[] {channelSplitResult(8L), 16L, ImmutableList.of(\"A\"), 0.5, 0})\n+          .add(new Object[] {channelSplitResult(9L), 16L, ImmutableList.of(\"A\", \"B\", \"C\"), 0.5, 0})\n+          .add(\n+              new Object[] {\n+                channelSplitResult(11L),\n+                16L,\n+                ImmutableList.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"),\n+                0.5,\n+                0\n+              })\n+          // Progress into the active element influences where the split of the remainder falls.\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.25, 0.5})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\"), 0.25, 0.9})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\", \"B\"), 0.25, 0.0})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\", \"B\"), 0.25, 0.1})\n+          .build();\n+    }\n \n-  @Test\n-  public void testRegistration() {\n-    for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n-      if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n-        assertThat(\n-            registrar.getPTransformRunnerFactories(),\n-            IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n-        return;\n-      }\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long inputElements;\n+\n+    @Parameterized.Parameter(2)\n+    public List<String> processedElements;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public double elementProgress;\n+\n+    @Test\n+    public void testChannelSplit() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              inputElements,\n+              processedElements,\n+              fractionOfRemainder,\n+              Collections.EMPTY_LIST));\n     }\n-    fail(\"Expected registrar not found.\");\n   }\n \n-  @Test\n-  public void testSplittingWhenNoElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.5)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n-    readRunner.trySplit(request, responseBuilder);\n+  // Test different cases of channel split with non-empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitWithAllowedSplitPointsTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // The desired split point is at 4.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(4L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(2L, 3L, 4L, 5L)\n+              })\n+          // If we can't split at 4, choose the closest possible split point.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(5L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(2L, 3L, 5L)\n+              })\n+          .add(\n+              new Object[] {\n+                channelSplitResult(3L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(2L, 3L, 6L)\n+              })\n+          // Also test the case where all possible split points lie above or below the desired split\n+          // point.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(5L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(5L, 6L, 7L)\n+              })\n+          .add(\n+              new Object[] {\n+                channelSplitResult(3L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(1L, 2L, 3L)\n+              })\n+          // We have progressed beyond all possible split points, so can't split.\n+          .add(\n+              new Object[] {\n+                ProcessBundleSplitResponse.getDefaultInstance(),\n+                16L,\n+                ImmutableList.of(\"A\", \"B\", \"C\", \"D\", \"F\", \"G\"),\n+                0.25,\n+                ImmutableList.of(1L, 2L, 3L)\n+              })\n+          .build();\n+    }\n \n-    ProcessBundleSplitResponse expected =\n-        ProcessBundleSplitResponse.newBuilder()\n-            .addChannelSplits(\n-                ChannelSplit.newBuilder()\n-                    .setLastPrimaryElement(4)\n-                    .setFirstResidualElement(5)\n-                    .build())\n-            .build();\n-    assertEquals(expected, responseBuilder.build());\n-\n-    // Ensure that we process the correct number of elements after splitting.\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n-    assertThat(\n-        outputValues,\n-        contains(\n-            valueInGlobalWindow(\"A\"),\n-            valueInGlobalWindow(\"B\"),\n-            valueInGlobalWindow(\"C\"),\n-            valueInGlobalWindow(\"D\"),\n-            valueInGlobalWindow(\"E\")));\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long inputElements;\n+\n+    @Parameterized.Parameter(2)\n+    public List<String> processedElements;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public List<Long> allowedSplitPoints;\n+\n+    @Test\n+    public void testChannelSplittingWithAllowedSplitPoints() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              inputElements,\n+              processedElements,\n+              fractionOfRemainder,\n+              allowedSplitPoints));\n+    }\n   }\n \n-  @Test\n-  public void testSplittingWhenSomeElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.5)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n-\n-    // Process 2 elements then split\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.trySplit(request, responseBuilder);\n+  // Test different cases of element split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ElementSplitTest {", "originalCommit": "e68fe093b7d654148ef0392e8ba4f7c1c127a10d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDE4ODIyMQ==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424188221", "bodyText": "The same to test_sdf_split_with_allowed_splits", "author": "boyuanzz", "createdAt": "2020-05-13T05:54:47Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java", "diffHunk": "@@ -122,334 +129,579 @@\n \n   private static final String INPUT_TRANSFORM_ID = \"1\";\n \n-  @Rule public TestExecutorService executor = TestExecutors.from(Executors::newCachedThreadPool);\n-  @Mock private BeamFnDataClient mockBeamFnDataClient;\n-  @Captor private ArgumentCaptor<FnDataReceiver<WindowedValue<String>>> consumerCaptor;\n-\n-  @Before\n-  public void setUp() {\n-    MockitoAnnotations.initMocks(this);\n-  }\n-\n-  @Test\n-  public void testCreatingAndProcessingBeamFnDataReadRunner() throws Exception {\n-    String bundleId = \"57\";\n+  private static final String PTRANSFORM_ID = \"ptransform_id\";\n \n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n+  // Test basic executions of BeamFnDataReadRunner.\n+  @RunWith(JUnit4.class)\n+  public static class BeamFnDataReadRunnerExecutionTest {\n+    @Rule public TestExecutorService executor = TestExecutors.from(Executors::newCachedThreadPool);\n+    @Mock private BeamFnDataClient mockBeamFnDataClient;\n+    @Captor private ArgumentCaptor<FnDataReceiver<WindowedValue<String>>> consumerCaptor;\n \n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    String localOutputId = \"outputPC\";\n-    String pTransformId = \"pTransformId\";\n-    consumers.register(\n-        localOutputId,\n-        pTransformId,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) outputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    RunnerApi.PTransform pTransform =\n-        RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n-\n-    new BeamFnDataReadRunner.Factory<String>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            mockBeamFnDataClient,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            pTransformId,\n-            pTransform,\n-            Suppliers.ofInstance(bundleId)::get,\n-            ImmutableMap.of(\n-                localOutputId,\n-                RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n-            COMPONENTS.getCodersMap(),\n-            COMPONENTS.getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertThat(teardownFunctions, empty());\n-\n-    verifyZeroInteractions(mockBeamFnDataClient);\n+    @Before\n+    public void setUp() {\n+      MockitoAnnotations.initMocks(this);\n+    }\n \n-    InboundDataClient completionFuture = CompletableFutureInboundDataClient.create();\n-    when(mockBeamFnDataClient.receive(any(), any(), any(), any())).thenReturn(completionFuture);\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId, pTransformId)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n+    @Test\n+    public void testCreatingAndProcessingBeamFnDataReadRunner() throws Exception {\n+      String bundleId = \"57\";\n+\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      String localOutputId = \"outputPC\";\n+      String pTransformId = \"pTransformId\";\n+      consumers.register(\n+          localOutputId,\n+          pTransformId,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) outputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      RunnerApi.PTransform pTransform =\n+          RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n+\n+      new BeamFnDataReadRunner.Factory<String>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              mockBeamFnDataClient,\n+              null /* beamFnStateClient */,\n+              null /* beamFnTimerClient */,\n+              pTransformId,\n+              pTransform,\n+              Suppliers.ofInstance(bundleId)::get,\n+              ImmutableMap.of(\n+                  localOutputId,\n+                  RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n+              COMPONENTS.getCodersMap(),\n+              COMPONENTS.getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertThat(teardownFunctions, empty());\n+\n+      verifyZeroInteractions(mockBeamFnDataClient);\n+\n+      InboundDataClient completionFuture = CompletableFutureInboundDataClient.create();\n+      when(mockBeamFnDataClient.receive(any(), any(), any(), any())).thenReturn(completionFuture);\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId, pTransformId)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      consumerCaptor.getValue().accept(valueInGlobalWindow(\"TestValue\"));\n+      assertThat(outputValues, contains(valueInGlobalWindow(\"TestValue\")));\n+      outputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(localOutputId));\n+\n+      completionFuture.complete();\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-    consumerCaptor.getValue().accept(valueInGlobalWindow(\"TestValue\"));\n-    assertThat(outputValues, contains(valueInGlobalWindow(\"TestValue\")));\n-    outputValues.clear();\n+    @Test\n+    public void testReuseForMultipleBundles() throws Exception {\n+      InboundDataClient bundle1Future = CompletableFutureInboundDataClient.create();\n+      InboundDataClient bundle2Future = CompletableFutureInboundDataClient.create();\n+      when(mockBeamFnDataClient.receive(any(), any(), any(), any()))\n+          .thenReturn(bundle1Future)\n+          .thenReturn(bundle2Future);\n+      List<WindowedValue<String>> values = new ArrayList<>();\n+      FnDataReceiver<WindowedValue<String>> consumers = values::add;\n+      AtomicReference<String> bundleId = new AtomicReference<>(\"0\");\n+      BeamFnDataReadRunner<String> readRunner =\n+          new BeamFnDataReadRunner<>(\n+              INPUT_TRANSFORM_ID,\n+              RemoteGrpcPortRead.readFromPort(PORT_SPEC, \"localOutput\").toPTransform(),\n+              bundleId::get,\n+              COMPONENTS.getCodersMap(),\n+              mockBeamFnDataClient,\n+              consumers);\n+\n+      // Process for bundle id 0\n+      readRunner.registerInputLocation();\n+\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      Future<?> future =\n+          executor.submit(\n+              () -> {\n+                // Sleep for some small amount of time simulating the parent blocking\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+                try {\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"ABC\"));\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"DEF\"));\n+                } catch (Exception e) {\n+                  bundle1Future.fail(e);\n+                } finally {\n+                  bundle1Future.complete();\n+                }\n+              });\n+\n+      readRunner.blockTillReadFinishes();\n+      future.get();\n+      assertThat(values, contains(valueInGlobalWindow(\"ABC\"), valueInGlobalWindow(\"DEF\")));\n+\n+      // Process for bundle id 1\n+      bundleId.set(\"1\");\n+      values.clear();\n+      readRunner.registerInputLocation();\n+\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      future =\n+          executor.submit(\n+              () -> {\n+                // Sleep for some small amount of time simulating the parent blocking\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+                try {\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"GHI\"));\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"JKL\"));\n+                } catch (Exception e) {\n+                  bundle2Future.fail(e);\n+                } finally {\n+                  bundle2Future.complete();\n+                }\n+              });\n+\n+      readRunner.blockTillReadFinishes();\n+      future.get();\n+      assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n+\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-    assertThat(consumers.keySet(), containsInAnyOrder(localOutputId));\n+    @Test\n+    public void testRegistration() {\n+      for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n+        if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n+          assertThat(\n+              registrar.getPTransformRunnerFactories(),\n+              IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n+          return;\n+        }\n+      }\n+      fail(\"Expected registrar not found.\");\n+    }\n \n-    completionFuture.complete();\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+    @Test\n+    public void testSplittingWhenNoElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      // The split should happen at 5 since the allowedSplitPoints is empty.\n+      assertEquals(\n+          channelSplitResult(5),\n+          executeSplit(\n+              readRunner, PTRANSFORM_ID, 10, Collections.EMPTY_LIST, 0.5, Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\")));\n+    }\n \n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n+    @Test\n+    public void testSplittingWhenSomeElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          channelSplitResult(6),\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              10,\n+              ImmutableList.of(\"A\", \"B\"),\n+              0.5,\n+              Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\"),\n+              valueInGlobalWindow(\"F\")));\n+    }\n   }\n \n-  @Test\n-  public void testReuseForMultipleBundles() throws Exception {\n-    InboundDataClient bundle1Future = CompletableFutureInboundDataClient.create();\n-    InboundDataClient bundle2Future = CompletableFutureInboundDataClient.create();\n-    when(mockBeamFnDataClient.receive(any(), any(), any(), any()))\n-        .thenReturn(bundle1Future)\n-        .thenReturn(bundle2Future);\n-    List<WindowedValue<String>> values = new ArrayList<>();\n-    FnDataReceiver<WindowedValue<String>> consumers = values::add;\n-    AtomicReference<String> bundleId = new AtomicReference<>(\"0\");\n-    BeamFnDataReadRunner<String> readRunner =\n-        new BeamFnDataReadRunner<>(\n-            INPUT_TRANSFORM_ID,\n-            RemoteGrpcPortRead.readFromPort(PORT_SPEC, \"localOutput\").toPTransform(),\n-            bundleId::get,\n-            COMPONENTS.getCodersMap(),\n-            mockBeamFnDataClient,\n-            consumers);\n-\n-    // Process for bundle id 0\n-    readRunner.registerInputLocation();\n-\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n-\n-    Future<?> future =\n-        executor.submit(\n-            () -> {\n-              // Sleep for some small amount of time simulating the parent blocking\n-              Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-              try {\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"ABC\"));\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"DEF\"));\n-              } catch (Exception e) {\n-                bundle1Future.fail(e);\n-              } finally {\n-                bundle1Future.complete();\n-              }\n-            });\n-\n-    readRunner.blockTillReadFinishes();\n-    future.get();\n-    assertThat(values, contains(valueInGlobalWindow(\"ABC\"), valueInGlobalWindow(\"DEF\")));\n-\n-    // Process for bundle id 1\n-    bundleId.set(\"1\");\n-    values.clear();\n-    readRunner.registerInputLocation();\n-\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n-\n-    future =\n-        executor.submit(\n-            () -> {\n-              // Sleep for some small amount of time simulating the parent blocking\n-              Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-              try {\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"GHI\"));\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"JKL\"));\n-              } catch (Exception e) {\n-                bundle2Future.fail(e);\n-              } finally {\n-                bundle2Future.complete();\n-              }\n-            });\n-\n-    readRunner.blockTillReadFinishes();\n-    future.get();\n-    assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n-\n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n-  }\n+  // Test different cases of chan nel split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitTest {\n+\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // Split as close to the beginning as possible.\n+          .add(new Object[] {channelSplitResult(1L), 16L, ImmutableList.of(\"A\"), 0, 0})\n+          // The closest split is at 4, even when just above or below it.\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.24, 0})\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.25, 0})\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.26, 0})\n+          // Split the *remainder* in half.\n+          .add(new Object[] {channelSplitResult(8L), 16L, ImmutableList.of(\"A\"), 0.5, 0})\n+          .add(new Object[] {channelSplitResult(9L), 16L, ImmutableList.of(\"A\", \"B\", \"C\"), 0.5, 0})\n+          .add(\n+              new Object[] {\n+                channelSplitResult(11L),\n+                16L,\n+                ImmutableList.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"),\n+                0.5,\n+                0\n+              })\n+          // Progress into the active element influences where the split of the remainder falls.\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.25, 0.5})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\"), 0.25, 0.9})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\", \"B\"), 0.25, 0.0})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\", \"B\"), 0.25, 0.1})\n+          .build();\n+    }\n \n-  @Test\n-  public void testRegistration() {\n-    for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n-      if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n-        assertThat(\n-            registrar.getPTransformRunnerFactories(),\n-            IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n-        return;\n-      }\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long inputElements;\n+\n+    @Parameterized.Parameter(2)\n+    public List<String> processedElements;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public double elementProgress;\n+\n+    @Test\n+    public void testChannelSplit() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              inputElements,\n+              processedElements,\n+              fractionOfRemainder,\n+              Collections.EMPTY_LIST));\n     }\n-    fail(\"Expected registrar not found.\");\n   }\n \n-  @Test\n-  public void testSplittingWhenNoElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.5)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n-    readRunner.trySplit(request, responseBuilder);\n+  // Test different cases of channel split with non-empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitWithAllowedSplitPointsTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // The desired split point is at 4.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(4L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(2L, 3L, 4L, 5L)\n+              })\n+          // If we can't split at 4, choose the closest possible split point.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(5L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(2L, 3L, 5L)\n+              })\n+          .add(\n+              new Object[] {\n+                channelSplitResult(3L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(2L, 3L, 6L)\n+              })\n+          // Also test the case where all possible split points lie above or below the desired split\n+          // point.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(5L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(5L, 6L, 7L)\n+              })\n+          .add(\n+              new Object[] {\n+                channelSplitResult(3L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(1L, 2L, 3L)\n+              })\n+          // We have progressed beyond all possible split points, so can't split.\n+          .add(\n+              new Object[] {\n+                ProcessBundleSplitResponse.getDefaultInstance(),\n+                16L,\n+                ImmutableList.of(\"A\", \"B\", \"C\", \"D\", \"F\", \"G\"),\n+                0.25,\n+                ImmutableList.of(1L, 2L, 3L)\n+              })\n+          .build();\n+    }\n \n-    ProcessBundleSplitResponse expected =\n-        ProcessBundleSplitResponse.newBuilder()\n-            .addChannelSplits(\n-                ChannelSplit.newBuilder()\n-                    .setLastPrimaryElement(4)\n-                    .setFirstResidualElement(5)\n-                    .build())\n-            .build();\n-    assertEquals(expected, responseBuilder.build());\n-\n-    // Ensure that we process the correct number of elements after splitting.\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n-    assertThat(\n-        outputValues,\n-        contains(\n-            valueInGlobalWindow(\"A\"),\n-            valueInGlobalWindow(\"B\"),\n-            valueInGlobalWindow(\"C\"),\n-            valueInGlobalWindow(\"D\"),\n-            valueInGlobalWindow(\"E\")));\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long inputElements;\n+\n+    @Parameterized.Parameter(2)\n+    public List<String> processedElements;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public List<Long> allowedSplitPoints;\n+\n+    @Test\n+    public void testChannelSplittingWithAllowedSplitPoints() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              inputElements,\n+              processedElements,\n+              fractionOfRemainder,\n+              allowedSplitPoints));\n+    }\n   }\n \n-  @Test\n-  public void testSplittingWhenSomeElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.5)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n-\n-    // Process 2 elements then split\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.trySplit(request, responseBuilder);\n+  // Test different cases of element split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ElementSplitTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // Split between future elements at element boundaries.\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\"), 0.51, 0})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\"), 0.49, 0})\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.26, 0})\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.25, 0})\n+          // If the split falls inside the first, splittable element, split there.\n+          .add(new Object[] {elementSplitResult(0L), 4L, ImmutableList.of(\"A\"), 0.2, 0})\n+          // The choice of split depends on the progress into the first element.\n+          .add(new Object[] {elementSplitResult(0L), 4L, ImmutableList.of(\"A\"), 0.125, 0})\n+          // Here we are far enough into the first element that splitting at 0.2 of the remainder\n+          // falls outside the first element.\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.2, 0.5})\n+          // Verify the above logic when we are partially through the stream.\n+          .add(new Object[] {channelSplitResult(3L), 4L, ImmutableList.of(\"A\", \"B\", \"C\"), 0.6, 0})\n+          .add(new Object[] {channelSplitResult(4L), 4L, ImmutableList.of(\"A\", \"B\", \"C\"), 0.6, 0.9})\n+          .add(new Object[] {elementSplitResult(2L), 4L, ImmutableList.of(\"A\", \"B\", \"C\"), 0.2, 0.5})\n+          .build();\n+    }\n \n-    ProcessBundleSplitResponse expected =\n-        ProcessBundleSplitResponse.newBuilder()\n-            .addChannelSplits(\n-                ChannelSplit.newBuilder()\n-                    .setLastPrimaryElement(5)\n-                    .setFirstResidualElement(6)\n-                    .build())\n-            .build();\n-    assertEquals(expected, responseBuilder.build());\n-\n-    // Ensure that we process the correct number of elements after splitting.\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n-    assertThat(\n-        outputValues,\n-        contains(\n-            valueInGlobalWindow(\"A\"),\n-            valueInGlobalWindow(\"B\"),\n-            valueInGlobalWindow(\"C\"),\n-            valueInGlobalWindow(\"D\"),\n-            valueInGlobalWindow(\"E\"),\n-            valueInGlobalWindow(\"F\")));\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long inputElements;\n+\n+    @Parameterized.Parameter(2)\n+    public List<String> processedElements;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public double elementProgress;\n+\n+    @Test\n+    public void testElementSplit() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      when(splittingReceiver.trySplit(anyDouble())).thenReturn(mockSplitResult);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              inputElements,\n+              processedElements,\n+              fractionOfRemainder,\n+              Collections.EMPTY_LIST));\n+    }\n   }\n \n-  @Test\n-  public void testSplittingDownstreamReceiver() throws Exception {\n-    SplitResult splitResult =\n-        SplitResult.of(\n-            BundleApplication.newBuilder().setInputId(\"primary\").build(),\n-            DelayedBundleApplication.newBuilder()\n-                .setApplication(BundleApplication.newBuilder().setInputId(\"residual\").build())\n-                .build());\n-    SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n-    when(splittingReceiver.getProgress()).thenReturn(0.3);\n-    when(splittingReceiver.trySplit(anyDouble())).thenReturn(splitResult);\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.05)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n-\n-    // We will be \"processing\" the 'C' element, aka 2nd index\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.trySplit(request, responseBuilder);\n+  // Test different cases of element split with non-empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ElementSplitWithAllowedSplitPointsTest {", "originalCommit": "e68fe093b7d654148ef0392e8ba4f7c1c127a10d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ5MTM3Mw==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424491373", "bodyText": "nit: mockSplitResult -> TEST_SPLIT_RESULT\nmock in a variable name usually means that it isn't a real instance of something.", "author": "lukecwik", "createdAt": "2020-05-13T14:39:55Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java", "diffHunk": "@@ -103,6 +104,12 @@\n           .setApiServiceDescriptor(Endpoints.ApiServiceDescriptor.getDefaultInstance())\n           .setCoderId(CODER_SPEC_ID)\n           .build();\n+  private static final SplitResult mockSplitResult =", "originalCommit": "e68fe093b7d654148ef0392e8ba4f7c1c127a10d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ5MzgwMA==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424493800", "bodyText": "This should be @RunWith(Enclosed.class) to prevent an issue from junit not detecting inner classes for test execution.", "author": "lukecwik", "createdAt": "2020-05-13T14:42:57Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java", "diffHunk": "@@ -82,15 +84,14 @@\n import org.junit.Test;\n import org.junit.runner.RunWith;\n import org.junit.runners.JUnit4;\n+import org.junit.runners.Parameterized;\n import org.mockito.ArgumentCaptor;\n import org.mockito.Captor;\n import org.mockito.Mock;\n import org.mockito.MockitoAnnotations;\n \n /** Tests for {@link BeamFnDataReadRunner}. */\n-@RunWith(JUnit4.class)", "originalCommit": "e68fe093b7d654148ef0392e8ba4f7c1c127a10d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDQ5OTA3Mg==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424499072", "bodyText": "It would be nice if the fraction did make it through into the split result allowing us to validate correctly computing the fraction.", "author": "lukecwik", "createdAt": "2020-05-13T14:49:44Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java", "diffHunk": "@@ -122,334 +129,579 @@\n \n   private static final String INPUT_TRANSFORM_ID = \"1\";\n \n-  @Rule public TestExecutorService executor = TestExecutors.from(Executors::newCachedThreadPool);\n-  @Mock private BeamFnDataClient mockBeamFnDataClient;\n-  @Captor private ArgumentCaptor<FnDataReceiver<WindowedValue<String>>> consumerCaptor;\n-\n-  @Before\n-  public void setUp() {\n-    MockitoAnnotations.initMocks(this);\n-  }\n-\n-  @Test\n-  public void testCreatingAndProcessingBeamFnDataReadRunner() throws Exception {\n-    String bundleId = \"57\";\n+  private static final String PTRANSFORM_ID = \"ptransform_id\";\n \n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n+  // Test basic executions of BeamFnDataReadRunner.\n+  @RunWith(JUnit4.class)\n+  public static class BeamFnDataReadRunnerExecutionTest {\n+    @Rule public TestExecutorService executor = TestExecutors.from(Executors::newCachedThreadPool);\n+    @Mock private BeamFnDataClient mockBeamFnDataClient;\n+    @Captor private ArgumentCaptor<FnDataReceiver<WindowedValue<String>>> consumerCaptor;\n \n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    String localOutputId = \"outputPC\";\n-    String pTransformId = \"pTransformId\";\n-    consumers.register(\n-        localOutputId,\n-        pTransformId,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) outputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    RunnerApi.PTransform pTransform =\n-        RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n-\n-    new BeamFnDataReadRunner.Factory<String>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            mockBeamFnDataClient,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            pTransformId,\n-            pTransform,\n-            Suppliers.ofInstance(bundleId)::get,\n-            ImmutableMap.of(\n-                localOutputId,\n-                RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n-            COMPONENTS.getCodersMap(),\n-            COMPONENTS.getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertThat(teardownFunctions, empty());\n-\n-    verifyZeroInteractions(mockBeamFnDataClient);\n+    @Before\n+    public void setUp() {\n+      MockitoAnnotations.initMocks(this);\n+    }\n \n-    InboundDataClient completionFuture = CompletableFutureInboundDataClient.create();\n-    when(mockBeamFnDataClient.receive(any(), any(), any(), any())).thenReturn(completionFuture);\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId, pTransformId)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n+    @Test\n+    public void testCreatingAndProcessingBeamFnDataReadRunner() throws Exception {\n+      String bundleId = \"57\";\n+\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      String localOutputId = \"outputPC\";\n+      String pTransformId = \"pTransformId\";\n+      consumers.register(\n+          localOutputId,\n+          pTransformId,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) outputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      RunnerApi.PTransform pTransform =\n+          RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n+\n+      new BeamFnDataReadRunner.Factory<String>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              mockBeamFnDataClient,\n+              null /* beamFnStateClient */,\n+              null /* beamFnTimerClient */,\n+              pTransformId,\n+              pTransform,\n+              Suppliers.ofInstance(bundleId)::get,\n+              ImmutableMap.of(\n+                  localOutputId,\n+                  RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n+              COMPONENTS.getCodersMap(),\n+              COMPONENTS.getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertThat(teardownFunctions, empty());\n+\n+      verifyZeroInteractions(mockBeamFnDataClient);\n+\n+      InboundDataClient completionFuture = CompletableFutureInboundDataClient.create();\n+      when(mockBeamFnDataClient.receive(any(), any(), any(), any())).thenReturn(completionFuture);\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId, pTransformId)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      consumerCaptor.getValue().accept(valueInGlobalWindow(\"TestValue\"));\n+      assertThat(outputValues, contains(valueInGlobalWindow(\"TestValue\")));\n+      outputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(localOutputId));\n+\n+      completionFuture.complete();\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-    consumerCaptor.getValue().accept(valueInGlobalWindow(\"TestValue\"));\n-    assertThat(outputValues, contains(valueInGlobalWindow(\"TestValue\")));\n-    outputValues.clear();\n+    @Test\n+    public void testReuseForMultipleBundles() throws Exception {\n+      InboundDataClient bundle1Future = CompletableFutureInboundDataClient.create();\n+      InboundDataClient bundle2Future = CompletableFutureInboundDataClient.create();\n+      when(mockBeamFnDataClient.receive(any(), any(), any(), any()))\n+          .thenReturn(bundle1Future)\n+          .thenReturn(bundle2Future);\n+      List<WindowedValue<String>> values = new ArrayList<>();\n+      FnDataReceiver<WindowedValue<String>> consumers = values::add;\n+      AtomicReference<String> bundleId = new AtomicReference<>(\"0\");\n+      BeamFnDataReadRunner<String> readRunner =\n+          new BeamFnDataReadRunner<>(\n+              INPUT_TRANSFORM_ID,\n+              RemoteGrpcPortRead.readFromPort(PORT_SPEC, \"localOutput\").toPTransform(),\n+              bundleId::get,\n+              COMPONENTS.getCodersMap(),\n+              mockBeamFnDataClient,\n+              consumers);\n+\n+      // Process for bundle id 0\n+      readRunner.registerInputLocation();\n+\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      Future<?> future =\n+          executor.submit(\n+              () -> {\n+                // Sleep for some small amount of time simulating the parent blocking\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+                try {\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"ABC\"));\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"DEF\"));\n+                } catch (Exception e) {\n+                  bundle1Future.fail(e);\n+                } finally {\n+                  bundle1Future.complete();\n+                }\n+              });\n+\n+      readRunner.blockTillReadFinishes();\n+      future.get();\n+      assertThat(values, contains(valueInGlobalWindow(\"ABC\"), valueInGlobalWindow(\"DEF\")));\n+\n+      // Process for bundle id 1\n+      bundleId.set(\"1\");\n+      values.clear();\n+      readRunner.registerInputLocation();\n+\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      future =\n+          executor.submit(\n+              () -> {\n+                // Sleep for some small amount of time simulating the parent blocking\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+                try {\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"GHI\"));\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"JKL\"));\n+                } catch (Exception e) {\n+                  bundle2Future.fail(e);\n+                } finally {\n+                  bundle2Future.complete();\n+                }\n+              });\n+\n+      readRunner.blockTillReadFinishes();\n+      future.get();\n+      assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n+\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-    assertThat(consumers.keySet(), containsInAnyOrder(localOutputId));\n+    @Test\n+    public void testRegistration() {\n+      for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n+        if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n+          assertThat(\n+              registrar.getPTransformRunnerFactories(),\n+              IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n+          return;\n+        }\n+      }\n+      fail(\"Expected registrar not found.\");\n+    }\n \n-    completionFuture.complete();\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+    @Test\n+    public void testSplittingWhenNoElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      // The split should happen at 5 since the allowedSplitPoints is empty.\n+      assertEquals(\n+          channelSplitResult(5),\n+          executeSplit(\n+              readRunner, PTRANSFORM_ID, 10, Collections.EMPTY_LIST, 0.5, Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\")));\n+    }\n \n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n+    @Test\n+    public void testSplittingWhenSomeElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          channelSplitResult(6),\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              10,\n+              ImmutableList.of(\"A\", \"B\"),\n+              0.5,\n+              Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\"),\n+              valueInGlobalWindow(\"F\")));\n+    }\n   }\n \n-  @Test\n-  public void testReuseForMultipleBundles() throws Exception {\n-    InboundDataClient bundle1Future = CompletableFutureInboundDataClient.create();\n-    InboundDataClient bundle2Future = CompletableFutureInboundDataClient.create();\n-    when(mockBeamFnDataClient.receive(any(), any(), any(), any()))\n-        .thenReturn(bundle1Future)\n-        .thenReturn(bundle2Future);\n-    List<WindowedValue<String>> values = new ArrayList<>();\n-    FnDataReceiver<WindowedValue<String>> consumers = values::add;\n-    AtomicReference<String> bundleId = new AtomicReference<>(\"0\");\n-    BeamFnDataReadRunner<String> readRunner =\n-        new BeamFnDataReadRunner<>(\n-            INPUT_TRANSFORM_ID,\n-            RemoteGrpcPortRead.readFromPort(PORT_SPEC, \"localOutput\").toPTransform(),\n-            bundleId::get,\n-            COMPONENTS.getCodersMap(),\n-            mockBeamFnDataClient,\n-            consumers);\n-\n-    // Process for bundle id 0\n-    readRunner.registerInputLocation();\n-\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n-\n-    Future<?> future =\n-        executor.submit(\n-            () -> {\n-              // Sleep for some small amount of time simulating the parent blocking\n-              Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-              try {\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"ABC\"));\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"DEF\"));\n-              } catch (Exception e) {\n-                bundle1Future.fail(e);\n-              } finally {\n-                bundle1Future.complete();\n-              }\n-            });\n-\n-    readRunner.blockTillReadFinishes();\n-    future.get();\n-    assertThat(values, contains(valueInGlobalWindow(\"ABC\"), valueInGlobalWindow(\"DEF\")));\n-\n-    // Process for bundle id 1\n-    bundleId.set(\"1\");\n-    values.clear();\n-    readRunner.registerInputLocation();\n-\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n-\n-    future =\n-        executor.submit(\n-            () -> {\n-              // Sleep for some small amount of time simulating the parent blocking\n-              Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-              try {\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"GHI\"));\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"JKL\"));\n-              } catch (Exception e) {\n-                bundle2Future.fail(e);\n-              } finally {\n-                bundle2Future.complete();\n-              }\n-            });\n-\n-    readRunner.blockTillReadFinishes();\n-    future.get();\n-    assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n-\n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n-  }\n+  // Test different cases of chan nel split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitTest {\n+\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // Split as close to the beginning as possible.\n+          .add(new Object[] {channelSplitResult(1L), 16L, ImmutableList.of(\"A\"), 0, 0})\n+          // The closest split is at 4, even when just above or below it.\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.24, 0})\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.25, 0})\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.26, 0})\n+          // Split the *remainder* in half.\n+          .add(new Object[] {channelSplitResult(8L), 16L, ImmutableList.of(\"A\"), 0.5, 0})\n+          .add(new Object[] {channelSplitResult(9L), 16L, ImmutableList.of(\"A\", \"B\", \"C\"), 0.5, 0})\n+          .add(\n+              new Object[] {\n+                channelSplitResult(11L),\n+                16L,\n+                ImmutableList.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"),\n+                0.5,\n+                0\n+              })\n+          // Progress into the active element influences where the split of the remainder falls.\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.25, 0.5})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\"), 0.25, 0.9})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\", \"B\"), 0.25, 0.0})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\", \"B\"), 0.25, 0.1})\n+          .build();\n+    }\n \n-  @Test\n-  public void testRegistration() {\n-    for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n-      if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n-        assertThat(\n-            registrar.getPTransformRunnerFactories(),\n-            IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n-        return;\n-      }\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long inputElements;\n+\n+    @Parameterized.Parameter(2)\n+    public List<String> processedElements;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public double elementProgress;\n+\n+    @Test\n+    public void testChannelSplit() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              inputElements,\n+              processedElements,\n+              fractionOfRemainder,\n+              Collections.EMPTY_LIST));\n     }\n-    fail(\"Expected registrar not found.\");\n   }\n \n-  @Test\n-  public void testSplittingWhenNoElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.5)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n-    readRunner.trySplit(request, responseBuilder);\n+  // Test different cases of channel split with non-empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitWithAllowedSplitPointsTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // The desired split point is at 4.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(4L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(2L, 3L, 4L, 5L)\n+              })\n+          // If we can't split at 4, choose the closest possible split point.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(5L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(2L, 3L, 5L)\n+              })\n+          .add(\n+              new Object[] {\n+                channelSplitResult(3L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(2L, 3L, 6L)\n+              })\n+          // Also test the case where all possible split points lie above or below the desired split\n+          // point.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(5L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(5L, 6L, 7L)\n+              })\n+          .add(\n+              new Object[] {\n+                channelSplitResult(3L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(1L, 2L, 3L)\n+              })\n+          // We have progressed beyond all possible split points, so can't split.\n+          .add(\n+              new Object[] {\n+                ProcessBundleSplitResponse.getDefaultInstance(),\n+                16L,\n+                ImmutableList.of(\"A\", \"B\", \"C\", \"D\", \"F\", \"G\"),\n+                0.25,\n+                ImmutableList.of(1L, 2L, 3L)\n+              })\n+          .build();\n+    }\n \n-    ProcessBundleSplitResponse expected =\n-        ProcessBundleSplitResponse.newBuilder()\n-            .addChannelSplits(\n-                ChannelSplit.newBuilder()\n-                    .setLastPrimaryElement(4)\n-                    .setFirstResidualElement(5)\n-                    .build())\n-            .build();\n-    assertEquals(expected, responseBuilder.build());\n-\n-    // Ensure that we process the correct number of elements after splitting.\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n-    assertThat(\n-        outputValues,\n-        contains(\n-            valueInGlobalWindow(\"A\"),\n-            valueInGlobalWindow(\"B\"),\n-            valueInGlobalWindow(\"C\"),\n-            valueInGlobalWindow(\"D\"),\n-            valueInGlobalWindow(\"E\")));\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long inputElements;\n+\n+    @Parameterized.Parameter(2)\n+    public List<String> processedElements;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public List<Long> allowedSplitPoints;\n+\n+    @Test\n+    public void testChannelSplittingWithAllowedSplitPoints() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              inputElements,\n+              processedElements,\n+              fractionOfRemainder,\n+              allowedSplitPoints));\n+    }\n   }\n \n-  @Test\n-  public void testSplittingWhenSomeElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.5)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n-\n-    // Process 2 elements then split\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.trySplit(request, responseBuilder);\n+  // Test different cases of element split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ElementSplitTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // Split between future elements at element boundaries.\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\"), 0.51, 0})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\"), 0.49, 0})\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.26, 0})\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.25, 0})\n+          // If the split falls inside the first, splittable element, split there.\n+          .add(new Object[] {elementSplitResult(0L), 4L, ImmutableList.of(\"A\"), 0.2, 0})", "originalCommit": "e68fe093b7d654148ef0392e8ba4f7c1c127a10d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDUwMTE5NQ==", "url": "https://github.com/apache/beam/pull/11688#discussion_r424501195", "bodyText": "nit: If you want to better mirror the python version of the test, you could generate the list of elements in testElementSplittingWithAllowedSplitPoints based upon the \"index\"  you pass in instead of explicitly listing them (here and in the other parameterized versions)\nnit: ordering the parameters the same way also makes for easier maintenance in the future (here and in the other parameterized versions)", "author": "lukecwik", "createdAt": "2020-05-13T14:52:23Z", "path": "sdks/java/harness/src/test/java/org/apache/beam/fn/harness/BeamFnDataReadRunnerTest.java", "diffHunk": "@@ -122,334 +129,579 @@\n \n   private static final String INPUT_TRANSFORM_ID = \"1\";\n \n-  @Rule public TestExecutorService executor = TestExecutors.from(Executors::newCachedThreadPool);\n-  @Mock private BeamFnDataClient mockBeamFnDataClient;\n-  @Captor private ArgumentCaptor<FnDataReceiver<WindowedValue<String>>> consumerCaptor;\n-\n-  @Before\n-  public void setUp() {\n-    MockitoAnnotations.initMocks(this);\n-  }\n-\n-  @Test\n-  public void testCreatingAndProcessingBeamFnDataReadRunner() throws Exception {\n-    String bundleId = \"57\";\n+  private static final String PTRANSFORM_ID = \"ptransform_id\";\n \n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n+  // Test basic executions of BeamFnDataReadRunner.\n+  @RunWith(JUnit4.class)\n+  public static class BeamFnDataReadRunnerExecutionTest {\n+    @Rule public TestExecutorService executor = TestExecutors.from(Executors::newCachedThreadPool);\n+    @Mock private BeamFnDataClient mockBeamFnDataClient;\n+    @Captor private ArgumentCaptor<FnDataReceiver<WindowedValue<String>>> consumerCaptor;\n \n-    MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n-    PCollectionConsumerRegistry consumers =\n-        new PCollectionConsumerRegistry(\n-            metricsContainerRegistry, mock(ExecutionStateTracker.class));\n-    String localOutputId = \"outputPC\";\n-    String pTransformId = \"pTransformId\";\n-    consumers.register(\n-        localOutputId,\n-        pTransformId,\n-        (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) outputValues::add);\n-    PTransformFunctionRegistry startFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n-    PTransformFunctionRegistry finishFunctionRegistry =\n-        new PTransformFunctionRegistry(\n-            mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n-    List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n-\n-    RunnerApi.PTransform pTransform =\n-        RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n-\n-    new BeamFnDataReadRunner.Factory<String>()\n-        .createRunnerForPTransform(\n-            PipelineOptionsFactory.create(),\n-            mockBeamFnDataClient,\n-            null /* beamFnStateClient */,\n-            null /* beamFnTimerClient */,\n-            pTransformId,\n-            pTransform,\n-            Suppliers.ofInstance(bundleId)::get,\n-            ImmutableMap.of(\n-                localOutputId,\n-                RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n-            COMPONENTS.getCodersMap(),\n-            COMPONENTS.getWindowingStrategiesMap(),\n-            consumers,\n-            startFunctionRegistry,\n-            finishFunctionRegistry,\n-            teardownFunctions::add,\n-            null /* addProgressRequestCallback */,\n-            null /* splitListener */,\n-            null /* bundleFinalizer */);\n-\n-    assertThat(teardownFunctions, empty());\n-\n-    verifyZeroInteractions(mockBeamFnDataClient);\n+    @Before\n+    public void setUp() {\n+      MockitoAnnotations.initMocks(this);\n+    }\n \n-    InboundDataClient completionFuture = CompletableFutureInboundDataClient.create();\n-    when(mockBeamFnDataClient.receive(any(), any(), any(), any())).thenReturn(completionFuture);\n-    Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId, pTransformId)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n+    @Test\n+    public void testCreatingAndProcessingBeamFnDataReadRunner() throws Exception {\n+      String bundleId = \"57\";\n+\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+\n+      MetricsContainerStepMap metricsContainerRegistry = new MetricsContainerStepMap();\n+      PCollectionConsumerRegistry consumers =\n+          new PCollectionConsumerRegistry(\n+              metricsContainerRegistry, mock(ExecutionStateTracker.class));\n+      String localOutputId = \"outputPC\";\n+      String pTransformId = \"pTransformId\";\n+      consumers.register(\n+          localOutputId,\n+          pTransformId,\n+          (FnDataReceiver) (FnDataReceiver<WindowedValue<String>>) outputValues::add);\n+      PTransformFunctionRegistry startFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"start\");\n+      PTransformFunctionRegistry finishFunctionRegistry =\n+          new PTransformFunctionRegistry(\n+              mock(MetricsContainerStepMap.class), mock(ExecutionStateTracker.class), \"finish\");\n+      List<ThrowingRunnable> teardownFunctions = new ArrayList<>();\n+\n+      RunnerApi.PTransform pTransform =\n+          RemoteGrpcPortRead.readFromPort(PORT_SPEC, localOutputId).toPTransform();\n+\n+      new BeamFnDataReadRunner.Factory<String>()\n+          .createRunnerForPTransform(\n+              PipelineOptionsFactory.create(),\n+              mockBeamFnDataClient,\n+              null /* beamFnStateClient */,\n+              null /* beamFnTimerClient */,\n+              pTransformId,\n+              pTransform,\n+              Suppliers.ofInstance(bundleId)::get,\n+              ImmutableMap.of(\n+                  localOutputId,\n+                  RunnerApi.PCollection.newBuilder().setCoderId(ELEMENT_CODER_SPEC_ID).build()),\n+              COMPONENTS.getCodersMap(),\n+              COMPONENTS.getWindowingStrategiesMap(),\n+              consumers,\n+              startFunctionRegistry,\n+              finishFunctionRegistry,\n+              teardownFunctions::add,\n+              null /* addProgressRequestCallback */,\n+              null /* splitListener */,\n+              null /* bundleFinalizer */);\n+\n+      assertThat(teardownFunctions, empty());\n+\n+      verifyZeroInteractions(mockBeamFnDataClient);\n+\n+      InboundDataClient completionFuture = CompletableFutureInboundDataClient.create();\n+      when(mockBeamFnDataClient.receive(any(), any(), any(), any())).thenReturn(completionFuture);\n+      Iterables.getOnlyElement(startFunctionRegistry.getFunctions()).run();\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId, pTransformId)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      consumerCaptor.getValue().accept(valueInGlobalWindow(\"TestValue\"));\n+      assertThat(outputValues, contains(valueInGlobalWindow(\"TestValue\")));\n+      outputValues.clear();\n+\n+      assertThat(consumers.keySet(), containsInAnyOrder(localOutputId));\n+\n+      completionFuture.complete();\n+      Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-    consumerCaptor.getValue().accept(valueInGlobalWindow(\"TestValue\"));\n-    assertThat(outputValues, contains(valueInGlobalWindow(\"TestValue\")));\n-    outputValues.clear();\n+    @Test\n+    public void testReuseForMultipleBundles() throws Exception {\n+      InboundDataClient bundle1Future = CompletableFutureInboundDataClient.create();\n+      InboundDataClient bundle2Future = CompletableFutureInboundDataClient.create();\n+      when(mockBeamFnDataClient.receive(any(), any(), any(), any()))\n+          .thenReturn(bundle1Future)\n+          .thenReturn(bundle2Future);\n+      List<WindowedValue<String>> values = new ArrayList<>();\n+      FnDataReceiver<WindowedValue<String>> consumers = values::add;\n+      AtomicReference<String> bundleId = new AtomicReference<>(\"0\");\n+      BeamFnDataReadRunner<String> readRunner =\n+          new BeamFnDataReadRunner<>(\n+              INPUT_TRANSFORM_ID,\n+              RemoteGrpcPortRead.readFromPort(PORT_SPEC, \"localOutput\").toPTransform(),\n+              bundleId::get,\n+              COMPONENTS.getCodersMap(),\n+              mockBeamFnDataClient,\n+              consumers);\n+\n+      // Process for bundle id 0\n+      readRunner.registerInputLocation();\n+\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      Future<?> future =\n+          executor.submit(\n+              () -> {\n+                // Sleep for some small amount of time simulating the parent blocking\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+                try {\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"ABC\"));\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"DEF\"));\n+                } catch (Exception e) {\n+                  bundle1Future.fail(e);\n+                } finally {\n+                  bundle1Future.complete();\n+                }\n+              });\n+\n+      readRunner.blockTillReadFinishes();\n+      future.get();\n+      assertThat(values, contains(valueInGlobalWindow(\"ABC\"), valueInGlobalWindow(\"DEF\")));\n+\n+      // Process for bundle id 1\n+      bundleId.set(\"1\");\n+      values.clear();\n+      readRunner.registerInputLocation();\n+\n+      verify(mockBeamFnDataClient)\n+          .receive(\n+              eq(PORT_SPEC.getApiServiceDescriptor()),\n+              eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n+              eq(CODER),\n+              consumerCaptor.capture());\n+\n+      future =\n+          executor.submit(\n+              () -> {\n+                // Sleep for some small amount of time simulating the parent blocking\n+                Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n+                try {\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"GHI\"));\n+                  consumerCaptor.getValue().accept(valueInGlobalWindow(\"JKL\"));\n+                } catch (Exception e) {\n+                  bundle2Future.fail(e);\n+                } finally {\n+                  bundle2Future.complete();\n+                }\n+              });\n+\n+      readRunner.blockTillReadFinishes();\n+      future.get();\n+      assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n+\n+      verifyNoMoreInteractions(mockBeamFnDataClient);\n+    }\n \n-    assertThat(consumers.keySet(), containsInAnyOrder(localOutputId));\n+    @Test\n+    public void testRegistration() {\n+      for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n+        if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n+          assertThat(\n+              registrar.getPTransformRunnerFactories(),\n+              IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n+          return;\n+        }\n+      }\n+      fail(\"Expected registrar not found.\");\n+    }\n \n-    completionFuture.complete();\n-    Iterables.getOnlyElement(finishFunctionRegistry.getFunctions()).run();\n+    @Test\n+    public void testSplittingWhenNoElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      // The split should happen at 5 since the allowedSplitPoints is empty.\n+      assertEquals(\n+          channelSplitResult(5),\n+          executeSplit(\n+              readRunner, PTRANSFORM_ID, 10, Collections.EMPTY_LIST, 0.5, Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\")));\n+    }\n \n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n+    @Test\n+    public void testSplittingWhenSomeElementsProcessed() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          channelSplitResult(6),\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              10,\n+              ImmutableList.of(\"A\", \"B\"),\n+              0.5,\n+              Collections.EMPTY_LIST));\n+\n+      // Ensure that we process the correct number of elements after splitting.\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n+      readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n+      assertThat(\n+          outputValues,\n+          contains(\n+              valueInGlobalWindow(\"A\"),\n+              valueInGlobalWindow(\"B\"),\n+              valueInGlobalWindow(\"C\"),\n+              valueInGlobalWindow(\"D\"),\n+              valueInGlobalWindow(\"E\"),\n+              valueInGlobalWindow(\"F\")));\n+    }\n   }\n \n-  @Test\n-  public void testReuseForMultipleBundles() throws Exception {\n-    InboundDataClient bundle1Future = CompletableFutureInboundDataClient.create();\n-    InboundDataClient bundle2Future = CompletableFutureInboundDataClient.create();\n-    when(mockBeamFnDataClient.receive(any(), any(), any(), any()))\n-        .thenReturn(bundle1Future)\n-        .thenReturn(bundle2Future);\n-    List<WindowedValue<String>> values = new ArrayList<>();\n-    FnDataReceiver<WindowedValue<String>> consumers = values::add;\n-    AtomicReference<String> bundleId = new AtomicReference<>(\"0\");\n-    BeamFnDataReadRunner<String> readRunner =\n-        new BeamFnDataReadRunner<>(\n-            INPUT_TRANSFORM_ID,\n-            RemoteGrpcPortRead.readFromPort(PORT_SPEC, \"localOutput\").toPTransform(),\n-            bundleId::get,\n-            COMPONENTS.getCodersMap(),\n-            mockBeamFnDataClient,\n-            consumers);\n-\n-    // Process for bundle id 0\n-    readRunner.registerInputLocation();\n-\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n-\n-    Future<?> future =\n-        executor.submit(\n-            () -> {\n-              // Sleep for some small amount of time simulating the parent blocking\n-              Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-              try {\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"ABC\"));\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"DEF\"));\n-              } catch (Exception e) {\n-                bundle1Future.fail(e);\n-              } finally {\n-                bundle1Future.complete();\n-              }\n-            });\n-\n-    readRunner.blockTillReadFinishes();\n-    future.get();\n-    assertThat(values, contains(valueInGlobalWindow(\"ABC\"), valueInGlobalWindow(\"DEF\")));\n-\n-    // Process for bundle id 1\n-    bundleId.set(\"1\");\n-    values.clear();\n-    readRunner.registerInputLocation();\n-\n-    verify(mockBeamFnDataClient)\n-        .receive(\n-            eq(PORT_SPEC.getApiServiceDescriptor()),\n-            eq(LogicalEndpoint.data(bundleId.get(), INPUT_TRANSFORM_ID)),\n-            eq(CODER),\n-            consumerCaptor.capture());\n-\n-    future =\n-        executor.submit(\n-            () -> {\n-              // Sleep for some small amount of time simulating the parent blocking\n-              Uninterruptibles.sleepUninterruptibly(100, TimeUnit.MILLISECONDS);\n-              try {\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"GHI\"));\n-                consumerCaptor.getValue().accept(valueInGlobalWindow(\"JKL\"));\n-              } catch (Exception e) {\n-                bundle2Future.fail(e);\n-              } finally {\n-                bundle2Future.complete();\n-              }\n-            });\n-\n-    readRunner.blockTillReadFinishes();\n-    future.get();\n-    assertThat(values, contains(valueInGlobalWindow(\"GHI\"), valueInGlobalWindow(\"JKL\")));\n-\n-    verifyNoMoreInteractions(mockBeamFnDataClient);\n-  }\n+  // Test different cases of chan nel split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitTest {\n+\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // Split as close to the beginning as possible.\n+          .add(new Object[] {channelSplitResult(1L), 16L, ImmutableList.of(\"A\"), 0, 0})\n+          // The closest split is at 4, even when just above or below it.\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.24, 0})\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.25, 0})\n+          .add(new Object[] {channelSplitResult(4L), 16L, ImmutableList.of(\"A\"), 0.26, 0})\n+          // Split the *remainder* in half.\n+          .add(new Object[] {channelSplitResult(8L), 16L, ImmutableList.of(\"A\"), 0.5, 0})\n+          .add(new Object[] {channelSplitResult(9L), 16L, ImmutableList.of(\"A\", \"B\", \"C\"), 0.5, 0})\n+          .add(\n+              new Object[] {\n+                channelSplitResult(11L),\n+                16L,\n+                ImmutableList.of(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\", \"G\"),\n+                0.5,\n+                0\n+              })\n+          // Progress into the active element influences where the split of the remainder falls.\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.25, 0.5})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\"), 0.25, 0.9})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\", \"B\"), 0.25, 0.0})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\", \"B\"), 0.25, 0.1})\n+          .build();\n+    }\n \n-  @Test\n-  public void testRegistration() {\n-    for (Registrar registrar : ServiceLoader.load(Registrar.class)) {\n-      if (registrar instanceof BeamFnDataReadRunner.Registrar) {\n-        assertThat(\n-            registrar.getPTransformRunnerFactories(),\n-            IsMapContaining.hasKey(RemoteGrpcPortRead.URN));\n-        return;\n-      }\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long inputElements;\n+\n+    @Parameterized.Parameter(2)\n+    public List<String> processedElements;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public double elementProgress;\n+\n+    @Test\n+    public void testChannelSplit() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              inputElements,\n+              processedElements,\n+              fractionOfRemainder,\n+              Collections.EMPTY_LIST));\n     }\n-    fail(\"Expected registrar not found.\");\n   }\n \n-  @Test\n-  public void testSplittingWhenNoElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.5)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n-    readRunner.trySplit(request, responseBuilder);\n+  // Test different cases of channel split with non-empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ChannelSplitWithAllowedSplitPointsTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // The desired split point is at 4.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(4L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(2L, 3L, 4L, 5L)\n+              })\n+          // If we can't split at 4, choose the closest possible split point.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(5L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(2L, 3L, 5L)\n+              })\n+          .add(\n+              new Object[] {\n+                channelSplitResult(3L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(2L, 3L, 6L)\n+              })\n+          // Also test the case where all possible split points lie above or below the desired split\n+          // point.\n+          .add(\n+              new Object[] {\n+                channelSplitResult(5L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(5L, 6L, 7L)\n+              })\n+          .add(\n+              new Object[] {\n+                channelSplitResult(3L),\n+                16L,\n+                ImmutableList.of(\"A\"),\n+                0.25,\n+                ImmutableList.of(1L, 2L, 3L)\n+              })\n+          // We have progressed beyond all possible split points, so can't split.\n+          .add(\n+              new Object[] {\n+                ProcessBundleSplitResponse.getDefaultInstance(),\n+                16L,\n+                ImmutableList.of(\"A\", \"B\", \"C\", \"D\", \"F\", \"G\"),\n+                0.25,\n+                ImmutableList.of(1L, 2L, 3L)\n+              })\n+          .build();\n+    }\n \n-    ProcessBundleSplitResponse expected =\n-        ProcessBundleSplitResponse.newBuilder()\n-            .addChannelSplits(\n-                ChannelSplit.newBuilder()\n-                    .setLastPrimaryElement(4)\n-                    .setFirstResidualElement(5)\n-                    .build())\n-            .build();\n-    assertEquals(expected, responseBuilder.build());\n-\n-    // Ensure that we process the correct number of elements after splitting.\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n-    assertThat(\n-        outputValues,\n-        contains(\n-            valueInGlobalWindow(\"A\"),\n-            valueInGlobalWindow(\"B\"),\n-            valueInGlobalWindow(\"C\"),\n-            valueInGlobalWindow(\"D\"),\n-            valueInGlobalWindow(\"E\")));\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long inputElements;\n+\n+    @Parameterized.Parameter(2)\n+    public List<String> processedElements;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public List<Long> allowedSplitPoints;\n+\n+    @Test\n+    public void testChannelSplittingWithAllowedSplitPoints() throws Exception {\n+      List<WindowedValue<String>> outputValues = new ArrayList<>();\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(outputValues::add, PTRANSFORM_ID, mockBeamFnDataClient);\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              inputElements,\n+              processedElements,\n+              fractionOfRemainder,\n+              allowedSplitPoints));\n+    }\n   }\n \n-  @Test\n-  public void testSplittingWhenSomeElementsProcessed() throws Exception {\n-    List<WindowedValue<String>> outputValues = new ArrayList<>();\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(outputValues::add);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.5)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n-\n-    // Process 2 elements then split\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.trySplit(request, responseBuilder);\n+  // Test different cases of element split with empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ElementSplitTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // Split between future elements at element boundaries.\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\"), 0.51, 0})\n+          .add(new Object[] {channelSplitResult(2L), 4L, ImmutableList.of(\"A\"), 0.49, 0})\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.26, 0})\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.25, 0})\n+          // If the split falls inside the first, splittable element, split there.\n+          .add(new Object[] {elementSplitResult(0L), 4L, ImmutableList.of(\"A\"), 0.2, 0})\n+          // The choice of split depends on the progress into the first element.\n+          .add(new Object[] {elementSplitResult(0L), 4L, ImmutableList.of(\"A\"), 0.125, 0})\n+          // Here we are far enough into the first element that splitting at 0.2 of the remainder\n+          // falls outside the first element.\n+          .add(new Object[] {channelSplitResult(1L), 4L, ImmutableList.of(\"A\"), 0.2, 0.5})\n+          // Verify the above logic when we are partially through the stream.\n+          .add(new Object[] {channelSplitResult(3L), 4L, ImmutableList.of(\"A\", \"B\", \"C\"), 0.6, 0})\n+          .add(new Object[] {channelSplitResult(4L), 4L, ImmutableList.of(\"A\", \"B\", \"C\"), 0.6, 0.9})\n+          .add(new Object[] {elementSplitResult(2L), 4L, ImmutableList.of(\"A\", \"B\", \"C\"), 0.2, 0.5})\n+          .build();\n+    }\n \n-    ProcessBundleSplitResponse expected =\n-        ProcessBundleSplitResponse.newBuilder()\n-            .addChannelSplits(\n-                ChannelSplit.newBuilder()\n-                    .setLastPrimaryElement(5)\n-                    .setFirstResidualElement(6)\n-                    .build())\n-            .build();\n-    assertEquals(expected, responseBuilder.build());\n-\n-    // Ensure that we process the correct number of elements after splitting.\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"D\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"E\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"F\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"G\"));\n-    assertThat(\n-        outputValues,\n-        contains(\n-            valueInGlobalWindow(\"A\"),\n-            valueInGlobalWindow(\"B\"),\n-            valueInGlobalWindow(\"C\"),\n-            valueInGlobalWindow(\"D\"),\n-            valueInGlobalWindow(\"E\"),\n-            valueInGlobalWindow(\"F\")));\n+    @Parameterized.Parameter(0)\n+    public ProcessBundleSplitResponse expectedResponse;\n+\n+    @Parameterized.Parameter(1)\n+    public long inputElements;\n+\n+    @Parameterized.Parameter(2)\n+    public List<String> processedElements;\n+\n+    @Parameterized.Parameter(3)\n+    public double fractionOfRemainder;\n+\n+    @Parameterized.Parameter(4)\n+    public double elementProgress;\n+\n+    @Test\n+    public void testElementSplit() throws Exception {\n+      SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n+      BeamFnDataClient mockBeamFnDataClient = mock(BeamFnDataClient.class);\n+      when(splittingReceiver.getProgress()).thenReturn(elementProgress);\n+      when(splittingReceiver.trySplit(anyDouble())).thenReturn(mockSplitResult);\n+      BeamFnDataReadRunner<String> readRunner =\n+          createReadRunner(splittingReceiver, PTRANSFORM_ID, mockBeamFnDataClient);\n+\n+      assertEquals(\n+          expectedResponse,\n+          executeSplit(\n+              readRunner,\n+              PTRANSFORM_ID,\n+              inputElements,\n+              processedElements,\n+              fractionOfRemainder,\n+              Collections.EMPTY_LIST));\n+    }\n   }\n \n-  @Test\n-  public void testSplittingDownstreamReceiver() throws Exception {\n-    SplitResult splitResult =\n-        SplitResult.of(\n-            BundleApplication.newBuilder().setInputId(\"primary\").build(),\n-            DelayedBundleApplication.newBuilder()\n-                .setApplication(BundleApplication.newBuilder().setInputId(\"residual\").build())\n-                .build());\n-    SplittingReceiver splittingReceiver = mock(SplittingReceiver.class);\n-    when(splittingReceiver.getProgress()).thenReturn(0.3);\n-    when(splittingReceiver.trySplit(anyDouble())).thenReturn(splitResult);\n-    BeamFnDataReadRunner<String> readRunner = createReadRunner(splittingReceiver);\n-\n-    ProcessBundleSplitRequest request =\n-        ProcessBundleSplitRequest.newBuilder()\n-            .putDesiredSplits(\n-                \"pTransformId\",\n-                DesiredSplit.newBuilder()\n-                    .setEstimatedInputElements(10)\n-                    .setFractionOfRemainder(0.05)\n-                    .build())\n-            .build();\n-    ProcessBundleSplitResponse.Builder responseBuilder = ProcessBundleSplitResponse.newBuilder();\n-\n-    // We will be \"processing\" the 'C' element, aka 2nd index\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"A\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"B\"));\n-    readRunner.forwardElementToConsumer(valueInGlobalWindow(\"C\"));\n-    readRunner.trySplit(request, responseBuilder);\n+  // Test different cases of element split with non-empty allowed split points.\n+  @RunWith(Parameterized.class)\n+  public static class ElementSplitWithAllowedSplitPointsTest {\n+    @Parameterized.Parameters\n+    public static Iterable<Object[]> data() {\n+      return ImmutableList.<Object[]>builder()\n+          // This is where we would like to split, when all split points are available.\n+          .add(\n+              new Object[] {\n+                elementSplitResult(2L),\n+                5L,\n+                ImmutableList.of(\"A\", \"B\", \"C\"),", "originalCommit": "e68fe093b7d654148ef0392e8ba4f7c1c127a10d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "efdee96f04d339445298b4a4dc44f8aa75e6aa67", "url": "https://github.com/apache/beam/commit/efdee96f04d339445298b4a4dc44f8aa75e6aa67", "message": "[BEAM-9935] Respect allowed split points in Java", "committedDate": "2020-05-13T20:26:05Z", "type": "forcePushed"}, {"oid": "216dbe671f1203f73861317c8dce7f3a7f5c0e8e", "url": "https://github.com/apache/beam/commit/216dbe671f1203f73861317c8dce7f3a7f5c0e8e", "message": "[BEAM-9935] Respect allowed split points in Java", "committedDate": "2020-05-13T20:28:26Z", "type": "commit"}, {"oid": "216dbe671f1203f73861317c8dce7f3a7f5c0e8e", "url": "https://github.com/apache/beam/commit/216dbe671f1203f73861317c8dce7f3a7f5c0e8e", "message": "[BEAM-9935] Respect allowed split points in Java", "committedDate": "2020-05-13T20:28:26Z", "type": "forcePushed"}]}