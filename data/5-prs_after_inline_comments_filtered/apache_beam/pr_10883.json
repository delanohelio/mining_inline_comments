{"pr_number": 10883, "pr_title": "[BEAM-9331] Add better Row builders", "pr_createdAt": "2020-02-17T18:35:47Z", "pr_url": "https://github.com/apache/beam/pull/10883", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQyMjQ1OQ==", "url": "https://github.com/apache/beam/pull/10883#discussion_r380422459", "bodyText": "Would this be more readable if it was withAddedFieldValue?", "author": "rezarokni", "createdAt": "2020-02-18T02:01:32Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/values/Row.java", "diffHunk": "@@ -55,8 +59,31 @@\n  * {@link Row} is an immutable tuple-like schema to represent one element in a {@link PCollection}.\n  * The fields are described with a {@link Schema}.\n  *\n- * <p>{@link Schema} contains the names for each field and the coder for the whole record,\n- * {see @link Schema#getRowCoder()}.\n+ * <p>{@link Schema} contains the names and types for each field.\n+ *\n+ * <p>There are several ways to build a new Row object. To build a row from scratch using a schema\n+ * object, {@link Row#withSchema} can be used. Schema fields can be specified by name, and nested\n+ * fields can be specified using the field selection syntax. For example:\n+ *\n+ * <pre>{@code\n+ * Row row = Row.withSchema(schema)\n+ *              .withFieldValue(\"userId\", \"user1)\n+ *              .withFieldValue(\"location.city\", \"seattle\")\n+ *              .withFieldValue(\"location.state\", \"wa\")\n+ *              .build();\n+ * }</pre>\n+ *\n+ * <p>The {@link Row#fromRow} builder can be used to base a row off of another row. The builder can\n+ * be used to specify values for specific fields, and all the remaining values will be taken from\n+ * the original row. For example, the following produces a row identical to the above row except for\n+ * the location.city field.\n+ *\n+ * <pre>{@code\n+ * Row modifiedRow =\n+ *     Row.fromRow(row)\n+ *        .withFieldValue(\"location.city\", \"tacoma\")", "originalCommit": "29174544625f5aee2c5a3852a6046e7d41bf90b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUyMTA1Mg==", "url": "https://github.com/apache/beam/pull/10883#discussion_r380521052", "bodyText": "I don't think so. We're not really adding anything, we're setting something.", "author": "reuvenlax", "createdAt": "2020-02-18T08:32:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQyMjQ1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE1ODU5Mw==", "url": "https://github.com/apache/beam/pull/10883#discussion_r381158593", "bodyText": "Nope, I like the proposed withFieldValue.", "author": "alexvanboxel", "createdAt": "2020-02-19T09:08:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQyMjQ1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQyNDEzOA==", "url": "https://github.com/apache/beam/pull/10883#discussion_r380424138", "bodyText": "Is it worth having a logical type to test as well?", "author": "rezarokni", "createdAt": "2020-02-18T02:11:19Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/values/RowTest.java", "diffHunk": "@@ -477,6 +477,172 @@ public void testCreateMapWithRowValue() {\n     assertEquals(data, row.getMap(\"map\"));\n   }\n \n+  @Test", "originalCommit": "29174544625f5aee2c5a3852a6046e7d41bf90b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDUyMTE0Ng==", "url": "https://github.com/apache/beam/pull/10883#discussion_r380521146", "bodyText": "yes will add one", "author": "reuvenlax", "createdAt": "2020-02-18T08:32:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQyNDEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE2MDg1OQ==", "url": "https://github.com/apache/beam/pull/10883#discussion_r381160859", "bodyText": "What get's people confused on the current API is that you can't loop over the values of a Row with getValue() and can't supply them to the Builder as the addValue() expects the input type, while the getValue returns a base type.", "author": "alexvanboxel", "createdAt": "2020-02-19T09:13:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQyNDEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIyNzI5NA==", "url": "https://github.com/apache/beam/pull/10883#discussion_r382227294", "bodyText": "added test", "author": "reuvenlax", "createdAt": "2020-02-20T20:01:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQyNDEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIyODk1Mg==", "url": "https://github.com/apache/beam/pull/10883#discussion_r382228952", "bodyText": "still struggling to figure out a good answer to the API. getValues is supposed to return the base value so that transforms that don't know about the specific logical value can process it.", "author": "reuvenlax", "createdAt": "2020-02-20T20:04:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQyNDEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjI0MTkwNA==", "url": "https://github.com/apache/beam/pull/10883#discussion_r382241904", "bodyText": "What about this,\n\naddValue, getValue and getValues return the input type(s) (so the logical type)\nadd, get, detach returns the base types (is also inline with the attach)\nThat means a behaviour change only for getValue and getValues", "author": "alexvanboxel", "createdAt": "2020-02-20T20:32:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQyNDEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjQyMjk1Nw==", "url": "https://github.com/apache/beam/pull/10883#discussion_r382422957", "bodyText": "Elaborating on the above comment:\ngetValues is currently not safe (it makes the Row mutable), if the meaning changes that it returns the logical type the implementation will need to make a copy of the content as it needs to translate the basetype to the logicaltype. As it's a copy the Row is immutable again. See this for test:\n  @Test\n  public void testImmutability() {\n    Schema schema = Schema.builder().addInt32Field(\"a\").addInt32Field(\"b\").build();\n    Row row1 = Row.withSchema(schema).addValue(1).addValue(2).build();\n    List<Object> values = row1.getValues();\n    values.set(1, 3);\n    assertEquals(2,(int)row1.getValue(1));\n  }\n\nThen the question is left for attach or detach: if you make values an immutable array it can be returned with detach, as it's immutable that's safe. The attach needs then make a copy of the array to an immutable array (or check if it's immutable) and build needs to make the immutable array as well.", "author": "alexvanboxel", "createdAt": "2020-02-21T06:56:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQyNDEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzA2Mjk1Mw==", "url": "https://github.com/apache/beam/pull/10883#discussion_r383062953", "bodyText": "The fact that getValues returns the underlying objects I think is in line with many other things. e.g. ImmutableList in Java still returns the underlying objects, so you can mutate them. The onus is on the user not to do that.\nIn particular, the elements of a PCollection are not allowed to be mutated in a ParDo (and the main point of the Row object is to be used in ParDos). The DirectRunner has a mutability checker that will fail your test if you mutate the input elements.", "author": "reuvenlax", "createdAt": "2020-02-24T01:49:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQyNDEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzMwNjUzNg==", "url": "https://github.com/apache/beam/pull/10883#discussion_r383306536", "bodyText": "Aside from the mutability/. WDYT of the proposed addValue, getValue and getValues vs add, get, detach", "author": "alexvanboxel", "createdAt": "2020-02-24T14:46:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQyNDEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDk2OTE1Mg==", "url": "https://github.com/apache/beam/pull/10883#discussion_r384969152", "bodyText": "I propose to take this discussion out of this PR, as I really like this already. For me it's already a LGTM. (Best to wait till the 2.20 is cut though).", "author": "alexvanboxel", "createdAt": "2020-02-27T08:14:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDQyNDEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE0Nzg2Nw==", "url": "https://github.com/apache/beam/pull/10883#discussion_r381147867", "bodyText": "Maybe this is an opportunity to change the attachValues. No values should be set before or after the attach. I see 2 options to improve this:\n\nIn the attach first see if values are already set. Let the attachValues return the new Row directly. This is maybe a bit strange as it violates a builder pattern.\nHave 4 build in builders. The starting one (that includes an attachValues, add and withFieldValue), all of them return a specific builder: the new ModifyingBuilder and a new AddValuesBuilder that only has the add methods and an AttachBuilder that only has build. This also eliminates some elaborate if/then/else's in the builder().", "author": "alexvanboxel", "createdAt": "2020-02-19T08:47:18Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/values/Row.java", "diffHunk": "@@ -599,272 +709,555 @@ public Builder addArray(Object... values) {\n       return this;\n     }\n \n-    // Values are attached. No verification is done, and no conversions are done. LogicalType\n-    // values must be specified as the base type.\n+    // Values are attached. No verification is done, and no conversions are done. LogicalType values\n+    // must be specified\n+    // as the base type. This method should be used with great care, as no validation is done. If\n+    // incorrect values are\n+    // passed in, it could result in strange errors later in the pipeline. This method is largely\n+    // used internal\n+    // to Beam.\n+    @Internal\n     public Builder attachValues(List<Object> values) {", "originalCommit": "2022ae61687844b30512d55fd8ae0a54a2864e91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIyOTAzMw==", "url": "https://github.com/apache/beam/pull/10883#discussion_r382229033", "bodyText": "I like making attachValues return a Row. I thin the same for withFieldValueBuilders. this simplifies the builder code", "author": "reuvenlax", "createdAt": "2020-02-20T20:05:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE0Nzg2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE1MTk1MQ==", "url": "https://github.com/apache/beam/pull/10883#discussion_r381151951", "bodyText": "Can't this be tweaked a bit, that this is the builder specifically for use with withFieldValue. Meaning that if when nit doesn't have a source row it just assumes null values for the fields not set. See remark on withFieldValue on initial builder as well.", "author": "alexvanboxel", "createdAt": "2020-02-19T08:55:32Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/values/Row.java", "diffHunk": "@@ -539,37 +568,118 @@ public String toString() {\n   }\n \n   /**\n-   * Creates a record builder with specified {@link #getSchema()}. {@link Builder#build()} will\n-   * throw an {@link IllegalArgumentException} if number of fields in {@link #getSchema()} does not\n-   * match the number of fields specified.\n+   * Creates a row builder with specified {@link #getSchema()}. {@link Builder#build()} will throw\n+   * an {@link IllegalArgumentException} if number of fields in {@link #getSchema()} does not match\n+   * the number of fields specified. If any of the arguments don't match the expected types for the\n+   * schema fields, {@link Builder#build()} will throw a {@link ClassCastException}.\n    */\n   public static Builder withSchema(Schema schema) {\n     return new Builder(schema);\n   }\n \n+  /**\n+   * Creates a row builder based on the specified row. Field values in the new row can be explicitly\n+   * set using {@link ModifyingBuilder#withFieldValue}. Any values not so overridden will be the\n+   * same as the values in the original row.\n+   */\n+  public static ModifyingBuilder fromRow(Row row) {\n+    return new ModifyingBuilder(row);\n+  }\n+\n+  /** Builder for {@link Row} that bases a row on another row. */\n+  public static class ModifyingBuilder {", "originalCommit": "2022ae61687844b30512d55fd8ae0a54a2864e91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIyOTU4Mg==", "url": "https://github.com/apache/beam/pull/10883#discussion_r382229582", "bodyText": "Yes, good suggestion. This should simplify the code", "author": "reuvenlax", "createdAt": "2020-02-20T20:06:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE1MTk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE1Mjk0OA==", "url": "https://github.com/apache/beam/pull/10883#discussion_r381152948", "bodyText": "Maybe this one can return the ModifyingBuilder so that no other methods can used (no attachValues, no add's).", "author": "alexvanboxel", "createdAt": "2020-02-19T08:57:26Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/values/Row.java", "diffHunk": "@@ -539,37 +568,118 @@ public String toString() {\n   }\n \n   /**\n-   * Creates a record builder with specified {@link #getSchema()}. {@link Builder#build()} will\n-   * throw an {@link IllegalArgumentException} if number of fields in {@link #getSchema()} does not\n-   * match the number of fields specified.\n+   * Creates a row builder with specified {@link #getSchema()}. {@link Builder#build()} will throw\n+   * an {@link IllegalArgumentException} if number of fields in {@link #getSchema()} does not match\n+   * the number of fields specified. If any of the arguments don't match the expected types for the\n+   * schema fields, {@link Builder#build()} will throw a {@link ClassCastException}.\n    */\n   public static Builder withSchema(Schema schema) {\n     return new Builder(schema);\n   }\n \n+  /**\n+   * Creates a row builder based on the specified row. Field values in the new row can be explicitly\n+   * set using {@link ModifyingBuilder#withFieldValue}. Any values not so overridden will be the\n+   * same as the values in the original row.\n+   */\n+  public static ModifyingBuilder fromRow(Row row) {\n+    return new ModifyingBuilder(row);\n+  }\n+\n+  /** Builder for {@link Row} that bases a row on another row. */\n+  public static class ModifyingBuilder {\n+    private final Row sourceRow;\n+    private final Map<FieldAccessDescriptor, FieldOverride> fieldValues = Maps.newHashMap();\n+\n+    private ModifyingBuilder(Row sourceRow) {\n+      this.sourceRow = sourceRow;\n+    }\n+\n+    public Schema getSchema() {\n+      return sourceRow.getSchema();\n+    }\n+\n+    public ModifyingBuilder withFieldValue(String fieldName, Object value) {\n+      FieldAccessDescriptor fieldAccessDescriptor =\n+          FieldAccessDescriptor.withFieldNames(fieldName).resolve(getSchema());\n+      checkArgument(fieldAccessDescriptor.referencesSingleField(), \"\");\n+      fieldValues.put(fieldAccessDescriptor, new FieldOverride(value));\n+      return this;\n+    }\n+\n+    public ModifyingBuilder withFieldValues(Map<String, Object> values) {\n+      fieldValues.putAll(\n+          values.entrySet().stream()\n+              .collect(\n+                  Collectors.toMap(\n+                      e -> FieldAccessDescriptor.withFieldNames(e.getKey()),\n+                      e -> new FieldOverride(e.getValue()))));\n+      return this;\n+    }\n+\n+    public Row build() {\n+      Row row =\n+          (Row)\n+              new RowFieldMatcher()\n+                  .match(\n+                      new CapturingRowCases(getSchema(), this.fieldValues, false),\n+                      FieldType.row(getSchema()),\n+                      FieldAccessDescriptor.create(),\n+                      sourceRow);\n+      return row;\n+    }\n+  }\n+\n   /** Builder for {@link Row}. */\n   public static class Builder {\n+    private final Map<FieldAccessDescriptor, FieldOverride> fieldValues = Maps.newHashMap();\n     private List<Object> values = Lists.newArrayList();\n     private boolean attached = false;\n     @Nullable private Factory<List<FieldValueGetter>> fieldValueGetterFactory;\n     @Nullable private Object getterTarget;\n-    private Schema schema;\n+    private final Schema schema;\n \n     Builder(Schema schema) {\n       this.schema = schema;\n     }\n \n-    public int nextFieldId() {\n-      if (fieldValueGetterFactory != null) {\n-        throw new RuntimeException(\"Not supported\");\n-      }\n-      return values.size();\n-    }\n-\n+    /** Return the schema for the row being built. */\n     public Schema getSchema() {\n       return schema;\n     }\n \n+    /**\n+     * Set a field value using the field name. Nested values can be set using the field selection\n+     * syntax.\n+     */\n+    public Builder withFieldValue(String fieldName, Object value) {", "originalCommit": "2022ae61687844b30512d55fd8ae0a54a2864e91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIyOTcwNg==", "url": "https://github.com/apache/beam/pull/10883#discussion_r382229706", "bodyText": "done", "author": "reuvenlax", "createdAt": "2020-02-20T20:06:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE1Mjk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE1Nzk1Mw==", "url": "https://github.com/apache/beam/pull/10883#discussion_r381157953", "bodyText": "Wouldn't it be useful to have a withFieldValue with an index?", "author": "alexvanboxel", "createdAt": "2020-02-19T09:07:11Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/values/Row.java", "diffHunk": "@@ -539,37 +568,118 @@ public String toString() {\n   }\n \n   /**\n-   * Creates a record builder with specified {@link #getSchema()}. {@link Builder#build()} will\n-   * throw an {@link IllegalArgumentException} if number of fields in {@link #getSchema()} does not\n-   * match the number of fields specified.\n+   * Creates a row builder with specified {@link #getSchema()}. {@link Builder#build()} will throw\n+   * an {@link IllegalArgumentException} if number of fields in {@link #getSchema()} does not match\n+   * the number of fields specified. If any of the arguments don't match the expected types for the\n+   * schema fields, {@link Builder#build()} will throw a {@link ClassCastException}.\n    */\n   public static Builder withSchema(Schema schema) {\n     return new Builder(schema);\n   }\n \n+  /**\n+   * Creates a row builder based on the specified row. Field values in the new row can be explicitly\n+   * set using {@link ModifyingBuilder#withFieldValue}. Any values not so overridden will be the\n+   * same as the values in the original row.\n+   */\n+  public static ModifyingBuilder fromRow(Row row) {\n+    return new ModifyingBuilder(row);\n+  }\n+\n+  /** Builder for {@link Row} that bases a row on another row. */\n+  public static class ModifyingBuilder {\n+    private final Row sourceRow;\n+    private final Map<FieldAccessDescriptor, FieldOverride> fieldValues = Maps.newHashMap();\n+\n+    private ModifyingBuilder(Row sourceRow) {\n+      this.sourceRow = sourceRow;\n+    }\n+\n+    public Schema getSchema() {\n+      return sourceRow.getSchema();\n+    }\n+\n+    public ModifyingBuilder withFieldValue(String fieldName, Object value) {", "originalCommit": "2022ae61687844b30512d55fd8ae0a54a2864e91", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MjIyOTcxOA==", "url": "https://github.com/apache/beam/pull/10883#discussion_r382229718", "bodyText": "added", "author": "reuvenlax", "createdAt": "2020-02-20T20:06:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MTE1Nzk1Mw=="}], "type": "inlineReview"}, {"oid": "2d3e1bc3e5f5144b3b09debc57cb893cbf438b17", "url": "https://github.com/apache/beam/commit/2d3e1bc3e5f5144b3b09debc57cb893cbf438b17", "message": "add better row builders", "committedDate": "2020-03-24T06:15:08Z", "type": "commit"}, {"oid": "f478de782b26afeaac066b269b90442cd213f1fb", "url": "https://github.com/apache/beam/commit/f478de782b26afeaac066b269b90442cd213f1fb", "message": "foo", "committedDate": "2020-03-25T17:27:17Z", "type": "commit"}, {"oid": "52695aa68322b8bbd5fd90a9e99cd6ad72168bee", "url": "https://github.com/apache/beam/commit/52695aa68322b8bbd5fd90a9e99cd6ad72168bee", "message": "fix failing tests", "committedDate": "2020-03-26T22:38:16Z", "type": "commit"}, {"oid": "52695aa68322b8bbd5fd90a9e99cd6ad72168bee", "url": "https://github.com/apache/beam/commit/52695aa68322b8bbd5fd90a9e99cd6ad72168bee", "message": "fix failing tests", "committedDate": "2020-03-26T22:38:16Z", "type": "forcePushed"}, {"oid": "d50f358619fc67c603f78c87ba04206aeea14540", "url": "https://github.com/apache/beam/commit/d50f358619fc67c603f78c87ba04206aeea14540", "message": "fix tests", "committedDate": "2020-03-27T18:47:25Z", "type": "commit"}]}