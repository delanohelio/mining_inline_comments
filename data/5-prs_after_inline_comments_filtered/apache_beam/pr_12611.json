{"pr_number": 12611, "pr_title": "[BEAM-10139][BEAM-10140] Add cross-language support for Java SpannerIO with python wrapper", "pr_createdAt": "2020-08-18T14:00:40Z", "pr_url": "https://github.com/apache/beam/pull/12611", "timeline": [{"oid": "e1d90016a73cb983f18a0616dca7ab989d890fa3", "url": "https://github.com/apache/beam/commit/e1d90016a73cb983f18a0616dca7ab989d890fa3", "message": "[BEAM-10131][BEAM-10140] Add spanner IT tests to Python Portable Postcommit", "committedDate": "2020-08-20T13:03:45Z", "type": "forcePushed"}, {"oid": "2839b8e0f1bc27c0914db9bce3d0180e397495a7", "url": "https://github.com/apache/beam/commit/2839b8e0f1bc27c0914db9bce3d0180e397495a7", "message": "[BEAM-10139][BEAM-10140] Add spanner IT tests to Python Portable Postcommit", "committedDate": "2020-08-20T13:12:18Z", "type": "forcePushed"}, {"oid": "fed767a2904c0c8ac4f1ae18d5461367beb985ab", "url": "https://github.com/apache/beam/commit/fed767a2904c0c8ac4f1ae18d5461367beb985ab", "message": "[BEAM-10139][BEAM-10140] Add spanner IT tests to Python Portable Postcommit", "committedDate": "2020-08-31T07:20:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYxNDMwMA==", "url": "https://github.com/apache/beam/pull/12611#discussion_r477614300", "bodyText": "What is the issue here? Nullable fields should be supported in cross-language", "author": "TheNeuralBit", "createdAt": "2020-08-26T22:01:42Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/spanner/StructUtils.java", "diffHunk": "@@ -0,0 +1,545 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.spanner;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+\n+import com.google.cloud.ByteArray;\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.Struct;\n+import com.google.cloud.spanner.Type;\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.values.Row;\n+import org.joda.time.DateTime;\n+import org.joda.time.Instant;\n+\n+final class StructUtils {\n+  public static Row translateStructToRow(Struct struct, Schema schema) {\n+    checkForSchemasEquality(schema.getFields(), struct.getType().getStructFields(), false);\n+\n+    List<Schema.Field> fields = schema.getFields();\n+    Row.FieldValueBuilder valueBuilder = null;\n+    // TODO: Remove this null-checking once nullable fields are supported in cross-language", "originalCommit": "2839b8e0f1bc27c0914db9bce3d0180e397495a7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA2MzQ4NA==", "url": "https://github.com/apache/beam/pull/12611#discussion_r482063484", "bodyText": "NullableCoder is not a standard coder as was mentioned here: https://issues.apache.org/jira/browse/BEAM-10529?jql=project%20%3D%20BEAM%20AND%20text%20~%20%22nullable%20python%22\nSo I suppose the only way to support null values is not to set them.\nI noticed that when I tried to read a null field from Spanner table. But I may be wrong", "author": "piotr-szuberski", "createdAt": "2020-09-02T13:21:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYxNDMwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMwMTM4Nw==", "url": "https://github.com/apache/beam/pull/12611#discussion_r483301387", "bodyText": "Hm so it should be supported. RowCoder encodes nulls for top-level fields separately so there's no need for NullableCoder. NullableCoder is only used when you have a nullable type in a container type, e.g. ARRAY<NULLABLE INT>. This wasn't supported in Python until recently - #12426 should have fixed it though.", "author": "TheNeuralBit", "createdAt": "2020-09-03T23:15:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYxNDMwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODQyMjEzNA==", "url": "https://github.com/apache/beam/pull/12611#discussion_r488422134", "bodyText": "I'm not sure where my message has gone, but I wrote that nulls come up with no problems, I've just used ImmutableMap which does not allow null values. Replacing it with java.util.HashMap solved the issue.", "author": "piotr-szuberski", "createdAt": "2020-09-15T06:41:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NzYxNDMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NjA0Mw==", "url": "https://github.com/apache/beam/pull/12611#discussion_r480396043", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                      .setRowSchema(schema)\n          \n          \n            \n                      .setCoder(RowCoder.of(schema));\n          \n          \n            \n                      .setRowSchema(schema);\n          \n      \n    \n    \n  \n\nsetCoder(RowCoder.of(schema)) is what setRowSchema does", "author": "TheNeuralBit", "createdAt": "2020-08-31T20:59:48Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/spanner/SpannerIO.java", "diffHunk": "@@ -678,6 +703,42 @@ public Read withPartitionOptions(PartitionOptions partitionOptions) {\n               .withTransaction(getTransaction());\n       return input.apply(Create.of(getReadOperation())).apply(\"Execute query\", readAll);\n     }\n+\n+    SerializableFunction<Struct, Row> getFormatFn() {\n+      return (SerializableFunction<Struct, Row>)\n+          input ->\n+              Row.withSchema(Schema.builder().addInt64Field(\"Key\").build())\n+                  .withFieldValue(\"Key\", 3L)\n+                  .build();\n+    }\n+  }\n+\n+  public static class ReadRows extends PTransform<PBegin, PCollection<Row>> {\n+    Read read;\n+    Schema schema;\n+\n+    public ReadRows(Read read, Schema schema) {\n+      super(\"Read rows\");\n+      this.read = read;\n+      this.schema = schema;\n+    }\n+\n+    @Override\n+    public PCollection<Row> expand(PBegin input) {\n+      return input\n+          .apply(read)\n+          .apply(\n+              MapElements.into(TypeDescriptor.of(Row.class))\n+                  .via(\n+                      new SerializableFunction<Struct, Row>() {\n+                        @Override\n+                        public Row apply(Struct struct) {\n+                          return StructUtils.translateStructToRow(struct, schema);\n+                        }\n+                      }))\n+          .setRowSchema(schema)\n+          .setCoder(RowCoder.of(schema));", "originalCommit": "fed767a2904c0c8ac4f1ae18d5461367beb985ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA3MDMyNQ==", "url": "https://github.com/apache/beam/pull/12611#discussion_r482070325", "bodyText": "For some reason it was not obvious to me. Done.", "author": "piotr-szuberski", "createdAt": "2020-09-02T13:31:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDM5NjA0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQyOTQ0MQ==", "url": "https://github.com/apache/beam/pull/12611#discussion_r480429441", "bodyText": "It would be really great if SpannerIO.ReadRows could determine the schema at pipeline construction time so the user doesn't have to specify it. In SpannerIO.Read#expand we require the user to specify either a query or a list of columns: \n  \n    \n      beam/sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/spanner/SpannerIO.java\n    \n    \n        Lines 656 to 671\n      in\n      2872e37\n    \n    \n    \n    \n\n        \n          \n           if (getReadOperation().getQuery() != null) { \n        \n\n        \n          \n             // TODO: validate query? \n        \n\n        \n          \n           } else if (getReadOperation().getTable() != null) { \n        \n\n        \n          \n             // Assume read \n        \n\n        \n          \n             checkNotNull( \n        \n\n        \n          \n                 getReadOperation().getColumns(), \n        \n\n        \n          \n                 \"For a read operation SpannerIO.read() requires a list of \" \n        \n\n        \n          \n                     + \"columns to set with withColumns method\"); \n        \n\n        \n          \n             checkArgument( \n        \n\n        \n          \n                 !getReadOperation().getColumns().isEmpty(), \n        \n\n        \n          \n                 \"For a read operation SpannerIO.read() requires a\" \n        \n\n        \n          \n                     + \" list of columns to set with withColumns method\"); \n        \n\n        \n          \n           } else { \n        \n\n        \n          \n             throw new IllegalArgumentException( \n        \n\n        \n          \n                 \"SpannerIO.read() requires configuring query or read operation.\"); \n        \n\n        \n          \n           } \n        \n    \n  \n\n\nIn both case we're very close to a schema. We just need to analyze the query and/or get the output types for the projected columns. I looked into it a little bit, but I'm not quite sure the best way to use the spanner client to look up the schema. The only thing I could figure out was to start a read and look at the type of ResultSet#getCurrentRowAsStruct which seems less than ideal.\nCC @nielm who's done some work with SpannerIO recently - do you have any suggestions for a way to determine the types of the Structs that SpannerIO.Read will produce?", "author": "TheNeuralBit", "createdAt": "2020-08-31T22:16:32Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/spanner/SpannerIO.java", "diffHunk": "@@ -678,6 +703,42 @@ public Read withPartitionOptions(PartitionOptions partitionOptions) {\n               .withTransaction(getTransaction());\n       return input.apply(Create.of(getReadOperation())).apply(\"Execute query\", readAll);\n     }\n+\n+    SerializableFunction<Struct, Row> getFormatFn() {\n+      return (SerializableFunction<Struct, Row>)\n+          input ->\n+              Row.withSchema(Schema.builder().addInt64Field(\"Key\").build())\n+                  .withFieldValue(\"Key\", 3L)\n+                  .build();\n+    }\n+  }\n+\n+  public static class ReadRows extends PTransform<PBegin, PCollection<Row>> {\n+    Read read;\n+    Schema schema;\n+\n+    public ReadRows(Read read, Schema schema) {\n+      super(\"Read rows\");\n+      this.read = read;\n+      this.schema = schema;", "originalCommit": "fed767a2904c0c8ac4f1ae18d5461367beb985ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQyOTkxMA==", "url": "https://github.com/apache/beam/pull/12611#discussion_r480429910", "bodyText": "We could also punt on this question and file a jira with a TODO here. I recognize this is a little out of scope for BEAM-10139, BEAM-10140.", "author": "TheNeuralBit", "createdAt": "2020-08-31T22:18:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQyOTQ0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA3Mzg5OQ==", "url": "https://github.com/apache/beam/pull/12611#discussion_r482073899", "bodyText": "I'd really like to do it in this PR, but the only thing that comes to mind is to do what you said - perform the read request with client and then read the schema. The obvious disadvantage is that the Spanner query will be executed twice. I researched that limit of 1 row added to the end of query will not improve the performance so this is not the thing to do for huge result sets", "author": "piotr-szuberski", "createdAt": "2020-09-02T13:36:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQyOTQ0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMxNTA1OQ==", "url": "https://github.com/apache/beam/pull/12611#discussion_r483315059", "bodyText": "I can reach out to the Spanner team to see if there's a good way to do this, I'll let you know if I learn anything. For now we can just plan on a jira and a TODO", "author": "TheNeuralBit", "createdAt": "2020-09-04T00:04:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQyOTQ0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA2NjczMw==", "url": "https://github.com/apache/beam/pull/12611#discussion_r501066733", "bodyText": "I don't see any good solution here...\nWhen reading an entire table, it could be possible to read the table's schema first, and determine what types the columns are, but this does not work for a query as the query output columns may not correspond to table columns.\nAdding LIMIT 1 would only work for simple queries, anything with joins, GROUP BY, ORDER BY will require the majority of the query to be executed before a single row is returned.\nSo the only solution I can see is for the caller to specify the row Schema as you do here..", "author": "nielm", "createdAt": "2020-10-07T14:38:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQyOTQ0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM3OTI0NQ==", "url": "https://github.com/apache/beam/pull/12611#discussion_r501379245", "bodyText": "It seems like it should be possible to analyze the query and determine the output schema, SqlTransform and JdbcIO both do this.\nI got a similar response from my internal queries though, it doesn't look like there's a good way to do this with the Spanner client", "author": "TheNeuralBit", "createdAt": "2020-10-08T00:11:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQyOTQ0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY3NjE0Ng==", "url": "https://github.com/apache/beam/pull/12611#discussion_r501676146", "bodyText": "Thank you @nielm ! I thought about the LIMIT approach but then I found the same arguments not to do that.\nIt appears there exist a jdbc client for Spanner: https://cloud.google.com/spanner/docs/jdbc-drivers . I'll try to figure out if I can use it.\nThere is ResultSetMetadata in Spanner's REST API which extends json object. https://cloud.google.com/spanner/docs/reference/rest/v1/ResultSetMetadata but at the end of the day it requires at least partially to fetch the data.\nBut I would leave it for another PR as it supposedly require to move SchemaUtils from io/jdbc to some more general place (extensions/sql?). As I can see Struct type is mapped to String/Varchar as is mentioned in the FAQ, so it may not be the best option\nThe Cloud Spanner STRUCT data type is mapped to a SQL VARCHAR data type, accessible through \nthis driver as String types. All other types have appropriate mappings.", "author": "piotr-szuberski", "createdAt": "2020-10-08T12:21:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQyOTQ0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQzMTcxNA==", "url": "https://github.com/apache/beam/pull/12611#discussion_r480431714", "bodyText": "This is lossy isn't it? I think we should just refuse to convert DECIMAL since Spanner doesn't have a corresponding type: https://cloud.google.com/spanner/docs/data-types#allowable_types", "author": "TheNeuralBit", "createdAt": "2020-08-31T22:23:00Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/spanner/StructUtils.java", "diffHunk": "@@ -0,0 +1,545 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.spanner;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+\n+import com.google.cloud.ByteArray;\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.Struct;\n+import com.google.cloud.spanner.Type;\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.values.Row;\n+import org.joda.time.DateTime;\n+import org.joda.time.Instant;\n+\n+final class StructUtils {\n+  public static Row translateStructToRow(Struct struct, Schema schema) {\n+    checkForSchemasEquality(schema.getFields(), struct.getType().getStructFields(), false);\n+\n+    List<Schema.Field> fields = schema.getFields();\n+    Row.FieldValueBuilder valueBuilder = null;\n+    // TODO: Remove this null-checking once nullable fields are supported in cross-language\n+    int count = 0;\n+    while (valueBuilder == null && count < fields.size()) {\n+      valueBuilder = getFirstStructValue(struct, fields.get(count), schema);\n+      ++count;\n+    }\n+    for (int i = count; i < fields.size(); ++i) {\n+      valueBuilder = getStructValue(valueBuilder, struct, fields.get(i));\n+    }\n+    return valueBuilder != null ? valueBuilder.build() : Row.withSchema(schema).build();\n+  }\n+\n+  public static Struct translateRowToStruct(Row row) {\n+    Struct.Builder structBuilder = Struct.newBuilder();\n+    List<Schema.Field> fields = row.getSchema().getFields();\n+    fields.forEach(\n+        field -> {\n+          String column = field.getName();\n+          switch (field.getType().getTypeName()) {\n+            case ROW:\n+              structBuilder\n+                  .set(column)\n+                  .to(\n+                      beamTypeToSpannerType(field.getType()),\n+                      translateRowToStruct(row.getRow(column)));\n+              break;\n+            case ARRAY:\n+              addArrayToStruct(structBuilder, row, field);\n+              break;\n+            case ITERABLE:\n+              addIterableToStruct(structBuilder, row, field);\n+              break;\n+            case FLOAT:\n+              structBuilder.set(column).to(row.getFloat(column).doubleValue());\n+              break;\n+            case DOUBLE:\n+              structBuilder.set(column).to(row.getDouble(column));\n+              break;\n+            case DECIMAL:\n+              structBuilder.set(column).to(row.getDecimal(column).doubleValue());", "originalCommit": "fed767a2904c0c8ac4f1ae18d5461367beb985ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA3NTQ4OQ==", "url": "https://github.com/apache/beam/pull/12611#discussion_r482075489", "bodyText": "I agree, at first I didn't include decimals but it definitely is lossy.", "author": "piotr-szuberski", "createdAt": "2020-09-02T13:38:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQzMTcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTA2NzUzNg==", "url": "https://github.com/apache/beam/pull/12611#discussion_r501067536", "bodyText": "Spanner now supports NUMERIC which may be a better conversion?", "author": "nielm", "createdAt": "2020-10-07T14:39:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQzMTcxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTY3NzA4Ng==", "url": "https://github.com/apache/beam/pull/12611#discussion_r501677086", "bodyText": "Great, quite a new thing in Spanner as I can see! Thanks! Done.", "author": "piotr-szuberski", "createdAt": "2020-10-08T12:22:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQzMTcxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ0MDg3NQ==", "url": "https://github.com/apache/beam/pull/12611#discussion_r480440875", "bodyText": "woo this is a hefty class for type conversions! It does seem like there's a lot of duplicated logic, what's preventing us from combining more of it?", "author": "TheNeuralBit", "createdAt": "2020-08-31T22:37:14Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/spanner/StructUtils.java", "diffHunk": "@@ -0,0 +1,545 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.spanner;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+\n+import com.google.cloud.ByteArray;\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.Struct;\n+import com.google.cloud.spanner.Type;\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.values.Row;\n+import org.joda.time.DateTime;\n+import org.joda.time.Instant;\n+\n+final class StructUtils {", "originalCommit": "fed767a2904c0c8ac4f1ae18d5461367beb985ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA3OTg2MA==", "url": "https://github.com/apache/beam/pull/12611#discussion_r482079860", "bodyText": "There are non-related different classes that require the same things to be done on them.\nOne of them are Key and Mutation, other one Row.Builder and Row.FieldValueBuilder. In python there is duck typing and it's easy. But in Java I don't know how to reduce the repeated code. Maybe I should do more setValue(Object obj) and depend on castings instead of returning the proper type all the time. I'll try it.", "author": "piotr-szuberski", "createdAt": "2020-09-02T13:44:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ0MDg3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ0NjY0OA==", "url": "https://github.com/apache/beam/pull/12611#discussion_r480446648", "bodyText": "Another reason to get the schema eagerly at pipeline construction time, this is an expensive operation to be doing for every Struct that we read.", "author": "TheNeuralBit", "createdAt": "2020-08-31T22:45:50Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/spanner/StructUtils.java", "diffHunk": "@@ -0,0 +1,545 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.spanner;\n+\n+import static java.util.stream.Collectors.toList;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+\n+import com.google.cloud.ByteArray;\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.Struct;\n+import com.google.cloud.spanner.Type;\n+import java.math.BigDecimal;\n+import java.util.List;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.values.Row;\n+import org.joda.time.DateTime;\n+import org.joda.time.Instant;\n+\n+final class StructUtils {\n+  public static Row translateStructToRow(Struct struct, Schema schema) {\n+    checkForSchemasEquality(schema.getFields(), struct.getType().getStructFields(), false);", "originalCommit": "fed767a2904c0c8ac4f1ae18d5461367beb985ab", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MjA4MDMyNA==", "url": "https://github.com/apache/beam/pull/12611#discussion_r482080324", "bodyText": "Maybe we could just skip this check and let it crash when the types don't match?", "author": "piotr-szuberski", "createdAt": "2020-09-02T13:45:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MDQ0NjY0OA=="}], "type": "inlineReview"}, {"oid": "55ee406ad3cd25838165b211683926f1ba80ad7c", "url": "https://github.com/apache/beam/commit/55ee406ad3cd25838165b211683926f1ba80ad7c", "message": "Remove redundant setCoder", "committedDate": "2020-09-02T13:50:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMxNjcwNg==", "url": "https://github.com/apache/beam/pull/12611#discussion_r483316706", "bodyText": "FYI now with #12481 it's possible to use schema inference for these configuration objects, so you should be able to use @AutoValue and AutoValueSchema which could save a lot of boiler plate There's an example here:\n\n  \n    \n      beam/sdks/java/expansion-service/src/test/java/org/apache/beam/sdk/expansion/service/ExpansionServiceTest.java\n    \n    \n        Lines 305 to 315\n      in\n      89a2d17\n    \n    \n    \n    \n\n        \n          \n           @DefaultSchema(AutoValueSchema.class) \n        \n\n        \n          \n           @AutoValue \n        \n\n        \n          \n           abstract static class TestConfigSchema { \n        \n\n        \n          \n             abstract @Nullable Long getConfigKey1(); \n        \n\n        \n          \n            \n        \n\n        \n          \n             abstract @Nullable Iterable<byte[]> getConfigKey2(); \n        \n\n        \n          \n            \n        \n\n        \n          \n             abstract @Nullable Map<String, Long> getConfigKey3(); \n        \n\n        \n          \n            \n        \n\n        \n          \n             abstract @Nullable Map<String, List<Long>> getConfigKey4(); \n        \n\n        \n          \n           } \n        \n    \n  \n\n\n(it's fine to leave it as-is, just letting you know)", "author": "TheNeuralBit", "createdAt": "2020-09-04T00:10:03Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/spanner/SpannerTransformRegistrar.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.spanner;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.TimestampBound;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.beam.model.pipeline.v1.SchemaApi;\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.annotations.Experimental.Kind;\n+import org.apache.beam.sdk.expansion.ExternalTransformRegistrar;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.schemas.SchemaTranslation;\n+import org.apache.beam.sdk.transforms.ExternalTransformBuilder;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.values.PBegin;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PDone;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.InvalidProtocolBufferException;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.joda.time.Duration;\n+\n+/**\n+ * Exposes {@link SpannerIO.WriteRows} and {@link SpannerIO.ReadRows} as an external transform for\n+ * cross-language usage.\n+ */\n+@Experimental(Kind.PORTABILITY)\n+@AutoService(ExternalTransformRegistrar.class)\n+public class SpannerTransformRegistrar implements ExternalTransformRegistrar {\n+  public static final String WRITE_URN = \"beam:external:java:spanner:write:v1\";\n+  public static final String READ_URN = \"beam:external:java:spanner:read:v1\";\n+\n+  @Override\n+  public Map<String, ExternalTransformBuilder<?, ?, ?>> knownBuilderInstances() {\n+    return ImmutableMap.of(WRITE_URN, new WriteBuilder(), READ_URN, new ReadBuilder());\n+  }\n+\n+  public abstract static class CrossLanguageConfiguration {\n+    String instanceId;\n+    String databaseId;\n+    String projectId;\n+    @Nullable String host;\n+    @Nullable String emulatorHost;\n+\n+    public void setInstanceId(String instanceId) {\n+      this.instanceId = instanceId;\n+    }\n+\n+    public void setDatabaseId(String databaseId) {\n+      this.databaseId = databaseId;\n+    }\n+\n+    public void setProjectId(String projectId) {\n+      this.projectId = projectId;\n+    }\n+\n+    public void setHost(@Nullable String host) {\n+      this.host = host;\n+    }\n+\n+    public void setEmulatorHost(@Nullable String emulatorHost) {\n+      this.emulatorHost = emulatorHost;\n+    }\n+  }\n+\n+  @Experimental(Kind.PORTABILITY)\n+  public static class ReadBuilder\n+      implements ExternalTransformBuilder<ReadBuilder.Configuration, PBegin, PCollection<Row>> {\n+\n+    public static class Configuration extends CrossLanguageConfiguration {\n+      // TODO: BEAM-10851 Come up with something to determine schema without this explicit parameter\n+      private Schema schema;\n+      private @Nullable String sql;\n+      private @Nullable String table;\n+      private @Nullable Boolean batching;\n+      private @Nullable String timestampBoundMode;\n+      private @Nullable String readTimestamp;\n+      private @Nullable String timeUnit;\n+      private @Nullable Long exactStaleness;\n+\n+      public void setSql(@Nullable String sql) {\n+        this.sql = sql;\n+      }\n+\n+      public void setTable(@Nullable String table) {\n+        this.table = table;\n+      }\n+\n+      public void setBatching(@Nullable Boolean batching) {\n+        this.batching = batching;\n+      }\n+\n+      public void setTimestampBoundMode(@Nullable String timestampBoundMode) {\n+        this.timestampBoundMode = timestampBoundMode;\n+      }\n+\n+      public void setSchema(byte[] schema) throws InvalidProtocolBufferException {\n+        this.schema = SchemaTranslation.schemaFromProto(SchemaApi.Schema.parseFrom(schema));\n+      }\n+\n+      public void setReadTimestamp(@Nullable String readTimestamp) {\n+        this.readTimestamp = readTimestamp;\n+      }\n+\n+      public void setTimeUnit(@Nullable String timeUnit) {\n+        this.timeUnit = timeUnit;\n+      }\n+\n+      public void setExactStaleness(@Nullable Long exactStaleness) {\n+        this.exactStaleness = exactStaleness;\n+      }\n+\n+      private TimestampBound getTimestampBound() {\n+        if (timestampBoundMode == null) {\n+          return null;\n+        }\n+\n+        TimestampBound.Mode mode = TimestampBound.Mode.valueOf(timestampBoundMode);\n+        if (mode == TimestampBound.Mode.MAX_STALENESS\n+            || mode == TimestampBound.Mode.EXACT_STALENESS) {\n+          checkArgument(\n+              exactStaleness != null,\n+              \"Staleness value cannot be null when MAX_STALENESS or EXACT_STALENESS mode is selected\");\n+          checkArgument(\n+              timeUnit != null,\n+              \"Time unit cannot be null when MAX_STALENESS or EXACT_STALENESS mode is selected\");\n+        }\n+        if (mode == TimestampBound.Mode.READ_TIMESTAMP\n+            || mode == TimestampBound.Mode.MIN_READ_TIMESTAMP) {\n+          checkArgument(\n+              readTimestamp != null,\n+              \"Timestamp cannot be null when READ_TIMESTAMP or MIN_READ_TIMESTAMP mode is selected\");\n+        }\n+        switch (mode) {\n+          case STRONG:\n+            return TimestampBound.strong();\n+          case MAX_STALENESS:\n+            return TimestampBound.ofMaxStaleness(exactStaleness, TimeUnit.valueOf(timeUnit));\n+          case EXACT_STALENESS:\n+            return TimestampBound.ofExactStaleness(exactStaleness, TimeUnit.valueOf(timeUnit));\n+          case READ_TIMESTAMP:\n+            return TimestampBound.ofReadTimestamp(Timestamp.parseTimestamp(readTimestamp));\n+          case MIN_READ_TIMESTAMP:\n+            return TimestampBound.ofMinReadTimestamp(Timestamp.parseTimestamp(readTimestamp));\n+          default:\n+            throw new RuntimeException(\"Unknown timestamp bound mode: \" + mode);\n+        }\n+      }\n+\n+      public ReadOperation getReadOperation() {\n+        checkArgument(\n+            sql == null || table == null,\n+            \"Query and table params are mutually exclusive. Set just one of them.\");\n+        if (sql != null) {\n+          return ReadOperation.create().withQuery(sql);\n+        }\n+        return ReadOperation.create().withTable(table).withColumns(schema.getFieldNames());\n+      }\n+    }\n+\n+    @Override\n+    public PTransform<PBegin, PCollection<Row>> buildExternal(Configuration configuration) {\n+      SpannerIO.Read readTransform =\n+          SpannerIO.read()\n+              .withProjectId(configuration.projectId)\n+              .withDatabaseId(configuration.databaseId)\n+              .withInstanceId(configuration.instanceId)\n+              .withReadOperation(configuration.getReadOperation());\n+\n+      if (configuration.host != null) {\n+        readTransform = readTransform.withHost(configuration.host);\n+      }\n+      if (configuration.emulatorHost != null) {\n+        readTransform = readTransform.withEmulatorHost(configuration.emulatorHost);\n+      }\n+      if (configuration.getTimestampBound() != null) {\n+        readTransform = readTransform.withTimestampBound(configuration.getTimestampBound());\n+      }\n+      if (configuration.batching != null) {\n+        readTransform = readTransform.withBatching(configuration.batching);\n+      }\n+\n+      return new SpannerIO.ReadRows(readTransform, configuration.schema);\n+    }\n+  }\n+\n+  @Experimental(Kind.PORTABILITY)\n+  public static class WriteBuilder\n+      implements ExternalTransformBuilder<WriteBuilder.Configuration, PCollection<Row>, PDone> {\n+\n+    public static class Configuration extends CrossLanguageConfiguration {", "originalCommit": "5feb3d9332e2da6caeeae15822e725b8ef5122be", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU3NDgwMA==", "url": "https://github.com/apache/beam/pull/12611#discussion_r483574800", "bodyText": "Many setters have some logic inside them and AutoValue does not allow inheritance so there would be some code duplication in getter methods. As this is just a cosmetic thing and I have other things to do I'll leave it as it is for now.", "author": "piotr-szuberski", "createdAt": "2020-09-04T12:08:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMxNjcwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODMxNDQ5Mg==", "url": "https://github.com/apache/beam/pull/12611#discussion_r488314492", "bodyText": "Sounds good", "author": "TheNeuralBit", "createdAt": "2020-09-15T00:41:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzMxNjcwNg=="}], "type": "inlineReview"}, {"oid": "c24e8cba7bd09a20f4eae37dc84e4ac764105296", "url": "https://github.com/apache/beam/commit/c24e8cba7bd09a20f4eae37dc84e4ac764105296", "message": "Fix docstrings", "committedDate": "2020-09-08T09:43:47Z", "type": "forcePushed"}, {"oid": "1c43284593c2f7350b67b3ddb1878cb521ced284", "url": "https://github.com/apache/beam/commit/1c43284593c2f7350b67b3ddb1878cb521ced284", "message": "Add support for numeric type", "committedDate": "2020-10-08T12:19:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYxMTU4Mg==", "url": "https://github.com/apache/beam/pull/12611#discussion_r502611582", "bodyText": "Please add some documentation about the mapping from Mutation to Beam schemas, I think this would be the appropriate place. You might duplicate the doc somewhere in the Python code as well, or just reference this.", "author": "TheNeuralBit", "createdAt": "2020-10-09T18:43:56Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/spanner/MutationUtils.java", "diffHunk": "@@ -34,4 +49,237 @@ public static boolean isPointDelete(Mutation m) {\n         && Iterables.isEmpty(m.getKeySet().getRanges())\n         && Iterables.size(m.getKeySet().getKeys()) == 1;\n   }\n+\n+  /**\n+   * Utility function to convert row to mutation.\n+   *\n+   * @return function that can convert row to mutation\n+   */\n+  public static SerializableFunction<Row, Mutation> beamRowToMutationFn() {", "originalCommit": "1c43284593c2f7350b67b3ddb1878cb521ced284", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY5MzA1NQ==", "url": "https://github.com/apache/beam/pull/12611#discussion_r505693055", "bodyText": "Done. I hope it's not too brief.", "author": "piotr-szuberski", "createdAt": "2020-10-15T16:50:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYxMTU4Mg=="}], "type": "inlineReview"}, {"oid": "159def6e6fbf46bf7c7894d1d7008fa4a032e1f7", "url": "https://github.com/apache/beam/commit/159def6e6fbf46bf7c7894d1d7008fa4a032e1f7", "message": "Change test method names", "committedDate": "2020-10-15T16:48:57Z", "type": "forcePushed"}, {"oid": "a120f310a671a484d55b1867d48e840860f1ee12", "url": "https://github.com/apache/beam/commit/a120f310a671a484d55b1867d48e840860f1ee12", "message": "Add missing imports", "committedDate": "2020-10-16T08:23:07Z", "type": "forcePushed"}, {"oid": "8f64294c4505134d1077548047fc486d3c9f12d5", "url": "https://github.com/apache/beam/commit/8f64294c4505134d1077548047fc486d3c9f12d5", "message": "Move tests to apache_beam.io.gcp.tests", "committedDate": "2020-10-26T18:19:45Z", "type": "forcePushed"}, {"oid": "e07de53266518ff4751bf9baf91a85aa8a1bedbd", "url": "https://github.com/apache/beam/commit/e07de53266518ff4751bf9baf91a85aa8a1bedbd", "message": "Move tests to apache_beam.io.gcp.tests", "committedDate": "2020-10-26T18:25:45Z", "type": "forcePushed"}, {"oid": "a5af89435211f3122912f6ee3a85a3d08a8777a7", "url": "https://github.com/apache/beam/commit/a5af89435211f3122912f6ee3a85a3d08a8777a7", "message": "Remove lambdas", "committedDate": "2020-10-26T20:23:57Z", "type": "forcePushed"}, {"oid": "b76a62a12d622ebc523146d587feb786e7d4e29e", "url": "https://github.com/apache/beam/commit/b76a62a12d622ebc523146d587feb786e7d4e29e", "message": "Remove lambdas", "committedDate": "2020-10-26T21:39:21Z", "type": "forcePushed"}, {"oid": "537aa7faf89ed3131bf792384fa0a631f4d931a7", "url": "https://github.com/apache/beam/commit/537aa7faf89ed3131bf792384fa0a631f4d931a7", "message": "change to environment_config = None instead od choosing docker", "committedDate": "2020-10-27T11:25:23Z", "type": "forcePushed"}, {"oid": "46e0f1a632c9ff3416d0a64d1fc166bcc6ffc411", "url": "https://github.com/apache/beam/commit/46e0f1a632c9ff3416d0a64d1fc166bcc6ffc411", "message": "Move spanner tests to apache_beam.io.gcp.tests", "committedDate": "2020-10-27T14:31:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIxMDE3NA==", "url": "https://github.com/apache/beam/pull/12611#discussion_r520210174", "bodyText": "What I had in mind was that there would be a separate URN for each possible write operation like beam:external:java:spanner:delete, beam:external:java:spanner:insert_or_update, ...\nRather than accepting mutations encoded as rows to go over the xlang boundary, each of these transforms would have an input of just  PCollection<Row> representing the actual data (or PCollection<List<Row>> representing the keyset in the Delete case). Then python doesn't even need to have a concept of mutations.\nThere's definitely value in a generic beam:external:java:spanner:write transform which accepts arbitrary mutations, but I think we should leave that for future work.", "author": "TheNeuralBit", "createdAt": "2020-11-10T00:36:11Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/spanner/SpannerTransformRegistrar.java", "diffHunk": "@@ -0,0 +1,287 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.spanner;\n+\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+\n+import com.google.auto.service.AutoService;\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.TimestampBound;\n+import java.util.Map;\n+import java.util.concurrent.TimeUnit;\n+import org.apache.beam.model.pipeline.v1.SchemaApi;\n+import org.apache.beam.sdk.annotations.Experimental;\n+import org.apache.beam.sdk.annotations.Experimental.Kind;\n+import org.apache.beam.sdk.expansion.ExternalTransformRegistrar;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.schemas.SchemaTranslation;\n+import org.apache.beam.sdk.transforms.ExternalTransformBuilder;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.values.PBegin;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PDone;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.vendor.grpc.v1p26p0.com.google.protobuf.InvalidProtocolBufferException;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.joda.time.Duration;\n+\n+/**\n+ * Exposes {@link SpannerIO.WriteRows} and {@link SpannerIO.ReadRows} as an external transform for\n+ * cross-language usage.\n+ */\n+@Experimental(Kind.PORTABILITY)\n+@AutoService(ExternalTransformRegistrar.class)\n+public class SpannerTransformRegistrar implements ExternalTransformRegistrar {\n+  public static final String WRITE_URN = \"beam:external:java:spanner:write:v1\";\n+  public static final String READ_URN = \"beam:external:java:spanner:read:v1\";\n+\n+  @Override\n+  public Map<String, ExternalTransformBuilder<?, ?, ?>> knownBuilderInstances() {\n+    return ImmutableMap.of(WRITE_URN, new WriteBuilder(), READ_URN, new ReadBuilder());", "originalCommit": "356788f69b56cd7ead4c95c94d589dcea71b7e20", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjA1MjkxNQ==", "url": "https://github.com/apache/beam/pull/12611#discussion_r522052915", "bodyText": "That makes sense. Done.", "author": "piotr-szuberski", "createdAt": "2020-11-12T11:58:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMDIxMDE3NA=="}], "type": "inlineReview"}, {"oid": "1602c262fd2d8ba1f008c9bda32d99d5b0dd21b3", "url": "https://github.com/apache/beam/commit/1602c262fd2d8ba1f008c9bda32d99d5b0dd21b3", "message": "[BEAM-10139][BEAM-10140] Add Support for cross-language transforms with python wrapper to Java SpannerIO", "committedDate": "2020-11-12T08:54:25Z", "type": "commit"}, {"oid": "1602c262fd2d8ba1f008c9bda32d99d5b0dd21b3", "url": "https://github.com/apache/beam/commit/1602c262fd2d8ba1f008c9bda32d99d5b0dd21b3", "message": "[BEAM-10139][BEAM-10140] Add Support for cross-language transforms with python wrapper to Java SpannerIO", "committedDate": "2020-11-12T08:54:25Z", "type": "forcePushed"}, {"oid": "17248f3fa0871e2b193dd8d56ce89f0eda3b4fb6", "url": "https://github.com/apache/beam/commit/17248f3fa0871e2b193dd8d56ce89f0eda3b4fb6", "message": "Change docstrings to use named parameters", "committedDate": "2020-11-12T09:40:13Z", "type": "commit"}, {"oid": "9efa8c7106b2dfd3838bf9c105956e1ed8e93551", "url": "https://github.com/apache/beam/commit/9efa8c7106b2dfd3838bf9c105956e1ed8e93551", "message": "Update Read docstring", "committedDate": "2020-11-12T14:33:15Z", "type": "forcePushed"}, {"oid": "72286222229f5984b7244722f15b7dac3ae7ed22", "url": "https://github.com/apache/beam/commit/72286222229f5984b7244722f15b7dac3ae7ed22", "message": "Remove mutation row concept from write operations", "committedDate": "2020-11-12T14:49:42Z", "type": "forcePushed"}, {"oid": "3a153aedd7220ba962e74d081758b2eda2ee825f", "url": "https://github.com/apache/beam/commit/3a153aedd7220ba962e74d081758b2eda2ee825f", "message": "Remove mutation row concept from write operations", "committedDate": "2020-11-12T18:20:58Z", "type": "commit"}, {"oid": "3a153aedd7220ba962e74d081758b2eda2ee825f", "url": "https://github.com/apache/beam/commit/3a153aedd7220ba962e74d081758b2eda2ee825f", "message": "Remove mutation row concept from write operations", "committedDate": "2020-11-12T18:20:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ3MDkyOA==", "url": "https://github.com/apache/beam/pull/12611#discussion_r522470928", "bodyText": "Could you try to address any lingering nullness errors here and in the other files that have it suppressed? If there are any intractable issues we could consider a smaller @SuppressWarnings blocks around a few functions, but in general we should make sure that new classes pass the null checker.", "author": "TheNeuralBit", "createdAt": "2020-11-12T22:25:32Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/spanner/StructUtils.java", "diffHunk": "@@ -0,0 +1,301 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.spanner;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import com.google.cloud.ByteArray;\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.Struct;\n+import com.google.cloud.spanner.Type;\n+import java.math.BigDecimal;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.values.Row;\n+import org.joda.time.DateTime;\n+import org.joda.time.Instant;\n+\n+@SuppressWarnings({\n+  \"nullness\" // TODO(https://issues.apache.org/jira/browse/BEAM-10402)\n+})", "originalCommit": "3a153aedd7220ba962e74d081758b2eda2ee825f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzAyNDc4OA==", "url": "https://github.com/apache/beam/pull/12611#discussion_r523024788", "bodyText": "Done. Oh, it was quite painful as all of the row getters return a @nullable value. Especially that checkNotNull doesn't work with the checker and there is even no possibility to check for null in a function (only if (var == null) { throw new NullPointerException(\"Null var\"); } seem to work.\nIt doesn't even work in chained functions as in this example:\n@Nullable Object var = new Object();\nif (var != null) {\n  someObject.doSth().doChained(var); // checker doesn't understand that var is checked for nullness)\n}\n\nSo it's quite unfriendly. In general I'm really excited about dealing with NPE problem, but for now it adds much more complexity and reduces the contributor friendliness. But I guess that it's worth it, especially when the checker gets smarter and will work with the Guava checks and chained functions (if it's even possible?)", "author": "piotr-szuberski", "createdAt": "2020-11-13T15:30:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQ3MDkyOA=="}], "type": "inlineReview"}, {"oid": "d9a8342e1e702b84dfc2edafb697dff3af58a968", "url": "https://github.com/apache/beam/commit/d9a8342e1e702b84dfc2edafb697dff3af58a968", "message": "exactStaleness -> staleness", "committedDate": "2020-11-13T14:10:06Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA5MjA3Mw==", "url": "https://github.com/apache/beam/pull/12611#discussion_r523092073", "bodyText": "Let's make these null checks use org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkNotNull, that will be a bit more concise, and it avoids throwing an NPE", "author": "TheNeuralBit", "createdAt": "2020-11-13T17:08:28Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/spanner/StructUtils.java", "diffHunk": "@@ -0,0 +1,380 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.spanner;\n+\n+import static java.util.stream.Collectors.toList;\n+\n+import com.google.cloud.ByteArray;\n+import com.google.cloud.Timestamp;\n+import com.google.cloud.spanner.Struct;\n+import com.google.cloud.spanner.Type;\n+import java.math.BigDecimal;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.StreamSupport;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.values.Row;\n+import org.checkerframework.checker.nullness.qual.Nullable;\n+import org.joda.time.DateTime;\n+import org.joda.time.Instant;\n+import org.joda.time.ReadableDateTime;\n+\n+final class StructUtils {\n+  public static Row structToBeamRow(Struct struct, Schema schema) {\n+    Map<String, Object> structValues =\n+        schema.getFields().stream()\n+            .collect(\n+                HashMap::new,\n+                (map, field) -> {\n+                  @Nullable Object structValue = getStructValue(struct, field);\n+                  if (structValue == null) {\n+                    throw new NullPointerException(\"Null struct value at field \" + field.getName());\n+                  }\n+                  map.put(field.getName(), structValue);\n+                },\n+                Map::putAll);\n+    return Row.withSchema(schema).withFieldValues(structValues).build();\n+  }\n+\n+  public static Struct beamRowToStruct(Row row) {\n+    Struct.Builder structBuilder = Struct.newBuilder();\n+    List<Schema.Field> fields = row.getSchema().getFields();\n+    fields.forEach(\n+        field -> {\n+          String column = field.getName();\n+          switch (field.getType().getTypeName()) {\n+            case ROW:\n+              @Nullable Row subRow = row.getRow(column);\n+              if (subRow == null) {\n+                throw new NullPointerException(String.format(\"Null subRow at '%s' column\", column));\n+              }", "originalCommit": "7eb457634c3f52fec3435ab0f185d47cc0644cb3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzEzMjk5OA==", "url": "https://github.com/apache/beam/pull/12611#discussion_r523132998", "bodyText": "Guava's checkNotNull doesn't work - checker doesn't consider fields checked this way as not nulls. It also isn't expected to throw anything so I get missing return statements in the switch statements. So for now I'd leave it throwing NPE.", "author": "piotr-szuberski", "createdAt": "2020-11-13T18:07:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA5MjA3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDQ2ODY2NA==", "url": "https://github.com/apache/beam/pull/12611#discussion_r524468664", "bodyText": "Ack, ok", "author": "TheNeuralBit", "createdAt": "2020-11-16T18:03:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzA5MjA3Mw=="}], "type": "inlineReview"}, {"oid": "2e1ad017fd87689888e59f13b6cb55e03b8a4fae", "url": "https://github.com/apache/beam/commit/2e1ad017fd87689888e59f13b6cb55e03b8a4fae", "message": "Add nulls instead of throwing NPE", "committedDate": "2020-11-13T18:11:57Z", "type": "forcePushed"}, {"oid": "d05e0e49b115efccfc935a9ff481a19e6a7f0b7f", "url": "https://github.com/apache/beam/commit/d05e0e49b115efccfc935a9ff481a19e6a7f0b7f", "message": "Add nulls instead of throwing NPE", "committedDate": "2020-11-13T20:46:35Z", "type": "forcePushed"}, {"oid": "aa73ae144a0c7ecb754a35082c86bfff841d4ad7", "url": "https://github.com/apache/beam/commit/aa73ae144a0c7ecb754a35082c86bfff841d4ad7", "message": "Add null values tests", "committedDate": "2020-11-14T04:52:10Z", "type": "forcePushed"}, {"oid": "315ef36141c947890ba9ec40dba39ab20107edad", "url": "https://github.com/apache/beam/commit/315ef36141c947890ba9ec40dba39ab20107edad", "message": "Deal with nullness", "committedDate": "2020-11-14T06:27:38Z", "type": "commit"}, {"oid": "6370a871eda29f61728e7a3ce49d884325b8a632", "url": "https://github.com/apache/beam/commit/6370a871eda29f61728e7a3ce49d884325b8a632", "message": "Remove deprecated javadoc", "committedDate": "2020-11-14T06:27:54Z", "type": "commit"}, {"oid": "6370a871eda29f61728e7a3ce49d884325b8a632", "url": "https://github.com/apache/beam/commit/6370a871eda29f61728e7a3ce49d884325b8a632", "message": "Remove deprecated javadoc", "committedDate": "2020-11-14T06:27:54Z", "type": "forcePushed"}]}