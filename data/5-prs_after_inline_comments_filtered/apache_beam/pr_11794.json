{"pr_number": 11794, "pr_title": "[BEAM-9894] Add batch SnowflakeIO.Write to Java SDK", "pr_createdAt": "2020-05-22T08:04:56Z", "pr_url": "https://github.com/apache/beam/pull/11794", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTEwNTI3NQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r429105275", "bodyText": "Note: This file was moved to services/SnowflakeServiceImpl.java", "author": "purbanow", "createdAt": "2020-05-22T08:11:05Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeServiceImpl.java", "diffHunk": "@@ -1,90 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing, software\n- * distributed under the License is distributed on an \"AS IS\" BASIS,\n- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n- * See the License for the specific language governing permissions and\n- * limitations under the License.\n- */\n-package org.apache.beam.sdk.io.snowflake;\n-\n-import java.sql.Connection;\n-import java.sql.PreparedStatement;\n-import java.sql.ResultSet;\n-import java.sql.SQLException;\n-import java.util.function.Consumer;\n-import javax.sql.DataSource;\n-import org.apache.beam.sdk.transforms.SerializableFunction;\n-\n-/**\n- * Implemenation of {@link org.apache.beam.sdk.io.snowflake.SnowflakeService} used in production.\n- */\n-public class SnowflakeServiceImpl implements SnowflakeService {", "originalCommit": "2bb48aa16c1a579a5e39d1f464f410769e5143b3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c845a2c9322dcdeab267beffc1eac707388eaa49", "url": "https://github.com/apache/beam/commit/c845a2c9322dcdeab267beffc1eac707388eaa49", "message": "[BEAM-9894] Add batch SnowflakeIO.Write to Java SDK", "committedDate": "2020-05-22T08:41:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxMjE3Mg==", "url": "https://github.com/apache/beam/pull/11794#discussion_r430612172", "bodyText": "I took only a very superficial look. Are you using CSV file imports to write to Snowflake? I would be concerned about types being properly encoded in the CSV (big integers, floats, bytes, date/time types, strings with newlines/quotes). Have you already considered how to deal with all types?", "author": "pabloem", "createdAt": "2020-05-26T18:14:11Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/CSVSink.java", "diffHunk": "@@ -0,0 +1,67 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.snowflake;\n+\n+import java.io.BufferedWriter;\n+import java.io.IOException;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.nio.channels.Channels;\n+import java.nio.channels.WritableByteChannel;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import org.apache.beam.sdk.io.FileIO;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Joiner;\n+\n+/** Implementation of {@link org.apache.beam.sdk.io.FileIO.Sink} for writing CSV. */\n+public class CSVSink implements FileIO.Sink<String> {", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4Njg4NQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r430886885", "bodyText": "Yes, we are using COPY INTO table with CSV format.\nCurrently, SnowflakeIO.write is constructed in a way that requires a particular table to exist in Snowflake before starting writing into Snowflake.\nIn one of the next Snowflake PR's we're planning to add the option for a user a possibility for passing table schema.", "author": "purbanow", "createdAt": "2020-05-27T06:34:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxMjE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5NjUxMg==", "url": "https://github.com/apache/beam/pull/11794#discussion_r430996512", "bodyText": "Just a little nitpick!  This class really has nothing to do with CSV, other than writing a header line.  If you're going to add a schema (orient it towards Beam Row for example), you might want to swap it out for an Avro or Parquet file storage!\nThis would be a big change.  If you were to make this class private to your implementation, do you think it would be possible to swap it out for a schema-capable format transparently later?", "author": "RyanSkraba", "createdAt": "2020-05-27T09:52:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxMjE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY1Mjc5Mw==", "url": "https://github.com/apache/beam/pull/11794#discussion_r433652793", "bodyText": "Thanks for spotting this. I removed CSVSink class and start using .via(TextIO.sink()) .", "author": "purbanow", "createdAt": "2020-06-02T06:42:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxMjE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzczOTM2NA==", "url": "https://github.com/apache/beam/pull/11794#discussion_r433739364", "bodyText": "In one of the PR's , we're planing to add create dispositions for tables  which is connected more with schema concept. Let's talk about it then :)", "author": "purbanow", "createdAt": "2020-06-02T09:22:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYxMjE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MzMwMA==", "url": "https://github.com/apache/beam/pull/11794#discussion_r430983300", "bodyText": "Not backwards compatible on a non-@Experimental class.  Some of these would be easy to implement on top of Location with a  @Deprecate tag?\n(My personal opinion would be not to worry too much about it... put @Experimental on the SnowflakeIO?)\nThat being said, refactoring the two into a Location POJO doesn't really add a LOT of value and it might be more worthwhile to put it back to two separate configs.  Up to you!", "author": "RyanSkraba", "createdAt": "2020-05-27T09:29:44Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeIO.java", "diffHunk": "@@ -172,10 +230,7 @@\n     abstract String getTable();\n \n     @Nullable\n-    abstract String getIntegrationName();", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYxODA3Ng==", "url": "https://github.com/apache/beam/pull/11794#discussion_r433618076", "bodyText": "As you suggested I added @experimental annotation + removed Location class", "author": "purbanow", "createdAt": "2020-06-02T04:48:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4MzMwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4NjM0Ng==", "url": "https://github.com/apache/beam/pull/11794#discussion_r430986346", "bodyText": "The original withStagingBucketName and withIntegrationName had some useful javadoc and links!", "author": "RyanSkraba", "createdAt": "2020-05-27T09:34:38Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/Location.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.snowflake;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Used as one of the arguments for {@link org.apache.beam.sdk.io.snowflake.SnowflakeIO} write and\n+ * read operations. It keeps information about storage integration and staging bucket name.\n+ * Integration name is Snowflake storage integration object created according to Snowflake\n+ * documentation for the GCS bucket. Staging bucket name is Google Cloud Storage bucket which in the\n+ * case of writing operation will be used to save CSV files which will end up in Snowflake under\n+ * \u201cstaging_bucket_name/data\u201d path and in the case of reading operation will be used as a temporary\n+ * location for storing CSV files named `sf_copy_csv_DATE_TIME_RANDOMSUFFIX` which will be removed\n+ * automatically once Read operation finishes.\n+ */\n+public class Location implements Serializable {\n+  private String storageIntegrationName;\n+  private String stagingBucketName;\n+\n+  public static Location of(SnowflakePipelineOptions options) {\n+    return new Location(options.getStorageIntegrationName(), options.getStagingBucketName());\n+  }\n+\n+  public static Location of(String storageIntegrationName, String stagingBucketName) {", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQxMzUyMQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r432413521", "bodyText": "I added removed link https://docs.snowflake.com/en/sql-reference/sql/create-storage-integration.html . Thanks", "author": "purbanow", "createdAt": "2020-05-29T11:07:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk4NjM0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5NzMwNg==", "url": "https://github.com/apache/beam/pull/11794#discussion_r430997306", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /** Snowflake IO data types. */\n          \n          \n            \n            /*\n          \n          \n            \n             * Licensed to the Apache Software Foundation (ASF) under one\n          \n          \n            \n             * or more contributor license agreements.  See the NOTICE file\n          \n          \n            \n             * distributed with this work for additional information\n          \n          \n            \n             * regarding copyright ownership.  The ASF licenses this file\n          \n          \n            \n             * to you under the Apache License, Version 2.0 (the\n          \n          \n            \n             * \"License\"); you may not use this file except in compliance\n          \n          \n            \n             * with the License.  You may obtain a copy of the License at\n          \n          \n            \n             *\n          \n          \n            \n             *     http://www.apache.org/licenses/LICENSE-2.0\n          \n          \n            \n             *\n          \n          \n            \n             * Unless required by applicable law or agreed to in writing, software\n          \n          \n            \n             * distributed under the License is distributed on an \"AS IS\" BASIS,\n          \n          \n            \n             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n          \n          \n            \n             * See the License for the specific language governing permissions and\n          \n          \n            \n             * limitations under the License.\n          \n          \n            \n             */\n          \n          \n            \n            \n          \n          \n            \n            /** Snowflake IO data types. */", "author": "RyanSkraba", "createdAt": "2020-05-27T09:53:27Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/enums/package-info.java", "diffHunk": "@@ -0,0 +1,2 @@\n+/** Snowflake IO data types. */", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQwNzg2Mg==", "url": "https://github.com/apache/beam/pull/11794#discussion_r432407862", "bodyText": "Thanks for spotting this \ud83d\udc4d", "author": "purbanow", "createdAt": "2020-05-29T10:54:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5NzMwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5NzU4Mw==", "url": "https://github.com/apache/beam/pull/11794#discussion_r430997583", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /** Snowflake IO services and POJOs. */\n          \n          \n            \n            /*\n          \n          \n            \n             * Licensed to the Apache Software Foundation (ASF) under one\n          \n          \n            \n             * or more contributor license agreements.  See the NOTICE file\n          \n          \n            \n             * distributed with this work for additional information\n          \n          \n            \n             * regarding copyright ownership.  The ASF licenses this file\n          \n          \n            \n             * to you under the Apache License, Version 2.0 (the\n          \n          \n            \n             * \"License\"); you may not use this file except in compliance\n          \n          \n            \n             * with the License.  You may obtain a copy of the License at\n          \n          \n            \n             *\n          \n          \n            \n             *     http://www.apache.org/licenses/LICENSE-2.0\n          \n          \n            \n             *\n          \n          \n            \n             * Unless required by applicable law or agreed to in writing, software\n          \n          \n            \n             * distributed under the License is distributed on an \"AS IS\" BASIS,\n          \n          \n            \n             * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n          \n          \n            \n             * See the License for the specific language governing permissions and\n          \n          \n            \n             * limitations under the License.\n          \n          \n            \n             */\n          \n          \n            \n            \n          \n          \n            \n            /** Snowflake IO services and POJOs. */", "author": "RyanSkraba", "createdAt": "2020-05-27T09:54:00Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/services/package-info.java", "diffHunk": "@@ -0,0 +1,2 @@\n+/** Snowflake IO services and POJOs. */", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQwNzYzMQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r432407631", "bodyText": "Thanks for spotting this.", "author": "purbanow", "createdAt": "2020-05-29T10:53:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5NzU4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgzNTE5OA==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431835198", "bodyText": "It's not mandatory, but I've gotten used to seeing @Nullable annotations in Beam code!  This looks like it can be valid when null, but staging bucket doesn't.", "author": "RyanSkraba", "createdAt": "2020-05-28T13:30:06Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/Location.java", "diffHunk": "@@ -0,0 +1,60 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.snowflake;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Used as one of the arguments for {@link org.apache.beam.sdk.io.snowflake.SnowflakeIO} write and\n+ * read operations. It keeps information about storage integration and staging bucket name.\n+ * Integration name is Snowflake storage integration object created according to Snowflake\n+ * documentation for the GCS bucket. Staging bucket name is Google Cloud Storage bucket which in the\n+ * case of writing operation will be used to save CSV files which will end up in Snowflake under\n+ * \u201cstaging_bucket_name/data\u201d path and in the case of reading operation will be used as a temporary\n+ * location for storing CSV files named `sf_copy_csv_DATE_TIME_RANDOMSUFFIX` which will be removed\n+ * automatically once Read operation finishes.\n+ */\n+public class Location implements Serializable {\n+  private String storageIntegrationName;", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ1MzUyNA==", "url": "https://github.com/apache/beam/pull/11794#discussion_r432453524", "bodyText": "Yes, you're right. Thanks for spotting this.", "author": "purbanow", "createdAt": "2020-05-29T12:36:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgzNTE5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgzODc0NQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431838745", "bodyText": "I know we use via elsewhere in Beam code, but mostly for callback functions -- any reason why this wouldn't just be withLocation ?", "author": "RyanSkraba", "createdAt": "2020-05-28T13:35:19Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeIO.java", "diffHunk": "@@ -257,23 +301,12 @@\n     }\n \n     /**\n-     * Name of the cloud bucket (GCS by now) to use as tmp location of CSVs during COPY statement.\n-     *\n-     * @param stagingBucketName - String with the name of the bucket.\n-     */\n-    public Read<T> withStagingBucketName(String stagingBucketName) {\n-      return toBuilder().setStagingBucketName(stagingBucketName).build();\n-    }\n-\n-    /**\n-     * Name of the Storage Integration in Snowflake to be used. See\n-     * https://docs.snowflake.com/en/sql-reference/sql/create-storage-integration.html for\n-     * reference.\n+     * A location object which contains connection config between Snowflake and GCP.\n      *\n-     * @param integrationName - String with the name of the Storage Integration.\n+     * @param location - an instance of {@link Location}.\n      */\n-    public Read<T> withIntegrationName(String integrationName) {\n-      return toBuilder().setIntegrationName(integrationName).build();\n+    public Read<T> via(Location location) {", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQyMzY5NQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r432423695", "bodyText": "No reason. I changed to withLocation  to be more consistent.", "author": "purbanow", "createdAt": "2020-05-29T11:31:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTgzODc0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg0NTkxOA==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431845918", "bodyText": "Hello!  Refactoring this part out into a separate method is odd -- the loc configuration is passed as a parameter while all the rest of the configurations are accessed as methods.  Were you going to reuse the location check at some point? As it is, it's inconsistent.\nAlso, storageIntegrationName must not be null.  Is that true?  Later, it's checked against null in SnowflakeServiceImpl", "author": "RyanSkraba", "createdAt": "2020-05-28T13:45:13Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeIO.java", "diffHunk": "@@ -339,10 +360,31 @@\n       emptyCollection\n           .apply(Wait.on(output))\n           .apply(ParDo.of(new CleanTmpFilesFromGcsFn(stagingBucketDir)));\n-\n       return output;\n     }\n \n+    private void checkArguments(Location loc) {\n+      // Either table or query is required. If query is present, it's being used, table is used\n+      // otherwise\n+      checkArgument(loc != null, \"via() is required\");\n+      checkArgument(\n+          loc.getStorageIntegrationName() != null,", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ1NjgxMQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r432456811", "bodyText": "I think it is more readable with separate method but i agree with you that is odd -- the loc configuration is passed as a parameter while all the rest of the configurations are accessed as methods. that's why I changed checkArguments method to stop accepting location as argument.\n\n\nSnowflakeIO.Read  requires storageIntegrationName  to be always set but SnowflakeIO.Write  doesn't require that.  The check against null in SnowflakeServiceImpl is corresponding to SnowflakeIO.Write  method", "author": "purbanow", "createdAt": "2020-05-29T12:43:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg0NTkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1MTc0OA==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431851748", "bodyText": "Likewise -- can this be nullable?", "author": "RyanSkraba", "createdAt": "2020-05-28T13:52:42Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeIO.java", "diffHunk": "@@ -447,6 +494,346 @@ public void populateDisplayData(DisplayData.Builder builder) {\n     }\n   }\n \n+  /** Implementation of {@link #write()}. */\n+  @AutoValue\n+  public abstract static class Write<T> extends PTransform<PCollection<T>, PDone> {\n+    @Nullable\n+    abstract SerializableFunction<Void, DataSource> getDataSourceProviderFn();\n+\n+    @Nullable\n+    abstract String getTable();\n+\n+    @Nullable\n+    abstract String getQuery();\n+\n+    @Nullable\n+    abstract Location getLocation();\n+\n+    @Nullable\n+    abstract String getFileNameTemplate();\n+\n+    @Nullable\n+    abstract WriteDisposition getWriteDisposition();\n+\n+    @Nullable\n+    abstract UserDataMapper getUserDataMapper();\n+\n+    @Nullable\n+    abstract SnowflakeService getSnowflakeService();\n+\n+    abstract Builder<T> toBuilder();\n+\n+    @AutoValue.Builder\n+    abstract static class Builder<T> {\n+      abstract Builder<T> setDataSourceProviderFn(\n+          SerializableFunction<Void, DataSource> dataSourceProviderFn);\n+\n+      abstract Builder<T> setTable(String table);\n+\n+      abstract Builder<T> setQuery(String query);\n+\n+      abstract Builder<T> setLocation(Location location);\n+\n+      abstract Builder<T> setFileNameTemplate(String fileNameTemplate);\n+\n+      abstract Builder<T> setUserDataMapper(UserDataMapper userDataMapper);\n+\n+      abstract Builder<T> setWriteDisposition(WriteDisposition writeDisposition);\n+\n+      abstract Builder<T> setSnowflakeService(SnowflakeService snowflakeService);\n+\n+      abstract Write<T> build();\n+    }\n+\n+    /**\n+     * Setting information about Snowflake server.\n+     *\n+     * @param config - An instance of {@link DataSourceConfiguration}.\n+     */\n+    public Write<T> withDataSourceConfiguration(final DataSourceConfiguration config) {\n+      return withDataSourceProviderFn(new DataSourceProviderFromDataSourceConfiguration(config));\n+    }\n+\n+    /**\n+     * Setting function that will provide {@link DataSourceConfiguration} in runtime.\n+     *\n+     * @param dataSourceProviderFn a {@link SerializableFunction}.\n+     */\n+    public Write<T> withDataSourceProviderFn(\n+        SerializableFunction<Void, DataSource> dataSourceProviderFn) {\n+      return toBuilder().setDataSourceProviderFn(dataSourceProviderFn).build();\n+    }\n+\n+    /**\n+     * A table name to be written in Snowflake.\n+     *\n+     * @param table - String with the name of the table.\n+     */\n+    public Write<T> to(String table) {\n+      return toBuilder().setTable(table).build();\n+    }\n+\n+    /**\n+     * A query to be executed in Snowflake.\n+     *\n+     * @param query - String with query.\n+     */\n+    public Write<T> withQueryTransformation(String query) {\n+      return toBuilder().setQuery(query).build();\n+    }\n+\n+    /**\n+     * A location object which contains connection config between Snowflake and GCP.\n+     *\n+     * @param location - an instance of {@link Location}.\n+     */\n+    public Write<T> via(Location location) {\n+      return toBuilder().setLocation(location).build();\n+    }\n+\n+    /**\n+     * A template name for files saved to GCP.\n+     *\n+     * @param fileNameTemplate - String with template name for files.\n+     */\n+    public Write<T> withFileNameTemplate(String fileNameTemplate) {\n+      return toBuilder().setFileNameTemplate(fileNameTemplate).build();\n+    }\n+\n+    /**\n+     * User-defined function mapping user data into CSV lines.\n+     *\n+     * @param userDataMapper - an instance of {@link UserDataMapper}.\n+     */\n+    public Write<T> withUserDataMapper(UserDataMapper userDataMapper) {\n+      return toBuilder().setUserDataMapper(userDataMapper).build();\n+    }\n+\n+    /**\n+     * A disposition to be used during writing to table phase.\n+     *\n+     * @param writeDisposition - an instance of {@link WriteDisposition}.\n+     */\n+    public Write<T> withWriteDisposition(WriteDisposition writeDisposition) {\n+      return toBuilder().setWriteDisposition(writeDisposition).build();\n+    }\n+\n+    /**\n+     * A snowflake service which is supposed to be used. Note: Currently we have {@link\n+     * SnowflakeServiceImpl} with corresponding {@link FakeSnowflakeServiceImpl} used for testing.\n+     *\n+     * @param snowflakeService - an instance of {@link SnowflakeService}.\n+     */\n+    public Write<T> withSnowflakeService(SnowflakeService snowflakeService) {\n+      return toBuilder().setSnowflakeService(snowflakeService).build();\n+    }\n+\n+    @Override\n+    public PDone expand(PCollection<T> input) {\n+      Location loc = getLocation();\n+      checkArguments(loc);\n+\n+      String stagingBucketDir = String.format(\"%s/%s/\", loc.getStagingBucketName(), WRITE_TMP_PATH);\n+\n+      PCollection out = write(input, stagingBucketDir);\n+      out.setCoder(StringUtf8Coder.of());\n+\n+      return PDone.in(out.getPipeline());\n+    }\n+\n+    private void checkArguments(Location loc) {\n+      checkArgument(loc != null, \"via() is required\");\n+      checkArgument(\n+          loc.getStorageIntegrationName() != null,\n+          \"location with storageIntegrationName is required\");", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQ1ODQ3Nw==", "url": "https://github.com/apache/beam/pull/11794#discussion_r432458477", "bodyText": "Yes, it can be nullable for Write method. Thanks for spotting this :)", "author": "purbanow", "createdAt": "2020-05-29T12:46:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1MTc0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1MzEyNg==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431853126", "bodyText": "There's no withTable()  in Write, probably to()", "author": "RyanSkraba", "createdAt": "2020-05-28T13:54:31Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeIO.java", "diffHunk": "@@ -447,6 +494,346 @@ public void populateDisplayData(DisplayData.Builder builder) {\n     }\n   }\n \n+  /** Implementation of {@link #write()}. */\n+  @AutoValue\n+  public abstract static class Write<T> extends PTransform<PCollection<T>, PDone> {\n+    @Nullable\n+    abstract SerializableFunction<Void, DataSource> getDataSourceProviderFn();\n+\n+    @Nullable\n+    abstract String getTable();\n+\n+    @Nullable\n+    abstract String getQuery();\n+\n+    @Nullable\n+    abstract Location getLocation();\n+\n+    @Nullable\n+    abstract String getFileNameTemplate();\n+\n+    @Nullable\n+    abstract WriteDisposition getWriteDisposition();\n+\n+    @Nullable\n+    abstract UserDataMapper getUserDataMapper();\n+\n+    @Nullable\n+    abstract SnowflakeService getSnowflakeService();\n+\n+    abstract Builder<T> toBuilder();\n+\n+    @AutoValue.Builder\n+    abstract static class Builder<T> {\n+      abstract Builder<T> setDataSourceProviderFn(\n+          SerializableFunction<Void, DataSource> dataSourceProviderFn);\n+\n+      abstract Builder<T> setTable(String table);\n+\n+      abstract Builder<T> setQuery(String query);\n+\n+      abstract Builder<T> setLocation(Location location);\n+\n+      abstract Builder<T> setFileNameTemplate(String fileNameTemplate);\n+\n+      abstract Builder<T> setUserDataMapper(UserDataMapper userDataMapper);\n+\n+      abstract Builder<T> setWriteDisposition(WriteDisposition writeDisposition);\n+\n+      abstract Builder<T> setSnowflakeService(SnowflakeService snowflakeService);\n+\n+      abstract Write<T> build();\n+    }\n+\n+    /**\n+     * Setting information about Snowflake server.\n+     *\n+     * @param config - An instance of {@link DataSourceConfiguration}.\n+     */\n+    public Write<T> withDataSourceConfiguration(final DataSourceConfiguration config) {\n+      return withDataSourceProviderFn(new DataSourceProviderFromDataSourceConfiguration(config));\n+    }\n+\n+    /**\n+     * Setting function that will provide {@link DataSourceConfiguration} in runtime.\n+     *\n+     * @param dataSourceProviderFn a {@link SerializableFunction}.\n+     */\n+    public Write<T> withDataSourceProviderFn(\n+        SerializableFunction<Void, DataSource> dataSourceProviderFn) {\n+      return toBuilder().setDataSourceProviderFn(dataSourceProviderFn).build();\n+    }\n+\n+    /**\n+     * A table name to be written in Snowflake.\n+     *\n+     * @param table - String with the name of the table.\n+     */\n+    public Write<T> to(String table) {\n+      return toBuilder().setTable(table).build();\n+    }\n+\n+    /**\n+     * A query to be executed in Snowflake.\n+     *\n+     * @param query - String with query.\n+     */\n+    public Write<T> withQueryTransformation(String query) {\n+      return toBuilder().setQuery(query).build();\n+    }\n+\n+    /**\n+     * A location object which contains connection config between Snowflake and GCP.\n+     *\n+     * @param location - an instance of {@link Location}.\n+     */\n+    public Write<T> via(Location location) {\n+      return toBuilder().setLocation(location).build();\n+    }\n+\n+    /**\n+     * A template name for files saved to GCP.\n+     *\n+     * @param fileNameTemplate - String with template name for files.\n+     */\n+    public Write<T> withFileNameTemplate(String fileNameTemplate) {\n+      return toBuilder().setFileNameTemplate(fileNameTemplate).build();\n+    }\n+\n+    /**\n+     * User-defined function mapping user data into CSV lines.\n+     *\n+     * @param userDataMapper - an instance of {@link UserDataMapper}.\n+     */\n+    public Write<T> withUserDataMapper(UserDataMapper userDataMapper) {\n+      return toBuilder().setUserDataMapper(userDataMapper).build();\n+    }\n+\n+    /**\n+     * A disposition to be used during writing to table phase.\n+     *\n+     * @param writeDisposition - an instance of {@link WriteDisposition}.\n+     */\n+    public Write<T> withWriteDisposition(WriteDisposition writeDisposition) {\n+      return toBuilder().setWriteDisposition(writeDisposition).build();\n+    }\n+\n+    /**\n+     * A snowflake service which is supposed to be used. Note: Currently we have {@link\n+     * SnowflakeServiceImpl} with corresponding {@link FakeSnowflakeServiceImpl} used for testing.\n+     *\n+     * @param snowflakeService - an instance of {@link SnowflakeService}.\n+     */\n+    public Write<T> withSnowflakeService(SnowflakeService snowflakeService) {\n+      return toBuilder().setSnowflakeService(snowflakeService).build();\n+    }\n+\n+    @Override\n+    public PDone expand(PCollection<T> input) {\n+      Location loc = getLocation();\n+      checkArguments(loc);\n+\n+      String stagingBucketDir = String.format(\"%s/%s/\", loc.getStagingBucketName(), WRITE_TMP_PATH);\n+\n+      PCollection out = write(input, stagingBucketDir);\n+      out.setCoder(StringUtf8Coder.of());\n+\n+      return PDone.in(out.getPipeline());\n+    }\n+\n+    private void checkArguments(Location loc) {\n+      checkArgument(loc != null, \"via() is required\");\n+      checkArgument(\n+          loc.getStorageIntegrationName() != null,\n+          \"location with storageIntegrationName is required\");\n+      checkArgument(\n+          loc.getStagingBucketName() != null, \"location with stagingBucketName is required\");\n+\n+      checkArgument(getUserDataMapper() != null, \"withUserDataMapper() is required\");\n+\n+      checkArgument(\n+          (getDataSourceProviderFn() != null),\n+          \"withDataSourceConfiguration() or withDataSourceProviderFn() is required\");\n+\n+      checkArgument(getTable() != null, \"withTable() is required\");", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQzMjMwNg==", "url": "https://github.com/apache/beam/pull/11794#discussion_r432432306", "bodyText": "Yes, you're right. I changed to() method to withTable() to be more consistent.", "author": "purbanow", "createdAt": "2020-05-29T11:51:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1MzEyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1NTA3MA==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431855070", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                private PCollection write(PCollection input, String stagingBucketDir) {\n          \n          \n            \n                private PCollection write(PCollection<T> input, String stagingBucketDir) {\n          \n      \n    \n    \n  \n\nI'd consider collapsing this method into expand (the caller) or combining with withFiles below.  It doesn't add much by itself.", "author": "RyanSkraba", "createdAt": "2020-05-28T13:56:59Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeIO.java", "diffHunk": "@@ -447,6 +494,346 @@ public void populateDisplayData(DisplayData.Builder builder) {\n     }\n   }\n \n+  /** Implementation of {@link #write()}. */\n+  @AutoValue\n+  public abstract static class Write<T> extends PTransform<PCollection<T>, PDone> {\n+    @Nullable\n+    abstract SerializableFunction<Void, DataSource> getDataSourceProviderFn();\n+\n+    @Nullable\n+    abstract String getTable();\n+\n+    @Nullable\n+    abstract String getQuery();\n+\n+    @Nullable\n+    abstract Location getLocation();\n+\n+    @Nullable\n+    abstract String getFileNameTemplate();\n+\n+    @Nullable\n+    abstract WriteDisposition getWriteDisposition();\n+\n+    @Nullable\n+    abstract UserDataMapper getUserDataMapper();\n+\n+    @Nullable\n+    abstract SnowflakeService getSnowflakeService();\n+\n+    abstract Builder<T> toBuilder();\n+\n+    @AutoValue.Builder\n+    abstract static class Builder<T> {\n+      abstract Builder<T> setDataSourceProviderFn(\n+          SerializableFunction<Void, DataSource> dataSourceProviderFn);\n+\n+      abstract Builder<T> setTable(String table);\n+\n+      abstract Builder<T> setQuery(String query);\n+\n+      abstract Builder<T> setLocation(Location location);\n+\n+      abstract Builder<T> setFileNameTemplate(String fileNameTemplate);\n+\n+      abstract Builder<T> setUserDataMapper(UserDataMapper userDataMapper);\n+\n+      abstract Builder<T> setWriteDisposition(WriteDisposition writeDisposition);\n+\n+      abstract Builder<T> setSnowflakeService(SnowflakeService snowflakeService);\n+\n+      abstract Write<T> build();\n+    }\n+\n+    /**\n+     * Setting information about Snowflake server.\n+     *\n+     * @param config - An instance of {@link DataSourceConfiguration}.\n+     */\n+    public Write<T> withDataSourceConfiguration(final DataSourceConfiguration config) {\n+      return withDataSourceProviderFn(new DataSourceProviderFromDataSourceConfiguration(config));\n+    }\n+\n+    /**\n+     * Setting function that will provide {@link DataSourceConfiguration} in runtime.\n+     *\n+     * @param dataSourceProviderFn a {@link SerializableFunction}.\n+     */\n+    public Write<T> withDataSourceProviderFn(\n+        SerializableFunction<Void, DataSource> dataSourceProviderFn) {\n+      return toBuilder().setDataSourceProviderFn(dataSourceProviderFn).build();\n+    }\n+\n+    /**\n+     * A table name to be written in Snowflake.\n+     *\n+     * @param table - String with the name of the table.\n+     */\n+    public Write<T> to(String table) {\n+      return toBuilder().setTable(table).build();\n+    }\n+\n+    /**\n+     * A query to be executed in Snowflake.\n+     *\n+     * @param query - String with query.\n+     */\n+    public Write<T> withQueryTransformation(String query) {\n+      return toBuilder().setQuery(query).build();\n+    }\n+\n+    /**\n+     * A location object which contains connection config between Snowflake and GCP.\n+     *\n+     * @param location - an instance of {@link Location}.\n+     */\n+    public Write<T> via(Location location) {\n+      return toBuilder().setLocation(location).build();\n+    }\n+\n+    /**\n+     * A template name for files saved to GCP.\n+     *\n+     * @param fileNameTemplate - String with template name for files.\n+     */\n+    public Write<T> withFileNameTemplate(String fileNameTemplate) {\n+      return toBuilder().setFileNameTemplate(fileNameTemplate).build();\n+    }\n+\n+    /**\n+     * User-defined function mapping user data into CSV lines.\n+     *\n+     * @param userDataMapper - an instance of {@link UserDataMapper}.\n+     */\n+    public Write<T> withUserDataMapper(UserDataMapper userDataMapper) {\n+      return toBuilder().setUserDataMapper(userDataMapper).build();\n+    }\n+\n+    /**\n+     * A disposition to be used during writing to table phase.\n+     *\n+     * @param writeDisposition - an instance of {@link WriteDisposition}.\n+     */\n+    public Write<T> withWriteDisposition(WriteDisposition writeDisposition) {\n+      return toBuilder().setWriteDisposition(writeDisposition).build();\n+    }\n+\n+    /**\n+     * A snowflake service which is supposed to be used. Note: Currently we have {@link\n+     * SnowflakeServiceImpl} with corresponding {@link FakeSnowflakeServiceImpl} used for testing.\n+     *\n+     * @param snowflakeService - an instance of {@link SnowflakeService}.\n+     */\n+    public Write<T> withSnowflakeService(SnowflakeService snowflakeService) {\n+      return toBuilder().setSnowflakeService(snowflakeService).build();\n+    }\n+\n+    @Override\n+    public PDone expand(PCollection<T> input) {\n+      Location loc = getLocation();\n+      checkArguments(loc);\n+\n+      String stagingBucketDir = String.format(\"%s/%s/\", loc.getStagingBucketName(), WRITE_TMP_PATH);\n+\n+      PCollection out = write(input, stagingBucketDir);\n+      out.setCoder(StringUtf8Coder.of());\n+\n+      return PDone.in(out.getPipeline());\n+    }\n+\n+    private void checkArguments(Location loc) {\n+      checkArgument(loc != null, \"via() is required\");\n+      checkArgument(\n+          loc.getStorageIntegrationName() != null,\n+          \"location with storageIntegrationName is required\");\n+      checkArgument(\n+          loc.getStagingBucketName() != null, \"location with stagingBucketName is required\");\n+\n+      checkArgument(getUserDataMapper() != null, \"withUserDataMapper() is required\");\n+\n+      checkArgument(\n+          (getDataSourceProviderFn() != null),\n+          \"withDataSourceConfiguration() or withDataSourceProviderFn() is required\");\n+\n+      checkArgument(getTable() != null, \"withTable() is required\");\n+    }\n+\n+    private PCollection write(PCollection input, String stagingBucketDir) {", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzA1MDY5Ng==", "url": "https://github.com/apache/beam/pull/11794#discussion_r433050696", "bodyText": "I wouldn't say that it doesn't add any value being like this as in my opinion makes code more readable.", "author": "purbanow", "createdAt": "2020-06-01T05:42:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1NTA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1NzUzMw==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431857533", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  PCollection mappedUserData =\n          \n          \n            \n                  PCollection<String> mappedUserData =\n          \n      \n    \n    \n  \n\nAvoid raw types where possible!  This should be true throughout the code.", "author": "RyanSkraba", "createdAt": "2020-05-28T14:00:15Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeIO.java", "diffHunk": "@@ -447,6 +494,346 @@ public void populateDisplayData(DisplayData.Builder builder) {\n     }\n   }\n \n+  /** Implementation of {@link #write()}. */\n+  @AutoValue\n+  public abstract static class Write<T> extends PTransform<PCollection<T>, PDone> {\n+    @Nullable\n+    abstract SerializableFunction<Void, DataSource> getDataSourceProviderFn();\n+\n+    @Nullable\n+    abstract String getTable();\n+\n+    @Nullable\n+    abstract String getQuery();\n+\n+    @Nullable\n+    abstract Location getLocation();\n+\n+    @Nullable\n+    abstract String getFileNameTemplate();\n+\n+    @Nullable\n+    abstract WriteDisposition getWriteDisposition();\n+\n+    @Nullable\n+    abstract UserDataMapper getUserDataMapper();\n+\n+    @Nullable\n+    abstract SnowflakeService getSnowflakeService();\n+\n+    abstract Builder<T> toBuilder();\n+\n+    @AutoValue.Builder\n+    abstract static class Builder<T> {\n+      abstract Builder<T> setDataSourceProviderFn(\n+          SerializableFunction<Void, DataSource> dataSourceProviderFn);\n+\n+      abstract Builder<T> setTable(String table);\n+\n+      abstract Builder<T> setQuery(String query);\n+\n+      abstract Builder<T> setLocation(Location location);\n+\n+      abstract Builder<T> setFileNameTemplate(String fileNameTemplate);\n+\n+      abstract Builder<T> setUserDataMapper(UserDataMapper userDataMapper);\n+\n+      abstract Builder<T> setWriteDisposition(WriteDisposition writeDisposition);\n+\n+      abstract Builder<T> setSnowflakeService(SnowflakeService snowflakeService);\n+\n+      abstract Write<T> build();\n+    }\n+\n+    /**\n+     * Setting information about Snowflake server.\n+     *\n+     * @param config - An instance of {@link DataSourceConfiguration}.\n+     */\n+    public Write<T> withDataSourceConfiguration(final DataSourceConfiguration config) {\n+      return withDataSourceProviderFn(new DataSourceProviderFromDataSourceConfiguration(config));\n+    }\n+\n+    /**\n+     * Setting function that will provide {@link DataSourceConfiguration} in runtime.\n+     *\n+     * @param dataSourceProviderFn a {@link SerializableFunction}.\n+     */\n+    public Write<T> withDataSourceProviderFn(\n+        SerializableFunction<Void, DataSource> dataSourceProviderFn) {\n+      return toBuilder().setDataSourceProviderFn(dataSourceProviderFn).build();\n+    }\n+\n+    /**\n+     * A table name to be written in Snowflake.\n+     *\n+     * @param table - String with the name of the table.\n+     */\n+    public Write<T> to(String table) {\n+      return toBuilder().setTable(table).build();\n+    }\n+\n+    /**\n+     * A query to be executed in Snowflake.\n+     *\n+     * @param query - String with query.\n+     */\n+    public Write<T> withQueryTransformation(String query) {\n+      return toBuilder().setQuery(query).build();\n+    }\n+\n+    /**\n+     * A location object which contains connection config between Snowflake and GCP.\n+     *\n+     * @param location - an instance of {@link Location}.\n+     */\n+    public Write<T> via(Location location) {\n+      return toBuilder().setLocation(location).build();\n+    }\n+\n+    /**\n+     * A template name for files saved to GCP.\n+     *\n+     * @param fileNameTemplate - String with template name for files.\n+     */\n+    public Write<T> withFileNameTemplate(String fileNameTemplate) {\n+      return toBuilder().setFileNameTemplate(fileNameTemplate).build();\n+    }\n+\n+    /**\n+     * User-defined function mapping user data into CSV lines.\n+     *\n+     * @param userDataMapper - an instance of {@link UserDataMapper}.\n+     */\n+    public Write<T> withUserDataMapper(UserDataMapper userDataMapper) {\n+      return toBuilder().setUserDataMapper(userDataMapper).build();\n+    }\n+\n+    /**\n+     * A disposition to be used during writing to table phase.\n+     *\n+     * @param writeDisposition - an instance of {@link WriteDisposition}.\n+     */\n+    public Write<T> withWriteDisposition(WriteDisposition writeDisposition) {\n+      return toBuilder().setWriteDisposition(writeDisposition).build();\n+    }\n+\n+    /**\n+     * A snowflake service which is supposed to be used. Note: Currently we have {@link\n+     * SnowflakeServiceImpl} with corresponding {@link FakeSnowflakeServiceImpl} used for testing.\n+     *\n+     * @param snowflakeService - an instance of {@link SnowflakeService}.\n+     */\n+    public Write<T> withSnowflakeService(SnowflakeService snowflakeService) {\n+      return toBuilder().setSnowflakeService(snowflakeService).build();\n+    }\n+\n+    @Override\n+    public PDone expand(PCollection<T> input) {\n+      Location loc = getLocation();\n+      checkArguments(loc);\n+\n+      String stagingBucketDir = String.format(\"%s/%s/\", loc.getStagingBucketName(), WRITE_TMP_PATH);\n+\n+      PCollection out = write(input, stagingBucketDir);\n+      out.setCoder(StringUtf8Coder.of());\n+\n+      return PDone.in(out.getPipeline());\n+    }\n+\n+    private void checkArguments(Location loc) {\n+      checkArgument(loc != null, \"via() is required\");\n+      checkArgument(\n+          loc.getStorageIntegrationName() != null,\n+          \"location with storageIntegrationName is required\");\n+      checkArgument(\n+          loc.getStagingBucketName() != null, \"location with stagingBucketName is required\");\n+\n+      checkArgument(getUserDataMapper() != null, \"withUserDataMapper() is required\");\n+\n+      checkArgument(\n+          (getDataSourceProviderFn() != null),\n+          \"withDataSourceConfiguration() or withDataSourceProviderFn() is required\");\n+\n+      checkArgument(getTable() != null, \"withTable() is required\");\n+    }\n+\n+    private PCollection write(PCollection input, String stagingBucketDir) {\n+      SnowflakeService snowflakeService =\n+          getSnowflakeService() != null ? getSnowflakeService() : new SnowflakeServiceImpl();\n+\n+      PCollection files = writeFiles(input, stagingBucketDir);\n+\n+      files =\n+          (PCollection)\n+              files.apply(\"Create list of files to copy\", Combine.globally(new Concatenate()));\n+\n+      return (PCollection)\n+          files.apply(\"Copy files to table\", copyToTable(snowflakeService, stagingBucketDir));\n+    }\n+\n+    private PCollection writeFiles(PCollection<T> input, String stagingBucketDir) {\n+      class Parse extends DoFn<KV<T, String>, String> {\n+        @ProcessElement\n+        public void processElement(ProcessContext c) {\n+          c.output(c.element().getValue());\n+        }\n+      }\n+\n+      PCollection mappedUserData =", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyMDE2Ng==", "url": "https://github.com/apache/beam/pull/11794#discussion_r433620166", "bodyText": "I checked whole code and I added missing types :)", "author": "purbanow", "createdAt": "2020-06-02T04:57:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg1NzUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg2MjE5MQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431862191", "bodyText": "It looks like you're re-implementing Values.create()!  Consider using the existing transform.", "author": "RyanSkraba", "createdAt": "2020-05-28T14:06:52Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeIO.java", "diffHunk": "@@ -447,6 +494,346 @@ public void populateDisplayData(DisplayData.Builder builder) {\n     }\n   }\n \n+  /** Implementation of {@link #write()}. */\n+  @AutoValue\n+  public abstract static class Write<T> extends PTransform<PCollection<T>, PDone> {\n+    @Nullable\n+    abstract SerializableFunction<Void, DataSource> getDataSourceProviderFn();\n+\n+    @Nullable\n+    abstract String getTable();\n+\n+    @Nullable\n+    abstract String getQuery();\n+\n+    @Nullable\n+    abstract Location getLocation();\n+\n+    @Nullable\n+    abstract String getFileNameTemplate();\n+\n+    @Nullable\n+    abstract WriteDisposition getWriteDisposition();\n+\n+    @Nullable\n+    abstract UserDataMapper getUserDataMapper();\n+\n+    @Nullable\n+    abstract SnowflakeService getSnowflakeService();\n+\n+    abstract Builder<T> toBuilder();\n+\n+    @AutoValue.Builder\n+    abstract static class Builder<T> {\n+      abstract Builder<T> setDataSourceProviderFn(\n+          SerializableFunction<Void, DataSource> dataSourceProviderFn);\n+\n+      abstract Builder<T> setTable(String table);\n+\n+      abstract Builder<T> setQuery(String query);\n+\n+      abstract Builder<T> setLocation(Location location);\n+\n+      abstract Builder<T> setFileNameTemplate(String fileNameTemplate);\n+\n+      abstract Builder<T> setUserDataMapper(UserDataMapper userDataMapper);\n+\n+      abstract Builder<T> setWriteDisposition(WriteDisposition writeDisposition);\n+\n+      abstract Builder<T> setSnowflakeService(SnowflakeService snowflakeService);\n+\n+      abstract Write<T> build();\n+    }\n+\n+    /**\n+     * Setting information about Snowflake server.\n+     *\n+     * @param config - An instance of {@link DataSourceConfiguration}.\n+     */\n+    public Write<T> withDataSourceConfiguration(final DataSourceConfiguration config) {\n+      return withDataSourceProviderFn(new DataSourceProviderFromDataSourceConfiguration(config));\n+    }\n+\n+    /**\n+     * Setting function that will provide {@link DataSourceConfiguration} in runtime.\n+     *\n+     * @param dataSourceProviderFn a {@link SerializableFunction}.\n+     */\n+    public Write<T> withDataSourceProviderFn(\n+        SerializableFunction<Void, DataSource> dataSourceProviderFn) {\n+      return toBuilder().setDataSourceProviderFn(dataSourceProviderFn).build();\n+    }\n+\n+    /**\n+     * A table name to be written in Snowflake.\n+     *\n+     * @param table - String with the name of the table.\n+     */\n+    public Write<T> to(String table) {\n+      return toBuilder().setTable(table).build();\n+    }\n+\n+    /**\n+     * A query to be executed in Snowflake.\n+     *\n+     * @param query - String with query.\n+     */\n+    public Write<T> withQueryTransformation(String query) {\n+      return toBuilder().setQuery(query).build();\n+    }\n+\n+    /**\n+     * A location object which contains connection config between Snowflake and GCP.\n+     *\n+     * @param location - an instance of {@link Location}.\n+     */\n+    public Write<T> via(Location location) {\n+      return toBuilder().setLocation(location).build();\n+    }\n+\n+    /**\n+     * A template name for files saved to GCP.\n+     *\n+     * @param fileNameTemplate - String with template name for files.\n+     */\n+    public Write<T> withFileNameTemplate(String fileNameTemplate) {\n+      return toBuilder().setFileNameTemplate(fileNameTemplate).build();\n+    }\n+\n+    /**\n+     * User-defined function mapping user data into CSV lines.\n+     *\n+     * @param userDataMapper - an instance of {@link UserDataMapper}.\n+     */\n+    public Write<T> withUserDataMapper(UserDataMapper userDataMapper) {\n+      return toBuilder().setUserDataMapper(userDataMapper).build();\n+    }\n+\n+    /**\n+     * A disposition to be used during writing to table phase.\n+     *\n+     * @param writeDisposition - an instance of {@link WriteDisposition}.\n+     */\n+    public Write<T> withWriteDisposition(WriteDisposition writeDisposition) {\n+      return toBuilder().setWriteDisposition(writeDisposition).build();\n+    }\n+\n+    /**\n+     * A snowflake service which is supposed to be used. Note: Currently we have {@link\n+     * SnowflakeServiceImpl} with corresponding {@link FakeSnowflakeServiceImpl} used for testing.\n+     *\n+     * @param snowflakeService - an instance of {@link SnowflakeService}.\n+     */\n+    public Write<T> withSnowflakeService(SnowflakeService snowflakeService) {\n+      return toBuilder().setSnowflakeService(snowflakeService).build();\n+    }\n+\n+    @Override\n+    public PDone expand(PCollection<T> input) {\n+      Location loc = getLocation();\n+      checkArguments(loc);\n+\n+      String stagingBucketDir = String.format(\"%s/%s/\", loc.getStagingBucketName(), WRITE_TMP_PATH);\n+\n+      PCollection out = write(input, stagingBucketDir);\n+      out.setCoder(StringUtf8Coder.of());\n+\n+      return PDone.in(out.getPipeline());\n+    }\n+\n+    private void checkArguments(Location loc) {\n+      checkArgument(loc != null, \"via() is required\");\n+      checkArgument(\n+          loc.getStorageIntegrationName() != null,\n+          \"location with storageIntegrationName is required\");\n+      checkArgument(\n+          loc.getStagingBucketName() != null, \"location with stagingBucketName is required\");\n+\n+      checkArgument(getUserDataMapper() != null, \"withUserDataMapper() is required\");\n+\n+      checkArgument(\n+          (getDataSourceProviderFn() != null),\n+          \"withDataSourceConfiguration() or withDataSourceProviderFn() is required\");\n+\n+      checkArgument(getTable() != null, \"withTable() is required\");\n+    }\n+\n+    private PCollection write(PCollection input, String stagingBucketDir) {\n+      SnowflakeService snowflakeService =\n+          getSnowflakeService() != null ? getSnowflakeService() : new SnowflakeServiceImpl();\n+\n+      PCollection files = writeFiles(input, stagingBucketDir);\n+\n+      files =\n+          (PCollection)\n+              files.apply(\"Create list of files to copy\", Combine.globally(new Concatenate()));\n+\n+      return (PCollection)\n+          files.apply(\"Copy files to table\", copyToTable(snowflakeService, stagingBucketDir));\n+    }\n+\n+    private PCollection writeFiles(PCollection<T> input, String stagingBucketDir) {\n+      class Parse extends DoFn<KV<T, String>, String> {", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYxMDMxMw==", "url": "https://github.com/apache/beam/pull/11794#discussion_r433610313", "bodyText": "Thanks for this tip :) I removed Parse class", "author": "purbanow", "createdAt": "2020-06-02T04:15:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg2MjE5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg2NTUwMQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431865501", "bodyText": "Consider reusing a MapElements.via(t -> csvMapper.mapRow(t)) instead.", "author": "RyanSkraba", "createdAt": "2020-05-28T14:11:27Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeIO.java", "diffHunk": "@@ -447,6 +494,346 @@ public void populateDisplayData(DisplayData.Builder builder) {\n     }\n   }\n \n+  /** Implementation of {@link #write()}. */\n+  @AutoValue\n+  public abstract static class Write<T> extends PTransform<PCollection<T>, PDone> {\n+    @Nullable\n+    abstract SerializableFunction<Void, DataSource> getDataSourceProviderFn();\n+\n+    @Nullable\n+    abstract String getTable();\n+\n+    @Nullable\n+    abstract String getQuery();\n+\n+    @Nullable\n+    abstract Location getLocation();\n+\n+    @Nullable\n+    abstract String getFileNameTemplate();\n+\n+    @Nullable\n+    abstract WriteDisposition getWriteDisposition();\n+\n+    @Nullable\n+    abstract UserDataMapper getUserDataMapper();\n+\n+    @Nullable\n+    abstract SnowflakeService getSnowflakeService();\n+\n+    abstract Builder<T> toBuilder();\n+\n+    @AutoValue.Builder\n+    abstract static class Builder<T> {\n+      abstract Builder<T> setDataSourceProviderFn(\n+          SerializableFunction<Void, DataSource> dataSourceProviderFn);\n+\n+      abstract Builder<T> setTable(String table);\n+\n+      abstract Builder<T> setQuery(String query);\n+\n+      abstract Builder<T> setLocation(Location location);\n+\n+      abstract Builder<T> setFileNameTemplate(String fileNameTemplate);\n+\n+      abstract Builder<T> setUserDataMapper(UserDataMapper userDataMapper);\n+\n+      abstract Builder<T> setWriteDisposition(WriteDisposition writeDisposition);\n+\n+      abstract Builder<T> setSnowflakeService(SnowflakeService snowflakeService);\n+\n+      abstract Write<T> build();\n+    }\n+\n+    /**\n+     * Setting information about Snowflake server.\n+     *\n+     * @param config - An instance of {@link DataSourceConfiguration}.\n+     */\n+    public Write<T> withDataSourceConfiguration(final DataSourceConfiguration config) {\n+      return withDataSourceProviderFn(new DataSourceProviderFromDataSourceConfiguration(config));\n+    }\n+\n+    /**\n+     * Setting function that will provide {@link DataSourceConfiguration} in runtime.\n+     *\n+     * @param dataSourceProviderFn a {@link SerializableFunction}.\n+     */\n+    public Write<T> withDataSourceProviderFn(\n+        SerializableFunction<Void, DataSource> dataSourceProviderFn) {\n+      return toBuilder().setDataSourceProviderFn(dataSourceProviderFn).build();\n+    }\n+\n+    /**\n+     * A table name to be written in Snowflake.\n+     *\n+     * @param table - String with the name of the table.\n+     */\n+    public Write<T> to(String table) {\n+      return toBuilder().setTable(table).build();\n+    }\n+\n+    /**\n+     * A query to be executed in Snowflake.\n+     *\n+     * @param query - String with query.\n+     */\n+    public Write<T> withQueryTransformation(String query) {\n+      return toBuilder().setQuery(query).build();\n+    }\n+\n+    /**\n+     * A location object which contains connection config between Snowflake and GCP.\n+     *\n+     * @param location - an instance of {@link Location}.\n+     */\n+    public Write<T> via(Location location) {\n+      return toBuilder().setLocation(location).build();\n+    }\n+\n+    /**\n+     * A template name for files saved to GCP.\n+     *\n+     * @param fileNameTemplate - String with template name for files.\n+     */\n+    public Write<T> withFileNameTemplate(String fileNameTemplate) {\n+      return toBuilder().setFileNameTemplate(fileNameTemplate).build();\n+    }\n+\n+    /**\n+     * User-defined function mapping user data into CSV lines.\n+     *\n+     * @param userDataMapper - an instance of {@link UserDataMapper}.\n+     */\n+    public Write<T> withUserDataMapper(UserDataMapper userDataMapper) {\n+      return toBuilder().setUserDataMapper(userDataMapper).build();\n+    }\n+\n+    /**\n+     * A disposition to be used during writing to table phase.\n+     *\n+     * @param writeDisposition - an instance of {@link WriteDisposition}.\n+     */\n+    public Write<T> withWriteDisposition(WriteDisposition writeDisposition) {\n+      return toBuilder().setWriteDisposition(writeDisposition).build();\n+    }\n+\n+    /**\n+     * A snowflake service which is supposed to be used. Note: Currently we have {@link\n+     * SnowflakeServiceImpl} with corresponding {@link FakeSnowflakeServiceImpl} used for testing.\n+     *\n+     * @param snowflakeService - an instance of {@link SnowflakeService}.\n+     */\n+    public Write<T> withSnowflakeService(SnowflakeService snowflakeService) {\n+      return toBuilder().setSnowflakeService(snowflakeService).build();\n+    }\n+\n+    @Override\n+    public PDone expand(PCollection<T> input) {\n+      Location loc = getLocation();\n+      checkArguments(loc);\n+\n+      String stagingBucketDir = String.format(\"%s/%s/\", loc.getStagingBucketName(), WRITE_TMP_PATH);\n+\n+      PCollection out = write(input, stagingBucketDir);\n+      out.setCoder(StringUtf8Coder.of());\n+\n+      return PDone.in(out.getPipeline());\n+    }\n+\n+    private void checkArguments(Location loc) {\n+      checkArgument(loc != null, \"via() is required\");\n+      checkArgument(\n+          loc.getStorageIntegrationName() != null,\n+          \"location with storageIntegrationName is required\");\n+      checkArgument(\n+          loc.getStagingBucketName() != null, \"location with stagingBucketName is required\");\n+\n+      checkArgument(getUserDataMapper() != null, \"withUserDataMapper() is required\");\n+\n+      checkArgument(\n+          (getDataSourceProviderFn() != null),\n+          \"withDataSourceConfiguration() or withDataSourceProviderFn() is required\");\n+\n+      checkArgument(getTable() != null, \"withTable() is required\");\n+    }\n+\n+    private PCollection write(PCollection input, String stagingBucketDir) {\n+      SnowflakeService snowflakeService =\n+          getSnowflakeService() != null ? getSnowflakeService() : new SnowflakeServiceImpl();\n+\n+      PCollection files = writeFiles(input, stagingBucketDir);\n+\n+      files =\n+          (PCollection)\n+              files.apply(\"Create list of files to copy\", Combine.globally(new Concatenate()));\n+\n+      return (PCollection)\n+          files.apply(\"Copy files to table\", copyToTable(snowflakeService, stagingBucketDir));\n+    }\n+\n+    private PCollection writeFiles(PCollection<T> input, String stagingBucketDir) {\n+      class Parse extends DoFn<KV<T, String>, String> {\n+        @ProcessElement\n+        public void processElement(ProcessContext c) {\n+          c.output(c.element().getValue());\n+        }\n+      }\n+\n+      PCollection mappedUserData =\n+          input\n+              .apply(\n+                  \"Map user data to Objects array\",\n+                  ParDo.of(new MapUserDataObjectsArrayFn<T>(getUserDataMapper())))\n+              .apply(\"Map Objects array to CSV lines\", ParDo.of(new MapObjectsArrayToCsvFn()))\n+              .setCoder(StringUtf8Coder.of());\n+\n+      WriteFilesResult filesResult =\n+          (WriteFilesResult)\n+              mappedUserData.apply(\n+                  \"Write files to specified location\",\n+                  FileIO.write()\n+                      .via((FileIO.Sink) new CSVSink())\n+                      .to(stagingBucketDir)\n+                      .withPrefix(getFileNameTemplate())\n+                      .withSuffix(\".csv\")\n+                      .withPrefix(UUID.randomUUID().toString().subSequence(0, 8).toString())\n+                      .withCompression(Compression.GZIP));\n+\n+      return (PCollection)\n+          filesResult\n+              .getPerDestinationOutputFilenames()\n+              .apply(\"Parse KV filenames to Strings\", ParDo.of(new Parse()));\n+    }\n+\n+    private ParDo.SingleOutput<Object, Object> copyToTable(\n+        SnowflakeService snowflakeService, String stagingBucketDir) {\n+      return ParDo.of(\n+          new CopyToTableFn<>(\n+              getDataSourceProviderFn(),\n+              getTable(),\n+              getQuery(),\n+              stagingBucketDir,\n+              getLocation(),\n+              getWriteDisposition(),\n+              snowflakeService));\n+    }\n+  }\n+\n+  public static class Concatenate extends Combine.CombineFn<String, List<String>, List<String>> {\n+    @Override\n+    public List<String> createAccumulator() {\n+      return new ArrayList<>();\n+    }\n+\n+    @Override\n+    public List<String> addInput(List<String> mutableAccumulator, String input) {\n+      mutableAccumulator.add(String.format(\"'%s'\", input));\n+      return mutableAccumulator;\n+    }\n+\n+    @Override\n+    public List<String> mergeAccumulators(Iterable<List<String>> accumulators) {\n+      List<String> result = createAccumulator();\n+      for (List<String> accumulator : accumulators) {\n+        result.addAll(accumulator);\n+      }\n+      return result;\n+    }\n+\n+    @Override\n+    public List<String> extractOutput(List<String> accumulator) {\n+      return accumulator;\n+    }\n+  }\n+\n+  private static class MapUserDataObjectsArrayFn<T> extends DoFn<T, Object[]> {", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzExNDMxMQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r433114311", "bodyText": "Thanks, I changed to MapElements.via with SimpleFunction", "author": "purbanow", "createdAt": "2020-06-01T08:46:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg2NTUwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5NTcyNw==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431895727", "bodyText": "Hmmmm -- a common pattern to process a small list of results is to treat it as a sideInput instead of collecting it into a singleton collection.  I have no really strong opinion about this, but someone might want to weigh in!", "author": "RyanSkraba", "createdAt": "2020-05-28T14:47:18Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeIO.java", "diffHunk": "@@ -447,6 +494,346 @@ public void populateDisplayData(DisplayData.Builder builder) {\n     }\n   }\n \n+  /** Implementation of {@link #write()}. */\n+  @AutoValue\n+  public abstract static class Write<T> extends PTransform<PCollection<T>, PDone> {\n+    @Nullable\n+    abstract SerializableFunction<Void, DataSource> getDataSourceProviderFn();\n+\n+    @Nullable\n+    abstract String getTable();\n+\n+    @Nullable\n+    abstract String getQuery();\n+\n+    @Nullable\n+    abstract Location getLocation();\n+\n+    @Nullable\n+    abstract String getFileNameTemplate();\n+\n+    @Nullable\n+    abstract WriteDisposition getWriteDisposition();\n+\n+    @Nullable\n+    abstract UserDataMapper getUserDataMapper();\n+\n+    @Nullable\n+    abstract SnowflakeService getSnowflakeService();\n+\n+    abstract Builder<T> toBuilder();\n+\n+    @AutoValue.Builder\n+    abstract static class Builder<T> {\n+      abstract Builder<T> setDataSourceProviderFn(\n+          SerializableFunction<Void, DataSource> dataSourceProviderFn);\n+\n+      abstract Builder<T> setTable(String table);\n+\n+      abstract Builder<T> setQuery(String query);\n+\n+      abstract Builder<T> setLocation(Location location);\n+\n+      abstract Builder<T> setFileNameTemplate(String fileNameTemplate);\n+\n+      abstract Builder<T> setUserDataMapper(UserDataMapper userDataMapper);\n+\n+      abstract Builder<T> setWriteDisposition(WriteDisposition writeDisposition);\n+\n+      abstract Builder<T> setSnowflakeService(SnowflakeService snowflakeService);\n+\n+      abstract Write<T> build();\n+    }\n+\n+    /**\n+     * Setting information about Snowflake server.\n+     *\n+     * @param config - An instance of {@link DataSourceConfiguration}.\n+     */\n+    public Write<T> withDataSourceConfiguration(final DataSourceConfiguration config) {\n+      return withDataSourceProviderFn(new DataSourceProviderFromDataSourceConfiguration(config));\n+    }\n+\n+    /**\n+     * Setting function that will provide {@link DataSourceConfiguration} in runtime.\n+     *\n+     * @param dataSourceProviderFn a {@link SerializableFunction}.\n+     */\n+    public Write<T> withDataSourceProviderFn(\n+        SerializableFunction<Void, DataSource> dataSourceProviderFn) {\n+      return toBuilder().setDataSourceProviderFn(dataSourceProviderFn).build();\n+    }\n+\n+    /**\n+     * A table name to be written in Snowflake.\n+     *\n+     * @param table - String with the name of the table.\n+     */\n+    public Write<T> to(String table) {\n+      return toBuilder().setTable(table).build();\n+    }\n+\n+    /**\n+     * A query to be executed in Snowflake.\n+     *\n+     * @param query - String with query.\n+     */\n+    public Write<T> withQueryTransformation(String query) {\n+      return toBuilder().setQuery(query).build();\n+    }\n+\n+    /**\n+     * A location object which contains connection config between Snowflake and GCP.\n+     *\n+     * @param location - an instance of {@link Location}.\n+     */\n+    public Write<T> via(Location location) {\n+      return toBuilder().setLocation(location).build();\n+    }\n+\n+    /**\n+     * A template name for files saved to GCP.\n+     *\n+     * @param fileNameTemplate - String with template name for files.\n+     */\n+    public Write<T> withFileNameTemplate(String fileNameTemplate) {\n+      return toBuilder().setFileNameTemplate(fileNameTemplate).build();\n+    }\n+\n+    /**\n+     * User-defined function mapping user data into CSV lines.\n+     *\n+     * @param userDataMapper - an instance of {@link UserDataMapper}.\n+     */\n+    public Write<T> withUserDataMapper(UserDataMapper userDataMapper) {\n+      return toBuilder().setUserDataMapper(userDataMapper).build();\n+    }\n+\n+    /**\n+     * A disposition to be used during writing to table phase.\n+     *\n+     * @param writeDisposition - an instance of {@link WriteDisposition}.\n+     */\n+    public Write<T> withWriteDisposition(WriteDisposition writeDisposition) {\n+      return toBuilder().setWriteDisposition(writeDisposition).build();\n+    }\n+\n+    /**\n+     * A snowflake service which is supposed to be used. Note: Currently we have {@link\n+     * SnowflakeServiceImpl} with corresponding {@link FakeSnowflakeServiceImpl} used for testing.\n+     *\n+     * @param snowflakeService - an instance of {@link SnowflakeService}.\n+     */\n+    public Write<T> withSnowflakeService(SnowflakeService snowflakeService) {\n+      return toBuilder().setSnowflakeService(snowflakeService).build();\n+    }\n+\n+    @Override\n+    public PDone expand(PCollection<T> input) {\n+      Location loc = getLocation();\n+      checkArguments(loc);\n+\n+      String stagingBucketDir = String.format(\"%s/%s/\", loc.getStagingBucketName(), WRITE_TMP_PATH);\n+\n+      PCollection out = write(input, stagingBucketDir);\n+      out.setCoder(StringUtf8Coder.of());\n+\n+      return PDone.in(out.getPipeline());\n+    }\n+\n+    private void checkArguments(Location loc) {\n+      checkArgument(loc != null, \"via() is required\");\n+      checkArgument(\n+          loc.getStorageIntegrationName() != null,\n+          \"location with storageIntegrationName is required\");\n+      checkArgument(\n+          loc.getStagingBucketName() != null, \"location with stagingBucketName is required\");\n+\n+      checkArgument(getUserDataMapper() != null, \"withUserDataMapper() is required\");\n+\n+      checkArgument(\n+          (getDataSourceProviderFn() != null),\n+          \"withDataSourceConfiguration() or withDataSourceProviderFn() is required\");\n+\n+      checkArgument(getTable() != null, \"withTable() is required\");\n+    }\n+\n+    private PCollection write(PCollection input, String stagingBucketDir) {\n+      SnowflakeService snowflakeService =\n+          getSnowflakeService() != null ? getSnowflakeService() : new SnowflakeServiceImpl();\n+\n+      PCollection files = writeFiles(input, stagingBucketDir);\n+\n+      files =\n+          (PCollection)\n+              files.apply(\"Create list of files to copy\", Combine.globally(new Concatenate()));\n+\n+      return (PCollection)\n+          files.apply(\"Copy files to table\", copyToTable(snowflakeService, stagingBucketDir));\n+    }\n+\n+    private PCollection writeFiles(PCollection<T> input, String stagingBucketDir) {\n+      class Parse extends DoFn<KV<T, String>, String> {\n+        @ProcessElement\n+        public void processElement(ProcessContext c) {\n+          c.output(c.element().getValue());\n+        }\n+      }\n+\n+      PCollection mappedUserData =\n+          input\n+              .apply(\n+                  \"Map user data to Objects array\",\n+                  ParDo.of(new MapUserDataObjectsArrayFn<T>(getUserDataMapper())))\n+              .apply(\"Map Objects array to CSV lines\", ParDo.of(new MapObjectsArrayToCsvFn()))\n+              .setCoder(StringUtf8Coder.of());\n+\n+      WriteFilesResult filesResult =\n+          (WriteFilesResult)\n+              mappedUserData.apply(\n+                  \"Write files to specified location\",\n+                  FileIO.write()\n+                      .via((FileIO.Sink) new CSVSink())\n+                      .to(stagingBucketDir)\n+                      .withPrefix(getFileNameTemplate())\n+                      .withSuffix(\".csv\")\n+                      .withPrefix(UUID.randomUUID().toString().subSequence(0, 8).toString())\n+                      .withCompression(Compression.GZIP));\n+\n+      return (PCollection)\n+          filesResult\n+              .getPerDestinationOutputFilenames()\n+              .apply(\"Parse KV filenames to Strings\", ParDo.of(new Parse()));\n+    }\n+\n+    private ParDo.SingleOutput<Object, Object> copyToTable(\n+        SnowflakeService snowflakeService, String stagingBucketDir) {\n+      return ParDo.of(\n+          new CopyToTableFn<>(\n+              getDataSourceProviderFn(),\n+              getTable(),\n+              getQuery(),\n+              stagingBucketDir,\n+              getLocation(),\n+              getWriteDisposition(),\n+              snowflakeService));\n+    }\n+  }\n+\n+  public static class Concatenate extends Combine.CombineFn<String, List<String>, List<String>> {", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODI4OTU4Ng==", "url": "https://github.com/apache/beam/pull/11794#discussion_r438289586", "bodyText": "Thank you @RyanSkraba - it was challenging but I think I managed to change it with Reify :) After testing it seems working as expected. Could you check is solution that you expected?", "author": "kkucharc", "createdAt": "2020-06-10T17:24:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTg5NTcyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkwMzE2Mw==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431903163", "bodyText": "Oooooooo -- relying on the toString() representation of a Java instance is almost always dangerous...  At this point, any non-String Object that contains a ' or , is going to break the current line.\nIs there any Snowflake doc on the CSV format they're using?  All I could find was related to valid character encodings.", "author": "RyanSkraba", "createdAt": "2020-05-28T14:56:44Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeIO.java", "diffHunk": "@@ -447,6 +494,346 @@ public void populateDisplayData(DisplayData.Builder builder) {\n     }\n   }\n \n+  /** Implementation of {@link #write()}. */\n+  @AutoValue\n+  public abstract static class Write<T> extends PTransform<PCollection<T>, PDone> {\n+    @Nullable\n+    abstract SerializableFunction<Void, DataSource> getDataSourceProviderFn();\n+\n+    @Nullable\n+    abstract String getTable();\n+\n+    @Nullable\n+    abstract String getQuery();\n+\n+    @Nullable\n+    abstract Location getLocation();\n+\n+    @Nullable\n+    abstract String getFileNameTemplate();\n+\n+    @Nullable\n+    abstract WriteDisposition getWriteDisposition();\n+\n+    @Nullable\n+    abstract UserDataMapper getUserDataMapper();\n+\n+    @Nullable\n+    abstract SnowflakeService getSnowflakeService();\n+\n+    abstract Builder<T> toBuilder();\n+\n+    @AutoValue.Builder\n+    abstract static class Builder<T> {\n+      abstract Builder<T> setDataSourceProviderFn(\n+          SerializableFunction<Void, DataSource> dataSourceProviderFn);\n+\n+      abstract Builder<T> setTable(String table);\n+\n+      abstract Builder<T> setQuery(String query);\n+\n+      abstract Builder<T> setLocation(Location location);\n+\n+      abstract Builder<T> setFileNameTemplate(String fileNameTemplate);\n+\n+      abstract Builder<T> setUserDataMapper(UserDataMapper userDataMapper);\n+\n+      abstract Builder<T> setWriteDisposition(WriteDisposition writeDisposition);\n+\n+      abstract Builder<T> setSnowflakeService(SnowflakeService snowflakeService);\n+\n+      abstract Write<T> build();\n+    }\n+\n+    /**\n+     * Setting information about Snowflake server.\n+     *\n+     * @param config - An instance of {@link DataSourceConfiguration}.\n+     */\n+    public Write<T> withDataSourceConfiguration(final DataSourceConfiguration config) {\n+      return withDataSourceProviderFn(new DataSourceProviderFromDataSourceConfiguration(config));\n+    }\n+\n+    /**\n+     * Setting function that will provide {@link DataSourceConfiguration} in runtime.\n+     *\n+     * @param dataSourceProviderFn a {@link SerializableFunction}.\n+     */\n+    public Write<T> withDataSourceProviderFn(\n+        SerializableFunction<Void, DataSource> dataSourceProviderFn) {\n+      return toBuilder().setDataSourceProviderFn(dataSourceProviderFn).build();\n+    }\n+\n+    /**\n+     * A table name to be written in Snowflake.\n+     *\n+     * @param table - String with the name of the table.\n+     */\n+    public Write<T> to(String table) {\n+      return toBuilder().setTable(table).build();\n+    }\n+\n+    /**\n+     * A query to be executed in Snowflake.\n+     *\n+     * @param query - String with query.\n+     */\n+    public Write<T> withQueryTransformation(String query) {\n+      return toBuilder().setQuery(query).build();\n+    }\n+\n+    /**\n+     * A location object which contains connection config between Snowflake and GCP.\n+     *\n+     * @param location - an instance of {@link Location}.\n+     */\n+    public Write<T> via(Location location) {\n+      return toBuilder().setLocation(location).build();\n+    }\n+\n+    /**\n+     * A template name for files saved to GCP.\n+     *\n+     * @param fileNameTemplate - String with template name for files.\n+     */\n+    public Write<T> withFileNameTemplate(String fileNameTemplate) {\n+      return toBuilder().setFileNameTemplate(fileNameTemplate).build();\n+    }\n+\n+    /**\n+     * User-defined function mapping user data into CSV lines.\n+     *\n+     * @param userDataMapper - an instance of {@link UserDataMapper}.\n+     */\n+    public Write<T> withUserDataMapper(UserDataMapper userDataMapper) {\n+      return toBuilder().setUserDataMapper(userDataMapper).build();\n+    }\n+\n+    /**\n+     * A disposition to be used during writing to table phase.\n+     *\n+     * @param writeDisposition - an instance of {@link WriteDisposition}.\n+     */\n+    public Write<T> withWriteDisposition(WriteDisposition writeDisposition) {\n+      return toBuilder().setWriteDisposition(writeDisposition).build();\n+    }\n+\n+    /**\n+     * A snowflake service which is supposed to be used. Note: Currently we have {@link\n+     * SnowflakeServiceImpl} with corresponding {@link FakeSnowflakeServiceImpl} used for testing.\n+     *\n+     * @param snowflakeService - an instance of {@link SnowflakeService}.\n+     */\n+    public Write<T> withSnowflakeService(SnowflakeService snowflakeService) {\n+      return toBuilder().setSnowflakeService(snowflakeService).build();\n+    }\n+\n+    @Override\n+    public PDone expand(PCollection<T> input) {\n+      Location loc = getLocation();\n+      checkArguments(loc);\n+\n+      String stagingBucketDir = String.format(\"%s/%s/\", loc.getStagingBucketName(), WRITE_TMP_PATH);\n+\n+      PCollection out = write(input, stagingBucketDir);\n+      out.setCoder(StringUtf8Coder.of());\n+\n+      return PDone.in(out.getPipeline());\n+    }\n+\n+    private void checkArguments(Location loc) {\n+      checkArgument(loc != null, \"via() is required\");\n+      checkArgument(\n+          loc.getStorageIntegrationName() != null,\n+          \"location with storageIntegrationName is required\");\n+      checkArgument(\n+          loc.getStagingBucketName() != null, \"location with stagingBucketName is required\");\n+\n+      checkArgument(getUserDataMapper() != null, \"withUserDataMapper() is required\");\n+\n+      checkArgument(\n+          (getDataSourceProviderFn() != null),\n+          \"withDataSourceConfiguration() or withDataSourceProviderFn() is required\");\n+\n+      checkArgument(getTable() != null, \"withTable() is required\");\n+    }\n+\n+    private PCollection write(PCollection input, String stagingBucketDir) {\n+      SnowflakeService snowflakeService =\n+          getSnowflakeService() != null ? getSnowflakeService() : new SnowflakeServiceImpl();\n+\n+      PCollection files = writeFiles(input, stagingBucketDir);\n+\n+      files =\n+          (PCollection)\n+              files.apply(\"Create list of files to copy\", Combine.globally(new Concatenate()));\n+\n+      return (PCollection)\n+          files.apply(\"Copy files to table\", copyToTable(snowflakeService, stagingBucketDir));\n+    }\n+\n+    private PCollection writeFiles(PCollection<T> input, String stagingBucketDir) {\n+      class Parse extends DoFn<KV<T, String>, String> {\n+        @ProcessElement\n+        public void processElement(ProcessContext c) {\n+          c.output(c.element().getValue());\n+        }\n+      }\n+\n+      PCollection mappedUserData =\n+          input\n+              .apply(\n+                  \"Map user data to Objects array\",\n+                  ParDo.of(new MapUserDataObjectsArrayFn<T>(getUserDataMapper())))\n+              .apply(\"Map Objects array to CSV lines\", ParDo.of(new MapObjectsArrayToCsvFn()))\n+              .setCoder(StringUtf8Coder.of());\n+\n+      WriteFilesResult filesResult =\n+          (WriteFilesResult)\n+              mappedUserData.apply(\n+                  \"Write files to specified location\",\n+                  FileIO.write()\n+                      .via((FileIO.Sink) new CSVSink())\n+                      .to(stagingBucketDir)\n+                      .withPrefix(getFileNameTemplate())\n+                      .withSuffix(\".csv\")\n+                      .withPrefix(UUID.randomUUID().toString().subSequence(0, 8).toString())\n+                      .withCompression(Compression.GZIP));\n+\n+      return (PCollection)\n+          filesResult\n+              .getPerDestinationOutputFilenames()\n+              .apply(\"Parse KV filenames to Strings\", ParDo.of(new Parse()));\n+    }\n+\n+    private ParDo.SingleOutput<Object, Object> copyToTable(\n+        SnowflakeService snowflakeService, String stagingBucketDir) {\n+      return ParDo.of(\n+          new CopyToTableFn<>(\n+              getDataSourceProviderFn(),\n+              getTable(),\n+              getQuery(),\n+              stagingBucketDir,\n+              getLocation(),\n+              getWriteDisposition(),\n+              snowflakeService));\n+    }\n+  }\n+\n+  public static class Concatenate extends Combine.CombineFn<String, List<String>, List<String>> {\n+    @Override\n+    public List<String> createAccumulator() {\n+      return new ArrayList<>();\n+    }\n+\n+    @Override\n+    public List<String> addInput(List<String> mutableAccumulator, String input) {\n+      mutableAccumulator.add(String.format(\"'%s'\", input));\n+      return mutableAccumulator;\n+    }\n+\n+    @Override\n+    public List<String> mergeAccumulators(Iterable<List<String>> accumulators) {\n+      List<String> result = createAccumulator();\n+      for (List<String> accumulator : accumulators) {\n+        result.addAll(accumulator);\n+      }\n+      return result;\n+    }\n+\n+    @Override\n+    public List<String> extractOutput(List<String> accumulator) {\n+      return accumulator;\n+    }\n+  }\n+\n+  private static class MapUserDataObjectsArrayFn<T> extends DoFn<T, Object[]> {\n+    private final UserDataMapper<T> csvMapper;\n+\n+    public MapUserDataObjectsArrayFn(UserDataMapper<T> csvMapper) {\n+      this.csvMapper = csvMapper;\n+    }\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext context) throws Exception {\n+      context.output(csvMapper.mapRow(context.element()));\n+    }\n+  }\n+\n+  /**\n+   * Custom DoFn that maps {@link Object[]} into CSV line to be saved to Snowflake.\n+   *\n+   * <p>Adds Snowflake-specific quotations around strings.\n+   */\n+  private static class MapObjectsArrayToCsvFn extends DoFn<Object[], String> {\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext context) {\n+      List<Object> csvItems = new ArrayList<>();\n+      for (Object o : context.element()) {\n+        if (o instanceof String) {\n+          String field = (String) o;\n+          field = field.replace(\"'\", \"''\");\n+          field = quoteField(field);\n+\n+          csvItems.add(field);\n+        } else {\n+          csvItems.add(o);", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkxMjc1NQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431912755", "bodyText": "Ugh, found a reference: https://docs.snowflake.com/en/user-guide/data-load-considerations-prepare.html#preparing-delimited-text-files\n\nFields that contain delimiter characters should be enclosed in quotes (single or double). If the data contains single or double quotes, then those quotes must be escaped.\n\nCan you confirm that this means 'I can''t believe it.' or 'I can\\'t believe it' ?", "author": "RyanSkraba", "createdAt": "2020-05-28T15:09:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkwMzE2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzYyNzY4Nw==", "url": "https://github.com/apache/beam/pull/11794#discussion_r433627687", "bodyText": "Based on  If the data contains single or double quotes, then those quotes must be escaped. proper is  'I can\\'t believe it'", "author": "purbanow", "createdAt": "2020-06-02T05:26:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkwMzE2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY3OTU2OQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r443679569", "bodyText": "The line above field = field.replace(\"'\", \"''\"); ?  It looks like the '' style.  If you confirm it works with Snowflake, I'll trust you!", "author": "RyanSkraba", "createdAt": "2020-06-22T16:23:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkwMzE2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkwNDkzNw==", "url": "https://github.com/apache/beam/pull/11794#discussion_r431904937", "bodyText": "Just to be sure you're aware!  This breaks users that are passing this information from the command line using the --stage option.", "author": "RyanSkraba", "createdAt": "2020-05-28T14:59:06Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakePipelineOptions.java", "diffHunk": "@@ -111,23 +111,13 @@\n \n   void setLoginTimeout(String loginTimeout);\n \n-  @Description(\"External location name to connect to.\")\n-  String getExternalLocation();\n-\n-  void setExternalLocation(String externalLocation);\n-\n-  @Description(\"Temporary GCS bucket name\")\n+  @Description(\"Temporary GCS bucket name.\")\n   String getStagingBucketName();\n \n   void setStagingBucketName(String stagingBucketName);\n \n-  @Description(\"Storage integration - required in case the external stage is not specified.\")\n-  String getStorageIntegration();\n-\n-  void setStorageIntegration(String integration);\n-\n-  @Description(\"Stage name. Optional.\")\n-  String getStage();\n+  @Description(\"Storage integration name\")\n+  String getStorageIntegrationName();", "originalCommit": "c845a2c9322dcdeab267beffc1eac707388eaa49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQwOTUxNw==", "url": "https://github.com/apache/beam/pull/11794#discussion_r432409517", "bodyText": "Yes. I'm totally aware of that. --stage option is not being used anywhere in the codebase.", "author": "purbanow", "createdAt": "2020-05-29T10:58:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTkwNDkzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY4NzEwMQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r443687101", "bodyText": "This is where there's an implicit .toString() on the objects in the array -- this is still pretty dangerous for many non-primitive classes!\nI can think of a couple of solutions: (1) Use something other than CSV as the file for copying into Snowflake, (2) Add a warning to the data mapper doc that the toString's have to be coherent!\nFor example, if my data mapper function returns new Object[] {Arrays.asList(1,',',\"\\n\")} to insert, it's almost certainly going to break the function.\nI can see this happening, for example, if a user thinks that returning a JsonObject will insert the JSON as a string into that column.", "author": "RyanSkraba", "createdAt": "2020-06-22T16:35:10Z", "path": "sdks/java/io/snowflake/src/main/java/org/apache/beam/sdk/io/snowflake/SnowflakeIO.java", "diffHunk": "@@ -447,6 +513,346 @@ public void populateDisplayData(DisplayData.Builder builder) {\n     }\n   }\n \n+  /** Implementation of {@link #write()}. */\n+  @AutoValue\n+  public abstract static class Write<T> extends PTransform<PCollection<T>, PDone> {\n+    @Nullable\n+    abstract SerializableFunction<Void, DataSource> getDataSourceProviderFn();\n+\n+    @Nullable\n+    abstract String getTable();\n+\n+    @Nullable\n+    abstract String getStorageIntegrationName();\n+\n+    @Nullable\n+    abstract String getStagingBucketName();\n+\n+    @Nullable\n+    abstract String getQuery();\n+\n+    @Nullable\n+    abstract String getFileNameTemplate();\n+\n+    @Nullable\n+    abstract WriteDisposition getWriteDisposition();\n+\n+    @Nullable\n+    abstract UserDataMapper getUserDataMapper();\n+\n+    @Nullable\n+    abstract SnowflakeService getSnowflakeService();\n+\n+    abstract Builder<T> toBuilder();\n+\n+    @AutoValue.Builder\n+    abstract static class Builder<T> {\n+      abstract Builder<T> setDataSourceProviderFn(\n+          SerializableFunction<Void, DataSource> dataSourceProviderFn);\n+\n+      abstract Builder<T> setTable(String table);\n+\n+      abstract Builder<T> setStorageIntegrationName(String storageIntegrationName);\n+\n+      abstract Builder<T> setStagingBucketName(String stagingBucketName);\n+\n+      abstract Builder<T> setQuery(String query);\n+\n+      abstract Builder<T> setFileNameTemplate(String fileNameTemplate);\n+\n+      abstract Builder<T> setUserDataMapper(UserDataMapper userDataMapper);\n+\n+      abstract Builder<T> setWriteDisposition(WriteDisposition writeDisposition);\n+\n+      abstract Builder<T> setSnowflakeService(SnowflakeService snowflakeService);\n+\n+      abstract Write<T> build();\n+    }\n+\n+    /**\n+     * Setting information about Snowflake server.\n+     *\n+     * @param config - An instance of {@link DataSourceConfiguration}.\n+     */\n+    public Write<T> withDataSourceConfiguration(final DataSourceConfiguration config) {\n+      return withDataSourceProviderFn(new DataSourceProviderFromDataSourceConfiguration(config));\n+    }\n+\n+    /**\n+     * Setting function that will provide {@link DataSourceConfiguration} in runtime.\n+     *\n+     * @param dataSourceProviderFn a {@link SerializableFunction}.\n+     */\n+    public Write<T> withDataSourceProviderFn(\n+        SerializableFunction<Void, DataSource> dataSourceProviderFn) {\n+      return toBuilder().setDataSourceProviderFn(dataSourceProviderFn).build();\n+    }\n+\n+    /**\n+     * A table name to be written in Snowflake.\n+     *\n+     * @param table - String with the name of the table.\n+     */\n+    public Write<T> withTable(String table) {\n+      return toBuilder().setTable(table).build();\n+    }\n+\n+    /**\n+     * Name of the cloud bucket (GCS by now) to use as tmp location of CSVs during COPY statement.\n+     *\n+     * @param stagingBucketName - String with the name of the bucket.\n+     */\n+    public Write<T> withStagingBucketName(String stagingBucketName) {\n+      return toBuilder().setStagingBucketName(stagingBucketName).build();\n+    }\n+\n+    /**\n+     * Name of the Storage Integration in Snowflake to be used. See\n+     * https://docs.snowflake.com/en/sql-reference/sql/create-storage-integration.html for\n+     * reference.\n+     *\n+     * @param integrationName - String with the name of the Storage Integration.\n+     */\n+    public Write<T> withStorageIntegrationName(String integrationName) {\n+      return toBuilder().setStorageIntegrationName(integrationName).build();\n+    }\n+\n+    /**\n+     * A query to be executed in Snowflake.\n+     *\n+     * @param query - String with query.\n+     */\n+    public Write<T> withQueryTransformation(String query) {\n+      return toBuilder().setQuery(query).build();\n+    }\n+\n+    /**\n+     * A template name for files saved to GCP.\n+     *\n+     * @param fileNameTemplate - String with template name for files.\n+     */\n+    public Write<T> withFileNameTemplate(String fileNameTemplate) {\n+      return toBuilder().setFileNameTemplate(fileNameTemplate).build();\n+    }\n+\n+    /**\n+     * User-defined function mapping user data into CSV lines.\n+     *\n+     * @param userDataMapper - an instance of {@link UserDataMapper}.\n+     */\n+    public Write<T> withUserDataMapper(UserDataMapper userDataMapper) {\n+      return toBuilder().setUserDataMapper(userDataMapper).build();\n+    }\n+\n+    /**\n+     * A disposition to be used during writing to table phase.\n+     *\n+     * @param writeDisposition - an instance of {@link WriteDisposition}.\n+     */\n+    public Write<T> withWriteDisposition(WriteDisposition writeDisposition) {\n+      return toBuilder().setWriteDisposition(writeDisposition).build();\n+    }\n+\n+    /**\n+     * A snowflake service which is supposed to be used. Note: Currently we have {@link\n+     * SnowflakeServiceImpl} with corresponding {@link FakeSnowflakeServiceImpl} used for testing.\n+     *\n+     * @param snowflakeService - an instance of {@link SnowflakeService}.\n+     */\n+    public Write<T> withSnowflakeService(SnowflakeService snowflakeService) {\n+      return toBuilder().setSnowflakeService(snowflakeService).build();\n+    }\n+\n+    @Override\n+    public PDone expand(PCollection<T> input) {\n+      checkArguments();\n+\n+      String stagingBucketDir = String.format(\"%s/%s/\", getStagingBucketName(), WRITE_TMP_PATH);\n+\n+      PCollection<String> out = write(input, stagingBucketDir);\n+      out.setCoder(StringUtf8Coder.of());\n+\n+      return PDone.in(out.getPipeline());\n+    }\n+\n+    private void checkArguments() {\n+      checkArgument(getStagingBucketName() != null, \"withStagingBucketName is required\");\n+\n+      checkArgument(getUserDataMapper() != null, \"withUserDataMapper() is required\");\n+\n+      checkArgument(\n+          (getDataSourceProviderFn() != null),\n+          \"withDataSourceConfiguration() or withDataSourceProviderFn() is required\");\n+\n+      checkArgument(getTable() != null, \"withTable() is required\");\n+    }\n+\n+    private PCollection<String> write(PCollection<T> input, String stagingBucketDir) {\n+      SnowflakeService snowflakeService =\n+          getSnowflakeService() != null ? getSnowflakeService() : new SnowflakeServiceImpl();\n+\n+      PCollection<String> files = writeFiles(input, stagingBucketDir);\n+\n+      // Combining PCollection of files as a side input into one list of files\n+      ListCoder<String> coder = ListCoder.of(StringUtf8Coder.of());\n+      files =\n+          (PCollection)\n+              files\n+                  .getPipeline()\n+                  .apply(\n+                      Reify.viewInGlobalWindow(\n+                          (PCollectionView) files.apply(View.asList()), coder));\n+\n+      return (PCollection)\n+          files.apply(\"Copy files to table\", copyToTable(snowflakeService, stagingBucketDir));\n+    }\n+\n+    private PCollection<String> writeFiles(PCollection<T> input, String stagingBucketDir) {\n+\n+      PCollection<String> mappedUserData =\n+          input\n+              .apply(\n+                  MapElements.via(\n+                      new SimpleFunction<T, Object[]>() {\n+                        @Override\n+                        public Object[] apply(T element) {\n+                          return getUserDataMapper().mapRow(element);\n+                        }\n+                      }))\n+              .apply(\"Map Objects array to CSV lines\", ParDo.of(new MapObjectsArrayToCsvFn()))\n+              .setCoder(StringUtf8Coder.of());\n+\n+      WriteFilesResult filesResult =\n+          mappedUserData.apply(\n+              \"Write files to specified location\",\n+              FileIO.<String>write()\n+                  .via(TextIO.sink())\n+                  .to(stagingBucketDir)\n+                  .withPrefix(getFileNameTemplate())\n+                  .withSuffix(\".csv\")\n+                  .withCompression(Compression.GZIP));\n+\n+      return (PCollection)\n+          filesResult\n+              .getPerDestinationOutputFilenames()\n+              .apply(\"Parse KV filenames to Strings\", Values.<String>create());\n+    }\n+\n+    private ParDo.SingleOutput<Object, Object> copyToTable(\n+        SnowflakeService snowflakeService, String stagingBucketDir) {\n+      return ParDo.of(\n+          new CopyToTableFn<>(\n+              getDataSourceProviderFn(),\n+              getTable(),\n+              getQuery(),\n+              stagingBucketDir,\n+              getStorageIntegrationName(),\n+              getWriteDisposition(),\n+              snowflakeService));\n+    }\n+  }\n+\n+  public static class Concatenate extends Combine.CombineFn<String, List<String>, List<String>> {\n+    @Override\n+    public List<String> createAccumulator() {\n+      return new ArrayList<>();\n+    }\n+\n+    @Override\n+    public List<String> addInput(List<String> mutableAccumulator, String input) {\n+      mutableAccumulator.add(String.format(\"'%s'\", input));\n+      return mutableAccumulator;\n+    }\n+\n+    @Override\n+    public List<String> mergeAccumulators(Iterable<List<String>> accumulators) {\n+      List<String> result = createAccumulator();\n+      for (List<String> accumulator : accumulators) {\n+        result.addAll(accumulator);\n+      }\n+      return result;\n+    }\n+\n+    @Override\n+    public List<String> extractOutput(List<String> accumulator) {\n+      return accumulator;\n+    }\n+  }\n+\n+  /**\n+   * Custom DoFn that maps {@link Object[]} into CSV line to be saved to Snowflake.\n+   *\n+   * <p>Adds Snowflake-specific quotations around strings.\n+   */\n+  private static class MapObjectsArrayToCsvFn extends DoFn<Object[], String> {\n+\n+    @ProcessElement\n+    public void processElement(ProcessContext context) {\n+      List<Object> csvItems = new ArrayList<>();\n+      for (Object o : context.element()) {\n+        if (o instanceof String) {\n+          String field = (String) o;\n+          field = field.replace(\"'\", \"''\");\n+          field = quoteField(field);\n+\n+          csvItems.add(field);\n+        } else {\n+          csvItems.add(o);\n+        }\n+      }\n+      context.output(Joiner.on(\",\").useForNull(\"\").join(csvItems));", "originalCommit": "4ad146d41101aca5db3c2351f6232761fff8ebf0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NDA1NTU3MQ==", "url": "https://github.com/apache/beam/pull/11794#discussion_r444055571", "bodyText": "Thanks for pointing this. We're going to add it to our feature improvement list.", "author": "purbanow", "createdAt": "2020-06-23T08:34:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzY4NzEwMQ=="}], "type": "inlineReview"}, {"oid": "0a643746208e0e422943726f5862d9a041acbbb5", "url": "https://github.com/apache/beam/commit/0a643746208e0e422943726f5862d9a041acbbb5", "message": "[BEAM-9894] Snowflake write - change Combine step into Reify", "committedDate": "2020-06-23T07:36:31Z", "type": "forcePushed"}, {"oid": "6375a925dd2987d3f0f38e7f76cbb47e222dfa50", "url": "https://github.com/apache/beam/commit/6375a925dd2987d3f0f38e7f76cbb47e222dfa50", "message": "[BEAM-9894] Add batch SnowflakeIO.Write to Java SDK", "committedDate": "2020-06-24T05:14:30Z", "type": "commit"}, {"oid": "73ef5dea01f4249c063c19429bc63f92e3069d3a", "url": "https://github.com/apache/beam/commit/73ef5dea01f4249c063c19429bc63f92e3069d3a", "message": "fix: add missing license headers", "committedDate": "2020-06-24T05:14:30Z", "type": "commit"}, {"oid": "0cb6328009f1b2ee4dff288556059b1f63ae2159", "url": "https://github.com/apache/beam/commit/0cb6328009f1b2ee4dff288556059b1f63ae2159", "message": "refactor: method names", "committedDate": "2020-06-24T05:14:31Z", "type": "commit"}, {"oid": "515894c4b87797ff434a7211a74abcd1cb2ef3dd", "url": "https://github.com/apache/beam/commit/515894c4b87797ff434a7211a74abcd1cb2ef3dd", "message": "fix: make Location.storageIntegrationName as a nullable variable", "committedDate": "2020-06-24T05:14:31Z", "type": "commit"}, {"oid": "c571a69c675b6e65a5f6cbd3cbc5ae67a15b76e9", "url": "https://github.com/apache/beam/commit/c571a69c675b6e65a5f6cbd3cbc5ae67a15b76e9", "message": "fix: remove MapUserDataObjectsArrayFn class", "committedDate": "2020-06-24T05:14:31Z", "type": "commit"}, {"oid": "e4564cd8ee60d5bf96d68f0e25e55e587214b0df", "url": "https://github.com/apache/beam/commit/e4564cd8ee60d5bf96d68f0e25e55e587214b0df", "message": "fix(SnowFlakeIO): removed Parse class + add @Experimental annotation", "committedDate": "2020-06-24T05:14:31Z", "type": "commit"}, {"oid": "44615d5eaaac8bb4e736330085647c326c0b0785", "url": "https://github.com/apache/beam/commit/44615d5eaaac8bb4e736330085647c326c0b0785", "message": "refactor(SnowFlakeIO): removed Location class", "committedDate": "2020-06-24T05:14:31Z", "type": "commit"}, {"oid": "6bc58d7e87dd830d06beb9fe43ae155878c36723", "url": "https://github.com/apache/beam/commit/6bc58d7e87dd830d06beb9fe43ae155878c36723", "message": "fix(SnowFlakeIO): added missing types", "committedDate": "2020-06-24T05:14:31Z", "type": "commit"}, {"oid": "1e44ed0db8940c6e3f3dce020261d17bbebebe0e", "url": "https://github.com/apache/beam/commit/1e44ed0db8940c6e3f3dce020261d17bbebebe0e", "message": "refactor(SnowFlakeIO): removed CSVSink class", "committedDate": "2020-06-24T05:14:31Z", "type": "commit"}, {"oid": "14cf5aeb5b9b3ac663158fef9ca54d06963c6568", "url": "https://github.com/apache/beam/commit/14cf5aeb5b9b3ac663158fef9ca54d06963c6568", "message": "[BEAM-9894] Snowflake write - change Combine step into Reify", "committedDate": "2020-06-24T05:14:31Z", "type": "commit"}, {"oid": "14cf5aeb5b9b3ac663158fef9ca54d06963c6568", "url": "https://github.com/apache/beam/commit/14cf5aeb5b9b3ac663158fef9ca54d06963c6568", "message": "[BEAM-9894] Snowflake write - change Combine step into Reify", "committedDate": "2020-06-24T05:14:31Z", "type": "forcePushed"}]}