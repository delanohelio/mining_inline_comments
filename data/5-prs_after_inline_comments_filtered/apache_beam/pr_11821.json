{"pr_number": 11821, "pr_title": "[BEAM-10097, BEAM-5982, BEAM-3080] Use primitive views directly instead of transforming KV<Void, Iterable<T>> to the view type via a naive mapping.", "pr_createdAt": "2020-05-26T22:22:26Z", "pr_url": "https://github.com/apache/beam/pull/11821", "timeline": [{"oid": "d8abc25540a0ed2227de8c549fbd67379007aa50", "url": "https://github.com/apache/beam/commit/d8abc25540a0ed2227de8c549fbd67379007aa50", "message": "[BEAM-10097, BEAM-5982, BEAM-3080] Use primitive views directly instead of transforming KV<Void, Iterable<T>> to the view type via a naive mapping.\n\nThis does not impact non-portable Dataflow since it overrides the PTransform expansion PCollection views.\nThis currently has little benefit for other runners since they still treat all views as in memory iterables of values but opens the door for them to meaningfully provide optimized versions.", "committedDate": "2020-05-27T22:25:54Z", "type": "forcePushed"}, {"oid": "f71ba818bdbed1c60d20d126730a1447cc38b466", "url": "https://github.com/apache/beam/commit/f71ba818bdbed1c60d20d126730a1447cc38b466", "message": "[BEAM-10097, BEAM-5982, BEAM-3080] Use primitive views directly instead of transforming KV<Void, Iterable<T>> to the view type via a naive mapping.\n\nThis does not impact non-portable Dataflow since it overrides the PTransform expansion PCollection views.\nThis currently has little benefit for other runners since they still treat all views as in memory iterables of values but opens the door for them to meaningfully provide optimized versions.", "committedDate": "2020-05-27T22:43:05Z", "type": "forcePushed"}, {"oid": "12e1760588da1357421a5968695c1e271d0b39e1", "url": "https://github.com/apache/beam/commit/12e1760588da1357421a5968695c1e271d0b39e1", "message": "[BEAM-10097, BEAM-5982, BEAM-3080] Use primitive views directly instead of transforming KV<Void, Iterable<T>> to the view type via a naive mapping.\n\nThis does not impact non-portable Dataflow since it overrides the PTransform expansion PCollection views.\nThis currently has little benefit for other runners since they still treat all views as in memory iterables of values but opens the door for them to meaningfully provide optimized versions.", "committedDate": "2020-05-28T17:55:09Z", "type": "forcePushed"}, {"oid": "dadff619b01125ff73c5f85aeea641f5635afe37", "url": "https://github.com/apache/beam/commit/dadff619b01125ff73c5f85aeea641f5635afe37", "message": "[BEAM-10097, BEAM-5982, BEAM-3080] Use primitive views directly instead of transforming KV<Void, Iterable<T>> to the view type via a naive mapping.\n\nThis does not impact non-portable runners since the new expansion is guarded by the experiment \"beam_fn_api\".\nThis currently has little benefit for portable runners since they still treat all views as in memory iterables of values but opens the door for them to meaningfully provide optimized versions.\nThe singleton and iterable views can't be translated except if using the Dataflow runner v2 experiment since runner v1 doesn't support the iterable access pattern.", "committedDate": "2020-06-01T19:21:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwNDU2Nw==", "url": "https://github.com/apache/beam/pull/11821#discussion_r439604567", "bodyText": "This is unrelated to your changes, but I'm curious why we would return empty here instead of throwing an error?", "author": "ibzib", "createdAt": "2020-06-12T19:27:13Z", "path": "runners/flink/src/main/java/org/apache/beam/runners/flink/translation/functions/FlinkSideInputReader.java", "diffHunk": "@@ -71,8 +79,23 @@ public FlinkSideInputReader(\n             tag.getId(), new SideInputInitializer<>(view));\n     T result = sideInputs.get(window);\n     if (result == null) {\n-      ViewFn<MultimapView, T> viewFn = (ViewFn<MultimapView, T>) view.getViewFn();\n-      result = viewFn.apply(InMemoryMultimapSideInputView.empty());", "originalCommit": "6352f726feec43529c06659c48f0224815d07cbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyMTI2NA==", "url": "https://github.com/apache/beam/pull/11821#discussion_r440421264", "bodyText": "In this case the side input is a valid side input but Flink says it has no data for it by returning null. Also viewFn.apply expects a non-null value which is why we pass in an empty view.", "author": "lukecwik", "createdAt": "2020-06-15T20:14:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwNDU2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwNzE0Mw==", "url": "https://github.com/apache/beam/pull/11821#discussion_r439607143", "bodyText": "Are use_runner_v2 and use_unified_worker synonymous? If so, which is preferred?", "author": "ibzib", "createdAt": "2020-06-12T19:33:26Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/Combine.java", "diffHunk": "@@ -1302,13 +1303,35 @@ private GloballyAsSingletonView(\n \n     @Override\n     public PCollectionView<OutputT> expand(PCollection<InputT> input) {\n+      // TODO(BEAM-10097): Make this the default expansion for all portable runners.\n+      if (hasExperiment(input.getPipeline().getOptions(), \"beam_fn_api\")\n+          && (hasExperiment(input.getPipeline().getOptions(), \"use_runner_v2\")", "originalCommit": "6352f726feec43529c06659c48f0224815d07cbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyMTI1Mg==", "url": "https://github.com/apache/beam/pull/11821#discussion_r440421252", "bodyText": "use_runner_v2 is preferred but internal test framework within Google has not been fully migrated to use one over the other. Also Googlers typically use use_unified_worker", "author": "lukecwik", "createdAt": "2020-06-15T20:14:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwNzE0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwNzQ0OQ==", "url": "https://github.com/apache/beam/pull/11821#discussion_r439607449", "bodyText": "Is the performance difference dependent on the runner implementation?", "author": "ibzib", "createdAt": "2020-06-12T19:34:16Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/View.java", "diffHunk": "@@ -157,7 +166,10 @@ private View() {}\n    * PCollectionView} mapping each window to a {@link List} containing all of the elements in the\n    * window.\n    *\n-   * <p>Unlike with {@link #asIterable}, the resulting list is required to fit in memory.\n+   * <p>This view should only be used if random access and/or size of the PCollection is required.\n+   * {@link #asIterable()} will perform significantly better for sequential access.", "originalCommit": "6352f726feec43529c06659c48f0224815d07cbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyMjQ4Mw==", "url": "https://github.com/apache/beam/pull/11821#discussion_r440422483", "bodyText": "No, most runners will be able to easily support an efficient iterable representation even if they only support an efficient multimap representation since the mapping on the runners side is trivial. The converse is not true.\nAlso, the list side input adds additional overhead in the format which the iterable does not.\nFinally, the list side input is about accessing elements in a random access fashion and the current format is likely to only assign one element underneath each key so sequential access will be much better under the iterable case.", "author": "lukecwik", "createdAt": "2020-06-15T20:17:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwNzQ0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ1NjA5Mg==", "url": "https://github.com/apache/beam/pull/11821#discussion_r440456092", "bodyText": "Thanks for the explanation.", "author": "ibzib", "createdAt": "2020-06-15T21:25:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwNzQ0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY0MTI3OQ==", "url": "https://github.com/apache/beam/pull/11821#discussion_r439641279", "bodyText": "I'm not sure these implementation details belong at the javadoc level; consider moving them into the body of the class so it's clearer what it's describing.", "author": "ibzib", "createdAt": "2020-06-12T21:03:06Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/View.java", "diffHunk": "@@ -219,6 +231,16 @@ private View() {}\n    * <p>Public only so a {@link PipelineRunner} may override its behavior.\n    *\n    * <p>See {@link View#asList()}.\n+   *\n+   * <p>The materialized format uses {@link Materializations#MULTIMAP_MATERIALIZATION_URN multimap}", "originalCommit": "6352f726feec43529c06659c48f0224815d07cbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyNjA4Mg==", "url": "https://github.com/apache/beam/pull/11821#discussion_r440426082", "bodyText": "Done", "author": "lukecwik", "createdAt": "2020-06-15T20:24:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY0MTI3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY0NTA1Mw==", "url": "https://github.com/apache/beam/pull/11821#discussion_r439645053", "bodyText": "Nit: consider a more descriptive naming scheme and/or comments to differentiate these from the originals.", "author": "ibzib", "createdAt": "2020-06-12T21:14:35Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/values/PCollectionViews.java", "diffHunk": "@@ -151,13 +279,103 @@\n   }\n \n   /**\n-   * Implementation which is able to adapt a multimap materialization to a {@code T}.\n+   * Implementation which is able to adapt an iterable materialization to a {@code T}.\n    *\n    * <p>For internal use only.\n    *\n    * <p>Instantiate via {@link PCollectionViews#singletonView}.\n    */\n   @Experimental(Kind.CORE_RUNNERS_ONLY)\n+  private static class SingletonViewFn2<T> extends ViewFn<IterableView<T>, T> {", "originalCommit": "6352f726feec43529c06659c48f0224815d07cbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyNzI1Mg==", "url": "https://github.com/apache/beam/pull/11821#discussion_r440427252", "bodyText": "The intent is that SingletonViewFn/MultimapViewFn/... would be removed and the SingletonViewFn2/MultimapViewFn2 would replace them once the JRH no longer exists.\nAdded comments.", "author": "lukecwik", "createdAt": "2020-06-15T20:27:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY0NTA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY0ODY4Nw==", "url": "https://github.com/apache/beam/pull/11821#discussion_r439648687", "bodyText": "Nit: missing a noun here", "author": "ibzib", "createdAt": "2020-06-12T21:25:40Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/values/PCollectionViews.java", "diffHunk": "@@ -533,4 +1251,141 @@ public String toString() {\n       return Collections.singletonMap(tag, pCollection);\n     }\n   }\n+\n+  /** A {@link MultimapView} to {@link Map Map<K, V>} adapter. */\n+  private static class MultimapViewToMapAdapter<K, V> extends AbstractMap<K, V> {\n+    private final MultimapView<K, V> primitiveViewT;\n+    private final Supplier<Integer> size;\n+\n+    private MultimapViewToMapAdapter(MultimapView<K, V> primitiveViewT) {\n+      this.primitiveViewT = primitiveViewT;\n+      this.size = Suppliers.memoize(() -> Iterables.size(primitiveViewT.get()));\n+    }\n+\n+    @Override\n+    public boolean containsKey(Object key) {\n+      return primitiveViewT.get((K) key).iterator().hasNext();\n+    }\n+\n+    @Override\n+    public V get(Object key) {\n+      Iterator<V> iterator = primitiveViewT.get((K) key).iterator();\n+      if (!iterator.hasNext()) {\n+        return null;\n+      }\n+      V value = iterator.next();\n+      if (iterator.hasNext()) {\n+        throw new IllegalArgumentException(\"Duplicate values for \" + key);\n+      }\n+      return value;\n+    }\n+\n+    @Override\n+    public int size() {\n+      return size.get();\n+    }\n+\n+    @Override\n+    public Set<Entry<K, V>> entrySet() {\n+      return new AbstractSet<Entry<K, V>>() {\n+        @Override\n+        public Iterator<Entry<K, V>> iterator() {\n+          return FluentIterable.from(primitiveViewT.get())\n+              .<Entry<K, V>>transform((K key) -> new SimpleEntry<>(key, get(key)))\n+              .iterator();\n+        }\n+\n+        @Override\n+        public boolean contains(Object o) {\n+          if (!(o instanceof Entry)) {\n+            return false;\n+          }\n+          Entry<?, ?> entry = (Entry<?, ?>) o;\n+          // We treat the absence of the key in the map as a difference in these abstract sets. The\n+          // underlying primitive view represents missing keys as empty iterables so we use this\n+          // to check if the map contains the key first before comparing values.\n+          Iterable<V> value = primitiveViewT.get((K) entry.getKey());\n+          if (value.iterator().hasNext()) {\n+            return false;\n+          }\n+          return Objects.equals(entry.getValue(), value);\n+        }\n+\n+        @Override\n+        public int size() {\n+          return size.get();\n+        }\n+      };\n+    }\n+  }\n+\n+  /** A {@link MultimapView} to {@link Map Map<K, Iterable<V>>} adapter. */\n+  private static class MultimapViewToMultimapAdapter<K, V> extends AbstractMap<K, Iterable<V>> {\n+    private final MultimapView<K, V> primitiveViewT;\n+    private final Supplier<Integer> size;\n+\n+    private MultimapViewToMultimapAdapter(MultimapView<K, V> primitiveViewT) {\n+      this.primitiveViewT = primitiveViewT;\n+      this.size = Suppliers.memoize(() -> Iterables.size(primitiveViewT.get()));\n+    }\n+\n+    @Override\n+    public boolean containsKey(Object key) {\n+      return primitiveViewT.get((K) key).iterator().hasNext();\n+    }\n+\n+    @Override\n+    public Iterable<V> get(Object key) {\n+      Iterable<V> values = primitiveViewT.get((K) key);\n+      // The only was for the values iterable to be empty is for us to have never seen such a key", "originalCommit": "6352f726feec43529c06659c48f0224815d07cbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyNzkzMQ==", "url": "https://github.com/apache/beam/pull/11821#discussion_r440427931", "bodyText": "Done", "author": "lukecwik", "createdAt": "2020-06-15T20:28:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY0ODY4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3OTY1OQ==", "url": "https://github.com/apache/beam/pull/11821#discussion_r439679659", "bodyText": "Nit: Can you rename this class? Maybe something like \"ValueOrMetadata\"?", "author": "ibzib", "createdAt": "2020-06-12T23:32:45Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/values/PCollectionViews.java", "diffHunk": "@@ -278,6 +528,398 @@ public IterableViewFn(TypeDescriptorSupplier<T> typeDescriptorSupplier) {\n    * <p>Instantiate via {@link PCollectionViews#listView}.\n    */\n   @Experimental(Kind.CORE_RUNNERS_ONLY)\n+  @VisibleForTesting\n+  static class ListViewFn2<T> extends ViewFn<MultimapView<Long, MetaOr<T, OffsetRange>>, List<T>> {\n+    private TypeDescriptorSupplier<T> typeDescriptorSupplier;\n+\n+    public ListViewFn2(TypeDescriptorSupplier<T> typeDescriptorSupplier) {\n+      this.typeDescriptorSupplier = typeDescriptorSupplier;\n+    }\n+\n+    @Override\n+    public Materialization<MultimapView<Long, MetaOr<T, OffsetRange>>> getMaterialization() {\n+      return Materializations.multimap();\n+    }\n+\n+    @Override\n+    public List<T> apply(MultimapView<Long, MetaOr<T, OffsetRange>> primitiveViewT) {\n+      return Collections.unmodifiableList(new ListOverMultimapView<>(primitiveViewT));\n+    }\n+\n+    @Override\n+    public TypeDescriptor<List<T>> getTypeDescriptor() {\n+      return TypeDescriptors.lists(typeDescriptorSupplier.get());\n+    }\n+\n+    /**\n+     * A {@link List} adapter over a {@link MultimapView}.\n+     *\n+     * <p>See {@link View.AsList} for a description of the materialized format and {@code index} to\n+     * {@code (position, sub-position)} mapping details.\n+     */\n+    private static class ListOverMultimapView<T> extends AbstractList<T> implements RandomAccess {\n+      private final MultimapView<Long, MetaOr<T, OffsetRange>> primitiveView;\n+      /**\n+       * A mapping from non over-lapping ranges to the number of elements at each position within\n+       * that range. Ranges not specified in the mapping implicitly have 0 elements at those\n+       * positions.\n+       *\n+       * <p>Used to quickly compute the {@code index} -> {@code (position, sub-position} within the\n+       * map.\n+       */\n+      private final Supplier<SortedMap<OffsetRange, Integer>>\n+          nonOverlappingRangesToNumElementsPerPosition;\n+\n+      private final Supplier<Integer> size;\n+\n+      private ListOverMultimapView(MultimapView<Long, MetaOr<T, OffsetRange>> primitiveView) {\n+        this.primitiveView = primitiveView;\n+        this.nonOverlappingRangesToNumElementsPerPosition =\n+            Suppliers.memoize(\n+                () ->\n+                    computeOverlappingRanges(\n+                        Iterables.transform(\n+                            primitiveView.get(Long.MIN_VALUE), (value) -> value.getMetadata())));\n+        this.size =\n+            Suppliers.memoize(\n+                () -> computeTotalNumElements(nonOverlappingRangesToNumElementsPerPosition.get()));\n+      }\n+\n+      @Override\n+      public T get(int index) {\n+        if (index < 0 || index >= size.get()) {\n+          throw new IndexOutOfBoundsException();\n+        }\n+        KV<Long, Integer> position =\n+            computePositionForIndex(nonOverlappingRangesToNumElementsPerPosition.get(), index);\n+        return Iterables.get(primitiveView.get(position.getKey()), position.getValue()).get();\n+      }\n+\n+      @Override\n+      public int size() {\n+        return size.get();\n+      }\n+\n+      @Override\n+      public Iterator<T> iterator() {\n+        return listIterator();\n+      }\n+\n+      @Override\n+      public ListIterator<T> listIterator() {\n+        return super.listIterator();\n+      }\n+\n+      /** A {@link ListIterator} over {@link MultimapView} adapter. */\n+      private class ListIteratorOverMultimapView implements ListIterator<T> {\n+        private int position;\n+\n+        @Override\n+        public boolean hasNext() {\n+          return position < size();\n+        }\n+\n+        @Override\n+        public T next() {\n+          if (!hasNext()) {\n+            throw new NoSuchElementException();\n+          }\n+          T rval = get(position);\n+          position += 1;\n+          return rval;\n+        }\n+\n+        @Override\n+        public boolean hasPrevious() {\n+          return position > 0;\n+        }\n+\n+        @Override\n+        public T previous() {\n+          if (!hasPrevious()) {\n+            throw new NoSuchElementException();\n+          }\n+          position -= 1;\n+          return get(position);\n+        }\n+\n+        @Override\n+        public int nextIndex() {\n+          return position;\n+        }\n+\n+        @Override\n+        public int previousIndex() {\n+          return position - 1;\n+        }\n+\n+        @Override\n+        public void remove() {\n+          throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void set(T e) {\n+          throw new UnsupportedOperationException();\n+        }\n+\n+        @Override\n+        public void add(T e) {\n+          throw new UnsupportedOperationException();\n+        }\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Compares {@link OffsetRange}s such that ranges are ordered by the smallest {@code from} and in\n+   * case of a tie the smallest {@code to}.\n+   */\n+  @VisibleForTesting\n+  static class OffsetRangeComparator implements Comparator<OffsetRange> {\n+    private static final OffsetRangeComparator INSTANCE = new OffsetRangeComparator();\n+\n+    @Override\n+    public int compare(OffsetRange o1, OffsetRange o2) {\n+      int fromComparison = Longs.compare(o1.getFrom(), o2.getFrom());\n+      if (fromComparison != 0) {\n+        return fromComparison;\n+      }\n+      return Longs.compare(o1.getTo(), o2.getTo());\n+    }\n+  }\n+\n+  @VisibleForTesting\n+  static SortedMap<OffsetRange, Integer> computeOverlappingRanges(Iterable<OffsetRange> ranges) {\n+    ImmutableSortedMap.Builder<OffsetRange, Integer> rval =\n+        ImmutableSortedMap.orderedBy(OffsetRangeComparator.INSTANCE);\n+    List<OffsetRange> sortedRanges = Lists.newArrayList(ranges);\n+    if (sortedRanges.isEmpty()) {\n+      return rval.build();\n+    }\n+    Collections.sort(sortedRanges, OffsetRangeComparator.INSTANCE);\n+\n+    // Stores ranges in smallest 'from' and then smallest 'to' order\n+    // e.g. [2, 7), [3, 4), [3, 5), [3, 5), [3, 6), [4, 0)\n+    PriorityQueue<OffsetRange> rangesWithSameFrom =\n+        new PriorityQueue<>(OffsetRangeComparator.INSTANCE);\n+    Iterator<OffsetRange> iterator = sortedRanges.iterator();\n+\n+    // Stored in reverse sorted order so that when we iterate and re-add them back to\n+    // overlappingRanges they are stored in sorted order from smallest to largest range.to\n+    List<OffsetRange> rangesToProcess = new ArrayList<>();\n+    while (iterator.hasNext()) {\n+      OffsetRange current = iterator.next();\n+      // Skip empty ranges\n+      if (current.getFrom() == current.getTo()) {\n+        continue;\n+      }\n+\n+      // If the current range has a different 'from' then a prior range then we must produce\n+      // ranges in [rangesWithSameFrom.from, current.from)\n+      while (!rangesWithSameFrom.isEmpty()\n+          && rangesWithSameFrom.peek().getFrom() != current.getFrom()) {\n+        rangesToProcess.addAll(rangesWithSameFrom);\n+        Collections.sort(rangesToProcess, OffsetRangeComparator.INSTANCE);\n+        rangesWithSameFrom.clear();\n+\n+        int i = 0;\n+        long lastTo = rangesToProcess.get(i).getFrom();\n+        // Output all the ranges that are strictly less then current.from\n+        // e.g. current.to := 7 for [3, 4), [3, 5), [3, 5), [3, 6) will produce\n+        // [3, 4) := 4\n+        // [4, 5) := 3\n+        // [5, 6) := 1\n+        for (; i < rangesToProcess.size(); ++i) {\n+          if (rangesToProcess.get(i).getTo() > current.getFrom()) {\n+            break;\n+          }\n+          // Output only the first of any subsequent duplicate ranges\n+          if (i == 0 || rangesToProcess.get(i - 1).getTo() != rangesToProcess.get(i).getTo()) {\n+            rval.put(\n+                new OffsetRange(lastTo, rangesToProcess.get(i).getTo()),\n+                rangesToProcess.size() - i);\n+            lastTo = rangesToProcess.get(i).getTo();\n+          }\n+        }\n+\n+        // We exitted the loop with 'to' > current.from, we must add the range [lastTo,\n+        // current.from) if it is non-empty\n+        if (lastTo < current.getFrom() && i != rangesToProcess.size()) {\n+          rval.put(new OffsetRange(lastTo, current.getFrom()), rangesToProcess.size() - i);\n+        }\n+\n+        // The remaining ranges have a 'to' that is greater then 'current.from' and will overlap\n+        // with current so add them back to rangesWithSameFrom with the updated 'from'\n+        for (; i < rangesToProcess.size(); ++i) {\n+          rangesWithSameFrom.add(\n+              new OffsetRange(current.getFrom(), rangesToProcess.get(i).getTo()));\n+        }\n+\n+        rangesToProcess.clear();\n+      }\n+      rangesWithSameFrom.add(current);\n+    }\n+\n+    // Process the last chunk of overlapping ranges\n+    while (!rangesWithSameFrom.isEmpty()) {\n+      // This range always represents the range with with the smallest 'to'\n+      OffsetRange current = rangesWithSameFrom.remove();\n+\n+      rangesToProcess.addAll(rangesWithSameFrom);\n+      Collections.sort(rangesToProcess, OffsetRangeComparator.INSTANCE);\n+      rangesWithSameFrom.clear();\n+\n+      rval.put(current, rangesToProcess.size() + 1 /* include current */);\n+\n+      // Shorten all the remaining ranges such that they start with current.to\n+      for (OffsetRange rangeWithDifferentFrom : rangesToProcess) {\n+        // Skip any duplicates of current\n+        if (rangeWithDifferentFrom.getTo() > current.getTo()) {\n+          rangesWithSameFrom.add(new OffsetRange(current.getTo(), rangeWithDifferentFrom.getTo()));\n+        }\n+      }\n+      rangesToProcess.clear();\n+    }\n+    return rval.build();\n+  }\n+\n+  @VisibleForTesting\n+  static int computeTotalNumElements(\n+      Map<OffsetRange, Integer> nonOverlappingRangesToNumElementsPerPosition) {\n+    long sum = 0;\n+    for (Map.Entry<OffsetRange, Integer> range :\n+        nonOverlappingRangesToNumElementsPerPosition.entrySet()) {\n+      sum +=\n+          Math.multiplyExact(\n+              Math.subtractExact(range.getKey().getTo(), range.getKey().getFrom()),\n+              range.getValue());\n+    }\n+    return Ints.checkedCast(sum);\n+  }\n+\n+  @VisibleForTesting\n+  static KV<Long, Integer> computePositionForIndex(\n+      Map<OffsetRange, Integer> nonOverlappingRangesToNumElementsPerPosition, int index) {\n+    if (index < 0) {\n+      throw new IndexOutOfBoundsException(\n+          String.format(\n+              \"Position %s was out of bounds for ranges %s.\",\n+              index, nonOverlappingRangesToNumElementsPerPosition));\n+    }\n+    for (Map.Entry<OffsetRange, Integer> range :\n+        nonOverlappingRangesToNumElementsPerPosition.entrySet()) {\n+      int numElementsInRange =\n+          Ints.checkedCast(\n+              Math.multiplyExact(\n+                  Math.subtractExact(range.getKey().getTo(), range.getKey().getFrom()),\n+                  range.getValue()));\n+      if (numElementsInRange <= index) {\n+        index -= numElementsInRange;\n+        continue;\n+      }\n+      long position = range.getKey().getFrom() + index / range.getValue();\n+      int subPosition = index % range.getValue();\n+      return KV.of(position, subPosition);\n+    }\n+    throw new IndexOutOfBoundsException(\n+        String.format(\n+            \"Position %s was out of bounds for ranges %s.\",\n+            index, nonOverlappingRangesToNumElementsPerPosition));\n+  }\n+\n+  /** Stores values or metadata about values. */\n+  public static class MetaOr<T, MetaT> {", "originalCommit": "6352f726feec43529c06659c48f0224815d07cbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyODQ3NQ==", "url": "https://github.com/apache/beam/pull/11821#discussion_r440428475", "bodyText": "Done", "author": "lukecwik", "createdAt": "2020-06-15T20:29:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3OTY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3OTg4Mw==", "url": "https://github.com/apache/beam/pull/11821#discussion_r439679883", "bodyText": "Where'd this number come from?", "author": "ibzib", "createdAt": "2020-06-12T23:34:14Z", "path": "sdks/java/core/src/test/java/org/apache/beam/sdk/values/PCollectionViewsTest.java", "diffHunk": "@@ -0,0 +1,269 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.values;\n+\n+import static org.apache.beam.sdk.values.PCollectionViews.computeOverlappingRanges;\n+import static org.apache.beam.sdk.values.PCollectionViews.computePositionForIndex;\n+import static org.apache.beam.sdk.values.PCollectionViews.computeTotalNumElements;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNotEquals;\n+import static org.junit.Assert.assertThrows;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Random;\n+import java.util.TreeSet;\n+import java.util.stream.IntStream;\n+import org.apache.beam.sdk.io.range.OffsetRange;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ArrayListMultimap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ListMultimap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+import org.junit.Test;\n+import org.junit.runner.RunWith;\n+import org.junit.runners.JUnit4;\n+\n+/** Tests for {@link PCollectionViews}. */\n+@RunWith(JUnit4.class)\n+public class PCollectionViewsTest {\n+  @Test\n+  public void testEmpty() {\n+    Iterable<OffsetRange> ranges = Collections.emptyList();\n+\n+    Map<OffsetRange, Integer> nonOverlappingRangesToNumElementsPerPosition =\n+        computeOverlappingRanges(ranges);\n+    assertEquals(nonOverlappingRangesToNumElementsPerPosition, Collections.emptyMap());\n+    assertEquals(0, computeTotalNumElements(nonOverlappingRangesToNumElementsPerPosition));\n+    assertThrows(\n+        IndexOutOfBoundsException.class,\n+        () -> computePositionForIndex(nonOverlappingRangesToNumElementsPerPosition, 0));\n+  }\n+\n+  @Test\n+  public void testNoOverlapping() {\n+    Iterable<OffsetRange> ranges = Arrays.asList(range(0, 2), range(4, 6));\n+\n+    Map<OffsetRange, Integer> nonOverlappingRangesToNumElementsPerPosition =\n+        computeOverlappingRanges(ranges);\n+    assertEquals(\n+        ImmutableMap.of(range(0, 2), 1, range(4, 6), 1),\n+        nonOverlappingRangesToNumElementsPerPosition);\n+    assertNonEmptyRangesAndPositions(ranges, nonOverlappingRangesToNumElementsPerPosition);\n+  }\n+\n+  @Test\n+  public void testOnlyTouchingRanges() {\n+    Iterable<OffsetRange> ranges = Arrays.asList(range(0, 4), range(4, 8), range(8, 12));\n+\n+    Map<OffsetRange, Integer> nonOverlappingRangesToNumElementsPerPosition =\n+        computeOverlappingRanges(ranges);\n+    assertEquals(\n+        ImmutableMap.of(range(0, 4), 1, range(4, 8), 1, range(8, 12), 1),\n+        nonOverlappingRangesToNumElementsPerPosition);\n+    assertNonEmptyRangesAndPositions(ranges, nonOverlappingRangesToNumElementsPerPosition);\n+  }\n+\n+  @Test\n+  public void testRangesWithAtMostOneOverlap() {\n+    Iterable<OffsetRange> ranges = Arrays.asList(range(0, 6), range(4, 10), range(8, 12));\n+\n+    Map<OffsetRange, Integer> nonOverlappingRangesToNumElementsPerPosition =\n+        computeOverlappingRanges(ranges);\n+    assertEquals(\n+        ImmutableMap.builder()\n+            .put(range(0, 4), 1)\n+            .put(range(4, 6), 2)\n+            .put(range(6, 8), 1)\n+            .put(range(8, 10), 2)\n+            .put(range(10, 12), 1)\n+            .build(),\n+        nonOverlappingRangesToNumElementsPerPosition);\n+    assertNonEmptyRangesAndPositions(ranges, nonOverlappingRangesToNumElementsPerPosition);\n+  }\n+\n+  @Test\n+  public void testOverlappingFroms() {\n+    Iterable<OffsetRange> ranges = Arrays.asList(range(0, 4), range(0, 8), range(0, 12));\n+\n+    Map<OffsetRange, Integer> nonOverlappingRangesToNumElementsPerPosition =\n+        computeOverlappingRanges(ranges);\n+    assertEquals(\n+        ImmutableMap.builder().put(range(0, 4), 3).put(range(4, 8), 2).put(range(8, 12), 1).build(),\n+        nonOverlappingRangesToNumElementsPerPosition);\n+    assertNonEmptyRangesAndPositions(ranges, nonOverlappingRangesToNumElementsPerPosition);\n+  }\n+\n+  @Test\n+  public void testOverlappingTos() {\n+    Iterable<OffsetRange> ranges = Arrays.asList(range(0, 12), range(4, 12), range(8, 12));\n+\n+    Map<OffsetRange, Integer> nonOverlappingRangesToNumElementsPerPosition =\n+        computeOverlappingRanges(ranges);\n+    assertEquals(\n+        ImmutableMap.builder().put(range(0, 4), 1).put(range(4, 8), 2).put(range(8, 12), 3).build(),\n+        nonOverlappingRangesToNumElementsPerPosition);\n+    assertNonEmptyRangesAndPositions(ranges, nonOverlappingRangesToNumElementsPerPosition);\n+  }\n+\n+  @Test\n+  public void testOverlappingFromsAndTos() {\n+    Iterable<OffsetRange> ranges = Arrays.asList(range(0, 4), range(0, 4), range(0, 4));\n+\n+    Map<OffsetRange, Integer> nonOverlappingRangesToNumElementsPerPosition =\n+        computeOverlappingRanges(ranges);\n+    assertEquals(\n+        ImmutableMap.builder().put(range(0, 4), 3).build(),\n+        nonOverlappingRangesToNumElementsPerPosition);\n+    assertNonEmptyRangesAndPositions(ranges, nonOverlappingRangesToNumElementsPerPosition);\n+  }\n+\n+  @Test\n+  public void testMultipleOverlapsForTheSameRange() {\n+    Iterable<OffsetRange> ranges =\n+        Arrays.asList(\n+            range(0, 4),\n+            range(0, 8),\n+            range(0, 12),\n+            range(0, 12),\n+            range(4, 12),\n+            range(8, 12),\n+            range(0, 4),\n+            range(0, 8),\n+            range(0, 12),\n+            range(0, 12),\n+            range(4, 12),\n+            range(8, 12));\n+\n+    Map<OffsetRange, Integer> nonOverlappingRangesToNumElementsPerPosition =\n+        computeOverlappingRanges(ranges);\n+    assertEquals(\n+        ImmutableMap.builder().put(range(0, 4), 8).put(range(4, 8), 8).put(range(8, 12), 8).build(),\n+        nonOverlappingRangesToNumElementsPerPosition);\n+    assertNonEmptyRangesAndPositions(ranges, nonOverlappingRangesToNumElementsPerPosition);\n+  }\n+\n+  @Test\n+  public void testIncreasingOverlaps() {\n+    Iterable<OffsetRange> ranges =\n+        Arrays.asList(range(0, 4), range(1, 5), range(2, 6), range(3, 7), range(4, 8), range(5, 9));\n+\n+    Map<OffsetRange, Integer> nonOverlappingRangesToNumElementsPerPosition =\n+        computeOverlappingRanges(ranges);\n+    assertEquals(\n+        ImmutableMap.builder()\n+            .put(range(0, 1), 1)\n+            .put(range(1, 2), 2)\n+            .put(range(2, 3), 3)\n+            .put(range(3, 4), 4)\n+            .put(range(4, 5), 4)\n+            .put(range(5, 6), 4)\n+            .put(range(6, 7), 3)\n+            .put(range(7, 8), 2)\n+            .put(range(8, 9), 1)\n+            .build(),\n+        nonOverlappingRangesToNumElementsPerPosition);\n+    assertNonEmptyRangesAndPositions(ranges, nonOverlappingRangesToNumElementsPerPosition);\n+  }\n+\n+  @Test\n+  public void testNestedOverlaps() {\n+    Iterable<OffsetRange> ranges =\n+        Arrays.asList(range(0, 8), range(1, 7), range(2, 6), range(3, 5));\n+\n+    Map<OffsetRange, Integer> nonOverlappingRangesToNumElementsPerPosition =\n+        computeOverlappingRanges(ranges);\n+    assertEquals(\n+        ImmutableMap.builder()\n+            .put(range(0, 1), 1)\n+            .put(range(1, 2), 2)\n+            .put(range(2, 3), 3)\n+            .put(range(3, 5), 4)\n+            .put(range(5, 6), 3)\n+            .put(range(6, 7), 2)\n+            .put(range(7, 8), 1)\n+            .build(),\n+        nonOverlappingRangesToNumElementsPerPosition);\n+    assertNonEmptyRangesAndPositions(ranges, nonOverlappingRangesToNumElementsPerPosition);\n+  }\n+\n+  @Test\n+  public void testRandomRanges() {\n+    Random random = new Random(123892154890L);", "originalCommit": "6352f726feec43529c06659c48f0224815d07cbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQyMzA5Mg==", "url": "https://github.com/apache/beam/pull/11821#discussion_r440423092", "bodyText": "Nowhere, just wanted a stable random number so that if it failed it was repeatable.", "author": "lukecwik", "createdAt": "2020-06-15T20:18:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3OTg4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQ1NTc2OA==", "url": "https://github.com/apache/beam/pull/11821#discussion_r440455768", "bodyText": "Makes sense. Can you add a comment?", "author": "ibzib", "createdAt": "2020-06-15T21:24:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY3OTg4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjU4Nw==", "url": "https://github.com/apache/beam/pull/11821#discussion_r439682587", "bodyText": "Is this used anywhere?", "author": "ibzib", "createdAt": "2020-06-12T23:50:48Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/View.java", "diffHunk": "@@ -496,6 +622,22 @@ public void processElement(@Element T element, OutputReceiver<KV<Void, T>> r) {\n     }\n   }\n \n+  /** An identity {@link PTransform}. */\n+  private static class IdentityTransform<T> extends PTransform<PCollection<T>, PCollection<T>> {", "originalCommit": "6352f726feec43529c06659c48f0224815d07cbf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzNjgwNg==", "url": "https://github.com/apache/beam/pull/11821#discussion_r440436806", "bodyText": "Not any more. It was used in a much earlier version.", "author": "lukecwik", "createdAt": "2020-06-15T20:46:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTY4MjU4Nw=="}], "type": "inlineReview"}, {"oid": "bd47e0f914842230d7aadfdfa17bd09c3de36587", "url": "https://github.com/apache/beam/commit/bd47e0f914842230d7aadfdfa17bd09c3de36587", "message": "[BEAM-10097, BEAM-5982, BEAM-3080] Use primitive views directly instead of transforming KV<Void, Iterable<T>> to the view type via a naive mapping.\n\nThis does not impact non-portable runners since the new expansion is guarded by the experiment \"beam_fn_api\".\nThis currently has little benefit for portable runners since they still treat all views as in memory iterables of values but opens the door for them to meaningfully provide optimized versions.\nThe singleton and iterable views can't be translated except if using the Dataflow runner v2 experiment since runner v1 doesn't support the iterable access pattern.", "committedDate": "2020-06-16T20:53:05Z", "type": "commit"}, {"oid": "ec8769f6163ca8a4daecc2fb29708bc1da430917", "url": "https://github.com/apache/beam/commit/ec8769f6163ca8a4daecc2fb29708bc1da430917", "message": "fixup! Fix test after rebase on master", "committedDate": "2020-06-16T21:25:34Z", "type": "commit"}, {"oid": "ec8769f6163ca8a4daecc2fb29708bc1da430917", "url": "https://github.com/apache/beam/commit/ec8769f6163ca8a4daecc2fb29708bc1da430917", "message": "fixup! Fix test after rebase on master", "committedDate": "2020-06-16T21:25:34Z", "type": "forcePushed"}]}