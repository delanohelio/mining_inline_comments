{"pr_number": 11929, "pr_title": "[BEAM-10201] Add deadletter support to JsonToRow", "pr_createdAt": "2020-06-05T04:35:01Z", "pr_url": "https://github.com/apache/beam/pull/11929", "timeline": [{"oid": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6", "url": "https://github.com/apache/beam/commit/09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6", "message": "[BEAM-10201] Add deadletter support to JsonToRow", "committedDate": "2020-06-05T04:31:15Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMzc4Nw==", "url": "https://github.com/apache/beam/pull/11929#discussion_r436213787", "bodyText": "you can add the schema for the outputs here, so that users do not need to add them themselves?", "author": "pabloem", "createdAt": "2020-06-06T00:17:49Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +157,65 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  static class JsonToRowWithFailureCaptureFn\n+      extends PTransform<PCollection<String>, PCollectionTuple> {\n+    private transient volatile @Nullable ObjectMapper objectMapper;\n+    private Schema schema;\n+    private static final String METRIC_NAMESPACE = \"JsonToRowFn\";\n+    private static final String DEAD_LETTER_METRIC_NAME = \"JsonToRowFn_ParseFailure\";\n+\n+    private Distribution jsonConversionErrors =\n+        Metrics.distribution(METRIC_NAMESPACE, DEAD_LETTER_METRIC_NAME);\n+\n+    public static final TupleTag<Row> main = MAIN_TUPLE_TAG;\n+    public static final TupleTag<Row> deadLetter = DEAD_LETTER_TUPLE_TAG;\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    static JsonToRowWithFailureCaptureFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new JsonToRowWithFailureCaptureFn(rowSchema);\n+    }\n+\n+    private JsonToRowWithFailureCaptureFn(Schema schema) {\n+      this.schema = schema;\n+    }\n+\n+    @Override\n+    public PCollectionTuple expand(PCollection<String> jsonStrings) {\n+\n+      return jsonStrings.apply(\n+          ParDo.of(\n+                  new DoFn<String, Row>() {\n+                    @ProcessElement\n+                    public void processElement(ProcessContext context) {\n+                      try {\n+                        context.output(jsonToRow(objectMapper(), context.element()));\n+                      } catch (Exception ex) {\n+                        context.output(\n+                            deadLetter,\n+                            Row.withSchema(ERROR_ROW_SCHEMA)\n+                                .addValue(context.element())\n+                                .addValue(ex.getMessage())\n+                                .build());\n+                      }\n+                    }\n+                  })\n+              .withOutputTags(main, TupleTagList.of(deadLetter)));", "originalCommit": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2MDU1MA==", "url": "https://github.com/apache/beam/pull/11929#discussion_r437760550", "bodyText": "Fixed.", "author": "rezarokni", "createdAt": "2020-06-09T22:37:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMzc4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMzg0Ng==", "url": "https://github.com/apache/beam/pull/11929#discussion_r436213846", "bodyText": "Maybe add the schema for the PCollections in expand so that users won't have to add them manually?", "author": "pabloem", "createdAt": "2020-06-06T00:18:09Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -72,10 +79,44 @@\n @Experimental(Kind.SCHEMAS)\n public class JsonToRow {\n \n+  private static final String LINE_FIELD_NAME = \"line\";\n+  private static final String ERROR_FIELD_NAME = \"err\";\n+\n+  public static final Schema ERROR_ROW_SCHEMA =\n+      Schema.of(\n+          Field.of(LINE_FIELD_NAME, FieldType.STRING),\n+          Field.of(ERROR_FIELD_NAME, FieldType.STRING));\n+\n+  public static final TupleTag<Row> MAIN_TUPLE_TAG = new TupleTag<Row>() {};\n+  public static final TupleTag<Row> DEAD_LETTER_TUPLE_TAG = new TupleTag<Row>() {};\n+\n   public static PTransform<PCollection<String>, PCollection<Row>> withSchema(Schema rowSchema) {\n     return JsonToRowFn.forSchema(rowSchema);\n   }\n \n+  /**\n+   * Enable Dead letter support. If this value is set errors in the parsing layer are returned as\n+   * Row objects of form: {@link JsonToRow#ERROR_ROW_SCHEMA} line : The original json string err :\n+   * The error message from the parsing function.\n+   *\n+   * <p>You can access the results by using:\n+   *\n+   * <p>{@link JsonToRow#MAIN_TUPLE_TAG}\n+   *\n+   * <p>{@Code PCollection<Row> personRows =\n+   * results.get(JsonToRow.MAIN_TUPLE_TAG).setRowSchema(personSchema)}", "originalCommit": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyMDczOQ==", "url": "https://github.com/apache/beam/pull/11929#discussion_r436220739", "bodyText": "+1. If you output.a Row, you should be setting the schema in your transform.", "author": "reuvenlax", "createdAt": "2020-06-06T00:49:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMzg0Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQxMTY0Ng==", "url": "https://github.com/apache/beam/pull/11929#discussion_r437411646", "bodyText": "Fixed.", "author": "rezarokni", "createdAt": "2020-06-09T13:21:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxMzg0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNDE1Nw==", "url": "https://github.com/apache/beam/pull/11929#discussion_r436214157", "bodyText": "I guess this doesn't make sense, but - would it help to include the Row Schema that we tried(and failed) to use for this JSON string? Some users may not needed, and others can add it themselves in the downstream ParDo - but it's possible it may help. Thoughts?", "author": "pabloem", "createdAt": "2020-06-06T00:20:26Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +157,65 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  static class JsonToRowWithFailureCaptureFn\n+      extends PTransform<PCollection<String>, PCollectionTuple> {\n+    private transient volatile @Nullable ObjectMapper objectMapper;\n+    private Schema schema;\n+    private static final String METRIC_NAMESPACE = \"JsonToRowFn\";\n+    private static final String DEAD_LETTER_METRIC_NAME = \"JsonToRowFn_ParseFailure\";\n+\n+    private Distribution jsonConversionErrors =\n+        Metrics.distribution(METRIC_NAMESPACE, DEAD_LETTER_METRIC_NAME);\n+\n+    public static final TupleTag<Row> main = MAIN_TUPLE_TAG;\n+    public static final TupleTag<Row> deadLetter = DEAD_LETTER_TUPLE_TAG;\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    static JsonToRowWithFailureCaptureFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new JsonToRowWithFailureCaptureFn(rowSchema);\n+    }\n+\n+    private JsonToRowWithFailureCaptureFn(Schema schema) {\n+      this.schema = schema;\n+    }\n+\n+    @Override\n+    public PCollectionTuple expand(PCollection<String> jsonStrings) {\n+\n+      return jsonStrings.apply(\n+          ParDo.of(\n+                  new DoFn<String, Row>() {\n+                    @ProcessElement\n+                    public void processElement(ProcessContext context) {\n+                      try {\n+                        context.output(jsonToRow(objectMapper(), context.element()));\n+                      } catch (Exception ex) {\n+                        context.output(\n+                            deadLetter,\n+                            Row.withSchema(ERROR_ROW_SCHEMA)\n+                                .addValue(context.element())\n+                                .addValue(ex.getMessage())\n+                                .build());", "originalCommit": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTE1NQ==", "url": "https://github.com/apache/beam/pull/11929#discussion_r436215155", "bodyText": "(I am mostly leaning towards not doing this, but lmk what you think)", "author": "pabloem", "createdAt": "2020-06-06T00:27:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNDE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQxMjI0OQ==", "url": "https://github.com/apache/beam/pull/11929#discussion_r437412249", "bodyText": "I think it would be nice to add it as SideInput, but I think for this first version maybe we stay with basic error message?", "author": "rezarokni", "createdAt": "2020-06-09T13:22:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNDE1Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQxMjQyOA==", "url": "https://github.com/apache/beam/pull/11929#discussion_r437412428", "bodyText": "I think it would be nice to add it as SideInput, but I think for this first version maybe we stay with basic error message?", "author": "rezarokni", "createdAt": "2020-06-09T13:22:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNDE1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTA2NA==", "url": "https://github.com/apache/beam/pull/11929#discussion_r436215064", "bodyText": "PCollectionTuple is not great (though it's what we have after all) - do you think it could make sense to return a custom, more elegant Result type? See this PR, where something like this was added for Map-type ptransforms: https://github.com/apache/beam/pull/7736/files#diff-895d512e486834dfd818eec82c75b2c3R122-R181", "author": "pabloem", "createdAt": "2020-06-06T00:27:16Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +157,65 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  static class JsonToRowWithFailureCaptureFn\n+      extends PTransform<PCollection<String>, PCollectionTuple> {\n+    private transient volatile @Nullable ObjectMapper objectMapper;\n+    private Schema schema;\n+    private static final String METRIC_NAMESPACE = \"JsonToRowFn\";\n+    private static final String DEAD_LETTER_METRIC_NAME = \"JsonToRowFn_ParseFailure\";\n+\n+    private Distribution jsonConversionErrors =\n+        Metrics.distribution(METRIC_NAMESPACE, DEAD_LETTER_METRIC_NAME);\n+\n+    public static final TupleTag<Row> main = MAIN_TUPLE_TAG;\n+    public static final TupleTag<Row> deadLetter = DEAD_LETTER_TUPLE_TAG;\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    static JsonToRowWithFailureCaptureFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new JsonToRowWithFailureCaptureFn(rowSchema);\n+    }\n+\n+    private JsonToRowWithFailureCaptureFn(Schema schema) {\n+      this.schema = schema;\n+    }\n+\n+    @Override\n+    public PCollectionTuple expand(PCollection<String> jsonStrings) {", "originalCommit": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQxMjY3MQ==", "url": "https://github.com/apache/beam/pull/11929#discussion_r437412671", "bodyText": "Created a ParseResult object.", "author": "rezarokni", "createdAt": "2020-06-09T13:23:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIxNTA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyMDY2MA==", "url": "https://github.com/apache/beam/pull/11929#discussion_r436220660", "bodyText": "would be nicer to make these field names configurable, though with defaults.", "author": "reuvenlax", "createdAt": "2020-06-06T00:48:40Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -72,10 +79,44 @@\n @Experimental(Kind.SCHEMAS)\n public class JsonToRow {\n \n+  private static final String LINE_FIELD_NAME = \"line\";\n+  private static final String ERROR_FIELD_NAME = \"err\";\n+\n+  public static final Schema ERROR_ROW_SCHEMA =\n+      Schema.of(\n+          Field.of(LINE_FIELD_NAME, FieldType.STRING),\n+          Field.of(ERROR_FIELD_NAME, FieldType.STRING));\n+", "originalCommit": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQxMjc3Nw==", "url": "https://github.com/apache/beam/pull/11929#discussion_r437412777", "bodyText": "Done.", "author": "rezarokni", "createdAt": "2020-06-09T13:23:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyMDY2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyMDY5NA==", "url": "https://github.com/apache/beam/pull/11929#discussion_r436220694", "bodyText": "give these tuple tags real names", "author": "reuvenlax", "createdAt": "2020-06-06T00:49:02Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -72,10 +79,44 @@\n @Experimental(Kind.SCHEMAS)\n public class JsonToRow {\n \n+  private static final String LINE_FIELD_NAME = \"line\";\n+  private static final String ERROR_FIELD_NAME = \"err\";\n+\n+  public static final Schema ERROR_ROW_SCHEMA =\n+      Schema.of(\n+          Field.of(LINE_FIELD_NAME, FieldType.STRING),\n+          Field.of(ERROR_FIELD_NAME, FieldType.STRING));\n+\n+  public static final TupleTag<Row> MAIN_TUPLE_TAG = new TupleTag<Row>() {};\n+  public static final TupleTag<Row> DEAD_LETTER_TUPLE_TAG = new TupleTag<Row>() {};\n+", "originalCommit": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ3MDkzOQ==", "url": "https://github.com/apache/beam/pull/11929#discussion_r438470939", "bodyText": "Done.", "author": "rezarokni", "createdAt": "2020-06-11T00:01:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyMDY5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyMDk3Ng==", "url": "https://github.com/apache/beam/pull/11929#discussion_r436220976", "bodyText": "I think it would be cleaner to wrap this in a custom result class and not expose the TupleTags to users. Look org.apache.beam.sdk.io.gcp.bigquery.WriteResult for an example.", "author": "reuvenlax", "createdAt": "2020-06-06T00:51:20Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +157,65 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  static class JsonToRowWithFailureCaptureFn\n+      extends PTransform<PCollection<String>, PCollectionTuple> {", "originalCommit": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQxMjk2Mg==", "url": "https://github.com/apache/beam/pull/11929#discussion_r437412962", "bodyText": "Done.", "author": "rezarokni", "createdAt": "2020-06-09T13:23:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyMDk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyMTAzMg==", "url": "https://github.com/apache/beam/pull/11929#discussion_r436221032", "bodyText": "make final", "author": "reuvenlax", "createdAt": "2020-06-06T00:51:50Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +157,65 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  static class JsonToRowWithFailureCaptureFn\n+      extends PTransform<PCollection<String>, PCollectionTuple> {\n+    private transient volatile @Nullable ObjectMapper objectMapper;\n+    private Schema schema;", "originalCommit": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyMTE4Nw==", "url": "https://github.com/apache/beam/pull/11929#discussion_r436221187", "bodyText": "Why not use injected parameters instead of ProcessContext?", "author": "reuvenlax", "createdAt": "2020-06-06T00:53:12Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +157,65 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  static class JsonToRowWithFailureCaptureFn\n+      extends PTransform<PCollection<String>, PCollectionTuple> {\n+    private transient volatile @Nullable ObjectMapper objectMapper;\n+    private Schema schema;\n+    private static final String METRIC_NAMESPACE = \"JsonToRowFn\";\n+    private static final String DEAD_LETTER_METRIC_NAME = \"JsonToRowFn_ParseFailure\";\n+\n+    private Distribution jsonConversionErrors =\n+        Metrics.distribution(METRIC_NAMESPACE, DEAD_LETTER_METRIC_NAME);\n+\n+    public static final TupleTag<Row> main = MAIN_TUPLE_TAG;\n+    public static final TupleTag<Row> deadLetter = DEAD_LETTER_TUPLE_TAG;\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    static JsonToRowWithFailureCaptureFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new JsonToRowWithFailureCaptureFn(rowSchema);\n+    }\n+\n+    private JsonToRowWithFailureCaptureFn(Schema schema) {\n+      this.schema = schema;\n+    }\n+\n+    @Override\n+    public PCollectionTuple expand(PCollection<String> jsonStrings) {\n+\n+      return jsonStrings.apply(\n+          ParDo.of(\n+                  new DoFn<String, Row>() {\n+                    @ProcessElement\n+                    public void processElement(ProcessContext context) {", "originalCommit": "09c6f9c0a2a6e619e2fe8c8aedc4e46fdcf8f8a6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgwNjk4MQ==", "url": "https://github.com/apache/beam/pull/11929#discussion_r437806981", "bodyText": "Done.", "author": "rezarokni", "createdAt": "2020-06-10T01:18:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIyMTE4Nw=="}], "type": "inlineReview"}, {"oid": "87278b3dfc6231d61f6c0e3e12d1e97c327ae31d", "url": "https://github.com/apache/beam/commit/87278b3dfc6231d61f6c0e3e12d1e97c327ae31d", "message": "Changed return type to ParseResult, no longer need to make use of Tupletag to access results.\nUse AutoValue object for configuration.\nConverted annon DoFn to class.", "committedDate": "2020-06-09T13:19:02Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ5NDQxMg==", "url": "https://github.com/apache/beam/pull/11929#discussion_r437494412", "bodyText": "I think we should name this something different, as not everyone knows the term dead letter.", "author": "reuvenlax", "createdAt": "2020-06-09T15:03:30Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +131,267 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  /**\n+   * Enable Dead letter support. If this value is set errors in the parsing layer are returned as\n+   * Row objects within a {@link ParseResult}\n+   *\n+   * <p>You can access the results by using:\n+   *\n+   * <p>ParseResult results = jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA));\n+   *\n+   * <p>{@link ParseResult#getResults()}\n+   *\n+   * <p>{@Code PCollection<Row> personRows = results.getResults()}\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLines()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLines = results.getFailedToParseLines()}\n+   *\n+   * <p>To access the reason for the failure you will need to first enable extended error reporting.\n+   * {@Code ParseResult results =\n+   * jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA).withExtendedErrorInfo()); }\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLinesWithErr()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLinesWithErrMsg = results.getFailedToParseLines()}\n+   *\n+   * @return {@link JsonToRowWithErrFn}\n+   */\n+  @Experimental(Kind.SCHEMAS)\n+  public static JsonToRowWithErrFn withDeadLetter(Schema rowSchema) {", "originalCommit": "87278b3dfc6231d61f6c0e3e12d1e97c327ae31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzgwNzA1Mw==", "url": "https://github.com/apache/beam/pull/11929#discussion_r437807053", "bodyText": "Changed to withExceptionReporting.", "author": "rezarokni", "createdAt": "2020-06-10T01:18:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzQ5NDQxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUwOTk2Ng==", "url": "https://github.com/apache/beam/pull/11929#discussion_r437509966", "bodyText": "Seems a bit roundabout. I would store these in the ParseResult object itself.", "author": "reuvenlax", "createdAt": "2020-06-09T15:17:42Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +131,267 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  /**\n+   * Enable Dead letter support. If this value is set errors in the parsing layer are returned as\n+   * Row objects within a {@link ParseResult}\n+   *\n+   * <p>You can access the results by using:\n+   *\n+   * <p>ParseResult results = jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA));\n+   *\n+   * <p>{@link ParseResult#getResults()}\n+   *\n+   * <p>{@Code PCollection<Row> personRows = results.getResults()}\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLines()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLines = results.getFailedToParseLines()}\n+   *\n+   * <p>To access the reason for the failure you will need to first enable extended error reporting.\n+   * {@Code ParseResult results =\n+   * jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA).withExtendedErrorInfo()); }\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLinesWithErr()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLinesWithErrMsg = results.getFailedToParseLines()}\n+   *\n+   * @return {@link JsonToRowWithErrFn}\n+   */\n+  @Experimental(Kind.SCHEMAS)\n+  public static JsonToRowWithErrFn withDeadLetter(Schema rowSchema) {\n+    return JsonToRowWithErrFn.forSchema(rowSchema);\n+  }\n+\n+  @AutoValue\n+  abstract static class JsonToRowWithErrFn extends PTransform<PCollection<String>, ParseResult> {\n+\n+    private Pipeline pipeline;\n+\n+    private PCollection<Row> parsedLine;\n+    private PCollection<Row> failedParse;\n+    private PCollection<Row> failedParseWithErr;\n+\n+    private static final String LINE_FIELD_NAME = \"line\";\n+    private static final String ERROR_FIELD_NAME = \"err\";\n+\n+    public static final Schema ERROR_ROW_SCHEMA =\n+        Schema.of(Field.of(LINE_FIELD_NAME, FieldType.STRING));\n+\n+    public static final Schema ERROR_ROW_WITH_ERR_MSG_SCHEMA =\n+        Schema.of(\n+            Field.of(LINE_FIELD_NAME, FieldType.STRING),\n+            Field.of(ERROR_FIELD_NAME, FieldType.STRING));\n+\n+    static final TupleTag<Row> PARSED_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE_WITH_MSG = new TupleTag<Row>() {};\n+\n+    public abstract Schema getSchema();\n+\n+    public abstract String getLineFieldName();\n+\n+    public abstract String getErrorFieldName();\n+\n+    public abstract boolean getExtendedErrorInfo();\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    public abstract Builder toBuilder();\n+\n+    @AutoValue.Builder\n+    public abstract static class Builder {\n+      public abstract Builder setSchema(Schema value);\n+\n+      public abstract Builder setLineFieldName(String value);\n+\n+      public abstract Builder setErrorFieldName(String value);\n+\n+      public abstract Builder setExtendedErrorInfo(boolean value);\n+\n+      public abstract JsonToRowWithErrFn build();\n+    }\n+\n+    public static JsonToRowWithErrFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new AutoValue_JsonToRow_JsonToRowWithErrFn.Builder()\n+          .setSchema(rowSchema)\n+          .setExtendedErrorInfo(false)\n+          .setLineFieldName(LINE_FIELD_NAME)\n+          .setErrorFieldName(ERROR_FIELD_NAME)\n+          .build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn withExtendedErrorInfo() {\n+      return this.toBuilder().setExtendedErrorInfo(true).build();\n+    }\n+\n+    /**\n+     * Sets the field name for the line field in the returned Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setLineField(String lineField) {\n+      return this.toBuilder().setLineFieldName(lineField).build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setErrorField(String errorField) {\n+      if (!this.getExtendedErrorInfo()) {\n+        throw new IllegalArgumentException(\n+            \"This option is only available with Extended Error Info.\");\n+      }\n+      return this.toBuilder().setErrorFieldName(errorField).build();\n+    }\n+\n+    @Override\n+    public ParseResult expand(PCollection<String> jsonStrings) {\n+\n+      PCollectionTuple result =\n+          jsonStrings.apply(\n+              ParDo.of(new ParseWithError(this.getSchema(), getExtendedErrorInfo()))\n+                  .withOutputTags(\n+                      PARSED_LINE,\n+                      TupleTagList.of(PARSE_ERROR_LINE).and(PARSE_ERROR_LINE_WITH_MSG)));\n+\n+      this.parsedLine = result.get(PARSED_LINE).setRowSchema(this.getSchema());", "originalCommit": "87278b3dfc6231d61f6c0e3e12d1e97c327ae31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODUwODAyMg==", "url": "https://github.com/apache/beam/pull/11929#discussion_r438508022", "bodyText": "Changed to be passed in via resultBuilder.", "author": "rezarokni", "createdAt": "2020-06-11T02:27:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUwOTk2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUxMDUxOQ==", "url": "https://github.com/apache/beam/pull/11929#discussion_r437510519", "bodyText": "why volatle?", "author": "reuvenlax", "createdAt": "2020-06-09T15:18:07Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +131,267 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  /**\n+   * Enable Dead letter support. If this value is set errors in the parsing layer are returned as\n+   * Row objects within a {@link ParseResult}\n+   *\n+   * <p>You can access the results by using:\n+   *\n+   * <p>ParseResult results = jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA));\n+   *\n+   * <p>{@link ParseResult#getResults()}\n+   *\n+   * <p>{@Code PCollection<Row> personRows = results.getResults()}\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLines()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLines = results.getFailedToParseLines()}\n+   *\n+   * <p>To access the reason for the failure you will need to first enable extended error reporting.\n+   * {@Code ParseResult results =\n+   * jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA).withExtendedErrorInfo()); }\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLinesWithErr()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLinesWithErrMsg = results.getFailedToParseLines()}\n+   *\n+   * @return {@link JsonToRowWithErrFn}\n+   */\n+  @Experimental(Kind.SCHEMAS)\n+  public static JsonToRowWithErrFn withDeadLetter(Schema rowSchema) {\n+    return JsonToRowWithErrFn.forSchema(rowSchema);\n+  }\n+\n+  @AutoValue\n+  abstract static class JsonToRowWithErrFn extends PTransform<PCollection<String>, ParseResult> {\n+\n+    private Pipeline pipeline;\n+\n+    private PCollection<Row> parsedLine;\n+    private PCollection<Row> failedParse;\n+    private PCollection<Row> failedParseWithErr;\n+\n+    private static final String LINE_FIELD_NAME = \"line\";\n+    private static final String ERROR_FIELD_NAME = \"err\";\n+\n+    public static final Schema ERROR_ROW_SCHEMA =\n+        Schema.of(Field.of(LINE_FIELD_NAME, FieldType.STRING));\n+\n+    public static final Schema ERROR_ROW_WITH_ERR_MSG_SCHEMA =\n+        Schema.of(\n+            Field.of(LINE_FIELD_NAME, FieldType.STRING),\n+            Field.of(ERROR_FIELD_NAME, FieldType.STRING));\n+\n+    static final TupleTag<Row> PARSED_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE_WITH_MSG = new TupleTag<Row>() {};\n+\n+    public abstract Schema getSchema();\n+\n+    public abstract String getLineFieldName();\n+\n+    public abstract String getErrorFieldName();\n+\n+    public abstract boolean getExtendedErrorInfo();\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    public abstract Builder toBuilder();\n+\n+    @AutoValue.Builder\n+    public abstract static class Builder {\n+      public abstract Builder setSchema(Schema value);\n+\n+      public abstract Builder setLineFieldName(String value);\n+\n+      public abstract Builder setErrorFieldName(String value);\n+\n+      public abstract Builder setExtendedErrorInfo(boolean value);\n+\n+      public abstract JsonToRowWithErrFn build();\n+    }\n+\n+    public static JsonToRowWithErrFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new AutoValue_JsonToRow_JsonToRowWithErrFn.Builder()\n+          .setSchema(rowSchema)\n+          .setExtendedErrorInfo(false)\n+          .setLineFieldName(LINE_FIELD_NAME)\n+          .setErrorFieldName(ERROR_FIELD_NAME)\n+          .build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn withExtendedErrorInfo() {\n+      return this.toBuilder().setExtendedErrorInfo(true).build();\n+    }\n+\n+    /**\n+     * Sets the field name for the line field in the returned Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setLineField(String lineField) {\n+      return this.toBuilder().setLineFieldName(lineField).build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setErrorField(String errorField) {\n+      if (!this.getExtendedErrorInfo()) {\n+        throw new IllegalArgumentException(\n+            \"This option is only available with Extended Error Info.\");\n+      }\n+      return this.toBuilder().setErrorFieldName(errorField).build();\n+    }\n+\n+    @Override\n+    public ParseResult expand(PCollection<String> jsonStrings) {\n+\n+      PCollectionTuple result =\n+          jsonStrings.apply(\n+              ParDo.of(new ParseWithError(this.getSchema(), getExtendedErrorInfo()))\n+                  .withOutputTags(\n+                      PARSED_LINE,\n+                      TupleTagList.of(PARSE_ERROR_LINE).and(PARSE_ERROR_LINE_WITH_MSG)));\n+\n+      this.parsedLine = result.get(PARSED_LINE).setRowSchema(this.getSchema());\n+      this.failedParse =\n+          result.get(PARSE_ERROR_LINE).setRowSchema(JsonToRowWithErrFn.ERROR_ROW_SCHEMA);\n+      this.failedParseWithErr =\n+          result\n+              .get(PARSE_ERROR_LINE_WITH_MSG)\n+              .setRowSchema(JsonToRowWithErrFn.ERROR_ROW_WITH_ERR_MSG_SCHEMA);\n+\n+      return ParseResult.result(this);\n+    }\n+\n+    private static class ParseWithError extends DoFn<String, Row> {\n+      private transient volatile @Nullable ObjectMapper objectMapper;", "originalCommit": "87278b3dfc6231d61f6c0e3e12d1e97c327ae31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2NDEwNQ==", "url": "https://github.com/apache/beam/pull/11929#discussion_r437764105", "bodyText": "This was used in the original JsonToRow , but I didnt see any notes as to why. Also this Object Mapper was at the Transform class level before and used in an anon DoFn.\nIn theory this is something that I would instantiate in @setup, but again we might want to make those changes in a separate PR which can also have some larger tests to make sure it works ok with multiple DoFn's are active?", "author": "rezarokni", "createdAt": "2020-06-09T22:48:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUxMDUxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUxMjAwNA==", "url": "https://github.com/apache/beam/pull/11929#discussion_r437512004", "bodyText": "Instead of separate output tags why not just add a nullable error-msg field to ERROR_ROW_SCHEMA that is not filled in if not asked for.", "author": "reuvenlax", "createdAt": "2020-06-09T15:19:14Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +131,267 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  /**\n+   * Enable Dead letter support. If this value is set errors in the parsing layer are returned as\n+   * Row objects within a {@link ParseResult}\n+   *\n+   * <p>You can access the results by using:\n+   *\n+   * <p>ParseResult results = jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA));\n+   *\n+   * <p>{@link ParseResult#getResults()}\n+   *\n+   * <p>{@Code PCollection<Row> personRows = results.getResults()}\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLines()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLines = results.getFailedToParseLines()}\n+   *\n+   * <p>To access the reason for the failure you will need to first enable extended error reporting.\n+   * {@Code ParseResult results =\n+   * jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA).withExtendedErrorInfo()); }\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLinesWithErr()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLinesWithErrMsg = results.getFailedToParseLines()}\n+   *\n+   * @return {@link JsonToRowWithErrFn}\n+   */\n+  @Experimental(Kind.SCHEMAS)\n+  public static JsonToRowWithErrFn withDeadLetter(Schema rowSchema) {\n+    return JsonToRowWithErrFn.forSchema(rowSchema);\n+  }\n+\n+  @AutoValue\n+  abstract static class JsonToRowWithErrFn extends PTransform<PCollection<String>, ParseResult> {\n+\n+    private Pipeline pipeline;\n+\n+    private PCollection<Row> parsedLine;\n+    private PCollection<Row> failedParse;\n+    private PCollection<Row> failedParseWithErr;\n+\n+    private static final String LINE_FIELD_NAME = \"line\";\n+    private static final String ERROR_FIELD_NAME = \"err\";\n+\n+    public static final Schema ERROR_ROW_SCHEMA =\n+        Schema.of(Field.of(LINE_FIELD_NAME, FieldType.STRING));\n+\n+    public static final Schema ERROR_ROW_WITH_ERR_MSG_SCHEMA =\n+        Schema.of(\n+            Field.of(LINE_FIELD_NAME, FieldType.STRING),\n+            Field.of(ERROR_FIELD_NAME, FieldType.STRING));\n+\n+    static final TupleTag<Row> PARSED_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE_WITH_MSG = new TupleTag<Row>() {};\n+\n+    public abstract Schema getSchema();\n+\n+    public abstract String getLineFieldName();\n+\n+    public abstract String getErrorFieldName();\n+\n+    public abstract boolean getExtendedErrorInfo();\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    public abstract Builder toBuilder();\n+\n+    @AutoValue.Builder\n+    public abstract static class Builder {\n+      public abstract Builder setSchema(Schema value);\n+\n+      public abstract Builder setLineFieldName(String value);\n+\n+      public abstract Builder setErrorFieldName(String value);\n+\n+      public abstract Builder setExtendedErrorInfo(boolean value);\n+\n+      public abstract JsonToRowWithErrFn build();\n+    }\n+\n+    public static JsonToRowWithErrFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new AutoValue_JsonToRow_JsonToRowWithErrFn.Builder()\n+          .setSchema(rowSchema)\n+          .setExtendedErrorInfo(false)\n+          .setLineFieldName(LINE_FIELD_NAME)\n+          .setErrorFieldName(ERROR_FIELD_NAME)\n+          .build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn withExtendedErrorInfo() {\n+      return this.toBuilder().setExtendedErrorInfo(true).build();\n+    }\n+\n+    /**\n+     * Sets the field name for the line field in the returned Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setLineField(String lineField) {\n+      return this.toBuilder().setLineFieldName(lineField).build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setErrorField(String errorField) {\n+      if (!this.getExtendedErrorInfo()) {\n+        throw new IllegalArgumentException(\n+            \"This option is only available with Extended Error Info.\");\n+      }\n+      return this.toBuilder().setErrorFieldName(errorField).build();\n+    }\n+\n+    @Override\n+    public ParseResult expand(PCollection<String> jsonStrings) {\n+\n+      PCollectionTuple result =\n+          jsonStrings.apply(\n+              ParDo.of(new ParseWithError(this.getSchema(), getExtendedErrorInfo()))\n+                  .withOutputTags(\n+                      PARSED_LINE,\n+                      TupleTagList.of(PARSE_ERROR_LINE).and(PARSE_ERROR_LINE_WITH_MSG)));\n+\n+      this.parsedLine = result.get(PARSED_LINE).setRowSchema(this.getSchema());\n+      this.failedParse =\n+          result.get(PARSE_ERROR_LINE).setRowSchema(JsonToRowWithErrFn.ERROR_ROW_SCHEMA);\n+      this.failedParseWithErr =\n+          result\n+              .get(PARSE_ERROR_LINE_WITH_MSG)\n+              .setRowSchema(JsonToRowWithErrFn.ERROR_ROW_WITH_ERR_MSG_SCHEMA);\n+\n+      return ParseResult.result(this);\n+    }\n+\n+    private static class ParseWithError extends DoFn<String, Row> {\n+      private transient volatile @Nullable ObjectMapper objectMapper;\n+      Schema schema;\n+      Boolean withExtendedErrorInfo;\n+\n+      ParseWithError(Schema schema, Boolean withExtendedErrorInfo) {\n+        this.schema = schema;\n+        this.withExtendedErrorInfo = withExtendedErrorInfo;\n+      }\n+\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        try {\n+\n+          context.output(jsonToRow(objectMapper(), context.element()));\n+\n+        } catch (Exception ex) {\n+\n+          if (withExtendedErrorInfo) {\n+            context.output(\n+                PARSE_ERROR_LINE_WITH_MSG,", "originalCommit": "87278b3dfc6231d61f6c0e3e12d1e97c327ae31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2MjE2NQ==", "url": "https://github.com/apache/beam/pull/11929#discussion_r437762165", "bodyText": "One advantage of being explicit is that the program will fail at pipeline creation time if the option is accidentally forgotten about.  Otherwise they could get a NPE.\nBut not sure if that protection is valuable enough, or if the simplification of the API is better?", "author": "rezarokni", "createdAt": "2020-06-09T22:42:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUxMjAwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUxMjY1OA==", "url": "https://github.com/apache/beam/pull/11929#discussion_r437512658", "bodyText": "BTW you know that there's a more-readable builder now, right?", "author": "reuvenlax", "createdAt": "2020-06-09T15:19:43Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +131,267 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  /**\n+   * Enable Dead letter support. If this value is set errors in the parsing layer are returned as\n+   * Row objects within a {@link ParseResult}\n+   *\n+   * <p>You can access the results by using:\n+   *\n+   * <p>ParseResult results = jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA));\n+   *\n+   * <p>{@link ParseResult#getResults()}\n+   *\n+   * <p>{@Code PCollection<Row> personRows = results.getResults()}\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLines()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLines = results.getFailedToParseLines()}\n+   *\n+   * <p>To access the reason for the failure you will need to first enable extended error reporting.\n+   * {@Code ParseResult results =\n+   * jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA).withExtendedErrorInfo()); }\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLinesWithErr()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLinesWithErrMsg = results.getFailedToParseLines()}\n+   *\n+   * @return {@link JsonToRowWithErrFn}\n+   */\n+  @Experimental(Kind.SCHEMAS)\n+  public static JsonToRowWithErrFn withDeadLetter(Schema rowSchema) {\n+    return JsonToRowWithErrFn.forSchema(rowSchema);\n+  }\n+\n+  @AutoValue\n+  abstract static class JsonToRowWithErrFn extends PTransform<PCollection<String>, ParseResult> {\n+\n+    private Pipeline pipeline;\n+\n+    private PCollection<Row> parsedLine;\n+    private PCollection<Row> failedParse;\n+    private PCollection<Row> failedParseWithErr;\n+\n+    private static final String LINE_FIELD_NAME = \"line\";\n+    private static final String ERROR_FIELD_NAME = \"err\";\n+\n+    public static final Schema ERROR_ROW_SCHEMA =\n+        Schema.of(Field.of(LINE_FIELD_NAME, FieldType.STRING));\n+\n+    public static final Schema ERROR_ROW_WITH_ERR_MSG_SCHEMA =\n+        Schema.of(\n+            Field.of(LINE_FIELD_NAME, FieldType.STRING),\n+            Field.of(ERROR_FIELD_NAME, FieldType.STRING));\n+\n+    static final TupleTag<Row> PARSED_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE_WITH_MSG = new TupleTag<Row>() {};\n+\n+    public abstract Schema getSchema();\n+\n+    public abstract String getLineFieldName();\n+\n+    public abstract String getErrorFieldName();\n+\n+    public abstract boolean getExtendedErrorInfo();\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    public abstract Builder toBuilder();\n+\n+    @AutoValue.Builder\n+    public abstract static class Builder {\n+      public abstract Builder setSchema(Schema value);\n+\n+      public abstract Builder setLineFieldName(String value);\n+\n+      public abstract Builder setErrorFieldName(String value);\n+\n+      public abstract Builder setExtendedErrorInfo(boolean value);\n+\n+      public abstract JsonToRowWithErrFn build();\n+    }\n+\n+    public static JsonToRowWithErrFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new AutoValue_JsonToRow_JsonToRowWithErrFn.Builder()\n+          .setSchema(rowSchema)\n+          .setExtendedErrorInfo(false)\n+          .setLineFieldName(LINE_FIELD_NAME)\n+          .setErrorFieldName(ERROR_FIELD_NAME)\n+          .build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn withExtendedErrorInfo() {\n+      return this.toBuilder().setExtendedErrorInfo(true).build();\n+    }\n+\n+    /**\n+     * Sets the field name for the line field in the returned Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setLineField(String lineField) {\n+      return this.toBuilder().setLineFieldName(lineField).build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setErrorField(String errorField) {\n+      if (!this.getExtendedErrorInfo()) {\n+        throw new IllegalArgumentException(\n+            \"This option is only available with Extended Error Info.\");\n+      }\n+      return this.toBuilder().setErrorFieldName(errorField).build();\n+    }\n+\n+    @Override\n+    public ParseResult expand(PCollection<String> jsonStrings) {\n+\n+      PCollectionTuple result =\n+          jsonStrings.apply(\n+              ParDo.of(new ParseWithError(this.getSchema(), getExtendedErrorInfo()))\n+                  .withOutputTags(\n+                      PARSED_LINE,\n+                      TupleTagList.of(PARSE_ERROR_LINE).and(PARSE_ERROR_LINE_WITH_MSG)));\n+\n+      this.parsedLine = result.get(PARSED_LINE).setRowSchema(this.getSchema());\n+      this.failedParse =\n+          result.get(PARSE_ERROR_LINE).setRowSchema(JsonToRowWithErrFn.ERROR_ROW_SCHEMA);\n+      this.failedParseWithErr =\n+          result\n+              .get(PARSE_ERROR_LINE_WITH_MSG)\n+              .setRowSchema(JsonToRowWithErrFn.ERROR_ROW_WITH_ERR_MSG_SCHEMA);\n+\n+      return ParseResult.result(this);\n+    }\n+\n+    private static class ParseWithError extends DoFn<String, Row> {\n+      private transient volatile @Nullable ObjectMapper objectMapper;\n+      Schema schema;\n+      Boolean withExtendedErrorInfo;\n+\n+      ParseWithError(Schema schema, Boolean withExtendedErrorInfo) {\n+        this.schema = schema;\n+        this.withExtendedErrorInfo = withExtendedErrorInfo;\n+      }\n+\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        try {\n+\n+          context.output(jsonToRow(objectMapper(), context.element()));\n+\n+        } catch (Exception ex) {\n+\n+          if (withExtendedErrorInfo) {\n+            context.output(\n+                PARSE_ERROR_LINE_WITH_MSG,\n+                Row.withSchema(ERROR_ROW_WITH_ERR_MSG_SCHEMA)\n+                    .addValue(context.element())\n+                    .addValue(ex.getMessage())\n+                    .build());", "originalCommit": "87278b3dfc6231d61f6c0e3e12d1e97c327ae31d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzc2MjY4Mw==", "url": "https://github.com/apache/beam/pull/11929#discussion_r437762683", "bodyText": "Not sure, do you mean using withFieldValue?", "author": "rezarokni", "createdAt": "2020-06-09T22:44:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUxMjY1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzUxMzQyNw==", "url": "https://github.com/apache/beam/pull/11929#discussion_r437513427", "bodyText": "see above - I don't think we need both here.", "author": "reuvenlax", "createdAt": "2020-06-09T15:20:16Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/transforms/JsonToRow.java", "diffHunk": "@@ -116,4 +131,267 @@ private ObjectMapper objectMapper() {\n       return this.objectMapper;\n     }\n   }\n+\n+  /**\n+   * Enable Dead letter support. If this value is set errors in the parsing layer are returned as\n+   * Row objects within a {@link ParseResult}\n+   *\n+   * <p>You can access the results by using:\n+   *\n+   * <p>ParseResult results = jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA));\n+   *\n+   * <p>{@link ParseResult#getResults()}\n+   *\n+   * <p>{@Code PCollection<Row> personRows = results.getResults()}\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLines()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLines = results.getFailedToParseLines()}\n+   *\n+   * <p>To access the reason for the failure you will need to first enable extended error reporting.\n+   * {@Code ParseResult results =\n+   * jsonPersons.apply(JsonToRow.withDeadLetter(PERSON_SCHEMA).withExtendedErrorInfo()); }\n+   *\n+   * <p>{@link ParseResult#getFailedToParseLinesWithErr()}\n+   *\n+   * <p>{@Code PCollection<Row> errorsLinesWithErrMsg = results.getFailedToParseLines()}\n+   *\n+   * @return {@link JsonToRowWithErrFn}\n+   */\n+  @Experimental(Kind.SCHEMAS)\n+  public static JsonToRowWithErrFn withDeadLetter(Schema rowSchema) {\n+    return JsonToRowWithErrFn.forSchema(rowSchema);\n+  }\n+\n+  @AutoValue\n+  abstract static class JsonToRowWithErrFn extends PTransform<PCollection<String>, ParseResult> {\n+\n+    private Pipeline pipeline;\n+\n+    private PCollection<Row> parsedLine;\n+    private PCollection<Row> failedParse;\n+    private PCollection<Row> failedParseWithErr;\n+\n+    private static final String LINE_FIELD_NAME = \"line\";\n+    private static final String ERROR_FIELD_NAME = \"err\";\n+\n+    public static final Schema ERROR_ROW_SCHEMA =\n+        Schema.of(Field.of(LINE_FIELD_NAME, FieldType.STRING));\n+\n+    public static final Schema ERROR_ROW_WITH_ERR_MSG_SCHEMA =\n+        Schema.of(\n+            Field.of(LINE_FIELD_NAME, FieldType.STRING),\n+            Field.of(ERROR_FIELD_NAME, FieldType.STRING));\n+\n+    static final TupleTag<Row> PARSED_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE = new TupleTag<Row>() {};\n+    static final TupleTag<Row> PARSE_ERROR_LINE_WITH_MSG = new TupleTag<Row>() {};\n+\n+    public abstract Schema getSchema();\n+\n+    public abstract String getLineFieldName();\n+\n+    public abstract String getErrorFieldName();\n+\n+    public abstract boolean getExtendedErrorInfo();\n+\n+    PCollection<Row> deadLetterCollection;\n+\n+    public abstract Builder toBuilder();\n+\n+    @AutoValue.Builder\n+    public abstract static class Builder {\n+      public abstract Builder setSchema(Schema value);\n+\n+      public abstract Builder setLineFieldName(String value);\n+\n+      public abstract Builder setErrorFieldName(String value);\n+\n+      public abstract Builder setExtendedErrorInfo(boolean value);\n+\n+      public abstract JsonToRowWithErrFn build();\n+    }\n+\n+    public static JsonToRowWithErrFn forSchema(Schema rowSchema) {\n+      // Throw exception if this schema is not supported by RowJson\n+      RowJson.verifySchemaSupported(rowSchema);\n+      return new AutoValue_JsonToRow_JsonToRowWithErrFn.Builder()\n+          .setSchema(rowSchema)\n+          .setExtendedErrorInfo(false)\n+          .setLineFieldName(LINE_FIELD_NAME)\n+          .setErrorFieldName(ERROR_FIELD_NAME)\n+          .build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn withExtendedErrorInfo() {\n+      return this.toBuilder().setExtendedErrorInfo(true).build();\n+    }\n+\n+    /**\n+     * Sets the field name for the line field in the returned Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setLineField(String lineField) {\n+      return this.toBuilder().setLineFieldName(lineField).build();\n+    }\n+\n+    /**\n+     * Adds the error message to the returned error Row.\n+     *\n+     * @return {@link JsonToRow}\n+     */\n+    public JsonToRowWithErrFn setErrorField(String errorField) {\n+      if (!this.getExtendedErrorInfo()) {\n+        throw new IllegalArgumentException(\n+            \"This option is only available with Extended Error Info.\");\n+      }\n+      return this.toBuilder().setErrorFieldName(errorField).build();\n+    }\n+\n+    @Override\n+    public ParseResult expand(PCollection<String> jsonStrings) {\n+\n+      PCollectionTuple result =\n+          jsonStrings.apply(\n+              ParDo.of(new ParseWithError(this.getSchema(), getExtendedErrorInfo()))\n+                  .withOutputTags(\n+                      PARSED_LINE,\n+                      TupleTagList.of(PARSE_ERROR_LINE).and(PARSE_ERROR_LINE_WITH_MSG)));\n+\n+      this.parsedLine = result.get(PARSED_LINE).setRowSchema(this.getSchema());\n+      this.failedParse =\n+          result.get(PARSE_ERROR_LINE).setRowSchema(JsonToRowWithErrFn.ERROR_ROW_SCHEMA);\n+      this.failedParseWithErr =\n+          result\n+              .get(PARSE_ERROR_LINE_WITH_MSG)\n+              .setRowSchema(JsonToRowWithErrFn.ERROR_ROW_WITH_ERR_MSG_SCHEMA);\n+\n+      return ParseResult.result(this);\n+    }\n+\n+    private static class ParseWithError extends DoFn<String, Row> {\n+      private transient volatile @Nullable ObjectMapper objectMapper;\n+      Schema schema;\n+      Boolean withExtendedErrorInfo;\n+\n+      ParseWithError(Schema schema, Boolean withExtendedErrorInfo) {\n+        this.schema = schema;\n+        this.withExtendedErrorInfo = withExtendedErrorInfo;\n+      }\n+\n+      @ProcessElement\n+      public void processElement(ProcessContext context) {\n+        try {\n+\n+          context.output(jsonToRow(objectMapper(), context.element()));\n+\n+        } catch (Exception ex) {\n+\n+          if (withExtendedErrorInfo) {\n+            context.output(\n+                PARSE_ERROR_LINE_WITH_MSG,\n+                Row.withSchema(ERROR_ROW_WITH_ERR_MSG_SCHEMA)\n+                    .addValue(context.element())\n+                    .addValue(ex.getMessage())\n+                    .build());\n+          } else {\n+            context.output(\n+                PARSE_ERROR_LINE,\n+                Row.withSchema(ERROR_ROW_SCHEMA).addValue(context.element()).build());\n+          }\n+        }\n+      }\n+\n+      private ObjectMapper objectMapper() {\n+        if (this.objectMapper == null) {\n+          synchronized (this) {\n+            if (this.objectMapper == null) {\n+              this.objectMapper = newObjectMapperWith(RowJsonDeserializer.forSchema(schema));\n+            }\n+          }\n+        }\n+\n+        return this.objectMapper;\n+      }\n+    }\n+  }\n+\n+  /** The result of a {@link JsonToRow#withDeadLetter(Schema)} transform. */\n+  public static final class ParseResult implements POutput {\n+    private final JsonToRowWithErrFn jsonToRowWithErrFn;\n+\n+    private ParseResult(JsonToRowWithErrFn jsonToRowWithErrFn) {\n+      this.jsonToRowWithErrFn = jsonToRowWithErrFn;\n+    }\n+\n+    public static ParseResult result(JsonToRowWithErrFn jsonToRowWithErrFn) {\n+      return new ParseResult(jsonToRowWithErrFn);\n+    }\n+\n+    @Override\n+    public Pipeline getPipeline() {\n+      return jsonToRowWithErrFn.pipeline;\n+    }\n+\n+    @Override\n+    public Map<TupleTag<?>, PValue> expand() {\n+      if (jsonToRowWithErrFn.getExtendedErrorInfo()) {\n+        return ImmutableMap.of(\n+            JsonToRowWithErrFn.PARSED_LINE,\n+            jsonToRowWithErrFn.parsedLine,\n+            JsonToRowWithErrFn.PARSE_ERROR_LINE_WITH_MSG,\n+            jsonToRowWithErrFn.failedParseWithErr);\n+      }\n+      return ImmutableMap.of(\n+          JsonToRowWithErrFn.PARSED_LINE,\n+          jsonToRowWithErrFn.parsedLine,\n+          JsonToRowWithErrFn.PARSE_ERROR_LINE,\n+          jsonToRowWithErrFn.failedParse);\n+    }\n+\n+    @Override\n+    public void finishSpecifyingOutput(\n+        String transformName, PInput input, PTransform<?, ?> transform) {}\n+\n+    /** Returns a {@link PCollection} containing the {@link Row}s that have been parsed. */\n+    public PCollection<Row> getResults() {\n+      return jsonToRowWithErrFn.parsedLine;\n+    }\n+\n+    /**\n+     * Returns a {@link PCollection} containing the {@link Row}s that didn't parse.\n+     *\n+     * <p>Only use this method if you haven't enabled {@link\n+     * JsonToRowWithErrFn#withExtendedErrorInfo()} . Otherwise use {@link\n+     * ParseResult##getFailedInsertsWithErr()}\n+     */\n+    public PCollection<Row> getFailedToParseLines() {\n+      checkArgument(\n+          !jsonToRowWithErrFn.getExtendedErrorInfo(),\n+          \"Cannot use getFailedToParseLines as this ParseResult uses extended errors\"\n+              + \" information. Use getFailedToParseLinesWithErr instead\");\n+      return jsonToRowWithErrFn.failedParse;\n+    }\n+\n+    /**\n+     * Returns a {@link PCollection} containing the a Row with detailed error information.\n+     *\n+     * <p>Only use this method if you have enabled {@link\n+     * JsonToRowWithErrFn#withExtendedErrorInfo()}. * Otherwise use {@link\n+     * ParseResult#getFailedToParseLines()}\n+     */\n+    public PCollection<Row> getFailedToParseLinesWithErr() {", "originalCommit": "87278b3dfc6231d61f6c0e3e12d1e97c327ae31d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f3485f5464e62bdc8130a6cba2a80376fed63508", "url": "https://github.com/apache/beam/commit/f3485f5464e62bdc8130a6cba2a80376fed63508", "message": "Change from ProcessContext to injected parameters.\nChange from deadletter name to withExceptionReporting.", "committedDate": "2020-06-10T01:16:13Z", "type": "commit"}, {"oid": "d50710b8a79a60cdee6c9d218f97d04c8fc50217", "url": "https://github.com/apache/beam/commit/d50710b8a79a60cdee6c9d218f97d04c8fc50217", "message": "Moved Error & Result PCollection references to be passed into ParseResult directly.\nChanged ParseResult and Parse DoFn to AutoValue.", "committedDate": "2020-06-11T02:22:46Z", "type": "commit"}, {"oid": "76fb2721b3854f2b57fd696799979df076abfee4", "url": "https://github.com/apache/beam/commit/76fb2721b3854f2b57fd696799979df076abfee4", "message": "Removed Error With MSG Tuple, using one Tuple to return both types.", "committedDate": "2020-06-12T01:53:04Z", "type": "commit"}, {"oid": "26ff97932a477428da4f529a27d4afc335f1fe0b", "url": "https://github.com/apache/beam/commit/26ff97932a477428da4f529a27d4afc335f1fe0b", "message": "Fix checkstyle in JsonToRowTest", "committedDate": "2020-06-13T03:32:35Z", "type": "commit"}, {"oid": "009190b5ea83c2406ca5c8d6e83e614a1386a5cb", "url": "https://github.com/apache/beam/commit/009190b5ea83c2406ca5c8d6e83e614a1386a5cb", "message": "Fix Bug with getPipeline in ParseResult", "committedDate": "2020-06-18T01:06:12Z", "type": "commit"}]}