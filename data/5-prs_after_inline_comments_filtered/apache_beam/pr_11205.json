{"pr_number": 11205, "pr_title": "[BEAM-9578] Enumerating artifacts is too expensive in Java", "pr_createdAt": "2020-03-24T09:36:37Z", "pr_url": "https://github.com/apache/beam/pull/11205", "timeline": [{"oid": "e62888a6aad537fecf47f1a9eb666adcf51d8aae", "url": "https://github.com/apache/beam/commit/e62888a6aad537fecf47f1a9eb666adcf51d8aae", "message": "deferred artifact and resolver sketch", "committedDate": "2020-04-01T10:05:16Z", "type": "forcePushed"}, {"oid": "ce2aa58c1bd13df476234b42365456242172e928", "url": "https://github.com/apache/beam/commit/ce2aa58c1bd13df476234b42365456242172e928", "message": "deferred artifact and resolver sketch", "committedDate": "2020-04-01T20:09:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ3NjUwMg==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402476502", "bodyText": "We won't need to rely on using Optional if we make registration take a URN and ResolutionFn and then the resolver can be found by URN.", "author": "lukecwik", "createdAt": "2020-04-02T17:14:47Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/ArtifactResolver.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.core.construction;\n+\n+import java.util.Optional;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+\n+public interface ArtifactResolver {\n+  void register(ResolutionFn fn);", "originalCommit": "3e9af32625859bdfdb5da4bf18b5f4f4bf1d26bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ5NDc2OA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402494768", "bodyText": "I agree. However, this might be more limited. E.g. one could have a more than one resolver per type, each of which can only resolve a subset, or alternatively one could want to resolve more than one type (or any type), e.g. a proxying resolver.", "author": "robertwb", "createdAt": "2020-04-02T17:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ3NjUwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ3NzM4OQ==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402477389", "bodyText": "Please add comments to this class and methods.", "author": "lukecwik", "createdAt": "2020-04-02T17:16:19Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/ArtifactResolver.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.core.construction;\n+\n+import java.util.Optional;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+\n+public interface ArtifactResolver {", "originalCommit": "3e9af32625859bdfdb5da4bf18b5f4f4bf1d26bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NDQwNQ==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402684405", "bodyText": "done.", "author": "ihji", "createdAt": "2020-04-03T01:18:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ3NzM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ3OTg0OA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402479848", "bodyText": "Class comment", "author": "lukecwik", "createdAt": "2020-04-02T17:20:03Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/DefaultArtifactResolver.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.core.construction;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+\n+public class DefaultArtifactResolver implements ArtifactResolver {", "originalCommit": "3e9af32625859bdfdb5da4bf18b5f4f4bf1d26bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NDQzMA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402684430", "bodyText": "done.", "author": "ihji", "createdAt": "2020-04-03T01:18:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ3OTg0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ4MjM2NQ==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402482365", "bodyText": "The level of nesting in this method is getting a little silly.\nUse local variables to logically describe what your doing and consider dropping using stream", "author": "lukecwik", "createdAt": "2020-04-02T17:23:40Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/DefaultArtifactResolver.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.core.construction;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+\n+public class DefaultArtifactResolver implements ArtifactResolver {\n+  public static ArtifactResolver INSTANCE = new DefaultArtifactResolver();\n+\n+  private ResolutionFn resolver =\n+      (info) -> {\n+        if (BeamUrns.getUrn(RunnerApi.StandardArtifacts.Types.FILE).equals(info.getTypeUrn())) {\n+          return Optional.of(info);\n+        } else {\n+          return Optional.empty();\n+        }\n+      };\n+\n+  @Override\n+  public void register(ResolutionFn fn) {\n+    resolver =\n+        (info) -> {\n+          Optional<RunnerApi.ArtifactInformation> resolved = fn.resolve(info);\n+          if (resolved.isPresent()) {\n+            return resolved;\n+          } else {\n+            return resolver.resolve(info);\n+          }\n+        };\n+  }\n+\n+  @Override\n+  public RunnerApi.Pipeline resolveArtifacts(RunnerApi.Pipeline pipeline) {", "originalCommit": "3e9af32625859bdfdb5da4bf18b5f4f4bf1d26bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NDQ4NA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402684484", "bodyText": "done \ud83d\ude04", "author": "ihji", "createdAt": "2020-04-03T01:18:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ4MjM2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ4MjkxOA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402482918", "bodyText": "Note that you could put one ID into the map for the entire list of files if you allowed ResolutionFn to return a List/Collection of artifacts.", "author": "lukecwik", "createdAt": "2020-04-02T17:24:27Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/Environments.java", "diffHunk": "@@ -215,22 +221,76 @@ public static Environment createProcessEnvironment(\n     }\n \n     ImmutableList.Builder<ArtifactInformation> filesToStage = ImmutableList.builder();\n+    ImmutableMap.Builder<String, Function<ArtifactInformation, ArtifactInformation>>\n+        lazyArtifactsBuilder = ImmutableMap.builder();\n     for (String path : pathsToStage) {\n       File file = new File(path);\n-      if (new File(path).exists()) {\n-        // Spurious items get added to the classpath. Filter by just those that exist.\n-        if (file.isDirectory()) {\n-          // Zip up directories so we can upload them to the artifact service.\n-          try {\n-            filesToStage.add(createArtifactInformation(zipDirectory(file)));\n-          } catch (IOException e) {\n-            throw new RuntimeException(e);\n-          }\n-        } else {\n-          filesToStage.add(createArtifactInformation(file));\n-        }\n+      // Spurious items get added to the classpath. Filter by just those that exist.\n+      if (file.exists()) {\n+        String id = UUID.randomUUID().toString();", "originalCommit": "3e9af32625859bdfdb5da4bf18b5f4f4bf1d26bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwMTg5OA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402501898", "bodyText": "Yes, I think the goal is to avoid even this enumeration until we actually need it.", "author": "robertwb", "createdAt": "2020-04-02T17:50:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ4MjkxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4NDU1MA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402684550", "bodyText": "done.", "author": "ihji", "createdAt": "2020-04-03T01:18:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ4MjkxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ5OTMzNQ==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402499335", "bodyText": "As with the resolution API, one may want to attempt to resolve multiple artifacts (e.g. maven dependencies) simultaneously. One may also need to return multiple artifacts as the resolution of a single artifact (e.g. the deferred \"ambient environment\" one).", "author": "robertwb", "createdAt": "2020-04-02T17:45:44Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/ArtifactResolver.java", "diffHunk": "@@ -0,0 +1,31 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.core.construction;\n+\n+import java.util.Optional;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+\n+public interface ArtifactResolver {\n+  void register(ResolutionFn fn);\n+\n+  RunnerApi.Pipeline resolveArtifacts(RunnerApi.Pipeline pipeline);\n+\n+  interface ResolutionFn {\n+    Optional<RunnerApi.ArtifactInformation> resolve(RunnerApi.ArtifactInformation info);", "originalCommit": "3e9af32625859bdfdb5da4bf18b5f4f4bf1d26bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY4ODA1MA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402688050", "bodyText": "changed to List.", "author": "ihji", "createdAt": "2020-04-03T01:31:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjQ5OTMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwMDY0OA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402500648", "bodyText": "I wonder if having an explicit List would be easier to understand than the implicit chaining in these abstract classes.", "author": "robertwb", "createdAt": "2020-04-02T17:47:58Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/DefaultArtifactResolver.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.core.construction;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+\n+public class DefaultArtifactResolver implements ArtifactResolver {\n+  public static ArtifactResolver INSTANCE = new DefaultArtifactResolver();\n+\n+  private ResolutionFn resolver =\n+      (info) -> {\n+        if (BeamUrns.getUrn(RunnerApi.StandardArtifacts.Types.FILE).equals(info.getTypeUrn())) {\n+          return Optional.of(info);\n+        } else {\n+          return Optional.empty();\n+        }\n+      };\n+\n+  @Override\n+  public void register(ResolutionFn fn) {\n+    resolver =", "originalCommit": "3e9af32625859bdfdb5da4bf18b5f4f4bf1d26bf", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzM5MDQyMg==", "url": "https://github.com/apache/beam/pull/11205#discussion_r403390422", "bodyText": "done.", "author": "ihji", "createdAt": "2020-04-04T00:03:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjUwMDY0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjY5OTM5OA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402699398", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                      String.format(\"cannot resolve artifact information: %s\", info));\n          \n          \n            \n                                      String.format(\"Cannot resolve artifact information: %s\", info));", "author": "lukecwik", "createdAt": "2020-04-03T02:18:12Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/DefaultArtifactResolver.java", "diffHunk": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.core.construction;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * A default artifact resolver. This resolver applies {@link ResolutionFn} first matched in the\n+ * order they registered.\n+ */\n+public class DefaultArtifactResolver implements ArtifactResolver {\n+  public static final ArtifactResolver INSTANCE = new DefaultArtifactResolver();\n+\n+  private ResolutionFn resolver =\n+      (info) -> {\n+        if (BeamUrns.getUrn(RunnerApi.StandardArtifacts.Types.FILE).equals(info.getTypeUrn())) {\n+          return ImmutableList.of(info);\n+        } else {\n+          return ImmutableList.of();\n+        }\n+      };\n+\n+  @Override\n+  public void register(ResolutionFn fn) {\n+    resolver =\n+        (info) -> {\n+          List<RunnerApi.ArtifactInformation> resolved = fn.resolve(info);\n+          if (!resolved.isEmpty()) {\n+            return resolved;\n+          } else {\n+            return resolver.resolve(info);\n+          }\n+        };\n+  }\n+\n+  @Override\n+  public RunnerApi.Pipeline resolveArtifacts(RunnerApi.Pipeline pipeline) {\n+    ImmutableMap.Builder<String, RunnerApi.Environment> environmentMapBuilder =\n+        ImmutableMap.builder();\n+    for (Map.Entry<String, RunnerApi.Environment> entry :\n+        pipeline.getComponents().getEnvironmentsMap().entrySet()) {\n+      List<RunnerApi.ArtifactInformation> resolvedDependencies =\n+          entry\n+              .getValue()\n+              .getDependenciesList()\n+              .parallelStream()\n+              .flatMap(\n+                  (info) -> {\n+                    List<RunnerApi.ArtifactInformation> resolved = resolver.resolve(info);\n+                    if (resolved.isEmpty()) {\n+                      throw new RuntimeException(\n+                          String.format(\"cannot resolve artifact information: %s\", info));", "originalCommit": "0a0422e8b1de81ab21b715533de34a9e2e19ab5a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMjcwMDYwMQ==", "url": "https://github.com/apache/beam/pull/11205#discussion_r402700601", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                String id = UUID.randomUUID().toString();\n          \n          \n            \n                DefaultArtifactResolver.INSTANCE.register(\n          \n          \n            \n                    (info) -> {\n          \n          \n            \n                      if (BeamUrns.getUrn(StandardArtifacts.Types.DEFERRED).equals(info.getTypeUrn())) {\n          \n          \n            \n                        RunnerApi.DeferredArtifactPayload deferredArtifactPayload;\n          \n          \n            \n                        try {\n          \n          \n            \n                          deferredArtifactPayload =\n          \n          \n            \n                              RunnerApi.DeferredArtifactPayload.parseFrom(info.getTypePayload());\n          \n          \n            \n                        } catch (InvalidProtocolBufferException e) {\n          \n          \n            \n                          throw new RuntimeException(\"Error parsing deferred artifact payload.\", e);\n          \n          \n            \n                        }\n          \n          \n            \n                        if (id.equals(deferredArtifactPayload.getKey())) {\n          \n          \n            \n                          return lazyArtifacts.stream().map(Supplier::get).collect(Collectors.toList());\n          \n          \n            \n                        } else {\n          \n          \n            \n                          return ImmutableList.of();\n          \n          \n            \n                        }\n          \n          \n            \n                      } else {\n          \n          \n            \n                        return ImmutableList.of();\n          \n          \n            \n                      }\n          \n          \n            \n                    });\n          \n          \n            \n            \n          \n          \n            \n                return ImmutableList.of(\n          \n          \n            \n                    ArtifactInformation.newBuilder()\n          \n          \n            \n                        .setTypeUrn(BeamUrns.getUrn(StandardArtifacts.Types.DEFERRED))\n          \n          \n            \n                        .setTypePayload(\n          \n          \n            \n                            RunnerApi.DeferredArtifactPayload.newBuilder().setKey(id).build().toByteString())\n          \n          \n            \n                String key = UUID.randomUUID().toString();\n          \n          \n            \n                DefaultArtifactResolver.INSTANCE.register(\n          \n          \n            \n                    (info) -> {\n          \n          \n            \n                      if (BeamUrns.getUrn(StandardArtifacts.Types.DEFERRED).equals(info.getTypeUrn())) {\n          \n          \n            \n                        RunnerApi.DeferredArtifactPayload deferredArtifactPayload;\n          \n          \n            \n                        try {\n          \n          \n            \n                          deferredArtifactPayload =\n          \n          \n            \n                              RunnerApi.DeferredArtifactPayload.parseFrom(info.getTypePayload());\n          \n          \n            \n                        } catch (InvalidProtocolBufferException e) {\n          \n          \n            \n                          throw new RuntimeException(\"Error parsing deferred artifact payload.\", e);\n          \n          \n            \n                        }\n          \n          \n            \n                        if (key.equals(deferredArtifactPayload.getKey())) {\n          \n          \n            \n                          return lazyArtifacts.stream().map(Supplier::get).collect(Collectors.toList());\n          \n          \n            \n                        } else {\n          \n          \n            \n                          return ImmutableList.of();\n          \n          \n            \n                        }\n          \n          \n            \n                      } else {\n          \n          \n            \n                        return ImmutableList.of();\n          \n          \n            \n                      }\n          \n          \n            \n                    });\n          \n          \n            \n            \n          \n          \n            \n                return ImmutableList.of(\n          \n          \n            \n                    ArtifactInformation.newBuilder()\n          \n          \n            \n                        .setTypeUrn(BeamUrns.getUrn(StandardArtifacts.Types.DEFERRED))\n          \n          \n            \n                        .setTypePayload(\n          \n          \n            \n                            RunnerApi.DeferredArtifactPayload.newBuilder().setKey(key).build().toByteString())", "author": "lukecwik", "createdAt": "2020-04-03T02:22:59Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/Environments.java", "diffHunk": "@@ -214,24 +220,87 @@ public static Environment createProcessEnvironment(\n       pathsToStage.addAll(stagingFiles);\n     }\n \n-    ImmutableList.Builder<ArtifactInformation> filesToStage = ImmutableList.builder();\n+    ImmutableList.Builder<Supplier<ArtifactInformation>> lazyArtifactsBuilder =\n+        ImmutableList.builder();\n     for (String path : pathsToStage) {\n       File file = new File(path);\n-      if (new File(path).exists()) {\n-        // Spurious items get added to the classpath. Filter by just those that exist.\n-        if (file.isDirectory()) {\n-          // Zip up directories so we can upload them to the artifact service.\n-          try {\n-            filesToStage.add(createArtifactInformation(zipDirectory(file)));\n-          } catch (IOException e) {\n-            throw new RuntimeException(e);\n-          }\n-        } else {\n-          filesToStage.add(createArtifactInformation(file));\n-        }\n+      // Spurious items get added to the classpath. Filter by just those that exist.\n+      if (file.exists()) {\n+        ArtifactInformation.Builder artifactBuilder = ArtifactInformation.newBuilder();\n+        artifactBuilder.setTypeUrn(BeamUrns.getUrn(StandardArtifacts.Types.FILE));\n+        artifactBuilder.setRoleUrn(BeamUrns.getUrn(StandardArtifacts.Roles.STAGING_TO));\n+        artifactBuilder.setRolePayload(\n+            RunnerApi.ArtifactStagingToRolePayload.newBuilder()\n+                .setStagedName(createStagingFileName(file))\n+                .build()\n+                .toByteString());\n+        lazyArtifactsBuilder.add(\n+            file.isDirectory()\n+                ? () -> {\n+                  File zippedFile;\n+                  HashCode hashCode;\n+                  try {\n+                    zippedFile = zipDirectory(file);\n+                    hashCode = Files.asByteSource(zippedFile).hash(Hashing.sha256());\n+                  } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                  }\n+                  return artifactBuilder\n+                      .setTypePayload(\n+                          RunnerApi.ArtifactFilePayload.newBuilder()\n+                              .setPath(zippedFile.getPath())\n+                              .setSha256(hashCode.toString())\n+                              .build()\n+                              .toByteString())\n+                      .build();\n+                }\n+                : () -> {\n+                  HashCode hashCode;\n+                  try {\n+                    hashCode = Files.asByteSource(file).hash(Hashing.sha256());\n+                  } catch (IOException e) {\n+                    throw new RuntimeException(e);\n+                  }\n+                  return artifactBuilder\n+                      .setTypePayload(\n+                          RunnerApi.ArtifactFilePayload.newBuilder()\n+                              .setPath(file.getPath())\n+                              .setSha256(hashCode.toString())\n+                              .build()\n+                              .toByteString())\n+                      .build();\n+                });\n       }\n     }\n-    return filesToStage.build();\n+\n+    List<Supplier<ArtifactInformation>> lazyArtifacts = lazyArtifactsBuilder.build();\n+    String id = UUID.randomUUID().toString();\n+    DefaultArtifactResolver.INSTANCE.register(\n+        (info) -> {\n+          if (BeamUrns.getUrn(StandardArtifacts.Types.DEFERRED).equals(info.getTypeUrn())) {\n+            RunnerApi.DeferredArtifactPayload deferredArtifactPayload;\n+            try {\n+              deferredArtifactPayload =\n+                  RunnerApi.DeferredArtifactPayload.parseFrom(info.getTypePayload());\n+            } catch (InvalidProtocolBufferException e) {\n+              throw new RuntimeException(\"Error parsing deferred artifact payload.\", e);\n+            }\n+            if (id.equals(deferredArtifactPayload.getKey())) {\n+              return lazyArtifacts.stream().map(Supplier::get).collect(Collectors.toList());\n+            } else {\n+              return ImmutableList.of();\n+            }\n+          } else {\n+            return ImmutableList.of();\n+          }\n+        });\n+\n+    return ImmutableList.of(\n+        ArtifactInformation.newBuilder()\n+            .setTypeUrn(BeamUrns.getUrn(StandardArtifacts.Types.DEFERRED))\n+            .setTypePayload(\n+                RunnerApi.DeferredArtifactPayload.newBuilder().setKey(id).build().toByteString())", "originalCommit": "0a0422e8b1de81ab21b715533de34a9e2e19ab5a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "5550d1f5c758565133c0d1b7c703e7550b8fc3c7", "url": "https://github.com/apache/beam/commit/5550d1f5c758565133c0d1b7c703e7550b8fc3c7", "message": "[BEAM-9578] Enumerating artifacts is too expensive in Java", "committedDate": "2020-04-03T23:52:41Z", "type": "commit"}, {"oid": "5550d1f5c758565133c0d1b7c703e7550b8fc3c7", "url": "https://github.com/apache/beam/commit/5550d1f5c758565133c0d1b7c703e7550b8fc3c7", "message": "[BEAM-9578] Enumerating artifacts is too expensive in Java", "committedDate": "2020-04-03T23:52:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwMzMzMg==", "url": "https://github.com/apache/beam/pull/11205#discussion_r403403332", "bodyText": "Is the empty list special? In particular sometimes a deferred artifact may resolve to nothing, which is different than not being able to be resolved... I think we still need optional or null or an exception to denote unresolveable by this resolver.", "author": "robertwb", "createdAt": "2020-04-04T01:14:38Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/DefaultArtifactResolver.java", "diffHunk": "@@ -0,0 +1,92 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.runners.core.construction;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.apache.beam.model.pipeline.v1.RunnerApi;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableList;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.Lists;\n+\n+/**\n+ * A default artifact resolver. This resolver applies {@link ResolutionFn} in the reversed order\n+ * they registered i.e. the function registered later overrides the earlier one if they resolve the\n+ * same artifact.\n+ */\n+public class DefaultArtifactResolver implements ArtifactResolver {\n+  public static final ArtifactResolver INSTANCE = new DefaultArtifactResolver();\n+\n+  private List<ResolutionFn> fns =\n+      Lists.newArrayList(\n+          (info) -> {\n+            if (BeamUrns.getUrn(RunnerApi.StandardArtifacts.Types.FILE).equals(info.getTypeUrn())) {\n+              return ImmutableList.of(info);\n+            } else {\n+              return ImmutableList.of();", "originalCommit": "5550d1f5c758565133c0d1b7c703e7550b8fc3c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMjYzNg==", "url": "https://github.com/apache/beam/pull/11205#discussion_r404412636", "bodyText": "Done. Optional list makes three choices: Failure, Success with empty output and Success with a list of artifacts.", "author": "ihji", "createdAt": "2020-04-06T21:55:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwMzMzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwNTI3OA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r403405278", "bodyText": "Don't we want this for loop to be lazy?\nRather than introducing intermediate streams of Suppliers, I think we could just rename the existing getArtifacts() something like getNonDeferredArtifacts() and then call it during resolution.\nif (key.equals(deferredArtifactPayload.getKey())) {\n      return getNonDeferredArtifacts(options);\n}", "author": "robertwb", "createdAt": "2020-04-04T01:30:40Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/Environments.java", "diffHunk": "@@ -214,24 +220,90 @@ public static Environment createProcessEnvironment(\n       pathsToStage.addAll(stagingFiles);\n     }\n \n-    ImmutableList.Builder<ArtifactInformation> filesToStage = ImmutableList.builder();\n+    ImmutableList.Builder<Supplier<ArtifactInformation>> lazyArtifactsBuilder =\n+        ImmutableList.builder();\n     for (String path : pathsToStage) {", "originalCommit": "5550d1f5c758565133c0d1b7c703e7550b8fc3c7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNDQxMTk1MQ==", "url": "https://github.com/apache/beam/pull/11205#discussion_r404411951", "bodyText": "This for loop is fairly cheap and from stream of Suppliers we can easily get additional performance benefits by creating parallelStream. When we consider parallelizing expensive computations, some boilerplate codes are needed anyway in getNonDeferredArtifacts(). I think building a stream is a nice way to abstract them out.", "author": "ihji", "createdAt": "2020-04-06T21:54:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwMzQwNTI3OA=="}], "type": "inlineReview"}, {"oid": "94a5a5fc3ce5dc6caf85412a9cf6e91ae90b4b0f", "url": "https://github.com/apache/beam/commit/94a5a5fc3ce5dc6caf85412a9cf6e91ae90b4b0f", "message": "allow explicit failure case", "committedDate": "2020-04-06T20:55:48Z", "type": "commit"}, {"oid": "8f419fbb34fd892094d1a98a24e251b2f0dfc477", "url": "https://github.com/apache/beam/commit/8f419fbb34fd892094d1a98a24e251b2f0dfc477", "message": "remove stream", "committedDate": "2020-04-07T00:36:10Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNjE2Mg==", "url": "https://github.com/apache/beam/pull/11205#discussion_r405136162", "bodyText": "Nit, there seems to be a fair amount of duplication between these two case.", "author": "robertwb", "createdAt": "2020-04-07T21:53:51Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/Environments.java", "diffHunk": "@@ -207,31 +210,94 @@ public static Environment createProcessEnvironment(\n     }\n   }\n \n-  public static Collection<ArtifactInformation> getArtifacts(PipelineOptions options) {\n-    Set<String> pathsToStage = Sets.newHashSet();\n-    List<String> stagingFiles = options.as(PortablePipelineOptions.class).getFilesToStage();\n-    if (stagingFiles != null) {\n-      pathsToStage.addAll(stagingFiles);\n-    }\n-\n-    ImmutableList.Builder<ArtifactInformation> filesToStage = ImmutableList.builder();\n+  private static List<ArtifactInformation> getArtifacts(List<String> stagingFiles) {\n+    Set<String> pathsToStage = Sets.newHashSet(stagingFiles);\n+    ImmutableList.Builder<ArtifactInformation> artifactsBuilder = ImmutableList.builder();\n     for (String path : pathsToStage) {\n       File file = new File(path);\n-      if (new File(path).exists()) {\n-        // Spurious items get added to the classpath. Filter by just those that exist.\n+      // Spurious items get added to the classpath. Filter by just those that exist.\n+      if (file.exists()) {\n+        ArtifactInformation.Builder artifactBuilder = ArtifactInformation.newBuilder();\n+        artifactBuilder.setTypeUrn(BeamUrns.getUrn(StandardArtifacts.Types.FILE));\n+        artifactBuilder.setRoleUrn(BeamUrns.getUrn(StandardArtifacts.Roles.STAGING_TO));\n+        artifactBuilder.setRolePayload(\n+            RunnerApi.ArtifactStagingToRolePayload.newBuilder()\n+                .setStagedName(createStagingFileName(file))\n+                .build()\n+                .toByteString());\n         if (file.isDirectory()) {\n-          // Zip up directories so we can upload them to the artifact service.\n+          File zippedFile;", "originalCommit": "8f419fbb34fd892094d1a98a24e251b2f0dfc477", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTEzNjQxOA==", "url": "https://github.com/apache/beam/pull/11205#discussion_r405136418", "bodyText": "Or would it be better to let the method throw an IOException?", "author": "robertwb", "createdAt": "2020-04-07T21:54:24Z", "path": "runners/core-construction-java/src/main/java/org/apache/beam/runners/core/construction/Environments.java", "diffHunk": "@@ -207,31 +210,94 @@ public static Environment createProcessEnvironment(\n     }\n   }\n \n-  public static Collection<ArtifactInformation> getArtifacts(PipelineOptions options) {\n-    Set<String> pathsToStage = Sets.newHashSet();\n-    List<String> stagingFiles = options.as(PortablePipelineOptions.class).getFilesToStage();\n-    if (stagingFiles != null) {\n-      pathsToStage.addAll(stagingFiles);\n-    }\n-\n-    ImmutableList.Builder<ArtifactInformation> filesToStage = ImmutableList.builder();\n+  private static List<ArtifactInformation> getArtifacts(List<String> stagingFiles) {\n+    Set<String> pathsToStage = Sets.newHashSet(stagingFiles);\n+    ImmutableList.Builder<ArtifactInformation> artifactsBuilder = ImmutableList.builder();\n     for (String path : pathsToStage) {\n       File file = new File(path);\n-      if (new File(path).exists()) {\n-        // Spurious items get added to the classpath. Filter by just those that exist.\n+      // Spurious items get added to the classpath. Filter by just those that exist.\n+      if (file.exists()) {\n+        ArtifactInformation.Builder artifactBuilder = ArtifactInformation.newBuilder();\n+        artifactBuilder.setTypeUrn(BeamUrns.getUrn(StandardArtifacts.Types.FILE));\n+        artifactBuilder.setRoleUrn(BeamUrns.getUrn(StandardArtifacts.Roles.STAGING_TO));\n+        artifactBuilder.setRolePayload(\n+            RunnerApi.ArtifactStagingToRolePayload.newBuilder()\n+                .setStagedName(createStagingFileName(file))\n+                .build()\n+                .toByteString());\n         if (file.isDirectory()) {\n-          // Zip up directories so we can upload them to the artifact service.\n+          File zippedFile;\n+          HashCode hashCode;\n           try {\n-            filesToStage.add(createArtifactInformation(zipDirectory(file)));\n+            zippedFile = zipDirectory(file);\n+            hashCode = Files.asByteSource(zippedFile).hash(Hashing.sha256());\n           } catch (IOException e) {\n             throw new RuntimeException(e);\n           }\n+          artifactsBuilder.add(\n+              artifactBuilder\n+                  .setTypePayload(\n+                      RunnerApi.ArtifactFilePayload.newBuilder()\n+                          .setPath(zippedFile.getPath())\n+                          .setSha256(hashCode.toString())\n+                          .build()\n+                          .toByteString())\n+                  .build());\n         } else {\n-          filesToStage.add(createArtifactInformation(file));\n+          HashCode hashCode;\n+          try {\n+            hashCode = Files.asByteSource(file).hash(Hashing.sha256());\n+          } catch (IOException e) {\n+            throw new RuntimeException(e);", "originalCommit": "8f419fbb34fd892094d1a98a24e251b2f0dfc477", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}