{"pr_number": 10634, "pr_title": "[BEAM-9178] Support all ZetaSQL TIMESTAMP functions", "pr_createdAt": "2020-01-17T23:40:36Z", "pr_url": "https://github.com/apache/beam/pull/10634", "timeline": [{"oid": "37b9890d40266eba7d5fb3ad20791a9c4b071fc2", "url": "https://github.com/apache/beam/commit/37b9890d40266eba7d5fb3ad20791a9c4b071fc2", "message": "Support all ZetaSQL TIMESTAMP functions", "committedDate": "2020-01-28T00:34:23Z", "type": "forcePushed"}, {"oid": "5f3c2923de0bbaaf4c48a9f6a009d39c17bd3d37", "url": "https://github.com/apache/beam/commit/5f3c2923de0bbaaf4c48a9f6a009d39c17bd3d37", "message": "Support all ZetaSQL TIMESTAMP functions", "committedDate": "2020-01-28T00:41:58Z", "type": "forcePushed"}, {"oid": "c6b36a0414c9489832f0f87cc4da20413341ea09", "url": "https://github.com/apache/beam/commit/c6b36a0414c9489832f0f87cc4da20413341ea09", "message": "Support all ZetaSQL TIMESTAMP functions", "committedDate": "2020-01-28T00:44:57Z", "type": "forcePushed"}, {"oid": "d8300dea9d9c6c22614791433365897b54db9b8a", "url": "https://github.com/apache/beam/commit/d8300dea9d9c6c22614791433365897b54db9b8a", "message": "Support all ZetaSQL TIMESTAMP functions", "committedDate": "2020-01-28T21:43:37Z", "type": "forcePushed"}, {"oid": "43524190dc6e6d7101351902e98c8fd3402d743f", "url": "https://github.com/apache/beam/commit/43524190dc6e6d7101351902e98c8fd3402d743f", "message": "Support all ZetaSQL TIMESTAMP functions", "committedDate": "2020-02-03T19:00:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQwODU0Mw==", "url": "https://github.com/apache/beam/pull/10634#discussion_r374408543", "bodyText": "s/parse/unparse/", "author": "apilloud", "createdAt": "2020-02-03T23:56:50Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/bigquery/BeamBigQuerySqlDialect.java", "diffHunk": "@@ -302,6 +316,38 @@ private void unparseTrim(SqlWriter writer, SqlCall call, int leftPrec, int right\n     writer.endFunCall(trimFrame);\n   }\n \n+  /**\n+   * For usage of INTERVAL, see <a\n+   * href=\"https://cloud.google.com/bigquery/docs/reference/standard-sql/functions-and-operators#timestamp_add\">\n+   * BQ TIMESTAMP_ADD function</a> for example.\n+   */\n+  private void unparseFunctionsUsingInterval(\n+      SqlWriter writer, SqlCall call, int leftPrec, int rightPrec) {\n+    // e.g. TIMESTAMP_ADD syntax:\n+    // TIMESTAMP_ADD(timestamp_expression, INTERVAL int64_expression date_part)\n+    int operandCount = call.operandCount();\n+    if (operandCount == 2) {\n+      // operand0: timestamp_expression\n+      // operand1: SqlIntervalLiteral (INTERVAL int64_expression date_part)\n+      super.unparseCall(writer, call, leftPrec, rightPrec);\n+    } else if (operandCount == 3) {\n+      // operand0: timestamp_expression\n+      // operand1: int64_expression\n+      // operand2: date_part\n+      final SqlWriter.Frame frame = writer.startFunCall(call.getOperator().getName());\n+      call.operand(0).unparse(writer, leftPrec, rightPrec);\n+      writer.literal(\",\");\n+      writer.literal(\"INTERVAL\");\n+      call.operand(1).unparse(writer, leftPrec, rightPrec);\n+      call.operand(2).unparse(writer, leftPrec, rightPrec);\n+      writer.endFunCall(frame);\n+    } else {\n+      throw new IllegalArgumentException(\n+          String.format(\n+              \"Unable to parse %s with %d operands.\", call.getOperator().getName(), operandCount));", "originalCommit": "3f3d7631d167ab72efed83193422fdca84677101", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg0MjM2MA==", "url": "https://github.com/apache/beam/pull/10634#discussion_r374842360", "bodyText": "Fixed.", "author": "robinyqiu", "createdAt": "2020-02-04T18:23:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQwODU0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQwOTAzMA==", "url": "https://github.com/apache/beam/pull/10634#discussion_r374409030", "bodyText": "\ud83d\udc4d Thanks. This actually adds quite a bit of complexity elsewhere.", "author": "apilloud", "createdAt": "2020-02-03T23:58:39Z", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -52,7 +51,6 @@\n import com.google.zetasql.resolvedast.ResolvedNodes.ResolvedOrderByScan;\n import com.google.zetasql.resolvedast.ResolvedNodes.ResolvedParameter;\n import com.google.zetasql.resolvedast.ResolvedNodes.ResolvedProjectScan;\n-import io.grpc.Status;", "originalCommit": "3f3d7631d167ab72efed83193422fdca84677101", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQxMDAzMw==", "url": "https://github.com/apache/beam/pull/10634#discussion_r374410033", "bodyText": "Manually maintaining this list seems like no fun. What about using functionCall.getSignature().getResultType().getType()?", "author": "apilloud", "createdAt": "2020-02-04T00:02:14Z", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -770,88 +765,34 @@ private RexNode convertResolvedFunctionCall(\n           throw new UnsupportedOperationException(\n               \"Only support TUMBLE, HOP AND SESSION functions right now.\");\n       }\n-    } else if (functionCall.getFunction().getGroup().equals(\"ZetaSQL\")) {\n-      op =\n-          SqlStdOperatorMappingTable.ZETASQL_FUNCTION_TO_CALCITE_SQL_OPERATOR.get(\n-              functionCall.getFunction().getName());\n-\n+    } else if (\"ZetaSQL\".equals(funGroup)) {\n       if (op == null) {\n-        throw new UnsupportedOperationException(\n-            \"Does not support ZetaSQL function: \" + functionCall.getFunction().getName());\n+        TypeKind returnType =\n+            SqlStdOperatorMappingTable.ZETASQL_FUNCTION_NAME_TO_RETURN_TYPE.get(funName);", "originalCommit": "3f3d7631d167ab72efed83193422fdca84677101", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg0MjkwMA==", "url": "https://github.com/apache/beam/pull/10634#discussion_r374842900", "bodyText": "Great suggestion! Removing the manual map simplifies the code quite a lot.", "author": "robinyqiu", "createdAt": "2020-02-04T18:24:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQxMDAzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQxMjAyNQ==", "url": "https://github.com/apache/beam/pull/10634#discussion_r374412025", "bodyText": "This 'works' now but it is still not supported in our type system, so it might work inconsistently. (Microseconds will be dropped once we are out of ZetaSQLCalc.) Should we be making sure ZetaSQLCalc has the correct hooks to error if the user interacts with microsecond precision values?\ncc: @kennknowles", "author": "apilloud", "createdAt": "2020-02-04T00:09:21Z", "path": "sdks/java/extensions/sql/zetasql/src/main/java/org/apache/beam/sdk/extensions/sql/zetasql/translation/ExpressionConverter.java", "diffHunk": "@@ -770,88 +765,34 @@ private RexNode convertResolvedFunctionCall(\n           throw new UnsupportedOperationException(\n               \"Only support TUMBLE, HOP AND SESSION functions right now.\");\n       }\n-    } else if (functionCall.getFunction().getGroup().equals(\"ZetaSQL\")) {\n-      op =\n-          SqlStdOperatorMappingTable.ZETASQL_FUNCTION_TO_CALCITE_SQL_OPERATOR.get(\n-              functionCall.getFunction().getName());\n-\n+    } else if (\"ZetaSQL\".equals(funGroup)) {\n       if (op == null) {\n-        throw new UnsupportedOperationException(\n-            \"Does not support ZetaSQL function: \" + functionCall.getFunction().getName());\n+        TypeKind returnType =\n+            SqlStdOperatorMappingTable.ZETASQL_FUNCTION_NAME_TO_RETURN_TYPE.get(funName);\n+        if (returnType != null) {\n+          op =\n+              SqlOperators.createSimpleSqlFunction(\n+                  funName, ZetaSqlUtils.zetaSqlTypeToCalciteType(returnType));\n+        } else {\n+          throw new UnsupportedOperationException(\"Does not support ZetaSQL function: \" + funName);\n+        }\n       }\n \n-      // There are different processes to handle argument conversion because INTERVAL is not a\n-      // type in ZetaSQL.\n-      if (FUNCTION_FAMILY_DATE_ADD.contains(functionCall.getFunction().getName())) {\n-        return convertTimestampAddFunction(functionCall, columnList, fieldList);\n-      } else {\n-        for (ResolvedExpr expr : functionCall.getArgumentList()) {\n-          operands.add(convertRexNodeFromResolvedExpr(expr, columnList, fieldList));\n-        }\n+      for (ResolvedExpr expr : functionCall.getArgumentList()) {\n+        operands.add(convertRexNodeFromResolvedExpr(expr, columnList, fieldList));\n       }\n     } else {\n-      throw new UnsupportedOperationException(\n-          \"Does not support function group: \" + functionCall.getFunction().getGroup());\n+      throw new UnsupportedOperationException(\"Does not support function group: \" + funGroup);\n     }\n \n     SqlOperatorRewriter rewriter =\n-        SqlStdOperatorMappingTable.ZETASQL_FUNCTION_TO_CALCITE_SQL_OPERATOR_REWRITER.get(\n-            functionCall.getFunction().getName());\n+        SqlStdOperatorMappingTable.ZETASQL_FUNCTION_TO_CALCITE_SQL_OPERATOR_REWRITER.get(funName);\n \n     if (rewriter != null) {\n-      ret = rewriter.apply(rexBuilder(), operands);\n+      return rewriter.apply(rexBuilder(), operands);\n     } else {\n-      ret = rexBuilder().makeCall(op, operands);\n-    }\n-    return ret;\n-  }\n-\n-  private RexNode convertTimestampAddFunction(\n-      ResolvedFunctionCall functionCall,\n-      List<ResolvedColumn> columnList,\n-      List<RelDataTypeField> fieldList) {\n-\n-    TimeUnit unit =\n-        TIME_UNIT_CASTING_MAP.get(\n-            ((ResolvedLiteral) functionCall.getArgumentList().get(2)).getValue().getEnumValue());\n-\n-    if ((unit == TimeUnit.MICROSECOND) || (unit == TimeUnit.NANOSECOND)) {", "originalCommit": "3f3d7631d167ab72efed83193422fdca84677101", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDg0NjE1MA==", "url": "https://github.com/apache/beam/pull/10634#discussion_r374846150", "bodyText": "Yeah right now it might work inconsistently. We can throw an exception during timestamp value conversion (here) if we see microsecond precision used, but I am not sure if we should do that. One  down side of that is we might break functions unnecessarily (e.g. CURRENT_TIMESTAMP). Or maybe we can leave it as it is and see if we can fully fix the precision problem? WDYT?", "author": "robinyqiu", "createdAt": "2020-02-04T18:30:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDQxMjAyNQ=="}], "type": "inlineReview"}, {"oid": "acb046004dc3a828ee5fbb896741084d5690720d", "url": "https://github.com/apache/beam/commit/acb046004dc3a828ee5fbb896741084d5690720d", "message": "Support all ZetaSQL TIMESTAMP functions", "committedDate": "2020-02-04T18:08:33Z", "type": "commit"}, {"oid": "acb046004dc3a828ee5fbb896741084d5690720d", "url": "https://github.com/apache/beam/commit/acb046004dc3a828ee5fbb896741084d5690720d", "message": "Support all ZetaSQL TIMESTAMP functions", "committedDate": "2020-02-04T18:08:33Z", "type": "forcePushed"}]}