{"pr_number": 12090, "pr_title": "[BEAM-10336,BEAM-10337] Add SchemaIO abstraction and implement for PubSub", "pr_createdAt": "2020-06-25T19:02:51Z", "pr_url": "https://github.com/apache/beam/pull/12090", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkwODE4NA==", "url": "https://github.com/apache/beam/pull/12090#discussion_r445908184", "bodyText": "It would be better if we could map the tableProperties into a Row by leveraging RowJson.RowJsonDeserializer initialized with configurationSchema(), then there wouldn't be any logic specific to pubsub here.\nThe biggest hang-up with that is \"useFlatSchema\", since its not actually part of the JSON - is there a reason we can't move all of the logic for detecting flat vs. nested schemas into PubsubSchemaCapableIOProvider#from?", "author": "TheNeuralBit", "createdAt": "2020-06-26T00:29:17Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/pubsub/PubsubJsonTableProvider.java", "diffHunk": "@@ -47,32 +44,40 @@\n @Experimental\n @AutoService(TableProvider.class)\n public class PubsubJsonTableProvider extends InMemoryMetaTableProvider {\n+  static final String TIMESTAMP_FIELD = \"event_timestamp\";\n+  static final String ATTRIBUTES_FIELD = \"attributes\";\n+  static final String PAYLOAD_FIELD = \"payload\";\n \n   @Override\n   public String getTableType() {\n     return \"pubsub\";\n   }\n \n   @Override\n-  public BeamSqlTable buildBeamSqlTable(Table tableDefintion) {\n-    JSONObject tableProperties = tableDefintion.getProperties();\n+  public BeamSqlTable buildBeamSqlTable(Table tableDefinition) {\n+    JSONObject tableProperties = tableDefinition.getProperties();\n     String timestampAttributeKey = tableProperties.getString(\"timestampAttributeKey\");\n     String deadLetterQueue = tableProperties.getString(\"deadLetterQueue\");\n-    validateDlq(deadLetterQueue);\n \n-    Schema schema = tableDefintion.getSchema();\n+    Schema schema = tableDefinition.getSchema();\n+    String location = tableDefinition.getLocation();\n+    Schema dataSchema = tableDefinition.getSchema();\n+\n+    validateDlq(deadLetterQueue);\n     validateEventTimestamp(schema);\n \n-    PubsubIOTableConfiguration config =\n-        PubsubIOTableConfiguration.builder()\n-            .setSchema(schema)\n-            .setTimestampAttribute(timestampAttributeKey)\n-            .setDeadLetterQueue(deadLetterQueue)\n-            .setTopic(tableDefintion.getLocation())\n-            .setUseFlatSchema(!definesAttributeAndPayload(schema))\n+    PubsubSchemaCapableIOProvider ioProvider = new PubsubSchemaCapableIOProvider();\n+    Schema configurationSchema = ioProvider.configurationSchema();\n+\n+    Row configurationRow =\n+        Row.withSchema(configurationSchema)\n+            .withFieldValue(\"timestampAttributeKey\", timestampAttributeKey)\n+            .withFieldValue(\"deadLetterQueue\", deadLetterQueue)\n+            .withFieldValue(\"useFlatSchema\", !definesAttributeAndPayload(schema))", "originalCommit": "fdcfdbdee40194d90a16a02f1b2d46f9123ac120", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkwODE5MQ==", "url": "https://github.com/apache/beam/pull/12090#discussion_r445908191", "bodyText": "Could you move this validation to the new implementation (probably in the from method)? We'll want to make sure we still do the validation when this is used outside of SQL (e.g. for cross-language).", "author": "TheNeuralBit", "createdAt": "2020-06-26T00:29:19Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/pubsub/PubsubJsonTableProvider.java", "diffHunk": "@@ -47,32 +44,40 @@\n @Experimental\n @AutoService(TableProvider.class)\n public class PubsubJsonTableProvider extends InMemoryMetaTableProvider {\n+  static final String TIMESTAMP_FIELD = \"event_timestamp\";\n+  static final String ATTRIBUTES_FIELD = \"attributes\";\n+  static final String PAYLOAD_FIELD = \"payload\";\n \n   @Override\n   public String getTableType() {\n     return \"pubsub\";\n   }\n \n   @Override\n-  public BeamSqlTable buildBeamSqlTable(Table tableDefintion) {\n-    JSONObject tableProperties = tableDefintion.getProperties();\n+  public BeamSqlTable buildBeamSqlTable(Table tableDefinition) {\n+    JSONObject tableProperties = tableDefinition.getProperties();\n     String timestampAttributeKey = tableProperties.getString(\"timestampAttributeKey\");\n     String deadLetterQueue = tableProperties.getString(\"deadLetterQueue\");\n-    validateDlq(deadLetterQueue);\n \n-    Schema schema = tableDefintion.getSchema();\n+    Schema schema = tableDefinition.getSchema();\n+    String location = tableDefinition.getLocation();\n+    Schema dataSchema = tableDefinition.getSchema();\n+\n+    validateDlq(deadLetterQueue);\n     validateEventTimestamp(schema);", "originalCommit": "fdcfdbdee40194d90a16a02f1b2d46f9123ac120", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkxMDA1MA==", "url": "https://github.com/apache/beam/pull/12090#discussion_r445910050", "bodyText": "nit: it won't be new forever :)\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /** Provides a new schema aware IO abstraction interface. */\n          \n          \n            \n            /** Provides abstractions for schema-aware IOs. */", "author": "TheNeuralBit", "createdAt": "2020-06-26T00:37:01Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/io/package-info.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/** Provides a new schema aware IO abstraction interface. */", "originalCommit": "fdcfdbdee40194d90a16a02f1b2d46f9123ac120", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkxMDcyMg==", "url": "https://github.com/apache/beam/pull/12090#discussion_r445910722", "bodyText": "Please add @DefaultAnnotation(NonNull.class) like this: \n  \n    \n      beam/sdks/java/core/src/main/java/org/apache/beam/sdk/package-info.java\n    \n    \n        Lines 29 to 30\n      in\n      451af51\n    \n    \n    \n    \n\n        \n          \n           @DefaultAnnotation(NonNull.class) \n        \n\n        \n          \n           package org.apache.beam.sdk; \n        \n    \n  \n\n\nThat's supposed to make spotbugs verify we never pass null to a function argument, unless it's explicitly allowed with @Nullable", "author": "TheNeuralBit", "createdAt": "2020-06-26T00:39:42Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/io/package-info.java", "diffHunk": "@@ -0,0 +1,20 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/** Provides a new schema aware IO abstraction interface. */\n+package org.apache.beam.sdk.schemas.io;", "originalCommit": "fdcfdbdee40194d90a16a02f1b2d46f9123ac120", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkxMTY2MQ==", "url": "https://github.com/apache/beam/pull/12090#discussion_r445911661", "bodyText": "This could defer to PubsubSchemaIOProvider#identifier(), but you'd need to have an instance of it (could be a static member, or you could add a constructor and create one there).", "author": "TheNeuralBit", "createdAt": "2020-06-26T00:43:35Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/pubsub/PubsubJsonTableProvider.java", "diffHunk": "@@ -47,32 +44,40 @@\n @Experimental\n @AutoService(TableProvider.class)\n public class PubsubJsonTableProvider extends InMemoryMetaTableProvider {\n+  static final String TIMESTAMP_FIELD = \"event_timestamp\";\n+  static final String ATTRIBUTES_FIELD = \"attributes\";\n+  static final String PAYLOAD_FIELD = \"payload\";\n \n   @Override\n   public String getTableType() {\n     return \"pubsub\";", "originalCommit": "fdcfdbdee40194d90a16a02f1b2d46f9123ac120", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkxNTc1NQ==", "url": "https://github.com/apache/beam/pull/12090#discussion_r445915755", "bodyText": "I think we should make this a private static inner class within PubsubSchemaCapableIOProvider so no one tries to use it on its own.", "author": "TheNeuralBit", "createdAt": "2020-06-26T01:00:56Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubSchemaIO.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.pubsub;\n+\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.DLQ_TAG;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.MAIN_TAG;\n+\n+import java.io.Serializable;\n+import org.apache.beam.sdk.annotations.Internal;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.schemas.io.SchemaIO;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.values.PBegin;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.Row;\n+\n+/** An abstraction to create schema aware IOs. */\n+@Internal\n+public class PubsubSchemaIO implements SchemaIO, Serializable {", "originalCommit": "fdcfdbdee40194d90a16a02f1b2d46f9123ac120", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTkxOTMyOQ==", "url": "https://github.com/apache/beam/pull/12090#discussion_r445919329", "bodyText": "Hm I feel like this also should not be public... but I see that's actually my fault since I did it originally. Would you mind fixing my mistake and making this a private static inner class?", "author": "TheNeuralBit", "createdAt": "2020-06-26T01:17:01Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/RowToPubsubMessage.java", "diffHunk": "@@ -38,29 +37,28 @@\n  * <p>Currently only supports writing a flat schema into a JSON payload. This means that all Row\n  * field values are written to the {@link PubsubMessage} JSON payload, except for {@code\n  * event_timestamp}, which is either ignored or written to the message attributes, depending on\n- * whether {@link PubsubJsonTableProvider.PubsubIOTableConfiguration#getTimestampAttribute()} is\n- * set.\n+ * whether config.getValue(\"timestampAttributeKey\") is set.\n  */\n @Experimental\n public class RowToPubsubMessage extends PTransform<PCollection<Row>, PCollection<PubsubMessage>> {", "originalCommit": "fdcfdbdee40194d90a16a02f1b2d46f9123ac120", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQxMzg3MQ==", "url": "https://github.com/apache/beam/pull/12090#discussion_r446413871", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /** Exception thrown when the request for a table is invalid, such as invalid metadata. */\n          \n          \n            \n            /** Exception thrown when the configuration for a {@link SchemaIO} is invalid. */", "author": "TheNeuralBit", "createdAt": "2020-06-26T21:16:35Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/io/InvalidConfigurationException.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.schemas.io;\n+\n+/** Exception thrown when the request for a table is invalid, such as invalid metadata. */", "originalCommit": "0b1804967423a7d35cdbe99261133e44279bd5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MDc3Mg==", "url": "https://github.com/apache/beam/pull/12090#discussion_r446460772", "bodyText": "Doesn't need to happen now but we may want to flesh this out a bit, so it can indicate which configuration field(s) are invalid. Also a separate exception for an invalid schema would be good.", "author": "TheNeuralBit", "createdAt": "2020-06-27T00:30:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQxMzg3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQxNDczMA==", "url": "https://github.com/apache/beam/pull/12090#discussion_r446414730", "bodyText": "Can you add a note that this can throw an InvalidConfigurationException?", "author": "TheNeuralBit", "createdAt": "2020-06-26T21:19:05Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/io/SchemaCapableIOProvider.java", "diffHunk": "@@ -0,0 +1,38 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.schemas.io;\n+\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.values.Row;\n+\n+public interface SchemaCapableIOProvider {\n+  /** Returns an id that uniquely represents this IO. */\n+  String identifier();\n+\n+  /**\n+   * Returns the expected schema of the configuration object. Note this is distinct from the schema\n+   * of the data source itself.\n+   */\n+  Schema configurationSchema();\n+\n+  /**\n+   * Produce a SchemaIO given a String representing the data's location, the schema of the data that\n+   * resides there, and some IO-specific configuration object.\n+   */", "originalCommit": "0b1804967423a7d35cdbe99261133e44279bd5a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ1ODYzMQ==", "url": "https://github.com/apache/beam/pull/12090#discussion_r446458631", "bodyText": "I don't think we want to lose the information in these doc comments. Could you move it into the javadoc for PubSubSchemaCapableIOProvider?", "author": "TheNeuralBit", "createdAt": "2020-06-27T00:15:57Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/pubsub/PubsubJsonTableProvider.java", "diffHunk": "@@ -54,125 +47,29 @@ public String getTableType() {\n   }\n \n   @Override\n-  public BeamSqlTable buildBeamSqlTable(Table tableDefintion) {\n-    JSONObject tableProperties = tableDefintion.getProperties();\n+  public BeamSqlTable buildBeamSqlTable(Table tableDefinition) {\n+    JSONObject tableProperties = tableDefinition.getProperties();\n     String timestampAttributeKey = tableProperties.getString(\"timestampAttributeKey\");\n     String deadLetterQueue = tableProperties.getString(\"deadLetterQueue\");\n-    validateDlq(deadLetterQueue);\n-\n-    Schema schema = tableDefintion.getSchema();\n-    validateEventTimestamp(schema);\n-\n-    PubsubIOTableConfiguration config =\n-        PubsubIOTableConfiguration.builder()\n-            .setSchema(schema)\n-            .setTimestampAttribute(timestampAttributeKey)\n-            .setDeadLetterQueue(deadLetterQueue)\n-            .setTopic(tableDefintion.getLocation())\n-            .setUseFlatSchema(!definesAttributeAndPayload(schema))\n-            .build();\n-\n-    return PubsubIOJsonTable.withConfiguration(config);\n-  }\n-\n-  private void validateEventTimestamp(Schema schema) {\n-    if (!fieldPresent(schema, TIMESTAMP_FIELD, TIMESTAMP)) {\n-      throw new InvalidTableException(\n-          \"Unsupported schema specified for Pubsub source in CREATE TABLE.\"\n-              + \"CREATE TABLE for Pubsub topic must include at least 'event_timestamp' field of \"\n-              + \"type 'TIMESTAMP'\");\n-    }\n-  }\n-\n-  private boolean definesAttributeAndPayload(Schema schema) {\n-    return fieldPresent(\n-            schema, ATTRIBUTES_FIELD, Schema.FieldType.map(VARCHAR.withNullable(false), VARCHAR))\n-        && (schema.hasField(PAYLOAD_FIELD)\n-            && ROW.equals(schema.getField(PAYLOAD_FIELD).getType().getTypeName()));\n-  }\n-\n-  private boolean fieldPresent(Schema schema, String field, Schema.FieldType expectedType) {\n-    return schema.hasField(field)\n-        && expectedType.equivalent(\n-            schema.getField(field).getType(), Schema.EquivalenceNullablePolicy.IGNORE);\n-  }\n-\n-  private void validateDlq(String deadLetterQueue) {\n-    if (deadLetterQueue != null && deadLetterQueue.isEmpty()) {\n-      throw new InvalidTableException(\"Dead letter queue topic name is not specified\");\n-    }\n-  }\n-\n-  @AutoValue\n-  public abstract static class PubsubIOTableConfiguration implements Serializable {\n-    public boolean useDlq() {\n-      return getDeadLetterQueue() != null;\n-    }\n-\n-    public boolean useTimestampAttribute() {\n-      return getTimestampAttribute() != null;\n-    }\n-\n-    /** Determines whether or not the messages should be represented with a flattened schema. */\n-    abstract boolean getUseFlatSchema();\n-\n-    /**\n-     * Optional attribute key of the Pubsub message from which to extract the event timestamp.\n-     *\n-     * <p>This attribute has to conform to the same requirements as in {@link\n-     * PubsubIO.Read.Builder#withTimestampAttribute}.\n-     *\n-     * <p>Short version: it has to be either millis since epoch or string in RFC 3339 format.\n-     *\n-     * <p>If the attribute is specified then event timestamps will be extracted from the specified\n-     * attribute. If it is not specified then message publish timestamp will be used.\n-     */\n-    @Nullable\n-    abstract String getTimestampAttribute();\n-\n-    /**\n-     * Optional topic path which will be used as a dead letter queue.\n-     *\n-     * <p>Messages that cannot be processed will be sent to this topic. If it is not specified then\n-     * exception will be thrown for errors during processing causing the pipeline to crash.\n-     */\n-    @Nullable\n-    abstract String getDeadLetterQueue();\n \n-    /**\n-     * Pubsub topic name.\n-     *\n-     * <p>Topic is the only way to specify the Pubsub source. Explicitly specifying the subscription\n-     * is not supported at the moment. Subscriptions are automatically created (but not deleted).\n-     */\n-    abstract String getTopic();\n+    Schema schema = tableDefinition.getSchema();\n+    String location = tableDefinition.getLocation();\n+    Schema dataSchema = tableDefinition.getSchema();\n \n-    /**\n-     * Table schema, describes Pubsub message schema.\n-     *\n-     * <p>If {@link #getUseFlatSchema()} is not set, schema must contain exactly fields\n-     * 'event_timestamp', 'attributes, and 'payload'. Else, it must contain just 'event_timestamp'.\n-     * See {@linkA PubsubMessageToRow} for details.\n-     */\n-    public abstract Schema getSchema();", "originalCommit": "0b1804967423a7d35cdbe99261133e44279bd5a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjQ2MDE5MA==", "url": "https://github.com/apache/beam/pull/12090#discussion_r446460190", "bodyText": "This should just catch InvalidConfigurationException e, not any Exception.\nAlso you should include the information from the original exception when re-throwing. Either use e.getMessage() to insert the original message into the new one, or add the exception as a cause (new InvalidTableException(msg, e)), or both.\nI think that should fix the unit test that's failing.", "author": "TheNeuralBit", "createdAt": "2020-06-27T00:26:26Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/pubsub/PubsubJsonTableProvider.java", "diffHunk": "@@ -54,125 +47,29 @@ public String getTableType() {\n   }\n \n   @Override\n-  public BeamSqlTable buildBeamSqlTable(Table tableDefintion) {\n-    JSONObject tableProperties = tableDefintion.getProperties();\n+  public BeamSqlTable buildBeamSqlTable(Table tableDefinition) {\n+    JSONObject tableProperties = tableDefinition.getProperties();\n     String timestampAttributeKey = tableProperties.getString(\"timestampAttributeKey\");\n     String deadLetterQueue = tableProperties.getString(\"deadLetterQueue\");\n-    validateDlq(deadLetterQueue);\n-\n-    Schema schema = tableDefintion.getSchema();\n-    validateEventTimestamp(schema);\n-\n-    PubsubIOTableConfiguration config =\n-        PubsubIOTableConfiguration.builder()\n-            .setSchema(schema)\n-            .setTimestampAttribute(timestampAttributeKey)\n-            .setDeadLetterQueue(deadLetterQueue)\n-            .setTopic(tableDefintion.getLocation())\n-            .setUseFlatSchema(!definesAttributeAndPayload(schema))\n-            .build();\n-\n-    return PubsubIOJsonTable.withConfiguration(config);\n-  }\n-\n-  private void validateEventTimestamp(Schema schema) {\n-    if (!fieldPresent(schema, TIMESTAMP_FIELD, TIMESTAMP)) {\n-      throw new InvalidTableException(\n-          \"Unsupported schema specified for Pubsub source in CREATE TABLE.\"\n-              + \"CREATE TABLE for Pubsub topic must include at least 'event_timestamp' field of \"\n-              + \"type 'TIMESTAMP'\");\n-    }\n-  }\n-\n-  private boolean definesAttributeAndPayload(Schema schema) {\n-    return fieldPresent(\n-            schema, ATTRIBUTES_FIELD, Schema.FieldType.map(VARCHAR.withNullable(false), VARCHAR))\n-        && (schema.hasField(PAYLOAD_FIELD)\n-            && ROW.equals(schema.getField(PAYLOAD_FIELD).getType().getTypeName()));\n-  }\n-\n-  private boolean fieldPresent(Schema schema, String field, Schema.FieldType expectedType) {\n-    return schema.hasField(field)\n-        && expectedType.equivalent(\n-            schema.getField(field).getType(), Schema.EquivalenceNullablePolicy.IGNORE);\n-  }\n-\n-  private void validateDlq(String deadLetterQueue) {\n-    if (deadLetterQueue != null && deadLetterQueue.isEmpty()) {\n-      throw new InvalidTableException(\"Dead letter queue topic name is not specified\");\n-    }\n-  }\n-\n-  @AutoValue\n-  public abstract static class PubsubIOTableConfiguration implements Serializable {\n-    public boolean useDlq() {\n-      return getDeadLetterQueue() != null;\n-    }\n-\n-    public boolean useTimestampAttribute() {\n-      return getTimestampAttribute() != null;\n-    }\n-\n-    /** Determines whether or not the messages should be represented with a flattened schema. */\n-    abstract boolean getUseFlatSchema();\n-\n-    /**\n-     * Optional attribute key of the Pubsub message from which to extract the event timestamp.\n-     *\n-     * <p>This attribute has to conform to the same requirements as in {@link\n-     * PubsubIO.Read.Builder#withTimestampAttribute}.\n-     *\n-     * <p>Short version: it has to be either millis since epoch or string in RFC 3339 format.\n-     *\n-     * <p>If the attribute is specified then event timestamps will be extracted from the specified\n-     * attribute. If it is not specified then message publish timestamp will be used.\n-     */\n-    @Nullable\n-    abstract String getTimestampAttribute();\n-\n-    /**\n-     * Optional topic path which will be used as a dead letter queue.\n-     *\n-     * <p>Messages that cannot be processed will be sent to this topic. If it is not specified then\n-     * exception will be thrown for errors during processing causing the pipeline to crash.\n-     */\n-    @Nullable\n-    abstract String getDeadLetterQueue();\n \n-    /**\n-     * Pubsub topic name.\n-     *\n-     * <p>Topic is the only way to specify the Pubsub source. Explicitly specifying the subscription\n-     * is not supported at the moment. Subscriptions are automatically created (but not deleted).\n-     */\n-    abstract String getTopic();\n+    Schema schema = tableDefinition.getSchema();\n+    String location = tableDefinition.getLocation();\n+    Schema dataSchema = tableDefinition.getSchema();\n \n-    /**\n-     * Table schema, describes Pubsub message schema.\n-     *\n-     * <p>If {@link #getUseFlatSchema()} is not set, schema must contain exactly fields\n-     * 'event_timestamp', 'attributes, and 'payload'. Else, it must contain just 'event_timestamp'.\n-     * See {@linkA PubsubMessageToRow} for details.\n-     */\n-    public abstract Schema getSchema();\n+    PubsubSchemaCapableIOProvider ioProvider = new PubsubSchemaCapableIOProvider();\n+    Schema configurationSchema = ioProvider.configurationSchema();\n \n-    static Builder builder() {\n-      return new AutoValue_PubsubJsonTableProvider_PubsubIOTableConfiguration.Builder();\n-    }\n-\n-    @AutoValue.Builder\n-    abstract static class Builder {\n-      abstract Builder setUseFlatSchema(boolean useFlatSchema);\n-\n-      abstract Builder setSchema(Schema schema);\n-\n-      abstract Builder setTimestampAttribute(String timestampAttribute);\n-\n-      abstract Builder setDeadLetterQueue(String deadLetterQueue);\n-\n-      abstract Builder setTopic(String topic);\n+    Row configurationRow =\n+        Row.withSchema(configurationSchema)\n+            .withFieldValue(\"timestampAttributeKey\", timestampAttributeKey)\n+            .withFieldValue(\"deadLetterQueue\", deadLetterQueue)\n+            .build();\n \n-      abstract PubsubIOTableConfiguration build();\n+    try {\n+      SchemaIO pubsubSchemaIO = ioProvider.from(location, configurationRow, dataSchema);\n+      return PubsubIOJsonTable.withConfiguration(pubsubSchemaIO, schema);\n+    } catch (Exception InvalidConfigurationException) {\n+      throw new InvalidTableException(\"Invalid configuration of table\");", "originalCommit": "0b1804967423a7d35cdbe99261133e44279bd5a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDY1Ng==", "url": "https://github.com/apache/beam/pull/12090#discussion_r446584656", "bodyText": "Now that configuration is gone, this function could be better named as something like fromSchemaIO().\nAlso, the second parameter schema doesn't seem necessary. You can get that information from pubsubSchemaIO.schema().", "author": "robinyqiu", "createdAt": "2020-06-28T00:52:48Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/pubsub/PubsubIOJsonTable.java", "diffHunk": "@@ -122,14 +115,16 @@\n @Experimental\n class PubsubIOJsonTable extends BaseBeamTable implements Serializable {\n \n-  protected final PubsubIOTableConfiguration config;\n+  protected final SchemaIO pubsubSchemaIO;\n+  protected final Schema schema;\n \n-  private PubsubIOJsonTable(PubsubIOTableConfiguration config) {\n-    this.config = config;\n+  private PubsubIOJsonTable(SchemaIO pubsubSchemaIO, Schema schema) {\n+    this.pubsubSchemaIO = pubsubSchemaIO;\n+    this.schema = schema;\n   }\n \n-  static PubsubIOJsonTable withConfiguration(PubsubIOTableConfiguration config) {\n-    return new PubsubIOJsonTable(config);\n+  static PubsubIOJsonTable withConfiguration(SchemaIO pubsubSchemaIO, Schema schema) {", "originalCommit": "0b1804967423a7d35cdbe99261133e44279bd5a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDg4Nw==", "url": "https://github.com/apache/beam/pull/12090#discussion_r446584887", "bodyText": "Nit: there is nothing wrong with this line, but usually we would write begin.apply(readerTransform) (same below)", "author": "robinyqiu", "createdAt": "2020-06-28T00:56:17Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/pubsub/PubsubIOJsonTable.java", "diffHunk": "@@ -139,65 +134,19 @@ static PubsubIOJsonTable withConfiguration(PubsubIOTableConfiguration config) {\n \n   @Override\n   public Schema getSchema() {\n-    return config.getSchema();\n+    return schema;\n   }\n \n   @Override\n   public PCollection<Row> buildIOReader(PBegin begin) {\n-    PCollectionTuple rowsWithDlq =\n-        begin\n-            .apply(\"ReadFromPubsub\", readMessagesWithAttributes())\n-            .apply(\n-                \"PubsubMessageToRow\",\n-                PubsubMessageToRow.builder()\n-                    .messageSchema(getSchema())\n-                    .useDlq(config.useDlq())\n-                    .useFlatSchema(config.getUseFlatSchema())\n-                    .build());\n-    rowsWithDlq.get(MAIN_TAG).setRowSchema(getSchema());\n-\n-    if (config.useDlq()) {\n-      rowsWithDlq.get(DLQ_TAG).apply(writeMessagesToDlq());\n-    }\n-\n-    return rowsWithDlq.get(MAIN_TAG);\n-  }\n-\n-  private PubsubIO.Read<PubsubMessage> readMessagesWithAttributes() {\n-    PubsubIO.Read<PubsubMessage> read =\n-        PubsubIO.readMessagesWithAttributes().fromTopic(config.getTopic());\n-\n-    return config.useTimestampAttribute()\n-        ? read.withTimestampAttribute(config.getTimestampAttribute())\n-        : read;\n-  }\n-\n-  private PubsubIO.Write<PubsubMessage> writeMessagesToDlq() {\n-    PubsubIO.Write<PubsubMessage> write = PubsubIO.writeMessages().to(config.getDeadLetterQueue());\n-\n-    return config.useTimestampAttribute()\n-        ? write.withTimestampAttribute(config.getTimestampAttribute())\n-        : write;\n+    PTransform<PBegin, PCollection<Row>> readerTransform = pubsubSchemaIO.buildReader();\n+    return readerTransform.expand(begin);", "originalCommit": "0b1804967423a7d35cdbe99261133e44279bd5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3NTI5Mg==", "url": "https://github.com/apache/beam/pull/12090#discussion_r447075292", "bodyText": "Good catch, thanks Robin. Same thing in buildIOWriter", "author": "TheNeuralBit", "createdAt": "2020-06-29T15:52:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NDg4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTI2Mw==", "url": "https://github.com/apache/beam/pull/12090#discussion_r446585263", "bodyText": "This is the same as dataSchema.\nAlso, almost all the local variables defined here is used only once. Maybe moving them inline will make the function looks better.", "author": "robinyqiu", "createdAt": "2020-06-28T01:02:04Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/pubsub/PubsubJsonTableProvider.java", "diffHunk": "@@ -54,125 +47,29 @@ public String getTableType() {\n   }\n \n   @Override\n-  public BeamSqlTable buildBeamSqlTable(Table tableDefintion) {\n-    JSONObject tableProperties = tableDefintion.getProperties();\n+  public BeamSqlTable buildBeamSqlTable(Table tableDefinition) {\n+    JSONObject tableProperties = tableDefinition.getProperties();\n     String timestampAttributeKey = tableProperties.getString(\"timestampAttributeKey\");\n     String deadLetterQueue = tableProperties.getString(\"deadLetterQueue\");\n-    validateDlq(deadLetterQueue);\n-\n-    Schema schema = tableDefintion.getSchema();\n-    validateEventTimestamp(schema);\n-\n-    PubsubIOTableConfiguration config =\n-        PubsubIOTableConfiguration.builder()\n-            .setSchema(schema)\n-            .setTimestampAttribute(timestampAttributeKey)\n-            .setDeadLetterQueue(deadLetterQueue)\n-            .setTopic(tableDefintion.getLocation())\n-            .setUseFlatSchema(!definesAttributeAndPayload(schema))\n-            .build();\n-\n-    return PubsubIOJsonTable.withConfiguration(config);\n-  }\n-\n-  private void validateEventTimestamp(Schema schema) {\n-    if (!fieldPresent(schema, TIMESTAMP_FIELD, TIMESTAMP)) {\n-      throw new InvalidTableException(\n-          \"Unsupported schema specified for Pubsub source in CREATE TABLE.\"\n-              + \"CREATE TABLE for Pubsub topic must include at least 'event_timestamp' field of \"\n-              + \"type 'TIMESTAMP'\");\n-    }\n-  }\n-\n-  private boolean definesAttributeAndPayload(Schema schema) {\n-    return fieldPresent(\n-            schema, ATTRIBUTES_FIELD, Schema.FieldType.map(VARCHAR.withNullable(false), VARCHAR))\n-        && (schema.hasField(PAYLOAD_FIELD)\n-            && ROW.equals(schema.getField(PAYLOAD_FIELD).getType().getTypeName()));\n-  }\n-\n-  private boolean fieldPresent(Schema schema, String field, Schema.FieldType expectedType) {\n-    return schema.hasField(field)\n-        && expectedType.equivalent(\n-            schema.getField(field).getType(), Schema.EquivalenceNullablePolicy.IGNORE);\n-  }\n-\n-  private void validateDlq(String deadLetterQueue) {\n-    if (deadLetterQueue != null && deadLetterQueue.isEmpty()) {\n-      throw new InvalidTableException(\"Dead letter queue topic name is not specified\");\n-    }\n-  }\n-\n-  @AutoValue\n-  public abstract static class PubsubIOTableConfiguration implements Serializable {\n-    public boolean useDlq() {\n-      return getDeadLetterQueue() != null;\n-    }\n-\n-    public boolean useTimestampAttribute() {\n-      return getTimestampAttribute() != null;\n-    }\n-\n-    /** Determines whether or not the messages should be represented with a flattened schema. */\n-    abstract boolean getUseFlatSchema();\n-\n-    /**\n-     * Optional attribute key of the Pubsub message from which to extract the event timestamp.\n-     *\n-     * <p>This attribute has to conform to the same requirements as in {@link\n-     * PubsubIO.Read.Builder#withTimestampAttribute}.\n-     *\n-     * <p>Short version: it has to be either millis since epoch or string in RFC 3339 format.\n-     *\n-     * <p>If the attribute is specified then event timestamps will be extracted from the specified\n-     * attribute. If it is not specified then message publish timestamp will be used.\n-     */\n-    @Nullable\n-    abstract String getTimestampAttribute();\n-\n-    /**\n-     * Optional topic path which will be used as a dead letter queue.\n-     *\n-     * <p>Messages that cannot be processed will be sent to this topic. If it is not specified then\n-     * exception will be thrown for errors during processing causing the pipeline to crash.\n-     */\n-    @Nullable\n-    abstract String getDeadLetterQueue();\n \n-    /**\n-     * Pubsub topic name.\n-     *\n-     * <p>Topic is the only way to specify the Pubsub source. Explicitly specifying the subscription\n-     * is not supported at the moment. Subscriptions are automatically created (but not deleted).\n-     */\n-    abstract String getTopic();\n+    Schema schema = tableDefinition.getSchema();", "originalCommit": "0b1804967423a7d35cdbe99261133e44279bd5a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTQ0MQ==", "url": "https://github.com/apache/beam/pull/12090#discussion_r446585441", "bodyText": "I am not sure if we expect the table type here to be the same as PubsubSchemaCapableIOProvider.identifier(). WDYT Brian?", "author": "robinyqiu", "createdAt": "2020-06-28T01:05:02Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/pubsub/PubsubJsonTableProvider.java", "diffHunk": "@@ -54,125 +47,29 @@ public String getTableType() {\n   }", "originalCommit": "0b1804967423a7d35cdbe99261133e44279bd5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzExOTU5Nw==", "url": "https://github.com/apache/beam/pull/12090#discussion_r447119597", "bodyText": "Yes my intention was that they should be the same. I'm not that concerned about it being hard-coded for now. We're planning to replace this class with a general-purpose \"wrapper\" that can adapt any SchemaCapableIOProvider to the TableProvider interface, and I figured getTableType would just call SchemaCapableIOProvider#identifier.\nThat work is tracked in BEAM-10337", "author": "TheNeuralBit", "createdAt": "2020-06-29T17:01:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTQ0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE1MzM0OA==", "url": "https://github.com/apache/beam/pull/12090#discussion_r447153348", "bodyText": "Sounds good!", "author": "robinyqiu", "createdAt": "2020-06-29T18:00:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTQ0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NTkyNw==", "url": "https://github.com/apache/beam/pull/12090#discussion_r446585927", "bodyText": "SchemaCapableIOProvider and SchemaIO are very important interfaces. Please add thorough class-level and method-level javadoc to explain what they are to help people better understand these concepts.", "author": "robinyqiu", "createdAt": "2020-06-28T01:12:05Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/io/SchemaIO.java", "diffHunk": "@@ -0,0 +1,33 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.schemas.io;\n+\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.values.PBegin;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.Row;\n+\n+public interface SchemaIO {", "originalCommit": "0b1804967423a7d35cdbe99261133e44279bd5a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NjUwNA==", "url": "https://github.com/apache/beam/pull/12090#discussion_r446586504", "bodyText": "How about adding validateConfiguration() here to make sure the configuration row matches configurationSchema?", "author": "robinyqiu", "createdAt": "2020-06-28T01:20:19Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubSchemaCapableIOProvider.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.pubsub;\n+\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.ATTRIBUTES_FIELD;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.DLQ_TAG;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.MAIN_TAG;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.PAYLOAD_FIELD;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.TIMESTAMP_FIELD;\n+import static org.apache.beam.sdk.schemas.Schema.TypeName.ROW;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+\n+import com.google.auto.service.AutoService;\n+import java.io.Serializable;\n+import java.nio.charset.StandardCharsets;\n+import org.apache.beam.sdk.annotations.Internal;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.schemas.Schema.FieldType;\n+import org.apache.beam.sdk.schemas.io.InvalidConfigurationException;\n+import org.apache.beam.sdk.schemas.io.SchemaCapableIOProvider;\n+import org.apache.beam.sdk.schemas.io.SchemaIO;\n+import org.apache.beam.sdk.schemas.transforms.DropFields;\n+import org.apache.beam.sdk.transforms.MapElements;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ToJson;\n+import org.apache.beam.sdk.transforms.WithTimestamps;\n+import org.apache.beam.sdk.values.PBegin;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.sdk.values.TypeDescriptor;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * {@link org.apache.beam.sdk.schemas.io.SchemaCapableIOProvider} to create {@link PubsubSchemaIO}\n+ * that implements {@link org.apache.beam.sdk.schemas.io.SchemaIO}.\n+ */\n+@Internal\n+@AutoService(SchemaCapableIOProvider.class)\n+public class PubsubSchemaCapableIOProvider implements SchemaCapableIOProvider {\n+  public static final FieldType VARCHAR = FieldType.STRING;\n+  public static final FieldType TIMESTAMP = FieldType.DATETIME;\n+\n+  /** Returns an id that uniquely represents this IO. */\n+  @Override\n+  public String identifier() {\n+    return \"pubsub\";\n+  }\n+\n+  /**\n+   * Returns the expected schema of the configuration object. Note this is distinct from the schema\n+   * of the data source itself.\n+   */\n+  @Override\n+  public Schema configurationSchema() {\n+    return Schema.builder()\n+        .addNullableField(\"timestampAttributeKey\", FieldType.STRING)\n+        .addNullableField(\"deadLetterQueue\", FieldType.STRING)\n+        .build();\n+  }\n+\n+  /**\n+   * Produce a SchemaIO given a String representing the data's location, the schema of the data that\n+   * resides there, and some IO-specific configuration object.\n+   */\n+  @Override\n+  public PubsubSchemaIO from(String location, Row configuration, Schema dataSchema) {", "originalCommit": "0b1804967423a7d35cdbe99261133e44279bd5a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4Njc1MA==", "url": "https://github.com/apache/beam/pull/12090#discussion_r446586750", "bodyText": "This static method is no longer necessary as the class became private. You can call the constructor directly from the outer class.", "author": "robinyqiu", "createdAt": "2020-06-28T01:24:20Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubSchemaCapableIOProvider.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.pubsub;\n+\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.ATTRIBUTES_FIELD;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.DLQ_TAG;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.MAIN_TAG;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.PAYLOAD_FIELD;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.TIMESTAMP_FIELD;\n+import static org.apache.beam.sdk.schemas.Schema.TypeName.ROW;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+\n+import com.google.auto.service.AutoService;\n+import java.io.Serializable;\n+import java.nio.charset.StandardCharsets;\n+import org.apache.beam.sdk.annotations.Internal;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.schemas.Schema.FieldType;\n+import org.apache.beam.sdk.schemas.io.InvalidConfigurationException;\n+import org.apache.beam.sdk.schemas.io.SchemaCapableIOProvider;\n+import org.apache.beam.sdk.schemas.io.SchemaIO;\n+import org.apache.beam.sdk.schemas.transforms.DropFields;\n+import org.apache.beam.sdk.transforms.MapElements;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ToJson;\n+import org.apache.beam.sdk.transforms.WithTimestamps;\n+import org.apache.beam.sdk.values.PBegin;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.sdk.values.TypeDescriptor;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * {@link org.apache.beam.sdk.schemas.io.SchemaCapableIOProvider} to create {@link PubsubSchemaIO}\n+ * that implements {@link org.apache.beam.sdk.schemas.io.SchemaIO}.\n+ */\n+@Internal\n+@AutoService(SchemaCapableIOProvider.class)\n+public class PubsubSchemaCapableIOProvider implements SchemaCapableIOProvider {\n+  public static final FieldType VARCHAR = FieldType.STRING;\n+  public static final FieldType TIMESTAMP = FieldType.DATETIME;\n+\n+  /** Returns an id that uniquely represents this IO. */\n+  @Override\n+  public String identifier() {\n+    return \"pubsub\";\n+  }\n+\n+  /**\n+   * Returns the expected schema of the configuration object. Note this is distinct from the schema\n+   * of the data source itself.\n+   */\n+  @Override\n+  public Schema configurationSchema() {\n+    return Schema.builder()\n+        .addNullableField(\"timestampAttributeKey\", FieldType.STRING)\n+        .addNullableField(\"deadLetterQueue\", FieldType.STRING)\n+        .build();\n+  }\n+\n+  /**\n+   * Produce a SchemaIO given a String representing the data's location, the schema of the data that\n+   * resides there, and some IO-specific configuration object.\n+   */\n+  @Override\n+  public PubsubSchemaIO from(String location, Row configuration, Schema dataSchema) {\n+    validateDlq(configuration.getValue(\"deadLetterQueue\"));\n+    validateEventTimestamp(dataSchema);\n+    return PubsubSchemaIO.withConfiguration(location, configuration, dataSchema);\n+  }\n+\n+  private void validateEventTimestamp(Schema schema) {\n+    if (!PubsubSchemaIO.fieldPresent(schema, TIMESTAMP_FIELD, TIMESTAMP)) {\n+      throw new InvalidConfigurationException(\n+          \"Unsupported schema specified for Pubsub source in CREATE TABLE.\"\n+              + \"CREATE TABLE for Pubsub topic must include at least 'event_timestamp' field of \"\n+              + \"type 'TIMESTAMP'\");\n+    }\n+  }\n+\n+  private void validateDlq(String deadLetterQueue) {\n+    if (deadLetterQueue != null && deadLetterQueue.isEmpty()) {\n+      throw new InvalidConfigurationException(\"Dead letter queue topic name is not specified\");\n+    }\n+  }\n+\n+  /** An abstraction to create schema aware IOs. */\n+  @Internal\n+  private static class PubsubSchemaIO implements SchemaIO, Serializable {\n+    protected final Row config;\n+    protected final Schema dataSchema;\n+    protected final String location;\n+    protected final Boolean useFlatSchema;\n+\n+    private PubsubSchemaIO(String location, Row config, Schema dataSchema) {\n+      this.config = config;\n+      this.dataSchema = dataSchema;\n+      this.location = location;\n+      this.useFlatSchema = !definesAttributeAndPayload(dataSchema);\n+    }\n+\n+    static PubsubSchemaIO withConfiguration(String location, Row config, Schema dataSchema) {", "originalCommit": "0b1804967423a7d35cdbe99261133e44279bd5a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NzE5OQ==", "url": "https://github.com/apache/beam/pull/12090#discussion_r446587199", "bodyText": "Same here.", "author": "robinyqiu", "createdAt": "2020-06-28T01:30:50Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubSchemaCapableIOProvider.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.pubsub;\n+\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.ATTRIBUTES_FIELD;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.DLQ_TAG;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.MAIN_TAG;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.PAYLOAD_FIELD;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.TIMESTAMP_FIELD;\n+import static org.apache.beam.sdk.schemas.Schema.TypeName.ROW;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+\n+import com.google.auto.service.AutoService;\n+import java.io.Serializable;\n+import java.nio.charset.StandardCharsets;\n+import org.apache.beam.sdk.annotations.Internal;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.schemas.Schema.FieldType;\n+import org.apache.beam.sdk.schemas.io.InvalidConfigurationException;\n+import org.apache.beam.sdk.schemas.io.SchemaCapableIOProvider;\n+import org.apache.beam.sdk.schemas.io.SchemaIO;\n+import org.apache.beam.sdk.schemas.transforms.DropFields;\n+import org.apache.beam.sdk.transforms.MapElements;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ToJson;\n+import org.apache.beam.sdk.transforms.WithTimestamps;\n+import org.apache.beam.sdk.values.PBegin;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.sdk.values.TypeDescriptor;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * {@link org.apache.beam.sdk.schemas.io.SchemaCapableIOProvider} to create {@link PubsubSchemaIO}\n+ * that implements {@link org.apache.beam.sdk.schemas.io.SchemaIO}.\n+ */\n+@Internal\n+@AutoService(SchemaCapableIOProvider.class)\n+public class PubsubSchemaCapableIOProvider implements SchemaCapableIOProvider {\n+  public static final FieldType VARCHAR = FieldType.STRING;\n+  public static final FieldType TIMESTAMP = FieldType.DATETIME;\n+\n+  /** Returns an id that uniquely represents this IO. */\n+  @Override\n+  public String identifier() {\n+    return \"pubsub\";\n+  }\n+\n+  /**\n+   * Returns the expected schema of the configuration object. Note this is distinct from the schema\n+   * of the data source itself.\n+   */\n+  @Override\n+  public Schema configurationSchema() {\n+    return Schema.builder()\n+        .addNullableField(\"timestampAttributeKey\", FieldType.STRING)\n+        .addNullableField(\"deadLetterQueue\", FieldType.STRING)\n+        .build();\n+  }\n+\n+  /**\n+   * Produce a SchemaIO given a String representing the data's location, the schema of the data that\n+   * resides there, and some IO-specific configuration object.\n+   */\n+  @Override\n+  public PubsubSchemaIO from(String location, Row configuration, Schema dataSchema) {\n+    validateDlq(configuration.getValue(\"deadLetterQueue\"));\n+    validateEventTimestamp(dataSchema);\n+    return PubsubSchemaIO.withConfiguration(location, configuration, dataSchema);\n+  }\n+\n+  private void validateEventTimestamp(Schema schema) {\n+    if (!PubsubSchemaIO.fieldPresent(schema, TIMESTAMP_FIELD, TIMESTAMP)) {\n+      throw new InvalidConfigurationException(\n+          \"Unsupported schema specified for Pubsub source in CREATE TABLE.\"\n+              + \"CREATE TABLE for Pubsub topic must include at least 'event_timestamp' field of \"\n+              + \"type 'TIMESTAMP'\");\n+    }\n+  }\n+\n+  private void validateDlq(String deadLetterQueue) {\n+    if (deadLetterQueue != null && deadLetterQueue.isEmpty()) {\n+      throw new InvalidConfigurationException(\"Dead letter queue topic name is not specified\");\n+    }\n+  }\n+\n+  /** An abstraction to create schema aware IOs. */\n+  @Internal\n+  private static class PubsubSchemaIO implements SchemaIO, Serializable {\n+    protected final Row config;\n+    protected final Schema dataSchema;\n+    protected final String location;\n+    protected final Boolean useFlatSchema;\n+\n+    private PubsubSchemaIO(String location, Row config, Schema dataSchema) {\n+      this.config = config;\n+      this.dataSchema = dataSchema;\n+      this.location = location;\n+      this.useFlatSchema = !definesAttributeAndPayload(dataSchema);\n+    }\n+\n+    static PubsubSchemaIO withConfiguration(String location, Row config, Schema dataSchema) {\n+      return new PubsubSchemaIO(location, config, dataSchema);\n+    }\n+\n+    @Override\n+    public Schema schema() {\n+      return dataSchema;\n+    }\n+\n+    @Override\n+    public PTransform<PBegin, PCollection<Row>> buildReader() {\n+      return new PTransform<PBegin, PCollection<Row>>() {\n+        @Override\n+        public PCollection<Row> expand(PBegin begin) {\n+          PCollectionTuple rowsWithDlq =\n+              begin\n+                  .apply(\"ReadFromPubsub\", readMessagesWithAttributes())\n+                  .apply(\n+                      \"PubsubMessageToRow\",\n+                      PubsubMessageToRow.builder()\n+                          .messageSchema(dataSchema)\n+                          .useDlq(useDlqCheck(config))\n+                          .useFlatSchema(useFlatSchema)\n+                          .build());\n+          rowsWithDlq.get(MAIN_TAG).setRowSchema(dataSchema);\n+\n+          if (useDlqCheck(config)) {\n+            rowsWithDlq.get(DLQ_TAG).apply(writeMessagesToDlq());\n+          }\n+\n+          return rowsWithDlq.get(MAIN_TAG);\n+        }\n+      };\n+    }\n+\n+    @Override\n+    public PTransform<PCollection<Row>, POutput> buildWriter() {\n+      if (!useFlatSchema) {\n+        throw new UnsupportedOperationException(\n+            \"Writing to a Pubsub topic is only supported for flattened schemas\");\n+      }\n+\n+      return new PTransform<PCollection<Row>, POutput>() {\n+        @Override\n+        public POutput expand(PCollection<Row> input) {\n+          return input\n+              .apply(RowToPubsubMessage.fromTableConfig(config, useFlatSchema))\n+              .apply(createPubsubMessageWrite());\n+        }\n+      };\n+    }\n+\n+    private PubsubIO.Read<PubsubMessage> readMessagesWithAttributes() {\n+      PubsubIO.Read<PubsubMessage> read = PubsubIO.readMessagesWithAttributes().fromTopic(location);\n+\n+      return useTimestampAttribute(config)\n+          ? read.withTimestampAttribute(config.getValue(\"timestampAttributeKey\"))\n+          : read;\n+    }\n+\n+    private PubsubIO.Write<PubsubMessage> createPubsubMessageWrite() {\n+      PubsubIO.Write<PubsubMessage> write = PubsubIO.writeMessages().to(location);\n+      if (useTimestampAttribute(config)) {\n+        write = write.withTimestampAttribute(config.getValue(\"timestampAttributeKey\"));\n+      }\n+      return write;\n+    }\n+\n+    private PubsubIO.Write<PubsubMessage> writeMessagesToDlq() {\n+      PubsubIO.Write<PubsubMessage> write =\n+          PubsubIO.writeMessages().to(config.getString(\"deadLetterQueue\"));\n+\n+      return useTimestampAttribute(config)\n+          ? write.withTimestampAttribute(config.getString(\"timestampAttributeKey\"))\n+          : write;\n+    }\n+\n+    private boolean useDlqCheck(Row config) {\n+      return config.getValue(\"deadLetterQueue\") != null;\n+    }\n+\n+    private boolean useTimestampAttribute(Row config) {\n+      return config.getValue(\"timestampAttributeKey\") != null;\n+    }\n+\n+    private boolean definesAttributeAndPayload(Schema schema) {\n+      return fieldPresent(\n+              schema, ATTRIBUTES_FIELD, Schema.FieldType.map(VARCHAR.withNullable(false), VARCHAR))\n+          && (schema.hasField(PAYLOAD_FIELD)\n+              && ROW.equals(schema.getField(PAYLOAD_FIELD).getType().getTypeName()));\n+    }\n+\n+    private static boolean fieldPresent(\n+        Schema schema, String field, Schema.FieldType expectedType) {\n+      return schema.hasField(field)\n+          && expectedType.equivalent(\n+              schema.getField(field).getType(), Schema.EquivalenceNullablePolicy.IGNORE);\n+    }\n+  }\n+\n+  /**\n+   * A {@link PTransform} to convert {@link Row} to {@link PubsubMessage} with JSON payload.\n+   *\n+   * <p>Currently only supports writing a flat schema into a JSON payload. This means that all Row\n+   * field values are written to the {@link PubsubMessage} JSON payload, except for {@code\n+   * event_timestamp}, which is either ignored or written to the message attributes, depending on\n+   * whether config.getValue(\"timestampAttributeKey\") is set.\n+   */\n+  private static class RowToPubsubMessage\n+      extends PTransform<PCollection<Row>, PCollection<PubsubMessage>> {\n+    private final Row config;\n+\n+    private RowToPubsubMessage(Row config, Boolean useFlatSchema) {\n+      checkArgument(useFlatSchema, \"RowToPubsubMessage is only supported for flattened schemas.\");\n+\n+      this.config = config;\n+    }\n+\n+    public static RowToPubsubMessage fromTableConfig(Row config, Boolean useFlatSchema) {", "originalCommit": "0b1804967423a7d35cdbe99261133e44279bd5a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NzM4MQ==", "url": "https://github.com/apache/beam/pull/12090#discussion_r446587381", "bodyText": "This constructor can just take 2 booleans instead (useTimestampAttribute and useFlatSchema), and the duplicate useTimestampAttribute() function at the end of the file can be removed.", "author": "robinyqiu", "createdAt": "2020-06-28T01:34:15Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubSchemaCapableIOProvider.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.pubsub;\n+\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.ATTRIBUTES_FIELD;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.DLQ_TAG;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.MAIN_TAG;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.PAYLOAD_FIELD;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.TIMESTAMP_FIELD;\n+import static org.apache.beam.sdk.schemas.Schema.TypeName.ROW;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+\n+import com.google.auto.service.AutoService;\n+import java.io.Serializable;\n+import java.nio.charset.StandardCharsets;\n+import org.apache.beam.sdk.annotations.Internal;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.schemas.Schema.FieldType;\n+import org.apache.beam.sdk.schemas.io.InvalidConfigurationException;\n+import org.apache.beam.sdk.schemas.io.SchemaCapableIOProvider;\n+import org.apache.beam.sdk.schemas.io.SchemaIO;\n+import org.apache.beam.sdk.schemas.transforms.DropFields;\n+import org.apache.beam.sdk.transforms.MapElements;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ToJson;\n+import org.apache.beam.sdk.transforms.WithTimestamps;\n+import org.apache.beam.sdk.values.PBegin;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.sdk.values.TypeDescriptor;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * {@link org.apache.beam.sdk.schemas.io.SchemaCapableIOProvider} to create {@link PubsubSchemaIO}\n+ * that implements {@link org.apache.beam.sdk.schemas.io.SchemaIO}.\n+ */\n+@Internal\n+@AutoService(SchemaCapableIOProvider.class)\n+public class PubsubSchemaCapableIOProvider implements SchemaCapableIOProvider {\n+  public static final FieldType VARCHAR = FieldType.STRING;\n+  public static final FieldType TIMESTAMP = FieldType.DATETIME;\n+\n+  /** Returns an id that uniquely represents this IO. */\n+  @Override\n+  public String identifier() {\n+    return \"pubsub\";\n+  }\n+\n+  /**\n+   * Returns the expected schema of the configuration object. Note this is distinct from the schema\n+   * of the data source itself.\n+   */\n+  @Override\n+  public Schema configurationSchema() {\n+    return Schema.builder()\n+        .addNullableField(\"timestampAttributeKey\", FieldType.STRING)\n+        .addNullableField(\"deadLetterQueue\", FieldType.STRING)\n+        .build();\n+  }\n+\n+  /**\n+   * Produce a SchemaIO given a String representing the data's location, the schema of the data that\n+   * resides there, and some IO-specific configuration object.\n+   */\n+  @Override\n+  public PubsubSchemaIO from(String location, Row configuration, Schema dataSchema) {\n+    validateDlq(configuration.getValue(\"deadLetterQueue\"));\n+    validateEventTimestamp(dataSchema);\n+    return PubsubSchemaIO.withConfiguration(location, configuration, dataSchema);\n+  }\n+\n+  private void validateEventTimestamp(Schema schema) {\n+    if (!PubsubSchemaIO.fieldPresent(schema, TIMESTAMP_FIELD, TIMESTAMP)) {\n+      throw new InvalidConfigurationException(\n+          \"Unsupported schema specified for Pubsub source in CREATE TABLE.\"\n+              + \"CREATE TABLE for Pubsub topic must include at least 'event_timestamp' field of \"\n+              + \"type 'TIMESTAMP'\");\n+    }\n+  }\n+\n+  private void validateDlq(String deadLetterQueue) {\n+    if (deadLetterQueue != null && deadLetterQueue.isEmpty()) {\n+      throw new InvalidConfigurationException(\"Dead letter queue topic name is not specified\");\n+    }\n+  }\n+\n+  /** An abstraction to create schema aware IOs. */\n+  @Internal\n+  private static class PubsubSchemaIO implements SchemaIO, Serializable {\n+    protected final Row config;\n+    protected final Schema dataSchema;\n+    protected final String location;\n+    protected final Boolean useFlatSchema;\n+\n+    private PubsubSchemaIO(String location, Row config, Schema dataSchema) {\n+      this.config = config;\n+      this.dataSchema = dataSchema;\n+      this.location = location;\n+      this.useFlatSchema = !definesAttributeAndPayload(dataSchema);\n+    }\n+\n+    static PubsubSchemaIO withConfiguration(String location, Row config, Schema dataSchema) {\n+      return new PubsubSchemaIO(location, config, dataSchema);\n+    }\n+\n+    @Override\n+    public Schema schema() {\n+      return dataSchema;\n+    }\n+\n+    @Override\n+    public PTransform<PBegin, PCollection<Row>> buildReader() {\n+      return new PTransform<PBegin, PCollection<Row>>() {\n+        @Override\n+        public PCollection<Row> expand(PBegin begin) {\n+          PCollectionTuple rowsWithDlq =\n+              begin\n+                  .apply(\"ReadFromPubsub\", readMessagesWithAttributes())\n+                  .apply(\n+                      \"PubsubMessageToRow\",\n+                      PubsubMessageToRow.builder()\n+                          .messageSchema(dataSchema)\n+                          .useDlq(useDlqCheck(config))\n+                          .useFlatSchema(useFlatSchema)\n+                          .build());\n+          rowsWithDlq.get(MAIN_TAG).setRowSchema(dataSchema);\n+\n+          if (useDlqCheck(config)) {\n+            rowsWithDlq.get(DLQ_TAG).apply(writeMessagesToDlq());\n+          }\n+\n+          return rowsWithDlq.get(MAIN_TAG);\n+        }\n+      };\n+    }\n+\n+    @Override\n+    public PTransform<PCollection<Row>, POutput> buildWriter() {\n+      if (!useFlatSchema) {\n+        throw new UnsupportedOperationException(\n+            \"Writing to a Pubsub topic is only supported for flattened schemas\");\n+      }\n+\n+      return new PTransform<PCollection<Row>, POutput>() {\n+        @Override\n+        public POutput expand(PCollection<Row> input) {\n+          return input\n+              .apply(RowToPubsubMessage.fromTableConfig(config, useFlatSchema))\n+              .apply(createPubsubMessageWrite());\n+        }\n+      };\n+    }\n+\n+    private PubsubIO.Read<PubsubMessage> readMessagesWithAttributes() {\n+      PubsubIO.Read<PubsubMessage> read = PubsubIO.readMessagesWithAttributes().fromTopic(location);\n+\n+      return useTimestampAttribute(config)\n+          ? read.withTimestampAttribute(config.getValue(\"timestampAttributeKey\"))\n+          : read;\n+    }\n+\n+    private PubsubIO.Write<PubsubMessage> createPubsubMessageWrite() {\n+      PubsubIO.Write<PubsubMessage> write = PubsubIO.writeMessages().to(location);\n+      if (useTimestampAttribute(config)) {\n+        write = write.withTimestampAttribute(config.getValue(\"timestampAttributeKey\"));\n+      }\n+      return write;\n+    }\n+\n+    private PubsubIO.Write<PubsubMessage> writeMessagesToDlq() {\n+      PubsubIO.Write<PubsubMessage> write =\n+          PubsubIO.writeMessages().to(config.getString(\"deadLetterQueue\"));\n+\n+      return useTimestampAttribute(config)\n+          ? write.withTimestampAttribute(config.getString(\"timestampAttributeKey\"))\n+          : write;\n+    }\n+\n+    private boolean useDlqCheck(Row config) {\n+      return config.getValue(\"deadLetterQueue\") != null;\n+    }\n+\n+    private boolean useTimestampAttribute(Row config) {\n+      return config.getValue(\"timestampAttributeKey\") != null;\n+    }\n+\n+    private boolean definesAttributeAndPayload(Schema schema) {\n+      return fieldPresent(\n+              schema, ATTRIBUTES_FIELD, Schema.FieldType.map(VARCHAR.withNullable(false), VARCHAR))\n+          && (schema.hasField(PAYLOAD_FIELD)\n+              && ROW.equals(schema.getField(PAYLOAD_FIELD).getType().getTypeName()));\n+    }\n+\n+    private static boolean fieldPresent(\n+        Schema schema, String field, Schema.FieldType expectedType) {\n+      return schema.hasField(field)\n+          && expectedType.equivalent(\n+              schema.getField(field).getType(), Schema.EquivalenceNullablePolicy.IGNORE);\n+    }\n+  }\n+\n+  /**\n+   * A {@link PTransform} to convert {@link Row} to {@link PubsubMessage} with JSON payload.\n+   *\n+   * <p>Currently only supports writing a flat schema into a JSON payload. This means that all Row\n+   * field values are written to the {@link PubsubMessage} JSON payload, except for {@code\n+   * event_timestamp}, which is either ignored or written to the message attributes, depending on\n+   * whether config.getValue(\"timestampAttributeKey\") is set.\n+   */\n+  private static class RowToPubsubMessage\n+      extends PTransform<PCollection<Row>, PCollection<PubsubMessage>> {\n+    private final Row config;\n+\n+    private RowToPubsubMessage(Row config, Boolean useFlatSchema) {", "originalCommit": "0b1804967423a7d35cdbe99261133e44279bd5a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NzQ1Nw==", "url": "https://github.com/apache/beam/pull/12090#discussion_r446587457", "bodyText": "Consider defining a constant for event_timestamp?", "author": "robinyqiu", "createdAt": "2020-06-28T01:35:11Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubSchemaCapableIOProvider.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.pubsub;\n+\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.ATTRIBUTES_FIELD;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.DLQ_TAG;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.MAIN_TAG;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.PAYLOAD_FIELD;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.TIMESTAMP_FIELD;\n+import static org.apache.beam.sdk.schemas.Schema.TypeName.ROW;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+\n+import com.google.auto.service.AutoService;\n+import java.io.Serializable;\n+import java.nio.charset.StandardCharsets;\n+import org.apache.beam.sdk.annotations.Internal;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.schemas.Schema.FieldType;\n+import org.apache.beam.sdk.schemas.io.InvalidConfigurationException;\n+import org.apache.beam.sdk.schemas.io.SchemaCapableIOProvider;\n+import org.apache.beam.sdk.schemas.io.SchemaIO;\n+import org.apache.beam.sdk.schemas.transforms.DropFields;\n+import org.apache.beam.sdk.transforms.MapElements;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ToJson;\n+import org.apache.beam.sdk.transforms.WithTimestamps;\n+import org.apache.beam.sdk.values.PBegin;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.sdk.values.TypeDescriptor;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * {@link org.apache.beam.sdk.schemas.io.SchemaCapableIOProvider} to create {@link PubsubSchemaIO}\n+ * that implements {@link org.apache.beam.sdk.schemas.io.SchemaIO}.\n+ */\n+@Internal\n+@AutoService(SchemaCapableIOProvider.class)\n+public class PubsubSchemaCapableIOProvider implements SchemaCapableIOProvider {\n+  public static final FieldType VARCHAR = FieldType.STRING;\n+  public static final FieldType TIMESTAMP = FieldType.DATETIME;\n+\n+  /** Returns an id that uniquely represents this IO. */\n+  @Override\n+  public String identifier() {\n+    return \"pubsub\";\n+  }\n+\n+  /**\n+   * Returns the expected schema of the configuration object. Note this is distinct from the schema\n+   * of the data source itself.\n+   */\n+  @Override\n+  public Schema configurationSchema() {\n+    return Schema.builder()\n+        .addNullableField(\"timestampAttributeKey\", FieldType.STRING)\n+        .addNullableField(\"deadLetterQueue\", FieldType.STRING)\n+        .build();\n+  }\n+\n+  /**\n+   * Produce a SchemaIO given a String representing the data's location, the schema of the data that\n+   * resides there, and some IO-specific configuration object.\n+   */\n+  @Override\n+  public PubsubSchemaIO from(String location, Row configuration, Schema dataSchema) {\n+    validateDlq(configuration.getValue(\"deadLetterQueue\"));\n+    validateEventTimestamp(dataSchema);\n+    return PubsubSchemaIO.withConfiguration(location, configuration, dataSchema);\n+  }\n+\n+  private void validateEventTimestamp(Schema schema) {\n+    if (!PubsubSchemaIO.fieldPresent(schema, TIMESTAMP_FIELD, TIMESTAMP)) {\n+      throw new InvalidConfigurationException(\n+          \"Unsupported schema specified for Pubsub source in CREATE TABLE.\"\n+              + \"CREATE TABLE for Pubsub topic must include at least 'event_timestamp' field of \"\n+              + \"type 'TIMESTAMP'\");\n+    }\n+  }\n+\n+  private void validateDlq(String deadLetterQueue) {\n+    if (deadLetterQueue != null && deadLetterQueue.isEmpty()) {\n+      throw new InvalidConfigurationException(\"Dead letter queue topic name is not specified\");\n+    }\n+  }\n+\n+  /** An abstraction to create schema aware IOs. */\n+  @Internal\n+  private static class PubsubSchemaIO implements SchemaIO, Serializable {\n+    protected final Row config;\n+    protected final Schema dataSchema;\n+    protected final String location;\n+    protected final Boolean useFlatSchema;\n+\n+    private PubsubSchemaIO(String location, Row config, Schema dataSchema) {\n+      this.config = config;\n+      this.dataSchema = dataSchema;\n+      this.location = location;\n+      this.useFlatSchema = !definesAttributeAndPayload(dataSchema);\n+    }\n+\n+    static PubsubSchemaIO withConfiguration(String location, Row config, Schema dataSchema) {\n+      return new PubsubSchemaIO(location, config, dataSchema);\n+    }\n+\n+    @Override\n+    public Schema schema() {\n+      return dataSchema;\n+    }\n+\n+    @Override\n+    public PTransform<PBegin, PCollection<Row>> buildReader() {\n+      return new PTransform<PBegin, PCollection<Row>>() {\n+        @Override\n+        public PCollection<Row> expand(PBegin begin) {\n+          PCollectionTuple rowsWithDlq =\n+              begin\n+                  .apply(\"ReadFromPubsub\", readMessagesWithAttributes())\n+                  .apply(\n+                      \"PubsubMessageToRow\",\n+                      PubsubMessageToRow.builder()\n+                          .messageSchema(dataSchema)\n+                          .useDlq(useDlqCheck(config))\n+                          .useFlatSchema(useFlatSchema)\n+                          .build());\n+          rowsWithDlq.get(MAIN_TAG).setRowSchema(dataSchema);\n+\n+          if (useDlqCheck(config)) {\n+            rowsWithDlq.get(DLQ_TAG).apply(writeMessagesToDlq());\n+          }\n+\n+          return rowsWithDlq.get(MAIN_TAG);\n+        }\n+      };\n+    }\n+\n+    @Override\n+    public PTransform<PCollection<Row>, POutput> buildWriter() {\n+      if (!useFlatSchema) {\n+        throw new UnsupportedOperationException(\n+            \"Writing to a Pubsub topic is only supported for flattened schemas\");\n+      }\n+\n+      return new PTransform<PCollection<Row>, POutput>() {\n+        @Override\n+        public POutput expand(PCollection<Row> input) {\n+          return input\n+              .apply(RowToPubsubMessage.fromTableConfig(config, useFlatSchema))\n+              .apply(createPubsubMessageWrite());\n+        }\n+      };\n+    }\n+\n+    private PubsubIO.Read<PubsubMessage> readMessagesWithAttributes() {\n+      PubsubIO.Read<PubsubMessage> read = PubsubIO.readMessagesWithAttributes().fromTopic(location);\n+\n+      return useTimestampAttribute(config)\n+          ? read.withTimestampAttribute(config.getValue(\"timestampAttributeKey\"))\n+          : read;\n+    }\n+\n+    private PubsubIO.Write<PubsubMessage> createPubsubMessageWrite() {\n+      PubsubIO.Write<PubsubMessage> write = PubsubIO.writeMessages().to(location);\n+      if (useTimestampAttribute(config)) {\n+        write = write.withTimestampAttribute(config.getValue(\"timestampAttributeKey\"));\n+      }\n+      return write;\n+    }\n+\n+    private PubsubIO.Write<PubsubMessage> writeMessagesToDlq() {\n+      PubsubIO.Write<PubsubMessage> write =\n+          PubsubIO.writeMessages().to(config.getString(\"deadLetterQueue\"));\n+\n+      return useTimestampAttribute(config)\n+          ? write.withTimestampAttribute(config.getString(\"timestampAttributeKey\"))\n+          : write;\n+    }\n+\n+    private boolean useDlqCheck(Row config) {\n+      return config.getValue(\"deadLetterQueue\") != null;\n+    }\n+\n+    private boolean useTimestampAttribute(Row config) {\n+      return config.getValue(\"timestampAttributeKey\") != null;\n+    }\n+\n+    private boolean definesAttributeAndPayload(Schema schema) {\n+      return fieldPresent(\n+              schema, ATTRIBUTES_FIELD, Schema.FieldType.map(VARCHAR.withNullable(false), VARCHAR))\n+          && (schema.hasField(PAYLOAD_FIELD)\n+              && ROW.equals(schema.getField(PAYLOAD_FIELD).getType().getTypeName()));\n+    }\n+\n+    private static boolean fieldPresent(\n+        Schema schema, String field, Schema.FieldType expectedType) {\n+      return schema.hasField(field)\n+          && expectedType.equivalent(\n+              schema.getField(field).getType(), Schema.EquivalenceNullablePolicy.IGNORE);\n+    }\n+  }\n+\n+  /**\n+   * A {@link PTransform} to convert {@link Row} to {@link PubsubMessage} with JSON payload.\n+   *\n+   * <p>Currently only supports writing a flat schema into a JSON payload. This means that all Row\n+   * field values are written to the {@link PubsubMessage} JSON payload, except for {@code\n+   * event_timestamp}, which is either ignored or written to the message attributes, depending on\n+   * whether config.getValue(\"timestampAttributeKey\") is set.\n+   */\n+  private static class RowToPubsubMessage\n+      extends PTransform<PCollection<Row>, PCollection<PubsubMessage>> {\n+    private final Row config;\n+\n+    private RowToPubsubMessage(Row config, Boolean useFlatSchema) {\n+      checkArgument(useFlatSchema, \"RowToPubsubMessage is only supported for flattened schemas.\");\n+\n+      this.config = config;\n+    }\n+\n+    public static RowToPubsubMessage fromTableConfig(Row config, Boolean useFlatSchema) {\n+      return new RowToPubsubMessage(config, useFlatSchema);\n+    }\n+\n+    @Override\n+    public PCollection<PubsubMessage> expand(PCollection<Row> input) {\n+      PCollection<Row> withTimestamp =\n+          (useTimestampAttribute(config))\n+              ? input.apply(\n+                  WithTimestamps.of((row) -> row.getDateTime(\"event_timestamp\").toInstant()))", "originalCommit": "0b1804967423a7d35cdbe99261133e44279bd5a3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NzUzMw==", "url": "https://github.com/apache/beam/pull/12090#discussion_r446587533", "bodyText": "Consider moving PubsubMessageToRow into this file as a inner class as well?", "author": "robinyqiu", "createdAt": "2020-06-28T01:36:31Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubSchemaCapableIOProvider.java", "diffHunk": "@@ -0,0 +1,264 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.pubsub;\n+\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.ATTRIBUTES_FIELD;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.DLQ_TAG;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.MAIN_TAG;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.PAYLOAD_FIELD;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.TIMESTAMP_FIELD;\n+import static org.apache.beam.sdk.schemas.Schema.TypeName.ROW;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+\n+import com.google.auto.service.AutoService;\n+import java.io.Serializable;\n+import java.nio.charset.StandardCharsets;\n+import org.apache.beam.sdk.annotations.Internal;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.schemas.Schema.FieldType;\n+import org.apache.beam.sdk.schemas.io.InvalidConfigurationException;\n+import org.apache.beam.sdk.schemas.io.SchemaCapableIOProvider;\n+import org.apache.beam.sdk.schemas.io.SchemaIO;\n+import org.apache.beam.sdk.schemas.transforms.DropFields;\n+import org.apache.beam.sdk.transforms.MapElements;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ToJson;\n+import org.apache.beam.sdk.transforms.WithTimestamps;\n+import org.apache.beam.sdk.values.PBegin;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.sdk.values.TypeDescriptor;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * {@link org.apache.beam.sdk.schemas.io.SchemaCapableIOProvider} to create {@link PubsubSchemaIO}\n+ * that implements {@link org.apache.beam.sdk.schemas.io.SchemaIO}.\n+ */\n+@Internal\n+@AutoService(SchemaCapableIOProvider.class)\n+public class PubsubSchemaCapableIOProvider implements SchemaCapableIOProvider {\n+  public static final FieldType VARCHAR = FieldType.STRING;\n+  public static final FieldType TIMESTAMP = FieldType.DATETIME;\n+\n+  /** Returns an id that uniquely represents this IO. */\n+  @Override\n+  public String identifier() {\n+    return \"pubsub\";\n+  }\n+\n+  /**\n+   * Returns the expected schema of the configuration object. Note this is distinct from the schema\n+   * of the data source itself.\n+   */\n+  @Override\n+  public Schema configurationSchema() {\n+    return Schema.builder()\n+        .addNullableField(\"timestampAttributeKey\", FieldType.STRING)\n+        .addNullableField(\"deadLetterQueue\", FieldType.STRING)\n+        .build();\n+  }\n+\n+  /**\n+   * Produce a SchemaIO given a String representing the data's location, the schema of the data that\n+   * resides there, and some IO-specific configuration object.\n+   */\n+  @Override\n+  public PubsubSchemaIO from(String location, Row configuration, Schema dataSchema) {\n+    validateDlq(configuration.getValue(\"deadLetterQueue\"));\n+    validateEventTimestamp(dataSchema);\n+    return PubsubSchemaIO.withConfiguration(location, configuration, dataSchema);\n+  }\n+\n+  private void validateEventTimestamp(Schema schema) {\n+    if (!PubsubSchemaIO.fieldPresent(schema, TIMESTAMP_FIELD, TIMESTAMP)) {\n+      throw new InvalidConfigurationException(\n+          \"Unsupported schema specified for Pubsub source in CREATE TABLE.\"\n+              + \"CREATE TABLE for Pubsub topic must include at least 'event_timestamp' field of \"\n+              + \"type 'TIMESTAMP'\");\n+    }\n+  }\n+\n+  private void validateDlq(String deadLetterQueue) {\n+    if (deadLetterQueue != null && deadLetterQueue.isEmpty()) {\n+      throw new InvalidConfigurationException(\"Dead letter queue topic name is not specified\");\n+    }\n+  }\n+\n+  /** An abstraction to create schema aware IOs. */\n+  @Internal\n+  private static class PubsubSchemaIO implements SchemaIO, Serializable {\n+    protected final Row config;\n+    protected final Schema dataSchema;\n+    protected final String location;\n+    protected final Boolean useFlatSchema;\n+\n+    private PubsubSchemaIO(String location, Row config, Schema dataSchema) {\n+      this.config = config;\n+      this.dataSchema = dataSchema;\n+      this.location = location;\n+      this.useFlatSchema = !definesAttributeAndPayload(dataSchema);\n+    }\n+\n+    static PubsubSchemaIO withConfiguration(String location, Row config, Schema dataSchema) {\n+      return new PubsubSchemaIO(location, config, dataSchema);\n+    }\n+\n+    @Override\n+    public Schema schema() {\n+      return dataSchema;\n+    }\n+\n+    @Override\n+    public PTransform<PBegin, PCollection<Row>> buildReader() {\n+      return new PTransform<PBegin, PCollection<Row>>() {\n+        @Override\n+        public PCollection<Row> expand(PBegin begin) {\n+          PCollectionTuple rowsWithDlq =\n+              begin\n+                  .apply(\"ReadFromPubsub\", readMessagesWithAttributes())\n+                  .apply(\n+                      \"PubsubMessageToRow\",\n+                      PubsubMessageToRow.builder()\n+                          .messageSchema(dataSchema)\n+                          .useDlq(useDlqCheck(config))\n+                          .useFlatSchema(useFlatSchema)\n+                          .build());\n+          rowsWithDlq.get(MAIN_TAG).setRowSchema(dataSchema);\n+\n+          if (useDlqCheck(config)) {\n+            rowsWithDlq.get(DLQ_TAG).apply(writeMessagesToDlq());\n+          }\n+\n+          return rowsWithDlq.get(MAIN_TAG);\n+        }\n+      };\n+    }\n+\n+    @Override\n+    public PTransform<PCollection<Row>, POutput> buildWriter() {\n+      if (!useFlatSchema) {\n+        throw new UnsupportedOperationException(\n+            \"Writing to a Pubsub topic is only supported for flattened schemas\");\n+      }\n+\n+      return new PTransform<PCollection<Row>, POutput>() {\n+        @Override\n+        public POutput expand(PCollection<Row> input) {\n+          return input\n+              .apply(RowToPubsubMessage.fromTableConfig(config, useFlatSchema))\n+              .apply(createPubsubMessageWrite());\n+        }\n+      };\n+    }\n+\n+    private PubsubIO.Read<PubsubMessage> readMessagesWithAttributes() {\n+      PubsubIO.Read<PubsubMessage> read = PubsubIO.readMessagesWithAttributes().fromTopic(location);\n+\n+      return useTimestampAttribute(config)\n+          ? read.withTimestampAttribute(config.getValue(\"timestampAttributeKey\"))\n+          : read;\n+    }\n+\n+    private PubsubIO.Write<PubsubMessage> createPubsubMessageWrite() {\n+      PubsubIO.Write<PubsubMessage> write = PubsubIO.writeMessages().to(location);\n+      if (useTimestampAttribute(config)) {\n+        write = write.withTimestampAttribute(config.getValue(\"timestampAttributeKey\"));\n+      }\n+      return write;\n+    }\n+\n+    private PubsubIO.Write<PubsubMessage> writeMessagesToDlq() {\n+      PubsubIO.Write<PubsubMessage> write =\n+          PubsubIO.writeMessages().to(config.getString(\"deadLetterQueue\"));\n+\n+      return useTimestampAttribute(config)\n+          ? write.withTimestampAttribute(config.getString(\"timestampAttributeKey\"))\n+          : write;\n+    }\n+\n+    private boolean useDlqCheck(Row config) {\n+      return config.getValue(\"deadLetterQueue\") != null;\n+    }\n+\n+    private boolean useTimestampAttribute(Row config) {\n+      return config.getValue(\"timestampAttributeKey\") != null;\n+    }\n+\n+    private boolean definesAttributeAndPayload(Schema schema) {\n+      return fieldPresent(\n+              schema, ATTRIBUTES_FIELD, Schema.FieldType.map(VARCHAR.withNullable(false), VARCHAR))\n+          && (schema.hasField(PAYLOAD_FIELD)\n+              && ROW.equals(schema.getField(PAYLOAD_FIELD).getType().getTypeName()));\n+    }\n+\n+    private static boolean fieldPresent(\n+        Schema schema, String field, Schema.FieldType expectedType) {\n+      return schema.hasField(field)\n+          && expectedType.equivalent(\n+              schema.getField(field).getType(), Schema.EquivalenceNullablePolicy.IGNORE);\n+    }\n+  }\n+\n+  /**\n+   * A {@link PTransform} to convert {@link Row} to {@link PubsubMessage} with JSON payload.\n+   *\n+   * <p>Currently only supports writing a flat schema into a JSON payload. This means that all Row\n+   * field values are written to the {@link PubsubMessage} JSON payload, except for {@code\n+   * event_timestamp}, which is either ignored or written to the message attributes, depending on\n+   * whether config.getValue(\"timestampAttributeKey\") is set.\n+   */\n+  private static class RowToPubsubMessage", "originalCommit": "0b1804967423a7d35cdbe99261133e44279bd5a3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzA3ODcyNg==", "url": "https://github.com/apache/beam/pull/12090#discussion_r447078726", "bodyText": "Scott and I actually discussed this offline a little bit. I suggested keeping it separate (but package-private) so that we could continue to test it separately with PubsubMessageToRowTest. I'm open to moving it here for symmetry though.", "author": "TheNeuralBit", "createdAt": "2020-06-29T15:57:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NzUzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzE1MDQwMA==", "url": "https://github.com/apache/beam/pull/12090#discussion_r447150400", "bodyText": "Make sense. Then maybe moving this class out as package-private?", "author": "robinyqiu", "createdAt": "2020-06-29T17:55:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NzUzMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY3OTQ4MA==", "url": "https://github.com/apache/beam/pull/12090#discussion_r448679480", "bodyText": "Yeah I think it makes sense to keep this separate and package-private, it will minimize the diff as well since it's just a file  rename.\nSorry for the churn Scott, could you move this back into it's own class?", "author": "TheNeuralBit", "createdAt": "2020-07-02T00:13:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjU4NzUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzMyNjAyNQ==", "url": "https://github.com/apache/beam/pull/12090#discussion_r447326025", "bodyText": "This should have a meaningful message like \"Failed to re-parse TBLPROPERTIES JSON\", and it would be good to include the JSON string that caused the issue: tableProperties.toString()", "author": "TheNeuralBit", "createdAt": "2020-06-29T23:58:46Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/pubsub/PubsubJsonTableProvider.java", "diffHunk": "@@ -54,125 +52,27 @@ public String getTableType() {\n   }\n \n   @Override\n-  public BeamSqlTable buildBeamSqlTable(Table tableDefintion) {\n-    JSONObject tableProperties = tableDefintion.getProperties();\n-    String timestampAttributeKey = tableProperties.getString(\"timestampAttributeKey\");\n-    String deadLetterQueue = tableProperties.getString(\"deadLetterQueue\");\n-    validateDlq(deadLetterQueue);\n-\n-    Schema schema = tableDefintion.getSchema();\n-    validateEventTimestamp(schema);\n-\n-    PubsubIOTableConfiguration config =\n-        PubsubIOTableConfiguration.builder()\n-            .setSchema(schema)\n-            .setTimestampAttribute(timestampAttributeKey)\n-            .setDeadLetterQueue(deadLetterQueue)\n-            .setTopic(tableDefintion.getLocation())\n-            .setUseFlatSchema(!definesAttributeAndPayload(schema))\n-            .build();\n-\n-    return PubsubIOJsonTable.withConfiguration(config);\n-  }\n-\n-  private void validateEventTimestamp(Schema schema) {\n-    if (!fieldPresent(schema, TIMESTAMP_FIELD, TIMESTAMP)) {\n-      throw new InvalidTableException(\n-          \"Unsupported schema specified for Pubsub source in CREATE TABLE.\"\n-              + \"CREATE TABLE for Pubsub topic must include at least 'event_timestamp' field of \"\n-              + \"type 'TIMESTAMP'\");\n-    }\n-  }\n-\n-  private boolean definesAttributeAndPayload(Schema schema) {\n-    return fieldPresent(\n-            schema, ATTRIBUTES_FIELD, Schema.FieldType.map(VARCHAR.withNullable(false), VARCHAR))\n-        && (schema.hasField(PAYLOAD_FIELD)\n-            && ROW.equals(schema.getField(PAYLOAD_FIELD).getType().getTypeName()));\n-  }\n-\n-  private boolean fieldPresent(Schema schema, String field, Schema.FieldType expectedType) {\n-    return schema.hasField(field)\n-        && expectedType.equivalent(\n-            schema.getField(field).getType(), Schema.EquivalenceNullablePolicy.IGNORE);\n-  }\n-\n-  private void validateDlq(String deadLetterQueue) {\n-    if (deadLetterQueue != null && deadLetterQueue.isEmpty()) {\n-      throw new InvalidTableException(\"Dead letter queue topic name is not specified\");\n-    }\n-  }\n-\n-  @AutoValue\n-  public abstract static class PubsubIOTableConfiguration implements Serializable {\n-    public boolean useDlq() {\n-      return getDeadLetterQueue() != null;\n-    }\n-\n-    public boolean useTimestampAttribute() {\n-      return getTimestampAttribute() != null;\n-    }\n-\n-    /** Determines whether or not the messages should be represented with a flattened schema. */\n-    abstract boolean getUseFlatSchema();\n-\n-    /**\n-     * Optional attribute key of the Pubsub message from which to extract the event timestamp.\n-     *\n-     * <p>This attribute has to conform to the same requirements as in {@link\n-     * PubsubIO.Read.Builder#withTimestampAttribute}.\n-     *\n-     * <p>Short version: it has to be either millis since epoch or string in RFC 3339 format.\n-     *\n-     * <p>If the attribute is specified then event timestamps will be extracted from the specified\n-     * attribute. If it is not specified then message publish timestamp will be used.\n-     */\n-    @Nullable\n-    abstract String getTimestampAttribute();\n-\n-    /**\n-     * Optional topic path which will be used as a dead letter queue.\n-     *\n-     * <p>Messages that cannot be processed will be sent to this topic. If it is not specified then\n-     * exception will be thrown for errors during processing causing the pipeline to crash.\n-     */\n-    @Nullable\n-    abstract String getDeadLetterQueue();\n-\n-    /**\n-     * Pubsub topic name.\n-     *\n-     * <p>Topic is the only way to specify the Pubsub source. Explicitly specifying the subscription\n-     * is not supported at the moment. Subscriptions are automatically created (but not deleted).\n-     */\n-    abstract String getTopic();\n-\n-    /**\n-     * Table schema, describes Pubsub message schema.\n-     *\n-     * <p>If {@link #getUseFlatSchema()} is not set, schema must contain exactly fields\n-     * 'event_timestamp', 'attributes, and 'payload'. Else, it must contain just 'event_timestamp'.\n-     * See {@linkA PubsubMessageToRow} for details.\n-     */\n-    public abstract Schema getSchema();\n-\n-    static Builder builder() {\n-      return new AutoValue_PubsubJsonTableProvider_PubsubIOTableConfiguration.Builder();\n-    }\n-\n-    @AutoValue.Builder\n-    abstract static class Builder {\n-      abstract Builder setUseFlatSchema(boolean useFlatSchema);\n-\n-      abstract Builder setSchema(Schema schema);\n-\n-      abstract Builder setTimestampAttribute(String timestampAttribute);\n-\n-      abstract Builder setDeadLetterQueue(String deadLetterQueue);\n-\n-      abstract Builder setTopic(String topic);\n-\n-      abstract PubsubIOTableConfiguration build();\n+  public BeamSqlTable buildBeamSqlTable(Table tableDefinition) {\n+    JSONObject tableProperties = tableDefinition.getProperties();\n+    PubsubSchemaCapableIOProvider ioProvider = new PubsubSchemaCapableIOProvider();\n+\n+    try {\n+      RowJsonDeserializer deserializer =\n+          RowJsonDeserializer.forSchema(ioProvider.configurationSchema())\n+              .withMissingFieldBehavior(RowJsonDeserializer.MissingFieldBehavior.ALLOW_MISSING);\n+\n+      Row configurationRow =\n+          newObjectMapperWith(deserializer).readValue(tableProperties.toString(), Row.class);\n+\n+      SchemaIO pubsubSchemaIO =\n+          ioProvider.from(\n+              tableDefinition.getLocation(), configurationRow, tableDefinition.getSchema());\n+\n+      return PubsubIOJsonTable.fromSchemaIO(pubsubSchemaIO);\n+    } catch (InvalidConfigurationException | InvalidSchemaException e) {\n+      throw new InvalidTableException(e.getMessage());\n+    } catch (JsonProcessingException e) {\n+      throw new AssertionError();", "originalCommit": "75f57c811b95325350f2bd278614759ede414a29", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "88989e9dfa196d2adb519b865816c1c29b18db6d", "url": "https://github.com/apache/beam/commit/88989e9dfa196d2adb519b865816c1c29b18db6d", "message": "Added schema aware abstraction SchemaIO and implemented for pubsub", "committedDate": "2020-07-01T16:39:36Z", "type": "commit"}, {"oid": "577e490e509620d5202a17216a044c1f8bc886a0", "url": "https://github.com/apache/beam/commit/577e490e509620d5202a17216a044c1f8bc886a0", "message": "pubsubSchemaCapableIOProvider subclasses rather than external classes", "committedDate": "2020-07-01T16:39:36Z", "type": "commit"}, {"oid": "fbad1e4ea46ccaada5e409125eb71ec8acf1e88e", "url": "https://github.com/apache/beam/commit/fbad1e4ea46ccaada5e409125eb71ec8acf1e88e", "message": "spotless and checkstyle", "committedDate": "2020-07-01T16:39:37Z", "type": "commit"}, {"oid": "ae0b0f904ea6572d33d040b81d4b430bfca60529", "url": "https://github.com/apache/beam/commit/ae0b0f904ea6572d33d040b81d4b430bfca60529", "message": "Added documentation for SchemaIO interfaces", "committedDate": "2020-07-01T16:40:10Z", "type": "commit"}, {"oid": "8f665fbaf6483be95952b4605808472dd6de0dcc", "url": "https://github.com/apache/beam/commit/8f665fbaf6483be95952b4605808472dd6de0dcc", "message": "Removed hardcoded configuration details from PubsubJsonTableProvider", "committedDate": "2020-07-01T16:40:28Z", "type": "commit"}, {"oid": "ba6464fbe5175e7900cfc263e52067f1a46290a2", "url": "https://github.com/apache/beam/commit/ba6464fbe5175e7900cfc263e52067f1a46290a2", "message": "Added description to PubsubJsonTableProvider JsonProcessingException", "committedDate": "2020-07-01T16:40:29Z", "type": "commit"}, {"oid": "ba6464fbe5175e7900cfc263e52067f1a46290a2", "url": "https://github.com/apache/beam/commit/ba6464fbe5175e7900cfc263e52067f1a46290a2", "message": "Added description to PubsubJsonTableProvider JsonProcessingException", "committedDate": "2020-07-01T16:40:29Z", "type": "forcePushed"}, {"oid": "6ac8bf56fd2b229d2e7ad62b5594c8d754c36bc0", "url": "https://github.com/apache/beam/commit/6ac8bf56fd2b229d2e7ad62b5594c8d754c36bc0", "message": "Resolved RowJsonDeserializer conflicts", "committedDate": "2020-07-01T19:25:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY3NTQzNw==", "url": "https://github.com/apache/beam/pull/12090#discussion_r448675437", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /** Unit tests for {@link org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow}. */\n          \n          \n            \n            /** Unit tests for {@link PubsubMessageToRow}. */\n          \n      \n    \n    \n  \n\nnit: IntelliJ probably did this automatically when PubsubMessageToRow was temporarily in a different package. Just the class name should be fine.", "author": "TheNeuralBit", "createdAt": "2020-07-01T23:58:08Z", "path": "sdks/java/extensions/sql/src/test/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubMessageToRowTest.java", "diffHunk": "@@ -48,7 +47,7 @@\n import org.junit.Rule;\n import org.junit.Test;\n \n-/** Unit tests for {@link PubsubMessageToRow}. */\n+/** Unit tests for {@link org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow}. */", "originalCommit": "6ac8bf56fd2b229d2e7ad62b5594c8d754c36bc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY3Njg1Mg==", "url": "https://github.com/apache/beam/pull/12090#discussion_r448676852", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * {@link SchemaCapableIOProvider} to create {@link PubsubSchemaIO} that implements {@link\n          \n          \n            \n             * SchemaIO}.\n          \n          \n            \n             * An implementation of {@link SchemaCapableIOProvider} for reading and writing JSON payloads\n          \n          \n            \n             * with {@link PubsubIO}.", "author": "TheNeuralBit", "createdAt": "2020-07-02T00:03:28Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubSchemaCapableIOProvider.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.pubsub;\n+\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.ATTRIBUTES_FIELD;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.DLQ_TAG;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.MAIN_TAG;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.PAYLOAD_FIELD;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.TIMESTAMP_FIELD;\n+import static org.apache.beam.sdk.schemas.Schema.TypeName.ROW;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+\n+import com.google.auto.service.AutoService;\n+import java.io.Serializable;\n+import java.nio.charset.StandardCharsets;\n+import org.apache.beam.sdk.annotations.Internal;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.schemas.Schema.FieldType;\n+import org.apache.beam.sdk.schemas.io.InvalidConfigurationException;\n+import org.apache.beam.sdk.schemas.io.InvalidSchemaException;\n+import org.apache.beam.sdk.schemas.io.SchemaCapableIOProvider;\n+import org.apache.beam.sdk.schemas.io.SchemaIO;\n+import org.apache.beam.sdk.schemas.transforms.DropFields;\n+import org.apache.beam.sdk.transforms.MapElements;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ToJson;\n+import org.apache.beam.sdk.transforms.WithTimestamps;\n+import org.apache.beam.sdk.values.PBegin;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.sdk.values.TypeDescriptor;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * {@link SchemaCapableIOProvider} to create {@link PubsubSchemaIO} that implements {@link\n+ * SchemaIO}.", "originalCommit": "6ac8bf56fd2b229d2e7ad62b5594c8d754c36bc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY4MjI0OA==", "url": "https://github.com/apache/beam/pull/12090#discussion_r448682248", "bodyText": "This class doesn't actually have anything specific to pubsub in it anymore, it's just a generic wrapper that could be used for any SchemaIO. Could you rename it to something like SchemaIOTable and remove references to pubsub?\nThe javadoc for this class should also be removed and incorporate into the one for PubsubSchemaCapableIOProvider (but without the specific examples using SQL syntax).", "author": "TheNeuralBit", "createdAt": "2020-07-02T00:24:04Z", "path": "sdks/java/extensions/sql/src/main/java/org/apache/beam/sdk/extensions/sql/meta/provider/pubsub/PubsubIOJsonTable.java", "diffHunk": "@@ -122,14 +115,14 @@\n @Experimental\n class PubsubIOJsonTable extends BaseBeamTable implements Serializable {", "originalCommit": "6ac8bf56fd2b229d2e7ad62b5594c8d754c36bc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDM4OTE3Ng==", "url": "https://github.com/apache/beam/pull/12090#discussion_r450389176", "bodyText": "Making the provider and table classes generic is being worked on in another branch. The renaming corrections will be part of a separate PR.", "author": "sclukas77", "createdAt": "2020-07-06T17:57:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY4MjI0OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUzNjAyNg==", "url": "https://github.com/apache/beam/pull/12090#discussion_r450536026", "bodyText": "Got it, SGTM. It'll probably be easier to verify when there's more than one implementation anyway :)", "author": "TheNeuralBit", "createdAt": "2020-07-06T23:48:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY4MjI0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY4NDk1MA==", "url": "https://github.com/apache/beam/pull/12090#discussion_r448684950", "bodyText": "PubsubSchemaIO.useFlatSchema is an implementation detail, this should instead be phrased like \"The data schema passed to from must take one of two forms: the \"nested\" style or the \"flat\" style ... \"\nThe javadoc for PubsubIOJsonTable has some good language about this that you could draw from.", "author": "TheNeuralBit", "createdAt": "2020-07-02T00:34:46Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubSchemaCapableIOProvider.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.pubsub;\n+\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.ATTRIBUTES_FIELD;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.DLQ_TAG;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.MAIN_TAG;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.PAYLOAD_FIELD;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.TIMESTAMP_FIELD;\n+import static org.apache.beam.sdk.schemas.Schema.TypeName.ROW;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+\n+import com.google.auto.service.AutoService;\n+import java.io.Serializable;\n+import java.nio.charset.StandardCharsets;\n+import org.apache.beam.sdk.annotations.Internal;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.schemas.Schema.FieldType;\n+import org.apache.beam.sdk.schemas.io.InvalidConfigurationException;\n+import org.apache.beam.sdk.schemas.io.InvalidSchemaException;\n+import org.apache.beam.sdk.schemas.io.SchemaCapableIOProvider;\n+import org.apache.beam.sdk.schemas.io.SchemaIO;\n+import org.apache.beam.sdk.schemas.transforms.DropFields;\n+import org.apache.beam.sdk.transforms.MapElements;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ToJson;\n+import org.apache.beam.sdk.transforms.WithTimestamps;\n+import org.apache.beam.sdk.values.PBegin;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.sdk.values.TypeDescriptor;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * {@link SchemaCapableIOProvider} to create {@link PubsubSchemaIO} that implements {@link\n+ * SchemaIO}.\n+ *\n+ * <p>If useFlatSchema of {@link PubsubSchemaIO} is not set, schema must contain exactly fields\n+ * 'event_timestamp', 'attributes, and 'payload'. Else, it must contain just 'event_timestamp'. See\n+ * {@link PubsubMessageToRow} for details.", "originalCommit": "6ac8bf56fd2b229d2e7ad62b5594c8d754c36bc0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY4NTkzOQ==", "url": "https://github.com/apache/beam/pull/12090#discussion_r448685939", "bodyText": "This feels a bit fractured now, It might help to give it a little structure with some headers and/or bulleted lists like we do in BigQueryIO (rendered).\nMaybe something like:\n<h2>Schema</h2>\n...\n<h2>Configuration</h2>\n...\n<h3>timestampAttributeKey</h3>\n...\n<h3>deadLetterQueueue</h3>\n...", "author": "TheNeuralBit", "createdAt": "2020-07-02T00:38:21Z", "path": "sdks/java/io/google-cloud-platform/src/main/java/org/apache/beam/sdk/io/gcp/pubsub/PubsubSchemaCapableIOProvider.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.io.gcp.pubsub;\n+\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.ATTRIBUTES_FIELD;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.DLQ_TAG;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.MAIN_TAG;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.PAYLOAD_FIELD;\n+import static org.apache.beam.sdk.io.gcp.pubsub.PubsubMessageToRow.TIMESTAMP_FIELD;\n+import static org.apache.beam.sdk.schemas.Schema.TypeName.ROW;\n+import static org.apache.beam.vendor.guava.v26_0_jre.com.google.common.base.Preconditions.checkArgument;\n+\n+import com.google.auto.service.AutoService;\n+import java.io.Serializable;\n+import java.nio.charset.StandardCharsets;\n+import org.apache.beam.sdk.annotations.Internal;\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.schemas.Schema.FieldType;\n+import org.apache.beam.sdk.schemas.io.InvalidConfigurationException;\n+import org.apache.beam.sdk.schemas.io.InvalidSchemaException;\n+import org.apache.beam.sdk.schemas.io.SchemaCapableIOProvider;\n+import org.apache.beam.sdk.schemas.io.SchemaIO;\n+import org.apache.beam.sdk.schemas.transforms.DropFields;\n+import org.apache.beam.sdk.transforms.MapElements;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.transforms.ToJson;\n+import org.apache.beam.sdk.transforms.WithTimestamps;\n+import org.apache.beam.sdk.values.PBegin;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.PCollectionTuple;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.Row;\n+import org.apache.beam.sdk.values.TypeDescriptor;\n+import org.apache.beam.vendor.guava.v26_0_jre.com.google.common.collect.ImmutableMap;\n+\n+/**\n+ * {@link SchemaCapableIOProvider} to create {@link PubsubSchemaIO} that implements {@link\n+ * SchemaIO}.\n+ *\n+ * <p>If useFlatSchema of {@link PubsubSchemaIO} is not set, schema must contain exactly fields\n+ * 'event_timestamp', 'attributes, and 'payload'. Else, it must contain just 'event_timestamp'. See\n+ * {@link PubsubMessageToRow} for details.\n+ *\n+ * <p>{@link #configurationSchema()} consists of two attributes, timestampAttributeKey and\n+ * deadLetterQueue.\n+ *\n+ * <p>timestampAttributeKey is an optional attribute key of the Pubsub message from which to extract\n+ * the event timestamp.\n+ *\n+ * <p>This attribute has to conform to the same requirements as in {@link\n+ * PubsubIO.Read.Builder#withTimestampAttribute}.\n+ *\n+ * <p>Short version: it has to be either millis since epoch or string in RFC 3339 format.\n+ *\n+ * <p>If the attribute is specified then event timestamps will be extracted from the specified\n+ * attribute. If it is not specified then message publish timestamp will be used.\n+ *\n+ * <p>deadLetterQueue is an optional topic path which will be used as a dead letter queue.\n+ *\n+ * <p>Messages that cannot be processed will be sent to this topic. If it is not specified then\n+ * exception will be thrown for errors during processing causing the pipeline to crash.", "originalCommit": "6ac8bf56fd2b229d2e7ad62b5594c8d754c36bc0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUzNTU4MQ==", "url": "https://github.com/apache/beam/pull/12090#discussion_r450535581", "bodyText": "Looks great, thank you!", "author": "TheNeuralBit", "createdAt": "2020-07-06T23:47:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODY4NTkzOQ=="}], "type": "inlineReview"}, {"oid": "c90136be1fc0601a8ca70a05f0847cec4810f538", "url": "https://github.com/apache/beam/commit/c90136be1fc0601a8ca70a05f0847cec4810f538", "message": "Updated PubsubSchemaCapableIOProvider javadoc", "committedDate": "2020-07-06T20:04:26Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDUzNjM2Mg==", "url": "https://github.com/apache/beam/pull/12090#discussion_r450536362", "bodyText": "Beam java  is itself an SDK, so we should be clear this will enable IOs in other SDKs\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n             * <p>The interfaces can be implemented to enable IOs for SDKs in addition to Beam SQL.\n          \n          \n            \n             * <p>The interfaces can be implemented to make IOs available in other SDKs in addition to Beam SQL.", "author": "TheNeuralBit", "createdAt": "2020-07-06T23:50:02Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/io/SchemaIO.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.schemas.io;\n+\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.transforms.PTransform;\n+import org.apache.beam.sdk.values.PBegin;\n+import org.apache.beam.sdk.values.PCollection;\n+import org.apache.beam.sdk.values.POutput;\n+import org.apache.beam.sdk.values.Row;\n+\n+/**\n+ * An abstraction to create schema capable and aware IOs. The interface is intended to be used in\n+ * conjunction with the interface {@link SchemaCapableIOProvider}.\n+ *\n+ * <p>The interfaces can be implemented to enable IOs for SDKs in addition to Beam SQL.", "originalCommit": "c90136be1fc0601a8ca70a05f0847cec4810f538", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDU0MTIzMw==", "url": "https://github.com/apache/beam/pull/12090#discussion_r450541233", "bodyText": "Sorry I should've brought this up before. We should add some disclaimers here and in SchemaIO (and the exceptions should at least get the annotations):\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /** Provider to create {@link SchemaIO}. */\n          \n          \n            \n            public interface SchemaCapableIOProvider {\n          \n          \n            \n            /** \n          \n          \n            \n             * Provider to create {@link SchemaIO} instances for use in Beam SQL and other SDKs.\n          \n          \n            \n             *\n          \n          \n            \n             * <p><b>Internal only:</b> This interface is actively being worked on and it will likely change as we provide\n          \n          \n            \n             * implementations for more standard Beam IOs. We provide no backwards compatibility guarantees and\n          \n          \n            \n             * it should not be implemented outside of the Beam repository.\n          \n          \n            \n             */\n          \n          \n            \n            @Internal\n          \n          \n            \n            @Experimental(Kind.SCHEMAS)\n          \n          \n            \n            public interface SchemaCapableIOProvider {\n          \n      \n    \n    \n  \n\nI think it's very likely we'll make some changes to these interfaces (e.g. @tysonjh and @kennknowles have a good suggestion in the doc), so we don't want anyone other than us trying to implement them yet. Let's do this to make that clear.", "author": "TheNeuralBit", "createdAt": "2020-07-07T00:07:41Z", "path": "sdks/java/core/src/main/java/org/apache/beam/sdk/schemas/io/SchemaCapableIOProvider.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.beam.sdk.schemas.io;\n+\n+import org.apache.beam.sdk.schemas.Schema;\n+import org.apache.beam.sdk.values.Row;\n+\n+/** Provider to create {@link SchemaIO}. */\n+public interface SchemaCapableIOProvider {", "originalCommit": "c90136be1fc0601a8ca70a05f0847cec4810f538", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d546ec5b1e6e6ce62c47234d212a04331c3c2e59", "url": "https://github.com/apache/beam/commit/d546ec5b1e6e6ce62c47234d212a04331c3c2e59", "message": "Added experimental and internal annotations to schemaIO interfaces", "committedDate": "2020-07-07T14:22:11Z", "type": "commit"}]}