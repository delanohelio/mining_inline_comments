{"pr_number": 1366, "pr_title": "Use  LifecycleManager in Android", "pr_createdAt": "2020-05-29T20:12:50Z", "pr_url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1366", "timeline": [{"oid": "931aa1bdbe15af338c1593c6d1ec1885b4d0f27c", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/931aa1bdbe15af338c1593c6d1ec1885b4d0f27c", "message": "Move code from LifecycleManager to BaseLifecycleManager", "committedDate": "2020-05-28T17:58:20Z", "type": "commit"}, {"oid": "54e6d7de2a3ee581a33e116412d93e6a83aff515", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/54e6d7de2a3ee581a33e116412d93e6a83aff515", "message": "Fix symlinks", "committedDate": "2020-05-28T18:17:54Z", "type": "commit"}, {"oid": "95ece776d53caa5b5963af0f2338b7c8e76a3f6c", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/95ece776d53caa5b5963af0f2338b7c8e76a3f6c", "message": "Move constructor from BaseLifecycleManager to LifecycleManager", "committedDate": "2020-05-28T19:18:59Z", "type": "commit"}, {"oid": "59cb907de0b36d130086441ee356a51d4b478990", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/59cb907de0b36d130086441ee356a51d4b478990", "message": "Add Android LifecycleManager constructor", "committedDate": "2020-05-28T19:31:56Z", "type": "commit"}, {"oid": "e3bcebab830d465227c1c49f9207964880ea7737", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/e3bcebab830d465227c1c49f9207964880ea7737", "message": "Setup Android SdlManager to use LifecycleManager", "committedDate": "2020-05-29T17:08:02Z", "type": "commit"}, {"oid": "b414208899ac8872b4bacf85c99cd2c14c467199", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/b414208899ac8872b4bacf85c99cd2c14c467199", "message": "Merge branch 'develop' into feature/android_lcm", "committedDate": "2020-05-29T17:08:24Z", "type": "commit"}, {"oid": "2e23c196821cd99acd2a3d9a7d61cb14770e4705", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/2e23c196821cd99acd2a3d9a7d61cb14770e4705", "message": "Update code formatting", "committedDate": "2020-05-29T17:44:08Z", "type": "commit"}, {"oid": "3917c85a6a7e90716ed6f68f0bb1653441fd2169", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/3917c85a6a7e90716ed6f68f0bb1653441fd2169", "message": "Check NPE in onProxyClosed", "committedDate": "2020-06-01T20:19:47Z", "type": "commit"}, {"oid": "18f803e4d2fb505c17a35b778a3837351533d98b", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/18f803e4d2fb505c17a35b778a3837351533d98b", "message": "Update SdlManager javadoc", "committedDate": "2020-06-02T14:22:43Z", "type": "commit"}, {"oid": "7e926f28f8f8a8f57a7559093c73a09b075b3d05", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/7e926f28f8f8a8f57a7559093c73a09b075b3d05", "message": "Add NAV & PCM dupport to EncryptionLifecycleManager", "committedDate": "2020-06-02T19:29:03Z", "type": "commit"}, {"oid": "c572b8b3581c45abcbd4c9dd3fbc0877841fb290", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/c572b8b3581c45abcbd4c9dd3fbc0877841fb290", "message": "Merge branch 'develop' into feature/android_lcm", "committedDate": "2020-06-02T19:31:04Z", "type": "commit"}, {"oid": "050ae26425751b3beaa0995f3724c22ebe05351f", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/050ae26425751b3beaa0995f3724c22ebe05351f", "message": "Add basic NAV & PCM support to BaseLifecycleManager", "committedDate": "2020-06-02T19:53:26Z", "type": "commit"}, {"oid": "30cb9d76521d24b447de5ca389018852cb4ad0a0", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/30cb9d76521d24b447de5ca389018852cb4ad0a0", "message": "Merge branch 'develop' into feature/android_lcm", "committedDate": "2020-06-02T19:53:40Z", "type": "commit"}, {"oid": "f2ee959c1d252d7ecc8537fcb108e8c57f162a8e", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/f2ee959c1d252d7ecc8537fcb108e8c57f162a8e", "message": "Cleanup LCM", "committedDate": "2020-06-03T14:42:36Z", "type": "commit"}, {"oid": "afb592c0804c55be7a5ba395f181dc4d50d745f5", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/afb592c0804c55be7a5ba395f181dc4d50d745f5", "message": "Move NAV & PCM code to Android LifecycleManager", "committedDate": "2020-06-03T17:32:26Z", "type": "commit"}, {"oid": "dddd3f79355f707d223a2accf37d7d753369946b", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/dddd3f79355f707d223a2accf37d7d753369946b", "message": "Remove unused imports", "committedDate": "2020-06-03T17:39:17Z", "type": "commit"}, {"oid": "3c28c2367b0eba1cc5b5ee9c572ba67518c5140b", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/3c28c2367b0eba1cc5b5ee9c572ba67518c5140b", "message": "Fix potential NPE in hello sdl java", "committedDate": "2020-06-03T20:07:28Z", "type": "commit"}, {"oid": "54706b28b458a3ce38247ee6f64a9641460b1595", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/54706b28b458a3ce38247ee6f64a9641460b1595", "message": "Update formatting", "committedDate": "2020-06-03T21:05:55Z", "type": "commit"}, {"oid": "88b02528208efdc6c6e029bcc0c5441868506b9f", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/88b02528208efdc6c6e029bcc0c5441868506b9f", "message": "Merge branch 'develop' into feature/android_lcm\n\n# Conflicts:\n#\tandroid/sdl_android/src/main/java/com/smartdevicelink/managers/SdlManager.java\n#\tbase/src/main/java/com/smartdevicelink/managers/BaseSdlManager.java\n#\tjavaSE/src/main/java/com/smartdevicelink/managers/SdlManager.java", "committedDate": "2020-06-04T15:37:18Z", "type": "commit"}, {"oid": "8a6e18e90d2c4702e354f63bd6fb2d0184181d1f", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/8a6e18e90d2c4702e354f63bd6fb2d0184181d1f", "message": "Remove old checkLifecycleConfiguration method", "committedDate": "2020-06-04T15:47:44Z", "type": "commit"}, {"oid": "64023263a5a8a22bd32f7d2511e0422309a3c5d0", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/64023263a5a8a22bd32f7d2511e0422309a3c5d0", "message": "Prevent sending RPC with protected CorrelationID", "committedDate": "2020-06-04T20:25:07Z", "type": "commit"}, {"oid": "454c3e3a6682d5bcf136d6b1087482591c3ab11b", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/454c3e3a6682d5bcf136d6b1087482591c3ab11b", "message": "Update getProtocolVersion() to return default version if value is null", "committedDate": "2020-06-04T20:31:31Z", "type": "commit"}, {"oid": "ed4286b4dd410a03cf32d7ecb842ec102c8fac49", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/ed4286b4dd410a03cf32d7ecb842ec102c8fac49", "message": "Update formatting in SdlManager", "committedDate": "2020-06-05T15:23:19Z", "type": "commit"}, {"oid": "3622381b0d5a99a941302bdde1ef3c4b0f353f8c", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/3622381b0d5a99a941302bdde1ef3c4b0f353f8c", "message": "Add logic to set SdlSecurityBase.context", "committedDate": "2020-06-05T15:53:48Z", "type": "commit"}, {"oid": "f45dc766fa5c8e7bcd236e5db0bf8af966f5d5b0", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/f45dc766fa5c8e7bcd236e5db0bf8af966f5d5b0", "message": "Remove deprecated methods usage in SdlManager", "committedDate": "2020-06-05T17:59:29Z", "type": "commit"}, {"oid": "582014293e69ec06d96f7b0d9d3fd59f748deb35", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/582014293e69ec06d96f7b0d9d3fd59f748deb35", "message": "Fix SdlManager unit tests", "committedDate": "2020-06-05T17:59:44Z", "type": "commit"}, {"oid": "a65389af0a19e9ec54beb1080a1b7e64c8660914", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/a65389af0a19e9ec54beb1080a1b7e64c8660914", "message": "Remove unused import", "committedDate": "2020-06-05T21:11:11Z", "type": "commit"}, {"oid": "9a9cc73fa4a540218ac4b9442a498401243da1db", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/9a9cc73fa4a540218ac4b9442a498401243da1db", "message": "Remove unsed vars from LifecycleManager", "committedDate": "2020-06-08T13:59:19Z", "type": "commit"}, {"oid": "97ecbfab51b1e61788565dc328eaa039b6f6f857", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/97ecbfab51b1e61788565dc328eaa039b6f6f857", "message": "add createSession method to LCM", "committedDate": "2020-06-08T18:44:01Z", "type": "commit"}, {"oid": "e6498f057b86c21310fd5e9d1ba2c593e31ef5a5", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/e6498f057b86c21310fd5e9d1ba2c593e31ef5a5", "message": "Add cycle proxy logic to LCM", "committedDate": "2020-06-09T15:33:41Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1NjU0OQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1366#discussion_r438856549", "bodyText": "There are formatting issues in this class with spaces needing to be added before { in regards to methods and if statements", "author": "JulianKast", "createdAt": "2020-06-11T15:08:39Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/SdlManager.java", "diffHunk": "@@ -41,65 +41,22 @@\n import android.support.annotation.Nullable;", "originalCommit": "e6498f057b86c21310fd5e9d1ba2c593e31ef5a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg1ODE4Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1366#discussion_r438858182", "bodyText": "add space before {", "author": "JulianKast", "createdAt": "2020-06-11T15:11:05Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/lifecycle/LifecycleManager.java", "diffHunk": "@@ -0,0 +1,394 @@\n+/*\n+ * Copyright (c) 2019 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.managers.lifecycle;\n+\n+import android.app.Service;\n+import android.content.Context;\n+import android.support.annotation.RestrictTo;\n+import android.util.Log;\n+\n+import com.smartdevicelink.SdlConnection.SdlSession;\n+import com.smartdevicelink.SdlConnection.SdlSession2;\n+import com.smartdevicelink.exception.SdlException;\n+import com.smartdevicelink.exception.SdlExceptionCause;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.proxy.rpc.enums.SdlDisconnectedReason;\n+import com.smartdevicelink.proxy.rpc.enums.SystemCapabilityType;\n+import com.smartdevicelink.security.SdlSecurityBase;\n+import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n+import com.smartdevicelink.transport.BaseTransportConfig;\n+import com.smartdevicelink.transport.MultiplexTransportConfig;\n+import com.smartdevicelink.transport.TCPTransportConfig;\n+import com.smartdevicelink.transport.USBTransportConfig;\n+import com.smartdevicelink.transport.enums.TransportType;\n+import com.smartdevicelink.util.DebugTool;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.concurrent.Callable;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.FutureTask;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+/**\n+ * The lifecycle manager creates a central point for all SDL session logic to converge. It should only be used by\n+ * the library itself. Usage outside the library is not permitted and will not be protected for in the future.\n+ *\n+ * @author Bilal Alsharifi.\n+ */\n+@RestrictTo(RestrictTo.Scope.LIBRARY)\n+public class LifecycleManager extends BaseLifecycleManager {\n+    private static final int RESPONSE_WAIT_TIME = 2000;\n+    private ISdlServiceListener navServiceListener;\n+    private boolean navServiceStartResponseReceived = false;\n+    private boolean navServiceStartResponse = false;\n+    private boolean navServiceEndResponseReceived = false;\n+    private boolean navServiceEndResponse = false;\n+    private boolean pcmServiceEndResponseReceived = false;\n+    private boolean pcmServiceEndResponse = false;\n+    private Context context;\n+\n+    public LifecycleManager(AppConfig appConfig, BaseTransportConfig config, LifecycleListener listener) {\n+        super(appConfig, config, listener);\n+    }\n+\n+    @Override\n+    void initializeProxy() {\n+        super.initializeProxy();\n+\n+        //Handle legacy USB connections\n+        if (_transportConfig != null && TransportType.USB.equals(_transportConfig.getTransportType())) {\n+            //A USB transport config was provided\n+            USBTransportConfig usbTransportConfig = (USBTransportConfig) _transportConfig;\n+            if (usbTransportConfig.getUsbAccessory() == null) {\n+                DebugTool.logInfo(\"Legacy USB transport config was used, but received null for accessory. Attempting to connect with router service\");\n+                //The accessory was null which means it came from a router service\n+                MultiplexTransportConfig multiplexTransportConfig = new MultiplexTransportConfig(usbTransportConfig.getUSBContext(), appConfig.getAppID());\n+                multiplexTransportConfig.setRequiresHighBandwidth(true);\n+                multiplexTransportConfig.setSecurityLevel(MultiplexTransportConfig.FLAG_MULTI_SECURITY_OFF);\n+                multiplexTransportConfig.setPrimaryTransports(Collections.singletonList(TransportType.USB));\n+                multiplexTransportConfig.setSecondaryTransports(new ArrayList<TransportType>());\n+                _transportConfig = multiplexTransportConfig;\n+            }\n+        }\n+\n+        if (_transportConfig != null && _transportConfig.getTransportType().equals(TransportType.MULTIPLEX)) {\n+            this.session = new SdlSession2(sdlConnectionListener, (MultiplexTransportConfig) _transportConfig);\n+        } else if (_transportConfig != null && _transportConfig.getTransportType().equals(TransportType.TCP)) {\n+            this.session = new SdlSession2(sdlConnectionListener, (TCPTransportConfig) _transportConfig);\n+        } else {\n+            this.session = SdlSession.createSession((byte) getProtocolVersion().getMajor(), sdlConnectionListener, _transportConfig);\n+        }\n+    }\n+\n+    private void cycleProxy(SdlDisconnectedReason disconnectedReason) {\n+        cleanProxy();\n+        initializeProxy();\n+        if(!SdlDisconnectedReason.LEGACY_BLUETOOTH_MODE_ENABLED.equals(disconnectedReason) && !SdlDisconnectedReason.PRIMARY_TRANSPORT_CYCLE_REQUEST.equals(disconnectedReason)){\n+            //We don't want to alert higher if we are just cycling for legacy bluetooth\n+            onClose(\"Sdl Proxy Cycled\", new SdlException(\"Sdl Proxy Cycled\", SdlExceptionCause.SDL_PROXY_CYCLED));\n+        }\n+        try {\n+            session.startSession();\n+        } catch (SdlException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+\n+    @RestrictTo(RestrictTo.Scope.LIBRARY)\n+    public void setContext(Context context) {\n+        this.context = context;\n+    }\n+\n+    @Override\n+    void setSdlSecurityStaticVars() {\n+        super.setSdlSecurityStaticVars();\n+\n+        Service service = null;\n+        if (context != null && context instanceof Service) {\n+            service = (Service) context;\n+        }\n+        SdlSecurityBase.setAppService(service);\n+        SdlSecurityBase.setContext(context);\n+    }\n+\n+    @Override\n+    void onProtocolSessionStarted(SessionType sessionType) {\n+        super.onProtocolSessionStarted(sessionType);\n+        if (sessionType.eq(SessionType.NAV)) {\n+            navServiceStartResponseReceived = true;\n+            navServiceStartResponse = true;\n+        }\n+    }\n+\n+    @Override\n+    void onTransportDisconnected(String info, boolean availablePrimary, BaseTransportConfig transportConfig){", "originalCommit": "e6498f057b86c21310fd5e9d1ba2c593e31ef5a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2MTYxMA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1366#discussion_r438861610", "bodyText": "There are several cases in this class where a space needs to be added before {", "author": "JulianKast", "createdAt": "2020-06-11T15:15:57Z", "path": "base/src/main/java/com/smartdevicelink/managers/BaseSdlManager.java", "diffHunk": "@@ -31,24 +31,46 @@\n  */", "originalCommit": "e6498f057b86c21310fd5e9d1ba2c593e31ef5a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2Mjk3Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1366#discussion_r438862972", "bodyText": "There are several cases in this class where a space needs to be added before {", "author": "JulianKast", "createdAt": "2020-06-11T15:17:54Z", "path": "base/src/main/java/com/smartdevicelink/managers/lifecycle/BaseLifecycleManager.java", "diffHunk": "@@ -32,5 +32,1490 @@\n ", "originalCommit": "e6498f057b86c21310fd5e9d1ba2c593e31ef5a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2MzkyMA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1366#discussion_r438863920", "bodyText": "Add space before '{'", "author": "JulianKast", "createdAt": "2020-06-11T15:19:14Z", "path": "javaSE/src/main/java/com/smartdevicelink/managers/SdlManager.java", "diffHunk": "@@ -89,755 +54,137 @@\n  * 3. Sending Requests <br>\n  * 4. Helper methods\n  */\n-public class SdlManager extends BaseSdlManager{\n-\n-\tprivate static final String TAG = \"SdlManager\";\n-\n-\tprivate SdlArtwork appIcon;\n-\tprivate SdlManagerListener managerListener;\n-\tprivate List<Class<? extends SdlSecurityBase>> sdlSecList;\n-\tprivate ServiceEncryptionListener serviceEncryptionListener;\n-\tprivate FileManagerConfig fileManagerConfig;\n-\n-\t// Managers\n-\tprivate LifecycleManager lifecycleManager;\n-\tprivate PermissionManager permissionManager;\n-\tprivate FileManager fileManager;\n-    private ScreenManager screenManager;\n-\n-\n-\t// INTERNAL INTERFACE\n-\t/**\n-\t * This is from the LifeCycleManager directly. In the future if there is a reason to be a man in the middle\n-\t * the SdlManager could create it's own, however right now it was only a duplication of logic tied to the LCM.\n-\t */\n-\tprivate ISdl _internalInterface;\n-\n-\n-\t// Initialize proxyBridge with anonymous lifecycleListener\n-\tprivate final LifecycleManager.LifecycleListener lifecycleListener = new LifecycleManager.LifecycleListener() {\n-\t\tboolean initStarted = false;\n-\t\t@Override\n-\t\tpublic void onProxyConnected(LifecycleManager lifeCycleManager) {\n-\t\t\tLog.i(TAG,\"Proxy is connected. Now initializing.\");\n-\t\t\tsynchronized (this){\n-\t\t\t\tif(!initStarted){\n-\t\t\t\t\tchangeRegistrationRetry = 0;\n-\t\t\t\t\tcheckLifecycleConfiguration();\n-\t\t\t\t\tinitialize();\n-\t\t\t\t\tinitStarted = true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t@Override\n-\t\tpublic void onServiceStarted(SessionType sessionType){\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onServiceEnded(SessionType sessionType){\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onProxyClosed(LifecycleManager lifeCycleManager, String info, Exception e, SdlDisconnectedReason reason) {\n-\t\t\tLog.i(TAG,\"Proxy is closed.\");\n-\t\t\tif(managerListener != null){\n-\t\t\t\tmanagerListener.onDestroy(SdlManager.this);\n-\t\t\t}\n-\n-\t\t}\n-\n-\n-\t\t@Override\n-\t\tpublic void onError(LifecycleManager lifeCycleManager, String info, Exception e) {\n-\n-\t\t}\n-\t};\n-\n-\t// Sub manager listener\n-\tprivate final CompletionListener subManagerListener = new CompletionListener() {\n-\t\t@Override\n-\t\tpublic synchronized void onComplete(boolean success) {\n-\t\t\tif(!success){\n-\t\t\t\tLog.e(TAG, \"Sub manager failed to initialize\");\n-\t\t\t}\n-\t\t\tcheckState();\n-\t\t}\n-\t};\n-\n-\t@Override\n-\tvoid checkState() {\n-\t\tif (permissionManager != null && fileManager != null && screenManager != null ){\n-\t\t\tif (permissionManager.getState() == BaseSubManager.READY && fileManager.getState() == BaseSubManager.READY && screenManager.getState() == BaseSubManager.READY){\n-\t\t\t\tDebugTool.logInfo(\"Starting sdl manager, all sub managers are in ready state\");\n-\t\t\t\ttransitionToState(BaseSubManager.READY);\n-\t\t\t\thandleQueuedNotifications();\n-\t\t\t\tnotifyDevListener(null);\n-\t\t\t\tonReady();\n-\t\t\t} else if (permissionManager.getState() == BaseSubManager.ERROR && fileManager.getState() == BaseSubManager.ERROR && screenManager.getState() == BaseSubManager.ERROR){\n-\t\t\t\tString info = \"ERROR starting sdl manager, all sub managers are in error state\";\n-\t\t\t\tLog.e(TAG, info);\n-\t\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t\t\tnotifyDevListener(info);\n-\t\t\t} else if (permissionManager.getState() == BaseSubManager.SETTING_UP || fileManager.getState() == BaseSubManager.SETTING_UP || screenManager.getState() == BaseSubManager.SETTING_UP) {\n-\t\t\t\tDebugTool.logInfo(\"SETTING UP sdl manager, some sub managers are still setting up\");\n-\t\t\t\ttransitionToState(BaseSubManager.SETTING_UP);\n-\t\t\t\t// No need to notify developer here!\n-\t\t\t} else {\n-\t\t\t\tLog.w(TAG, \"LIMITED starting sdl manager, some sub managers are in error or limited state and the others finished setting up\");\n-\t\t\t\ttransitionToState(BaseSubManager.LIMITED);\n-\t\t\t\thandleQueuedNotifications();\n-\t\t\t\tnotifyDevListener(null);\n-\t\t\t\tonReady();\n-\t\t\t}\n-\t\t} else {\n-\t\t\t// We should never be here, but somehow one of the sub-sub managers is null\n-\t\t\tString info = \"ERROR one of the sdl sub managers is null\";\n-\t\t\tLog.e(TAG, info);\n-\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t\tnotifyDevListener(info);\n-\t\t}\n-\t}\n-\n-\tprivate void notifyDevListener(String info) {\n-\t\tif (managerListener != null) {\n-\t\t\tif (getState() == BaseSubManager.ERROR){\n-\t\t\t\tmanagerListener.onError(this, info, null);\n-\t\t\t} else {\n-\t\t\t\tmanagerListener.onStart(this);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void onReady(){\n-\t\t// Set the app icon\n-\t\t if (SdlManager.this.appIcon != null && SdlManager.this.appIcon.getName() != null) {\n-\t\t\tif (fileManager != null && fileManager.getState() == BaseSubManager.READY && !fileManager.hasUploadedFile(SdlManager.this.appIcon)) {\n-\t\t\t\tfileManager.uploadArtwork(SdlManager.this.appIcon, new CompletionListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\t\t\tif (success) {\n-\t\t\t\t\t\t\tSetAppIcon msg = new SetAppIcon(SdlManager.this.appIcon.getName());\n-\t\t\t\t\t\t\t_internalInterface.sendRPCRequest(msg);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t} else {\n-\t\t\t\tSetAppIcon msg = new SetAppIcon(SdlManager.this.appIcon.getName());\n-\t\t\t\t_internalInterface.sendRPCRequest(msg);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void checkLifecycleConfiguration(){\n-\t\tfinal Language actualLanguage =  this.getRegisterAppInterfaceResponse().getLanguage();\n-\t\tfinal Language actualHMILanguage =  this.getRegisterAppInterfaceResponse().getHmiDisplayLanguage();\n-\n-\t\tif ((actualLanguage != null && !actualLanguage.equals(language)) || (actualHMILanguage != null && !actualHMILanguage.equals(hmiLanguage))) {\n-\n-\t\t\tLifecycleConfigurationUpdate lcuNew = managerListener.managerShouldUpdateLifecycle(actualLanguage, actualHMILanguage);\n-\t\t\tLifecycleConfigurationUpdate lcuOld = managerListener.managerShouldUpdateLifecycle(actualLanguage);\n-\t\t\tfinal LifecycleConfigurationUpdate lcu;\n-\t\t\tChangeRegistration changeRegistration;\n-\t\t\tif (lcuNew == null) {\n-\t\t\t\tlcu = lcuOld;\n-\t\t\t\tchangeRegistration = new ChangeRegistration(actualLanguage, actualLanguage);\n-\t\t\t} else {\n-\t\t\t\tlcu = lcuNew;\n-\t\t\t\tchangeRegistration = new ChangeRegistration(actualLanguage, actualHMILanguage);\n-\t\t\t}\n-\n-\t\t\tif (lcu != null) {\n-\t\t\t\tchangeRegistration.setAppName(lcu.getAppName());\n-\t\t\t\tchangeRegistration.setNgnMediaScreenAppName(lcu.getShortAppName());\n-\t\t\t\tchangeRegistration.setTtsName(lcu.getTtsName());\n-\t\t\t\tchangeRegistration.setVrSynonyms(lcu.getVoiceRecognitionCommandNames());\n-\t\t\t\tchangeRegistration.setOnRPCResponseListener(new OnRPCResponseListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onResponse(int correlationId, RPCResponse response) {\n-\t\t\t\t\t\tif (response.getSuccess()){\n-\t\t\t\t\t\t\t// go through and change sdlManager properties that were changed via the LCU update\n-\t\t\t\t\t\t\thmiLanguage = actualHMILanguage;\n-\t\t\t\t\t\t\tlanguage = actualLanguage;\n-\n-\t\t\t\t\t\t\tif (lcu.getAppName() != null) {\n-\t\t\t\t\t\t\t\tappName = lcu.getAppName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getShortAppName() != null) {\n-\t\t\t\t\t\t\t\tshortAppName = lcu.getShortAppName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getTtsName() != null) {\n-\t\t\t\t\t\t\t\tttsChunks = lcu.getTtsName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getVoiceRecognitionCommandNames() != null) {\n-\t\t\t\t\t\t\t\tvrSynonyms = lcu.getVoiceRecognitionCommandNames();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tLog.v(TAG, response.serializeJSON().toString());\n-\t\t\t\t\t\t} catch (JSONException e) {\n-\t\t\t\t\t\t\te.printStackTrace();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onError(int correlationId, Result resultCode, String info) {\n-\t\t\t\t\t\tLog.e(TAG, \"Change Registration onError: \" + resultCode + \" | Info: \" + info);\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t\t_internalInterface.sendRPC(changeRegistration);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void initialize(){\n-\t\t// Instantiate sub managers\n-\t\tthis.permissionManager = new PermissionManager(_internalInterface);\n-\t\tthis.fileManager = new FileManager(_internalInterface, fileManagerConfig);\n-\t\tthis.screenManager = new ScreenManager(_internalInterface, this.fileManager);\n-\n-\t\t// Start sub managers\n-\t\tthis.permissionManager.start(subManagerListener);\n-\t\tthis.fileManager.start(subManagerListener);\n-\t\tthis.screenManager.start(subManagerListener);\n-\t}\n-\n-\t@Override\n-\tpublic void dispose() {\n-\t\tif (this.permissionManager != null) {\n-\t\t\tthis.permissionManager.dispose();\n-\t\t}\n-\n-\t\tif (this.fileManager != null) {\n-\t\t\tthis.fileManager.dispose();\n-\t\t}\n-\n-\t\tif (this.screenManager != null) {\n-\t\t\tthis.screenManager.dispose();\n-\t\t}\n-\n-\t\tif (this.lifecycleManager != null) {\n-\t\t\tthis.lifecycleManager.stop();\n-\t\t}\n-\n-\t\tif(managerListener != null){\n-\t\t\tmanagerListener.onDestroy(this);\n-\t\t\tmanagerListener = null;\n-\t\t}\n-\n-\t\ttransitionToState(BaseSubManager.SHUTDOWN);\n-\t}\n-\n-\n-\t// MANAGER GETTERS\n-\t/**\n-\t * Gets the PermissionManager. <br>\n-\t * <strong>Note: PermissionManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a PermissionManager object\n-\t */\n-\tpublic PermissionManager getPermissionManager() {\n-\t\tif (permissionManager.getState() != BaseSubManager.READY && permissionManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG,\"PermissionManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn permissionManager;\n-\t}\n-\n-\t/**\n-\t * Gets the FileManager. <br>\n-\t * <strong>Note: FileManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a FileManager object\n-\t */\n-\tpublic FileManager getFileManager() {\n-\t\tif (fileManager.getState() != BaseSubManager.READY && fileManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG, \"FileManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn fileManager;\n-\t}\n-\n-\t/**\n-\t * Gets the ScreenManager. <br>\n-\t * <strong>Note: ScreenManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a ScreenManager object\n-\t */\n-\tpublic ScreenManager getScreenManager() {\n-\t\tif (screenManager.getState() != BaseSubManager.READY && screenManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG, \"ScreenManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn screenManager;\n-\t}\n-\n-\t/**\n-\t * Gets the SystemCapabilityManager. <br>\n-\t * <strong>Note: SystemCapabilityManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a SystemCapabilityManager object\n-\t */\n-\tpublic SystemCapabilityManager getSystemCapabilityManager(){\n-\t\treturn lifecycleManager.getSystemCapabilityManager(this);\n-\t}\n-\n-\t/**\n-\t * Method to retrieve the RegisterAppInterface Response message that was sent back from the\n-\t * module. It contains various attributes about the connected module and can be used to adapt\n-\t * to different module types and their supported features.\n-\t *\n-\t * @return RegisterAppInterfaceResponse received from the module or null if the app has not yet\n-\t * registered with the module.\n-\t */\n-\t@Override\n-\tpublic RegisterAppInterfaceResponse getRegisterAppInterfaceResponse(){\n-\t\tif(lifecycleManager != null){\n-\t\t\treturn lifecycleManager.getRegisterAppInterfaceResponse();\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\t/**\n-\t * Get the current OnHMIStatus\n-\t * @return OnHMIStatus object represents the current OnHMIStatus\n-\t */\n-\t@Override\n-\tpublic OnHMIStatus getCurrentHMIStatus(){\n-\t\tif(this.lifecycleManager !=null ){\n-\t\t\treturn lifecycleManager.getCurrentHMIStatus();\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\t// PROTECTED GETTERS\n-\n-\tprotected FileManagerConfig getFileManagerConfig() { return fileManagerConfig; }\n-\n-\t/**\n-\t * Retrieves the auth token, if any, that was attached to the StartServiceACK for the RPC\n-\t * service from the module. For example, this should be used to login to a user account.\n-\t * @return the string representation of the auth token\n-\t */\n-\t@Override\n-\tpublic String getAuthToken(){\n-\t\treturn this.lifecycleManager.getAuthToken();\n-\t}\n-\n-\t// SENDING REQUESTS\n-\n-\t/**\n-\t * Send RPC Message <br>\n-\t * @param message RPCMessage\n-\t */\n-\t@Override\n-\tpublic void sendRPC(RPCMessage message) {\n-\t\t_internalInterface.sendRPC(message);\n-\t}\n-\n-\t/**\n-\t * Takes a list of RPCMessages and sends it to SDL in a synchronous fashion. Responses are captured through callback on OnMultipleRequestListener.\n-\t * For sending requests asynchronously, use sendRequests <br>\n-\t *\n-\t * <strong>NOTE: This will override any listeners on individual RPCs</strong><br>\n-\t *\n-\t * <strong>ADDITIONAL NOTE: This only takes the type of RPCRequest for now, notifications and responses will be thrown out</strong>\n-\t *\n-\t * @param rpcs is the list of RPCMessages being sent\n-\t * @param listener listener for updates and completions\n-\t */\n-\t@Override\n-\tpublic void sendSequentialRPCs(final List<? extends RPCMessage> rpcs, final OnMultipleRequestListener listener){\n-\n-\t\tList<RPCRequest> rpcRequestList = new ArrayList<>();\n-\t\tfor (int i = 0; i < rpcs.size(); i++) {\n-\t\t\tif (rpcs.get(i) instanceof RPCRequest){\n-\t\t\t\trpcRequestList.add((RPCRequest)rpcs.get(i));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (rpcRequestList.size() > 0) {\n-\t\t\t_internalInterface.sendSequentialRPCs(rpcRequestList, listener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Takes a list of RPCMessages and sends it to SDL. Responses are captured through callback on OnMultipleRequestListener.\n-\t * For sending requests synchronously, use sendSequentialRPCs <br>\n-\t *\n-\t * <strong>NOTE: This will override any listeners on individual RPCs</strong> <br>\n-\t *\n-\t * <strong>ADDITIONAL NOTE: This only takes the type of RPCRequest for now, notifications and responses will be thrown out</strong>\n-\t *\n-\t * @param rpcs is the list of RPCMessages being sent\n-\t * @param listener listener for updates and completions\n-\t */\n-\t@Override\n-\tpublic void sendRPCs(List<? extends RPCMessage> rpcs, final OnMultipleRequestListener listener) {\n-\n-\t\tList<RPCRequest> rpcRequestList = new ArrayList<>();\n-\t\tfor (int i = 0; i < rpcs.size(); i++) {\n-\t\t\tif (rpcs.get(i) instanceof RPCRequest){\n-\t\t\t\trpcRequestList.add((RPCRequest)rpcs.get(i));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (rpcRequestList.size() > 0) {\n-\t\t\t_internalInterface.sendRequests(rpcRequestList,listener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Add an OnRPCNotificationListener\n-\t * @param listener listener that will be called when a notification is received\n-\t */\n-\t@Override\n-\tpublic void addOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener){\n-\t\t_internalInterface.addOnRPCNotificationListener(notificationId,listener);\n-\t}\n-\n-\t/**\n-\t * Remove an OnRPCNotificationListener\n-\t * @param listener listener that was previously added\n-\t */\n-\t@Override\n-\tpublic void removeOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener){\n-\t\t_internalInterface.removeOnRPCNotificationListener(notificationId, listener);\n-\t}\n-\n-\t/**\n-\t * Add an OnRPCRequestListener\n-\t * @param listener listener that will be called when a request is received\n-\t */\n-\t@Override\n-\tpublic void addOnRPCRequestListener(FunctionID requestId, OnRPCRequestListener listener){\n-\t\t_internalInterface.addOnRPCRequestListener(requestId,listener);\n-\t}\n-\n-\t/**\n-\t * Remove an OnRPCRequestListener\n-\t * @param listener listener that was previously added\n-\t */\n-\t@Override\n-\tpublic void removeOnRPCRequestListener(FunctionID requestId, OnRPCRequestListener listener){\n-\t\t_internalInterface.removeOnRPCRequestListener(requestId, listener);\n-\t}\n-\n-\t// LIFECYCLE / OTHER\n-\n-\t// STARTUP\n-\n-\t/**\n-\t * Starts up a SdlManager, and calls provided callback called once all BaseSubManagers are done setting up\n-\t */\n-\t@SuppressWarnings(\"unchecked\")\n-\t@Override\n-\tpublic void start(){\n-\n-\t\tRuntime.getRuntime().addShutdownHook(new Thread() {\n-\t\t\t@Override\n-\t\t\tpublic void run() {\n-\t\t\t\tdispose();\n-\t\t\t}\n-\t\t});\n-\n-\t\tLog.i(TAG, \"start\");\n-\t\tif (lifecycleManager == null) {\n-\t\t\tif (transport != null\n-\t\t\t\t\t&& (transport.getTransportType().equals(TransportType.WEB_SOCKET_SERVER) || transport.getTransportType().equals(TransportType.CUSTOM))) {\n-\t\t\t\t//Do the thing\n-\n-\t\t\t\tLifecycleManager.AppConfig appConfig = new LifecycleManager.AppConfig();\n-\t\t\t\tappConfig.setAppName(appName);\n-\t\t\t\t//short app name\n-\t\t\t\tappConfig.setMediaApp(isMediaApp);\n-\t\t\t\tappConfig.setHmiDisplayLanguageDesired(hmiLanguage);\n-\t\t\t\tappConfig.setLanguageDesired(hmiLanguage);\n-\t\t\t\tappConfig.setAppType(hmiTypes);\n-\t\t\t\tappConfig.setVrSynonyms(vrSynonyms);\n-\t\t\t\tappConfig.setTtsName(ttsChunks);\n-\t\t\t\tappConfig.setDayColorScheme(dayColorScheme);\n-\t\t\t\tappConfig.setNightColorScheme(nightColorScheme);\n-\t\t\t\tappConfig.setAppID(appId);\n-\t\t\t\tappConfig.setMinimumProtocolVersion(minimumProtocolVersion);\n-\t\t\t\tappConfig.setMinimumRPCVersion(minimumRPCVersion);\n-\n-\t\t\t\tlifecycleManager = new LifecycleManager(appConfig, transport, lifecycleListener);\n-\t\t\t\t_internalInterface = lifecycleManager.getInternalInterface(SdlManager.this);\n-\n-\t\t\t\tif (sdlSecList != null && !sdlSecList.isEmpty()) {\n-\t\t\t\t\tlifecycleManager.setSdlSecurity(sdlSecList, serviceEncryptionListener);\n-\t\t\t\t}\n-\n-\t\t\t\t//Setup the notification queue\n-\t\t\t\tinitNotificationQueue();\n-\n-\t\t\t\tlifecycleManager.start();\n-\n-\n-\t\t\t}else{\n-\t\t\t\tthrow new RuntimeException(\"No transport provided\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\n-\t// BUILDER\n-\tpublic static class Builder {\n-\t\tSdlManager sdlManager;\n-\n-\t\t/**\n-\t\t * Builder for the SdlManager. Parameters in the constructor are required.\n-\t\t * @param appId the app's ID\n-\t\t * @param appName the app's name\n-\t\t * @param listener a SdlManagerListener object\n-\t\t */\n-\t\tpublic Builder(@NonNull final String appId, @NonNull final String appName, @NonNull final SdlManagerListener listener){\n-\t\t\tsdlManager = new SdlManager();\n-\t\t\tsetAppId(appId);\n-\t\t\tsetAppName(appName);\n-\t\t\tsetManagerListener(listener);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the App ID\n-\t\t * @param appId String representation of the App ID retreived from the SDL Developer Portal\n-\t\t */\n-\t\tpublic Builder setAppId(@NonNull final String appId){\n-\t\t\tsdlManager.appId = appId;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Application Name\n-\t\t * @param appName String that will be associated as the app's name\n-\t\t */\n-\t\tpublic Builder setAppName(@NonNull final String appName){\n-\t\t\tsdlManager.appName = appName;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Short Application Name\n-\t\t * @param shortAppName a shorter representation of the app's name for smaller displays\n-\t\t */\n-\t\tpublic Builder setShortAppName(final String shortAppName) {\n-\t\t\tsdlManager.shortAppName = shortAppName;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the minimum protocol version that will be permitted to connect.\n-\t\t * If the protocol version of the head unit connected is below this version,\n-\t\t * the app will disconnect with an EndService protocol message and will not register.\n-\t\t * @param minimumProtocolVersion the minimum Protocol spec version that should be accepted\n-\t\t */\n-\t\tpublic Builder setMinimumProtocolVersion(final Version minimumProtocolVersion) {\n-\t\t\tsdlManager.minimumProtocolVersion = minimumProtocolVersion;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * The minimum RPC version that will be permitted to connect.\n-\t\t * If the RPC version of the head unit connected is below this version, an UnregisterAppInterface will be sent.\n-\t\t * @param minimumRPCVersion the minimum RPC spec version that should be accepted\n-\t\t */\n-\t\tpublic Builder setMinimumRPCVersion(final Version minimumRPCVersion) {\n-\t\t\tsdlManager.minimumRPCVersion = minimumRPCVersion;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Language of the App\n-\t\t * @param hmiLanguage the desired language to be used on the display/HMI of the connected module\n-\t\t */\n-\t\tpublic Builder setLanguage(final Language hmiLanguage) {\n-\t\t\tsdlManager.hmiLanguage = hmiLanguage;\n-\t\t\tsdlManager.language = hmiLanguage;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the TemplateColorScheme for daytime\n-\t\t * @param dayColorScheme color scheme that will be used (if supported) when the display is in a \"Day Mode\" or\n-\t\t *                       similar. Should comprise of colors that contrast well during the day under sunlight.\n-\t\t */\n-\t\tpublic Builder setDayColorScheme(final TemplateColorScheme dayColorScheme){\n-\t\t\tsdlManager.dayColorScheme = dayColorScheme;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the TemplateColorScheme for nighttime\n-\t\t * @param nightColorScheme color scheme that will be used (if supported) when the display is in a \"Night Mode\"\n-\t\t *                         or similar. Should comprise of colors that contrast well during the night and are not\n-\t\t *                         brighter than average.\n-\t\t */\n-\t\tpublic Builder setNightColorScheme(final TemplateColorScheme nightColorScheme){\n-\t\t\tsdlManager.nightColorScheme = nightColorScheme;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the icon for the app on head unit / In-Vehicle-Infotainment system <br>\n-\t\t * @param sdlArtwork the icon that will be used to represent this application on the connected module\n-\t\t */\n-\t\tpublic Builder setAppIcon(final SdlArtwork sdlArtwork){\n-\t\t\tsdlManager.appIcon = sdlArtwork;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the vector of AppHMIType <br>\n-\t\t * <strong>Note: This should be an ordered list from most -> least relevant</strong>\n-\t\t * @param hmiTypes HMI types that represent this application. For example, if the app is a music player, the\n-\t\t *                 MEDIA HMIType should be included.\n-\t\t */\n-\t\tpublic Builder setAppTypes(final Vector<AppHMIType> hmiTypes){\n-\n-\t\t\tsdlManager.hmiTypes = hmiTypes;\n-\n-\t\t\tif (hmiTypes != null) {\n-\t\t\t\tsdlManager.isMediaApp = hmiTypes.contains(AppHMIType.MEDIA);\n-\t\t\t}\n-\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the FileManagerConfig for the session.<br>\n-\t\t * <strong>Note: If not set, the default configuration value of 1 will be set for\n-\t\t * artworkRetryCount and fileRetryCount in FileManagerConfig</strong>\n-\t\t * @param fileManagerConfig - configuration options\n-\t\t */\n-\t\tpublic Builder setFileManagerConfig (final FileManagerConfig fileManagerConfig){\n-\t\t\tsdlManager.fileManagerConfig = fileManagerConfig;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the voice recognition synonyms that can be used to identify this application.\n-\t\t * @param vrSynonyms a vector of Strings that can be associated with this app. For example the app's name should\n-\t\t *                   be included as well as any phonetic spellings of the app name that might help the on-board\n-\t\t *                   VR system associated a users spoken word with the supplied synonyms.\n-\t\t */\n-\t\tpublic Builder setVrSynonyms(final Vector<String> vrSynonyms) {\n-\t\t\tsdlManager.vrSynonyms = vrSynonyms;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Text-To-Speech Name of the application. These TTSChunks might be used by the module as an audio\n-\t\t * representation of the app's name.\n-\t\t * @param ttsChunks the TTS chunks that can represent this app's name\n-\t\t */\n-\t\tpublic Builder setTtsName(final Vector<TTSChunk> ttsChunks) {\n-\t\t\tsdlManager.ttsChunks = ttsChunks;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * This Object type may change with the transport refactor\n-\t\t * Sets the BaseTransportConfig\n-\t\t * @param transport the type of transport that should be used for this SdlManager instance.\n-\t\t */\n-\t\tpublic Builder setTransportType(BaseTransportConfig transport){\n-\t\t\tsdlManager.transport = transport;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Security libraries\n-\t\t * @param secList The list of security class(es)\n-\t\t */\n-\t\t@Deprecated\n-\t\tpublic Builder setSdlSecurity(List<Class<? extends SdlSecurityBase>> secList) {\n-\t\t\tsdlManager.sdlSecList = secList;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the security libraries and a callback to notify caller when there is update to encryption service\n-\t\t * @param secList The list of security class(es)\n-\t\t * @param listener The callback object\n-\t\t */\n-\t\tpublic Builder setSdlSecurity(@NonNull List<Class<? extends SdlSecurityBase>> secList, ServiceEncryptionListener listener) {\n-\t\t\tsdlManager.sdlSecList = secList;\n-\t\t\tsdlManager.serviceEncryptionListener = listener;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Set the SdlManager Listener\n-\t\t * @param listener the listener\n-\t\t */\n-\t\tpublic Builder setManagerListener(@NonNull final SdlManagerListener listener){\n-\t\t\tsdlManager.managerListener = listener;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Set RPCNotification listeners. SdlManager will preload these listeners before any RPCs are sent/received.\n-\t\t * @param listeners a map of listeners that will be called when a notification is received.\n-\t\t * Key represents the FunctionID of the notification and value represents the listener\n-\t\t */\n-\t\tpublic Builder setRPCNotificationListeners(Map<FunctionID, OnRPCNotificationListener> listeners){\n-\t\t\tsdlManager.onRPCNotificationListeners = listeners;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\tpublic SdlManager build() {\n-\n-\t\t\tif (sdlManager.appName == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must specify an app name by calling setAppName\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.appId == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must specify an app ID by calling setAppId\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.managerListener == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must set a SdlManagerListener object\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.hmiTypes == null) {\n-\t\t\t\tVector<AppHMIType> hmiTypesDefault = new Vector<>();\n-\t\t\t\thmiTypesDefault.add(AppHMIType.DEFAULT);\n-\t\t\t\tsdlManager.hmiTypes = hmiTypesDefault;\n-\t\t\t\tsdlManager.isMediaApp = false;\n-\t\t\t}\n-\t\t\tif(sdlManager.fileManagerConfig == null){\n-\t\t\t\t//if FileManagerConfig is not set use default\n-\t\t\t\tsdlManager.fileManagerConfig = new FileManagerConfig();\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.hmiLanguage == null) {\n-\t\t\t\tsdlManager.hmiLanguage = Language.EN_US;\n-\t\t\t\tsdlManager.language = Language.EN_US;\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.minimumProtocolVersion == null){\n-\t\t\t\tsdlManager.minimumProtocolVersion = new Version(\"1.0.0\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.minimumRPCVersion == null){\n-\t\t\t\tsdlManager.minimumRPCVersion = new Version(\"1.0.0\");\n-\t\t\t}\n-\n-\t\t\tsdlManager.transitionToState(BaseSubManager.SETTING_UP);\n-\n-\t\t\treturn sdlManager;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Start a secured RPC service\n-\t */\n-\tpublic void startRPCEncryption() {\n-\t\tif (lifecycleManager != null) {\n-\t\t\tlifecycleManager.startRPCEncryption();\n-\t\t}\n-\t}\n+public class SdlManager extends BaseSdlManager {\n+\n+    /**\n+     * Starts up a SdlManager, and calls provided callback called once all BaseSubManagers are done setting up\n+     */\n+    @Override\n+    public void start() {\n+        Runtime.getRuntime().addShutdownHook(new Thread() {\n+            @Override\n+            public void run() {\n+                dispose();\n+            }\n+        });\n+\n+        Log.i(TAG, \"start\");\n+        if (lifecycleManager == null) {\n+            if (transport != null && (transport.getTransportType().equals(TransportType.WEB_SOCKET_SERVER) || transport.getTransportType().equals(TransportType.CUSTOM))) {\n+                super.start();\n+                lifecycleManager.start();\n+            } else {\n+                throw new RuntimeException(\"No transport provided\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void initialize(){\n+        // Instantiate sub managers\n+        this.permissionManager = new PermissionManager(_internalInterface);\n+        this.fileManager = new FileManager(_internalInterface, fileManagerConfig);\n+        this.screenManager = new ScreenManager(_internalInterface, this.fileManager);\n+\n+        // Start sub managers\n+        this.permissionManager.start(subManagerListener);\n+        this.fileManager.start(subManagerListener);\n+        this.screenManager.start(subManagerListener);\n+    }\n+\n+    @Override\n+    void checkState() {\n+        if (permissionManager != null && fileManager != null && screenManager != null ){\n+            if (permissionManager.getState() == BaseSubManager.READY && fileManager.getState() == BaseSubManager.READY && screenManager.getState() == BaseSubManager.READY){\n+                DebugTool.logInfo(\"Starting sdl manager, all sub managers are in ready state\");\n+                transitionToState(BaseSubManager.READY);\n+                handleQueuedNotifications();\n+                notifyDevListener(null);\n+                onReady();\n+            } else if (permissionManager.getState() == BaseSubManager.ERROR && fileManager.getState() == BaseSubManager.ERROR && screenManager.getState() == BaseSubManager.ERROR){\n+                String info = \"ERROR starting sdl manager, all sub managers are in error state\";\n+                Log.e(TAG, info);\n+                transitionToState(BaseSubManager.ERROR);\n+                notifyDevListener(info);\n+            } else if (permissionManager.getState() == BaseSubManager.SETTING_UP || fileManager.getState() == BaseSubManager.SETTING_UP || screenManager.getState() == BaseSubManager.SETTING_UP) {\n+                DebugTool.logInfo(\"SETTING UP sdl manager, some sub managers are still setting up\");\n+                transitionToState(BaseSubManager.SETTING_UP);\n+                // No need to notify developer here!\n+            } else {\n+                Log.w(TAG, \"LIMITED starting sdl manager, some sub managers are in error or limited state and the others finished setting up\");\n+                transitionToState(BaseSubManager.LIMITED);\n+                handleQueuedNotifications();\n+                notifyDevListener(null);\n+                onReady();\n+            }\n+        } else {\n+            // We should never be here, but somehow one of the sub-sub managers is null\n+            String info = \"ERROR one of the sdl sub managers is null\";\n+            Log.e(TAG, info);\n+            transitionToState(BaseSubManager.ERROR);\n+            notifyDevListener(info);\n+        }\n+    }\n+\n+    private void notifyDevListener(String info) {\n+        if (managerListener != null) {\n+            if (getState() == BaseSubManager.ERROR){\n+                managerListener.onError((SdlManager)this, info, null);\n+            } else {\n+                managerListener.onStart((SdlManager) this);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    void retryChangeRegistration() {\n+        // Do nothing\n+    }\n+\n+    @Override\n+    void onProxyClosed(SdlDisconnectedReason reason) {\n+        Log.i(TAG,\"Proxy is closed.\");\n+        if(managerListener != null){\n+            managerListener.onDestroy(SdlManager.this);\n+        }\n+    }\n+\n+    @Override\n+    public void dispose() {\n+        if (this.permissionManager != null) {\n+            this.permissionManager.dispose();\n+        }\n+\n+        if (this.fileManager != null) {\n+            this.fileManager.dispose();\n+        }\n+\n+        if (this.screenManager != null) {\n+            this.screenManager.dispose();\n+        }\n+\n+        if (this.lifecycleManager != null) {\n+            this.lifecycleManager.stop();\n+        }\n+\n+        if(managerListener != null){\n+            managerListener.onDestroy((SdlManager)this);\n+            managerListener = null;\n+        }\n+\n+        transitionToState(BaseSubManager.SHUTDOWN);\n+    }\n+\n+    // BUILDER\n+    public static class Builder extends BaseSdlManager.Builder {\n+        /**\n+         * Builder for the SdlManager. Parameters in the constructor are required.\n+         * @param appId the app's ID\n+         * @param appName the app's name\n+         * @param listener a SdlManagerListener object\n+         */\n+        public Builder(@NonNull final String appId, @NonNull final String appName, @NonNull final SdlManagerListener listener){", "originalCommit": "e6498f057b86c21310fd5e9d1ba2c593e31ef5a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2NDE3NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1366#discussion_r438864174", "bodyText": "Add space before '{'", "author": "JulianKast", "createdAt": "2020-06-11T15:19:39Z", "path": "javaSE/src/main/java/com/smartdevicelink/managers/SdlManager.java", "diffHunk": "@@ -89,755 +54,137 @@\n  * 3. Sending Requests <br>\n  * 4. Helper methods\n  */\n-public class SdlManager extends BaseSdlManager{\n-\n-\tprivate static final String TAG = \"SdlManager\";\n-\n-\tprivate SdlArtwork appIcon;\n-\tprivate SdlManagerListener managerListener;\n-\tprivate List<Class<? extends SdlSecurityBase>> sdlSecList;\n-\tprivate ServiceEncryptionListener serviceEncryptionListener;\n-\tprivate FileManagerConfig fileManagerConfig;\n-\n-\t// Managers\n-\tprivate LifecycleManager lifecycleManager;\n-\tprivate PermissionManager permissionManager;\n-\tprivate FileManager fileManager;\n-    private ScreenManager screenManager;\n-\n-\n-\t// INTERNAL INTERFACE\n-\t/**\n-\t * This is from the LifeCycleManager directly. In the future if there is a reason to be a man in the middle\n-\t * the SdlManager could create it's own, however right now it was only a duplication of logic tied to the LCM.\n-\t */\n-\tprivate ISdl _internalInterface;\n-\n-\n-\t// Initialize proxyBridge with anonymous lifecycleListener\n-\tprivate final LifecycleManager.LifecycleListener lifecycleListener = new LifecycleManager.LifecycleListener() {\n-\t\tboolean initStarted = false;\n-\t\t@Override\n-\t\tpublic void onProxyConnected(LifecycleManager lifeCycleManager) {\n-\t\t\tLog.i(TAG,\"Proxy is connected. Now initializing.\");\n-\t\t\tsynchronized (this){\n-\t\t\t\tif(!initStarted){\n-\t\t\t\t\tchangeRegistrationRetry = 0;\n-\t\t\t\t\tcheckLifecycleConfiguration();\n-\t\t\t\t\tinitialize();\n-\t\t\t\t\tinitStarted = true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t@Override\n-\t\tpublic void onServiceStarted(SessionType sessionType){\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onServiceEnded(SessionType sessionType){\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onProxyClosed(LifecycleManager lifeCycleManager, String info, Exception e, SdlDisconnectedReason reason) {\n-\t\t\tLog.i(TAG,\"Proxy is closed.\");\n-\t\t\tif(managerListener != null){\n-\t\t\t\tmanagerListener.onDestroy(SdlManager.this);\n-\t\t\t}\n-\n-\t\t}\n-\n-\n-\t\t@Override\n-\t\tpublic void onError(LifecycleManager lifeCycleManager, String info, Exception e) {\n-\n-\t\t}\n-\t};\n-\n-\t// Sub manager listener\n-\tprivate final CompletionListener subManagerListener = new CompletionListener() {\n-\t\t@Override\n-\t\tpublic synchronized void onComplete(boolean success) {\n-\t\t\tif(!success){\n-\t\t\t\tLog.e(TAG, \"Sub manager failed to initialize\");\n-\t\t\t}\n-\t\t\tcheckState();\n-\t\t}\n-\t};\n-\n-\t@Override\n-\tvoid checkState() {\n-\t\tif (permissionManager != null && fileManager != null && screenManager != null ){\n-\t\t\tif (permissionManager.getState() == BaseSubManager.READY && fileManager.getState() == BaseSubManager.READY && screenManager.getState() == BaseSubManager.READY){\n-\t\t\t\tDebugTool.logInfo(\"Starting sdl manager, all sub managers are in ready state\");\n-\t\t\t\ttransitionToState(BaseSubManager.READY);\n-\t\t\t\thandleQueuedNotifications();\n-\t\t\t\tnotifyDevListener(null);\n-\t\t\t\tonReady();\n-\t\t\t} else if (permissionManager.getState() == BaseSubManager.ERROR && fileManager.getState() == BaseSubManager.ERROR && screenManager.getState() == BaseSubManager.ERROR){\n-\t\t\t\tString info = \"ERROR starting sdl manager, all sub managers are in error state\";\n-\t\t\t\tLog.e(TAG, info);\n-\t\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t\t\tnotifyDevListener(info);\n-\t\t\t} else if (permissionManager.getState() == BaseSubManager.SETTING_UP || fileManager.getState() == BaseSubManager.SETTING_UP || screenManager.getState() == BaseSubManager.SETTING_UP) {\n-\t\t\t\tDebugTool.logInfo(\"SETTING UP sdl manager, some sub managers are still setting up\");\n-\t\t\t\ttransitionToState(BaseSubManager.SETTING_UP);\n-\t\t\t\t// No need to notify developer here!\n-\t\t\t} else {\n-\t\t\t\tLog.w(TAG, \"LIMITED starting sdl manager, some sub managers are in error or limited state and the others finished setting up\");\n-\t\t\t\ttransitionToState(BaseSubManager.LIMITED);\n-\t\t\t\thandleQueuedNotifications();\n-\t\t\t\tnotifyDevListener(null);\n-\t\t\t\tonReady();\n-\t\t\t}\n-\t\t} else {\n-\t\t\t// We should never be here, but somehow one of the sub-sub managers is null\n-\t\t\tString info = \"ERROR one of the sdl sub managers is null\";\n-\t\t\tLog.e(TAG, info);\n-\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t\tnotifyDevListener(info);\n-\t\t}\n-\t}\n-\n-\tprivate void notifyDevListener(String info) {\n-\t\tif (managerListener != null) {\n-\t\t\tif (getState() == BaseSubManager.ERROR){\n-\t\t\t\tmanagerListener.onError(this, info, null);\n-\t\t\t} else {\n-\t\t\t\tmanagerListener.onStart(this);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void onReady(){\n-\t\t// Set the app icon\n-\t\t if (SdlManager.this.appIcon != null && SdlManager.this.appIcon.getName() != null) {\n-\t\t\tif (fileManager != null && fileManager.getState() == BaseSubManager.READY && !fileManager.hasUploadedFile(SdlManager.this.appIcon)) {\n-\t\t\t\tfileManager.uploadArtwork(SdlManager.this.appIcon, new CompletionListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\t\t\tif (success) {\n-\t\t\t\t\t\t\tSetAppIcon msg = new SetAppIcon(SdlManager.this.appIcon.getName());\n-\t\t\t\t\t\t\t_internalInterface.sendRPCRequest(msg);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t} else {\n-\t\t\t\tSetAppIcon msg = new SetAppIcon(SdlManager.this.appIcon.getName());\n-\t\t\t\t_internalInterface.sendRPCRequest(msg);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void checkLifecycleConfiguration(){\n-\t\tfinal Language actualLanguage =  this.getRegisterAppInterfaceResponse().getLanguage();\n-\t\tfinal Language actualHMILanguage =  this.getRegisterAppInterfaceResponse().getHmiDisplayLanguage();\n-\n-\t\tif ((actualLanguage != null && !actualLanguage.equals(language)) || (actualHMILanguage != null && !actualHMILanguage.equals(hmiLanguage))) {\n-\n-\t\t\tLifecycleConfigurationUpdate lcuNew = managerListener.managerShouldUpdateLifecycle(actualLanguage, actualHMILanguage);\n-\t\t\tLifecycleConfigurationUpdate lcuOld = managerListener.managerShouldUpdateLifecycle(actualLanguage);\n-\t\t\tfinal LifecycleConfigurationUpdate lcu;\n-\t\t\tChangeRegistration changeRegistration;\n-\t\t\tif (lcuNew == null) {\n-\t\t\t\tlcu = lcuOld;\n-\t\t\t\tchangeRegistration = new ChangeRegistration(actualLanguage, actualLanguage);\n-\t\t\t} else {\n-\t\t\t\tlcu = lcuNew;\n-\t\t\t\tchangeRegistration = new ChangeRegistration(actualLanguage, actualHMILanguage);\n-\t\t\t}\n-\n-\t\t\tif (lcu != null) {\n-\t\t\t\tchangeRegistration.setAppName(lcu.getAppName());\n-\t\t\t\tchangeRegistration.setNgnMediaScreenAppName(lcu.getShortAppName());\n-\t\t\t\tchangeRegistration.setTtsName(lcu.getTtsName());\n-\t\t\t\tchangeRegistration.setVrSynonyms(lcu.getVoiceRecognitionCommandNames());\n-\t\t\t\tchangeRegistration.setOnRPCResponseListener(new OnRPCResponseListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onResponse(int correlationId, RPCResponse response) {\n-\t\t\t\t\t\tif (response.getSuccess()){\n-\t\t\t\t\t\t\t// go through and change sdlManager properties that were changed via the LCU update\n-\t\t\t\t\t\t\thmiLanguage = actualHMILanguage;\n-\t\t\t\t\t\t\tlanguage = actualLanguage;\n-\n-\t\t\t\t\t\t\tif (lcu.getAppName() != null) {\n-\t\t\t\t\t\t\t\tappName = lcu.getAppName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getShortAppName() != null) {\n-\t\t\t\t\t\t\t\tshortAppName = lcu.getShortAppName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getTtsName() != null) {\n-\t\t\t\t\t\t\t\tttsChunks = lcu.getTtsName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getVoiceRecognitionCommandNames() != null) {\n-\t\t\t\t\t\t\t\tvrSynonyms = lcu.getVoiceRecognitionCommandNames();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tLog.v(TAG, response.serializeJSON().toString());\n-\t\t\t\t\t\t} catch (JSONException e) {\n-\t\t\t\t\t\t\te.printStackTrace();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onError(int correlationId, Result resultCode, String info) {\n-\t\t\t\t\t\tLog.e(TAG, \"Change Registration onError: \" + resultCode + \" | Info: \" + info);\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t\t_internalInterface.sendRPC(changeRegistration);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void initialize(){\n-\t\t// Instantiate sub managers\n-\t\tthis.permissionManager = new PermissionManager(_internalInterface);\n-\t\tthis.fileManager = new FileManager(_internalInterface, fileManagerConfig);\n-\t\tthis.screenManager = new ScreenManager(_internalInterface, this.fileManager);\n-\n-\t\t// Start sub managers\n-\t\tthis.permissionManager.start(subManagerListener);\n-\t\tthis.fileManager.start(subManagerListener);\n-\t\tthis.screenManager.start(subManagerListener);\n-\t}\n-\n-\t@Override\n-\tpublic void dispose() {\n-\t\tif (this.permissionManager != null) {\n-\t\t\tthis.permissionManager.dispose();\n-\t\t}\n-\n-\t\tif (this.fileManager != null) {\n-\t\t\tthis.fileManager.dispose();\n-\t\t}\n-\n-\t\tif (this.screenManager != null) {\n-\t\t\tthis.screenManager.dispose();\n-\t\t}\n-\n-\t\tif (this.lifecycleManager != null) {\n-\t\t\tthis.lifecycleManager.stop();\n-\t\t}\n-\n-\t\tif(managerListener != null){\n-\t\t\tmanagerListener.onDestroy(this);\n-\t\t\tmanagerListener = null;\n-\t\t}\n-\n-\t\ttransitionToState(BaseSubManager.SHUTDOWN);\n-\t}\n-\n-\n-\t// MANAGER GETTERS\n-\t/**\n-\t * Gets the PermissionManager. <br>\n-\t * <strong>Note: PermissionManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a PermissionManager object\n-\t */\n-\tpublic PermissionManager getPermissionManager() {\n-\t\tif (permissionManager.getState() != BaseSubManager.READY && permissionManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG,\"PermissionManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn permissionManager;\n-\t}\n-\n-\t/**\n-\t * Gets the FileManager. <br>\n-\t * <strong>Note: FileManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a FileManager object\n-\t */\n-\tpublic FileManager getFileManager() {\n-\t\tif (fileManager.getState() != BaseSubManager.READY && fileManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG, \"FileManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn fileManager;\n-\t}\n-\n-\t/**\n-\t * Gets the ScreenManager. <br>\n-\t * <strong>Note: ScreenManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a ScreenManager object\n-\t */\n-\tpublic ScreenManager getScreenManager() {\n-\t\tif (screenManager.getState() != BaseSubManager.READY && screenManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG, \"ScreenManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn screenManager;\n-\t}\n-\n-\t/**\n-\t * Gets the SystemCapabilityManager. <br>\n-\t * <strong>Note: SystemCapabilityManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a SystemCapabilityManager object\n-\t */\n-\tpublic SystemCapabilityManager getSystemCapabilityManager(){\n-\t\treturn lifecycleManager.getSystemCapabilityManager(this);\n-\t}\n-\n-\t/**\n-\t * Method to retrieve the RegisterAppInterface Response message that was sent back from the\n-\t * module. It contains various attributes about the connected module and can be used to adapt\n-\t * to different module types and their supported features.\n-\t *\n-\t * @return RegisterAppInterfaceResponse received from the module or null if the app has not yet\n-\t * registered with the module.\n-\t */\n-\t@Override\n-\tpublic RegisterAppInterfaceResponse getRegisterAppInterfaceResponse(){\n-\t\tif(lifecycleManager != null){\n-\t\t\treturn lifecycleManager.getRegisterAppInterfaceResponse();\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\t/**\n-\t * Get the current OnHMIStatus\n-\t * @return OnHMIStatus object represents the current OnHMIStatus\n-\t */\n-\t@Override\n-\tpublic OnHMIStatus getCurrentHMIStatus(){\n-\t\tif(this.lifecycleManager !=null ){\n-\t\t\treturn lifecycleManager.getCurrentHMIStatus();\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\t// PROTECTED GETTERS\n-\n-\tprotected FileManagerConfig getFileManagerConfig() { return fileManagerConfig; }\n-\n-\t/**\n-\t * Retrieves the auth token, if any, that was attached to the StartServiceACK for the RPC\n-\t * service from the module. For example, this should be used to login to a user account.\n-\t * @return the string representation of the auth token\n-\t */\n-\t@Override\n-\tpublic String getAuthToken(){\n-\t\treturn this.lifecycleManager.getAuthToken();\n-\t}\n-\n-\t// SENDING REQUESTS\n-\n-\t/**\n-\t * Send RPC Message <br>\n-\t * @param message RPCMessage\n-\t */\n-\t@Override\n-\tpublic void sendRPC(RPCMessage message) {\n-\t\t_internalInterface.sendRPC(message);\n-\t}\n-\n-\t/**\n-\t * Takes a list of RPCMessages and sends it to SDL in a synchronous fashion. Responses are captured through callback on OnMultipleRequestListener.\n-\t * For sending requests asynchronously, use sendRequests <br>\n-\t *\n-\t * <strong>NOTE: This will override any listeners on individual RPCs</strong><br>\n-\t *\n-\t * <strong>ADDITIONAL NOTE: This only takes the type of RPCRequest for now, notifications and responses will be thrown out</strong>\n-\t *\n-\t * @param rpcs is the list of RPCMessages being sent\n-\t * @param listener listener for updates and completions\n-\t */\n-\t@Override\n-\tpublic void sendSequentialRPCs(final List<? extends RPCMessage> rpcs, final OnMultipleRequestListener listener){\n-\n-\t\tList<RPCRequest> rpcRequestList = new ArrayList<>();\n-\t\tfor (int i = 0; i < rpcs.size(); i++) {\n-\t\t\tif (rpcs.get(i) instanceof RPCRequest){\n-\t\t\t\trpcRequestList.add((RPCRequest)rpcs.get(i));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (rpcRequestList.size() > 0) {\n-\t\t\t_internalInterface.sendSequentialRPCs(rpcRequestList, listener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Takes a list of RPCMessages and sends it to SDL. Responses are captured through callback on OnMultipleRequestListener.\n-\t * For sending requests synchronously, use sendSequentialRPCs <br>\n-\t *\n-\t * <strong>NOTE: This will override any listeners on individual RPCs</strong> <br>\n-\t *\n-\t * <strong>ADDITIONAL NOTE: This only takes the type of RPCRequest for now, notifications and responses will be thrown out</strong>\n-\t *\n-\t * @param rpcs is the list of RPCMessages being sent\n-\t * @param listener listener for updates and completions\n-\t */\n-\t@Override\n-\tpublic void sendRPCs(List<? extends RPCMessage> rpcs, final OnMultipleRequestListener listener) {\n-\n-\t\tList<RPCRequest> rpcRequestList = new ArrayList<>();\n-\t\tfor (int i = 0; i < rpcs.size(); i++) {\n-\t\t\tif (rpcs.get(i) instanceof RPCRequest){\n-\t\t\t\trpcRequestList.add((RPCRequest)rpcs.get(i));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (rpcRequestList.size() > 0) {\n-\t\t\t_internalInterface.sendRequests(rpcRequestList,listener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Add an OnRPCNotificationListener\n-\t * @param listener listener that will be called when a notification is received\n-\t */\n-\t@Override\n-\tpublic void addOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener){\n-\t\t_internalInterface.addOnRPCNotificationListener(notificationId,listener);\n-\t}\n-\n-\t/**\n-\t * Remove an OnRPCNotificationListener\n-\t * @param listener listener that was previously added\n-\t */\n-\t@Override\n-\tpublic void removeOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener){\n-\t\t_internalInterface.removeOnRPCNotificationListener(notificationId, listener);\n-\t}\n-\n-\t/**\n-\t * Add an OnRPCRequestListener\n-\t * @param listener listener that will be called when a request is received\n-\t */\n-\t@Override\n-\tpublic void addOnRPCRequestListener(FunctionID requestId, OnRPCRequestListener listener){\n-\t\t_internalInterface.addOnRPCRequestListener(requestId,listener);\n-\t}\n-\n-\t/**\n-\t * Remove an OnRPCRequestListener\n-\t * @param listener listener that was previously added\n-\t */\n-\t@Override\n-\tpublic void removeOnRPCRequestListener(FunctionID requestId, OnRPCRequestListener listener){\n-\t\t_internalInterface.removeOnRPCRequestListener(requestId, listener);\n-\t}\n-\n-\t// LIFECYCLE / OTHER\n-\n-\t// STARTUP\n-\n-\t/**\n-\t * Starts up a SdlManager, and calls provided callback called once all BaseSubManagers are done setting up\n-\t */\n-\t@SuppressWarnings(\"unchecked\")\n-\t@Override\n-\tpublic void start(){\n-\n-\t\tRuntime.getRuntime().addShutdownHook(new Thread() {\n-\t\t\t@Override\n-\t\t\tpublic void run() {\n-\t\t\t\tdispose();\n-\t\t\t}\n-\t\t});\n-\n-\t\tLog.i(TAG, \"start\");\n-\t\tif (lifecycleManager == null) {\n-\t\t\tif (transport != null\n-\t\t\t\t\t&& (transport.getTransportType().equals(TransportType.WEB_SOCKET_SERVER) || transport.getTransportType().equals(TransportType.CUSTOM))) {\n-\t\t\t\t//Do the thing\n-\n-\t\t\t\tLifecycleManager.AppConfig appConfig = new LifecycleManager.AppConfig();\n-\t\t\t\tappConfig.setAppName(appName);\n-\t\t\t\t//short app name\n-\t\t\t\tappConfig.setMediaApp(isMediaApp);\n-\t\t\t\tappConfig.setHmiDisplayLanguageDesired(hmiLanguage);\n-\t\t\t\tappConfig.setLanguageDesired(hmiLanguage);\n-\t\t\t\tappConfig.setAppType(hmiTypes);\n-\t\t\t\tappConfig.setVrSynonyms(vrSynonyms);\n-\t\t\t\tappConfig.setTtsName(ttsChunks);\n-\t\t\t\tappConfig.setDayColorScheme(dayColorScheme);\n-\t\t\t\tappConfig.setNightColorScheme(nightColorScheme);\n-\t\t\t\tappConfig.setAppID(appId);\n-\t\t\t\tappConfig.setMinimumProtocolVersion(minimumProtocolVersion);\n-\t\t\t\tappConfig.setMinimumRPCVersion(minimumRPCVersion);\n-\n-\t\t\t\tlifecycleManager = new LifecycleManager(appConfig, transport, lifecycleListener);\n-\t\t\t\t_internalInterface = lifecycleManager.getInternalInterface(SdlManager.this);\n-\n-\t\t\t\tif (sdlSecList != null && !sdlSecList.isEmpty()) {\n-\t\t\t\t\tlifecycleManager.setSdlSecurity(sdlSecList, serviceEncryptionListener);\n-\t\t\t\t}\n-\n-\t\t\t\t//Setup the notification queue\n-\t\t\t\tinitNotificationQueue();\n-\n-\t\t\t\tlifecycleManager.start();\n-\n-\n-\t\t\t}else{\n-\t\t\t\tthrow new RuntimeException(\"No transport provided\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\n-\t// BUILDER\n-\tpublic static class Builder {\n-\t\tSdlManager sdlManager;\n-\n-\t\t/**\n-\t\t * Builder for the SdlManager. Parameters in the constructor are required.\n-\t\t * @param appId the app's ID\n-\t\t * @param appName the app's name\n-\t\t * @param listener a SdlManagerListener object\n-\t\t */\n-\t\tpublic Builder(@NonNull final String appId, @NonNull final String appName, @NonNull final SdlManagerListener listener){\n-\t\t\tsdlManager = new SdlManager();\n-\t\t\tsetAppId(appId);\n-\t\t\tsetAppName(appName);\n-\t\t\tsetManagerListener(listener);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the App ID\n-\t\t * @param appId String representation of the App ID retreived from the SDL Developer Portal\n-\t\t */\n-\t\tpublic Builder setAppId(@NonNull final String appId){\n-\t\t\tsdlManager.appId = appId;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Application Name\n-\t\t * @param appName String that will be associated as the app's name\n-\t\t */\n-\t\tpublic Builder setAppName(@NonNull final String appName){\n-\t\t\tsdlManager.appName = appName;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Short Application Name\n-\t\t * @param shortAppName a shorter representation of the app's name for smaller displays\n-\t\t */\n-\t\tpublic Builder setShortAppName(final String shortAppName) {\n-\t\t\tsdlManager.shortAppName = shortAppName;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the minimum protocol version that will be permitted to connect.\n-\t\t * If the protocol version of the head unit connected is below this version,\n-\t\t * the app will disconnect with an EndService protocol message and will not register.\n-\t\t * @param minimumProtocolVersion the minimum Protocol spec version that should be accepted\n-\t\t */\n-\t\tpublic Builder setMinimumProtocolVersion(final Version minimumProtocolVersion) {\n-\t\t\tsdlManager.minimumProtocolVersion = minimumProtocolVersion;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * The minimum RPC version that will be permitted to connect.\n-\t\t * If the RPC version of the head unit connected is below this version, an UnregisterAppInterface will be sent.\n-\t\t * @param minimumRPCVersion the minimum RPC spec version that should be accepted\n-\t\t */\n-\t\tpublic Builder setMinimumRPCVersion(final Version minimumRPCVersion) {\n-\t\t\tsdlManager.minimumRPCVersion = minimumRPCVersion;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Language of the App\n-\t\t * @param hmiLanguage the desired language to be used on the display/HMI of the connected module\n-\t\t */\n-\t\tpublic Builder setLanguage(final Language hmiLanguage) {\n-\t\t\tsdlManager.hmiLanguage = hmiLanguage;\n-\t\t\tsdlManager.language = hmiLanguage;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the TemplateColorScheme for daytime\n-\t\t * @param dayColorScheme color scheme that will be used (if supported) when the display is in a \"Day Mode\" or\n-\t\t *                       similar. Should comprise of colors that contrast well during the day under sunlight.\n-\t\t */\n-\t\tpublic Builder setDayColorScheme(final TemplateColorScheme dayColorScheme){\n-\t\t\tsdlManager.dayColorScheme = dayColorScheme;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the TemplateColorScheme for nighttime\n-\t\t * @param nightColorScheme color scheme that will be used (if supported) when the display is in a \"Night Mode\"\n-\t\t *                         or similar. Should comprise of colors that contrast well during the night and are not\n-\t\t *                         brighter than average.\n-\t\t */\n-\t\tpublic Builder setNightColorScheme(final TemplateColorScheme nightColorScheme){\n-\t\t\tsdlManager.nightColorScheme = nightColorScheme;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the icon for the app on head unit / In-Vehicle-Infotainment system <br>\n-\t\t * @param sdlArtwork the icon that will be used to represent this application on the connected module\n-\t\t */\n-\t\tpublic Builder setAppIcon(final SdlArtwork sdlArtwork){\n-\t\t\tsdlManager.appIcon = sdlArtwork;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the vector of AppHMIType <br>\n-\t\t * <strong>Note: This should be an ordered list from most -> least relevant</strong>\n-\t\t * @param hmiTypes HMI types that represent this application. For example, if the app is a music player, the\n-\t\t *                 MEDIA HMIType should be included.\n-\t\t */\n-\t\tpublic Builder setAppTypes(final Vector<AppHMIType> hmiTypes){\n-\n-\t\t\tsdlManager.hmiTypes = hmiTypes;\n-\n-\t\t\tif (hmiTypes != null) {\n-\t\t\t\tsdlManager.isMediaApp = hmiTypes.contains(AppHMIType.MEDIA);\n-\t\t\t}\n-\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the FileManagerConfig for the session.<br>\n-\t\t * <strong>Note: If not set, the default configuration value of 1 will be set for\n-\t\t * artworkRetryCount and fileRetryCount in FileManagerConfig</strong>\n-\t\t * @param fileManagerConfig - configuration options\n-\t\t */\n-\t\tpublic Builder setFileManagerConfig (final FileManagerConfig fileManagerConfig){\n-\t\t\tsdlManager.fileManagerConfig = fileManagerConfig;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the voice recognition synonyms that can be used to identify this application.\n-\t\t * @param vrSynonyms a vector of Strings that can be associated with this app. For example the app's name should\n-\t\t *                   be included as well as any phonetic spellings of the app name that might help the on-board\n-\t\t *                   VR system associated a users spoken word with the supplied synonyms.\n-\t\t */\n-\t\tpublic Builder setVrSynonyms(final Vector<String> vrSynonyms) {\n-\t\t\tsdlManager.vrSynonyms = vrSynonyms;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Text-To-Speech Name of the application. These TTSChunks might be used by the module as an audio\n-\t\t * representation of the app's name.\n-\t\t * @param ttsChunks the TTS chunks that can represent this app's name\n-\t\t */\n-\t\tpublic Builder setTtsName(final Vector<TTSChunk> ttsChunks) {\n-\t\t\tsdlManager.ttsChunks = ttsChunks;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * This Object type may change with the transport refactor\n-\t\t * Sets the BaseTransportConfig\n-\t\t * @param transport the type of transport that should be used for this SdlManager instance.\n-\t\t */\n-\t\tpublic Builder setTransportType(BaseTransportConfig transport){\n-\t\t\tsdlManager.transport = transport;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Security libraries\n-\t\t * @param secList The list of security class(es)\n-\t\t */\n-\t\t@Deprecated\n-\t\tpublic Builder setSdlSecurity(List<Class<? extends SdlSecurityBase>> secList) {\n-\t\t\tsdlManager.sdlSecList = secList;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the security libraries and a callback to notify caller when there is update to encryption service\n-\t\t * @param secList The list of security class(es)\n-\t\t * @param listener The callback object\n-\t\t */\n-\t\tpublic Builder setSdlSecurity(@NonNull List<Class<? extends SdlSecurityBase>> secList, ServiceEncryptionListener listener) {\n-\t\t\tsdlManager.sdlSecList = secList;\n-\t\t\tsdlManager.serviceEncryptionListener = listener;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Set the SdlManager Listener\n-\t\t * @param listener the listener\n-\t\t */\n-\t\tpublic Builder setManagerListener(@NonNull final SdlManagerListener listener){\n-\t\t\tsdlManager.managerListener = listener;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Set RPCNotification listeners. SdlManager will preload these listeners before any RPCs are sent/received.\n-\t\t * @param listeners a map of listeners that will be called when a notification is received.\n-\t\t * Key represents the FunctionID of the notification and value represents the listener\n-\t\t */\n-\t\tpublic Builder setRPCNotificationListeners(Map<FunctionID, OnRPCNotificationListener> listeners){\n-\t\t\tsdlManager.onRPCNotificationListeners = listeners;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\tpublic SdlManager build() {\n-\n-\t\t\tif (sdlManager.appName == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must specify an app name by calling setAppName\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.appId == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must specify an app ID by calling setAppId\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.managerListener == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must set a SdlManagerListener object\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.hmiTypes == null) {\n-\t\t\t\tVector<AppHMIType> hmiTypesDefault = new Vector<>();\n-\t\t\t\thmiTypesDefault.add(AppHMIType.DEFAULT);\n-\t\t\t\tsdlManager.hmiTypes = hmiTypesDefault;\n-\t\t\t\tsdlManager.isMediaApp = false;\n-\t\t\t}\n-\t\t\tif(sdlManager.fileManagerConfig == null){\n-\t\t\t\t//if FileManagerConfig is not set use default\n-\t\t\t\tsdlManager.fileManagerConfig = new FileManagerConfig();\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.hmiLanguage == null) {\n-\t\t\t\tsdlManager.hmiLanguage = Language.EN_US;\n-\t\t\t\tsdlManager.language = Language.EN_US;\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.minimumProtocolVersion == null){\n-\t\t\t\tsdlManager.minimumProtocolVersion = new Version(\"1.0.0\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.minimumRPCVersion == null){\n-\t\t\t\tsdlManager.minimumRPCVersion = new Version(\"1.0.0\");\n-\t\t\t}\n-\n-\t\t\tsdlManager.transitionToState(BaseSubManager.SETTING_UP);\n-\n-\t\t\treturn sdlManager;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Start a secured RPC service\n-\t */\n-\tpublic void startRPCEncryption() {\n-\t\tif (lifecycleManager != null) {\n-\t\t\tlifecycleManager.startRPCEncryption();\n-\t\t}\n-\t}\n+public class SdlManager extends BaseSdlManager {\n+\n+    /**\n+     * Starts up a SdlManager, and calls provided callback called once all BaseSubManagers are done setting up\n+     */\n+    @Override\n+    public void start() {\n+        Runtime.getRuntime().addShutdownHook(new Thread() {\n+            @Override\n+            public void run() {\n+                dispose();\n+            }\n+        });\n+\n+        Log.i(TAG, \"start\");\n+        if (lifecycleManager == null) {\n+            if (transport != null && (transport.getTransportType().equals(TransportType.WEB_SOCKET_SERVER) || transport.getTransportType().equals(TransportType.CUSTOM))) {\n+                super.start();\n+                lifecycleManager.start();\n+            } else {\n+                throw new RuntimeException(\"No transport provided\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void initialize(){\n+        // Instantiate sub managers\n+        this.permissionManager = new PermissionManager(_internalInterface);\n+        this.fileManager = new FileManager(_internalInterface, fileManagerConfig);\n+        this.screenManager = new ScreenManager(_internalInterface, this.fileManager);\n+\n+        // Start sub managers\n+        this.permissionManager.start(subManagerListener);\n+        this.fileManager.start(subManagerListener);\n+        this.screenManager.start(subManagerListener);\n+    }\n+\n+    @Override\n+    void checkState() {\n+        if (permissionManager != null && fileManager != null && screenManager != null ){\n+            if (permissionManager.getState() == BaseSubManager.READY && fileManager.getState() == BaseSubManager.READY && screenManager.getState() == BaseSubManager.READY){\n+                DebugTool.logInfo(\"Starting sdl manager, all sub managers are in ready state\");\n+                transitionToState(BaseSubManager.READY);\n+                handleQueuedNotifications();\n+                notifyDevListener(null);\n+                onReady();\n+            } else if (permissionManager.getState() == BaseSubManager.ERROR && fileManager.getState() == BaseSubManager.ERROR && screenManager.getState() == BaseSubManager.ERROR){\n+                String info = \"ERROR starting sdl manager, all sub managers are in error state\";\n+                Log.e(TAG, info);\n+                transitionToState(BaseSubManager.ERROR);\n+                notifyDevListener(info);\n+            } else if (permissionManager.getState() == BaseSubManager.SETTING_UP || fileManager.getState() == BaseSubManager.SETTING_UP || screenManager.getState() == BaseSubManager.SETTING_UP) {\n+                DebugTool.logInfo(\"SETTING UP sdl manager, some sub managers are still setting up\");\n+                transitionToState(BaseSubManager.SETTING_UP);\n+                // No need to notify developer here!\n+            } else {\n+                Log.w(TAG, \"LIMITED starting sdl manager, some sub managers are in error or limited state and the others finished setting up\");\n+                transitionToState(BaseSubManager.LIMITED);\n+                handleQueuedNotifications();\n+                notifyDevListener(null);\n+                onReady();\n+            }\n+        } else {\n+            // We should never be here, but somehow one of the sub-sub managers is null\n+            String info = \"ERROR one of the sdl sub managers is null\";\n+            Log.e(TAG, info);\n+            transitionToState(BaseSubManager.ERROR);\n+            notifyDevListener(info);\n+        }\n+    }\n+\n+    private void notifyDevListener(String info) {\n+        if (managerListener != null) {\n+            if (getState() == BaseSubManager.ERROR){", "originalCommit": "e6498f057b86c21310fd5e9d1ba2c593e31ef5a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2NDUzOA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1366#discussion_r438864538", "bodyText": "Add space before '{'", "author": "JulianKast", "createdAt": "2020-06-11T15:20:10Z", "path": "javaSE/src/main/java/com/smartdevicelink/managers/SdlManager.java", "diffHunk": "@@ -89,755 +54,137 @@\n  * 3. Sending Requests <br>\n  * 4. Helper methods\n  */\n-public class SdlManager extends BaseSdlManager{\n-\n-\tprivate static final String TAG = \"SdlManager\";\n-\n-\tprivate SdlArtwork appIcon;\n-\tprivate SdlManagerListener managerListener;\n-\tprivate List<Class<? extends SdlSecurityBase>> sdlSecList;\n-\tprivate ServiceEncryptionListener serviceEncryptionListener;\n-\tprivate FileManagerConfig fileManagerConfig;\n-\n-\t// Managers\n-\tprivate LifecycleManager lifecycleManager;\n-\tprivate PermissionManager permissionManager;\n-\tprivate FileManager fileManager;\n-    private ScreenManager screenManager;\n-\n-\n-\t// INTERNAL INTERFACE\n-\t/**\n-\t * This is from the LifeCycleManager directly. In the future if there is a reason to be a man in the middle\n-\t * the SdlManager could create it's own, however right now it was only a duplication of logic tied to the LCM.\n-\t */\n-\tprivate ISdl _internalInterface;\n-\n-\n-\t// Initialize proxyBridge with anonymous lifecycleListener\n-\tprivate final LifecycleManager.LifecycleListener lifecycleListener = new LifecycleManager.LifecycleListener() {\n-\t\tboolean initStarted = false;\n-\t\t@Override\n-\t\tpublic void onProxyConnected(LifecycleManager lifeCycleManager) {\n-\t\t\tLog.i(TAG,\"Proxy is connected. Now initializing.\");\n-\t\t\tsynchronized (this){\n-\t\t\t\tif(!initStarted){\n-\t\t\t\t\tchangeRegistrationRetry = 0;\n-\t\t\t\t\tcheckLifecycleConfiguration();\n-\t\t\t\t\tinitialize();\n-\t\t\t\t\tinitStarted = true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t@Override\n-\t\tpublic void onServiceStarted(SessionType sessionType){\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onServiceEnded(SessionType sessionType){\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onProxyClosed(LifecycleManager lifeCycleManager, String info, Exception e, SdlDisconnectedReason reason) {\n-\t\t\tLog.i(TAG,\"Proxy is closed.\");\n-\t\t\tif(managerListener != null){\n-\t\t\t\tmanagerListener.onDestroy(SdlManager.this);\n-\t\t\t}\n-\n-\t\t}\n-\n-\n-\t\t@Override\n-\t\tpublic void onError(LifecycleManager lifeCycleManager, String info, Exception e) {\n-\n-\t\t}\n-\t};\n-\n-\t// Sub manager listener\n-\tprivate final CompletionListener subManagerListener = new CompletionListener() {\n-\t\t@Override\n-\t\tpublic synchronized void onComplete(boolean success) {\n-\t\t\tif(!success){\n-\t\t\t\tLog.e(TAG, \"Sub manager failed to initialize\");\n-\t\t\t}\n-\t\t\tcheckState();\n-\t\t}\n-\t};\n-\n-\t@Override\n-\tvoid checkState() {\n-\t\tif (permissionManager != null && fileManager != null && screenManager != null ){\n-\t\t\tif (permissionManager.getState() == BaseSubManager.READY && fileManager.getState() == BaseSubManager.READY && screenManager.getState() == BaseSubManager.READY){\n-\t\t\t\tDebugTool.logInfo(\"Starting sdl manager, all sub managers are in ready state\");\n-\t\t\t\ttransitionToState(BaseSubManager.READY);\n-\t\t\t\thandleQueuedNotifications();\n-\t\t\t\tnotifyDevListener(null);\n-\t\t\t\tonReady();\n-\t\t\t} else if (permissionManager.getState() == BaseSubManager.ERROR && fileManager.getState() == BaseSubManager.ERROR && screenManager.getState() == BaseSubManager.ERROR){\n-\t\t\t\tString info = \"ERROR starting sdl manager, all sub managers are in error state\";\n-\t\t\t\tLog.e(TAG, info);\n-\t\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t\t\tnotifyDevListener(info);\n-\t\t\t} else if (permissionManager.getState() == BaseSubManager.SETTING_UP || fileManager.getState() == BaseSubManager.SETTING_UP || screenManager.getState() == BaseSubManager.SETTING_UP) {\n-\t\t\t\tDebugTool.logInfo(\"SETTING UP sdl manager, some sub managers are still setting up\");\n-\t\t\t\ttransitionToState(BaseSubManager.SETTING_UP);\n-\t\t\t\t// No need to notify developer here!\n-\t\t\t} else {\n-\t\t\t\tLog.w(TAG, \"LIMITED starting sdl manager, some sub managers are in error or limited state and the others finished setting up\");\n-\t\t\t\ttransitionToState(BaseSubManager.LIMITED);\n-\t\t\t\thandleQueuedNotifications();\n-\t\t\t\tnotifyDevListener(null);\n-\t\t\t\tonReady();\n-\t\t\t}\n-\t\t} else {\n-\t\t\t// We should never be here, but somehow one of the sub-sub managers is null\n-\t\t\tString info = \"ERROR one of the sdl sub managers is null\";\n-\t\t\tLog.e(TAG, info);\n-\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t\tnotifyDevListener(info);\n-\t\t}\n-\t}\n-\n-\tprivate void notifyDevListener(String info) {\n-\t\tif (managerListener != null) {\n-\t\t\tif (getState() == BaseSubManager.ERROR){\n-\t\t\t\tmanagerListener.onError(this, info, null);\n-\t\t\t} else {\n-\t\t\t\tmanagerListener.onStart(this);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void onReady(){\n-\t\t// Set the app icon\n-\t\t if (SdlManager.this.appIcon != null && SdlManager.this.appIcon.getName() != null) {\n-\t\t\tif (fileManager != null && fileManager.getState() == BaseSubManager.READY && !fileManager.hasUploadedFile(SdlManager.this.appIcon)) {\n-\t\t\t\tfileManager.uploadArtwork(SdlManager.this.appIcon, new CompletionListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\t\t\tif (success) {\n-\t\t\t\t\t\t\tSetAppIcon msg = new SetAppIcon(SdlManager.this.appIcon.getName());\n-\t\t\t\t\t\t\t_internalInterface.sendRPCRequest(msg);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t} else {\n-\t\t\t\tSetAppIcon msg = new SetAppIcon(SdlManager.this.appIcon.getName());\n-\t\t\t\t_internalInterface.sendRPCRequest(msg);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void checkLifecycleConfiguration(){\n-\t\tfinal Language actualLanguage =  this.getRegisterAppInterfaceResponse().getLanguage();\n-\t\tfinal Language actualHMILanguage =  this.getRegisterAppInterfaceResponse().getHmiDisplayLanguage();\n-\n-\t\tif ((actualLanguage != null && !actualLanguage.equals(language)) || (actualHMILanguage != null && !actualHMILanguage.equals(hmiLanguage))) {\n-\n-\t\t\tLifecycleConfigurationUpdate lcuNew = managerListener.managerShouldUpdateLifecycle(actualLanguage, actualHMILanguage);\n-\t\t\tLifecycleConfigurationUpdate lcuOld = managerListener.managerShouldUpdateLifecycle(actualLanguage);\n-\t\t\tfinal LifecycleConfigurationUpdate lcu;\n-\t\t\tChangeRegistration changeRegistration;\n-\t\t\tif (lcuNew == null) {\n-\t\t\t\tlcu = lcuOld;\n-\t\t\t\tchangeRegistration = new ChangeRegistration(actualLanguage, actualLanguage);\n-\t\t\t} else {\n-\t\t\t\tlcu = lcuNew;\n-\t\t\t\tchangeRegistration = new ChangeRegistration(actualLanguage, actualHMILanguage);\n-\t\t\t}\n-\n-\t\t\tif (lcu != null) {\n-\t\t\t\tchangeRegistration.setAppName(lcu.getAppName());\n-\t\t\t\tchangeRegistration.setNgnMediaScreenAppName(lcu.getShortAppName());\n-\t\t\t\tchangeRegistration.setTtsName(lcu.getTtsName());\n-\t\t\t\tchangeRegistration.setVrSynonyms(lcu.getVoiceRecognitionCommandNames());\n-\t\t\t\tchangeRegistration.setOnRPCResponseListener(new OnRPCResponseListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onResponse(int correlationId, RPCResponse response) {\n-\t\t\t\t\t\tif (response.getSuccess()){\n-\t\t\t\t\t\t\t// go through and change sdlManager properties that were changed via the LCU update\n-\t\t\t\t\t\t\thmiLanguage = actualHMILanguage;\n-\t\t\t\t\t\t\tlanguage = actualLanguage;\n-\n-\t\t\t\t\t\t\tif (lcu.getAppName() != null) {\n-\t\t\t\t\t\t\t\tappName = lcu.getAppName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getShortAppName() != null) {\n-\t\t\t\t\t\t\t\tshortAppName = lcu.getShortAppName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getTtsName() != null) {\n-\t\t\t\t\t\t\t\tttsChunks = lcu.getTtsName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getVoiceRecognitionCommandNames() != null) {\n-\t\t\t\t\t\t\t\tvrSynonyms = lcu.getVoiceRecognitionCommandNames();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tLog.v(TAG, response.serializeJSON().toString());\n-\t\t\t\t\t\t} catch (JSONException e) {\n-\t\t\t\t\t\t\te.printStackTrace();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onError(int correlationId, Result resultCode, String info) {\n-\t\t\t\t\t\tLog.e(TAG, \"Change Registration onError: \" + resultCode + \" | Info: \" + info);\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t\t_internalInterface.sendRPC(changeRegistration);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void initialize(){\n-\t\t// Instantiate sub managers\n-\t\tthis.permissionManager = new PermissionManager(_internalInterface);\n-\t\tthis.fileManager = new FileManager(_internalInterface, fileManagerConfig);\n-\t\tthis.screenManager = new ScreenManager(_internalInterface, this.fileManager);\n-\n-\t\t// Start sub managers\n-\t\tthis.permissionManager.start(subManagerListener);\n-\t\tthis.fileManager.start(subManagerListener);\n-\t\tthis.screenManager.start(subManagerListener);\n-\t}\n-\n-\t@Override\n-\tpublic void dispose() {\n-\t\tif (this.permissionManager != null) {\n-\t\t\tthis.permissionManager.dispose();\n-\t\t}\n-\n-\t\tif (this.fileManager != null) {\n-\t\t\tthis.fileManager.dispose();\n-\t\t}\n-\n-\t\tif (this.screenManager != null) {\n-\t\t\tthis.screenManager.dispose();\n-\t\t}\n-\n-\t\tif (this.lifecycleManager != null) {\n-\t\t\tthis.lifecycleManager.stop();\n-\t\t}\n-\n-\t\tif(managerListener != null){\n-\t\t\tmanagerListener.onDestroy(this);\n-\t\t\tmanagerListener = null;\n-\t\t}\n-\n-\t\ttransitionToState(BaseSubManager.SHUTDOWN);\n-\t}\n-\n-\n-\t// MANAGER GETTERS\n-\t/**\n-\t * Gets the PermissionManager. <br>\n-\t * <strong>Note: PermissionManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a PermissionManager object\n-\t */\n-\tpublic PermissionManager getPermissionManager() {\n-\t\tif (permissionManager.getState() != BaseSubManager.READY && permissionManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG,\"PermissionManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn permissionManager;\n-\t}\n-\n-\t/**\n-\t * Gets the FileManager. <br>\n-\t * <strong>Note: FileManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a FileManager object\n-\t */\n-\tpublic FileManager getFileManager() {\n-\t\tif (fileManager.getState() != BaseSubManager.READY && fileManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG, \"FileManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn fileManager;\n-\t}\n-\n-\t/**\n-\t * Gets the ScreenManager. <br>\n-\t * <strong>Note: ScreenManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a ScreenManager object\n-\t */\n-\tpublic ScreenManager getScreenManager() {\n-\t\tif (screenManager.getState() != BaseSubManager.READY && screenManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG, \"ScreenManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn screenManager;\n-\t}\n-\n-\t/**\n-\t * Gets the SystemCapabilityManager. <br>\n-\t * <strong>Note: SystemCapabilityManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a SystemCapabilityManager object\n-\t */\n-\tpublic SystemCapabilityManager getSystemCapabilityManager(){\n-\t\treturn lifecycleManager.getSystemCapabilityManager(this);\n-\t}\n-\n-\t/**\n-\t * Method to retrieve the RegisterAppInterface Response message that was sent back from the\n-\t * module. It contains various attributes about the connected module and can be used to adapt\n-\t * to different module types and their supported features.\n-\t *\n-\t * @return RegisterAppInterfaceResponse received from the module or null if the app has not yet\n-\t * registered with the module.\n-\t */\n-\t@Override\n-\tpublic RegisterAppInterfaceResponse getRegisterAppInterfaceResponse(){\n-\t\tif(lifecycleManager != null){\n-\t\t\treturn lifecycleManager.getRegisterAppInterfaceResponse();\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\t/**\n-\t * Get the current OnHMIStatus\n-\t * @return OnHMIStatus object represents the current OnHMIStatus\n-\t */\n-\t@Override\n-\tpublic OnHMIStatus getCurrentHMIStatus(){\n-\t\tif(this.lifecycleManager !=null ){\n-\t\t\treturn lifecycleManager.getCurrentHMIStatus();\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\t// PROTECTED GETTERS\n-\n-\tprotected FileManagerConfig getFileManagerConfig() { return fileManagerConfig; }\n-\n-\t/**\n-\t * Retrieves the auth token, if any, that was attached to the StartServiceACK for the RPC\n-\t * service from the module. For example, this should be used to login to a user account.\n-\t * @return the string representation of the auth token\n-\t */\n-\t@Override\n-\tpublic String getAuthToken(){\n-\t\treturn this.lifecycleManager.getAuthToken();\n-\t}\n-\n-\t// SENDING REQUESTS\n-\n-\t/**\n-\t * Send RPC Message <br>\n-\t * @param message RPCMessage\n-\t */\n-\t@Override\n-\tpublic void sendRPC(RPCMessage message) {\n-\t\t_internalInterface.sendRPC(message);\n-\t}\n-\n-\t/**\n-\t * Takes a list of RPCMessages and sends it to SDL in a synchronous fashion. Responses are captured through callback on OnMultipleRequestListener.\n-\t * For sending requests asynchronously, use sendRequests <br>\n-\t *\n-\t * <strong>NOTE: This will override any listeners on individual RPCs</strong><br>\n-\t *\n-\t * <strong>ADDITIONAL NOTE: This only takes the type of RPCRequest for now, notifications and responses will be thrown out</strong>\n-\t *\n-\t * @param rpcs is the list of RPCMessages being sent\n-\t * @param listener listener for updates and completions\n-\t */\n-\t@Override\n-\tpublic void sendSequentialRPCs(final List<? extends RPCMessage> rpcs, final OnMultipleRequestListener listener){\n-\n-\t\tList<RPCRequest> rpcRequestList = new ArrayList<>();\n-\t\tfor (int i = 0; i < rpcs.size(); i++) {\n-\t\t\tif (rpcs.get(i) instanceof RPCRequest){\n-\t\t\t\trpcRequestList.add((RPCRequest)rpcs.get(i));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (rpcRequestList.size() > 0) {\n-\t\t\t_internalInterface.sendSequentialRPCs(rpcRequestList, listener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Takes a list of RPCMessages and sends it to SDL. Responses are captured through callback on OnMultipleRequestListener.\n-\t * For sending requests synchronously, use sendSequentialRPCs <br>\n-\t *\n-\t * <strong>NOTE: This will override any listeners on individual RPCs</strong> <br>\n-\t *\n-\t * <strong>ADDITIONAL NOTE: This only takes the type of RPCRequest for now, notifications and responses will be thrown out</strong>\n-\t *\n-\t * @param rpcs is the list of RPCMessages being sent\n-\t * @param listener listener for updates and completions\n-\t */\n-\t@Override\n-\tpublic void sendRPCs(List<? extends RPCMessage> rpcs, final OnMultipleRequestListener listener) {\n-\n-\t\tList<RPCRequest> rpcRequestList = new ArrayList<>();\n-\t\tfor (int i = 0; i < rpcs.size(); i++) {\n-\t\t\tif (rpcs.get(i) instanceof RPCRequest){\n-\t\t\t\trpcRequestList.add((RPCRequest)rpcs.get(i));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (rpcRequestList.size() > 0) {\n-\t\t\t_internalInterface.sendRequests(rpcRequestList,listener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Add an OnRPCNotificationListener\n-\t * @param listener listener that will be called when a notification is received\n-\t */\n-\t@Override\n-\tpublic void addOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener){\n-\t\t_internalInterface.addOnRPCNotificationListener(notificationId,listener);\n-\t}\n-\n-\t/**\n-\t * Remove an OnRPCNotificationListener\n-\t * @param listener listener that was previously added\n-\t */\n-\t@Override\n-\tpublic void removeOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener){\n-\t\t_internalInterface.removeOnRPCNotificationListener(notificationId, listener);\n-\t}\n-\n-\t/**\n-\t * Add an OnRPCRequestListener\n-\t * @param listener listener that will be called when a request is received\n-\t */\n-\t@Override\n-\tpublic void addOnRPCRequestListener(FunctionID requestId, OnRPCRequestListener listener){\n-\t\t_internalInterface.addOnRPCRequestListener(requestId,listener);\n-\t}\n-\n-\t/**\n-\t * Remove an OnRPCRequestListener\n-\t * @param listener listener that was previously added\n-\t */\n-\t@Override\n-\tpublic void removeOnRPCRequestListener(FunctionID requestId, OnRPCRequestListener listener){\n-\t\t_internalInterface.removeOnRPCRequestListener(requestId, listener);\n-\t}\n-\n-\t// LIFECYCLE / OTHER\n-\n-\t// STARTUP\n-\n-\t/**\n-\t * Starts up a SdlManager, and calls provided callback called once all BaseSubManagers are done setting up\n-\t */\n-\t@SuppressWarnings(\"unchecked\")\n-\t@Override\n-\tpublic void start(){\n-\n-\t\tRuntime.getRuntime().addShutdownHook(new Thread() {\n-\t\t\t@Override\n-\t\t\tpublic void run() {\n-\t\t\t\tdispose();\n-\t\t\t}\n-\t\t});\n-\n-\t\tLog.i(TAG, \"start\");\n-\t\tif (lifecycleManager == null) {\n-\t\t\tif (transport != null\n-\t\t\t\t\t&& (transport.getTransportType().equals(TransportType.WEB_SOCKET_SERVER) || transport.getTransportType().equals(TransportType.CUSTOM))) {\n-\t\t\t\t//Do the thing\n-\n-\t\t\t\tLifecycleManager.AppConfig appConfig = new LifecycleManager.AppConfig();\n-\t\t\t\tappConfig.setAppName(appName);\n-\t\t\t\t//short app name\n-\t\t\t\tappConfig.setMediaApp(isMediaApp);\n-\t\t\t\tappConfig.setHmiDisplayLanguageDesired(hmiLanguage);\n-\t\t\t\tappConfig.setLanguageDesired(hmiLanguage);\n-\t\t\t\tappConfig.setAppType(hmiTypes);\n-\t\t\t\tappConfig.setVrSynonyms(vrSynonyms);\n-\t\t\t\tappConfig.setTtsName(ttsChunks);\n-\t\t\t\tappConfig.setDayColorScheme(dayColorScheme);\n-\t\t\t\tappConfig.setNightColorScheme(nightColorScheme);\n-\t\t\t\tappConfig.setAppID(appId);\n-\t\t\t\tappConfig.setMinimumProtocolVersion(minimumProtocolVersion);\n-\t\t\t\tappConfig.setMinimumRPCVersion(minimumRPCVersion);\n-\n-\t\t\t\tlifecycleManager = new LifecycleManager(appConfig, transport, lifecycleListener);\n-\t\t\t\t_internalInterface = lifecycleManager.getInternalInterface(SdlManager.this);\n-\n-\t\t\t\tif (sdlSecList != null && !sdlSecList.isEmpty()) {\n-\t\t\t\t\tlifecycleManager.setSdlSecurity(sdlSecList, serviceEncryptionListener);\n-\t\t\t\t}\n-\n-\t\t\t\t//Setup the notification queue\n-\t\t\t\tinitNotificationQueue();\n-\n-\t\t\t\tlifecycleManager.start();\n-\n-\n-\t\t\t}else{\n-\t\t\t\tthrow new RuntimeException(\"No transport provided\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\n-\t// BUILDER\n-\tpublic static class Builder {\n-\t\tSdlManager sdlManager;\n-\n-\t\t/**\n-\t\t * Builder for the SdlManager. Parameters in the constructor are required.\n-\t\t * @param appId the app's ID\n-\t\t * @param appName the app's name\n-\t\t * @param listener a SdlManagerListener object\n-\t\t */\n-\t\tpublic Builder(@NonNull final String appId, @NonNull final String appName, @NonNull final SdlManagerListener listener){\n-\t\t\tsdlManager = new SdlManager();\n-\t\t\tsetAppId(appId);\n-\t\t\tsetAppName(appName);\n-\t\t\tsetManagerListener(listener);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the App ID\n-\t\t * @param appId String representation of the App ID retreived from the SDL Developer Portal\n-\t\t */\n-\t\tpublic Builder setAppId(@NonNull final String appId){\n-\t\t\tsdlManager.appId = appId;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Application Name\n-\t\t * @param appName String that will be associated as the app's name\n-\t\t */\n-\t\tpublic Builder setAppName(@NonNull final String appName){\n-\t\t\tsdlManager.appName = appName;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Short Application Name\n-\t\t * @param shortAppName a shorter representation of the app's name for smaller displays\n-\t\t */\n-\t\tpublic Builder setShortAppName(final String shortAppName) {\n-\t\t\tsdlManager.shortAppName = shortAppName;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the minimum protocol version that will be permitted to connect.\n-\t\t * If the protocol version of the head unit connected is below this version,\n-\t\t * the app will disconnect with an EndService protocol message and will not register.\n-\t\t * @param minimumProtocolVersion the minimum Protocol spec version that should be accepted\n-\t\t */\n-\t\tpublic Builder setMinimumProtocolVersion(final Version minimumProtocolVersion) {\n-\t\t\tsdlManager.minimumProtocolVersion = minimumProtocolVersion;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * The minimum RPC version that will be permitted to connect.\n-\t\t * If the RPC version of the head unit connected is below this version, an UnregisterAppInterface will be sent.\n-\t\t * @param minimumRPCVersion the minimum RPC spec version that should be accepted\n-\t\t */\n-\t\tpublic Builder setMinimumRPCVersion(final Version minimumRPCVersion) {\n-\t\t\tsdlManager.minimumRPCVersion = minimumRPCVersion;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Language of the App\n-\t\t * @param hmiLanguage the desired language to be used on the display/HMI of the connected module\n-\t\t */\n-\t\tpublic Builder setLanguage(final Language hmiLanguage) {\n-\t\t\tsdlManager.hmiLanguage = hmiLanguage;\n-\t\t\tsdlManager.language = hmiLanguage;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the TemplateColorScheme for daytime\n-\t\t * @param dayColorScheme color scheme that will be used (if supported) when the display is in a \"Day Mode\" or\n-\t\t *                       similar. Should comprise of colors that contrast well during the day under sunlight.\n-\t\t */\n-\t\tpublic Builder setDayColorScheme(final TemplateColorScheme dayColorScheme){\n-\t\t\tsdlManager.dayColorScheme = dayColorScheme;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the TemplateColorScheme for nighttime\n-\t\t * @param nightColorScheme color scheme that will be used (if supported) when the display is in a \"Night Mode\"\n-\t\t *                         or similar. Should comprise of colors that contrast well during the night and are not\n-\t\t *                         brighter than average.\n-\t\t */\n-\t\tpublic Builder setNightColorScheme(final TemplateColorScheme nightColorScheme){\n-\t\t\tsdlManager.nightColorScheme = nightColorScheme;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the icon for the app on head unit / In-Vehicle-Infotainment system <br>\n-\t\t * @param sdlArtwork the icon that will be used to represent this application on the connected module\n-\t\t */\n-\t\tpublic Builder setAppIcon(final SdlArtwork sdlArtwork){\n-\t\t\tsdlManager.appIcon = sdlArtwork;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the vector of AppHMIType <br>\n-\t\t * <strong>Note: This should be an ordered list from most -> least relevant</strong>\n-\t\t * @param hmiTypes HMI types that represent this application. For example, if the app is a music player, the\n-\t\t *                 MEDIA HMIType should be included.\n-\t\t */\n-\t\tpublic Builder setAppTypes(final Vector<AppHMIType> hmiTypes){\n-\n-\t\t\tsdlManager.hmiTypes = hmiTypes;\n-\n-\t\t\tif (hmiTypes != null) {\n-\t\t\t\tsdlManager.isMediaApp = hmiTypes.contains(AppHMIType.MEDIA);\n-\t\t\t}\n-\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the FileManagerConfig for the session.<br>\n-\t\t * <strong>Note: If not set, the default configuration value of 1 will be set for\n-\t\t * artworkRetryCount and fileRetryCount in FileManagerConfig</strong>\n-\t\t * @param fileManagerConfig - configuration options\n-\t\t */\n-\t\tpublic Builder setFileManagerConfig (final FileManagerConfig fileManagerConfig){\n-\t\t\tsdlManager.fileManagerConfig = fileManagerConfig;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the voice recognition synonyms that can be used to identify this application.\n-\t\t * @param vrSynonyms a vector of Strings that can be associated with this app. For example the app's name should\n-\t\t *                   be included as well as any phonetic spellings of the app name that might help the on-board\n-\t\t *                   VR system associated a users spoken word with the supplied synonyms.\n-\t\t */\n-\t\tpublic Builder setVrSynonyms(final Vector<String> vrSynonyms) {\n-\t\t\tsdlManager.vrSynonyms = vrSynonyms;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Text-To-Speech Name of the application. These TTSChunks might be used by the module as an audio\n-\t\t * representation of the app's name.\n-\t\t * @param ttsChunks the TTS chunks that can represent this app's name\n-\t\t */\n-\t\tpublic Builder setTtsName(final Vector<TTSChunk> ttsChunks) {\n-\t\t\tsdlManager.ttsChunks = ttsChunks;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * This Object type may change with the transport refactor\n-\t\t * Sets the BaseTransportConfig\n-\t\t * @param transport the type of transport that should be used for this SdlManager instance.\n-\t\t */\n-\t\tpublic Builder setTransportType(BaseTransportConfig transport){\n-\t\t\tsdlManager.transport = transport;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Security libraries\n-\t\t * @param secList The list of security class(es)\n-\t\t */\n-\t\t@Deprecated\n-\t\tpublic Builder setSdlSecurity(List<Class<? extends SdlSecurityBase>> secList) {\n-\t\t\tsdlManager.sdlSecList = secList;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the security libraries and a callback to notify caller when there is update to encryption service\n-\t\t * @param secList The list of security class(es)\n-\t\t * @param listener The callback object\n-\t\t */\n-\t\tpublic Builder setSdlSecurity(@NonNull List<Class<? extends SdlSecurityBase>> secList, ServiceEncryptionListener listener) {\n-\t\t\tsdlManager.sdlSecList = secList;\n-\t\t\tsdlManager.serviceEncryptionListener = listener;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Set the SdlManager Listener\n-\t\t * @param listener the listener\n-\t\t */\n-\t\tpublic Builder setManagerListener(@NonNull final SdlManagerListener listener){\n-\t\t\tsdlManager.managerListener = listener;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Set RPCNotification listeners. SdlManager will preload these listeners before any RPCs are sent/received.\n-\t\t * @param listeners a map of listeners that will be called when a notification is received.\n-\t\t * Key represents the FunctionID of the notification and value represents the listener\n-\t\t */\n-\t\tpublic Builder setRPCNotificationListeners(Map<FunctionID, OnRPCNotificationListener> listeners){\n-\t\t\tsdlManager.onRPCNotificationListeners = listeners;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\tpublic SdlManager build() {\n-\n-\t\t\tif (sdlManager.appName == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must specify an app name by calling setAppName\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.appId == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must specify an app ID by calling setAppId\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.managerListener == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must set a SdlManagerListener object\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.hmiTypes == null) {\n-\t\t\t\tVector<AppHMIType> hmiTypesDefault = new Vector<>();\n-\t\t\t\thmiTypesDefault.add(AppHMIType.DEFAULT);\n-\t\t\t\tsdlManager.hmiTypes = hmiTypesDefault;\n-\t\t\t\tsdlManager.isMediaApp = false;\n-\t\t\t}\n-\t\t\tif(sdlManager.fileManagerConfig == null){\n-\t\t\t\t//if FileManagerConfig is not set use default\n-\t\t\t\tsdlManager.fileManagerConfig = new FileManagerConfig();\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.hmiLanguage == null) {\n-\t\t\t\tsdlManager.hmiLanguage = Language.EN_US;\n-\t\t\t\tsdlManager.language = Language.EN_US;\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.minimumProtocolVersion == null){\n-\t\t\t\tsdlManager.minimumProtocolVersion = new Version(\"1.0.0\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.minimumRPCVersion == null){\n-\t\t\t\tsdlManager.minimumRPCVersion = new Version(\"1.0.0\");\n-\t\t\t}\n-\n-\t\t\tsdlManager.transitionToState(BaseSubManager.SETTING_UP);\n-\n-\t\t\treturn sdlManager;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Start a secured RPC service\n-\t */\n-\tpublic void startRPCEncryption() {\n-\t\tif (lifecycleManager != null) {\n-\t\t\tlifecycleManager.startRPCEncryption();\n-\t\t}\n-\t}\n+public class SdlManager extends BaseSdlManager {\n+\n+    /**\n+     * Starts up a SdlManager, and calls provided callback called once all BaseSubManagers are done setting up\n+     */\n+    @Override\n+    public void start() {\n+        Runtime.getRuntime().addShutdownHook(new Thread() {\n+            @Override\n+            public void run() {\n+                dispose();\n+            }\n+        });\n+\n+        Log.i(TAG, \"start\");\n+        if (lifecycleManager == null) {\n+            if (transport != null && (transport.getTransportType().equals(TransportType.WEB_SOCKET_SERVER) || transport.getTransportType().equals(TransportType.CUSTOM))) {\n+                super.start();\n+                lifecycleManager.start();\n+            } else {\n+                throw new RuntimeException(\"No transport provided\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void initialize(){\n+        // Instantiate sub managers\n+        this.permissionManager = new PermissionManager(_internalInterface);\n+        this.fileManager = new FileManager(_internalInterface, fileManagerConfig);\n+        this.screenManager = new ScreenManager(_internalInterface, this.fileManager);\n+\n+        // Start sub managers\n+        this.permissionManager.start(subManagerListener);\n+        this.fileManager.start(subManagerListener);\n+        this.screenManager.start(subManagerListener);\n+    }\n+\n+    @Override\n+    void checkState() {\n+        if (permissionManager != null && fileManager != null && screenManager != null ){\n+            if (permissionManager.getState() == BaseSubManager.READY && fileManager.getState() == BaseSubManager.READY && screenManager.getState() == BaseSubManager.READY){\n+                DebugTool.logInfo(\"Starting sdl manager, all sub managers are in ready state\");\n+                transitionToState(BaseSubManager.READY);\n+                handleQueuedNotifications();\n+                notifyDevListener(null);\n+                onReady();\n+            } else if (permissionManager.getState() == BaseSubManager.ERROR && fileManager.getState() == BaseSubManager.ERROR && screenManager.getState() == BaseSubManager.ERROR){", "originalCommit": "e6498f057b86c21310fd5e9d1ba2c593e31ef5a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2NDYwMg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1366#discussion_r438864602", "bodyText": "Add space before '{'", "author": "JulianKast", "createdAt": "2020-06-11T15:20:16Z", "path": "javaSE/src/main/java/com/smartdevicelink/managers/SdlManager.java", "diffHunk": "@@ -89,755 +54,137 @@\n  * 3. Sending Requests <br>\n  * 4. Helper methods\n  */\n-public class SdlManager extends BaseSdlManager{\n-\n-\tprivate static final String TAG = \"SdlManager\";\n-\n-\tprivate SdlArtwork appIcon;\n-\tprivate SdlManagerListener managerListener;\n-\tprivate List<Class<? extends SdlSecurityBase>> sdlSecList;\n-\tprivate ServiceEncryptionListener serviceEncryptionListener;\n-\tprivate FileManagerConfig fileManagerConfig;\n-\n-\t// Managers\n-\tprivate LifecycleManager lifecycleManager;\n-\tprivate PermissionManager permissionManager;\n-\tprivate FileManager fileManager;\n-    private ScreenManager screenManager;\n-\n-\n-\t// INTERNAL INTERFACE\n-\t/**\n-\t * This is from the LifeCycleManager directly. In the future if there is a reason to be a man in the middle\n-\t * the SdlManager could create it's own, however right now it was only a duplication of logic tied to the LCM.\n-\t */\n-\tprivate ISdl _internalInterface;\n-\n-\n-\t// Initialize proxyBridge with anonymous lifecycleListener\n-\tprivate final LifecycleManager.LifecycleListener lifecycleListener = new LifecycleManager.LifecycleListener() {\n-\t\tboolean initStarted = false;\n-\t\t@Override\n-\t\tpublic void onProxyConnected(LifecycleManager lifeCycleManager) {\n-\t\t\tLog.i(TAG,\"Proxy is connected. Now initializing.\");\n-\t\t\tsynchronized (this){\n-\t\t\t\tif(!initStarted){\n-\t\t\t\t\tchangeRegistrationRetry = 0;\n-\t\t\t\t\tcheckLifecycleConfiguration();\n-\t\t\t\t\tinitialize();\n-\t\t\t\t\tinitStarted = true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t@Override\n-\t\tpublic void onServiceStarted(SessionType sessionType){\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onServiceEnded(SessionType sessionType){\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onProxyClosed(LifecycleManager lifeCycleManager, String info, Exception e, SdlDisconnectedReason reason) {\n-\t\t\tLog.i(TAG,\"Proxy is closed.\");\n-\t\t\tif(managerListener != null){\n-\t\t\t\tmanagerListener.onDestroy(SdlManager.this);\n-\t\t\t}\n-\n-\t\t}\n-\n-\n-\t\t@Override\n-\t\tpublic void onError(LifecycleManager lifeCycleManager, String info, Exception e) {\n-\n-\t\t}\n-\t};\n-\n-\t// Sub manager listener\n-\tprivate final CompletionListener subManagerListener = new CompletionListener() {\n-\t\t@Override\n-\t\tpublic synchronized void onComplete(boolean success) {\n-\t\t\tif(!success){\n-\t\t\t\tLog.e(TAG, \"Sub manager failed to initialize\");\n-\t\t\t}\n-\t\t\tcheckState();\n-\t\t}\n-\t};\n-\n-\t@Override\n-\tvoid checkState() {\n-\t\tif (permissionManager != null && fileManager != null && screenManager != null ){\n-\t\t\tif (permissionManager.getState() == BaseSubManager.READY && fileManager.getState() == BaseSubManager.READY && screenManager.getState() == BaseSubManager.READY){\n-\t\t\t\tDebugTool.logInfo(\"Starting sdl manager, all sub managers are in ready state\");\n-\t\t\t\ttransitionToState(BaseSubManager.READY);\n-\t\t\t\thandleQueuedNotifications();\n-\t\t\t\tnotifyDevListener(null);\n-\t\t\t\tonReady();\n-\t\t\t} else if (permissionManager.getState() == BaseSubManager.ERROR && fileManager.getState() == BaseSubManager.ERROR && screenManager.getState() == BaseSubManager.ERROR){\n-\t\t\t\tString info = \"ERROR starting sdl manager, all sub managers are in error state\";\n-\t\t\t\tLog.e(TAG, info);\n-\t\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t\t\tnotifyDevListener(info);\n-\t\t\t} else if (permissionManager.getState() == BaseSubManager.SETTING_UP || fileManager.getState() == BaseSubManager.SETTING_UP || screenManager.getState() == BaseSubManager.SETTING_UP) {\n-\t\t\t\tDebugTool.logInfo(\"SETTING UP sdl manager, some sub managers are still setting up\");\n-\t\t\t\ttransitionToState(BaseSubManager.SETTING_UP);\n-\t\t\t\t// No need to notify developer here!\n-\t\t\t} else {\n-\t\t\t\tLog.w(TAG, \"LIMITED starting sdl manager, some sub managers are in error or limited state and the others finished setting up\");\n-\t\t\t\ttransitionToState(BaseSubManager.LIMITED);\n-\t\t\t\thandleQueuedNotifications();\n-\t\t\t\tnotifyDevListener(null);\n-\t\t\t\tonReady();\n-\t\t\t}\n-\t\t} else {\n-\t\t\t// We should never be here, but somehow one of the sub-sub managers is null\n-\t\t\tString info = \"ERROR one of the sdl sub managers is null\";\n-\t\t\tLog.e(TAG, info);\n-\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t\tnotifyDevListener(info);\n-\t\t}\n-\t}\n-\n-\tprivate void notifyDevListener(String info) {\n-\t\tif (managerListener != null) {\n-\t\t\tif (getState() == BaseSubManager.ERROR){\n-\t\t\t\tmanagerListener.onError(this, info, null);\n-\t\t\t} else {\n-\t\t\t\tmanagerListener.onStart(this);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void onReady(){\n-\t\t// Set the app icon\n-\t\t if (SdlManager.this.appIcon != null && SdlManager.this.appIcon.getName() != null) {\n-\t\t\tif (fileManager != null && fileManager.getState() == BaseSubManager.READY && !fileManager.hasUploadedFile(SdlManager.this.appIcon)) {\n-\t\t\t\tfileManager.uploadArtwork(SdlManager.this.appIcon, new CompletionListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\t\t\tif (success) {\n-\t\t\t\t\t\t\tSetAppIcon msg = new SetAppIcon(SdlManager.this.appIcon.getName());\n-\t\t\t\t\t\t\t_internalInterface.sendRPCRequest(msg);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t} else {\n-\t\t\t\tSetAppIcon msg = new SetAppIcon(SdlManager.this.appIcon.getName());\n-\t\t\t\t_internalInterface.sendRPCRequest(msg);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void checkLifecycleConfiguration(){\n-\t\tfinal Language actualLanguage =  this.getRegisterAppInterfaceResponse().getLanguage();\n-\t\tfinal Language actualHMILanguage =  this.getRegisterAppInterfaceResponse().getHmiDisplayLanguage();\n-\n-\t\tif ((actualLanguage != null && !actualLanguage.equals(language)) || (actualHMILanguage != null && !actualHMILanguage.equals(hmiLanguage))) {\n-\n-\t\t\tLifecycleConfigurationUpdate lcuNew = managerListener.managerShouldUpdateLifecycle(actualLanguage, actualHMILanguage);\n-\t\t\tLifecycleConfigurationUpdate lcuOld = managerListener.managerShouldUpdateLifecycle(actualLanguage);\n-\t\t\tfinal LifecycleConfigurationUpdate lcu;\n-\t\t\tChangeRegistration changeRegistration;\n-\t\t\tif (lcuNew == null) {\n-\t\t\t\tlcu = lcuOld;\n-\t\t\t\tchangeRegistration = new ChangeRegistration(actualLanguage, actualLanguage);\n-\t\t\t} else {\n-\t\t\t\tlcu = lcuNew;\n-\t\t\t\tchangeRegistration = new ChangeRegistration(actualLanguage, actualHMILanguage);\n-\t\t\t}\n-\n-\t\t\tif (lcu != null) {\n-\t\t\t\tchangeRegistration.setAppName(lcu.getAppName());\n-\t\t\t\tchangeRegistration.setNgnMediaScreenAppName(lcu.getShortAppName());\n-\t\t\t\tchangeRegistration.setTtsName(lcu.getTtsName());\n-\t\t\t\tchangeRegistration.setVrSynonyms(lcu.getVoiceRecognitionCommandNames());\n-\t\t\t\tchangeRegistration.setOnRPCResponseListener(new OnRPCResponseListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onResponse(int correlationId, RPCResponse response) {\n-\t\t\t\t\t\tif (response.getSuccess()){\n-\t\t\t\t\t\t\t// go through and change sdlManager properties that were changed via the LCU update\n-\t\t\t\t\t\t\thmiLanguage = actualHMILanguage;\n-\t\t\t\t\t\t\tlanguage = actualLanguage;\n-\n-\t\t\t\t\t\t\tif (lcu.getAppName() != null) {\n-\t\t\t\t\t\t\t\tappName = lcu.getAppName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getShortAppName() != null) {\n-\t\t\t\t\t\t\t\tshortAppName = lcu.getShortAppName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getTtsName() != null) {\n-\t\t\t\t\t\t\t\tttsChunks = lcu.getTtsName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getVoiceRecognitionCommandNames() != null) {\n-\t\t\t\t\t\t\t\tvrSynonyms = lcu.getVoiceRecognitionCommandNames();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tLog.v(TAG, response.serializeJSON().toString());\n-\t\t\t\t\t\t} catch (JSONException e) {\n-\t\t\t\t\t\t\te.printStackTrace();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onError(int correlationId, Result resultCode, String info) {\n-\t\t\t\t\t\tLog.e(TAG, \"Change Registration onError: \" + resultCode + \" | Info: \" + info);\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t\t_internalInterface.sendRPC(changeRegistration);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void initialize(){\n-\t\t// Instantiate sub managers\n-\t\tthis.permissionManager = new PermissionManager(_internalInterface);\n-\t\tthis.fileManager = new FileManager(_internalInterface, fileManagerConfig);\n-\t\tthis.screenManager = new ScreenManager(_internalInterface, this.fileManager);\n-\n-\t\t// Start sub managers\n-\t\tthis.permissionManager.start(subManagerListener);\n-\t\tthis.fileManager.start(subManagerListener);\n-\t\tthis.screenManager.start(subManagerListener);\n-\t}\n-\n-\t@Override\n-\tpublic void dispose() {\n-\t\tif (this.permissionManager != null) {\n-\t\t\tthis.permissionManager.dispose();\n-\t\t}\n-\n-\t\tif (this.fileManager != null) {\n-\t\t\tthis.fileManager.dispose();\n-\t\t}\n-\n-\t\tif (this.screenManager != null) {\n-\t\t\tthis.screenManager.dispose();\n-\t\t}\n-\n-\t\tif (this.lifecycleManager != null) {\n-\t\t\tthis.lifecycleManager.stop();\n-\t\t}\n-\n-\t\tif(managerListener != null){\n-\t\t\tmanagerListener.onDestroy(this);\n-\t\t\tmanagerListener = null;\n-\t\t}\n-\n-\t\ttransitionToState(BaseSubManager.SHUTDOWN);\n-\t}\n-\n-\n-\t// MANAGER GETTERS\n-\t/**\n-\t * Gets the PermissionManager. <br>\n-\t * <strong>Note: PermissionManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a PermissionManager object\n-\t */\n-\tpublic PermissionManager getPermissionManager() {\n-\t\tif (permissionManager.getState() != BaseSubManager.READY && permissionManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG,\"PermissionManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn permissionManager;\n-\t}\n-\n-\t/**\n-\t * Gets the FileManager. <br>\n-\t * <strong>Note: FileManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a FileManager object\n-\t */\n-\tpublic FileManager getFileManager() {\n-\t\tif (fileManager.getState() != BaseSubManager.READY && fileManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG, \"FileManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn fileManager;\n-\t}\n-\n-\t/**\n-\t * Gets the ScreenManager. <br>\n-\t * <strong>Note: ScreenManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a ScreenManager object\n-\t */\n-\tpublic ScreenManager getScreenManager() {\n-\t\tif (screenManager.getState() != BaseSubManager.READY && screenManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG, \"ScreenManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn screenManager;\n-\t}\n-\n-\t/**\n-\t * Gets the SystemCapabilityManager. <br>\n-\t * <strong>Note: SystemCapabilityManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a SystemCapabilityManager object\n-\t */\n-\tpublic SystemCapabilityManager getSystemCapabilityManager(){\n-\t\treturn lifecycleManager.getSystemCapabilityManager(this);\n-\t}\n-\n-\t/**\n-\t * Method to retrieve the RegisterAppInterface Response message that was sent back from the\n-\t * module. It contains various attributes about the connected module and can be used to adapt\n-\t * to different module types and their supported features.\n-\t *\n-\t * @return RegisterAppInterfaceResponse received from the module or null if the app has not yet\n-\t * registered with the module.\n-\t */\n-\t@Override\n-\tpublic RegisterAppInterfaceResponse getRegisterAppInterfaceResponse(){\n-\t\tif(lifecycleManager != null){\n-\t\t\treturn lifecycleManager.getRegisterAppInterfaceResponse();\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\t/**\n-\t * Get the current OnHMIStatus\n-\t * @return OnHMIStatus object represents the current OnHMIStatus\n-\t */\n-\t@Override\n-\tpublic OnHMIStatus getCurrentHMIStatus(){\n-\t\tif(this.lifecycleManager !=null ){\n-\t\t\treturn lifecycleManager.getCurrentHMIStatus();\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\t// PROTECTED GETTERS\n-\n-\tprotected FileManagerConfig getFileManagerConfig() { return fileManagerConfig; }\n-\n-\t/**\n-\t * Retrieves the auth token, if any, that was attached to the StartServiceACK for the RPC\n-\t * service from the module. For example, this should be used to login to a user account.\n-\t * @return the string representation of the auth token\n-\t */\n-\t@Override\n-\tpublic String getAuthToken(){\n-\t\treturn this.lifecycleManager.getAuthToken();\n-\t}\n-\n-\t// SENDING REQUESTS\n-\n-\t/**\n-\t * Send RPC Message <br>\n-\t * @param message RPCMessage\n-\t */\n-\t@Override\n-\tpublic void sendRPC(RPCMessage message) {\n-\t\t_internalInterface.sendRPC(message);\n-\t}\n-\n-\t/**\n-\t * Takes a list of RPCMessages and sends it to SDL in a synchronous fashion. Responses are captured through callback on OnMultipleRequestListener.\n-\t * For sending requests asynchronously, use sendRequests <br>\n-\t *\n-\t * <strong>NOTE: This will override any listeners on individual RPCs</strong><br>\n-\t *\n-\t * <strong>ADDITIONAL NOTE: This only takes the type of RPCRequest for now, notifications and responses will be thrown out</strong>\n-\t *\n-\t * @param rpcs is the list of RPCMessages being sent\n-\t * @param listener listener for updates and completions\n-\t */\n-\t@Override\n-\tpublic void sendSequentialRPCs(final List<? extends RPCMessage> rpcs, final OnMultipleRequestListener listener){\n-\n-\t\tList<RPCRequest> rpcRequestList = new ArrayList<>();\n-\t\tfor (int i = 0; i < rpcs.size(); i++) {\n-\t\t\tif (rpcs.get(i) instanceof RPCRequest){\n-\t\t\t\trpcRequestList.add((RPCRequest)rpcs.get(i));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (rpcRequestList.size() > 0) {\n-\t\t\t_internalInterface.sendSequentialRPCs(rpcRequestList, listener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Takes a list of RPCMessages and sends it to SDL. Responses are captured through callback on OnMultipleRequestListener.\n-\t * For sending requests synchronously, use sendSequentialRPCs <br>\n-\t *\n-\t * <strong>NOTE: This will override any listeners on individual RPCs</strong> <br>\n-\t *\n-\t * <strong>ADDITIONAL NOTE: This only takes the type of RPCRequest for now, notifications and responses will be thrown out</strong>\n-\t *\n-\t * @param rpcs is the list of RPCMessages being sent\n-\t * @param listener listener for updates and completions\n-\t */\n-\t@Override\n-\tpublic void sendRPCs(List<? extends RPCMessage> rpcs, final OnMultipleRequestListener listener) {\n-\n-\t\tList<RPCRequest> rpcRequestList = new ArrayList<>();\n-\t\tfor (int i = 0; i < rpcs.size(); i++) {\n-\t\t\tif (rpcs.get(i) instanceof RPCRequest){\n-\t\t\t\trpcRequestList.add((RPCRequest)rpcs.get(i));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (rpcRequestList.size() > 0) {\n-\t\t\t_internalInterface.sendRequests(rpcRequestList,listener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Add an OnRPCNotificationListener\n-\t * @param listener listener that will be called when a notification is received\n-\t */\n-\t@Override\n-\tpublic void addOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener){\n-\t\t_internalInterface.addOnRPCNotificationListener(notificationId,listener);\n-\t}\n-\n-\t/**\n-\t * Remove an OnRPCNotificationListener\n-\t * @param listener listener that was previously added\n-\t */\n-\t@Override\n-\tpublic void removeOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener){\n-\t\t_internalInterface.removeOnRPCNotificationListener(notificationId, listener);\n-\t}\n-\n-\t/**\n-\t * Add an OnRPCRequestListener\n-\t * @param listener listener that will be called when a request is received\n-\t */\n-\t@Override\n-\tpublic void addOnRPCRequestListener(FunctionID requestId, OnRPCRequestListener listener){\n-\t\t_internalInterface.addOnRPCRequestListener(requestId,listener);\n-\t}\n-\n-\t/**\n-\t * Remove an OnRPCRequestListener\n-\t * @param listener listener that was previously added\n-\t */\n-\t@Override\n-\tpublic void removeOnRPCRequestListener(FunctionID requestId, OnRPCRequestListener listener){\n-\t\t_internalInterface.removeOnRPCRequestListener(requestId, listener);\n-\t}\n-\n-\t// LIFECYCLE / OTHER\n-\n-\t// STARTUP\n-\n-\t/**\n-\t * Starts up a SdlManager, and calls provided callback called once all BaseSubManagers are done setting up\n-\t */\n-\t@SuppressWarnings(\"unchecked\")\n-\t@Override\n-\tpublic void start(){\n-\n-\t\tRuntime.getRuntime().addShutdownHook(new Thread() {\n-\t\t\t@Override\n-\t\t\tpublic void run() {\n-\t\t\t\tdispose();\n-\t\t\t}\n-\t\t});\n-\n-\t\tLog.i(TAG, \"start\");\n-\t\tif (lifecycleManager == null) {\n-\t\t\tif (transport != null\n-\t\t\t\t\t&& (transport.getTransportType().equals(TransportType.WEB_SOCKET_SERVER) || transport.getTransportType().equals(TransportType.CUSTOM))) {\n-\t\t\t\t//Do the thing\n-\n-\t\t\t\tLifecycleManager.AppConfig appConfig = new LifecycleManager.AppConfig();\n-\t\t\t\tappConfig.setAppName(appName);\n-\t\t\t\t//short app name\n-\t\t\t\tappConfig.setMediaApp(isMediaApp);\n-\t\t\t\tappConfig.setHmiDisplayLanguageDesired(hmiLanguage);\n-\t\t\t\tappConfig.setLanguageDesired(hmiLanguage);\n-\t\t\t\tappConfig.setAppType(hmiTypes);\n-\t\t\t\tappConfig.setVrSynonyms(vrSynonyms);\n-\t\t\t\tappConfig.setTtsName(ttsChunks);\n-\t\t\t\tappConfig.setDayColorScheme(dayColorScheme);\n-\t\t\t\tappConfig.setNightColorScheme(nightColorScheme);\n-\t\t\t\tappConfig.setAppID(appId);\n-\t\t\t\tappConfig.setMinimumProtocolVersion(minimumProtocolVersion);\n-\t\t\t\tappConfig.setMinimumRPCVersion(minimumRPCVersion);\n-\n-\t\t\t\tlifecycleManager = new LifecycleManager(appConfig, transport, lifecycleListener);\n-\t\t\t\t_internalInterface = lifecycleManager.getInternalInterface(SdlManager.this);\n-\n-\t\t\t\tif (sdlSecList != null && !sdlSecList.isEmpty()) {\n-\t\t\t\t\tlifecycleManager.setSdlSecurity(sdlSecList, serviceEncryptionListener);\n-\t\t\t\t}\n-\n-\t\t\t\t//Setup the notification queue\n-\t\t\t\tinitNotificationQueue();\n-\n-\t\t\t\tlifecycleManager.start();\n-\n-\n-\t\t\t}else{\n-\t\t\t\tthrow new RuntimeException(\"No transport provided\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\n-\t// BUILDER\n-\tpublic static class Builder {\n-\t\tSdlManager sdlManager;\n-\n-\t\t/**\n-\t\t * Builder for the SdlManager. Parameters in the constructor are required.\n-\t\t * @param appId the app's ID\n-\t\t * @param appName the app's name\n-\t\t * @param listener a SdlManagerListener object\n-\t\t */\n-\t\tpublic Builder(@NonNull final String appId, @NonNull final String appName, @NonNull final SdlManagerListener listener){\n-\t\t\tsdlManager = new SdlManager();\n-\t\t\tsetAppId(appId);\n-\t\t\tsetAppName(appName);\n-\t\t\tsetManagerListener(listener);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the App ID\n-\t\t * @param appId String representation of the App ID retreived from the SDL Developer Portal\n-\t\t */\n-\t\tpublic Builder setAppId(@NonNull final String appId){\n-\t\t\tsdlManager.appId = appId;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Application Name\n-\t\t * @param appName String that will be associated as the app's name\n-\t\t */\n-\t\tpublic Builder setAppName(@NonNull final String appName){\n-\t\t\tsdlManager.appName = appName;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Short Application Name\n-\t\t * @param shortAppName a shorter representation of the app's name for smaller displays\n-\t\t */\n-\t\tpublic Builder setShortAppName(final String shortAppName) {\n-\t\t\tsdlManager.shortAppName = shortAppName;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the minimum protocol version that will be permitted to connect.\n-\t\t * If the protocol version of the head unit connected is below this version,\n-\t\t * the app will disconnect with an EndService protocol message and will not register.\n-\t\t * @param minimumProtocolVersion the minimum Protocol spec version that should be accepted\n-\t\t */\n-\t\tpublic Builder setMinimumProtocolVersion(final Version minimumProtocolVersion) {\n-\t\t\tsdlManager.minimumProtocolVersion = minimumProtocolVersion;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * The minimum RPC version that will be permitted to connect.\n-\t\t * If the RPC version of the head unit connected is below this version, an UnregisterAppInterface will be sent.\n-\t\t * @param minimumRPCVersion the minimum RPC spec version that should be accepted\n-\t\t */\n-\t\tpublic Builder setMinimumRPCVersion(final Version minimumRPCVersion) {\n-\t\t\tsdlManager.minimumRPCVersion = minimumRPCVersion;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Language of the App\n-\t\t * @param hmiLanguage the desired language to be used on the display/HMI of the connected module\n-\t\t */\n-\t\tpublic Builder setLanguage(final Language hmiLanguage) {\n-\t\t\tsdlManager.hmiLanguage = hmiLanguage;\n-\t\t\tsdlManager.language = hmiLanguage;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the TemplateColorScheme for daytime\n-\t\t * @param dayColorScheme color scheme that will be used (if supported) when the display is in a \"Day Mode\" or\n-\t\t *                       similar. Should comprise of colors that contrast well during the day under sunlight.\n-\t\t */\n-\t\tpublic Builder setDayColorScheme(final TemplateColorScheme dayColorScheme){\n-\t\t\tsdlManager.dayColorScheme = dayColorScheme;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the TemplateColorScheme for nighttime\n-\t\t * @param nightColorScheme color scheme that will be used (if supported) when the display is in a \"Night Mode\"\n-\t\t *                         or similar. Should comprise of colors that contrast well during the night and are not\n-\t\t *                         brighter than average.\n-\t\t */\n-\t\tpublic Builder setNightColorScheme(final TemplateColorScheme nightColorScheme){\n-\t\t\tsdlManager.nightColorScheme = nightColorScheme;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the icon for the app on head unit / In-Vehicle-Infotainment system <br>\n-\t\t * @param sdlArtwork the icon that will be used to represent this application on the connected module\n-\t\t */\n-\t\tpublic Builder setAppIcon(final SdlArtwork sdlArtwork){\n-\t\t\tsdlManager.appIcon = sdlArtwork;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the vector of AppHMIType <br>\n-\t\t * <strong>Note: This should be an ordered list from most -> least relevant</strong>\n-\t\t * @param hmiTypes HMI types that represent this application. For example, if the app is a music player, the\n-\t\t *                 MEDIA HMIType should be included.\n-\t\t */\n-\t\tpublic Builder setAppTypes(final Vector<AppHMIType> hmiTypes){\n-\n-\t\t\tsdlManager.hmiTypes = hmiTypes;\n-\n-\t\t\tif (hmiTypes != null) {\n-\t\t\t\tsdlManager.isMediaApp = hmiTypes.contains(AppHMIType.MEDIA);\n-\t\t\t}\n-\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the FileManagerConfig for the session.<br>\n-\t\t * <strong>Note: If not set, the default configuration value of 1 will be set for\n-\t\t * artworkRetryCount and fileRetryCount in FileManagerConfig</strong>\n-\t\t * @param fileManagerConfig - configuration options\n-\t\t */\n-\t\tpublic Builder setFileManagerConfig (final FileManagerConfig fileManagerConfig){\n-\t\t\tsdlManager.fileManagerConfig = fileManagerConfig;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the voice recognition synonyms that can be used to identify this application.\n-\t\t * @param vrSynonyms a vector of Strings that can be associated with this app. For example the app's name should\n-\t\t *                   be included as well as any phonetic spellings of the app name that might help the on-board\n-\t\t *                   VR system associated a users spoken word with the supplied synonyms.\n-\t\t */\n-\t\tpublic Builder setVrSynonyms(final Vector<String> vrSynonyms) {\n-\t\t\tsdlManager.vrSynonyms = vrSynonyms;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Text-To-Speech Name of the application. These TTSChunks might be used by the module as an audio\n-\t\t * representation of the app's name.\n-\t\t * @param ttsChunks the TTS chunks that can represent this app's name\n-\t\t */\n-\t\tpublic Builder setTtsName(final Vector<TTSChunk> ttsChunks) {\n-\t\t\tsdlManager.ttsChunks = ttsChunks;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * This Object type may change with the transport refactor\n-\t\t * Sets the BaseTransportConfig\n-\t\t * @param transport the type of transport that should be used for this SdlManager instance.\n-\t\t */\n-\t\tpublic Builder setTransportType(BaseTransportConfig transport){\n-\t\t\tsdlManager.transport = transport;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Security libraries\n-\t\t * @param secList The list of security class(es)\n-\t\t */\n-\t\t@Deprecated\n-\t\tpublic Builder setSdlSecurity(List<Class<? extends SdlSecurityBase>> secList) {\n-\t\t\tsdlManager.sdlSecList = secList;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the security libraries and a callback to notify caller when there is update to encryption service\n-\t\t * @param secList The list of security class(es)\n-\t\t * @param listener The callback object\n-\t\t */\n-\t\tpublic Builder setSdlSecurity(@NonNull List<Class<? extends SdlSecurityBase>> secList, ServiceEncryptionListener listener) {\n-\t\t\tsdlManager.sdlSecList = secList;\n-\t\t\tsdlManager.serviceEncryptionListener = listener;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Set the SdlManager Listener\n-\t\t * @param listener the listener\n-\t\t */\n-\t\tpublic Builder setManagerListener(@NonNull final SdlManagerListener listener){\n-\t\t\tsdlManager.managerListener = listener;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Set RPCNotification listeners. SdlManager will preload these listeners before any RPCs are sent/received.\n-\t\t * @param listeners a map of listeners that will be called when a notification is received.\n-\t\t * Key represents the FunctionID of the notification and value represents the listener\n-\t\t */\n-\t\tpublic Builder setRPCNotificationListeners(Map<FunctionID, OnRPCNotificationListener> listeners){\n-\t\t\tsdlManager.onRPCNotificationListeners = listeners;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\tpublic SdlManager build() {\n-\n-\t\t\tif (sdlManager.appName == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must specify an app name by calling setAppName\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.appId == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must specify an app ID by calling setAppId\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.managerListener == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must set a SdlManagerListener object\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.hmiTypes == null) {\n-\t\t\t\tVector<AppHMIType> hmiTypesDefault = new Vector<>();\n-\t\t\t\thmiTypesDefault.add(AppHMIType.DEFAULT);\n-\t\t\t\tsdlManager.hmiTypes = hmiTypesDefault;\n-\t\t\t\tsdlManager.isMediaApp = false;\n-\t\t\t}\n-\t\t\tif(sdlManager.fileManagerConfig == null){\n-\t\t\t\t//if FileManagerConfig is not set use default\n-\t\t\t\tsdlManager.fileManagerConfig = new FileManagerConfig();\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.hmiLanguage == null) {\n-\t\t\t\tsdlManager.hmiLanguage = Language.EN_US;\n-\t\t\t\tsdlManager.language = Language.EN_US;\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.minimumProtocolVersion == null){\n-\t\t\t\tsdlManager.minimumProtocolVersion = new Version(\"1.0.0\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.minimumRPCVersion == null){\n-\t\t\t\tsdlManager.minimumRPCVersion = new Version(\"1.0.0\");\n-\t\t\t}\n-\n-\t\t\tsdlManager.transitionToState(BaseSubManager.SETTING_UP);\n-\n-\t\t\treturn sdlManager;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Start a secured RPC service\n-\t */\n-\tpublic void startRPCEncryption() {\n-\t\tif (lifecycleManager != null) {\n-\t\t\tlifecycleManager.startRPCEncryption();\n-\t\t}\n-\t}\n+public class SdlManager extends BaseSdlManager {\n+\n+    /**\n+     * Starts up a SdlManager, and calls provided callback called once all BaseSubManagers are done setting up\n+     */\n+    @Override\n+    public void start() {\n+        Runtime.getRuntime().addShutdownHook(new Thread() {\n+            @Override\n+            public void run() {\n+                dispose();\n+            }\n+        });\n+\n+        Log.i(TAG, \"start\");\n+        if (lifecycleManager == null) {\n+            if (transport != null && (transport.getTransportType().equals(TransportType.WEB_SOCKET_SERVER) || transport.getTransportType().equals(TransportType.CUSTOM))) {\n+                super.start();\n+                lifecycleManager.start();\n+            } else {\n+                throw new RuntimeException(\"No transport provided\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void initialize(){\n+        // Instantiate sub managers\n+        this.permissionManager = new PermissionManager(_internalInterface);\n+        this.fileManager = new FileManager(_internalInterface, fileManagerConfig);\n+        this.screenManager = new ScreenManager(_internalInterface, this.fileManager);\n+\n+        // Start sub managers\n+        this.permissionManager.start(subManagerListener);\n+        this.fileManager.start(subManagerListener);\n+        this.screenManager.start(subManagerListener);\n+    }\n+\n+    @Override\n+    void checkState() {\n+        if (permissionManager != null && fileManager != null && screenManager != null ){\n+            if (permissionManager.getState() == BaseSubManager.READY && fileManager.getState() == BaseSubManager.READY && screenManager.getState() == BaseSubManager.READY){", "originalCommit": "e6498f057b86c21310fd5e9d1ba2c593e31ef5a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODg2NDY3MQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1366#discussion_r438864671", "bodyText": "Add space before '{'", "author": "JulianKast", "createdAt": "2020-06-11T15:20:21Z", "path": "javaSE/src/main/java/com/smartdevicelink/managers/SdlManager.java", "diffHunk": "@@ -89,755 +54,137 @@\n  * 3. Sending Requests <br>\n  * 4. Helper methods\n  */\n-public class SdlManager extends BaseSdlManager{\n-\n-\tprivate static final String TAG = \"SdlManager\";\n-\n-\tprivate SdlArtwork appIcon;\n-\tprivate SdlManagerListener managerListener;\n-\tprivate List<Class<? extends SdlSecurityBase>> sdlSecList;\n-\tprivate ServiceEncryptionListener serviceEncryptionListener;\n-\tprivate FileManagerConfig fileManagerConfig;\n-\n-\t// Managers\n-\tprivate LifecycleManager lifecycleManager;\n-\tprivate PermissionManager permissionManager;\n-\tprivate FileManager fileManager;\n-    private ScreenManager screenManager;\n-\n-\n-\t// INTERNAL INTERFACE\n-\t/**\n-\t * This is from the LifeCycleManager directly. In the future if there is a reason to be a man in the middle\n-\t * the SdlManager could create it's own, however right now it was only a duplication of logic tied to the LCM.\n-\t */\n-\tprivate ISdl _internalInterface;\n-\n-\n-\t// Initialize proxyBridge with anonymous lifecycleListener\n-\tprivate final LifecycleManager.LifecycleListener lifecycleListener = new LifecycleManager.LifecycleListener() {\n-\t\tboolean initStarted = false;\n-\t\t@Override\n-\t\tpublic void onProxyConnected(LifecycleManager lifeCycleManager) {\n-\t\t\tLog.i(TAG,\"Proxy is connected. Now initializing.\");\n-\t\t\tsynchronized (this){\n-\t\t\t\tif(!initStarted){\n-\t\t\t\t\tchangeRegistrationRetry = 0;\n-\t\t\t\t\tcheckLifecycleConfiguration();\n-\t\t\t\t\tinitialize();\n-\t\t\t\t\tinitStarted = true;\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t@Override\n-\t\tpublic void onServiceStarted(SessionType sessionType){\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onServiceEnded(SessionType sessionType){\n-\n-\t\t}\n-\n-\t\t@Override\n-\t\tpublic void onProxyClosed(LifecycleManager lifeCycleManager, String info, Exception e, SdlDisconnectedReason reason) {\n-\t\t\tLog.i(TAG,\"Proxy is closed.\");\n-\t\t\tif(managerListener != null){\n-\t\t\t\tmanagerListener.onDestroy(SdlManager.this);\n-\t\t\t}\n-\n-\t\t}\n-\n-\n-\t\t@Override\n-\t\tpublic void onError(LifecycleManager lifeCycleManager, String info, Exception e) {\n-\n-\t\t}\n-\t};\n-\n-\t// Sub manager listener\n-\tprivate final CompletionListener subManagerListener = new CompletionListener() {\n-\t\t@Override\n-\t\tpublic synchronized void onComplete(boolean success) {\n-\t\t\tif(!success){\n-\t\t\t\tLog.e(TAG, \"Sub manager failed to initialize\");\n-\t\t\t}\n-\t\t\tcheckState();\n-\t\t}\n-\t};\n-\n-\t@Override\n-\tvoid checkState() {\n-\t\tif (permissionManager != null && fileManager != null && screenManager != null ){\n-\t\t\tif (permissionManager.getState() == BaseSubManager.READY && fileManager.getState() == BaseSubManager.READY && screenManager.getState() == BaseSubManager.READY){\n-\t\t\t\tDebugTool.logInfo(\"Starting sdl manager, all sub managers are in ready state\");\n-\t\t\t\ttransitionToState(BaseSubManager.READY);\n-\t\t\t\thandleQueuedNotifications();\n-\t\t\t\tnotifyDevListener(null);\n-\t\t\t\tonReady();\n-\t\t\t} else if (permissionManager.getState() == BaseSubManager.ERROR && fileManager.getState() == BaseSubManager.ERROR && screenManager.getState() == BaseSubManager.ERROR){\n-\t\t\t\tString info = \"ERROR starting sdl manager, all sub managers are in error state\";\n-\t\t\t\tLog.e(TAG, info);\n-\t\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t\t\tnotifyDevListener(info);\n-\t\t\t} else if (permissionManager.getState() == BaseSubManager.SETTING_UP || fileManager.getState() == BaseSubManager.SETTING_UP || screenManager.getState() == BaseSubManager.SETTING_UP) {\n-\t\t\t\tDebugTool.logInfo(\"SETTING UP sdl manager, some sub managers are still setting up\");\n-\t\t\t\ttransitionToState(BaseSubManager.SETTING_UP);\n-\t\t\t\t// No need to notify developer here!\n-\t\t\t} else {\n-\t\t\t\tLog.w(TAG, \"LIMITED starting sdl manager, some sub managers are in error or limited state and the others finished setting up\");\n-\t\t\t\ttransitionToState(BaseSubManager.LIMITED);\n-\t\t\t\thandleQueuedNotifications();\n-\t\t\t\tnotifyDevListener(null);\n-\t\t\t\tonReady();\n-\t\t\t}\n-\t\t} else {\n-\t\t\t// We should never be here, but somehow one of the sub-sub managers is null\n-\t\t\tString info = \"ERROR one of the sdl sub managers is null\";\n-\t\t\tLog.e(TAG, info);\n-\t\t\ttransitionToState(BaseSubManager.ERROR);\n-\t\t\tnotifyDevListener(info);\n-\t\t}\n-\t}\n-\n-\tprivate void notifyDevListener(String info) {\n-\t\tif (managerListener != null) {\n-\t\t\tif (getState() == BaseSubManager.ERROR){\n-\t\t\t\tmanagerListener.onError(this, info, null);\n-\t\t\t} else {\n-\t\t\t\tmanagerListener.onStart(this);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\tprivate void onReady(){\n-\t\t// Set the app icon\n-\t\t if (SdlManager.this.appIcon != null && SdlManager.this.appIcon.getName() != null) {\n-\t\t\tif (fileManager != null && fileManager.getState() == BaseSubManager.READY && !fileManager.hasUploadedFile(SdlManager.this.appIcon)) {\n-\t\t\t\tfileManager.uploadArtwork(SdlManager.this.appIcon, new CompletionListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onComplete(boolean success) {\n-\t\t\t\t\t\tif (success) {\n-\t\t\t\t\t\t\tSetAppIcon msg = new SetAppIcon(SdlManager.this.appIcon.getName());\n-\t\t\t\t\t\t\t_internalInterface.sendRPCRequest(msg);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t} else {\n-\t\t\t\tSetAppIcon msg = new SetAppIcon(SdlManager.this.appIcon.getName());\n-\t\t\t\t_internalInterface.sendRPCRequest(msg);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void checkLifecycleConfiguration(){\n-\t\tfinal Language actualLanguage =  this.getRegisterAppInterfaceResponse().getLanguage();\n-\t\tfinal Language actualHMILanguage =  this.getRegisterAppInterfaceResponse().getHmiDisplayLanguage();\n-\n-\t\tif ((actualLanguage != null && !actualLanguage.equals(language)) || (actualHMILanguage != null && !actualHMILanguage.equals(hmiLanguage))) {\n-\n-\t\t\tLifecycleConfigurationUpdate lcuNew = managerListener.managerShouldUpdateLifecycle(actualLanguage, actualHMILanguage);\n-\t\t\tLifecycleConfigurationUpdate lcuOld = managerListener.managerShouldUpdateLifecycle(actualLanguage);\n-\t\t\tfinal LifecycleConfigurationUpdate lcu;\n-\t\t\tChangeRegistration changeRegistration;\n-\t\t\tif (lcuNew == null) {\n-\t\t\t\tlcu = lcuOld;\n-\t\t\t\tchangeRegistration = new ChangeRegistration(actualLanguage, actualLanguage);\n-\t\t\t} else {\n-\t\t\t\tlcu = lcuNew;\n-\t\t\t\tchangeRegistration = new ChangeRegistration(actualLanguage, actualHMILanguage);\n-\t\t\t}\n-\n-\t\t\tif (lcu != null) {\n-\t\t\t\tchangeRegistration.setAppName(lcu.getAppName());\n-\t\t\t\tchangeRegistration.setNgnMediaScreenAppName(lcu.getShortAppName());\n-\t\t\t\tchangeRegistration.setTtsName(lcu.getTtsName());\n-\t\t\t\tchangeRegistration.setVrSynonyms(lcu.getVoiceRecognitionCommandNames());\n-\t\t\t\tchangeRegistration.setOnRPCResponseListener(new OnRPCResponseListener() {\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onResponse(int correlationId, RPCResponse response) {\n-\t\t\t\t\t\tif (response.getSuccess()){\n-\t\t\t\t\t\t\t// go through and change sdlManager properties that were changed via the LCU update\n-\t\t\t\t\t\t\thmiLanguage = actualHMILanguage;\n-\t\t\t\t\t\t\tlanguage = actualLanguage;\n-\n-\t\t\t\t\t\t\tif (lcu.getAppName() != null) {\n-\t\t\t\t\t\t\t\tappName = lcu.getAppName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getShortAppName() != null) {\n-\t\t\t\t\t\t\t\tshortAppName = lcu.getShortAppName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getTtsName() != null) {\n-\t\t\t\t\t\t\t\tttsChunks = lcu.getTtsName();\n-\t\t\t\t\t\t\t}\n-\n-\t\t\t\t\t\t\tif (lcu.getVoiceRecognitionCommandNames() != null) {\n-\t\t\t\t\t\t\t\tvrSynonyms = lcu.getVoiceRecognitionCommandNames();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\ttry {\n-\t\t\t\t\t\t\tLog.v(TAG, response.serializeJSON().toString());\n-\t\t\t\t\t\t} catch (JSONException e) {\n-\t\t\t\t\t\t\te.printStackTrace();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\t@Override\n-\t\t\t\t\tpublic void onError(int correlationId, Result resultCode, String info) {\n-\t\t\t\t\t\tLog.e(TAG, \"Change Registration onError: \" + resultCode + \" | Info: \" + info);\n-\t\t\t\t\t}\n-\t\t\t\t});\n-\t\t\t\t_internalInterface.sendRPC(changeRegistration);\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t@Override\n-\tprotected void initialize(){\n-\t\t// Instantiate sub managers\n-\t\tthis.permissionManager = new PermissionManager(_internalInterface);\n-\t\tthis.fileManager = new FileManager(_internalInterface, fileManagerConfig);\n-\t\tthis.screenManager = new ScreenManager(_internalInterface, this.fileManager);\n-\n-\t\t// Start sub managers\n-\t\tthis.permissionManager.start(subManagerListener);\n-\t\tthis.fileManager.start(subManagerListener);\n-\t\tthis.screenManager.start(subManagerListener);\n-\t}\n-\n-\t@Override\n-\tpublic void dispose() {\n-\t\tif (this.permissionManager != null) {\n-\t\t\tthis.permissionManager.dispose();\n-\t\t}\n-\n-\t\tif (this.fileManager != null) {\n-\t\t\tthis.fileManager.dispose();\n-\t\t}\n-\n-\t\tif (this.screenManager != null) {\n-\t\t\tthis.screenManager.dispose();\n-\t\t}\n-\n-\t\tif (this.lifecycleManager != null) {\n-\t\t\tthis.lifecycleManager.stop();\n-\t\t}\n-\n-\t\tif(managerListener != null){\n-\t\t\tmanagerListener.onDestroy(this);\n-\t\t\tmanagerListener = null;\n-\t\t}\n-\n-\t\ttransitionToState(BaseSubManager.SHUTDOWN);\n-\t}\n-\n-\n-\t// MANAGER GETTERS\n-\t/**\n-\t * Gets the PermissionManager. <br>\n-\t * <strong>Note: PermissionManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a PermissionManager object\n-\t */\n-\tpublic PermissionManager getPermissionManager() {\n-\t\tif (permissionManager.getState() != BaseSubManager.READY && permissionManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG,\"PermissionManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn permissionManager;\n-\t}\n-\n-\t/**\n-\t * Gets the FileManager. <br>\n-\t * <strong>Note: FileManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a FileManager object\n-\t */\n-\tpublic FileManager getFileManager() {\n-\t\tif (fileManager.getState() != BaseSubManager.READY && fileManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG, \"FileManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn fileManager;\n-\t}\n-\n-\t/**\n-\t * Gets the ScreenManager. <br>\n-\t * <strong>Note: ScreenManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a ScreenManager object\n-\t */\n-\tpublic ScreenManager getScreenManager() {\n-\t\tif (screenManager.getState() != BaseSubManager.READY && screenManager.getState() != BaseSubManager.LIMITED){\n-\t\t\tLog.e(TAG, \"ScreenManager should not be accessed because it is not in READY/LIMITED state\");\n-\t\t}\n-\t\tcheckSdlManagerState();\n-\t\treturn screenManager;\n-\t}\n-\n-\t/**\n-\t * Gets the SystemCapabilityManager. <br>\n-\t * <strong>Note: SystemCapabilityManager should be used only after SdlManager.start() CompletionListener callback is completed successfully.</strong>\n-\t * @return a SystemCapabilityManager object\n-\t */\n-\tpublic SystemCapabilityManager getSystemCapabilityManager(){\n-\t\treturn lifecycleManager.getSystemCapabilityManager(this);\n-\t}\n-\n-\t/**\n-\t * Method to retrieve the RegisterAppInterface Response message that was sent back from the\n-\t * module. It contains various attributes about the connected module and can be used to adapt\n-\t * to different module types and their supported features.\n-\t *\n-\t * @return RegisterAppInterfaceResponse received from the module or null if the app has not yet\n-\t * registered with the module.\n-\t */\n-\t@Override\n-\tpublic RegisterAppInterfaceResponse getRegisterAppInterfaceResponse(){\n-\t\tif(lifecycleManager != null){\n-\t\t\treturn lifecycleManager.getRegisterAppInterfaceResponse();\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\t/**\n-\t * Get the current OnHMIStatus\n-\t * @return OnHMIStatus object represents the current OnHMIStatus\n-\t */\n-\t@Override\n-\tpublic OnHMIStatus getCurrentHMIStatus(){\n-\t\tif(this.lifecycleManager !=null ){\n-\t\t\treturn lifecycleManager.getCurrentHMIStatus();\n-\t\t}\n-\t\treturn null;\n-\t}\n-\n-\t// PROTECTED GETTERS\n-\n-\tprotected FileManagerConfig getFileManagerConfig() { return fileManagerConfig; }\n-\n-\t/**\n-\t * Retrieves the auth token, if any, that was attached to the StartServiceACK for the RPC\n-\t * service from the module. For example, this should be used to login to a user account.\n-\t * @return the string representation of the auth token\n-\t */\n-\t@Override\n-\tpublic String getAuthToken(){\n-\t\treturn this.lifecycleManager.getAuthToken();\n-\t}\n-\n-\t// SENDING REQUESTS\n-\n-\t/**\n-\t * Send RPC Message <br>\n-\t * @param message RPCMessage\n-\t */\n-\t@Override\n-\tpublic void sendRPC(RPCMessage message) {\n-\t\t_internalInterface.sendRPC(message);\n-\t}\n-\n-\t/**\n-\t * Takes a list of RPCMessages and sends it to SDL in a synchronous fashion. Responses are captured through callback on OnMultipleRequestListener.\n-\t * For sending requests asynchronously, use sendRequests <br>\n-\t *\n-\t * <strong>NOTE: This will override any listeners on individual RPCs</strong><br>\n-\t *\n-\t * <strong>ADDITIONAL NOTE: This only takes the type of RPCRequest for now, notifications and responses will be thrown out</strong>\n-\t *\n-\t * @param rpcs is the list of RPCMessages being sent\n-\t * @param listener listener for updates and completions\n-\t */\n-\t@Override\n-\tpublic void sendSequentialRPCs(final List<? extends RPCMessage> rpcs, final OnMultipleRequestListener listener){\n-\n-\t\tList<RPCRequest> rpcRequestList = new ArrayList<>();\n-\t\tfor (int i = 0; i < rpcs.size(); i++) {\n-\t\t\tif (rpcs.get(i) instanceof RPCRequest){\n-\t\t\t\trpcRequestList.add((RPCRequest)rpcs.get(i));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (rpcRequestList.size() > 0) {\n-\t\t\t_internalInterface.sendSequentialRPCs(rpcRequestList, listener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Takes a list of RPCMessages and sends it to SDL. Responses are captured through callback on OnMultipleRequestListener.\n-\t * For sending requests synchronously, use sendSequentialRPCs <br>\n-\t *\n-\t * <strong>NOTE: This will override any listeners on individual RPCs</strong> <br>\n-\t *\n-\t * <strong>ADDITIONAL NOTE: This only takes the type of RPCRequest for now, notifications and responses will be thrown out</strong>\n-\t *\n-\t * @param rpcs is the list of RPCMessages being sent\n-\t * @param listener listener for updates and completions\n-\t */\n-\t@Override\n-\tpublic void sendRPCs(List<? extends RPCMessage> rpcs, final OnMultipleRequestListener listener) {\n-\n-\t\tList<RPCRequest> rpcRequestList = new ArrayList<>();\n-\t\tfor (int i = 0; i < rpcs.size(); i++) {\n-\t\t\tif (rpcs.get(i) instanceof RPCRequest){\n-\t\t\t\trpcRequestList.add((RPCRequest)rpcs.get(i));\n-\t\t\t}\n-\t\t}\n-\n-\t\tif (rpcRequestList.size() > 0) {\n-\t\t\t_internalInterface.sendRequests(rpcRequestList,listener);\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Add an OnRPCNotificationListener\n-\t * @param listener listener that will be called when a notification is received\n-\t */\n-\t@Override\n-\tpublic void addOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener){\n-\t\t_internalInterface.addOnRPCNotificationListener(notificationId,listener);\n-\t}\n-\n-\t/**\n-\t * Remove an OnRPCNotificationListener\n-\t * @param listener listener that was previously added\n-\t */\n-\t@Override\n-\tpublic void removeOnRPCNotificationListener(FunctionID notificationId, OnRPCNotificationListener listener){\n-\t\t_internalInterface.removeOnRPCNotificationListener(notificationId, listener);\n-\t}\n-\n-\t/**\n-\t * Add an OnRPCRequestListener\n-\t * @param listener listener that will be called when a request is received\n-\t */\n-\t@Override\n-\tpublic void addOnRPCRequestListener(FunctionID requestId, OnRPCRequestListener listener){\n-\t\t_internalInterface.addOnRPCRequestListener(requestId,listener);\n-\t}\n-\n-\t/**\n-\t * Remove an OnRPCRequestListener\n-\t * @param listener listener that was previously added\n-\t */\n-\t@Override\n-\tpublic void removeOnRPCRequestListener(FunctionID requestId, OnRPCRequestListener listener){\n-\t\t_internalInterface.removeOnRPCRequestListener(requestId, listener);\n-\t}\n-\n-\t// LIFECYCLE / OTHER\n-\n-\t// STARTUP\n-\n-\t/**\n-\t * Starts up a SdlManager, and calls provided callback called once all BaseSubManagers are done setting up\n-\t */\n-\t@SuppressWarnings(\"unchecked\")\n-\t@Override\n-\tpublic void start(){\n-\n-\t\tRuntime.getRuntime().addShutdownHook(new Thread() {\n-\t\t\t@Override\n-\t\t\tpublic void run() {\n-\t\t\t\tdispose();\n-\t\t\t}\n-\t\t});\n-\n-\t\tLog.i(TAG, \"start\");\n-\t\tif (lifecycleManager == null) {\n-\t\t\tif (transport != null\n-\t\t\t\t\t&& (transport.getTransportType().equals(TransportType.WEB_SOCKET_SERVER) || transport.getTransportType().equals(TransportType.CUSTOM))) {\n-\t\t\t\t//Do the thing\n-\n-\t\t\t\tLifecycleManager.AppConfig appConfig = new LifecycleManager.AppConfig();\n-\t\t\t\tappConfig.setAppName(appName);\n-\t\t\t\t//short app name\n-\t\t\t\tappConfig.setMediaApp(isMediaApp);\n-\t\t\t\tappConfig.setHmiDisplayLanguageDesired(hmiLanguage);\n-\t\t\t\tappConfig.setLanguageDesired(hmiLanguage);\n-\t\t\t\tappConfig.setAppType(hmiTypes);\n-\t\t\t\tappConfig.setVrSynonyms(vrSynonyms);\n-\t\t\t\tappConfig.setTtsName(ttsChunks);\n-\t\t\t\tappConfig.setDayColorScheme(dayColorScheme);\n-\t\t\t\tappConfig.setNightColorScheme(nightColorScheme);\n-\t\t\t\tappConfig.setAppID(appId);\n-\t\t\t\tappConfig.setMinimumProtocolVersion(minimumProtocolVersion);\n-\t\t\t\tappConfig.setMinimumRPCVersion(minimumRPCVersion);\n-\n-\t\t\t\tlifecycleManager = new LifecycleManager(appConfig, transport, lifecycleListener);\n-\t\t\t\t_internalInterface = lifecycleManager.getInternalInterface(SdlManager.this);\n-\n-\t\t\t\tif (sdlSecList != null && !sdlSecList.isEmpty()) {\n-\t\t\t\t\tlifecycleManager.setSdlSecurity(sdlSecList, serviceEncryptionListener);\n-\t\t\t\t}\n-\n-\t\t\t\t//Setup the notification queue\n-\t\t\t\tinitNotificationQueue();\n-\n-\t\t\t\tlifecycleManager.start();\n-\n-\n-\t\t\t}else{\n-\t\t\t\tthrow new RuntimeException(\"No transport provided\");\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\n-\t// BUILDER\n-\tpublic static class Builder {\n-\t\tSdlManager sdlManager;\n-\n-\t\t/**\n-\t\t * Builder for the SdlManager. Parameters in the constructor are required.\n-\t\t * @param appId the app's ID\n-\t\t * @param appName the app's name\n-\t\t * @param listener a SdlManagerListener object\n-\t\t */\n-\t\tpublic Builder(@NonNull final String appId, @NonNull final String appName, @NonNull final SdlManagerListener listener){\n-\t\t\tsdlManager = new SdlManager();\n-\t\t\tsetAppId(appId);\n-\t\t\tsetAppName(appName);\n-\t\t\tsetManagerListener(listener);\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the App ID\n-\t\t * @param appId String representation of the App ID retreived from the SDL Developer Portal\n-\t\t */\n-\t\tpublic Builder setAppId(@NonNull final String appId){\n-\t\t\tsdlManager.appId = appId;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Application Name\n-\t\t * @param appName String that will be associated as the app's name\n-\t\t */\n-\t\tpublic Builder setAppName(@NonNull final String appName){\n-\t\t\tsdlManager.appName = appName;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Short Application Name\n-\t\t * @param shortAppName a shorter representation of the app's name for smaller displays\n-\t\t */\n-\t\tpublic Builder setShortAppName(final String shortAppName) {\n-\t\t\tsdlManager.shortAppName = shortAppName;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the minimum protocol version that will be permitted to connect.\n-\t\t * If the protocol version of the head unit connected is below this version,\n-\t\t * the app will disconnect with an EndService protocol message and will not register.\n-\t\t * @param minimumProtocolVersion the minimum Protocol spec version that should be accepted\n-\t\t */\n-\t\tpublic Builder setMinimumProtocolVersion(final Version minimumProtocolVersion) {\n-\t\t\tsdlManager.minimumProtocolVersion = minimumProtocolVersion;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * The minimum RPC version that will be permitted to connect.\n-\t\t * If the RPC version of the head unit connected is below this version, an UnregisterAppInterface will be sent.\n-\t\t * @param minimumRPCVersion the minimum RPC spec version that should be accepted\n-\t\t */\n-\t\tpublic Builder setMinimumRPCVersion(final Version minimumRPCVersion) {\n-\t\t\tsdlManager.minimumRPCVersion = minimumRPCVersion;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Language of the App\n-\t\t * @param hmiLanguage the desired language to be used on the display/HMI of the connected module\n-\t\t */\n-\t\tpublic Builder setLanguage(final Language hmiLanguage) {\n-\t\t\tsdlManager.hmiLanguage = hmiLanguage;\n-\t\t\tsdlManager.language = hmiLanguage;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the TemplateColorScheme for daytime\n-\t\t * @param dayColorScheme color scheme that will be used (if supported) when the display is in a \"Day Mode\" or\n-\t\t *                       similar. Should comprise of colors that contrast well during the day under sunlight.\n-\t\t */\n-\t\tpublic Builder setDayColorScheme(final TemplateColorScheme dayColorScheme){\n-\t\t\tsdlManager.dayColorScheme = dayColorScheme;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the TemplateColorScheme for nighttime\n-\t\t * @param nightColorScheme color scheme that will be used (if supported) when the display is in a \"Night Mode\"\n-\t\t *                         or similar. Should comprise of colors that contrast well during the night and are not\n-\t\t *                         brighter than average.\n-\t\t */\n-\t\tpublic Builder setNightColorScheme(final TemplateColorScheme nightColorScheme){\n-\t\t\tsdlManager.nightColorScheme = nightColorScheme;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the icon for the app on head unit / In-Vehicle-Infotainment system <br>\n-\t\t * @param sdlArtwork the icon that will be used to represent this application on the connected module\n-\t\t */\n-\t\tpublic Builder setAppIcon(final SdlArtwork sdlArtwork){\n-\t\t\tsdlManager.appIcon = sdlArtwork;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the vector of AppHMIType <br>\n-\t\t * <strong>Note: This should be an ordered list from most -> least relevant</strong>\n-\t\t * @param hmiTypes HMI types that represent this application. For example, if the app is a music player, the\n-\t\t *                 MEDIA HMIType should be included.\n-\t\t */\n-\t\tpublic Builder setAppTypes(final Vector<AppHMIType> hmiTypes){\n-\n-\t\t\tsdlManager.hmiTypes = hmiTypes;\n-\n-\t\t\tif (hmiTypes != null) {\n-\t\t\t\tsdlManager.isMediaApp = hmiTypes.contains(AppHMIType.MEDIA);\n-\t\t\t}\n-\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the FileManagerConfig for the session.<br>\n-\t\t * <strong>Note: If not set, the default configuration value of 1 will be set for\n-\t\t * artworkRetryCount and fileRetryCount in FileManagerConfig</strong>\n-\t\t * @param fileManagerConfig - configuration options\n-\t\t */\n-\t\tpublic Builder setFileManagerConfig (final FileManagerConfig fileManagerConfig){\n-\t\t\tsdlManager.fileManagerConfig = fileManagerConfig;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the voice recognition synonyms that can be used to identify this application.\n-\t\t * @param vrSynonyms a vector of Strings that can be associated with this app. For example the app's name should\n-\t\t *                   be included as well as any phonetic spellings of the app name that might help the on-board\n-\t\t *                   VR system associated a users spoken word with the supplied synonyms.\n-\t\t */\n-\t\tpublic Builder setVrSynonyms(final Vector<String> vrSynonyms) {\n-\t\t\tsdlManager.vrSynonyms = vrSynonyms;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Text-To-Speech Name of the application. These TTSChunks might be used by the module as an audio\n-\t\t * representation of the app's name.\n-\t\t * @param ttsChunks the TTS chunks that can represent this app's name\n-\t\t */\n-\t\tpublic Builder setTtsName(final Vector<TTSChunk> ttsChunks) {\n-\t\t\tsdlManager.ttsChunks = ttsChunks;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * This Object type may change with the transport refactor\n-\t\t * Sets the BaseTransportConfig\n-\t\t * @param transport the type of transport that should be used for this SdlManager instance.\n-\t\t */\n-\t\tpublic Builder setTransportType(BaseTransportConfig transport){\n-\t\t\tsdlManager.transport = transport;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the Security libraries\n-\t\t * @param secList The list of security class(es)\n-\t\t */\n-\t\t@Deprecated\n-\t\tpublic Builder setSdlSecurity(List<Class<? extends SdlSecurityBase>> secList) {\n-\t\t\tsdlManager.sdlSecList = secList;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Sets the security libraries and a callback to notify caller when there is update to encryption service\n-\t\t * @param secList The list of security class(es)\n-\t\t * @param listener The callback object\n-\t\t */\n-\t\tpublic Builder setSdlSecurity(@NonNull List<Class<? extends SdlSecurityBase>> secList, ServiceEncryptionListener listener) {\n-\t\t\tsdlManager.sdlSecList = secList;\n-\t\t\tsdlManager.serviceEncryptionListener = listener;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Set the SdlManager Listener\n-\t\t * @param listener the listener\n-\t\t */\n-\t\tpublic Builder setManagerListener(@NonNull final SdlManagerListener listener){\n-\t\t\tsdlManager.managerListener = listener;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\t/**\n-\t\t * Set RPCNotification listeners. SdlManager will preload these listeners before any RPCs are sent/received.\n-\t\t * @param listeners a map of listeners that will be called when a notification is received.\n-\t\t * Key represents the FunctionID of the notification and value represents the listener\n-\t\t */\n-\t\tpublic Builder setRPCNotificationListeners(Map<FunctionID, OnRPCNotificationListener> listeners){\n-\t\t\tsdlManager.onRPCNotificationListeners = listeners;\n-\t\t\treturn this;\n-\t\t}\n-\n-\t\tpublic SdlManager build() {\n-\n-\t\t\tif (sdlManager.appName == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must specify an app name by calling setAppName\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.appId == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must specify an app ID by calling setAppId\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.managerListener == null) {\n-\t\t\t\tthrow new IllegalArgumentException(\"You must set a SdlManagerListener object\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.hmiTypes == null) {\n-\t\t\t\tVector<AppHMIType> hmiTypesDefault = new Vector<>();\n-\t\t\t\thmiTypesDefault.add(AppHMIType.DEFAULT);\n-\t\t\t\tsdlManager.hmiTypes = hmiTypesDefault;\n-\t\t\t\tsdlManager.isMediaApp = false;\n-\t\t\t}\n-\t\t\tif(sdlManager.fileManagerConfig == null){\n-\t\t\t\t//if FileManagerConfig is not set use default\n-\t\t\t\tsdlManager.fileManagerConfig = new FileManagerConfig();\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.hmiLanguage == null) {\n-\t\t\t\tsdlManager.hmiLanguage = Language.EN_US;\n-\t\t\t\tsdlManager.language = Language.EN_US;\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.minimumProtocolVersion == null){\n-\t\t\t\tsdlManager.minimumProtocolVersion = new Version(\"1.0.0\");\n-\t\t\t}\n-\n-\t\t\tif (sdlManager.minimumRPCVersion == null){\n-\t\t\t\tsdlManager.minimumRPCVersion = new Version(\"1.0.0\");\n-\t\t\t}\n-\n-\t\t\tsdlManager.transitionToState(BaseSubManager.SETTING_UP);\n-\n-\t\t\treturn sdlManager;\n-\t\t}\n-\t}\n-\n-\t/**\n-\t * Start a secured RPC service\n-\t */\n-\tpublic void startRPCEncryption() {\n-\t\tif (lifecycleManager != null) {\n-\t\t\tlifecycleManager.startRPCEncryption();\n-\t\t}\n-\t}\n+public class SdlManager extends BaseSdlManager {\n+\n+    /**\n+     * Starts up a SdlManager, and calls provided callback called once all BaseSubManagers are done setting up\n+     */\n+    @Override\n+    public void start() {\n+        Runtime.getRuntime().addShutdownHook(new Thread() {\n+            @Override\n+            public void run() {\n+                dispose();\n+            }\n+        });\n+\n+        Log.i(TAG, \"start\");\n+        if (lifecycleManager == null) {\n+            if (transport != null && (transport.getTransportType().equals(TransportType.WEB_SOCKET_SERVER) || transport.getTransportType().equals(TransportType.CUSTOM))) {\n+                super.start();\n+                lifecycleManager.start();\n+            } else {\n+                throw new RuntimeException(\"No transport provided\");\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected void initialize(){\n+        // Instantiate sub managers\n+        this.permissionManager = new PermissionManager(_internalInterface);\n+        this.fileManager = new FileManager(_internalInterface, fileManagerConfig);\n+        this.screenManager = new ScreenManager(_internalInterface, this.fileManager);\n+\n+        // Start sub managers\n+        this.permissionManager.start(subManagerListener);\n+        this.fileManager.start(subManagerListener);\n+        this.screenManager.start(subManagerListener);\n+    }\n+\n+    @Override\n+    void checkState() {\n+        if (permissionManager != null && fileManager != null && screenManager != null ){", "originalCommit": "e6498f057b86c21310fd5e9d1ba2c593e31ef5a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkyMzc5NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1366#discussion_r438923794", "bodyText": "Add space before {", "author": "JulianKast", "createdAt": "2020-06-11T16:40:34Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/managers/SdlManagerTests.java", "diffHunk": "@@ -371,18 +369,16 @@ public Void answer(InvocationOnMock invocation) {\n \t\t\t\treturn null;\n \t\t\t}\n \t\t};\n-\t\ttry {\n-\t\t\tif (sequentialSend){\n-\t\t\t\tdoAnswer(answer).when(sdlProxyBase).sendSequentialRequests(any(List.class), any(OnMultipleRequestListener.class));\n \n-\t\t\t} else {\n-\t\t\t\tdoAnswer(answer).when(sdlProxyBase).sendRequests(any(List.class), any(OnMultipleRequestListener.class));\n-\t\t\t}\n-\t\t} catch (SdlException e) {\n-\t\t\te.printStackTrace();\n+\t\tif (sequentialSend){", "originalCommit": "e6498f057b86c21310fd5e9d1ba2c593e31ef5a5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4c025a72c44c53a7b9ff6fbf88aad62d0a840771", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/4c025a72c44c53a7b9ff6fbf88aad62d0a840771", "message": "Update formatting", "committedDate": "2020-06-11T18:35:15Z", "type": "commit"}]}