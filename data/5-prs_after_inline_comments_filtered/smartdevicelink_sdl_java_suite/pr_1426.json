{"pr_number": 1426, "pr_title": "SdlSession Refactor", "pr_createdAt": "2020-07-30T13:59:51Z", "pr_url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426", "timeline": [{"oid": "9d24a0e87d83b3544a4fd4bb208bec32479e322c", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/9d24a0e87d83b3544a4fd4bb208bec32479e322c", "message": "Refactor SdlSession2 into SdlSession with base", "committedDate": "2020-07-21T15:57:43Z", "type": "commit"}, {"oid": "c0c4f50e409b486f524d7ded9d0dc6d8f4f875c3", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/c0c4f50e409b486f524d7ded9d0dc6d8f4f875c3", "message": "Remove deprecated classes that used old SdlSession\n\nAlso remove deprecated classes that had to reference those deleted classes.", "committedDate": "2020-07-21T15:58:38Z", "type": "commit"}, {"oid": "a905bb89b9dd6737a6c92723baf53ce17a547914", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/a905bb89b9dd6737a6c92723baf53ce17a547914", "message": "Fix unit tests", "committedDate": "2020-07-21T15:58:54Z", "type": "commit"}, {"oid": "147f71a881d03b984497ac62519336ee7e667101", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/147f71a881d03b984497ac62519336ee7e667101", "message": "Merge branch 'develop' of https://github.com/smartdevicelink/sdl_android into feature/sdlsession_refactor", "committedDate": "2020-07-30T13:53:13Z", "type": "commit"}, {"oid": "f8080616efd531480981fb265b611e91dffa8489", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/f8080616efd531480981fb265b611e91dffa8489", "message": "Add missing method to JavaSE SdlSession", "committedDate": "2020-07-30T14:23:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NTAwMQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r463755001", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import com.smartdevicelink.protocol.ISdlProtocol;", "author": "JulianKast", "createdAt": "2020-07-31T18:04:53Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -1,838 +1,339 @@\n-/*\r\n- * Copyright (c) 2017 - 2019, SmartDeviceLink Consortium, Inc.\r\n- * All rights reserved.\r\n- *\r\n- * Redistribution and use in source and binary forms, with or without\r\n- * modification, are permitted provided that the following conditions are met:\r\n- *\r\n- * Redistributions of source code must retain the above copyright notice, this\r\n- * list of conditions and the following disclaimer.\r\n- *\r\n- * Redistributions in binary form must reproduce the above copyright notice,\r\n- * this list of conditions and the following\r\n- * disclaimer in the documentation and/or other materials provided with the\r\n- * distribution.\r\n- *\r\n- * Neither the name of the SmartDeviceLink Consortium, Inc. nor the names of its\r\n- * contributors may be used to endorse or promote products derived from this \r\n- * software without specific prior written permission.\r\n- *\r\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n- * POSSIBILITY OF SUCH DAMAGE.\r\n- */\r\n-package com.smartdevicelink.SdlConnection;\r\n-\r\n-import android.annotation.SuppressLint;\r\n-import android.os.Build;\r\n-import android.view.Surface;\r\n-\r\n-import com.smartdevicelink.encoder.SdlEncoder;\r\n-import com.smartdevicelink.encoder.VirtualDisplayEncoder;\r\n-import com.smartdevicelink.exception.SdlException;\r\n-import com.smartdevicelink.protocol.ProtocolMessage;\r\n-import com.smartdevicelink.protocol.enums.SessionType;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitorListener;\r\n-import com.smartdevicelink.proxy.LockScreenManager;\r\n-import com.smartdevicelink.proxy.RPCRequest;\r\n-import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\r\n-import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\r\n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\r\n-import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\r\n-import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\r\n-import com.smartdevicelink.security.ISecurityInitializedListener;\r\n-import com.smartdevicelink.security.SdlSecurityBase;\r\n-import com.smartdevicelink.streaming.AbstractPacketizer;\r\n-import com.smartdevicelink.streaming.IStreamListener;\r\n-import com.smartdevicelink.streaming.StreamPacketizer;\r\n-import com.smartdevicelink.streaming.StreamRPCPacketizer;\r\n-import com.smartdevicelink.streaming.video.RTPH264Packetizer;\r\n-import com.smartdevicelink.streaming.video.VideoStreamingParameters;\r\n-import com.smartdevicelink.transport.BaseTransportConfig;\r\n-import com.smartdevicelink.transport.MultiplexTransport;\r\n-import com.smartdevicelink.transport.enums.TransportType;\r\n-import com.smartdevicelink.util.DebugTool;\r\n-import com.smartdevicelink.util.Version;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.OutputStream;\r\n-import java.io.PipedInputStream;\r\n-import java.io.PipedOutputStream;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.ListIterator;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-@Deprecated\r\n-public class SdlSession implements ISdlConnectionListener, IHeartbeatMonitorListener, IStreamListener, ISecurityInitializedListener {\r\n-\r\n-   private static final String TAG = \"SdlSession\";\r\n-\r\n-    protected final static int BUFF_READ_SIZE = 1024;\r\n-\r\n-\tprivate static CopyOnWriteArrayList<SdlConnection> shareConnections = new CopyOnWriteArrayList<SdlConnection>();\r\n-\r\n-\tprivate byte wiproProcolVer;\r\n-\r\n-    protected BaseTransportConfig transportConfig;\r\n-    protected ISdlConnectionListener sessionListener;\r\n-\tprotected LockScreenManager lockScreenMan  = new LockScreenManager();\r\n-\tprotected SdlSecurityBase sdlSecurity = null;\r\n-\tprotected VideoStreamingParameters desiredVideoParams = null;\r\n-\tprotected VideoStreamingParameters acceptedVideoParams = null;\r\n-\r\n-\tprotected byte sessionId;\r\n-\tprotected int sessionHashId = 0;\r\n-\tprotected HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> serviceListeners;\r\n-\tprotected CopyOnWriteArrayList<SessionType> encryptedServices = new CopyOnWriteArrayList<SessionType>();\r\n-\r\n-\r\n-\tSdlConnection _sdlConnection = null;\r\n-\r\n-\tIHeartbeatMonitor _outgoingHeartbeatMonitor = null;\r\n-\tIHeartbeatMonitor _incomingHeartbeatMonitor = null;\r\n-\r\n-    StreamRPCPacketizer mRPCPacketizer = null;\r\n-    AbstractPacketizer mVideoPacketizer = null;\r\n-    StreamPacketizer mAudioPacketizer = null;\r\n-    SdlEncoder mSdlEncoder = null;\r\n-    VirtualDisplayEncoder virtualDisplayEncoder = null;\r\n-    boolean sdlSecurityInitializing = false;\r\n-\r\n-    public static SdlSession createSession(byte wiproVersion, ISdlConnectionListener listener, BaseTransportConfig btConfig) {\r\n-\r\n-        SdlSession session =  new SdlSession();\r\n-        session.wiproProcolVer = wiproVersion;\r\n-        session.sessionListener = listener;\r\n-        session.transportConfig = btConfig;\r\n-\r\n-        return session;\r\n-    }\r\n-\r\n-    public BaseTransportConfig getTransportConfig() {\r\n-        return this.transportConfig;\r\n-    }\r\n-\r\n-    public LockScreenManager getLockScreenMan() {\r\n-        return lockScreenMan;\r\n-    }\r\n-\r\n-\r\n-    public IHeartbeatMonitor getOutgoingHeartbeatMonitor() {\r\n-        return _outgoingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public IHeartbeatMonitor getIncomingHeartbeatMonitor() {\r\n-        return _incomingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public void setOutgoingHeartbeatMonitor(IHeartbeatMonitor outgoingHeartbeatMonitor) {\r\n-        this._outgoingHeartbeatMonitor = outgoingHeartbeatMonitor;\r\n-        _outgoingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public void setIncomingHeartbeatMonitor(IHeartbeatMonitor incomingHeartbeatMonitor) {\r\n-        this._incomingHeartbeatMonitor = incomingHeartbeatMonitor;\r\n-        _incomingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public int getSessionHashId() {\r\n-        return this.sessionHashId;\r\n-    }\r\n-\r\n-    public byte getSessionId() {\r\n-        return this.sessionId;\r\n-    }\r\n-\r\n-    public SdlConnection getSdlConnection() {\r\n-        return this._sdlConnection;\r\n-    }\r\n-\r\n-    public int getMtu(){\r\n-        if(this._sdlConnection!=null){\r\n-            return this._sdlConnection.getWiProProtocol().getMtu();\r\n-        }else{\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public long getMtu(SessionType type) {\r\n-        if (this._sdlConnection != null) {\r\n-            return this._sdlConnection.getWiProProtocol().getMtu(type);\r\n-        } else {\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        if (sdlSecurity != null)\r\n-        {\r\n-            sdlSecurity.resetParams();\r\n-            sdlSecurity.shutDown();\r\n-        }\r\n-\r\n-        if (_sdlConnection != null) { //sessionId == 0 means session is not started.\r\n-            //_sdlConnection.unregisterSession(this);\r\n-\r\n-            if (_sdlConnection.getRegisterCount() == 0) {\r\n-                shareConnections.remove(_sdlConnection);\r\n-            }\r\n-\r\n-            _sdlConnection = null;\r\n-        }\r\n-    }\r\n-\r\n-    public void resetSession(){\r\n-\r\n-    }\r\n-\r\n-    public void startStream(InputStream is, SessionType sType, byte rpcSessionID) throws IOException {\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressLint(\"NewApi\")\r\n-    public OutputStream startStream(SessionType sType, byte rpcSessionID) throws IOException {\r\n-        OutputStream os = new PipedOutputStream();\r\n-        InputStream is = null;\r\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\r\n-            is = new PipedInputStream((PipedOutputStream) os, BUFF_READ_SIZE);\r\n-        } else {\r\n-            is = new PipedInputStream((PipedOutputStream) os);\r\n-        }\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-        else\r\n-        {\r\n-            os.close();\r\n-            is.close();\r\n-            return null;\r\n-        }\r\n-        return os;\r\n-    }\r\n-\r\n-    public IVideoStreamListener startVideoStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        VideoStreamingProtocol protocol = getAcceptedProtocol();\r\n-        try {\r\n-            switch (protocol) {\r\n-                case RAW: {\r\n-                    StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.NAV, rpcSessionID, this);\r\n-                    packetizer.sdlConnection = this.getSdlConnection();\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                case RTP: {\r\n-                    RTPH264Packetizer packetizer = new RTPH264Packetizer(this, SessionType.NAV, rpcSessionID, this);\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                default:\r\n-                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\r\n-                    return null;\r\n-            }\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    public IAudioStreamListener startAudioStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        try {\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.PCM, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer = packetizer;\r\n-            mAudioPacketizer.start();\r\n-            return packetizer;\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void startRPCStream(InputStream is, RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public OutputStream startRPCStream(RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            OutputStream os = new PipedOutputStream();\r\n-            InputStream is = new PipedInputStream((PipedOutputStream) os);\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-            return os;\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void pauseRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.pause();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void resumeRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.resume();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void stopRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.stop();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean stopAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean stopVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public Surface createOpenGLInputSurface(int frameRate, int iFrameInterval, int width,\r\n-                                            int height, int bitrate, SessionType sType, byte rpcSessionID) {\r\n-        IVideoStreamListener encoderListener = startVideoStream();\r\n-        if (encoderListener == null) {\r\n-            return null;\r\n-        }\r\n-\r\n-        mSdlEncoder = new SdlEncoder();\r\n-        mSdlEncoder.setFrameRate(frameRate);\r\n-        mSdlEncoder.setFrameInterval(iFrameInterval);\r\n-        mSdlEncoder.setFrameWidth(width);\r\n-        mSdlEncoder.setFrameHeight(height);\r\n-        mSdlEncoder.setBitrate(bitrate);\r\n-        mSdlEncoder.setOutputListener(encoderListener);\r\n-        return mSdlEncoder.prepareEncoder();\r\n-    }\r\n-\r\n-    public void startEncoder () {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.startEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void releaseEncoder() {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.releaseEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void drainEncoder(boolean endOfStream) {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.drainEncoder(endOfStream);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendStreamPacket(ProtocolMessage pm) {\r\n-        sendMessage(pm);\r\n-    }\r\n-\r\n-    public void setSdlSecurity(SdlSecurityBase sec) {\r\n-        sdlSecurity = sec;\r\n-    }\r\n-\r\n-    public SdlSecurityBase getSdlSecurity() {\r\n-        return sdlSecurity;\r\n-    }\r\n-\r\n-    public void startService (SessionType serviceType, byte sessionID, boolean isEncrypted) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-\r\n-        if (isEncrypted)\r\n-        {\r\n-            if (sdlSecurity != null)\r\n-            {\r\n-                List<SessionType> serviceList = sdlSecurity.getServiceList();\r\n-                if (!serviceList.contains(serviceType))\r\n-                    serviceList.add(serviceType);\r\n-\r\n-                if (!sdlSecurityInitializing) {\r\n-                    sdlSecurityInitializing = true;\r\n-                    sdlSecurity.initialize();\r\n-                    return;\r\n-                }\r\n-            }\r\n-        }\r\n-        _sdlConnection.startService(serviceType, sessionID, isEncrypted);\r\n-    }\r\n-\r\n-    public void endService (SessionType serviceType, byte sessionID) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.endService(serviceType, sessionID);\r\n-    }\r\n-\r\n-    protected void processControlService(ProtocolMessage msg) {\r\n-        if (sdlSecurity == null)\r\n-            return;\r\n-        int ilen = msg.getData().length - 12;\r\n-        byte[] data = new byte[ilen];\r\n-        System.arraycopy(msg.getData(), 12, data, 0, ilen);\r\n-\r\n-        byte[] dataToRead = new byte[4096];\r\n-\r\n-        Integer iNumBytes = sdlSecurity.runHandshake(data, dataToRead);\r\n-\r\n-        if (iNumBytes == null || iNumBytes <= 0)\r\n-            return;\r\n-\r\n-        byte[] returnBytes = new byte[iNumBytes];\r\n-        System.arraycopy(dataToRead, 0, returnBytes, 0, iNumBytes);\r\n-        ProtocolMessage protocolMessage = new ProtocolMessage();\r\n-        protocolMessage.setSessionType(SessionType.CONTROL);\r\n-        protocolMessage.setData(returnBytes);\r\n-        protocolMessage.setFunctionID(0x01);\r\n-        protocolMessage.setVersion(wiproProcolVer);\r\n-        protocolMessage.setSessionID(getSessionId());\r\n-\r\n-        //sdlSecurity.hs();\r\n-\r\n-        sendMessage(protocolMessage);\r\n-    }\r\n-\r\n-    public String getBroadcastComment(BaseTransportConfig myTransport) {\r\n-        SdlConnection connection = null;\r\n-        if (myTransport.shareConnection()) {\r\n-            connection = findTheProperConnection(myTransport);\r\n-        } else {\r\n-            connection = this._sdlConnection;\r\n-        }\r\n-\r\n-        if (connection != null)\r\n-            return connection.getBroadcastComment();\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-\r\n-    public void startSession() throws SdlException {\r\n-        SdlConnection connection = null;\r\n-        if (this.transportConfig.shareConnection()) {\r\n-            connection = findTheProperConnection(this.transportConfig);\r\n-\r\n-            if (connection == null) {\r\n-                connection = new SdlConnection(this.transportConfig);\r\n-                shareConnections.add(connection);\r\n-            }\r\n-        } else {\r\n-            connection = new SdlConnection(this.transportConfig);\r\n-        }\r\n-\r\n-        this._sdlConnection = connection;\r\n-        connection.registerSession(this); //Handshake will start when register.\r\n-    }\r\n-\r\n-    protected void initialiseSession() {\r\n-        if (_outgoingHeartbeatMonitor != null) {\r\n-            _outgoingHeartbeatMonitor.start();\r\n-        }\r\n-        if (_incomingHeartbeatMonitor != null) {\r\n-            _incomingHeartbeatMonitor.start();\r\n-        }\r\n-    }\r\n-\r\n-    public void sendMessage(ProtocolMessage msg) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.sendMessage(msg);\r\n-    }\r\n-\r\n-    public TransportType getCurrentTransportType() {\r\n-        if (_sdlConnection == null)\r\n-            return null;\r\n-        return _sdlConnection.getCurrentTransportType();\r\n-    }\r\n-\r\n-    public boolean getIsConnected() {\r\n-        if (_sdlConnection == null)\r\n-            return false;\r\n-        return _sdlConnection != null && _sdlConnection.getIsConnected();\r\n-    }\r\n-\r\n-    public boolean isServiceProtected(SessionType sType) {\r\n-        return encryptedServices.contains(sType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info, boolean availablePrimary, BaseTransportConfig transportConfig) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportError(String info, Exception e) {\r\n-        this.sessionListener.onTransportError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolMessageReceived(ProtocolMessage msg) {\r\n-        if (msg.getSessionType().equals(SessionType.CONTROL)) {\r\n-            processControlService(msg);\r\n-            return;\r\n-        }\r\n-\r\n-        this.sessionListener.onProtocolMessageReceived(msg);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onHeartbeatTimedOut(byte sessionID) {\r\n-        this.sessionListener.onHeartbeatTimedOut(sessionID);\r\n-\r\n-    }\r\n-\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStarted(SessionType sessionType,\r\n-                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\r\n-        this.sessionId = sessionID;\r\n-        lockScreenMan.setSessionID(sessionID);\r\n-        if (sessionType.eq(SessionType.RPC)){\r\n-            sessionHashId = hashID;\r\n-            wiproProcolVer = version;\r\n-        }\r\n-        if (isEncrypted)\r\n-            encryptedServices.addIfAbsent(sessionType);\r\n-        this.sessionListener.onProtocolSessionStarted(sessionType, sessionID, version, correlationID, hashID, isEncrypted);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceStarted(this, sessionType, isEncrypted);\r\n-            }\r\n-        }\r\n-        //if (version == 3)\r\n-        initialiseSession();\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEnded(SessionType sessionType, byte sessionID,\r\n-                                       String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEnded(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceEnded(this, sessionType);\r\n-            }\r\n-        }\r\n-        encryptedServices.remove(sessionType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolError(String info, Exception e) {\r\n-        this.sessionListener.onProtocolError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendHeartbeat(IHeartbeatMonitor monitor) {\r\n-        DebugTool.logInfo(TAG, \"Asked to send heartbeat\");\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection.sendHeartbeat(this);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void heartbeatTimedOut(IHeartbeatMonitor monitor) {\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection._connectionListener.onHeartbeatTimedOut(this.sessionId);\r\n-        close();\r\n-    }\r\n-\r\n-    private static SdlConnection findTheProperConnection(BaseTransportConfig config) {\r\n-        SdlConnection connection = null;\r\n-\r\n-        int minCount = 0;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == config.getTransportType()) {\r\n-                if (minCount == 0 || minCount >= c.getRegisterCount()) {\r\n-                    connection = c;\r\n-                    minCount = c.getRegisterCount();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStartedNACKed(SessionType sessionType,\r\n-                                               byte sessionID, byte version, String correlationID, List<String> rejectedParams) {\r\n-        this.sessionListener.onProtocolSessionStartedNACKed(sessionType,\r\n-                sessionID, version, correlationID, rejectedParams);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"Start \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEndedNACKed(SessionType sessionType,\r\n-                                             byte sessionID, String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEndedNACKed(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"End \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolServiceDataACK(SessionType sessionType, int dataSize, byte sessionID) {\r\n-        this.sessionListener.onProtocolServiceDataACK(sessionType, dataSize, sessionID);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onAuthTokenReceived(String authToken, byte sessionId) {\r\n-        this.sessionListener.onAuthTokenReceived(authToken, sessionId);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onSecurityInitialized() {\r\n-\r\n-        if (_sdlConnection != null && sdlSecurity != null)\r\n-        {\r\n-            List<SessionType> list = sdlSecurity.getServiceList();\r\n-\r\n-            SessionType service;\r\n-            ListIterator<SessionType> iter = list.listIterator();\r\n-\r\n-            while (iter.hasNext()) {\r\n-                service = iter.next();\r\n-\r\n-                if (service != null)\r\n-                    _sdlConnection.startService(service, getSessionId(), true);\r\n-\r\n-                iter.remove();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void clearConnection(){\r\n-        _sdlConnection = null;\r\n-    }\r\n-\r\n-    public void checkForOpenMultiplexConnection(SdlConnection connection){\r\n-        removeConnection(connection);\r\n-        connection.unregisterSession(this);\r\n-        _sdlConnection = null;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == TransportType.MULTIPLEX) {\r\n-                if(c.getIsConnected() || ((MultiplexTransport)c._transport).isPendingConnected()){\r\n-                    _sdlConnection = c;\r\n-                    try {\r\n-                        _sdlConnection.registerSession(this);//Handshake will start when register.\r\n-                    } catch (SdlException e) {\r\n-                        e.printStackTrace();\r\n-                    }\r\n-                    return;\r\n-                }\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-    public static boolean removeConnection(SdlConnection connection){\r\n-        return shareConnections.remove(connection);\r\n-    }\r\n-\r\n-    public void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners == null){\r\n-            serviceListeners = new HashMap<>();\r\n-        }\r\n-        if(serviceType != null && sdlServiceListener != null){\r\n-            if(!serviceListeners.containsKey(serviceType)){\r\n-                serviceListeners.put(serviceType,new CopyOnWriteArrayList<ISdlServiceListener>());\r\n-            }\r\n-            serviceListeners.get(serviceType).add(sdlServiceListener);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners!= null && serviceType != null && sdlServiceListener != null && serviceListeners.containsKey(serviceType)){\r\n-            return serviceListeners.get(serviceType).remove(sdlServiceListener);\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-\r\n-    public HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> getServiceListeners(){\r\n-        return serviceListeners;\r\n-    }\r\n-\r\n-    public void setDesiredVideoParams(VideoStreamingParameters params){\r\n-        this.desiredVideoParams = params;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the currently set desired video streaming parameters. If there haven't been any set,\r\n-     * the default options will be returned and set for this instance.\r\n-     * @return\r\n-     */\r\n-    public VideoStreamingParameters getDesiredVideoParams(){\r\n-        if(desiredVideoParams == null){\r\n-            desiredVideoParams = new VideoStreamingParameters();\r\n-        }\r\n-        return desiredVideoParams;\r\n-    }\r\n-\r\n-    public void setAcceptedVideoParams(VideoStreamingParameters params){\r\n-        this.acceptedVideoParams = params;\r\n-    }\r\n-\r\n-    public VideoStreamingParameters getAcceptedVideoParams(){\r\n-        return acceptedVideoParams;\r\n-    }\r\n-\r\n-    private VideoStreamingProtocol getAcceptedProtocol() {\r\n-        // acquire default protocol (RAW)\r\n-        VideoStreamingProtocol protocol = new VideoStreamingParameters().getFormat().getProtocol();\r\n-\r\n-        if (acceptedVideoParams != null) {\r\n-            VideoStreamingFormat format = acceptedVideoParams.getFormat();\r\n-            if (format != null && format.getProtocol() != null) {\r\n-                protocol = format.getProtocol();\r\n-            }\r\n-        }\r\n-\r\n-        return protocol;\r\n-    }\r\n-\r\n-    public Version getProtocolVersion(){\r\n-        //Since this session version never supported a minor protocol version this should be fine\r\n-        return new Version(wiproProcolVer,0,0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if a transport is available to start/use the supplied service.\r\n-     * @param sessionType the session that should be checked for transport availability\r\n-     * @return true if there is either a supported\r\n-     *         transport currently connected or a transport is\r\n-     *         available to connect with for the supplied service type.\r\n-     *         <br>false if there is no\r\n-     *         transport connected to support the service type in question and\r\n-     *          no possibility in the foreseeable future.\r\n-     */\r\n-    public boolean isTransportForServiceAvailable(SessionType sessionType){\r\n-        return _sdlConnection!= null\r\n-                && _sdlConnection._transport!= null\r\n-                && _sdlConnection._transport.getIsConnected()\r\n-                && ((sessionType == SessionType.RPC || sessionType == SessionType.CONTROL || sessionType == SessionType.BULK_DATA ) //If this is a service that can run on any transport just return true\r\n-                    || (_sdlConnection._transport.getTransportType() == TransportType.USB || _sdlConnection._transport.getTransportType() == TransportType.TCP));\r\n-    }\r\n-\r\n-\r\n-}\n\\ No newline at end of file\n+/*\n+ * Copyright (c) 2018 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+import android.content.Context;\n+\n+import com.smartdevicelink.exception.SdlException;\n+import com.smartdevicelink.protocol.ISdlProtocol;", "originalCommit": "f8080616efd531480981fb265b611e91dffa8489", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NTQzMw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r463755433", "bodyText": "Unused Import", "author": "JulianKast", "createdAt": "2020-07-31T18:05:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NTAwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NTExNw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r463755117", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;", "author": "JulianKast", "createdAt": "2020-07-31T18:05:06Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -1,838 +1,339 @@\n-/*\r\n- * Copyright (c) 2017 - 2019, SmartDeviceLink Consortium, Inc.\r\n- * All rights reserved.\r\n- *\r\n- * Redistribution and use in source and binary forms, with or without\r\n- * modification, are permitted provided that the following conditions are met:\r\n- *\r\n- * Redistributions of source code must retain the above copyright notice, this\r\n- * list of conditions and the following disclaimer.\r\n- *\r\n- * Redistributions in binary form must reproduce the above copyright notice,\r\n- * this list of conditions and the following\r\n- * disclaimer in the documentation and/or other materials provided with the\r\n- * distribution.\r\n- *\r\n- * Neither the name of the SmartDeviceLink Consortium, Inc. nor the names of its\r\n- * contributors may be used to endorse or promote products derived from this \r\n- * software without specific prior written permission.\r\n- *\r\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n- * POSSIBILITY OF SUCH DAMAGE.\r\n- */\r\n-package com.smartdevicelink.SdlConnection;\r\n-\r\n-import android.annotation.SuppressLint;\r\n-import android.os.Build;\r\n-import android.view.Surface;\r\n-\r\n-import com.smartdevicelink.encoder.SdlEncoder;\r\n-import com.smartdevicelink.encoder.VirtualDisplayEncoder;\r\n-import com.smartdevicelink.exception.SdlException;\r\n-import com.smartdevicelink.protocol.ProtocolMessage;\r\n-import com.smartdevicelink.protocol.enums.SessionType;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitorListener;\r\n-import com.smartdevicelink.proxy.LockScreenManager;\r\n-import com.smartdevicelink.proxy.RPCRequest;\r\n-import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\r\n-import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\r\n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\r\n-import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\r\n-import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\r\n-import com.smartdevicelink.security.ISecurityInitializedListener;\r\n-import com.smartdevicelink.security.SdlSecurityBase;\r\n-import com.smartdevicelink.streaming.AbstractPacketizer;\r\n-import com.smartdevicelink.streaming.IStreamListener;\r\n-import com.smartdevicelink.streaming.StreamPacketizer;\r\n-import com.smartdevicelink.streaming.StreamRPCPacketizer;\r\n-import com.smartdevicelink.streaming.video.RTPH264Packetizer;\r\n-import com.smartdevicelink.streaming.video.VideoStreamingParameters;\r\n-import com.smartdevicelink.transport.BaseTransportConfig;\r\n-import com.smartdevicelink.transport.MultiplexTransport;\r\n-import com.smartdevicelink.transport.enums.TransportType;\r\n-import com.smartdevicelink.util.DebugTool;\r\n-import com.smartdevicelink.util.Version;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.OutputStream;\r\n-import java.io.PipedInputStream;\r\n-import java.io.PipedOutputStream;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.ListIterator;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-@Deprecated\r\n-public class SdlSession implements ISdlConnectionListener, IHeartbeatMonitorListener, IStreamListener, ISecurityInitializedListener {\r\n-\r\n-   private static final String TAG = \"SdlSession\";\r\n-\r\n-    protected final static int BUFF_READ_SIZE = 1024;\r\n-\r\n-\tprivate static CopyOnWriteArrayList<SdlConnection> shareConnections = new CopyOnWriteArrayList<SdlConnection>();\r\n-\r\n-\tprivate byte wiproProcolVer;\r\n-\r\n-    protected BaseTransportConfig transportConfig;\r\n-    protected ISdlConnectionListener sessionListener;\r\n-\tprotected LockScreenManager lockScreenMan  = new LockScreenManager();\r\n-\tprotected SdlSecurityBase sdlSecurity = null;\r\n-\tprotected VideoStreamingParameters desiredVideoParams = null;\r\n-\tprotected VideoStreamingParameters acceptedVideoParams = null;\r\n-\r\n-\tprotected byte sessionId;\r\n-\tprotected int sessionHashId = 0;\r\n-\tprotected HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> serviceListeners;\r\n-\tprotected CopyOnWriteArrayList<SessionType> encryptedServices = new CopyOnWriteArrayList<SessionType>();\r\n-\r\n-\r\n-\tSdlConnection _sdlConnection = null;\r\n-\r\n-\tIHeartbeatMonitor _outgoingHeartbeatMonitor = null;\r\n-\tIHeartbeatMonitor _incomingHeartbeatMonitor = null;\r\n-\r\n-    StreamRPCPacketizer mRPCPacketizer = null;\r\n-    AbstractPacketizer mVideoPacketizer = null;\r\n-    StreamPacketizer mAudioPacketizer = null;\r\n-    SdlEncoder mSdlEncoder = null;\r\n-    VirtualDisplayEncoder virtualDisplayEncoder = null;\r\n-    boolean sdlSecurityInitializing = false;\r\n-\r\n-    public static SdlSession createSession(byte wiproVersion, ISdlConnectionListener listener, BaseTransportConfig btConfig) {\r\n-\r\n-        SdlSession session =  new SdlSession();\r\n-        session.wiproProcolVer = wiproVersion;\r\n-        session.sessionListener = listener;\r\n-        session.transportConfig = btConfig;\r\n-\r\n-        return session;\r\n-    }\r\n-\r\n-    public BaseTransportConfig getTransportConfig() {\r\n-        return this.transportConfig;\r\n-    }\r\n-\r\n-    public LockScreenManager getLockScreenMan() {\r\n-        return lockScreenMan;\r\n-    }\r\n-\r\n-\r\n-    public IHeartbeatMonitor getOutgoingHeartbeatMonitor() {\r\n-        return _outgoingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public IHeartbeatMonitor getIncomingHeartbeatMonitor() {\r\n-        return _incomingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public void setOutgoingHeartbeatMonitor(IHeartbeatMonitor outgoingHeartbeatMonitor) {\r\n-        this._outgoingHeartbeatMonitor = outgoingHeartbeatMonitor;\r\n-        _outgoingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public void setIncomingHeartbeatMonitor(IHeartbeatMonitor incomingHeartbeatMonitor) {\r\n-        this._incomingHeartbeatMonitor = incomingHeartbeatMonitor;\r\n-        _incomingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public int getSessionHashId() {\r\n-        return this.sessionHashId;\r\n-    }\r\n-\r\n-    public byte getSessionId() {\r\n-        return this.sessionId;\r\n-    }\r\n-\r\n-    public SdlConnection getSdlConnection() {\r\n-        return this._sdlConnection;\r\n-    }\r\n-\r\n-    public int getMtu(){\r\n-        if(this._sdlConnection!=null){\r\n-            return this._sdlConnection.getWiProProtocol().getMtu();\r\n-        }else{\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public long getMtu(SessionType type) {\r\n-        if (this._sdlConnection != null) {\r\n-            return this._sdlConnection.getWiProProtocol().getMtu(type);\r\n-        } else {\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        if (sdlSecurity != null)\r\n-        {\r\n-            sdlSecurity.resetParams();\r\n-            sdlSecurity.shutDown();\r\n-        }\r\n-\r\n-        if (_sdlConnection != null) { //sessionId == 0 means session is not started.\r\n-            //_sdlConnection.unregisterSession(this);\r\n-\r\n-            if (_sdlConnection.getRegisterCount() == 0) {\r\n-                shareConnections.remove(_sdlConnection);\r\n-            }\r\n-\r\n-            _sdlConnection = null;\r\n-        }\r\n-    }\r\n-\r\n-    public void resetSession(){\r\n-\r\n-    }\r\n-\r\n-    public void startStream(InputStream is, SessionType sType, byte rpcSessionID) throws IOException {\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressLint(\"NewApi\")\r\n-    public OutputStream startStream(SessionType sType, byte rpcSessionID) throws IOException {\r\n-        OutputStream os = new PipedOutputStream();\r\n-        InputStream is = null;\r\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\r\n-            is = new PipedInputStream((PipedOutputStream) os, BUFF_READ_SIZE);\r\n-        } else {\r\n-            is = new PipedInputStream((PipedOutputStream) os);\r\n-        }\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-        else\r\n-        {\r\n-            os.close();\r\n-            is.close();\r\n-            return null;\r\n-        }\r\n-        return os;\r\n-    }\r\n-\r\n-    public IVideoStreamListener startVideoStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        VideoStreamingProtocol protocol = getAcceptedProtocol();\r\n-        try {\r\n-            switch (protocol) {\r\n-                case RAW: {\r\n-                    StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.NAV, rpcSessionID, this);\r\n-                    packetizer.sdlConnection = this.getSdlConnection();\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                case RTP: {\r\n-                    RTPH264Packetizer packetizer = new RTPH264Packetizer(this, SessionType.NAV, rpcSessionID, this);\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                default:\r\n-                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\r\n-                    return null;\r\n-            }\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    public IAudioStreamListener startAudioStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        try {\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.PCM, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer = packetizer;\r\n-            mAudioPacketizer.start();\r\n-            return packetizer;\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void startRPCStream(InputStream is, RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public OutputStream startRPCStream(RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            OutputStream os = new PipedOutputStream();\r\n-            InputStream is = new PipedInputStream((PipedOutputStream) os);\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-            return os;\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void pauseRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.pause();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void resumeRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.resume();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void stopRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.stop();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean stopAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean stopVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public Surface createOpenGLInputSurface(int frameRate, int iFrameInterval, int width,\r\n-                                            int height, int bitrate, SessionType sType, byte rpcSessionID) {\r\n-        IVideoStreamListener encoderListener = startVideoStream();\r\n-        if (encoderListener == null) {\r\n-            return null;\r\n-        }\r\n-\r\n-        mSdlEncoder = new SdlEncoder();\r\n-        mSdlEncoder.setFrameRate(frameRate);\r\n-        mSdlEncoder.setFrameInterval(iFrameInterval);\r\n-        mSdlEncoder.setFrameWidth(width);\r\n-        mSdlEncoder.setFrameHeight(height);\r\n-        mSdlEncoder.setBitrate(bitrate);\r\n-        mSdlEncoder.setOutputListener(encoderListener);\r\n-        return mSdlEncoder.prepareEncoder();\r\n-    }\r\n-\r\n-    public void startEncoder () {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.startEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void releaseEncoder() {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.releaseEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void drainEncoder(boolean endOfStream) {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.drainEncoder(endOfStream);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendStreamPacket(ProtocolMessage pm) {\r\n-        sendMessage(pm);\r\n-    }\r\n-\r\n-    public void setSdlSecurity(SdlSecurityBase sec) {\r\n-        sdlSecurity = sec;\r\n-    }\r\n-\r\n-    public SdlSecurityBase getSdlSecurity() {\r\n-        return sdlSecurity;\r\n-    }\r\n-\r\n-    public void startService (SessionType serviceType, byte sessionID, boolean isEncrypted) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-\r\n-        if (isEncrypted)\r\n-        {\r\n-            if (sdlSecurity != null)\r\n-            {\r\n-                List<SessionType> serviceList = sdlSecurity.getServiceList();\r\n-                if (!serviceList.contains(serviceType))\r\n-                    serviceList.add(serviceType);\r\n-\r\n-                if (!sdlSecurityInitializing) {\r\n-                    sdlSecurityInitializing = true;\r\n-                    sdlSecurity.initialize();\r\n-                    return;\r\n-                }\r\n-            }\r\n-        }\r\n-        _sdlConnection.startService(serviceType, sessionID, isEncrypted);\r\n-    }\r\n-\r\n-    public void endService (SessionType serviceType, byte sessionID) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.endService(serviceType, sessionID);\r\n-    }\r\n-\r\n-    protected void processControlService(ProtocolMessage msg) {\r\n-        if (sdlSecurity == null)\r\n-            return;\r\n-        int ilen = msg.getData().length - 12;\r\n-        byte[] data = new byte[ilen];\r\n-        System.arraycopy(msg.getData(), 12, data, 0, ilen);\r\n-\r\n-        byte[] dataToRead = new byte[4096];\r\n-\r\n-        Integer iNumBytes = sdlSecurity.runHandshake(data, dataToRead);\r\n-\r\n-        if (iNumBytes == null || iNumBytes <= 0)\r\n-            return;\r\n-\r\n-        byte[] returnBytes = new byte[iNumBytes];\r\n-        System.arraycopy(dataToRead, 0, returnBytes, 0, iNumBytes);\r\n-        ProtocolMessage protocolMessage = new ProtocolMessage();\r\n-        protocolMessage.setSessionType(SessionType.CONTROL);\r\n-        protocolMessage.setData(returnBytes);\r\n-        protocolMessage.setFunctionID(0x01);\r\n-        protocolMessage.setVersion(wiproProcolVer);\r\n-        protocolMessage.setSessionID(getSessionId());\r\n-\r\n-        //sdlSecurity.hs();\r\n-\r\n-        sendMessage(protocolMessage);\r\n-    }\r\n-\r\n-    public String getBroadcastComment(BaseTransportConfig myTransport) {\r\n-        SdlConnection connection = null;\r\n-        if (myTransport.shareConnection()) {\r\n-            connection = findTheProperConnection(myTransport);\r\n-        } else {\r\n-            connection = this._sdlConnection;\r\n-        }\r\n-\r\n-        if (connection != null)\r\n-            return connection.getBroadcastComment();\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-\r\n-    public void startSession() throws SdlException {\r\n-        SdlConnection connection = null;\r\n-        if (this.transportConfig.shareConnection()) {\r\n-            connection = findTheProperConnection(this.transportConfig);\r\n-\r\n-            if (connection == null) {\r\n-                connection = new SdlConnection(this.transportConfig);\r\n-                shareConnections.add(connection);\r\n-            }\r\n-        } else {\r\n-            connection = new SdlConnection(this.transportConfig);\r\n-        }\r\n-\r\n-        this._sdlConnection = connection;\r\n-        connection.registerSession(this); //Handshake will start when register.\r\n-    }\r\n-\r\n-    protected void initialiseSession() {\r\n-        if (_outgoingHeartbeatMonitor != null) {\r\n-            _outgoingHeartbeatMonitor.start();\r\n-        }\r\n-        if (_incomingHeartbeatMonitor != null) {\r\n-            _incomingHeartbeatMonitor.start();\r\n-        }\r\n-    }\r\n-\r\n-    public void sendMessage(ProtocolMessage msg) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.sendMessage(msg);\r\n-    }\r\n-\r\n-    public TransportType getCurrentTransportType() {\r\n-        if (_sdlConnection == null)\r\n-            return null;\r\n-        return _sdlConnection.getCurrentTransportType();\r\n-    }\r\n-\r\n-    public boolean getIsConnected() {\r\n-        if (_sdlConnection == null)\r\n-            return false;\r\n-        return _sdlConnection != null && _sdlConnection.getIsConnected();\r\n-    }\r\n-\r\n-    public boolean isServiceProtected(SessionType sType) {\r\n-        return encryptedServices.contains(sType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info, boolean availablePrimary, BaseTransportConfig transportConfig) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportError(String info, Exception e) {\r\n-        this.sessionListener.onTransportError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolMessageReceived(ProtocolMessage msg) {\r\n-        if (msg.getSessionType().equals(SessionType.CONTROL)) {\r\n-            processControlService(msg);\r\n-            return;\r\n-        }\r\n-\r\n-        this.sessionListener.onProtocolMessageReceived(msg);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onHeartbeatTimedOut(byte sessionID) {\r\n-        this.sessionListener.onHeartbeatTimedOut(sessionID);\r\n-\r\n-    }\r\n-\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStarted(SessionType sessionType,\r\n-                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\r\n-        this.sessionId = sessionID;\r\n-        lockScreenMan.setSessionID(sessionID);\r\n-        if (sessionType.eq(SessionType.RPC)){\r\n-            sessionHashId = hashID;\r\n-            wiproProcolVer = version;\r\n-        }\r\n-        if (isEncrypted)\r\n-            encryptedServices.addIfAbsent(sessionType);\r\n-        this.sessionListener.onProtocolSessionStarted(sessionType, sessionID, version, correlationID, hashID, isEncrypted);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceStarted(this, sessionType, isEncrypted);\r\n-            }\r\n-        }\r\n-        //if (version == 3)\r\n-        initialiseSession();\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEnded(SessionType sessionType, byte sessionID,\r\n-                                       String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEnded(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceEnded(this, sessionType);\r\n-            }\r\n-        }\r\n-        encryptedServices.remove(sessionType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolError(String info, Exception e) {\r\n-        this.sessionListener.onProtocolError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendHeartbeat(IHeartbeatMonitor monitor) {\r\n-        DebugTool.logInfo(TAG, \"Asked to send heartbeat\");\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection.sendHeartbeat(this);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void heartbeatTimedOut(IHeartbeatMonitor monitor) {\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection._connectionListener.onHeartbeatTimedOut(this.sessionId);\r\n-        close();\r\n-    }\r\n-\r\n-    private static SdlConnection findTheProperConnection(BaseTransportConfig config) {\r\n-        SdlConnection connection = null;\r\n-\r\n-        int minCount = 0;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == config.getTransportType()) {\r\n-                if (minCount == 0 || minCount >= c.getRegisterCount()) {\r\n-                    connection = c;\r\n-                    minCount = c.getRegisterCount();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStartedNACKed(SessionType sessionType,\r\n-                                               byte sessionID, byte version, String correlationID, List<String> rejectedParams) {\r\n-        this.sessionListener.onProtocolSessionStartedNACKed(sessionType,\r\n-                sessionID, version, correlationID, rejectedParams);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"Start \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEndedNACKed(SessionType sessionType,\r\n-                                             byte sessionID, String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEndedNACKed(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"End \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolServiceDataACK(SessionType sessionType, int dataSize, byte sessionID) {\r\n-        this.sessionListener.onProtocolServiceDataACK(sessionType, dataSize, sessionID);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onAuthTokenReceived(String authToken, byte sessionId) {\r\n-        this.sessionListener.onAuthTokenReceived(authToken, sessionId);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onSecurityInitialized() {\r\n-\r\n-        if (_sdlConnection != null && sdlSecurity != null)\r\n-        {\r\n-            List<SessionType> list = sdlSecurity.getServiceList();\r\n-\r\n-            SessionType service;\r\n-            ListIterator<SessionType> iter = list.listIterator();\r\n-\r\n-            while (iter.hasNext()) {\r\n-                service = iter.next();\r\n-\r\n-                if (service != null)\r\n-                    _sdlConnection.startService(service, getSessionId(), true);\r\n-\r\n-                iter.remove();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void clearConnection(){\r\n-        _sdlConnection = null;\r\n-    }\r\n-\r\n-    public void checkForOpenMultiplexConnection(SdlConnection connection){\r\n-        removeConnection(connection);\r\n-        connection.unregisterSession(this);\r\n-        _sdlConnection = null;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == TransportType.MULTIPLEX) {\r\n-                if(c.getIsConnected() || ((MultiplexTransport)c._transport).isPendingConnected()){\r\n-                    _sdlConnection = c;\r\n-                    try {\r\n-                        _sdlConnection.registerSession(this);//Handshake will start when register.\r\n-                    } catch (SdlException e) {\r\n-                        e.printStackTrace();\r\n-                    }\r\n-                    return;\r\n-                }\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-    public static boolean removeConnection(SdlConnection connection){\r\n-        return shareConnections.remove(connection);\r\n-    }\r\n-\r\n-    public void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners == null){\r\n-            serviceListeners = new HashMap<>();\r\n-        }\r\n-        if(serviceType != null && sdlServiceListener != null){\r\n-            if(!serviceListeners.containsKey(serviceType)){\r\n-                serviceListeners.put(serviceType,new CopyOnWriteArrayList<ISdlServiceListener>());\r\n-            }\r\n-            serviceListeners.get(serviceType).add(sdlServiceListener);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners!= null && serviceType != null && sdlServiceListener != null && serviceListeners.containsKey(serviceType)){\r\n-            return serviceListeners.get(serviceType).remove(sdlServiceListener);\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-\r\n-    public HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> getServiceListeners(){\r\n-        return serviceListeners;\r\n-    }\r\n-\r\n-    public void setDesiredVideoParams(VideoStreamingParameters params){\r\n-        this.desiredVideoParams = params;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the currently set desired video streaming parameters. If there haven't been any set,\r\n-     * the default options will be returned and set for this instance.\r\n-     * @return\r\n-     */\r\n-    public VideoStreamingParameters getDesiredVideoParams(){\r\n-        if(desiredVideoParams == null){\r\n-            desiredVideoParams = new VideoStreamingParameters();\r\n-        }\r\n-        return desiredVideoParams;\r\n-    }\r\n-\r\n-    public void setAcceptedVideoParams(VideoStreamingParameters params){\r\n-        this.acceptedVideoParams = params;\r\n-    }\r\n-\r\n-    public VideoStreamingParameters getAcceptedVideoParams(){\r\n-        return acceptedVideoParams;\r\n-    }\r\n-\r\n-    private VideoStreamingProtocol getAcceptedProtocol() {\r\n-        // acquire default protocol (RAW)\r\n-        VideoStreamingProtocol protocol = new VideoStreamingParameters().getFormat().getProtocol();\r\n-\r\n-        if (acceptedVideoParams != null) {\r\n-            VideoStreamingFormat format = acceptedVideoParams.getFormat();\r\n-            if (format != null && format.getProtocol() != null) {\r\n-                protocol = format.getProtocol();\r\n-            }\r\n-        }\r\n-\r\n-        return protocol;\r\n-    }\r\n-\r\n-    public Version getProtocolVersion(){\r\n-        //Since this session version never supported a minor protocol version this should be fine\r\n-        return new Version(wiproProcolVer,0,0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if a transport is available to start/use the supplied service.\r\n-     * @param sessionType the session that should be checked for transport availability\r\n-     * @return true if there is either a supported\r\n-     *         transport currently connected or a transport is\r\n-     *         available to connect with for the supplied service type.\r\n-     *         <br>false if there is no\r\n-     *         transport connected to support the service type in question and\r\n-     *          no possibility in the foreseeable future.\r\n-     */\r\n-    public boolean isTransportForServiceAvailable(SessionType sessionType){\r\n-        return _sdlConnection!= null\r\n-                && _sdlConnection._transport!= null\r\n-                && _sdlConnection._transport.getIsConnected()\r\n-                && ((sessionType == SessionType.RPC || sessionType == SessionType.CONTROL || sessionType == SessionType.BULK_DATA ) //If this is a service that can run on any transport just return true\r\n-                    || (_sdlConnection._transport.getTransportType() == TransportType.USB || _sdlConnection._transport.getTransportType() == TransportType.TCP));\r\n-    }\r\n-\r\n-\r\n-}\n\\ No newline at end of file\n+/*\n+ * Copyright (c) 2018 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+import android.content.Context;\n+\n+import com.smartdevicelink.exception.SdlException;\n+import com.smartdevicelink.protocol.ISdlProtocol;\n+import com.smartdevicelink.protocol.ProtocolMessage;\n+import com.smartdevicelink.protocol.SdlPacket;\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;", "originalCommit": "f8080616efd531480981fb265b611e91dffa8489", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NTI0OQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r463755249", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import com.smartdevicelink.transport.BaseTransportConfig;", "author": "JulianKast", "createdAt": "2020-07-31T18:05:22Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -1,838 +1,339 @@\n-/*\r\n- * Copyright (c) 2017 - 2019, SmartDeviceLink Consortium, Inc.\r\n- * All rights reserved.\r\n- *\r\n- * Redistribution and use in source and binary forms, with or without\r\n- * modification, are permitted provided that the following conditions are met:\r\n- *\r\n- * Redistributions of source code must retain the above copyright notice, this\r\n- * list of conditions and the following disclaimer.\r\n- *\r\n- * Redistributions in binary form must reproduce the above copyright notice,\r\n- * this list of conditions and the following\r\n- * disclaimer in the documentation and/or other materials provided with the\r\n- * distribution.\r\n- *\r\n- * Neither the name of the SmartDeviceLink Consortium, Inc. nor the names of its\r\n- * contributors may be used to endorse or promote products derived from this \r\n- * software without specific prior written permission.\r\n- *\r\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n- * POSSIBILITY OF SUCH DAMAGE.\r\n- */\r\n-package com.smartdevicelink.SdlConnection;\r\n-\r\n-import android.annotation.SuppressLint;\r\n-import android.os.Build;\r\n-import android.view.Surface;\r\n-\r\n-import com.smartdevicelink.encoder.SdlEncoder;\r\n-import com.smartdevicelink.encoder.VirtualDisplayEncoder;\r\n-import com.smartdevicelink.exception.SdlException;\r\n-import com.smartdevicelink.protocol.ProtocolMessage;\r\n-import com.smartdevicelink.protocol.enums.SessionType;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitorListener;\r\n-import com.smartdevicelink.proxy.LockScreenManager;\r\n-import com.smartdevicelink.proxy.RPCRequest;\r\n-import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\r\n-import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\r\n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\r\n-import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\r\n-import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\r\n-import com.smartdevicelink.security.ISecurityInitializedListener;\r\n-import com.smartdevicelink.security.SdlSecurityBase;\r\n-import com.smartdevicelink.streaming.AbstractPacketizer;\r\n-import com.smartdevicelink.streaming.IStreamListener;\r\n-import com.smartdevicelink.streaming.StreamPacketizer;\r\n-import com.smartdevicelink.streaming.StreamRPCPacketizer;\r\n-import com.smartdevicelink.streaming.video.RTPH264Packetizer;\r\n-import com.smartdevicelink.streaming.video.VideoStreamingParameters;\r\n-import com.smartdevicelink.transport.BaseTransportConfig;\r\n-import com.smartdevicelink.transport.MultiplexTransport;\r\n-import com.smartdevicelink.transport.enums.TransportType;\r\n-import com.smartdevicelink.util.DebugTool;\r\n-import com.smartdevicelink.util.Version;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.OutputStream;\r\n-import java.io.PipedInputStream;\r\n-import java.io.PipedOutputStream;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.ListIterator;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-@Deprecated\r\n-public class SdlSession implements ISdlConnectionListener, IHeartbeatMonitorListener, IStreamListener, ISecurityInitializedListener {\r\n-\r\n-   private static final String TAG = \"SdlSession\";\r\n-\r\n-    protected final static int BUFF_READ_SIZE = 1024;\r\n-\r\n-\tprivate static CopyOnWriteArrayList<SdlConnection> shareConnections = new CopyOnWriteArrayList<SdlConnection>();\r\n-\r\n-\tprivate byte wiproProcolVer;\r\n-\r\n-    protected BaseTransportConfig transportConfig;\r\n-    protected ISdlConnectionListener sessionListener;\r\n-\tprotected LockScreenManager lockScreenMan  = new LockScreenManager();\r\n-\tprotected SdlSecurityBase sdlSecurity = null;\r\n-\tprotected VideoStreamingParameters desiredVideoParams = null;\r\n-\tprotected VideoStreamingParameters acceptedVideoParams = null;\r\n-\r\n-\tprotected byte sessionId;\r\n-\tprotected int sessionHashId = 0;\r\n-\tprotected HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> serviceListeners;\r\n-\tprotected CopyOnWriteArrayList<SessionType> encryptedServices = new CopyOnWriteArrayList<SessionType>();\r\n-\r\n-\r\n-\tSdlConnection _sdlConnection = null;\r\n-\r\n-\tIHeartbeatMonitor _outgoingHeartbeatMonitor = null;\r\n-\tIHeartbeatMonitor _incomingHeartbeatMonitor = null;\r\n-\r\n-    StreamRPCPacketizer mRPCPacketizer = null;\r\n-    AbstractPacketizer mVideoPacketizer = null;\r\n-    StreamPacketizer mAudioPacketizer = null;\r\n-    SdlEncoder mSdlEncoder = null;\r\n-    VirtualDisplayEncoder virtualDisplayEncoder = null;\r\n-    boolean sdlSecurityInitializing = false;\r\n-\r\n-    public static SdlSession createSession(byte wiproVersion, ISdlConnectionListener listener, BaseTransportConfig btConfig) {\r\n-\r\n-        SdlSession session =  new SdlSession();\r\n-        session.wiproProcolVer = wiproVersion;\r\n-        session.sessionListener = listener;\r\n-        session.transportConfig = btConfig;\r\n-\r\n-        return session;\r\n-    }\r\n-\r\n-    public BaseTransportConfig getTransportConfig() {\r\n-        return this.transportConfig;\r\n-    }\r\n-\r\n-    public LockScreenManager getLockScreenMan() {\r\n-        return lockScreenMan;\r\n-    }\r\n-\r\n-\r\n-    public IHeartbeatMonitor getOutgoingHeartbeatMonitor() {\r\n-        return _outgoingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public IHeartbeatMonitor getIncomingHeartbeatMonitor() {\r\n-        return _incomingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public void setOutgoingHeartbeatMonitor(IHeartbeatMonitor outgoingHeartbeatMonitor) {\r\n-        this._outgoingHeartbeatMonitor = outgoingHeartbeatMonitor;\r\n-        _outgoingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public void setIncomingHeartbeatMonitor(IHeartbeatMonitor incomingHeartbeatMonitor) {\r\n-        this._incomingHeartbeatMonitor = incomingHeartbeatMonitor;\r\n-        _incomingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public int getSessionHashId() {\r\n-        return this.sessionHashId;\r\n-    }\r\n-\r\n-    public byte getSessionId() {\r\n-        return this.sessionId;\r\n-    }\r\n-\r\n-    public SdlConnection getSdlConnection() {\r\n-        return this._sdlConnection;\r\n-    }\r\n-\r\n-    public int getMtu(){\r\n-        if(this._sdlConnection!=null){\r\n-            return this._sdlConnection.getWiProProtocol().getMtu();\r\n-        }else{\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public long getMtu(SessionType type) {\r\n-        if (this._sdlConnection != null) {\r\n-            return this._sdlConnection.getWiProProtocol().getMtu(type);\r\n-        } else {\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        if (sdlSecurity != null)\r\n-        {\r\n-            sdlSecurity.resetParams();\r\n-            sdlSecurity.shutDown();\r\n-        }\r\n-\r\n-        if (_sdlConnection != null) { //sessionId == 0 means session is not started.\r\n-            //_sdlConnection.unregisterSession(this);\r\n-\r\n-            if (_sdlConnection.getRegisterCount() == 0) {\r\n-                shareConnections.remove(_sdlConnection);\r\n-            }\r\n-\r\n-            _sdlConnection = null;\r\n-        }\r\n-    }\r\n-\r\n-    public void resetSession(){\r\n-\r\n-    }\r\n-\r\n-    public void startStream(InputStream is, SessionType sType, byte rpcSessionID) throws IOException {\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressLint(\"NewApi\")\r\n-    public OutputStream startStream(SessionType sType, byte rpcSessionID) throws IOException {\r\n-        OutputStream os = new PipedOutputStream();\r\n-        InputStream is = null;\r\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\r\n-            is = new PipedInputStream((PipedOutputStream) os, BUFF_READ_SIZE);\r\n-        } else {\r\n-            is = new PipedInputStream((PipedOutputStream) os);\r\n-        }\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-        else\r\n-        {\r\n-            os.close();\r\n-            is.close();\r\n-            return null;\r\n-        }\r\n-        return os;\r\n-    }\r\n-\r\n-    public IVideoStreamListener startVideoStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        VideoStreamingProtocol protocol = getAcceptedProtocol();\r\n-        try {\r\n-            switch (protocol) {\r\n-                case RAW: {\r\n-                    StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.NAV, rpcSessionID, this);\r\n-                    packetizer.sdlConnection = this.getSdlConnection();\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                case RTP: {\r\n-                    RTPH264Packetizer packetizer = new RTPH264Packetizer(this, SessionType.NAV, rpcSessionID, this);\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                default:\r\n-                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\r\n-                    return null;\r\n-            }\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    public IAudioStreamListener startAudioStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        try {\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.PCM, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer = packetizer;\r\n-            mAudioPacketizer.start();\r\n-            return packetizer;\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void startRPCStream(InputStream is, RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public OutputStream startRPCStream(RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            OutputStream os = new PipedOutputStream();\r\n-            InputStream is = new PipedInputStream((PipedOutputStream) os);\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-            return os;\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void pauseRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.pause();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void resumeRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.resume();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void stopRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.stop();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean stopAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean stopVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public Surface createOpenGLInputSurface(int frameRate, int iFrameInterval, int width,\r\n-                                            int height, int bitrate, SessionType sType, byte rpcSessionID) {\r\n-        IVideoStreamListener encoderListener = startVideoStream();\r\n-        if (encoderListener == null) {\r\n-            return null;\r\n-        }\r\n-\r\n-        mSdlEncoder = new SdlEncoder();\r\n-        mSdlEncoder.setFrameRate(frameRate);\r\n-        mSdlEncoder.setFrameInterval(iFrameInterval);\r\n-        mSdlEncoder.setFrameWidth(width);\r\n-        mSdlEncoder.setFrameHeight(height);\r\n-        mSdlEncoder.setBitrate(bitrate);\r\n-        mSdlEncoder.setOutputListener(encoderListener);\r\n-        return mSdlEncoder.prepareEncoder();\r\n-    }\r\n-\r\n-    public void startEncoder () {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.startEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void releaseEncoder() {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.releaseEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void drainEncoder(boolean endOfStream) {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.drainEncoder(endOfStream);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendStreamPacket(ProtocolMessage pm) {\r\n-        sendMessage(pm);\r\n-    }\r\n-\r\n-    public void setSdlSecurity(SdlSecurityBase sec) {\r\n-        sdlSecurity = sec;\r\n-    }\r\n-\r\n-    public SdlSecurityBase getSdlSecurity() {\r\n-        return sdlSecurity;\r\n-    }\r\n-\r\n-    public void startService (SessionType serviceType, byte sessionID, boolean isEncrypted) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-\r\n-        if (isEncrypted)\r\n-        {\r\n-            if (sdlSecurity != null)\r\n-            {\r\n-                List<SessionType> serviceList = sdlSecurity.getServiceList();\r\n-                if (!serviceList.contains(serviceType))\r\n-                    serviceList.add(serviceType);\r\n-\r\n-                if (!sdlSecurityInitializing) {\r\n-                    sdlSecurityInitializing = true;\r\n-                    sdlSecurity.initialize();\r\n-                    return;\r\n-                }\r\n-            }\r\n-        }\r\n-        _sdlConnection.startService(serviceType, sessionID, isEncrypted);\r\n-    }\r\n-\r\n-    public void endService (SessionType serviceType, byte sessionID) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.endService(serviceType, sessionID);\r\n-    }\r\n-\r\n-    protected void processControlService(ProtocolMessage msg) {\r\n-        if (sdlSecurity == null)\r\n-            return;\r\n-        int ilen = msg.getData().length - 12;\r\n-        byte[] data = new byte[ilen];\r\n-        System.arraycopy(msg.getData(), 12, data, 0, ilen);\r\n-\r\n-        byte[] dataToRead = new byte[4096];\r\n-\r\n-        Integer iNumBytes = sdlSecurity.runHandshake(data, dataToRead);\r\n-\r\n-        if (iNumBytes == null || iNumBytes <= 0)\r\n-            return;\r\n-\r\n-        byte[] returnBytes = new byte[iNumBytes];\r\n-        System.arraycopy(dataToRead, 0, returnBytes, 0, iNumBytes);\r\n-        ProtocolMessage protocolMessage = new ProtocolMessage();\r\n-        protocolMessage.setSessionType(SessionType.CONTROL);\r\n-        protocolMessage.setData(returnBytes);\r\n-        protocolMessage.setFunctionID(0x01);\r\n-        protocolMessage.setVersion(wiproProcolVer);\r\n-        protocolMessage.setSessionID(getSessionId());\r\n-\r\n-        //sdlSecurity.hs();\r\n-\r\n-        sendMessage(protocolMessage);\r\n-    }\r\n-\r\n-    public String getBroadcastComment(BaseTransportConfig myTransport) {\r\n-        SdlConnection connection = null;\r\n-        if (myTransport.shareConnection()) {\r\n-            connection = findTheProperConnection(myTransport);\r\n-        } else {\r\n-            connection = this._sdlConnection;\r\n-        }\r\n-\r\n-        if (connection != null)\r\n-            return connection.getBroadcastComment();\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-\r\n-    public void startSession() throws SdlException {\r\n-        SdlConnection connection = null;\r\n-        if (this.transportConfig.shareConnection()) {\r\n-            connection = findTheProperConnection(this.transportConfig);\r\n-\r\n-            if (connection == null) {\r\n-                connection = new SdlConnection(this.transportConfig);\r\n-                shareConnections.add(connection);\r\n-            }\r\n-        } else {\r\n-            connection = new SdlConnection(this.transportConfig);\r\n-        }\r\n-\r\n-        this._sdlConnection = connection;\r\n-        connection.registerSession(this); //Handshake will start when register.\r\n-    }\r\n-\r\n-    protected void initialiseSession() {\r\n-        if (_outgoingHeartbeatMonitor != null) {\r\n-            _outgoingHeartbeatMonitor.start();\r\n-        }\r\n-        if (_incomingHeartbeatMonitor != null) {\r\n-            _incomingHeartbeatMonitor.start();\r\n-        }\r\n-    }\r\n-\r\n-    public void sendMessage(ProtocolMessage msg) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.sendMessage(msg);\r\n-    }\r\n-\r\n-    public TransportType getCurrentTransportType() {\r\n-        if (_sdlConnection == null)\r\n-            return null;\r\n-        return _sdlConnection.getCurrentTransportType();\r\n-    }\r\n-\r\n-    public boolean getIsConnected() {\r\n-        if (_sdlConnection == null)\r\n-            return false;\r\n-        return _sdlConnection != null && _sdlConnection.getIsConnected();\r\n-    }\r\n-\r\n-    public boolean isServiceProtected(SessionType sType) {\r\n-        return encryptedServices.contains(sType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info, boolean availablePrimary, BaseTransportConfig transportConfig) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportError(String info, Exception e) {\r\n-        this.sessionListener.onTransportError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolMessageReceived(ProtocolMessage msg) {\r\n-        if (msg.getSessionType().equals(SessionType.CONTROL)) {\r\n-            processControlService(msg);\r\n-            return;\r\n-        }\r\n-\r\n-        this.sessionListener.onProtocolMessageReceived(msg);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onHeartbeatTimedOut(byte sessionID) {\r\n-        this.sessionListener.onHeartbeatTimedOut(sessionID);\r\n-\r\n-    }\r\n-\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStarted(SessionType sessionType,\r\n-                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\r\n-        this.sessionId = sessionID;\r\n-        lockScreenMan.setSessionID(sessionID);\r\n-        if (sessionType.eq(SessionType.RPC)){\r\n-            sessionHashId = hashID;\r\n-            wiproProcolVer = version;\r\n-        }\r\n-        if (isEncrypted)\r\n-            encryptedServices.addIfAbsent(sessionType);\r\n-        this.sessionListener.onProtocolSessionStarted(sessionType, sessionID, version, correlationID, hashID, isEncrypted);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceStarted(this, sessionType, isEncrypted);\r\n-            }\r\n-        }\r\n-        //if (version == 3)\r\n-        initialiseSession();\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEnded(SessionType sessionType, byte sessionID,\r\n-                                       String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEnded(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceEnded(this, sessionType);\r\n-            }\r\n-        }\r\n-        encryptedServices.remove(sessionType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolError(String info, Exception e) {\r\n-        this.sessionListener.onProtocolError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendHeartbeat(IHeartbeatMonitor monitor) {\r\n-        DebugTool.logInfo(TAG, \"Asked to send heartbeat\");\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection.sendHeartbeat(this);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void heartbeatTimedOut(IHeartbeatMonitor monitor) {\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection._connectionListener.onHeartbeatTimedOut(this.sessionId);\r\n-        close();\r\n-    }\r\n-\r\n-    private static SdlConnection findTheProperConnection(BaseTransportConfig config) {\r\n-        SdlConnection connection = null;\r\n-\r\n-        int minCount = 0;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == config.getTransportType()) {\r\n-                if (minCount == 0 || minCount >= c.getRegisterCount()) {\r\n-                    connection = c;\r\n-                    minCount = c.getRegisterCount();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStartedNACKed(SessionType sessionType,\r\n-                                               byte sessionID, byte version, String correlationID, List<String> rejectedParams) {\r\n-        this.sessionListener.onProtocolSessionStartedNACKed(sessionType,\r\n-                sessionID, version, correlationID, rejectedParams);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"Start \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEndedNACKed(SessionType sessionType,\r\n-                                             byte sessionID, String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEndedNACKed(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"End \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolServiceDataACK(SessionType sessionType, int dataSize, byte sessionID) {\r\n-        this.sessionListener.onProtocolServiceDataACK(sessionType, dataSize, sessionID);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onAuthTokenReceived(String authToken, byte sessionId) {\r\n-        this.sessionListener.onAuthTokenReceived(authToken, sessionId);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onSecurityInitialized() {\r\n-\r\n-        if (_sdlConnection != null && sdlSecurity != null)\r\n-        {\r\n-            List<SessionType> list = sdlSecurity.getServiceList();\r\n-\r\n-            SessionType service;\r\n-            ListIterator<SessionType> iter = list.listIterator();\r\n-\r\n-            while (iter.hasNext()) {\r\n-                service = iter.next();\r\n-\r\n-                if (service != null)\r\n-                    _sdlConnection.startService(service, getSessionId(), true);\r\n-\r\n-                iter.remove();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void clearConnection(){\r\n-        _sdlConnection = null;\r\n-    }\r\n-\r\n-    public void checkForOpenMultiplexConnection(SdlConnection connection){\r\n-        removeConnection(connection);\r\n-        connection.unregisterSession(this);\r\n-        _sdlConnection = null;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == TransportType.MULTIPLEX) {\r\n-                if(c.getIsConnected() || ((MultiplexTransport)c._transport).isPendingConnected()){\r\n-                    _sdlConnection = c;\r\n-                    try {\r\n-                        _sdlConnection.registerSession(this);//Handshake will start when register.\r\n-                    } catch (SdlException e) {\r\n-                        e.printStackTrace();\r\n-                    }\r\n-                    return;\r\n-                }\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-    public static boolean removeConnection(SdlConnection connection){\r\n-        return shareConnections.remove(connection);\r\n-    }\r\n-\r\n-    public void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners == null){\r\n-            serviceListeners = new HashMap<>();\r\n-        }\r\n-        if(serviceType != null && sdlServiceListener != null){\r\n-            if(!serviceListeners.containsKey(serviceType)){\r\n-                serviceListeners.put(serviceType,new CopyOnWriteArrayList<ISdlServiceListener>());\r\n-            }\r\n-            serviceListeners.get(serviceType).add(sdlServiceListener);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners!= null && serviceType != null && sdlServiceListener != null && serviceListeners.containsKey(serviceType)){\r\n-            return serviceListeners.get(serviceType).remove(sdlServiceListener);\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-\r\n-    public HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> getServiceListeners(){\r\n-        return serviceListeners;\r\n-    }\r\n-\r\n-    public void setDesiredVideoParams(VideoStreamingParameters params){\r\n-        this.desiredVideoParams = params;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the currently set desired video streaming parameters. If there haven't been any set,\r\n-     * the default options will be returned and set for this instance.\r\n-     * @return\r\n-     */\r\n-    public VideoStreamingParameters getDesiredVideoParams(){\r\n-        if(desiredVideoParams == null){\r\n-            desiredVideoParams = new VideoStreamingParameters();\r\n-        }\r\n-        return desiredVideoParams;\r\n-    }\r\n-\r\n-    public void setAcceptedVideoParams(VideoStreamingParameters params){\r\n-        this.acceptedVideoParams = params;\r\n-    }\r\n-\r\n-    public VideoStreamingParameters getAcceptedVideoParams(){\r\n-        return acceptedVideoParams;\r\n-    }\r\n-\r\n-    private VideoStreamingProtocol getAcceptedProtocol() {\r\n-        // acquire default protocol (RAW)\r\n-        VideoStreamingProtocol protocol = new VideoStreamingParameters().getFormat().getProtocol();\r\n-\r\n-        if (acceptedVideoParams != null) {\r\n-            VideoStreamingFormat format = acceptedVideoParams.getFormat();\r\n-            if (format != null && format.getProtocol() != null) {\r\n-                protocol = format.getProtocol();\r\n-            }\r\n-        }\r\n-\r\n-        return protocol;\r\n-    }\r\n-\r\n-    public Version getProtocolVersion(){\r\n-        //Since this session version never supported a minor protocol version this should be fine\r\n-        return new Version(wiproProcolVer,0,0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if a transport is available to start/use the supplied service.\r\n-     * @param sessionType the session that should be checked for transport availability\r\n-     * @return true if there is either a supported\r\n-     *         transport currently connected or a transport is\r\n-     *         available to connect with for the supplied service type.\r\n-     *         <br>false if there is no\r\n-     *         transport connected to support the service type in question and\r\n-     *          no possibility in the foreseeable future.\r\n-     */\r\n-    public boolean isTransportForServiceAvailable(SessionType sessionType){\r\n-        return _sdlConnection!= null\r\n-                && _sdlConnection._transport!= null\r\n-                && _sdlConnection._transport.getIsConnected()\r\n-                && ((sessionType == SessionType.RPC || sessionType == SessionType.CONTROL || sessionType == SessionType.BULK_DATA ) //If this is a service that can run on any transport just return true\r\n-                    || (_sdlConnection._transport.getTransportType() == TransportType.USB || _sdlConnection._transport.getTransportType() == TransportType.TCP));\r\n-    }\r\n-\r\n-\r\n-}\n\\ No newline at end of file\n+/*\n+ * Copyright (c) 2018 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+import android.content.Context;\n+\n+import com.smartdevicelink.exception.SdlException;\n+import com.smartdevicelink.protocol.ISdlProtocol;\n+import com.smartdevicelink.protocol.ProtocolMessage;\n+import com.smartdevicelink.protocol.SdlPacket;\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\n+import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\n+import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\n+import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\n+import com.smartdevicelink.streaming.AbstractPacketizer;\n+import com.smartdevicelink.streaming.IStreamListener;\n+import com.smartdevicelink.streaming.StreamPacketizer;\n+import com.smartdevicelink.streaming.video.RTPH264Packetizer;\n+import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n+import com.smartdevicelink.transport.BaseTransportConfig;", "originalCommit": "f8080616efd531480981fb265b611e91dffa8489", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NTM1MQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r463755351", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import java.util.ListIterator;", "author": "JulianKast", "createdAt": "2020-07-31T18:05:35Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -1,838 +1,339 @@\n-/*\r\n- * Copyright (c) 2017 - 2019, SmartDeviceLink Consortium, Inc.\r\n- * All rights reserved.\r\n- *\r\n- * Redistribution and use in source and binary forms, with or without\r\n- * modification, are permitted provided that the following conditions are met:\r\n- *\r\n- * Redistributions of source code must retain the above copyright notice, this\r\n- * list of conditions and the following disclaimer.\r\n- *\r\n- * Redistributions in binary form must reproduce the above copyright notice,\r\n- * this list of conditions and the following\r\n- * disclaimer in the documentation and/or other materials provided with the\r\n- * distribution.\r\n- *\r\n- * Neither the name of the SmartDeviceLink Consortium, Inc. nor the names of its\r\n- * contributors may be used to endorse or promote products derived from this \r\n- * software without specific prior written permission.\r\n- *\r\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n- * POSSIBILITY OF SUCH DAMAGE.\r\n- */\r\n-package com.smartdevicelink.SdlConnection;\r\n-\r\n-import android.annotation.SuppressLint;\r\n-import android.os.Build;\r\n-import android.view.Surface;\r\n-\r\n-import com.smartdevicelink.encoder.SdlEncoder;\r\n-import com.smartdevicelink.encoder.VirtualDisplayEncoder;\r\n-import com.smartdevicelink.exception.SdlException;\r\n-import com.smartdevicelink.protocol.ProtocolMessage;\r\n-import com.smartdevicelink.protocol.enums.SessionType;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitorListener;\r\n-import com.smartdevicelink.proxy.LockScreenManager;\r\n-import com.smartdevicelink.proxy.RPCRequest;\r\n-import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\r\n-import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\r\n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\r\n-import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\r\n-import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\r\n-import com.smartdevicelink.security.ISecurityInitializedListener;\r\n-import com.smartdevicelink.security.SdlSecurityBase;\r\n-import com.smartdevicelink.streaming.AbstractPacketizer;\r\n-import com.smartdevicelink.streaming.IStreamListener;\r\n-import com.smartdevicelink.streaming.StreamPacketizer;\r\n-import com.smartdevicelink.streaming.StreamRPCPacketizer;\r\n-import com.smartdevicelink.streaming.video.RTPH264Packetizer;\r\n-import com.smartdevicelink.streaming.video.VideoStreamingParameters;\r\n-import com.smartdevicelink.transport.BaseTransportConfig;\r\n-import com.smartdevicelink.transport.MultiplexTransport;\r\n-import com.smartdevicelink.transport.enums.TransportType;\r\n-import com.smartdevicelink.util.DebugTool;\r\n-import com.smartdevicelink.util.Version;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.OutputStream;\r\n-import java.io.PipedInputStream;\r\n-import java.io.PipedOutputStream;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.ListIterator;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-@Deprecated\r\n-public class SdlSession implements ISdlConnectionListener, IHeartbeatMonitorListener, IStreamListener, ISecurityInitializedListener {\r\n-\r\n-   private static final String TAG = \"SdlSession\";\r\n-\r\n-    protected final static int BUFF_READ_SIZE = 1024;\r\n-\r\n-\tprivate static CopyOnWriteArrayList<SdlConnection> shareConnections = new CopyOnWriteArrayList<SdlConnection>();\r\n-\r\n-\tprivate byte wiproProcolVer;\r\n-\r\n-    protected BaseTransportConfig transportConfig;\r\n-    protected ISdlConnectionListener sessionListener;\r\n-\tprotected LockScreenManager lockScreenMan  = new LockScreenManager();\r\n-\tprotected SdlSecurityBase sdlSecurity = null;\r\n-\tprotected VideoStreamingParameters desiredVideoParams = null;\r\n-\tprotected VideoStreamingParameters acceptedVideoParams = null;\r\n-\r\n-\tprotected byte sessionId;\r\n-\tprotected int sessionHashId = 0;\r\n-\tprotected HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> serviceListeners;\r\n-\tprotected CopyOnWriteArrayList<SessionType> encryptedServices = new CopyOnWriteArrayList<SessionType>();\r\n-\r\n-\r\n-\tSdlConnection _sdlConnection = null;\r\n-\r\n-\tIHeartbeatMonitor _outgoingHeartbeatMonitor = null;\r\n-\tIHeartbeatMonitor _incomingHeartbeatMonitor = null;\r\n-\r\n-    StreamRPCPacketizer mRPCPacketizer = null;\r\n-    AbstractPacketizer mVideoPacketizer = null;\r\n-    StreamPacketizer mAudioPacketizer = null;\r\n-    SdlEncoder mSdlEncoder = null;\r\n-    VirtualDisplayEncoder virtualDisplayEncoder = null;\r\n-    boolean sdlSecurityInitializing = false;\r\n-\r\n-    public static SdlSession createSession(byte wiproVersion, ISdlConnectionListener listener, BaseTransportConfig btConfig) {\r\n-\r\n-        SdlSession session =  new SdlSession();\r\n-        session.wiproProcolVer = wiproVersion;\r\n-        session.sessionListener = listener;\r\n-        session.transportConfig = btConfig;\r\n-\r\n-        return session;\r\n-    }\r\n-\r\n-    public BaseTransportConfig getTransportConfig() {\r\n-        return this.transportConfig;\r\n-    }\r\n-\r\n-    public LockScreenManager getLockScreenMan() {\r\n-        return lockScreenMan;\r\n-    }\r\n-\r\n-\r\n-    public IHeartbeatMonitor getOutgoingHeartbeatMonitor() {\r\n-        return _outgoingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public IHeartbeatMonitor getIncomingHeartbeatMonitor() {\r\n-        return _incomingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public void setOutgoingHeartbeatMonitor(IHeartbeatMonitor outgoingHeartbeatMonitor) {\r\n-        this._outgoingHeartbeatMonitor = outgoingHeartbeatMonitor;\r\n-        _outgoingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public void setIncomingHeartbeatMonitor(IHeartbeatMonitor incomingHeartbeatMonitor) {\r\n-        this._incomingHeartbeatMonitor = incomingHeartbeatMonitor;\r\n-        _incomingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public int getSessionHashId() {\r\n-        return this.sessionHashId;\r\n-    }\r\n-\r\n-    public byte getSessionId() {\r\n-        return this.sessionId;\r\n-    }\r\n-\r\n-    public SdlConnection getSdlConnection() {\r\n-        return this._sdlConnection;\r\n-    }\r\n-\r\n-    public int getMtu(){\r\n-        if(this._sdlConnection!=null){\r\n-            return this._sdlConnection.getWiProProtocol().getMtu();\r\n-        }else{\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public long getMtu(SessionType type) {\r\n-        if (this._sdlConnection != null) {\r\n-            return this._sdlConnection.getWiProProtocol().getMtu(type);\r\n-        } else {\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        if (sdlSecurity != null)\r\n-        {\r\n-            sdlSecurity.resetParams();\r\n-            sdlSecurity.shutDown();\r\n-        }\r\n-\r\n-        if (_sdlConnection != null) { //sessionId == 0 means session is not started.\r\n-            //_sdlConnection.unregisterSession(this);\r\n-\r\n-            if (_sdlConnection.getRegisterCount() == 0) {\r\n-                shareConnections.remove(_sdlConnection);\r\n-            }\r\n-\r\n-            _sdlConnection = null;\r\n-        }\r\n-    }\r\n-\r\n-    public void resetSession(){\r\n-\r\n-    }\r\n-\r\n-    public void startStream(InputStream is, SessionType sType, byte rpcSessionID) throws IOException {\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressLint(\"NewApi\")\r\n-    public OutputStream startStream(SessionType sType, byte rpcSessionID) throws IOException {\r\n-        OutputStream os = new PipedOutputStream();\r\n-        InputStream is = null;\r\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\r\n-            is = new PipedInputStream((PipedOutputStream) os, BUFF_READ_SIZE);\r\n-        } else {\r\n-            is = new PipedInputStream((PipedOutputStream) os);\r\n-        }\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-        else\r\n-        {\r\n-            os.close();\r\n-            is.close();\r\n-            return null;\r\n-        }\r\n-        return os;\r\n-    }\r\n-\r\n-    public IVideoStreamListener startVideoStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        VideoStreamingProtocol protocol = getAcceptedProtocol();\r\n-        try {\r\n-            switch (protocol) {\r\n-                case RAW: {\r\n-                    StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.NAV, rpcSessionID, this);\r\n-                    packetizer.sdlConnection = this.getSdlConnection();\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                case RTP: {\r\n-                    RTPH264Packetizer packetizer = new RTPH264Packetizer(this, SessionType.NAV, rpcSessionID, this);\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                default:\r\n-                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\r\n-                    return null;\r\n-            }\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    public IAudioStreamListener startAudioStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        try {\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.PCM, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer = packetizer;\r\n-            mAudioPacketizer.start();\r\n-            return packetizer;\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void startRPCStream(InputStream is, RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public OutputStream startRPCStream(RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            OutputStream os = new PipedOutputStream();\r\n-            InputStream is = new PipedInputStream((PipedOutputStream) os);\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-            return os;\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void pauseRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.pause();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void resumeRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.resume();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void stopRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.stop();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean stopAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean stopVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public Surface createOpenGLInputSurface(int frameRate, int iFrameInterval, int width,\r\n-                                            int height, int bitrate, SessionType sType, byte rpcSessionID) {\r\n-        IVideoStreamListener encoderListener = startVideoStream();\r\n-        if (encoderListener == null) {\r\n-            return null;\r\n-        }\r\n-\r\n-        mSdlEncoder = new SdlEncoder();\r\n-        mSdlEncoder.setFrameRate(frameRate);\r\n-        mSdlEncoder.setFrameInterval(iFrameInterval);\r\n-        mSdlEncoder.setFrameWidth(width);\r\n-        mSdlEncoder.setFrameHeight(height);\r\n-        mSdlEncoder.setBitrate(bitrate);\r\n-        mSdlEncoder.setOutputListener(encoderListener);\r\n-        return mSdlEncoder.prepareEncoder();\r\n-    }\r\n-\r\n-    public void startEncoder () {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.startEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void releaseEncoder() {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.releaseEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void drainEncoder(boolean endOfStream) {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.drainEncoder(endOfStream);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendStreamPacket(ProtocolMessage pm) {\r\n-        sendMessage(pm);\r\n-    }\r\n-\r\n-    public void setSdlSecurity(SdlSecurityBase sec) {\r\n-        sdlSecurity = sec;\r\n-    }\r\n-\r\n-    public SdlSecurityBase getSdlSecurity() {\r\n-        return sdlSecurity;\r\n-    }\r\n-\r\n-    public void startService (SessionType serviceType, byte sessionID, boolean isEncrypted) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-\r\n-        if (isEncrypted)\r\n-        {\r\n-            if (sdlSecurity != null)\r\n-            {\r\n-                List<SessionType> serviceList = sdlSecurity.getServiceList();\r\n-                if (!serviceList.contains(serviceType))\r\n-                    serviceList.add(serviceType);\r\n-\r\n-                if (!sdlSecurityInitializing) {\r\n-                    sdlSecurityInitializing = true;\r\n-                    sdlSecurity.initialize();\r\n-                    return;\r\n-                }\r\n-            }\r\n-        }\r\n-        _sdlConnection.startService(serviceType, sessionID, isEncrypted);\r\n-    }\r\n-\r\n-    public void endService (SessionType serviceType, byte sessionID) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.endService(serviceType, sessionID);\r\n-    }\r\n-\r\n-    protected void processControlService(ProtocolMessage msg) {\r\n-        if (sdlSecurity == null)\r\n-            return;\r\n-        int ilen = msg.getData().length - 12;\r\n-        byte[] data = new byte[ilen];\r\n-        System.arraycopy(msg.getData(), 12, data, 0, ilen);\r\n-\r\n-        byte[] dataToRead = new byte[4096];\r\n-\r\n-        Integer iNumBytes = sdlSecurity.runHandshake(data, dataToRead);\r\n-\r\n-        if (iNumBytes == null || iNumBytes <= 0)\r\n-            return;\r\n-\r\n-        byte[] returnBytes = new byte[iNumBytes];\r\n-        System.arraycopy(dataToRead, 0, returnBytes, 0, iNumBytes);\r\n-        ProtocolMessage protocolMessage = new ProtocolMessage();\r\n-        protocolMessage.setSessionType(SessionType.CONTROL);\r\n-        protocolMessage.setData(returnBytes);\r\n-        protocolMessage.setFunctionID(0x01);\r\n-        protocolMessage.setVersion(wiproProcolVer);\r\n-        protocolMessage.setSessionID(getSessionId());\r\n-\r\n-        //sdlSecurity.hs();\r\n-\r\n-        sendMessage(protocolMessage);\r\n-    }\r\n-\r\n-    public String getBroadcastComment(BaseTransportConfig myTransport) {\r\n-        SdlConnection connection = null;\r\n-        if (myTransport.shareConnection()) {\r\n-            connection = findTheProperConnection(myTransport);\r\n-        } else {\r\n-            connection = this._sdlConnection;\r\n-        }\r\n-\r\n-        if (connection != null)\r\n-            return connection.getBroadcastComment();\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-\r\n-    public void startSession() throws SdlException {\r\n-        SdlConnection connection = null;\r\n-        if (this.transportConfig.shareConnection()) {\r\n-            connection = findTheProperConnection(this.transportConfig);\r\n-\r\n-            if (connection == null) {\r\n-                connection = new SdlConnection(this.transportConfig);\r\n-                shareConnections.add(connection);\r\n-            }\r\n-        } else {\r\n-            connection = new SdlConnection(this.transportConfig);\r\n-        }\r\n-\r\n-        this._sdlConnection = connection;\r\n-        connection.registerSession(this); //Handshake will start when register.\r\n-    }\r\n-\r\n-    protected void initialiseSession() {\r\n-        if (_outgoingHeartbeatMonitor != null) {\r\n-            _outgoingHeartbeatMonitor.start();\r\n-        }\r\n-        if (_incomingHeartbeatMonitor != null) {\r\n-            _incomingHeartbeatMonitor.start();\r\n-        }\r\n-    }\r\n-\r\n-    public void sendMessage(ProtocolMessage msg) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.sendMessage(msg);\r\n-    }\r\n-\r\n-    public TransportType getCurrentTransportType() {\r\n-        if (_sdlConnection == null)\r\n-            return null;\r\n-        return _sdlConnection.getCurrentTransportType();\r\n-    }\r\n-\r\n-    public boolean getIsConnected() {\r\n-        if (_sdlConnection == null)\r\n-            return false;\r\n-        return _sdlConnection != null && _sdlConnection.getIsConnected();\r\n-    }\r\n-\r\n-    public boolean isServiceProtected(SessionType sType) {\r\n-        return encryptedServices.contains(sType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info, boolean availablePrimary, BaseTransportConfig transportConfig) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportError(String info, Exception e) {\r\n-        this.sessionListener.onTransportError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolMessageReceived(ProtocolMessage msg) {\r\n-        if (msg.getSessionType().equals(SessionType.CONTROL)) {\r\n-            processControlService(msg);\r\n-            return;\r\n-        }\r\n-\r\n-        this.sessionListener.onProtocolMessageReceived(msg);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onHeartbeatTimedOut(byte sessionID) {\r\n-        this.sessionListener.onHeartbeatTimedOut(sessionID);\r\n-\r\n-    }\r\n-\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStarted(SessionType sessionType,\r\n-                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\r\n-        this.sessionId = sessionID;\r\n-        lockScreenMan.setSessionID(sessionID);\r\n-        if (sessionType.eq(SessionType.RPC)){\r\n-            sessionHashId = hashID;\r\n-            wiproProcolVer = version;\r\n-        }\r\n-        if (isEncrypted)\r\n-            encryptedServices.addIfAbsent(sessionType);\r\n-        this.sessionListener.onProtocolSessionStarted(sessionType, sessionID, version, correlationID, hashID, isEncrypted);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceStarted(this, sessionType, isEncrypted);\r\n-            }\r\n-        }\r\n-        //if (version == 3)\r\n-        initialiseSession();\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEnded(SessionType sessionType, byte sessionID,\r\n-                                       String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEnded(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceEnded(this, sessionType);\r\n-            }\r\n-        }\r\n-        encryptedServices.remove(sessionType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolError(String info, Exception e) {\r\n-        this.sessionListener.onProtocolError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendHeartbeat(IHeartbeatMonitor monitor) {\r\n-        DebugTool.logInfo(TAG, \"Asked to send heartbeat\");\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection.sendHeartbeat(this);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void heartbeatTimedOut(IHeartbeatMonitor monitor) {\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection._connectionListener.onHeartbeatTimedOut(this.sessionId);\r\n-        close();\r\n-    }\r\n-\r\n-    private static SdlConnection findTheProperConnection(BaseTransportConfig config) {\r\n-        SdlConnection connection = null;\r\n-\r\n-        int minCount = 0;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == config.getTransportType()) {\r\n-                if (minCount == 0 || minCount >= c.getRegisterCount()) {\r\n-                    connection = c;\r\n-                    minCount = c.getRegisterCount();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStartedNACKed(SessionType sessionType,\r\n-                                               byte sessionID, byte version, String correlationID, List<String> rejectedParams) {\r\n-        this.sessionListener.onProtocolSessionStartedNACKed(sessionType,\r\n-                sessionID, version, correlationID, rejectedParams);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"Start \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEndedNACKed(SessionType sessionType,\r\n-                                             byte sessionID, String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEndedNACKed(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"End \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolServiceDataACK(SessionType sessionType, int dataSize, byte sessionID) {\r\n-        this.sessionListener.onProtocolServiceDataACK(sessionType, dataSize, sessionID);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onAuthTokenReceived(String authToken, byte sessionId) {\r\n-        this.sessionListener.onAuthTokenReceived(authToken, sessionId);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onSecurityInitialized() {\r\n-\r\n-        if (_sdlConnection != null && sdlSecurity != null)\r\n-        {\r\n-            List<SessionType> list = sdlSecurity.getServiceList();\r\n-\r\n-            SessionType service;\r\n-            ListIterator<SessionType> iter = list.listIterator();\r\n-\r\n-            while (iter.hasNext()) {\r\n-                service = iter.next();\r\n-\r\n-                if (service != null)\r\n-                    _sdlConnection.startService(service, getSessionId(), true);\r\n-\r\n-                iter.remove();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void clearConnection(){\r\n-        _sdlConnection = null;\r\n-    }\r\n-\r\n-    public void checkForOpenMultiplexConnection(SdlConnection connection){\r\n-        removeConnection(connection);\r\n-        connection.unregisterSession(this);\r\n-        _sdlConnection = null;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == TransportType.MULTIPLEX) {\r\n-                if(c.getIsConnected() || ((MultiplexTransport)c._transport).isPendingConnected()){\r\n-                    _sdlConnection = c;\r\n-                    try {\r\n-                        _sdlConnection.registerSession(this);//Handshake will start when register.\r\n-                    } catch (SdlException e) {\r\n-                        e.printStackTrace();\r\n-                    }\r\n-                    return;\r\n-                }\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-    public static boolean removeConnection(SdlConnection connection){\r\n-        return shareConnections.remove(connection);\r\n-    }\r\n-\r\n-    public void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners == null){\r\n-            serviceListeners = new HashMap<>();\r\n-        }\r\n-        if(serviceType != null && sdlServiceListener != null){\r\n-            if(!serviceListeners.containsKey(serviceType)){\r\n-                serviceListeners.put(serviceType,new CopyOnWriteArrayList<ISdlServiceListener>());\r\n-            }\r\n-            serviceListeners.get(serviceType).add(sdlServiceListener);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners!= null && serviceType != null && sdlServiceListener != null && serviceListeners.containsKey(serviceType)){\r\n-            return serviceListeners.get(serviceType).remove(sdlServiceListener);\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-\r\n-    public HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> getServiceListeners(){\r\n-        return serviceListeners;\r\n-    }\r\n-\r\n-    public void setDesiredVideoParams(VideoStreamingParameters params){\r\n-        this.desiredVideoParams = params;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the currently set desired video streaming parameters. If there haven't been any set,\r\n-     * the default options will be returned and set for this instance.\r\n-     * @return\r\n-     */\r\n-    public VideoStreamingParameters getDesiredVideoParams(){\r\n-        if(desiredVideoParams == null){\r\n-            desiredVideoParams = new VideoStreamingParameters();\r\n-        }\r\n-        return desiredVideoParams;\r\n-    }\r\n-\r\n-    public void setAcceptedVideoParams(VideoStreamingParameters params){\r\n-        this.acceptedVideoParams = params;\r\n-    }\r\n-\r\n-    public VideoStreamingParameters getAcceptedVideoParams(){\r\n-        return acceptedVideoParams;\r\n-    }\r\n-\r\n-    private VideoStreamingProtocol getAcceptedProtocol() {\r\n-        // acquire default protocol (RAW)\r\n-        VideoStreamingProtocol protocol = new VideoStreamingParameters().getFormat().getProtocol();\r\n-\r\n-        if (acceptedVideoParams != null) {\r\n-            VideoStreamingFormat format = acceptedVideoParams.getFormat();\r\n-            if (format != null && format.getProtocol() != null) {\r\n-                protocol = format.getProtocol();\r\n-            }\r\n-        }\r\n-\r\n-        return protocol;\r\n-    }\r\n-\r\n-    public Version getProtocolVersion(){\r\n-        //Since this session version never supported a minor protocol version this should be fine\r\n-        return new Version(wiproProcolVer,0,0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if a transport is available to start/use the supplied service.\r\n-     * @param sessionType the session that should be checked for transport availability\r\n-     * @return true if there is either a supported\r\n-     *         transport currently connected or a transport is\r\n-     *         available to connect with for the supplied service type.\r\n-     *         <br>false if there is no\r\n-     *         transport connected to support the service type in question and\r\n-     *          no possibility in the foreseeable future.\r\n-     */\r\n-    public boolean isTransportForServiceAvailable(SessionType sessionType){\r\n-        return _sdlConnection!= null\r\n-                && _sdlConnection._transport!= null\r\n-                && _sdlConnection._transport.getIsConnected()\r\n-                && ((sessionType == SessionType.RPC || sessionType == SessionType.CONTROL || sessionType == SessionType.BULK_DATA ) //If this is a service that can run on any transport just return true\r\n-                    || (_sdlConnection._transport.getTransportType() == TransportType.USB || _sdlConnection._transport.getTransportType() == TransportType.TCP));\r\n-    }\r\n-\r\n-\r\n-}\n\\ No newline at end of file\n+/*\n+ * Copyright (c) 2018 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+import android.content.Context;\n+\n+import com.smartdevicelink.exception.SdlException;\n+import com.smartdevicelink.protocol.ISdlProtocol;\n+import com.smartdevicelink.protocol.ProtocolMessage;\n+import com.smartdevicelink.protocol.SdlPacket;\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\n+import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\n+import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\n+import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\n+import com.smartdevicelink.streaming.AbstractPacketizer;\n+import com.smartdevicelink.streaming.IStreamListener;\n+import com.smartdevicelink.streaming.StreamPacketizer;\n+import com.smartdevicelink.streaming.video.RTPH264Packetizer;\n+import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n+import com.smartdevicelink.transport.BaseTransportConfig;\n+import com.smartdevicelink.transport.MultiplexTransportConfig;\n+import com.smartdevicelink.transport.TCPTransportConfig;\n+import com.smartdevicelink.transport.enums.TransportType;\n+import com.smartdevicelink.util.DebugTool;\n+import com.smartdevicelink.util.MediaStreamingStatus;\n+import com.smartdevicelink.util.Version;\n+\n+import java.io.IOException;\n+import java.lang.ref.WeakReference;\n+import java.util.List;\n+import java.util.ListIterator;", "originalCommit": "f8080616efd531480981fb265b611e91dffa8489", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc1NjkzNQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r463756935", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            @SuppressWarnings({\"WeakerAccess\", \"deprecation\"})\n          \n      \n    \n    \n  \n\nI don't see the need to suppress theses warnings anymore.", "author": "JulianKast", "createdAt": "2020-07-31T18:09:09Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -1,838 +1,339 @@\n-/*\r\n- * Copyright (c) 2017 - 2019, SmartDeviceLink Consortium, Inc.\r\n- * All rights reserved.\r\n- *\r\n- * Redistribution and use in source and binary forms, with or without\r\n- * modification, are permitted provided that the following conditions are met:\r\n- *\r\n- * Redistributions of source code must retain the above copyright notice, this\r\n- * list of conditions and the following disclaimer.\r\n- *\r\n- * Redistributions in binary form must reproduce the above copyright notice,\r\n- * this list of conditions and the following\r\n- * disclaimer in the documentation and/or other materials provided with the\r\n- * distribution.\r\n- *\r\n- * Neither the name of the SmartDeviceLink Consortium, Inc. nor the names of its\r\n- * contributors may be used to endorse or promote products derived from this \r\n- * software without specific prior written permission.\r\n- *\r\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n- * POSSIBILITY OF SUCH DAMAGE.\r\n- */\r\n-package com.smartdevicelink.SdlConnection;\r\n-\r\n-import android.annotation.SuppressLint;\r\n-import android.os.Build;\r\n-import android.view.Surface;\r\n-\r\n-import com.smartdevicelink.encoder.SdlEncoder;\r\n-import com.smartdevicelink.encoder.VirtualDisplayEncoder;\r\n-import com.smartdevicelink.exception.SdlException;\r\n-import com.smartdevicelink.protocol.ProtocolMessage;\r\n-import com.smartdevicelink.protocol.enums.SessionType;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitorListener;\r\n-import com.smartdevicelink.proxy.LockScreenManager;\r\n-import com.smartdevicelink.proxy.RPCRequest;\r\n-import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\r\n-import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\r\n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\r\n-import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\r\n-import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\r\n-import com.smartdevicelink.security.ISecurityInitializedListener;\r\n-import com.smartdevicelink.security.SdlSecurityBase;\r\n-import com.smartdevicelink.streaming.AbstractPacketizer;\r\n-import com.smartdevicelink.streaming.IStreamListener;\r\n-import com.smartdevicelink.streaming.StreamPacketizer;\r\n-import com.smartdevicelink.streaming.StreamRPCPacketizer;\r\n-import com.smartdevicelink.streaming.video.RTPH264Packetizer;\r\n-import com.smartdevicelink.streaming.video.VideoStreamingParameters;\r\n-import com.smartdevicelink.transport.BaseTransportConfig;\r\n-import com.smartdevicelink.transport.MultiplexTransport;\r\n-import com.smartdevicelink.transport.enums.TransportType;\r\n-import com.smartdevicelink.util.DebugTool;\r\n-import com.smartdevicelink.util.Version;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.OutputStream;\r\n-import java.io.PipedInputStream;\r\n-import java.io.PipedOutputStream;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.ListIterator;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-@Deprecated\r\n-public class SdlSession implements ISdlConnectionListener, IHeartbeatMonitorListener, IStreamListener, ISecurityInitializedListener {\r\n-\r\n-   private static final String TAG = \"SdlSession\";\r\n-\r\n-    protected final static int BUFF_READ_SIZE = 1024;\r\n-\r\n-\tprivate static CopyOnWriteArrayList<SdlConnection> shareConnections = new CopyOnWriteArrayList<SdlConnection>();\r\n-\r\n-\tprivate byte wiproProcolVer;\r\n-\r\n-    protected BaseTransportConfig transportConfig;\r\n-    protected ISdlConnectionListener sessionListener;\r\n-\tprotected LockScreenManager lockScreenMan  = new LockScreenManager();\r\n-\tprotected SdlSecurityBase sdlSecurity = null;\r\n-\tprotected VideoStreamingParameters desiredVideoParams = null;\r\n-\tprotected VideoStreamingParameters acceptedVideoParams = null;\r\n-\r\n-\tprotected byte sessionId;\r\n-\tprotected int sessionHashId = 0;\r\n-\tprotected HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> serviceListeners;\r\n-\tprotected CopyOnWriteArrayList<SessionType> encryptedServices = new CopyOnWriteArrayList<SessionType>();\r\n-\r\n-\r\n-\tSdlConnection _sdlConnection = null;\r\n-\r\n-\tIHeartbeatMonitor _outgoingHeartbeatMonitor = null;\r\n-\tIHeartbeatMonitor _incomingHeartbeatMonitor = null;\r\n-\r\n-    StreamRPCPacketizer mRPCPacketizer = null;\r\n-    AbstractPacketizer mVideoPacketizer = null;\r\n-    StreamPacketizer mAudioPacketizer = null;\r\n-    SdlEncoder mSdlEncoder = null;\r\n-    VirtualDisplayEncoder virtualDisplayEncoder = null;\r\n-    boolean sdlSecurityInitializing = false;\r\n-\r\n-    public static SdlSession createSession(byte wiproVersion, ISdlConnectionListener listener, BaseTransportConfig btConfig) {\r\n-\r\n-        SdlSession session =  new SdlSession();\r\n-        session.wiproProcolVer = wiproVersion;\r\n-        session.sessionListener = listener;\r\n-        session.transportConfig = btConfig;\r\n-\r\n-        return session;\r\n-    }\r\n-\r\n-    public BaseTransportConfig getTransportConfig() {\r\n-        return this.transportConfig;\r\n-    }\r\n-\r\n-    public LockScreenManager getLockScreenMan() {\r\n-        return lockScreenMan;\r\n-    }\r\n-\r\n-\r\n-    public IHeartbeatMonitor getOutgoingHeartbeatMonitor() {\r\n-        return _outgoingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public IHeartbeatMonitor getIncomingHeartbeatMonitor() {\r\n-        return _incomingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public void setOutgoingHeartbeatMonitor(IHeartbeatMonitor outgoingHeartbeatMonitor) {\r\n-        this._outgoingHeartbeatMonitor = outgoingHeartbeatMonitor;\r\n-        _outgoingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public void setIncomingHeartbeatMonitor(IHeartbeatMonitor incomingHeartbeatMonitor) {\r\n-        this._incomingHeartbeatMonitor = incomingHeartbeatMonitor;\r\n-        _incomingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public int getSessionHashId() {\r\n-        return this.sessionHashId;\r\n-    }\r\n-\r\n-    public byte getSessionId() {\r\n-        return this.sessionId;\r\n-    }\r\n-\r\n-    public SdlConnection getSdlConnection() {\r\n-        return this._sdlConnection;\r\n-    }\r\n-\r\n-    public int getMtu(){\r\n-        if(this._sdlConnection!=null){\r\n-            return this._sdlConnection.getWiProProtocol().getMtu();\r\n-        }else{\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public long getMtu(SessionType type) {\r\n-        if (this._sdlConnection != null) {\r\n-            return this._sdlConnection.getWiProProtocol().getMtu(type);\r\n-        } else {\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        if (sdlSecurity != null)\r\n-        {\r\n-            sdlSecurity.resetParams();\r\n-            sdlSecurity.shutDown();\r\n-        }\r\n-\r\n-        if (_sdlConnection != null) { //sessionId == 0 means session is not started.\r\n-            //_sdlConnection.unregisterSession(this);\r\n-\r\n-            if (_sdlConnection.getRegisterCount() == 0) {\r\n-                shareConnections.remove(_sdlConnection);\r\n-            }\r\n-\r\n-            _sdlConnection = null;\r\n-        }\r\n-    }\r\n-\r\n-    public void resetSession(){\r\n-\r\n-    }\r\n-\r\n-    public void startStream(InputStream is, SessionType sType, byte rpcSessionID) throws IOException {\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressLint(\"NewApi\")\r\n-    public OutputStream startStream(SessionType sType, byte rpcSessionID) throws IOException {\r\n-        OutputStream os = new PipedOutputStream();\r\n-        InputStream is = null;\r\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\r\n-            is = new PipedInputStream((PipedOutputStream) os, BUFF_READ_SIZE);\r\n-        } else {\r\n-            is = new PipedInputStream((PipedOutputStream) os);\r\n-        }\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-        else\r\n-        {\r\n-            os.close();\r\n-            is.close();\r\n-            return null;\r\n-        }\r\n-        return os;\r\n-    }\r\n-\r\n-    public IVideoStreamListener startVideoStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        VideoStreamingProtocol protocol = getAcceptedProtocol();\r\n-        try {\r\n-            switch (protocol) {\r\n-                case RAW: {\r\n-                    StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.NAV, rpcSessionID, this);\r\n-                    packetizer.sdlConnection = this.getSdlConnection();\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                case RTP: {\r\n-                    RTPH264Packetizer packetizer = new RTPH264Packetizer(this, SessionType.NAV, rpcSessionID, this);\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                default:\r\n-                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\r\n-                    return null;\r\n-            }\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    public IAudioStreamListener startAudioStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        try {\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.PCM, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer = packetizer;\r\n-            mAudioPacketizer.start();\r\n-            return packetizer;\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void startRPCStream(InputStream is, RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public OutputStream startRPCStream(RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            OutputStream os = new PipedOutputStream();\r\n-            InputStream is = new PipedInputStream((PipedOutputStream) os);\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-            return os;\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void pauseRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.pause();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void resumeRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.resume();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void stopRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.stop();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean stopAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean stopVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public Surface createOpenGLInputSurface(int frameRate, int iFrameInterval, int width,\r\n-                                            int height, int bitrate, SessionType sType, byte rpcSessionID) {\r\n-        IVideoStreamListener encoderListener = startVideoStream();\r\n-        if (encoderListener == null) {\r\n-            return null;\r\n-        }\r\n-\r\n-        mSdlEncoder = new SdlEncoder();\r\n-        mSdlEncoder.setFrameRate(frameRate);\r\n-        mSdlEncoder.setFrameInterval(iFrameInterval);\r\n-        mSdlEncoder.setFrameWidth(width);\r\n-        mSdlEncoder.setFrameHeight(height);\r\n-        mSdlEncoder.setBitrate(bitrate);\r\n-        mSdlEncoder.setOutputListener(encoderListener);\r\n-        return mSdlEncoder.prepareEncoder();\r\n-    }\r\n-\r\n-    public void startEncoder () {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.startEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void releaseEncoder() {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.releaseEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void drainEncoder(boolean endOfStream) {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.drainEncoder(endOfStream);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendStreamPacket(ProtocolMessage pm) {\r\n-        sendMessage(pm);\r\n-    }\r\n-\r\n-    public void setSdlSecurity(SdlSecurityBase sec) {\r\n-        sdlSecurity = sec;\r\n-    }\r\n-\r\n-    public SdlSecurityBase getSdlSecurity() {\r\n-        return sdlSecurity;\r\n-    }\r\n-\r\n-    public void startService (SessionType serviceType, byte sessionID, boolean isEncrypted) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-\r\n-        if (isEncrypted)\r\n-        {\r\n-            if (sdlSecurity != null)\r\n-            {\r\n-                List<SessionType> serviceList = sdlSecurity.getServiceList();\r\n-                if (!serviceList.contains(serviceType))\r\n-                    serviceList.add(serviceType);\r\n-\r\n-                if (!sdlSecurityInitializing) {\r\n-                    sdlSecurityInitializing = true;\r\n-                    sdlSecurity.initialize();\r\n-                    return;\r\n-                }\r\n-            }\r\n-        }\r\n-        _sdlConnection.startService(serviceType, sessionID, isEncrypted);\r\n-    }\r\n-\r\n-    public void endService (SessionType serviceType, byte sessionID) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.endService(serviceType, sessionID);\r\n-    }\r\n-\r\n-    protected void processControlService(ProtocolMessage msg) {\r\n-        if (sdlSecurity == null)\r\n-            return;\r\n-        int ilen = msg.getData().length - 12;\r\n-        byte[] data = new byte[ilen];\r\n-        System.arraycopy(msg.getData(), 12, data, 0, ilen);\r\n-\r\n-        byte[] dataToRead = new byte[4096];\r\n-\r\n-        Integer iNumBytes = sdlSecurity.runHandshake(data, dataToRead);\r\n-\r\n-        if (iNumBytes == null || iNumBytes <= 0)\r\n-            return;\r\n-\r\n-        byte[] returnBytes = new byte[iNumBytes];\r\n-        System.arraycopy(dataToRead, 0, returnBytes, 0, iNumBytes);\r\n-        ProtocolMessage protocolMessage = new ProtocolMessage();\r\n-        protocolMessage.setSessionType(SessionType.CONTROL);\r\n-        protocolMessage.setData(returnBytes);\r\n-        protocolMessage.setFunctionID(0x01);\r\n-        protocolMessage.setVersion(wiproProcolVer);\r\n-        protocolMessage.setSessionID(getSessionId());\r\n-\r\n-        //sdlSecurity.hs();\r\n-\r\n-        sendMessage(protocolMessage);\r\n-    }\r\n-\r\n-    public String getBroadcastComment(BaseTransportConfig myTransport) {\r\n-        SdlConnection connection = null;\r\n-        if (myTransport.shareConnection()) {\r\n-            connection = findTheProperConnection(myTransport);\r\n-        } else {\r\n-            connection = this._sdlConnection;\r\n-        }\r\n-\r\n-        if (connection != null)\r\n-            return connection.getBroadcastComment();\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-\r\n-    public void startSession() throws SdlException {\r\n-        SdlConnection connection = null;\r\n-        if (this.transportConfig.shareConnection()) {\r\n-            connection = findTheProperConnection(this.transportConfig);\r\n-\r\n-            if (connection == null) {\r\n-                connection = new SdlConnection(this.transportConfig);\r\n-                shareConnections.add(connection);\r\n-            }\r\n-        } else {\r\n-            connection = new SdlConnection(this.transportConfig);\r\n-        }\r\n-\r\n-        this._sdlConnection = connection;\r\n-        connection.registerSession(this); //Handshake will start when register.\r\n-    }\r\n-\r\n-    protected void initialiseSession() {\r\n-        if (_outgoingHeartbeatMonitor != null) {\r\n-            _outgoingHeartbeatMonitor.start();\r\n-        }\r\n-        if (_incomingHeartbeatMonitor != null) {\r\n-            _incomingHeartbeatMonitor.start();\r\n-        }\r\n-    }\r\n-\r\n-    public void sendMessage(ProtocolMessage msg) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.sendMessage(msg);\r\n-    }\r\n-\r\n-    public TransportType getCurrentTransportType() {\r\n-        if (_sdlConnection == null)\r\n-            return null;\r\n-        return _sdlConnection.getCurrentTransportType();\r\n-    }\r\n-\r\n-    public boolean getIsConnected() {\r\n-        if (_sdlConnection == null)\r\n-            return false;\r\n-        return _sdlConnection != null && _sdlConnection.getIsConnected();\r\n-    }\r\n-\r\n-    public boolean isServiceProtected(SessionType sType) {\r\n-        return encryptedServices.contains(sType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info, boolean availablePrimary, BaseTransportConfig transportConfig) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportError(String info, Exception e) {\r\n-        this.sessionListener.onTransportError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolMessageReceived(ProtocolMessage msg) {\r\n-        if (msg.getSessionType().equals(SessionType.CONTROL)) {\r\n-            processControlService(msg);\r\n-            return;\r\n-        }\r\n-\r\n-        this.sessionListener.onProtocolMessageReceived(msg);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onHeartbeatTimedOut(byte sessionID) {\r\n-        this.sessionListener.onHeartbeatTimedOut(sessionID);\r\n-\r\n-    }\r\n-\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStarted(SessionType sessionType,\r\n-                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\r\n-        this.sessionId = sessionID;\r\n-        lockScreenMan.setSessionID(sessionID);\r\n-        if (sessionType.eq(SessionType.RPC)){\r\n-            sessionHashId = hashID;\r\n-            wiproProcolVer = version;\r\n-        }\r\n-        if (isEncrypted)\r\n-            encryptedServices.addIfAbsent(sessionType);\r\n-        this.sessionListener.onProtocolSessionStarted(sessionType, sessionID, version, correlationID, hashID, isEncrypted);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceStarted(this, sessionType, isEncrypted);\r\n-            }\r\n-        }\r\n-        //if (version == 3)\r\n-        initialiseSession();\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEnded(SessionType sessionType, byte sessionID,\r\n-                                       String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEnded(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceEnded(this, sessionType);\r\n-            }\r\n-        }\r\n-        encryptedServices.remove(sessionType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolError(String info, Exception e) {\r\n-        this.sessionListener.onProtocolError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendHeartbeat(IHeartbeatMonitor monitor) {\r\n-        DebugTool.logInfo(TAG, \"Asked to send heartbeat\");\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection.sendHeartbeat(this);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void heartbeatTimedOut(IHeartbeatMonitor monitor) {\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection._connectionListener.onHeartbeatTimedOut(this.sessionId);\r\n-        close();\r\n-    }\r\n-\r\n-    private static SdlConnection findTheProperConnection(BaseTransportConfig config) {\r\n-        SdlConnection connection = null;\r\n-\r\n-        int minCount = 0;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == config.getTransportType()) {\r\n-                if (minCount == 0 || minCount >= c.getRegisterCount()) {\r\n-                    connection = c;\r\n-                    minCount = c.getRegisterCount();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStartedNACKed(SessionType sessionType,\r\n-                                               byte sessionID, byte version, String correlationID, List<String> rejectedParams) {\r\n-        this.sessionListener.onProtocolSessionStartedNACKed(sessionType,\r\n-                sessionID, version, correlationID, rejectedParams);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"Start \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEndedNACKed(SessionType sessionType,\r\n-                                             byte sessionID, String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEndedNACKed(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"End \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolServiceDataACK(SessionType sessionType, int dataSize, byte sessionID) {\r\n-        this.sessionListener.onProtocolServiceDataACK(sessionType, dataSize, sessionID);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onAuthTokenReceived(String authToken, byte sessionId) {\r\n-        this.sessionListener.onAuthTokenReceived(authToken, sessionId);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onSecurityInitialized() {\r\n-\r\n-        if (_sdlConnection != null && sdlSecurity != null)\r\n-        {\r\n-            List<SessionType> list = sdlSecurity.getServiceList();\r\n-\r\n-            SessionType service;\r\n-            ListIterator<SessionType> iter = list.listIterator();\r\n-\r\n-            while (iter.hasNext()) {\r\n-                service = iter.next();\r\n-\r\n-                if (service != null)\r\n-                    _sdlConnection.startService(service, getSessionId(), true);\r\n-\r\n-                iter.remove();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void clearConnection(){\r\n-        _sdlConnection = null;\r\n-    }\r\n-\r\n-    public void checkForOpenMultiplexConnection(SdlConnection connection){\r\n-        removeConnection(connection);\r\n-        connection.unregisterSession(this);\r\n-        _sdlConnection = null;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == TransportType.MULTIPLEX) {\r\n-                if(c.getIsConnected() || ((MultiplexTransport)c._transport).isPendingConnected()){\r\n-                    _sdlConnection = c;\r\n-                    try {\r\n-                        _sdlConnection.registerSession(this);//Handshake will start when register.\r\n-                    } catch (SdlException e) {\r\n-                        e.printStackTrace();\r\n-                    }\r\n-                    return;\r\n-                }\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-    public static boolean removeConnection(SdlConnection connection){\r\n-        return shareConnections.remove(connection);\r\n-    }\r\n-\r\n-    public void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners == null){\r\n-            serviceListeners = new HashMap<>();\r\n-        }\r\n-        if(serviceType != null && sdlServiceListener != null){\r\n-            if(!serviceListeners.containsKey(serviceType)){\r\n-                serviceListeners.put(serviceType,new CopyOnWriteArrayList<ISdlServiceListener>());\r\n-            }\r\n-            serviceListeners.get(serviceType).add(sdlServiceListener);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners!= null && serviceType != null && sdlServiceListener != null && serviceListeners.containsKey(serviceType)){\r\n-            return serviceListeners.get(serviceType).remove(sdlServiceListener);\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-\r\n-    public HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> getServiceListeners(){\r\n-        return serviceListeners;\r\n-    }\r\n-\r\n-    public void setDesiredVideoParams(VideoStreamingParameters params){\r\n-        this.desiredVideoParams = params;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the currently set desired video streaming parameters. If there haven't been any set,\r\n-     * the default options will be returned and set for this instance.\r\n-     * @return\r\n-     */\r\n-    public VideoStreamingParameters getDesiredVideoParams(){\r\n-        if(desiredVideoParams == null){\r\n-            desiredVideoParams = new VideoStreamingParameters();\r\n-        }\r\n-        return desiredVideoParams;\r\n-    }\r\n-\r\n-    public void setAcceptedVideoParams(VideoStreamingParameters params){\r\n-        this.acceptedVideoParams = params;\r\n-    }\r\n-\r\n-    public VideoStreamingParameters getAcceptedVideoParams(){\r\n-        return acceptedVideoParams;\r\n-    }\r\n-\r\n-    private VideoStreamingProtocol getAcceptedProtocol() {\r\n-        // acquire default protocol (RAW)\r\n-        VideoStreamingProtocol protocol = new VideoStreamingParameters().getFormat().getProtocol();\r\n-\r\n-        if (acceptedVideoParams != null) {\r\n-            VideoStreamingFormat format = acceptedVideoParams.getFormat();\r\n-            if (format != null && format.getProtocol() != null) {\r\n-                protocol = format.getProtocol();\r\n-            }\r\n-        }\r\n-\r\n-        return protocol;\r\n-    }\r\n-\r\n-    public Version getProtocolVersion(){\r\n-        //Since this session version never supported a minor protocol version this should be fine\r\n-        return new Version(wiproProcolVer,0,0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if a transport is available to start/use the supplied service.\r\n-     * @param sessionType the session that should be checked for transport availability\r\n-     * @return true if there is either a supported\r\n-     *         transport currently connected or a transport is\r\n-     *         available to connect with for the supplied service type.\r\n-     *         <br>false if there is no\r\n-     *         transport connected to support the service type in question and\r\n-     *          no possibility in the foreseeable future.\r\n-     */\r\n-    public boolean isTransportForServiceAvailable(SessionType sessionType){\r\n-        return _sdlConnection!= null\r\n-                && _sdlConnection._transport!= null\r\n-                && _sdlConnection._transport.getIsConnected()\r\n-                && ((sessionType == SessionType.RPC || sessionType == SessionType.CONTROL || sessionType == SessionType.BULK_DATA ) //If this is a service that can run on any transport just return true\r\n-                    || (_sdlConnection._transport.getTransportType() == TransportType.USB || _sdlConnection._transport.getTransportType() == TransportType.TCP));\r\n-    }\r\n-\r\n-\r\n-}\n\\ No newline at end of file\n+/*\n+ * Copyright (c) 2018 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+import android.content.Context;\n+\n+import com.smartdevicelink.exception.SdlException;\n+import com.smartdevicelink.protocol.ISdlProtocol;\n+import com.smartdevicelink.protocol.ProtocolMessage;\n+import com.smartdevicelink.protocol.SdlPacket;\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\n+import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\n+import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\n+import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\n+import com.smartdevicelink.streaming.AbstractPacketizer;\n+import com.smartdevicelink.streaming.IStreamListener;\n+import com.smartdevicelink.streaming.StreamPacketizer;\n+import com.smartdevicelink.streaming.video.RTPH264Packetizer;\n+import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n+import com.smartdevicelink.transport.BaseTransportConfig;\n+import com.smartdevicelink.transport.MultiplexTransportConfig;\n+import com.smartdevicelink.transport.TCPTransportConfig;\n+import com.smartdevicelink.transport.enums.TransportType;\n+import com.smartdevicelink.util.DebugTool;\n+import com.smartdevicelink.util.MediaStreamingStatus;\n+import com.smartdevicelink.util.Version;\n+\n+import java.io.IOException;\n+import java.lang.ref.WeakReference;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+@SuppressWarnings({\"WeakerAccess\", \"deprecation\"})", "originalCommit": "f8080616efd531480981fb265b611e91dffa8489", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc2NDk3MQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r463764971", "bodyText": "Should a card be added to address the TODO here and should we remove the TODO comment now?", "author": "JulianKast", "createdAt": "2020-07-31T18:26:38Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -1,838 +1,339 @@\n-/*\r\n- * Copyright (c) 2017 - 2019, SmartDeviceLink Consortium, Inc.\r\n- * All rights reserved.\r\n- *\r\n- * Redistribution and use in source and binary forms, with or without\r\n- * modification, are permitted provided that the following conditions are met:\r\n- *\r\n- * Redistributions of source code must retain the above copyright notice, this\r\n- * list of conditions and the following disclaimer.\r\n- *\r\n- * Redistributions in binary form must reproduce the above copyright notice,\r\n- * this list of conditions and the following\r\n- * disclaimer in the documentation and/or other materials provided with the\r\n- * distribution.\r\n- *\r\n- * Neither the name of the SmartDeviceLink Consortium, Inc. nor the names of its\r\n- * contributors may be used to endorse or promote products derived from this \r\n- * software without specific prior written permission.\r\n- *\r\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n- * POSSIBILITY OF SUCH DAMAGE.\r\n- */\r\n-package com.smartdevicelink.SdlConnection;\r\n-\r\n-import android.annotation.SuppressLint;\r\n-import android.os.Build;\r\n-import android.view.Surface;\r\n-\r\n-import com.smartdevicelink.encoder.SdlEncoder;\r\n-import com.smartdevicelink.encoder.VirtualDisplayEncoder;\r\n-import com.smartdevicelink.exception.SdlException;\r\n-import com.smartdevicelink.protocol.ProtocolMessage;\r\n-import com.smartdevicelink.protocol.enums.SessionType;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitorListener;\r\n-import com.smartdevicelink.proxy.LockScreenManager;\r\n-import com.smartdevicelink.proxy.RPCRequest;\r\n-import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\r\n-import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\r\n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\r\n-import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\r\n-import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\r\n-import com.smartdevicelink.security.ISecurityInitializedListener;\r\n-import com.smartdevicelink.security.SdlSecurityBase;\r\n-import com.smartdevicelink.streaming.AbstractPacketizer;\r\n-import com.smartdevicelink.streaming.IStreamListener;\r\n-import com.smartdevicelink.streaming.StreamPacketizer;\r\n-import com.smartdevicelink.streaming.StreamRPCPacketizer;\r\n-import com.smartdevicelink.streaming.video.RTPH264Packetizer;\r\n-import com.smartdevicelink.streaming.video.VideoStreamingParameters;\r\n-import com.smartdevicelink.transport.BaseTransportConfig;\r\n-import com.smartdevicelink.transport.MultiplexTransport;\r\n-import com.smartdevicelink.transport.enums.TransportType;\r\n-import com.smartdevicelink.util.DebugTool;\r\n-import com.smartdevicelink.util.Version;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.OutputStream;\r\n-import java.io.PipedInputStream;\r\n-import java.io.PipedOutputStream;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.ListIterator;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-@Deprecated\r\n-public class SdlSession implements ISdlConnectionListener, IHeartbeatMonitorListener, IStreamListener, ISecurityInitializedListener {\r\n-\r\n-   private static final String TAG = \"SdlSession\";\r\n-\r\n-    protected final static int BUFF_READ_SIZE = 1024;\r\n-\r\n-\tprivate static CopyOnWriteArrayList<SdlConnection> shareConnections = new CopyOnWriteArrayList<SdlConnection>();\r\n-\r\n-\tprivate byte wiproProcolVer;\r\n-\r\n-    protected BaseTransportConfig transportConfig;\r\n-    protected ISdlConnectionListener sessionListener;\r\n-\tprotected LockScreenManager lockScreenMan  = new LockScreenManager();\r\n-\tprotected SdlSecurityBase sdlSecurity = null;\r\n-\tprotected VideoStreamingParameters desiredVideoParams = null;\r\n-\tprotected VideoStreamingParameters acceptedVideoParams = null;\r\n-\r\n-\tprotected byte sessionId;\r\n-\tprotected int sessionHashId = 0;\r\n-\tprotected HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> serviceListeners;\r\n-\tprotected CopyOnWriteArrayList<SessionType> encryptedServices = new CopyOnWriteArrayList<SessionType>();\r\n-\r\n-\r\n-\tSdlConnection _sdlConnection = null;\r\n-\r\n-\tIHeartbeatMonitor _outgoingHeartbeatMonitor = null;\r\n-\tIHeartbeatMonitor _incomingHeartbeatMonitor = null;\r\n-\r\n-    StreamRPCPacketizer mRPCPacketizer = null;\r\n-    AbstractPacketizer mVideoPacketizer = null;\r\n-    StreamPacketizer mAudioPacketizer = null;\r\n-    SdlEncoder mSdlEncoder = null;\r\n-    VirtualDisplayEncoder virtualDisplayEncoder = null;\r\n-    boolean sdlSecurityInitializing = false;\r\n-\r\n-    public static SdlSession createSession(byte wiproVersion, ISdlConnectionListener listener, BaseTransportConfig btConfig) {\r\n-\r\n-        SdlSession session =  new SdlSession();\r\n-        session.wiproProcolVer = wiproVersion;\r\n-        session.sessionListener = listener;\r\n-        session.transportConfig = btConfig;\r\n-\r\n-        return session;\r\n-    }\r\n-\r\n-    public BaseTransportConfig getTransportConfig() {\r\n-        return this.transportConfig;\r\n-    }\r\n-\r\n-    public LockScreenManager getLockScreenMan() {\r\n-        return lockScreenMan;\r\n-    }\r\n-\r\n-\r\n-    public IHeartbeatMonitor getOutgoingHeartbeatMonitor() {\r\n-        return _outgoingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public IHeartbeatMonitor getIncomingHeartbeatMonitor() {\r\n-        return _incomingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public void setOutgoingHeartbeatMonitor(IHeartbeatMonitor outgoingHeartbeatMonitor) {\r\n-        this._outgoingHeartbeatMonitor = outgoingHeartbeatMonitor;\r\n-        _outgoingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public void setIncomingHeartbeatMonitor(IHeartbeatMonitor incomingHeartbeatMonitor) {\r\n-        this._incomingHeartbeatMonitor = incomingHeartbeatMonitor;\r\n-        _incomingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public int getSessionHashId() {\r\n-        return this.sessionHashId;\r\n-    }\r\n-\r\n-    public byte getSessionId() {\r\n-        return this.sessionId;\r\n-    }\r\n-\r\n-    public SdlConnection getSdlConnection() {\r\n-        return this._sdlConnection;\r\n-    }\r\n-\r\n-    public int getMtu(){\r\n-        if(this._sdlConnection!=null){\r\n-            return this._sdlConnection.getWiProProtocol().getMtu();\r\n-        }else{\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public long getMtu(SessionType type) {\r\n-        if (this._sdlConnection != null) {\r\n-            return this._sdlConnection.getWiProProtocol().getMtu(type);\r\n-        } else {\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        if (sdlSecurity != null)\r\n-        {\r\n-            sdlSecurity.resetParams();\r\n-            sdlSecurity.shutDown();\r\n-        }\r\n-\r\n-        if (_sdlConnection != null) { //sessionId == 0 means session is not started.\r\n-            //_sdlConnection.unregisterSession(this);\r\n-\r\n-            if (_sdlConnection.getRegisterCount() == 0) {\r\n-                shareConnections.remove(_sdlConnection);\r\n-            }\r\n-\r\n-            _sdlConnection = null;\r\n-        }\r\n-    }\r\n-\r\n-    public void resetSession(){\r\n-\r\n-    }\r\n-\r\n-    public void startStream(InputStream is, SessionType sType, byte rpcSessionID) throws IOException {\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressLint(\"NewApi\")\r\n-    public OutputStream startStream(SessionType sType, byte rpcSessionID) throws IOException {\r\n-        OutputStream os = new PipedOutputStream();\r\n-        InputStream is = null;\r\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\r\n-            is = new PipedInputStream((PipedOutputStream) os, BUFF_READ_SIZE);\r\n-        } else {\r\n-            is = new PipedInputStream((PipedOutputStream) os);\r\n-        }\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-        else\r\n-        {\r\n-            os.close();\r\n-            is.close();\r\n-            return null;\r\n-        }\r\n-        return os;\r\n-    }\r\n-\r\n-    public IVideoStreamListener startVideoStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        VideoStreamingProtocol protocol = getAcceptedProtocol();\r\n-        try {\r\n-            switch (protocol) {\r\n-                case RAW: {\r\n-                    StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.NAV, rpcSessionID, this);\r\n-                    packetizer.sdlConnection = this.getSdlConnection();\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                case RTP: {\r\n-                    RTPH264Packetizer packetizer = new RTPH264Packetizer(this, SessionType.NAV, rpcSessionID, this);\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                default:\r\n-                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\r\n-                    return null;\r\n-            }\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    public IAudioStreamListener startAudioStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        try {\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.PCM, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer = packetizer;\r\n-            mAudioPacketizer.start();\r\n-            return packetizer;\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void startRPCStream(InputStream is, RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public OutputStream startRPCStream(RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            OutputStream os = new PipedOutputStream();\r\n-            InputStream is = new PipedInputStream((PipedOutputStream) os);\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-            return os;\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void pauseRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.pause();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void resumeRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.resume();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void stopRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.stop();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean stopAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean stopVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public Surface createOpenGLInputSurface(int frameRate, int iFrameInterval, int width,\r\n-                                            int height, int bitrate, SessionType sType, byte rpcSessionID) {\r\n-        IVideoStreamListener encoderListener = startVideoStream();\r\n-        if (encoderListener == null) {\r\n-            return null;\r\n-        }\r\n-\r\n-        mSdlEncoder = new SdlEncoder();\r\n-        mSdlEncoder.setFrameRate(frameRate);\r\n-        mSdlEncoder.setFrameInterval(iFrameInterval);\r\n-        mSdlEncoder.setFrameWidth(width);\r\n-        mSdlEncoder.setFrameHeight(height);\r\n-        mSdlEncoder.setBitrate(bitrate);\r\n-        mSdlEncoder.setOutputListener(encoderListener);\r\n-        return mSdlEncoder.prepareEncoder();\r\n-    }\r\n-\r\n-    public void startEncoder () {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.startEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void releaseEncoder() {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.releaseEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void drainEncoder(boolean endOfStream) {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.drainEncoder(endOfStream);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendStreamPacket(ProtocolMessage pm) {\r\n-        sendMessage(pm);\r\n-    }\r\n-\r\n-    public void setSdlSecurity(SdlSecurityBase sec) {\r\n-        sdlSecurity = sec;\r\n-    }\r\n-\r\n-    public SdlSecurityBase getSdlSecurity() {\r\n-        return sdlSecurity;\r\n-    }\r\n-\r\n-    public void startService (SessionType serviceType, byte sessionID, boolean isEncrypted) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-\r\n-        if (isEncrypted)\r\n-        {\r\n-            if (sdlSecurity != null)\r\n-            {\r\n-                List<SessionType> serviceList = sdlSecurity.getServiceList();\r\n-                if (!serviceList.contains(serviceType))\r\n-                    serviceList.add(serviceType);\r\n-\r\n-                if (!sdlSecurityInitializing) {\r\n-                    sdlSecurityInitializing = true;\r\n-                    sdlSecurity.initialize();\r\n-                    return;\r\n-                }\r\n-            }\r\n-        }\r\n-        _sdlConnection.startService(serviceType, sessionID, isEncrypted);\r\n-    }\r\n-\r\n-    public void endService (SessionType serviceType, byte sessionID) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.endService(serviceType, sessionID);\r\n-    }\r\n-\r\n-    protected void processControlService(ProtocolMessage msg) {\r\n-        if (sdlSecurity == null)\r\n-            return;\r\n-        int ilen = msg.getData().length - 12;\r\n-        byte[] data = new byte[ilen];\r\n-        System.arraycopy(msg.getData(), 12, data, 0, ilen);\r\n-\r\n-        byte[] dataToRead = new byte[4096];\r\n-\r\n-        Integer iNumBytes = sdlSecurity.runHandshake(data, dataToRead);\r\n-\r\n-        if (iNumBytes == null || iNumBytes <= 0)\r\n-            return;\r\n-\r\n-        byte[] returnBytes = new byte[iNumBytes];\r\n-        System.arraycopy(dataToRead, 0, returnBytes, 0, iNumBytes);\r\n-        ProtocolMessage protocolMessage = new ProtocolMessage();\r\n-        protocolMessage.setSessionType(SessionType.CONTROL);\r\n-        protocolMessage.setData(returnBytes);\r\n-        protocolMessage.setFunctionID(0x01);\r\n-        protocolMessage.setVersion(wiproProcolVer);\r\n-        protocolMessage.setSessionID(getSessionId());\r\n-\r\n-        //sdlSecurity.hs();\r\n-\r\n-        sendMessage(protocolMessage);\r\n-    }\r\n-\r\n-    public String getBroadcastComment(BaseTransportConfig myTransport) {\r\n-        SdlConnection connection = null;\r\n-        if (myTransport.shareConnection()) {\r\n-            connection = findTheProperConnection(myTransport);\r\n-        } else {\r\n-            connection = this._sdlConnection;\r\n-        }\r\n-\r\n-        if (connection != null)\r\n-            return connection.getBroadcastComment();\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-\r\n-    public void startSession() throws SdlException {\r\n-        SdlConnection connection = null;\r\n-        if (this.transportConfig.shareConnection()) {\r\n-            connection = findTheProperConnection(this.transportConfig);\r\n-\r\n-            if (connection == null) {\r\n-                connection = new SdlConnection(this.transportConfig);\r\n-                shareConnections.add(connection);\r\n-            }\r\n-        } else {\r\n-            connection = new SdlConnection(this.transportConfig);\r\n-        }\r\n-\r\n-        this._sdlConnection = connection;\r\n-        connection.registerSession(this); //Handshake will start when register.\r\n-    }\r\n-\r\n-    protected void initialiseSession() {\r\n-        if (_outgoingHeartbeatMonitor != null) {\r\n-            _outgoingHeartbeatMonitor.start();\r\n-        }\r\n-        if (_incomingHeartbeatMonitor != null) {\r\n-            _incomingHeartbeatMonitor.start();\r\n-        }\r\n-    }\r\n-\r\n-    public void sendMessage(ProtocolMessage msg) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.sendMessage(msg);\r\n-    }\r\n-\r\n-    public TransportType getCurrentTransportType() {\r\n-        if (_sdlConnection == null)\r\n-            return null;\r\n-        return _sdlConnection.getCurrentTransportType();\r\n-    }\r\n-\r\n-    public boolean getIsConnected() {\r\n-        if (_sdlConnection == null)\r\n-            return false;\r\n-        return _sdlConnection != null && _sdlConnection.getIsConnected();\r\n-    }\r\n-\r\n-    public boolean isServiceProtected(SessionType sType) {\r\n-        return encryptedServices.contains(sType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info, boolean availablePrimary, BaseTransportConfig transportConfig) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportError(String info, Exception e) {\r\n-        this.sessionListener.onTransportError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolMessageReceived(ProtocolMessage msg) {\r\n-        if (msg.getSessionType().equals(SessionType.CONTROL)) {\r\n-            processControlService(msg);\r\n-            return;\r\n-        }\r\n-\r\n-        this.sessionListener.onProtocolMessageReceived(msg);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onHeartbeatTimedOut(byte sessionID) {\r\n-        this.sessionListener.onHeartbeatTimedOut(sessionID);\r\n-\r\n-    }\r\n-\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStarted(SessionType sessionType,\r\n-                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\r\n-        this.sessionId = sessionID;\r\n-        lockScreenMan.setSessionID(sessionID);\r\n-        if (sessionType.eq(SessionType.RPC)){\r\n-            sessionHashId = hashID;\r\n-            wiproProcolVer = version;\r\n-        }\r\n-        if (isEncrypted)\r\n-            encryptedServices.addIfAbsent(sessionType);\r\n-        this.sessionListener.onProtocolSessionStarted(sessionType, sessionID, version, correlationID, hashID, isEncrypted);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceStarted(this, sessionType, isEncrypted);\r\n-            }\r\n-        }\r\n-        //if (version == 3)\r\n-        initialiseSession();\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEnded(SessionType sessionType, byte sessionID,\r\n-                                       String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEnded(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceEnded(this, sessionType);\r\n-            }\r\n-        }\r\n-        encryptedServices.remove(sessionType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolError(String info, Exception e) {\r\n-        this.sessionListener.onProtocolError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendHeartbeat(IHeartbeatMonitor monitor) {\r\n-        DebugTool.logInfo(TAG, \"Asked to send heartbeat\");\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection.sendHeartbeat(this);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void heartbeatTimedOut(IHeartbeatMonitor monitor) {\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection._connectionListener.onHeartbeatTimedOut(this.sessionId);\r\n-        close();\r\n-    }\r\n-\r\n-    private static SdlConnection findTheProperConnection(BaseTransportConfig config) {\r\n-        SdlConnection connection = null;\r\n-\r\n-        int minCount = 0;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == config.getTransportType()) {\r\n-                if (minCount == 0 || minCount >= c.getRegisterCount()) {\r\n-                    connection = c;\r\n-                    minCount = c.getRegisterCount();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStartedNACKed(SessionType sessionType,\r\n-                                               byte sessionID, byte version, String correlationID, List<String> rejectedParams) {\r\n-        this.sessionListener.onProtocolSessionStartedNACKed(sessionType,\r\n-                sessionID, version, correlationID, rejectedParams);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"Start \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEndedNACKed(SessionType sessionType,\r\n-                                             byte sessionID, String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEndedNACKed(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"End \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolServiceDataACK(SessionType sessionType, int dataSize, byte sessionID) {\r\n-        this.sessionListener.onProtocolServiceDataACK(sessionType, dataSize, sessionID);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onAuthTokenReceived(String authToken, byte sessionId) {\r\n-        this.sessionListener.onAuthTokenReceived(authToken, sessionId);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onSecurityInitialized() {\r\n-\r\n-        if (_sdlConnection != null && sdlSecurity != null)\r\n-        {\r\n-            List<SessionType> list = sdlSecurity.getServiceList();\r\n-\r\n-            SessionType service;\r\n-            ListIterator<SessionType> iter = list.listIterator();\r\n-\r\n-            while (iter.hasNext()) {\r\n-                service = iter.next();\r\n-\r\n-                if (service != null)\r\n-                    _sdlConnection.startService(service, getSessionId(), true);\r\n-\r\n-                iter.remove();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void clearConnection(){\r\n-        _sdlConnection = null;\r\n-    }\r\n-\r\n-    public void checkForOpenMultiplexConnection(SdlConnection connection){\r\n-        removeConnection(connection);\r\n-        connection.unregisterSession(this);\r\n-        _sdlConnection = null;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == TransportType.MULTIPLEX) {\r\n-                if(c.getIsConnected() || ((MultiplexTransport)c._transport).isPendingConnected()){\r\n-                    _sdlConnection = c;\r\n-                    try {\r\n-                        _sdlConnection.registerSession(this);//Handshake will start when register.\r\n-                    } catch (SdlException e) {\r\n-                        e.printStackTrace();\r\n-                    }\r\n-                    return;\r\n-                }\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-    public static boolean removeConnection(SdlConnection connection){\r\n-        return shareConnections.remove(connection);\r\n-    }\r\n-\r\n-    public void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners == null){\r\n-            serviceListeners = new HashMap<>();\r\n-        }\r\n-        if(serviceType != null && sdlServiceListener != null){\r\n-            if(!serviceListeners.containsKey(serviceType)){\r\n-                serviceListeners.put(serviceType,new CopyOnWriteArrayList<ISdlServiceListener>());\r\n-            }\r\n-            serviceListeners.get(serviceType).add(sdlServiceListener);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners!= null && serviceType != null && sdlServiceListener != null && serviceListeners.containsKey(serviceType)){\r\n-            return serviceListeners.get(serviceType).remove(sdlServiceListener);\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-\r\n-    public HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> getServiceListeners(){\r\n-        return serviceListeners;\r\n-    }\r\n-\r\n-    public void setDesiredVideoParams(VideoStreamingParameters params){\r\n-        this.desiredVideoParams = params;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the currently set desired video streaming parameters. If there haven't been any set,\r\n-     * the default options will be returned and set for this instance.\r\n-     * @return\r\n-     */\r\n-    public VideoStreamingParameters getDesiredVideoParams(){\r\n-        if(desiredVideoParams == null){\r\n-            desiredVideoParams = new VideoStreamingParameters();\r\n-        }\r\n-        return desiredVideoParams;\r\n-    }\r\n-\r\n-    public void setAcceptedVideoParams(VideoStreamingParameters params){\r\n-        this.acceptedVideoParams = params;\r\n-    }\r\n-\r\n-    public VideoStreamingParameters getAcceptedVideoParams(){\r\n-        return acceptedVideoParams;\r\n-    }\r\n-\r\n-    private VideoStreamingProtocol getAcceptedProtocol() {\r\n-        // acquire default protocol (RAW)\r\n-        VideoStreamingProtocol protocol = new VideoStreamingParameters().getFormat().getProtocol();\r\n-\r\n-        if (acceptedVideoParams != null) {\r\n-            VideoStreamingFormat format = acceptedVideoParams.getFormat();\r\n-            if (format != null && format.getProtocol() != null) {\r\n-                protocol = format.getProtocol();\r\n-            }\r\n-        }\r\n-\r\n-        return protocol;\r\n-    }\r\n-\r\n-    public Version getProtocolVersion(){\r\n-        //Since this session version never supported a minor protocol version this should be fine\r\n-        return new Version(wiproProcolVer,0,0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if a transport is available to start/use the supplied service.\r\n-     * @param sessionType the session that should be checked for transport availability\r\n-     * @return true if there is either a supported\r\n-     *         transport currently connected or a transport is\r\n-     *         available to connect with for the supplied service type.\r\n-     *         <br>false if there is no\r\n-     *         transport connected to support the service type in question and\r\n-     *          no possibility in the foreseeable future.\r\n-     */\r\n-    public boolean isTransportForServiceAvailable(SessionType sessionType){\r\n-        return _sdlConnection!= null\r\n-                && _sdlConnection._transport!= null\r\n-                && _sdlConnection._transport.getIsConnected()\r\n-                && ((sessionType == SessionType.RPC || sessionType == SessionType.CONTROL || sessionType == SessionType.BULK_DATA ) //If this is a service that can run on any transport just return true\r\n-                    || (_sdlConnection._transport.getTransportType() == TransportType.USB || _sdlConnection._transport.getTransportType() == TransportType.TCP));\r\n-    }\r\n-\r\n-\r\n-}\n\\ No newline at end of file\n+/*\n+ * Copyright (c) 2018 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+import android.content.Context;\n+\n+import com.smartdevicelink.exception.SdlException;\n+import com.smartdevicelink.protocol.ISdlProtocol;\n+import com.smartdevicelink.protocol.ProtocolMessage;\n+import com.smartdevicelink.protocol.SdlPacket;\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\n+import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\n+import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\n+import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\n+import com.smartdevicelink.streaming.AbstractPacketizer;\n+import com.smartdevicelink.streaming.IStreamListener;\n+import com.smartdevicelink.streaming.StreamPacketizer;\n+import com.smartdevicelink.streaming.video.RTPH264Packetizer;\n+import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n+import com.smartdevicelink.transport.BaseTransportConfig;\n+import com.smartdevicelink.transport.MultiplexTransportConfig;\n+import com.smartdevicelink.transport.TCPTransportConfig;\n+import com.smartdevicelink.transport.enums.TransportType;\n+import com.smartdevicelink.util.DebugTool;\n+import com.smartdevicelink.util.MediaStreamingStatus;\n+import com.smartdevicelink.util.Version;\n+\n+import java.io.IOException;\n+import java.lang.ref.WeakReference;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+@SuppressWarnings({\"WeakerAccess\", \"deprecation\"})\n+public class SdlSession extends BaseSdlSession {\n+    private static final String TAG = \"SdlSession\";\n+\n+    WeakReference<Context> contextWeakReference;\n+    MediaStreamingStatus mediaStreamingStatus;\n+    boolean requiresAudioSupport = false;\n+\n+    public SdlSession(ISdlConnectionListener listener, MultiplexTransportConfig config){\n+        super(listener,config);\n+        this.transportConfig = config;\n+        if(config != null){\n+            contextWeakReference = new WeakReference<>(config.getContext());\n+            this.requiresAudioSupport = Boolean.TRUE.equals(config.requiresAudioSupport()); //handle null case\n+\n+        }\n+        this.sessionListener = listener;\n+\n+    }\n+\n+    public SdlSession(ISdlConnectionListener listener, TCPTransportConfig config){ //TODO is it better to have two constructors or make it take BaseTransportConfig?", "originalCommit": "f8080616efd531480981fb265b611e91dffa8489", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5NTgyNA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465295824", "bodyText": "No, this was just a leftover comment/thought. I will remove.", "author": "joeygrover", "createdAt": "2020-08-04T19:58:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc2NDk3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mzc3Mzg4MQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r463773881", "bodyText": "Do we need to update this right now and does it need to go from 2017 - 2020 as a combination of the original SdlSession and SdlSession2", "author": "JulianKast", "createdAt": "2020-07-31T18:47:03Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -1,838 +1,339 @@\n-/*\r\n- * Copyright (c) 2017 - 2019, SmartDeviceLink Consortium, Inc.\r\n- * All rights reserved.\r\n- *\r\n- * Redistribution and use in source and binary forms, with or without\r\n- * modification, are permitted provided that the following conditions are met:\r\n- *\r\n- * Redistributions of source code must retain the above copyright notice, this\r\n- * list of conditions and the following disclaimer.\r\n- *\r\n- * Redistributions in binary form must reproduce the above copyright notice,\r\n- * this list of conditions and the following\r\n- * disclaimer in the documentation and/or other materials provided with the\r\n- * distribution.\r\n- *\r\n- * Neither the name of the SmartDeviceLink Consortium, Inc. nor the names of its\r\n- * contributors may be used to endorse or promote products derived from this \r\n- * software without specific prior written permission.\r\n- *\r\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n- * POSSIBILITY OF SUCH DAMAGE.\r\n- */\r\n-package com.smartdevicelink.SdlConnection;\r\n-\r\n-import android.annotation.SuppressLint;\r\n-import android.os.Build;\r\n-import android.view.Surface;\r\n-\r\n-import com.smartdevicelink.encoder.SdlEncoder;\r\n-import com.smartdevicelink.encoder.VirtualDisplayEncoder;\r\n-import com.smartdevicelink.exception.SdlException;\r\n-import com.smartdevicelink.protocol.ProtocolMessage;\r\n-import com.smartdevicelink.protocol.enums.SessionType;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitorListener;\r\n-import com.smartdevicelink.proxy.LockScreenManager;\r\n-import com.smartdevicelink.proxy.RPCRequest;\r\n-import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\r\n-import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\r\n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\r\n-import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\r\n-import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\r\n-import com.smartdevicelink.security.ISecurityInitializedListener;\r\n-import com.smartdevicelink.security.SdlSecurityBase;\r\n-import com.smartdevicelink.streaming.AbstractPacketizer;\r\n-import com.smartdevicelink.streaming.IStreamListener;\r\n-import com.smartdevicelink.streaming.StreamPacketizer;\r\n-import com.smartdevicelink.streaming.StreamRPCPacketizer;\r\n-import com.smartdevicelink.streaming.video.RTPH264Packetizer;\r\n-import com.smartdevicelink.streaming.video.VideoStreamingParameters;\r\n-import com.smartdevicelink.transport.BaseTransportConfig;\r\n-import com.smartdevicelink.transport.MultiplexTransport;\r\n-import com.smartdevicelink.transport.enums.TransportType;\r\n-import com.smartdevicelink.util.DebugTool;\r\n-import com.smartdevicelink.util.Version;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.OutputStream;\r\n-import java.io.PipedInputStream;\r\n-import java.io.PipedOutputStream;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.ListIterator;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-@Deprecated\r\n-public class SdlSession implements ISdlConnectionListener, IHeartbeatMonitorListener, IStreamListener, ISecurityInitializedListener {\r\n-\r\n-   private static final String TAG = \"SdlSession\";\r\n-\r\n-    protected final static int BUFF_READ_SIZE = 1024;\r\n-\r\n-\tprivate static CopyOnWriteArrayList<SdlConnection> shareConnections = new CopyOnWriteArrayList<SdlConnection>();\r\n-\r\n-\tprivate byte wiproProcolVer;\r\n-\r\n-    protected BaseTransportConfig transportConfig;\r\n-    protected ISdlConnectionListener sessionListener;\r\n-\tprotected LockScreenManager lockScreenMan  = new LockScreenManager();\r\n-\tprotected SdlSecurityBase sdlSecurity = null;\r\n-\tprotected VideoStreamingParameters desiredVideoParams = null;\r\n-\tprotected VideoStreamingParameters acceptedVideoParams = null;\r\n-\r\n-\tprotected byte sessionId;\r\n-\tprotected int sessionHashId = 0;\r\n-\tprotected HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> serviceListeners;\r\n-\tprotected CopyOnWriteArrayList<SessionType> encryptedServices = new CopyOnWriteArrayList<SessionType>();\r\n-\r\n-\r\n-\tSdlConnection _sdlConnection = null;\r\n-\r\n-\tIHeartbeatMonitor _outgoingHeartbeatMonitor = null;\r\n-\tIHeartbeatMonitor _incomingHeartbeatMonitor = null;\r\n-\r\n-    StreamRPCPacketizer mRPCPacketizer = null;\r\n-    AbstractPacketizer mVideoPacketizer = null;\r\n-    StreamPacketizer mAudioPacketizer = null;\r\n-    SdlEncoder mSdlEncoder = null;\r\n-    VirtualDisplayEncoder virtualDisplayEncoder = null;\r\n-    boolean sdlSecurityInitializing = false;\r\n-\r\n-    public static SdlSession createSession(byte wiproVersion, ISdlConnectionListener listener, BaseTransportConfig btConfig) {\r\n-\r\n-        SdlSession session =  new SdlSession();\r\n-        session.wiproProcolVer = wiproVersion;\r\n-        session.sessionListener = listener;\r\n-        session.transportConfig = btConfig;\r\n-\r\n-        return session;\r\n-    }\r\n-\r\n-    public BaseTransportConfig getTransportConfig() {\r\n-        return this.transportConfig;\r\n-    }\r\n-\r\n-    public LockScreenManager getLockScreenMan() {\r\n-        return lockScreenMan;\r\n-    }\r\n-\r\n-\r\n-    public IHeartbeatMonitor getOutgoingHeartbeatMonitor() {\r\n-        return _outgoingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public IHeartbeatMonitor getIncomingHeartbeatMonitor() {\r\n-        return _incomingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public void setOutgoingHeartbeatMonitor(IHeartbeatMonitor outgoingHeartbeatMonitor) {\r\n-        this._outgoingHeartbeatMonitor = outgoingHeartbeatMonitor;\r\n-        _outgoingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public void setIncomingHeartbeatMonitor(IHeartbeatMonitor incomingHeartbeatMonitor) {\r\n-        this._incomingHeartbeatMonitor = incomingHeartbeatMonitor;\r\n-        _incomingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public int getSessionHashId() {\r\n-        return this.sessionHashId;\r\n-    }\r\n-\r\n-    public byte getSessionId() {\r\n-        return this.sessionId;\r\n-    }\r\n-\r\n-    public SdlConnection getSdlConnection() {\r\n-        return this._sdlConnection;\r\n-    }\r\n-\r\n-    public int getMtu(){\r\n-        if(this._sdlConnection!=null){\r\n-            return this._sdlConnection.getWiProProtocol().getMtu();\r\n-        }else{\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public long getMtu(SessionType type) {\r\n-        if (this._sdlConnection != null) {\r\n-            return this._sdlConnection.getWiProProtocol().getMtu(type);\r\n-        } else {\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        if (sdlSecurity != null)\r\n-        {\r\n-            sdlSecurity.resetParams();\r\n-            sdlSecurity.shutDown();\r\n-        }\r\n-\r\n-        if (_sdlConnection != null) { //sessionId == 0 means session is not started.\r\n-            //_sdlConnection.unregisterSession(this);\r\n-\r\n-            if (_sdlConnection.getRegisterCount() == 0) {\r\n-                shareConnections.remove(_sdlConnection);\r\n-            }\r\n-\r\n-            _sdlConnection = null;\r\n-        }\r\n-    }\r\n-\r\n-    public void resetSession(){\r\n-\r\n-    }\r\n-\r\n-    public void startStream(InputStream is, SessionType sType, byte rpcSessionID) throws IOException {\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressLint(\"NewApi\")\r\n-    public OutputStream startStream(SessionType sType, byte rpcSessionID) throws IOException {\r\n-        OutputStream os = new PipedOutputStream();\r\n-        InputStream is = null;\r\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\r\n-            is = new PipedInputStream((PipedOutputStream) os, BUFF_READ_SIZE);\r\n-        } else {\r\n-            is = new PipedInputStream((PipedOutputStream) os);\r\n-        }\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-        else\r\n-        {\r\n-            os.close();\r\n-            is.close();\r\n-            return null;\r\n-        }\r\n-        return os;\r\n-    }\r\n-\r\n-    public IVideoStreamListener startVideoStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        VideoStreamingProtocol protocol = getAcceptedProtocol();\r\n-        try {\r\n-            switch (protocol) {\r\n-                case RAW: {\r\n-                    StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.NAV, rpcSessionID, this);\r\n-                    packetizer.sdlConnection = this.getSdlConnection();\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                case RTP: {\r\n-                    RTPH264Packetizer packetizer = new RTPH264Packetizer(this, SessionType.NAV, rpcSessionID, this);\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                default:\r\n-                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\r\n-                    return null;\r\n-            }\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    public IAudioStreamListener startAudioStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        try {\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.PCM, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer = packetizer;\r\n-            mAudioPacketizer.start();\r\n-            return packetizer;\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void startRPCStream(InputStream is, RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public OutputStream startRPCStream(RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            OutputStream os = new PipedOutputStream();\r\n-            InputStream is = new PipedInputStream((PipedOutputStream) os);\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-            return os;\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void pauseRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.pause();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void resumeRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.resume();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void stopRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.stop();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean stopAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean stopVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public Surface createOpenGLInputSurface(int frameRate, int iFrameInterval, int width,\r\n-                                            int height, int bitrate, SessionType sType, byte rpcSessionID) {\r\n-        IVideoStreamListener encoderListener = startVideoStream();\r\n-        if (encoderListener == null) {\r\n-            return null;\r\n-        }\r\n-\r\n-        mSdlEncoder = new SdlEncoder();\r\n-        mSdlEncoder.setFrameRate(frameRate);\r\n-        mSdlEncoder.setFrameInterval(iFrameInterval);\r\n-        mSdlEncoder.setFrameWidth(width);\r\n-        mSdlEncoder.setFrameHeight(height);\r\n-        mSdlEncoder.setBitrate(bitrate);\r\n-        mSdlEncoder.setOutputListener(encoderListener);\r\n-        return mSdlEncoder.prepareEncoder();\r\n-    }\r\n-\r\n-    public void startEncoder () {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.startEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void releaseEncoder() {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.releaseEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void drainEncoder(boolean endOfStream) {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.drainEncoder(endOfStream);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendStreamPacket(ProtocolMessage pm) {\r\n-        sendMessage(pm);\r\n-    }\r\n-\r\n-    public void setSdlSecurity(SdlSecurityBase sec) {\r\n-        sdlSecurity = sec;\r\n-    }\r\n-\r\n-    public SdlSecurityBase getSdlSecurity() {\r\n-        return sdlSecurity;\r\n-    }\r\n-\r\n-    public void startService (SessionType serviceType, byte sessionID, boolean isEncrypted) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-\r\n-        if (isEncrypted)\r\n-        {\r\n-            if (sdlSecurity != null)\r\n-            {\r\n-                List<SessionType> serviceList = sdlSecurity.getServiceList();\r\n-                if (!serviceList.contains(serviceType))\r\n-                    serviceList.add(serviceType);\r\n-\r\n-                if (!sdlSecurityInitializing) {\r\n-                    sdlSecurityInitializing = true;\r\n-                    sdlSecurity.initialize();\r\n-                    return;\r\n-                }\r\n-            }\r\n-        }\r\n-        _sdlConnection.startService(serviceType, sessionID, isEncrypted);\r\n-    }\r\n-\r\n-    public void endService (SessionType serviceType, byte sessionID) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.endService(serviceType, sessionID);\r\n-    }\r\n-\r\n-    protected void processControlService(ProtocolMessage msg) {\r\n-        if (sdlSecurity == null)\r\n-            return;\r\n-        int ilen = msg.getData().length - 12;\r\n-        byte[] data = new byte[ilen];\r\n-        System.arraycopy(msg.getData(), 12, data, 0, ilen);\r\n-\r\n-        byte[] dataToRead = new byte[4096];\r\n-\r\n-        Integer iNumBytes = sdlSecurity.runHandshake(data, dataToRead);\r\n-\r\n-        if (iNumBytes == null || iNumBytes <= 0)\r\n-            return;\r\n-\r\n-        byte[] returnBytes = new byte[iNumBytes];\r\n-        System.arraycopy(dataToRead, 0, returnBytes, 0, iNumBytes);\r\n-        ProtocolMessage protocolMessage = new ProtocolMessage();\r\n-        protocolMessage.setSessionType(SessionType.CONTROL);\r\n-        protocolMessage.setData(returnBytes);\r\n-        protocolMessage.setFunctionID(0x01);\r\n-        protocolMessage.setVersion(wiproProcolVer);\r\n-        protocolMessage.setSessionID(getSessionId());\r\n-\r\n-        //sdlSecurity.hs();\r\n-\r\n-        sendMessage(protocolMessage);\r\n-    }\r\n-\r\n-    public String getBroadcastComment(BaseTransportConfig myTransport) {\r\n-        SdlConnection connection = null;\r\n-        if (myTransport.shareConnection()) {\r\n-            connection = findTheProperConnection(myTransport);\r\n-        } else {\r\n-            connection = this._sdlConnection;\r\n-        }\r\n-\r\n-        if (connection != null)\r\n-            return connection.getBroadcastComment();\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-\r\n-    public void startSession() throws SdlException {\r\n-        SdlConnection connection = null;\r\n-        if (this.transportConfig.shareConnection()) {\r\n-            connection = findTheProperConnection(this.transportConfig);\r\n-\r\n-            if (connection == null) {\r\n-                connection = new SdlConnection(this.transportConfig);\r\n-                shareConnections.add(connection);\r\n-            }\r\n-        } else {\r\n-            connection = new SdlConnection(this.transportConfig);\r\n-        }\r\n-\r\n-        this._sdlConnection = connection;\r\n-        connection.registerSession(this); //Handshake will start when register.\r\n-    }\r\n-\r\n-    protected void initialiseSession() {\r\n-        if (_outgoingHeartbeatMonitor != null) {\r\n-            _outgoingHeartbeatMonitor.start();\r\n-        }\r\n-        if (_incomingHeartbeatMonitor != null) {\r\n-            _incomingHeartbeatMonitor.start();\r\n-        }\r\n-    }\r\n-\r\n-    public void sendMessage(ProtocolMessage msg) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.sendMessage(msg);\r\n-    }\r\n-\r\n-    public TransportType getCurrentTransportType() {\r\n-        if (_sdlConnection == null)\r\n-            return null;\r\n-        return _sdlConnection.getCurrentTransportType();\r\n-    }\r\n-\r\n-    public boolean getIsConnected() {\r\n-        if (_sdlConnection == null)\r\n-            return false;\r\n-        return _sdlConnection != null && _sdlConnection.getIsConnected();\r\n-    }\r\n-\r\n-    public boolean isServiceProtected(SessionType sType) {\r\n-        return encryptedServices.contains(sType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info, boolean availablePrimary, BaseTransportConfig transportConfig) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportError(String info, Exception e) {\r\n-        this.sessionListener.onTransportError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolMessageReceived(ProtocolMessage msg) {\r\n-        if (msg.getSessionType().equals(SessionType.CONTROL)) {\r\n-            processControlService(msg);\r\n-            return;\r\n-        }\r\n-\r\n-        this.sessionListener.onProtocolMessageReceived(msg);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onHeartbeatTimedOut(byte sessionID) {\r\n-        this.sessionListener.onHeartbeatTimedOut(sessionID);\r\n-\r\n-    }\r\n-\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStarted(SessionType sessionType,\r\n-                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\r\n-        this.sessionId = sessionID;\r\n-        lockScreenMan.setSessionID(sessionID);\r\n-        if (sessionType.eq(SessionType.RPC)){\r\n-            sessionHashId = hashID;\r\n-            wiproProcolVer = version;\r\n-        }\r\n-        if (isEncrypted)\r\n-            encryptedServices.addIfAbsent(sessionType);\r\n-        this.sessionListener.onProtocolSessionStarted(sessionType, sessionID, version, correlationID, hashID, isEncrypted);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceStarted(this, sessionType, isEncrypted);\r\n-            }\r\n-        }\r\n-        //if (version == 3)\r\n-        initialiseSession();\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEnded(SessionType sessionType, byte sessionID,\r\n-                                       String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEnded(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceEnded(this, sessionType);\r\n-            }\r\n-        }\r\n-        encryptedServices.remove(sessionType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolError(String info, Exception e) {\r\n-        this.sessionListener.onProtocolError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendHeartbeat(IHeartbeatMonitor monitor) {\r\n-        DebugTool.logInfo(TAG, \"Asked to send heartbeat\");\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection.sendHeartbeat(this);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void heartbeatTimedOut(IHeartbeatMonitor monitor) {\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection._connectionListener.onHeartbeatTimedOut(this.sessionId);\r\n-        close();\r\n-    }\r\n-\r\n-    private static SdlConnection findTheProperConnection(BaseTransportConfig config) {\r\n-        SdlConnection connection = null;\r\n-\r\n-        int minCount = 0;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == config.getTransportType()) {\r\n-                if (minCount == 0 || minCount >= c.getRegisterCount()) {\r\n-                    connection = c;\r\n-                    minCount = c.getRegisterCount();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStartedNACKed(SessionType sessionType,\r\n-                                               byte sessionID, byte version, String correlationID, List<String> rejectedParams) {\r\n-        this.sessionListener.onProtocolSessionStartedNACKed(sessionType,\r\n-                sessionID, version, correlationID, rejectedParams);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"Start \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEndedNACKed(SessionType sessionType,\r\n-                                             byte sessionID, String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEndedNACKed(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"End \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolServiceDataACK(SessionType sessionType, int dataSize, byte sessionID) {\r\n-        this.sessionListener.onProtocolServiceDataACK(sessionType, dataSize, sessionID);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onAuthTokenReceived(String authToken, byte sessionId) {\r\n-        this.sessionListener.onAuthTokenReceived(authToken, sessionId);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onSecurityInitialized() {\r\n-\r\n-        if (_sdlConnection != null && sdlSecurity != null)\r\n-        {\r\n-            List<SessionType> list = sdlSecurity.getServiceList();\r\n-\r\n-            SessionType service;\r\n-            ListIterator<SessionType> iter = list.listIterator();\r\n-\r\n-            while (iter.hasNext()) {\r\n-                service = iter.next();\r\n-\r\n-                if (service != null)\r\n-                    _sdlConnection.startService(service, getSessionId(), true);\r\n-\r\n-                iter.remove();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void clearConnection(){\r\n-        _sdlConnection = null;\r\n-    }\r\n-\r\n-    public void checkForOpenMultiplexConnection(SdlConnection connection){\r\n-        removeConnection(connection);\r\n-        connection.unregisterSession(this);\r\n-        _sdlConnection = null;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == TransportType.MULTIPLEX) {\r\n-                if(c.getIsConnected() || ((MultiplexTransport)c._transport).isPendingConnected()){\r\n-                    _sdlConnection = c;\r\n-                    try {\r\n-                        _sdlConnection.registerSession(this);//Handshake will start when register.\r\n-                    } catch (SdlException e) {\r\n-                        e.printStackTrace();\r\n-                    }\r\n-                    return;\r\n-                }\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-    public static boolean removeConnection(SdlConnection connection){\r\n-        return shareConnections.remove(connection);\r\n-    }\r\n-\r\n-    public void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners == null){\r\n-            serviceListeners = new HashMap<>();\r\n-        }\r\n-        if(serviceType != null && sdlServiceListener != null){\r\n-            if(!serviceListeners.containsKey(serviceType)){\r\n-                serviceListeners.put(serviceType,new CopyOnWriteArrayList<ISdlServiceListener>());\r\n-            }\r\n-            serviceListeners.get(serviceType).add(sdlServiceListener);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners!= null && serviceType != null && sdlServiceListener != null && serviceListeners.containsKey(serviceType)){\r\n-            return serviceListeners.get(serviceType).remove(sdlServiceListener);\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-\r\n-    public HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> getServiceListeners(){\r\n-        return serviceListeners;\r\n-    }\r\n-\r\n-    public void setDesiredVideoParams(VideoStreamingParameters params){\r\n-        this.desiredVideoParams = params;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the currently set desired video streaming parameters. If there haven't been any set,\r\n-     * the default options will be returned and set for this instance.\r\n-     * @return\r\n-     */\r\n-    public VideoStreamingParameters getDesiredVideoParams(){\r\n-        if(desiredVideoParams == null){\r\n-            desiredVideoParams = new VideoStreamingParameters();\r\n-        }\r\n-        return desiredVideoParams;\r\n-    }\r\n-\r\n-    public void setAcceptedVideoParams(VideoStreamingParameters params){\r\n-        this.acceptedVideoParams = params;\r\n-    }\r\n-\r\n-    public VideoStreamingParameters getAcceptedVideoParams(){\r\n-        return acceptedVideoParams;\r\n-    }\r\n-\r\n-    private VideoStreamingProtocol getAcceptedProtocol() {\r\n-        // acquire default protocol (RAW)\r\n-        VideoStreamingProtocol protocol = new VideoStreamingParameters().getFormat().getProtocol();\r\n-\r\n-        if (acceptedVideoParams != null) {\r\n-            VideoStreamingFormat format = acceptedVideoParams.getFormat();\r\n-            if (format != null && format.getProtocol() != null) {\r\n-                protocol = format.getProtocol();\r\n-            }\r\n-        }\r\n-\r\n-        return protocol;\r\n-    }\r\n-\r\n-    public Version getProtocolVersion(){\r\n-        //Since this session version never supported a minor protocol version this should be fine\r\n-        return new Version(wiproProcolVer,0,0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if a transport is available to start/use the supplied service.\r\n-     * @param sessionType the session that should be checked for transport availability\r\n-     * @return true if there is either a supported\r\n-     *         transport currently connected or a transport is\r\n-     *         available to connect with for the supplied service type.\r\n-     *         <br>false if there is no\r\n-     *         transport connected to support the service type in question and\r\n-     *          no possibility in the foreseeable future.\r\n-     */\r\n-    public boolean isTransportForServiceAvailable(SessionType sessionType){\r\n-        return _sdlConnection!= null\r\n-                && _sdlConnection._transport!= null\r\n-                && _sdlConnection._transport.getIsConnected()\r\n-                && ((sessionType == SessionType.RPC || sessionType == SessionType.CONTROL || sessionType == SessionType.BULK_DATA ) //If this is a service that can run on any transport just return true\r\n-                    || (_sdlConnection._transport.getTransportType() == TransportType.USB || _sdlConnection._transport.getTransportType() == TransportType.TCP));\r\n-    }\r\n-\r\n-\r\n-}\n\\ No newline at end of file\n+/*\n+ * Copyright (c) 2018 Livio, Inc.", "originalCommit": "f8080616efd531480981fb265b611e91dffa8489", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNDcwMg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465134702", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public SdlSession(ISdlConnectionListener listener, MultiplexTransportConfig config){\n          \n          \n            \n                public SdlSession(ISdlConnectionListener listener, MultiplexTransportConfig config) {", "author": "JulianKast", "createdAt": "2020-08-04T15:25:18Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -1,838 +1,339 @@\n-/*\r\n- * Copyright (c) 2017 - 2019, SmartDeviceLink Consortium, Inc.\r\n- * All rights reserved.\r\n- *\r\n- * Redistribution and use in source and binary forms, with or without\r\n- * modification, are permitted provided that the following conditions are met:\r\n- *\r\n- * Redistributions of source code must retain the above copyright notice, this\r\n- * list of conditions and the following disclaimer.\r\n- *\r\n- * Redistributions in binary form must reproduce the above copyright notice,\r\n- * this list of conditions and the following\r\n- * disclaimer in the documentation and/or other materials provided with the\r\n- * distribution.\r\n- *\r\n- * Neither the name of the SmartDeviceLink Consortium, Inc. nor the names of its\r\n- * contributors may be used to endorse or promote products derived from this \r\n- * software without specific prior written permission.\r\n- *\r\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n- * POSSIBILITY OF SUCH DAMAGE.\r\n- */\r\n-package com.smartdevicelink.SdlConnection;\r\n-\r\n-import android.annotation.SuppressLint;\r\n-import android.os.Build;\r\n-import android.view.Surface;\r\n-\r\n-import com.smartdevicelink.encoder.SdlEncoder;\r\n-import com.smartdevicelink.encoder.VirtualDisplayEncoder;\r\n-import com.smartdevicelink.exception.SdlException;\r\n-import com.smartdevicelink.protocol.ProtocolMessage;\r\n-import com.smartdevicelink.protocol.enums.SessionType;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitorListener;\r\n-import com.smartdevicelink.proxy.LockScreenManager;\r\n-import com.smartdevicelink.proxy.RPCRequest;\r\n-import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\r\n-import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\r\n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\r\n-import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\r\n-import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\r\n-import com.smartdevicelink.security.ISecurityInitializedListener;\r\n-import com.smartdevicelink.security.SdlSecurityBase;\r\n-import com.smartdevicelink.streaming.AbstractPacketizer;\r\n-import com.smartdevicelink.streaming.IStreamListener;\r\n-import com.smartdevicelink.streaming.StreamPacketizer;\r\n-import com.smartdevicelink.streaming.StreamRPCPacketizer;\r\n-import com.smartdevicelink.streaming.video.RTPH264Packetizer;\r\n-import com.smartdevicelink.streaming.video.VideoStreamingParameters;\r\n-import com.smartdevicelink.transport.BaseTransportConfig;\r\n-import com.smartdevicelink.transport.MultiplexTransport;\r\n-import com.smartdevicelink.transport.enums.TransportType;\r\n-import com.smartdevicelink.util.DebugTool;\r\n-import com.smartdevicelink.util.Version;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.OutputStream;\r\n-import java.io.PipedInputStream;\r\n-import java.io.PipedOutputStream;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.ListIterator;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-@Deprecated\r\n-public class SdlSession implements ISdlConnectionListener, IHeartbeatMonitorListener, IStreamListener, ISecurityInitializedListener {\r\n-\r\n-   private static final String TAG = \"SdlSession\";\r\n-\r\n-    protected final static int BUFF_READ_SIZE = 1024;\r\n-\r\n-\tprivate static CopyOnWriteArrayList<SdlConnection> shareConnections = new CopyOnWriteArrayList<SdlConnection>();\r\n-\r\n-\tprivate byte wiproProcolVer;\r\n-\r\n-    protected BaseTransportConfig transportConfig;\r\n-    protected ISdlConnectionListener sessionListener;\r\n-\tprotected LockScreenManager lockScreenMan  = new LockScreenManager();\r\n-\tprotected SdlSecurityBase sdlSecurity = null;\r\n-\tprotected VideoStreamingParameters desiredVideoParams = null;\r\n-\tprotected VideoStreamingParameters acceptedVideoParams = null;\r\n-\r\n-\tprotected byte sessionId;\r\n-\tprotected int sessionHashId = 0;\r\n-\tprotected HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> serviceListeners;\r\n-\tprotected CopyOnWriteArrayList<SessionType> encryptedServices = new CopyOnWriteArrayList<SessionType>();\r\n-\r\n-\r\n-\tSdlConnection _sdlConnection = null;\r\n-\r\n-\tIHeartbeatMonitor _outgoingHeartbeatMonitor = null;\r\n-\tIHeartbeatMonitor _incomingHeartbeatMonitor = null;\r\n-\r\n-    StreamRPCPacketizer mRPCPacketizer = null;\r\n-    AbstractPacketizer mVideoPacketizer = null;\r\n-    StreamPacketizer mAudioPacketizer = null;\r\n-    SdlEncoder mSdlEncoder = null;\r\n-    VirtualDisplayEncoder virtualDisplayEncoder = null;\r\n-    boolean sdlSecurityInitializing = false;\r\n-\r\n-    public static SdlSession createSession(byte wiproVersion, ISdlConnectionListener listener, BaseTransportConfig btConfig) {\r\n-\r\n-        SdlSession session =  new SdlSession();\r\n-        session.wiproProcolVer = wiproVersion;\r\n-        session.sessionListener = listener;\r\n-        session.transportConfig = btConfig;\r\n-\r\n-        return session;\r\n-    }\r\n-\r\n-    public BaseTransportConfig getTransportConfig() {\r\n-        return this.transportConfig;\r\n-    }\r\n-\r\n-    public LockScreenManager getLockScreenMan() {\r\n-        return lockScreenMan;\r\n-    }\r\n-\r\n-\r\n-    public IHeartbeatMonitor getOutgoingHeartbeatMonitor() {\r\n-        return _outgoingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public IHeartbeatMonitor getIncomingHeartbeatMonitor() {\r\n-        return _incomingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public void setOutgoingHeartbeatMonitor(IHeartbeatMonitor outgoingHeartbeatMonitor) {\r\n-        this._outgoingHeartbeatMonitor = outgoingHeartbeatMonitor;\r\n-        _outgoingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public void setIncomingHeartbeatMonitor(IHeartbeatMonitor incomingHeartbeatMonitor) {\r\n-        this._incomingHeartbeatMonitor = incomingHeartbeatMonitor;\r\n-        _incomingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public int getSessionHashId() {\r\n-        return this.sessionHashId;\r\n-    }\r\n-\r\n-    public byte getSessionId() {\r\n-        return this.sessionId;\r\n-    }\r\n-\r\n-    public SdlConnection getSdlConnection() {\r\n-        return this._sdlConnection;\r\n-    }\r\n-\r\n-    public int getMtu(){\r\n-        if(this._sdlConnection!=null){\r\n-            return this._sdlConnection.getWiProProtocol().getMtu();\r\n-        }else{\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public long getMtu(SessionType type) {\r\n-        if (this._sdlConnection != null) {\r\n-            return this._sdlConnection.getWiProProtocol().getMtu(type);\r\n-        } else {\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        if (sdlSecurity != null)\r\n-        {\r\n-            sdlSecurity.resetParams();\r\n-            sdlSecurity.shutDown();\r\n-        }\r\n-\r\n-        if (_sdlConnection != null) { //sessionId == 0 means session is not started.\r\n-            //_sdlConnection.unregisterSession(this);\r\n-\r\n-            if (_sdlConnection.getRegisterCount() == 0) {\r\n-                shareConnections.remove(_sdlConnection);\r\n-            }\r\n-\r\n-            _sdlConnection = null;\r\n-        }\r\n-    }\r\n-\r\n-    public void resetSession(){\r\n-\r\n-    }\r\n-\r\n-    public void startStream(InputStream is, SessionType sType, byte rpcSessionID) throws IOException {\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressLint(\"NewApi\")\r\n-    public OutputStream startStream(SessionType sType, byte rpcSessionID) throws IOException {\r\n-        OutputStream os = new PipedOutputStream();\r\n-        InputStream is = null;\r\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\r\n-            is = new PipedInputStream((PipedOutputStream) os, BUFF_READ_SIZE);\r\n-        } else {\r\n-            is = new PipedInputStream((PipedOutputStream) os);\r\n-        }\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-        else\r\n-        {\r\n-            os.close();\r\n-            is.close();\r\n-            return null;\r\n-        }\r\n-        return os;\r\n-    }\r\n-\r\n-    public IVideoStreamListener startVideoStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        VideoStreamingProtocol protocol = getAcceptedProtocol();\r\n-        try {\r\n-            switch (protocol) {\r\n-                case RAW: {\r\n-                    StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.NAV, rpcSessionID, this);\r\n-                    packetizer.sdlConnection = this.getSdlConnection();\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                case RTP: {\r\n-                    RTPH264Packetizer packetizer = new RTPH264Packetizer(this, SessionType.NAV, rpcSessionID, this);\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                default:\r\n-                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\r\n-                    return null;\r\n-            }\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    public IAudioStreamListener startAudioStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        try {\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.PCM, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer = packetizer;\r\n-            mAudioPacketizer.start();\r\n-            return packetizer;\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void startRPCStream(InputStream is, RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public OutputStream startRPCStream(RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            OutputStream os = new PipedOutputStream();\r\n-            InputStream is = new PipedInputStream((PipedOutputStream) os);\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-            return os;\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void pauseRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.pause();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void resumeRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.resume();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void stopRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.stop();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean stopAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean stopVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public Surface createOpenGLInputSurface(int frameRate, int iFrameInterval, int width,\r\n-                                            int height, int bitrate, SessionType sType, byte rpcSessionID) {\r\n-        IVideoStreamListener encoderListener = startVideoStream();\r\n-        if (encoderListener == null) {\r\n-            return null;\r\n-        }\r\n-\r\n-        mSdlEncoder = new SdlEncoder();\r\n-        mSdlEncoder.setFrameRate(frameRate);\r\n-        mSdlEncoder.setFrameInterval(iFrameInterval);\r\n-        mSdlEncoder.setFrameWidth(width);\r\n-        mSdlEncoder.setFrameHeight(height);\r\n-        mSdlEncoder.setBitrate(bitrate);\r\n-        mSdlEncoder.setOutputListener(encoderListener);\r\n-        return mSdlEncoder.prepareEncoder();\r\n-    }\r\n-\r\n-    public void startEncoder () {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.startEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void releaseEncoder() {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.releaseEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void drainEncoder(boolean endOfStream) {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.drainEncoder(endOfStream);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendStreamPacket(ProtocolMessage pm) {\r\n-        sendMessage(pm);\r\n-    }\r\n-\r\n-    public void setSdlSecurity(SdlSecurityBase sec) {\r\n-        sdlSecurity = sec;\r\n-    }\r\n-\r\n-    public SdlSecurityBase getSdlSecurity() {\r\n-        return sdlSecurity;\r\n-    }\r\n-\r\n-    public void startService (SessionType serviceType, byte sessionID, boolean isEncrypted) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-\r\n-        if (isEncrypted)\r\n-        {\r\n-            if (sdlSecurity != null)\r\n-            {\r\n-                List<SessionType> serviceList = sdlSecurity.getServiceList();\r\n-                if (!serviceList.contains(serviceType))\r\n-                    serviceList.add(serviceType);\r\n-\r\n-                if (!sdlSecurityInitializing) {\r\n-                    sdlSecurityInitializing = true;\r\n-                    sdlSecurity.initialize();\r\n-                    return;\r\n-                }\r\n-            }\r\n-        }\r\n-        _sdlConnection.startService(serviceType, sessionID, isEncrypted);\r\n-    }\r\n-\r\n-    public void endService (SessionType serviceType, byte sessionID) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.endService(serviceType, sessionID);\r\n-    }\r\n-\r\n-    protected void processControlService(ProtocolMessage msg) {\r\n-        if (sdlSecurity == null)\r\n-            return;\r\n-        int ilen = msg.getData().length - 12;\r\n-        byte[] data = new byte[ilen];\r\n-        System.arraycopy(msg.getData(), 12, data, 0, ilen);\r\n-\r\n-        byte[] dataToRead = new byte[4096];\r\n-\r\n-        Integer iNumBytes = sdlSecurity.runHandshake(data, dataToRead);\r\n-\r\n-        if (iNumBytes == null || iNumBytes <= 0)\r\n-            return;\r\n-\r\n-        byte[] returnBytes = new byte[iNumBytes];\r\n-        System.arraycopy(dataToRead, 0, returnBytes, 0, iNumBytes);\r\n-        ProtocolMessage protocolMessage = new ProtocolMessage();\r\n-        protocolMessage.setSessionType(SessionType.CONTROL);\r\n-        protocolMessage.setData(returnBytes);\r\n-        protocolMessage.setFunctionID(0x01);\r\n-        protocolMessage.setVersion(wiproProcolVer);\r\n-        protocolMessage.setSessionID(getSessionId());\r\n-\r\n-        //sdlSecurity.hs();\r\n-\r\n-        sendMessage(protocolMessage);\r\n-    }\r\n-\r\n-    public String getBroadcastComment(BaseTransportConfig myTransport) {\r\n-        SdlConnection connection = null;\r\n-        if (myTransport.shareConnection()) {\r\n-            connection = findTheProperConnection(myTransport);\r\n-        } else {\r\n-            connection = this._sdlConnection;\r\n-        }\r\n-\r\n-        if (connection != null)\r\n-            return connection.getBroadcastComment();\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-\r\n-    public void startSession() throws SdlException {\r\n-        SdlConnection connection = null;\r\n-        if (this.transportConfig.shareConnection()) {\r\n-            connection = findTheProperConnection(this.transportConfig);\r\n-\r\n-            if (connection == null) {\r\n-                connection = new SdlConnection(this.transportConfig);\r\n-                shareConnections.add(connection);\r\n-            }\r\n-        } else {\r\n-            connection = new SdlConnection(this.transportConfig);\r\n-        }\r\n-\r\n-        this._sdlConnection = connection;\r\n-        connection.registerSession(this); //Handshake will start when register.\r\n-    }\r\n-\r\n-    protected void initialiseSession() {\r\n-        if (_outgoingHeartbeatMonitor != null) {\r\n-            _outgoingHeartbeatMonitor.start();\r\n-        }\r\n-        if (_incomingHeartbeatMonitor != null) {\r\n-            _incomingHeartbeatMonitor.start();\r\n-        }\r\n-    }\r\n-\r\n-    public void sendMessage(ProtocolMessage msg) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.sendMessage(msg);\r\n-    }\r\n-\r\n-    public TransportType getCurrentTransportType() {\r\n-        if (_sdlConnection == null)\r\n-            return null;\r\n-        return _sdlConnection.getCurrentTransportType();\r\n-    }\r\n-\r\n-    public boolean getIsConnected() {\r\n-        if (_sdlConnection == null)\r\n-            return false;\r\n-        return _sdlConnection != null && _sdlConnection.getIsConnected();\r\n-    }\r\n-\r\n-    public boolean isServiceProtected(SessionType sType) {\r\n-        return encryptedServices.contains(sType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info, boolean availablePrimary, BaseTransportConfig transportConfig) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportError(String info, Exception e) {\r\n-        this.sessionListener.onTransportError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolMessageReceived(ProtocolMessage msg) {\r\n-        if (msg.getSessionType().equals(SessionType.CONTROL)) {\r\n-            processControlService(msg);\r\n-            return;\r\n-        }\r\n-\r\n-        this.sessionListener.onProtocolMessageReceived(msg);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onHeartbeatTimedOut(byte sessionID) {\r\n-        this.sessionListener.onHeartbeatTimedOut(sessionID);\r\n-\r\n-    }\r\n-\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStarted(SessionType sessionType,\r\n-                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\r\n-        this.sessionId = sessionID;\r\n-        lockScreenMan.setSessionID(sessionID);\r\n-        if (sessionType.eq(SessionType.RPC)){\r\n-            sessionHashId = hashID;\r\n-            wiproProcolVer = version;\r\n-        }\r\n-        if (isEncrypted)\r\n-            encryptedServices.addIfAbsent(sessionType);\r\n-        this.sessionListener.onProtocolSessionStarted(sessionType, sessionID, version, correlationID, hashID, isEncrypted);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceStarted(this, sessionType, isEncrypted);\r\n-            }\r\n-        }\r\n-        //if (version == 3)\r\n-        initialiseSession();\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEnded(SessionType sessionType, byte sessionID,\r\n-                                       String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEnded(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceEnded(this, sessionType);\r\n-            }\r\n-        }\r\n-        encryptedServices.remove(sessionType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolError(String info, Exception e) {\r\n-        this.sessionListener.onProtocolError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendHeartbeat(IHeartbeatMonitor monitor) {\r\n-        DebugTool.logInfo(TAG, \"Asked to send heartbeat\");\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection.sendHeartbeat(this);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void heartbeatTimedOut(IHeartbeatMonitor monitor) {\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection._connectionListener.onHeartbeatTimedOut(this.sessionId);\r\n-        close();\r\n-    }\r\n-\r\n-    private static SdlConnection findTheProperConnection(BaseTransportConfig config) {\r\n-        SdlConnection connection = null;\r\n-\r\n-        int minCount = 0;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == config.getTransportType()) {\r\n-                if (minCount == 0 || minCount >= c.getRegisterCount()) {\r\n-                    connection = c;\r\n-                    minCount = c.getRegisterCount();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStartedNACKed(SessionType sessionType,\r\n-                                               byte sessionID, byte version, String correlationID, List<String> rejectedParams) {\r\n-        this.sessionListener.onProtocolSessionStartedNACKed(sessionType,\r\n-                sessionID, version, correlationID, rejectedParams);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"Start \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEndedNACKed(SessionType sessionType,\r\n-                                             byte sessionID, String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEndedNACKed(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"End \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolServiceDataACK(SessionType sessionType, int dataSize, byte sessionID) {\r\n-        this.sessionListener.onProtocolServiceDataACK(sessionType, dataSize, sessionID);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onAuthTokenReceived(String authToken, byte sessionId) {\r\n-        this.sessionListener.onAuthTokenReceived(authToken, sessionId);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onSecurityInitialized() {\r\n-\r\n-        if (_sdlConnection != null && sdlSecurity != null)\r\n-        {\r\n-            List<SessionType> list = sdlSecurity.getServiceList();\r\n-\r\n-            SessionType service;\r\n-            ListIterator<SessionType> iter = list.listIterator();\r\n-\r\n-            while (iter.hasNext()) {\r\n-                service = iter.next();\r\n-\r\n-                if (service != null)\r\n-                    _sdlConnection.startService(service, getSessionId(), true);\r\n-\r\n-                iter.remove();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void clearConnection(){\r\n-        _sdlConnection = null;\r\n-    }\r\n-\r\n-    public void checkForOpenMultiplexConnection(SdlConnection connection){\r\n-        removeConnection(connection);\r\n-        connection.unregisterSession(this);\r\n-        _sdlConnection = null;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == TransportType.MULTIPLEX) {\r\n-                if(c.getIsConnected() || ((MultiplexTransport)c._transport).isPendingConnected()){\r\n-                    _sdlConnection = c;\r\n-                    try {\r\n-                        _sdlConnection.registerSession(this);//Handshake will start when register.\r\n-                    } catch (SdlException e) {\r\n-                        e.printStackTrace();\r\n-                    }\r\n-                    return;\r\n-                }\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-    public static boolean removeConnection(SdlConnection connection){\r\n-        return shareConnections.remove(connection);\r\n-    }\r\n-\r\n-    public void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners == null){\r\n-            serviceListeners = new HashMap<>();\r\n-        }\r\n-        if(serviceType != null && sdlServiceListener != null){\r\n-            if(!serviceListeners.containsKey(serviceType)){\r\n-                serviceListeners.put(serviceType,new CopyOnWriteArrayList<ISdlServiceListener>());\r\n-            }\r\n-            serviceListeners.get(serviceType).add(sdlServiceListener);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners!= null && serviceType != null && sdlServiceListener != null && serviceListeners.containsKey(serviceType)){\r\n-            return serviceListeners.get(serviceType).remove(sdlServiceListener);\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-\r\n-    public HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> getServiceListeners(){\r\n-        return serviceListeners;\r\n-    }\r\n-\r\n-    public void setDesiredVideoParams(VideoStreamingParameters params){\r\n-        this.desiredVideoParams = params;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the currently set desired video streaming parameters. If there haven't been any set,\r\n-     * the default options will be returned and set for this instance.\r\n-     * @return\r\n-     */\r\n-    public VideoStreamingParameters getDesiredVideoParams(){\r\n-        if(desiredVideoParams == null){\r\n-            desiredVideoParams = new VideoStreamingParameters();\r\n-        }\r\n-        return desiredVideoParams;\r\n-    }\r\n-\r\n-    public void setAcceptedVideoParams(VideoStreamingParameters params){\r\n-        this.acceptedVideoParams = params;\r\n-    }\r\n-\r\n-    public VideoStreamingParameters getAcceptedVideoParams(){\r\n-        return acceptedVideoParams;\r\n-    }\r\n-\r\n-    private VideoStreamingProtocol getAcceptedProtocol() {\r\n-        // acquire default protocol (RAW)\r\n-        VideoStreamingProtocol protocol = new VideoStreamingParameters().getFormat().getProtocol();\r\n-\r\n-        if (acceptedVideoParams != null) {\r\n-            VideoStreamingFormat format = acceptedVideoParams.getFormat();\r\n-            if (format != null && format.getProtocol() != null) {\r\n-                protocol = format.getProtocol();\r\n-            }\r\n-        }\r\n-\r\n-        return protocol;\r\n-    }\r\n-\r\n-    public Version getProtocolVersion(){\r\n-        //Since this session version never supported a minor protocol version this should be fine\r\n-        return new Version(wiproProcolVer,0,0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if a transport is available to start/use the supplied service.\r\n-     * @param sessionType the session that should be checked for transport availability\r\n-     * @return true if there is either a supported\r\n-     *         transport currently connected or a transport is\r\n-     *         available to connect with for the supplied service type.\r\n-     *         <br>false if there is no\r\n-     *         transport connected to support the service type in question and\r\n-     *          no possibility in the foreseeable future.\r\n-     */\r\n-    public boolean isTransportForServiceAvailable(SessionType sessionType){\r\n-        return _sdlConnection!= null\r\n-                && _sdlConnection._transport!= null\r\n-                && _sdlConnection._transport.getIsConnected()\r\n-                && ((sessionType == SessionType.RPC || sessionType == SessionType.CONTROL || sessionType == SessionType.BULK_DATA ) //If this is a service that can run on any transport just return true\r\n-                    || (_sdlConnection._transport.getTransportType() == TransportType.USB || _sdlConnection._transport.getTransportType() == TransportType.TCP));\r\n-    }\r\n-\r\n-\r\n-}\n\\ No newline at end of file\n+/*\n+ * Copyright (c) 2018 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+import android.content.Context;\n+\n+import com.smartdevicelink.exception.SdlException;\n+import com.smartdevicelink.protocol.ISdlProtocol;\n+import com.smartdevicelink.protocol.ProtocolMessage;\n+import com.smartdevicelink.protocol.SdlPacket;\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\n+import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\n+import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\n+import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\n+import com.smartdevicelink.streaming.AbstractPacketizer;\n+import com.smartdevicelink.streaming.IStreamListener;\n+import com.smartdevicelink.streaming.StreamPacketizer;\n+import com.smartdevicelink.streaming.video.RTPH264Packetizer;\n+import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n+import com.smartdevicelink.transport.BaseTransportConfig;\n+import com.smartdevicelink.transport.MultiplexTransportConfig;\n+import com.smartdevicelink.transport.TCPTransportConfig;\n+import com.smartdevicelink.transport.enums.TransportType;\n+import com.smartdevicelink.util.DebugTool;\n+import com.smartdevicelink.util.MediaStreamingStatus;\n+import com.smartdevicelink.util.Version;\n+\n+import java.io.IOException;\n+import java.lang.ref.WeakReference;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+@SuppressWarnings({\"WeakerAccess\", \"deprecation\"})\n+public class SdlSession extends BaseSdlSession {\n+    private static final String TAG = \"SdlSession\";\n+\n+    WeakReference<Context> contextWeakReference;\n+    MediaStreamingStatus mediaStreamingStatus;\n+    boolean requiresAudioSupport = false;\n+\n+    public SdlSession(ISdlConnectionListener listener, MultiplexTransportConfig config){", "originalCommit": "f8080616efd531480981fb265b611e91dffa8489", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNTkxMQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465135911", "bodyText": "This is a common issue in this class, should we run the formatter over the entire class now, or will this fall in the scope of another cleanup card", "author": "JulianKast", "createdAt": "2020-08-04T15:27:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTEzNDcwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NDA1Mw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465144053", "bodyText": "Do we want to keep this commented out log statement in here for testing purposes?", "author": "JulianKast", "createdAt": "2020-08-04T15:38:31Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -1,838 +1,339 @@\n-/*\r\n- * Copyright (c) 2017 - 2019, SmartDeviceLink Consortium, Inc.\r\n- * All rights reserved.\r\n- *\r\n- * Redistribution and use in source and binary forms, with or without\r\n- * modification, are permitted provided that the following conditions are met:\r\n- *\r\n- * Redistributions of source code must retain the above copyright notice, this\r\n- * list of conditions and the following disclaimer.\r\n- *\r\n- * Redistributions in binary form must reproduce the above copyright notice,\r\n- * this list of conditions and the following\r\n- * disclaimer in the documentation and/or other materials provided with the\r\n- * distribution.\r\n- *\r\n- * Neither the name of the SmartDeviceLink Consortium, Inc. nor the names of its\r\n- * contributors may be used to endorse or promote products derived from this \r\n- * software without specific prior written permission.\r\n- *\r\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n- * POSSIBILITY OF SUCH DAMAGE.\r\n- */\r\n-package com.smartdevicelink.SdlConnection;\r\n-\r\n-import android.annotation.SuppressLint;\r\n-import android.os.Build;\r\n-import android.view.Surface;\r\n-\r\n-import com.smartdevicelink.encoder.SdlEncoder;\r\n-import com.smartdevicelink.encoder.VirtualDisplayEncoder;\r\n-import com.smartdevicelink.exception.SdlException;\r\n-import com.smartdevicelink.protocol.ProtocolMessage;\r\n-import com.smartdevicelink.protocol.enums.SessionType;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitorListener;\r\n-import com.smartdevicelink.proxy.LockScreenManager;\r\n-import com.smartdevicelink.proxy.RPCRequest;\r\n-import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\r\n-import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\r\n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\r\n-import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\r\n-import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\r\n-import com.smartdevicelink.security.ISecurityInitializedListener;\r\n-import com.smartdevicelink.security.SdlSecurityBase;\r\n-import com.smartdevicelink.streaming.AbstractPacketizer;\r\n-import com.smartdevicelink.streaming.IStreamListener;\r\n-import com.smartdevicelink.streaming.StreamPacketizer;\r\n-import com.smartdevicelink.streaming.StreamRPCPacketizer;\r\n-import com.smartdevicelink.streaming.video.RTPH264Packetizer;\r\n-import com.smartdevicelink.streaming.video.VideoStreamingParameters;\r\n-import com.smartdevicelink.transport.BaseTransportConfig;\r\n-import com.smartdevicelink.transport.MultiplexTransport;\r\n-import com.smartdevicelink.transport.enums.TransportType;\r\n-import com.smartdevicelink.util.DebugTool;\r\n-import com.smartdevicelink.util.Version;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.OutputStream;\r\n-import java.io.PipedInputStream;\r\n-import java.io.PipedOutputStream;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.ListIterator;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-@Deprecated\r\n-public class SdlSession implements ISdlConnectionListener, IHeartbeatMonitorListener, IStreamListener, ISecurityInitializedListener {\r\n-\r\n-   private static final String TAG = \"SdlSession\";\r\n-\r\n-    protected final static int BUFF_READ_SIZE = 1024;\r\n-\r\n-\tprivate static CopyOnWriteArrayList<SdlConnection> shareConnections = new CopyOnWriteArrayList<SdlConnection>();\r\n-\r\n-\tprivate byte wiproProcolVer;\r\n-\r\n-    protected BaseTransportConfig transportConfig;\r\n-    protected ISdlConnectionListener sessionListener;\r\n-\tprotected LockScreenManager lockScreenMan  = new LockScreenManager();\r\n-\tprotected SdlSecurityBase sdlSecurity = null;\r\n-\tprotected VideoStreamingParameters desiredVideoParams = null;\r\n-\tprotected VideoStreamingParameters acceptedVideoParams = null;\r\n-\r\n-\tprotected byte sessionId;\r\n-\tprotected int sessionHashId = 0;\r\n-\tprotected HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> serviceListeners;\r\n-\tprotected CopyOnWriteArrayList<SessionType> encryptedServices = new CopyOnWriteArrayList<SessionType>();\r\n-\r\n-\r\n-\tSdlConnection _sdlConnection = null;\r\n-\r\n-\tIHeartbeatMonitor _outgoingHeartbeatMonitor = null;\r\n-\tIHeartbeatMonitor _incomingHeartbeatMonitor = null;\r\n-\r\n-    StreamRPCPacketizer mRPCPacketizer = null;\r\n-    AbstractPacketizer mVideoPacketizer = null;\r\n-    StreamPacketizer mAudioPacketizer = null;\r\n-    SdlEncoder mSdlEncoder = null;\r\n-    VirtualDisplayEncoder virtualDisplayEncoder = null;\r\n-    boolean sdlSecurityInitializing = false;\r\n-\r\n-    public static SdlSession createSession(byte wiproVersion, ISdlConnectionListener listener, BaseTransportConfig btConfig) {\r\n-\r\n-        SdlSession session =  new SdlSession();\r\n-        session.wiproProcolVer = wiproVersion;\r\n-        session.sessionListener = listener;\r\n-        session.transportConfig = btConfig;\r\n-\r\n-        return session;\r\n-    }\r\n-\r\n-    public BaseTransportConfig getTransportConfig() {\r\n-        return this.transportConfig;\r\n-    }\r\n-\r\n-    public LockScreenManager getLockScreenMan() {\r\n-        return lockScreenMan;\r\n-    }\r\n-\r\n-\r\n-    public IHeartbeatMonitor getOutgoingHeartbeatMonitor() {\r\n-        return _outgoingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public IHeartbeatMonitor getIncomingHeartbeatMonitor() {\r\n-        return _incomingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public void setOutgoingHeartbeatMonitor(IHeartbeatMonitor outgoingHeartbeatMonitor) {\r\n-        this._outgoingHeartbeatMonitor = outgoingHeartbeatMonitor;\r\n-        _outgoingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public void setIncomingHeartbeatMonitor(IHeartbeatMonitor incomingHeartbeatMonitor) {\r\n-        this._incomingHeartbeatMonitor = incomingHeartbeatMonitor;\r\n-        _incomingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public int getSessionHashId() {\r\n-        return this.sessionHashId;\r\n-    }\r\n-\r\n-    public byte getSessionId() {\r\n-        return this.sessionId;\r\n-    }\r\n-\r\n-    public SdlConnection getSdlConnection() {\r\n-        return this._sdlConnection;\r\n-    }\r\n-\r\n-    public int getMtu(){\r\n-        if(this._sdlConnection!=null){\r\n-            return this._sdlConnection.getWiProProtocol().getMtu();\r\n-        }else{\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public long getMtu(SessionType type) {\r\n-        if (this._sdlConnection != null) {\r\n-            return this._sdlConnection.getWiProProtocol().getMtu(type);\r\n-        } else {\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        if (sdlSecurity != null)\r\n-        {\r\n-            sdlSecurity.resetParams();\r\n-            sdlSecurity.shutDown();\r\n-        }\r\n-\r\n-        if (_sdlConnection != null) { //sessionId == 0 means session is not started.\r\n-            //_sdlConnection.unregisterSession(this);\r\n-\r\n-            if (_sdlConnection.getRegisterCount() == 0) {\r\n-                shareConnections.remove(_sdlConnection);\r\n-            }\r\n-\r\n-            _sdlConnection = null;\r\n-        }\r\n-    }\r\n-\r\n-    public void resetSession(){\r\n-\r\n-    }\r\n-\r\n-    public void startStream(InputStream is, SessionType sType, byte rpcSessionID) throws IOException {\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressLint(\"NewApi\")\r\n-    public OutputStream startStream(SessionType sType, byte rpcSessionID) throws IOException {\r\n-        OutputStream os = new PipedOutputStream();\r\n-        InputStream is = null;\r\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\r\n-            is = new PipedInputStream((PipedOutputStream) os, BUFF_READ_SIZE);\r\n-        } else {\r\n-            is = new PipedInputStream((PipedOutputStream) os);\r\n-        }\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-        else\r\n-        {\r\n-            os.close();\r\n-            is.close();\r\n-            return null;\r\n-        }\r\n-        return os;\r\n-    }\r\n-\r\n-    public IVideoStreamListener startVideoStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        VideoStreamingProtocol protocol = getAcceptedProtocol();\r\n-        try {\r\n-            switch (protocol) {\r\n-                case RAW: {\r\n-                    StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.NAV, rpcSessionID, this);\r\n-                    packetizer.sdlConnection = this.getSdlConnection();\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                case RTP: {\r\n-                    RTPH264Packetizer packetizer = new RTPH264Packetizer(this, SessionType.NAV, rpcSessionID, this);\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                default:\r\n-                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\r\n-                    return null;\r\n-            }\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    public IAudioStreamListener startAudioStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        try {\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.PCM, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer = packetizer;\r\n-            mAudioPacketizer.start();\r\n-            return packetizer;\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void startRPCStream(InputStream is, RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public OutputStream startRPCStream(RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            OutputStream os = new PipedOutputStream();\r\n-            InputStream is = new PipedInputStream((PipedOutputStream) os);\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-            return os;\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void pauseRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.pause();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void resumeRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.resume();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void stopRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.stop();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean stopAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean stopVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public Surface createOpenGLInputSurface(int frameRate, int iFrameInterval, int width,\r\n-                                            int height, int bitrate, SessionType sType, byte rpcSessionID) {\r\n-        IVideoStreamListener encoderListener = startVideoStream();\r\n-        if (encoderListener == null) {\r\n-            return null;\r\n-        }\r\n-\r\n-        mSdlEncoder = new SdlEncoder();\r\n-        mSdlEncoder.setFrameRate(frameRate);\r\n-        mSdlEncoder.setFrameInterval(iFrameInterval);\r\n-        mSdlEncoder.setFrameWidth(width);\r\n-        mSdlEncoder.setFrameHeight(height);\r\n-        mSdlEncoder.setBitrate(bitrate);\r\n-        mSdlEncoder.setOutputListener(encoderListener);\r\n-        return mSdlEncoder.prepareEncoder();\r\n-    }\r\n-\r\n-    public void startEncoder () {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.startEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void releaseEncoder() {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.releaseEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void drainEncoder(boolean endOfStream) {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.drainEncoder(endOfStream);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendStreamPacket(ProtocolMessage pm) {\r\n-        sendMessage(pm);\r\n-    }\r\n-\r\n-    public void setSdlSecurity(SdlSecurityBase sec) {\r\n-        sdlSecurity = sec;\r\n-    }\r\n-\r\n-    public SdlSecurityBase getSdlSecurity() {\r\n-        return sdlSecurity;\r\n-    }\r\n-\r\n-    public void startService (SessionType serviceType, byte sessionID, boolean isEncrypted) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-\r\n-        if (isEncrypted)\r\n-        {\r\n-            if (sdlSecurity != null)\r\n-            {\r\n-                List<SessionType> serviceList = sdlSecurity.getServiceList();\r\n-                if (!serviceList.contains(serviceType))\r\n-                    serviceList.add(serviceType);\r\n-\r\n-                if (!sdlSecurityInitializing) {\r\n-                    sdlSecurityInitializing = true;\r\n-                    sdlSecurity.initialize();\r\n-                    return;\r\n-                }\r\n-            }\r\n-        }\r\n-        _sdlConnection.startService(serviceType, sessionID, isEncrypted);\r\n-    }\r\n-\r\n-    public void endService (SessionType serviceType, byte sessionID) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.endService(serviceType, sessionID);\r\n-    }\r\n-\r\n-    protected void processControlService(ProtocolMessage msg) {\r\n-        if (sdlSecurity == null)\r\n-            return;\r\n-        int ilen = msg.getData().length - 12;\r\n-        byte[] data = new byte[ilen];\r\n-        System.arraycopy(msg.getData(), 12, data, 0, ilen);\r\n-\r\n-        byte[] dataToRead = new byte[4096];\r\n-\r\n-        Integer iNumBytes = sdlSecurity.runHandshake(data, dataToRead);\r\n-\r\n-        if (iNumBytes == null || iNumBytes <= 0)\r\n-            return;\r\n-\r\n-        byte[] returnBytes = new byte[iNumBytes];\r\n-        System.arraycopy(dataToRead, 0, returnBytes, 0, iNumBytes);\r\n-        ProtocolMessage protocolMessage = new ProtocolMessage();\r\n-        protocolMessage.setSessionType(SessionType.CONTROL);\r\n-        protocolMessage.setData(returnBytes);\r\n-        protocolMessage.setFunctionID(0x01);\r\n-        protocolMessage.setVersion(wiproProcolVer);\r\n-        protocolMessage.setSessionID(getSessionId());\r\n-\r\n-        //sdlSecurity.hs();\r\n-\r\n-        sendMessage(protocolMessage);\r\n-    }\r\n-\r\n-    public String getBroadcastComment(BaseTransportConfig myTransport) {\r\n-        SdlConnection connection = null;\r\n-        if (myTransport.shareConnection()) {\r\n-            connection = findTheProperConnection(myTransport);\r\n-        } else {\r\n-            connection = this._sdlConnection;\r\n-        }\r\n-\r\n-        if (connection != null)\r\n-            return connection.getBroadcastComment();\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-\r\n-    public void startSession() throws SdlException {\r\n-        SdlConnection connection = null;\r\n-        if (this.transportConfig.shareConnection()) {\r\n-            connection = findTheProperConnection(this.transportConfig);\r\n-\r\n-            if (connection == null) {\r\n-                connection = new SdlConnection(this.transportConfig);\r\n-                shareConnections.add(connection);\r\n-            }\r\n-        } else {\r\n-            connection = new SdlConnection(this.transportConfig);\r\n-        }\r\n-\r\n-        this._sdlConnection = connection;\r\n-        connection.registerSession(this); //Handshake will start when register.\r\n-    }\r\n-\r\n-    protected void initialiseSession() {\r\n-        if (_outgoingHeartbeatMonitor != null) {\r\n-            _outgoingHeartbeatMonitor.start();\r\n-        }\r\n-        if (_incomingHeartbeatMonitor != null) {\r\n-            _incomingHeartbeatMonitor.start();\r\n-        }\r\n-    }\r\n-\r\n-    public void sendMessage(ProtocolMessage msg) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.sendMessage(msg);\r\n-    }\r\n-\r\n-    public TransportType getCurrentTransportType() {\r\n-        if (_sdlConnection == null)\r\n-            return null;\r\n-        return _sdlConnection.getCurrentTransportType();\r\n-    }\r\n-\r\n-    public boolean getIsConnected() {\r\n-        if (_sdlConnection == null)\r\n-            return false;\r\n-        return _sdlConnection != null && _sdlConnection.getIsConnected();\r\n-    }\r\n-\r\n-    public boolean isServiceProtected(SessionType sType) {\r\n-        return encryptedServices.contains(sType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info, boolean availablePrimary, BaseTransportConfig transportConfig) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportError(String info, Exception e) {\r\n-        this.sessionListener.onTransportError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolMessageReceived(ProtocolMessage msg) {\r\n-        if (msg.getSessionType().equals(SessionType.CONTROL)) {\r\n-            processControlService(msg);\r\n-            return;\r\n-        }\r\n-\r\n-        this.sessionListener.onProtocolMessageReceived(msg);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onHeartbeatTimedOut(byte sessionID) {\r\n-        this.sessionListener.onHeartbeatTimedOut(sessionID);\r\n-\r\n-    }\r\n-\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStarted(SessionType sessionType,\r\n-                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\r\n-        this.sessionId = sessionID;\r\n-        lockScreenMan.setSessionID(sessionID);\r\n-        if (sessionType.eq(SessionType.RPC)){\r\n-            sessionHashId = hashID;\r\n-            wiproProcolVer = version;\r\n-        }\r\n-        if (isEncrypted)\r\n-            encryptedServices.addIfAbsent(sessionType);\r\n-        this.sessionListener.onProtocolSessionStarted(sessionType, sessionID, version, correlationID, hashID, isEncrypted);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceStarted(this, sessionType, isEncrypted);\r\n-            }\r\n-        }\r\n-        //if (version == 3)\r\n-        initialiseSession();\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEnded(SessionType sessionType, byte sessionID,\r\n-                                       String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEnded(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceEnded(this, sessionType);\r\n-            }\r\n-        }\r\n-        encryptedServices.remove(sessionType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolError(String info, Exception e) {\r\n-        this.sessionListener.onProtocolError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendHeartbeat(IHeartbeatMonitor monitor) {\r\n-        DebugTool.logInfo(TAG, \"Asked to send heartbeat\");\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection.sendHeartbeat(this);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void heartbeatTimedOut(IHeartbeatMonitor monitor) {\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection._connectionListener.onHeartbeatTimedOut(this.sessionId);\r\n-        close();\r\n-    }\r\n-\r\n-    private static SdlConnection findTheProperConnection(BaseTransportConfig config) {\r\n-        SdlConnection connection = null;\r\n-\r\n-        int minCount = 0;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == config.getTransportType()) {\r\n-                if (minCount == 0 || minCount >= c.getRegisterCount()) {\r\n-                    connection = c;\r\n-                    minCount = c.getRegisterCount();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStartedNACKed(SessionType sessionType,\r\n-                                               byte sessionID, byte version, String correlationID, List<String> rejectedParams) {\r\n-        this.sessionListener.onProtocolSessionStartedNACKed(sessionType,\r\n-                sessionID, version, correlationID, rejectedParams);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"Start \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEndedNACKed(SessionType sessionType,\r\n-                                             byte sessionID, String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEndedNACKed(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"End \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolServiceDataACK(SessionType sessionType, int dataSize, byte sessionID) {\r\n-        this.sessionListener.onProtocolServiceDataACK(sessionType, dataSize, sessionID);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onAuthTokenReceived(String authToken, byte sessionId) {\r\n-        this.sessionListener.onAuthTokenReceived(authToken, sessionId);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onSecurityInitialized() {\r\n-\r\n-        if (_sdlConnection != null && sdlSecurity != null)\r\n-        {\r\n-            List<SessionType> list = sdlSecurity.getServiceList();\r\n-\r\n-            SessionType service;\r\n-            ListIterator<SessionType> iter = list.listIterator();\r\n-\r\n-            while (iter.hasNext()) {\r\n-                service = iter.next();\r\n-\r\n-                if (service != null)\r\n-                    _sdlConnection.startService(service, getSessionId(), true);\r\n-\r\n-                iter.remove();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void clearConnection(){\r\n-        _sdlConnection = null;\r\n-    }\r\n-\r\n-    public void checkForOpenMultiplexConnection(SdlConnection connection){\r\n-        removeConnection(connection);\r\n-        connection.unregisterSession(this);\r\n-        _sdlConnection = null;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == TransportType.MULTIPLEX) {\r\n-                if(c.getIsConnected() || ((MultiplexTransport)c._transport).isPendingConnected()){\r\n-                    _sdlConnection = c;\r\n-                    try {\r\n-                        _sdlConnection.registerSession(this);//Handshake will start when register.\r\n-                    } catch (SdlException e) {\r\n-                        e.printStackTrace();\r\n-                    }\r\n-                    return;\r\n-                }\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-    public static boolean removeConnection(SdlConnection connection){\r\n-        return shareConnections.remove(connection);\r\n-    }\r\n-\r\n-    public void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners == null){\r\n-            serviceListeners = new HashMap<>();\r\n-        }\r\n-        if(serviceType != null && sdlServiceListener != null){\r\n-            if(!serviceListeners.containsKey(serviceType)){\r\n-                serviceListeners.put(serviceType,new CopyOnWriteArrayList<ISdlServiceListener>());\r\n-            }\r\n-            serviceListeners.get(serviceType).add(sdlServiceListener);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners!= null && serviceType != null && sdlServiceListener != null && serviceListeners.containsKey(serviceType)){\r\n-            return serviceListeners.get(serviceType).remove(sdlServiceListener);\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-\r\n-    public HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> getServiceListeners(){\r\n-        return serviceListeners;\r\n-    }\r\n-\r\n-    public void setDesiredVideoParams(VideoStreamingParameters params){\r\n-        this.desiredVideoParams = params;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the currently set desired video streaming parameters. If there haven't been any set,\r\n-     * the default options will be returned and set for this instance.\r\n-     * @return\r\n-     */\r\n-    public VideoStreamingParameters getDesiredVideoParams(){\r\n-        if(desiredVideoParams == null){\r\n-            desiredVideoParams = new VideoStreamingParameters();\r\n-        }\r\n-        return desiredVideoParams;\r\n-    }\r\n-\r\n-    public void setAcceptedVideoParams(VideoStreamingParameters params){\r\n-        this.acceptedVideoParams = params;\r\n-    }\r\n-\r\n-    public VideoStreamingParameters getAcceptedVideoParams(){\r\n-        return acceptedVideoParams;\r\n-    }\r\n-\r\n-    private VideoStreamingProtocol getAcceptedProtocol() {\r\n-        // acquire default protocol (RAW)\r\n-        VideoStreamingProtocol protocol = new VideoStreamingParameters().getFormat().getProtocol();\r\n-\r\n-        if (acceptedVideoParams != null) {\r\n-            VideoStreamingFormat format = acceptedVideoParams.getFormat();\r\n-            if (format != null && format.getProtocol() != null) {\r\n-                protocol = format.getProtocol();\r\n-            }\r\n-        }\r\n-\r\n-        return protocol;\r\n-    }\r\n-\r\n-    public Version getProtocolVersion(){\r\n-        //Since this session version never supported a minor protocol version this should be fine\r\n-        return new Version(wiproProcolVer,0,0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if a transport is available to start/use the supplied service.\r\n-     * @param sessionType the session that should be checked for transport availability\r\n-     * @return true if there is either a supported\r\n-     *         transport currently connected or a transport is\r\n-     *         available to connect with for the supplied service type.\r\n-     *         <br>false if there is no\r\n-     *         transport connected to support the service type in question and\r\n-     *          no possibility in the foreseeable future.\r\n-     */\r\n-    public boolean isTransportForServiceAvailable(SessionType sessionType){\r\n-        return _sdlConnection!= null\r\n-                && _sdlConnection._transport!= null\r\n-                && _sdlConnection._transport.getIsConnected()\r\n-                && ((sessionType == SessionType.RPC || sessionType == SessionType.CONTROL || sessionType == SessionType.BULK_DATA ) //If this is a service that can run on any transport just return true\r\n-                    || (_sdlConnection._transport.getTransportType() == TransportType.USB || _sdlConnection._transport.getTransportType() == TransportType.TCP));\r\n-    }\r\n-\r\n-\r\n-}\n\\ No newline at end of file\n+/*\n+ * Copyright (c) 2018 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+import android.content.Context;\n+\n+import com.smartdevicelink.exception.SdlException;\n+import com.smartdevicelink.protocol.ISdlProtocol;\n+import com.smartdevicelink.protocol.ProtocolMessage;\n+import com.smartdevicelink.protocol.SdlPacket;\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\n+import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\n+import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\n+import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\n+import com.smartdevicelink.streaming.AbstractPacketizer;\n+import com.smartdevicelink.streaming.IStreamListener;\n+import com.smartdevicelink.streaming.StreamPacketizer;\n+import com.smartdevicelink.streaming.video.RTPH264Packetizer;\n+import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n+import com.smartdevicelink.transport.BaseTransportConfig;\n+import com.smartdevicelink.transport.MultiplexTransportConfig;\n+import com.smartdevicelink.transport.TCPTransportConfig;\n+import com.smartdevicelink.transport.enums.TransportType;\n+import com.smartdevicelink.util.DebugTool;\n+import com.smartdevicelink.util.MediaStreamingStatus;\n+import com.smartdevicelink.util.Version;\n+\n+import java.io.IOException;\n+import java.lang.ref.WeakReference;\n+import java.util.List;\n+import java.util.ListIterator;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+@SuppressWarnings({\"WeakerAccess\", \"deprecation\"})\n+public class SdlSession extends BaseSdlSession {\n+    private static final String TAG = \"SdlSession\";\n+\n+    WeakReference<Context> contextWeakReference;\n+    MediaStreamingStatus mediaStreamingStatus;\n+    boolean requiresAudioSupport = false;\n+\n+    public SdlSession(ISdlConnectionListener listener, MultiplexTransportConfig config){\n+        super(listener,config);\n+        this.transportConfig = config;\n+        if(config != null){\n+            contextWeakReference = new WeakReference<>(config.getContext());\n+            this.requiresAudioSupport = Boolean.TRUE.equals(config.requiresAudioSupport()); //handle null case\n+\n+        }\n+        this.sessionListener = listener;\n+\n+    }\n+\n+    public SdlSession(ISdlConnectionListener listener, TCPTransportConfig config){ //TODO is it better to have two constructors or make it take BaseTransportConfig?\n+        super(listener, config);\n+        this.transportConfig = config;\n+        this.sessionListener = listener;\n+    }\n+\n+    protected SdlProtocolBase getSdlProtocolImplementation(){\n+        if(transportConfig instanceof  MultiplexTransportConfig) {\n+            return new SdlProtocol(this, (MultiplexTransportConfig)transportConfig);\n+        } else if(transportConfig instanceof  TCPTransportConfig) {\n+            return new SdlProtocol(this, (TCPTransportConfig)transportConfig);\n+        }\n+\n+        return null;\n+    }\n+\n+    boolean isAudioRequirementMet(){\n+        if(mediaStreamingStatus == null && contextWeakReference!= null && contextWeakReference.get() != null){\n+            mediaStreamingStatus = new MediaStreamingStatus(contextWeakReference.get(), new MediaStreamingStatus.Callback() {\n+                @Override\n+                public void onAudioNoLongerAvailable() {\n+                    close();\n+                    shutdown(\"Audio output no longer available\");\n+                }\n+            });\n+        }\n+\n+        // If requiresAudioSupport is false, or a supported audio output device is available\n+        return !requiresAudioSupport || mediaStreamingStatus.isAudioOutputAvailable();\n+\n+    }\n+\n+\n+    @SuppressWarnings(\"RedundantThrows\")\n+    @Override\n+    public void startSession() throws SdlException {\n+        if(!isAudioRequirementMet()){\n+            shutdown(\"Audio output not available\");\n+            return;\n+        }\n+\n+        sdlProtocol.start();\n+    }\n+\n+    @Override\n+    public TransportType getCurrentTransportType() {\n+        return TransportType.MULTIPLEX;\n+    }\n+\n+    @Override\n+    public void shutdown(String info){\n+        DebugTool.logInfo(TAG, \"Shutdown - \" + info);\n+        if(mediaStreamingStatus != null) {\n+            mediaStreamingStatus.clear();\n+        }\n+        super.shutdown(info);\n+\n+    }\n+\n+    /**\n+     * Get the current protocol version used by this session\n+     * @return Version that represents the Protocol version being used\n+     */\n+    @Override\n+    public Version getProtocolVersion(){\n+        if(sdlProtocol!=null){\n+            return sdlProtocol.getProtocolVersion();\n+        }\n+        return new Version(1,0,0);\n+    }\n+\n+\n+     /* ***********************************************************************************************************************************************************************\n+     * *****************************************************************  IProtocol Listener  ********************************************************************************\n+     *************************************************************************************************************************************************************************/\n+\n+    @Override\n+    public void onProtocolMessageBytesToSend(SdlPacket packet) {\n+        //Log.d(TAG, \"onProtocolMessageBytesToSend - \" + packet.getTransportType());", "originalCommit": "f8080616efd531480981fb265b611e91dffa8489", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5NjExOQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465296119", "bodyText": "It should be removed.", "author": "joeygrover", "createdAt": "2020-08-04T19:58:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NDA1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE0NjI4MQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465146281", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    }else{\n          \n          \n            \n                    } else {", "author": "JulianKast", "createdAt": "2020-08-04T15:41:49Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/managers/lifecycle/LifecycleManager.java", "diffHunk": "@@ -94,11 +93,11 @@ void initialize() {\n         }\n \n         if (_transportConfig != null && _transportConfig.getTransportType().equals(TransportType.MULTIPLEX)) {\n-            this.session = new SdlSession2(sdlConnectionListener, (MultiplexTransportConfig) _transportConfig);\n+            this.session = new SdlSession(sdlConnectionListener, (MultiplexTransportConfig) _transportConfig);\n         } else if (_transportConfig != null && _transportConfig.getTransportType().equals(TransportType.TCP)) {\n-            this.session = new SdlSession2(sdlConnectionListener, (TCPTransportConfig) _transportConfig);\n-        } else {\n-            this.session = SdlSession.createSession((byte) getProtocolVersion().getMajor(), sdlConnectionListener, _transportConfig);\n+            this.session = new SdlSession(sdlConnectionListener, (TCPTransportConfig) _transportConfig);\n+        }else{", "originalCommit": "f8080616efd531480981fb265b611e91dffa8489", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MjU4Nw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465152587", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t_session.endService(_serviceType,_rpcSessionID);\n          \n          \n            \n            \t\t\t_session.endService(_serviceType, _rpcSessionID);", "author": "JulianKast", "createdAt": "2020-08-04T15:50:59Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/streaming/StreamPacketizer.java", "diffHunk": "@@ -185,13 +183,7 @@ public void run() {\n \t\t}\r\n \t\tfinally\r\n \t\t{\r\n-\t\t\tif(_session == null) {\r\n-\t\t\t\tif (sdlConnection != null) {\r\n-\t\t\t\t\tsdlConnection.endService(_serviceType, _rpcSessionID);\r\n-\t\t\t\t}\r\n-\t\t\t}else{\r\n-\t\t\t\t_session.endService(_serviceType,_rpcSessionID);\r\n-\t\t\t}\r\n+\t\t\t_session.endService(_serviceType,_rpcSessionID);\r", "originalCommit": "f8080616efd531480981fb265b611e91dffa8489", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTE1MzY5NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465153694", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            import com.smartdevicelink.protocol.SdlProtocol;", "author": "JulianKast", "createdAt": "2020-08-04T15:52:40Z", "path": "base/src/main/java/com/smartdevicelink/SdlConnection/BaseSdlSession.java", "diffHunk": "@@ -1,44 +1,12 @@\n-/*\n- * Copyright (c) 2019 Livio, Inc.\n- * All rights reserved.\n- *\n- * Redistribution and use in source and binary forms, with or without\n- * modification, are permitted provided that the following conditions are met:\n- *\n- * Redistributions of source code must retain the above copyright notice, this\n- * list of conditions and the following disclaimer.\n- *\n- * Redistributions in binary form must reproduce the above copyright notice,\n- * this list of conditions and the following\n- * disclaimer in the documentation and/or other materials provided with the\n- * distribution.\n- *\n- * Neither the name of the Livio Inc. nor the names of its contributors\n- * may be used to endorse or promote products derived from this software\n- * without specific prior written permission.\n- *\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n- * POSSIBILITY OF SUCH DAMAGE.\n- */\n-\n package com.smartdevicelink.SdlConnection;\n \n-\n import com.smartdevicelink.exception.SdlException;\n import com.smartdevicelink.protocol.ISdlProtocol;\n import com.smartdevicelink.protocol.ProtocolMessage;\n import com.smartdevicelink.protocol.SdlPacket;\n-import com.smartdevicelink.protocol.enums.SessionType;\n import com.smartdevicelink.protocol.SdlProtocol;", "originalCommit": "f8080616efd531480981fb265b611e91dffa8489", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI0OTQ3Mg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465249472", "bodyText": "This FIXME, is this talking about this SdlSession class?", "author": "JulianKast", "createdAt": "2020-08-04T18:33:13Z", "path": "javaSE/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright (c) 2019 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.transport.BaseTransportConfig;\n+import com.smartdevicelink.util.DebugTool;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+public class SdlSession extends BaseSdlSession {\n+\n+    private static final String TAG = \"SdlSession\";\n+\n+\n+    public SdlSession(ISdlConnectionListener listener, BaseTransportConfig config){\n+       super(listener,config);\n+       //FIXME this class needs to move to JavaSE only", "originalCommit": "f8080616efd531480981fb265b611e91dffa8489", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI5NDIyOA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465294228", "bodyText": "Yes, it was already moved so the comment just needs to be deleted.", "author": "joeygrover", "createdAt": "2020-08-04T19:55:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI0OTQ3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI0OTc4NQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465249785", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public SdlSession(ISdlConnectionListener listener, BaseTransportConfig config){\n          \n          \n            \n                public SdlSession(ISdlConnectionListener listener, BaseTransportConfig config) {", "author": "JulianKast", "createdAt": "2020-08-04T18:33:50Z", "path": "javaSE/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright (c) 2019 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.transport.BaseTransportConfig;\n+import com.smartdevicelink.util.DebugTool;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+public class SdlSession extends BaseSdlSession {\n+\n+    private static final String TAG = \"SdlSession\";\n+\n+\n+    public SdlSession(ISdlConnectionListener listener, BaseTransportConfig config){", "originalCommit": "f8080616efd531480981fb265b611e91dffa8489", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI1MTEwNw==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465251107", "bodyText": "There are some added if statements and for loops that need this space added as well, should we fix theses now or run the formatted over them later?", "author": "JulianKast", "createdAt": "2020-08-04T18:36:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI0OTc4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI0OTk3MQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465249971", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (sessionType.eq(SessionType.RPC)){\n          \n          \n            \n                    if (sessionType.eq(SessionType.RPC)) {", "author": "JulianKast", "createdAt": "2020-08-04T18:34:11Z", "path": "javaSE/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright (c) 2019 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.transport.BaseTransportConfig;\n+import com.smartdevicelink.util.DebugTool;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+public class SdlSession extends BaseSdlSession {\n+\n+    private static final String TAG = \"SdlSession\";\n+\n+\n+    public SdlSession(ISdlConnectionListener listener, BaseTransportConfig config){\n+       super(listener,config);\n+       //FIXME this class needs to move to JavaSE only\n+    }\n+\n+    @Override\n+    protected SdlProtocolBase getSdlProtocolImplementation() {\n+        return new SdlProtocol(this, transportConfig);\n+    }\n+\n+\n+    @Override\n+    public void onProtocolSessionStarted(SessionType sessionType,\n+                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\n+\n+        DebugTool.logInfo(TAG, \"Protocol session started\");\n+\n+        this.sessionId = sessionID;\n+        if (sessionType.eq(SessionType.RPC)){", "originalCommit": "f8080616efd531480981fb265b611e91dffa8489", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI1MDU3OQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465250579", "bodyText": "Should we add brackets to the if statement to be consistent?", "author": "JulianKast", "createdAt": "2020-08-04T18:35:20Z", "path": "javaSE/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright (c) 2019 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.transport.BaseTransportConfig;\n+import com.smartdevicelink.util.DebugTool;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+public class SdlSession extends BaseSdlSession {\n+\n+    private static final String TAG = \"SdlSession\";\n+\n+\n+    public SdlSession(ISdlConnectionListener listener, BaseTransportConfig config){\n+       super(listener,config);\n+       //FIXME this class needs to move to JavaSE only\n+    }\n+\n+    @Override\n+    protected SdlProtocolBase getSdlProtocolImplementation() {\n+        return new SdlProtocol(this, transportConfig);\n+    }\n+\n+\n+    @Override\n+    public void onProtocolSessionStarted(SessionType sessionType,\n+                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\n+\n+        DebugTool.logInfo(TAG, \"Protocol session started\");\n+\n+        this.sessionId = sessionID;\n+        if (sessionType.eq(SessionType.RPC)){\n+            sessionHashId = hashID;\n+        }\n+        if (isEncrypted)", "originalCommit": "f8080616efd531480981fb265b611e91dffa8489", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI1MjIwOQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465252209", "bodyText": "Are we adding a Security Listener section or can these comments be removed", "author": "JulianKast", "createdAt": "2020-08-04T18:38:19Z", "path": "javaSE/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -0,0 +1,131 @@\n+/*\n+ * Copyright (c) 2019 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.transport.BaseTransportConfig;\n+import com.smartdevicelink.util.DebugTool;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+public class SdlSession extends BaseSdlSession {\n+\n+    private static final String TAG = \"SdlSession\";\n+\n+\n+    public SdlSession(ISdlConnectionListener listener, BaseTransportConfig config){\n+       super(listener,config);\n+       //FIXME this class needs to move to JavaSE only\n+    }\n+\n+    @Override\n+    protected SdlProtocolBase getSdlProtocolImplementation() {\n+        return new SdlProtocol(this, transportConfig);\n+    }\n+\n+\n+    @Override\n+    public void onProtocolSessionStarted(SessionType sessionType,\n+                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\n+\n+        DebugTool.logInfo(TAG, \"Protocol session started\");\n+\n+        this.sessionId = sessionID;\n+        if (sessionType.eq(SessionType.RPC)){\n+            sessionHashId = hashID;\n+        }\n+        if (isEncrypted)\n+            encryptedServices.addIfAbsent(sessionType);\n+        this.sessionListener.onProtocolSessionStarted(sessionType, sessionID, version, correlationID, hashID, isEncrypted);\n+        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\n+            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\n+            for(ISdlServiceListener listener:listeners){\n+                listener.onServiceStarted(this, sessionType, isEncrypted);\n+            }\n+        }\n+\n+    }\n+\n+    @Override\n+    public void onProtocolSessionEnded(SessionType sessionType, byte sessionID,\n+                                       String correlationID) {\n+        this.sessionListener.onProtocolSessionEnded(sessionType, sessionID, correlationID);\n+        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\n+            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\n+            for(ISdlServiceListener listener:listeners){\n+                listener.onServiceEnded(this, sessionType);\n+            }\n+        }\n+        encryptedServices.remove(sessionType);\n+    }\n+\n+\n+    @Override\n+    public void onProtocolSessionEndedNACKed(SessionType sessionType,\n+                                             byte sessionID, String correlationID) {\n+        this.sessionListener.onProtocolSessionEndedNACKed(sessionType, sessionID, correlationID);\n+        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\n+            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\n+            for(ISdlServiceListener listener:listeners){\n+                listener.onServiceError(this, sessionType, \"End \"+ sessionType.toString() +\" Service NACK'ed\");\n+            }\n+        }\n+    }\n+\n+\n+\n+\n+\n+    /* ***********************************************************************************************************************************************************************\n+     * *****************************************************************  IProtocol Listener  ********************************************************************************\n+     *************************************************************************************************************************************************************************/\n+\n+     public void onProtocolSessionNACKed(SessionType sessionType, byte sessionID, byte version, String correlationID, List<String> rejectedParams) {\n+        this.sessionListener.onProtocolSessionStartedNACKed(sessionType,\n+                sessionID, version, correlationID, rejectedParams);\n+        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\n+            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\n+            for(ISdlServiceListener listener:listeners){\n+                listener.onServiceError(this, sessionType, \"Start \"+ sessionType.toString() +\" Service NAKed\");\n+            }\n+        }\n+    }    /* ***********************************************************************************************************************************************************************\n+     * *****************************************************************  Security Listener  *********************************************************************************", "originalCommit": "f8080616efd531480981fb265b611e91dffa8489", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI1NjEyMg==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465256122", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t//", "author": "JulianKast", "createdAt": "2020-08-04T18:45:46Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/transport/MultiplexTransportTest.java", "diffHunk": "@@ -58,55 +51,25 @@ public void onTransportError(String info, Exception e) {\n \t\t};\n \t\t\n \t}\n-\t\n-\t@Test\n-\tpublic void testThreadRecoverability(){\n-\t\tMultiplexTransportConfig config = new MultiplexTransportConfig(getTargetContext(),SdlUnitTestContants.TEST_APP_ID);\n-\t\t//\tpublic MultiplexTransport(MultiplexTransportConfig transportConfig, final ITransportListener transportListener){\n-\t\tMultiplexTransport trans = new MultiplexTransport(config,transportListener);\n-\t\t\n-\t\tassertTrue(trans.brokerThread.isAlive());\n-\t\tif(trans.brokerThread.broker==null){\n-\t\t\tsynchronized(trans.brokerThread){\n-\t\t\t\ttry {\n-\t\t\t\t\ttrans.brokerThread.wait(TIMEOUT);;\n-\t\t\t\t} catch (InterruptedException e) {\n-\t\t\t\t\te.printStackTrace();\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\t\n-\t\tassertNotNull(trans.brokerThread.broker);\n-\t\t//Force this to true so we can test thread \n-\t\ttrans.brokerThread.connected = true;\n-\t\ttrans.brokerThread.broker.onHardwareDisconnected(TransportType.BLUETOOTH);\n-\t\t\n-\t\tassertNull(trans.brokerThread);\n-\t\t\n-\t\ttrans = new MultiplexTransport(config,transportListener);\n-\t\tassertTrue(trans.brokerThread.isAlive());\n-\n-\t\t// Send a null config object in the constructor and expect an IllegalArgumentException\n-\t\ttry {\n-\t\t\ttrans = new MultiplexTransport(null, transportListener);\n-\t\t} catch (IllegalArgumentException e) {\n-\t\t\tassertEquals(\"Null transportConfig in MultiplexTransport constructor\", e.getMessage());\n-\t\t} catch (NullPointerException e) {\n-\t\t\tAssert.fail(\"NPE in MultiplexTransport constructor\");\n-\t\t}\n-\t}\n-\n \t// test for setting error state.\n \t@Test\n \tpublic void testSetState() {\n-\t\tfinal Bundle bundle = new Bundle();\n \t\tMultiplexBluetoothTransport btTransport = new MultiplexBluetoothTransport(new Handler(Looper.getMainLooper()) {\n \t\t\t@Override\n \t\t\tpublic void handleMessage(Message message) {\n-\t\t\t\tassertTrue(message.getData().equals(bundle));\n+\t\t\t\tassertNotNull(message);\n+\t\t\t\tif (message.arg1 == MultiplexBaseTransport.STATE_ERROR) {\n+\t\t\t\t\tassertNotNull(message.getData());\n+\t\t\t\t\tassertEquals(MultiplexBaseTransport.REASON_SPP_ERROR, message.getData().getByte(MultiplexBaseTransport.ERROR_REASON_KEY));\n+\t\t\t\t} else {\n+\t\t\t\t\t//It will first listen before the error state\n+\t\t\t\t\tassertEquals(MultiplexBaseTransport.STATE_LISTEN, message.arg1);\n+\t\t\t\t}\n+\t\t\t\t//", "originalCommit": "f8080616efd531480981fb265b611e91dffa8489", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTI1NzkwOQ==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465257909", "bodyText": "Uncomment this and move it below\nsession.addServiceListener(SessionType.RPC, test);", "author": "JulianKast", "createdAt": "2020-08-04T18:49:06Z", "path": "android/sdl_android/src/androidTest/java/com/smartdevicelink/test/SdlConnection/SdlSessionTests.java", "diffHunk": "@@ -32,6 +37,7 @@ public void onServiceError(SdlSession session, SessionType type, String reason)\n \t\t\t}\n \t\t};\n \n+\t\t//assertNotNull(session.getServiceListeners());", "originalCommit": "f8080616efd531480981fb265b611e91dffa8489", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a24042f65eb84e60db9302d59a6df1c321513442", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/a24042f65eb84e60db9302d59a6df1c321513442", "message": "Address review comments", "committedDate": "2020-08-04T19:55:58Z", "type": "commit"}, {"oid": "f0ce26d1b840fd90208466a75cf9b7a688b50740", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/f0ce26d1b840fd90208466a75cf9b7a688b50740", "message": "Address comments on SdlSession", "committedDate": "2020-08-04T20:00:42Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTMwMzU0NA==", "url": "https://github.com/smartdevicelink/sdl_java_suite/pull/1426#discussion_r465303544", "bodyText": "I missed this on the first pass, Since we changed it in JavaSE, we should add brackets here as well", "author": "JulianKast", "createdAt": "2020-08-04T20:13:28Z", "path": "android/sdl_android/src/main/java/com/smartdevicelink/SdlConnection/SdlSession.java", "diffHunk": "@@ -1,838 +1,338 @@\n-/*\r\n- * Copyright (c) 2017 - 2019, SmartDeviceLink Consortium, Inc.\r\n- * All rights reserved.\r\n- *\r\n- * Redistribution and use in source and binary forms, with or without\r\n- * modification, are permitted provided that the following conditions are met:\r\n- *\r\n- * Redistributions of source code must retain the above copyright notice, this\r\n- * list of conditions and the following disclaimer.\r\n- *\r\n- * Redistributions in binary form must reproduce the above copyright notice,\r\n- * this list of conditions and the following\r\n- * disclaimer in the documentation and/or other materials provided with the\r\n- * distribution.\r\n- *\r\n- * Neither the name of the SmartDeviceLink Consortium, Inc. nor the names of its\r\n- * contributors may be used to endorse or promote products derived from this \r\n- * software without specific prior written permission.\r\n- *\r\n- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n- * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n- * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n- * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n- * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n- * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n- * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n- * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n- * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n- * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n- * POSSIBILITY OF SUCH DAMAGE.\r\n- */\r\n-package com.smartdevicelink.SdlConnection;\r\n-\r\n-import android.annotation.SuppressLint;\r\n-import android.os.Build;\r\n-import android.view.Surface;\r\n-\r\n-import com.smartdevicelink.encoder.SdlEncoder;\r\n-import com.smartdevicelink.encoder.VirtualDisplayEncoder;\r\n-import com.smartdevicelink.exception.SdlException;\r\n-import com.smartdevicelink.protocol.ProtocolMessage;\r\n-import com.smartdevicelink.protocol.enums.SessionType;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitor;\r\n-import com.smartdevicelink.protocol.heartbeat.IHeartbeatMonitorListener;\r\n-import com.smartdevicelink.proxy.LockScreenManager;\r\n-import com.smartdevicelink.proxy.RPCRequest;\r\n-import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\r\n-import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\r\n-import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\r\n-import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\r\n-import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\r\n-import com.smartdevicelink.security.ISecurityInitializedListener;\r\n-import com.smartdevicelink.security.SdlSecurityBase;\r\n-import com.smartdevicelink.streaming.AbstractPacketizer;\r\n-import com.smartdevicelink.streaming.IStreamListener;\r\n-import com.smartdevicelink.streaming.StreamPacketizer;\r\n-import com.smartdevicelink.streaming.StreamRPCPacketizer;\r\n-import com.smartdevicelink.streaming.video.RTPH264Packetizer;\r\n-import com.smartdevicelink.streaming.video.VideoStreamingParameters;\r\n-import com.smartdevicelink.transport.BaseTransportConfig;\r\n-import com.smartdevicelink.transport.MultiplexTransport;\r\n-import com.smartdevicelink.transport.enums.TransportType;\r\n-import com.smartdevicelink.util.DebugTool;\r\n-import com.smartdevicelink.util.Version;\r\n-\r\n-import java.io.IOException;\r\n-import java.io.InputStream;\r\n-import java.io.OutputStream;\r\n-import java.io.PipedInputStream;\r\n-import java.io.PipedOutputStream;\r\n-import java.util.HashMap;\r\n-import java.util.List;\r\n-import java.util.ListIterator;\r\n-import java.util.concurrent.CopyOnWriteArrayList;\r\n-\r\n-@Deprecated\r\n-public class SdlSession implements ISdlConnectionListener, IHeartbeatMonitorListener, IStreamListener, ISecurityInitializedListener {\r\n-\r\n-   private static final String TAG = \"SdlSession\";\r\n-\r\n-    protected final static int BUFF_READ_SIZE = 1024;\r\n-\r\n-\tprivate static CopyOnWriteArrayList<SdlConnection> shareConnections = new CopyOnWriteArrayList<SdlConnection>();\r\n-\r\n-\tprivate byte wiproProcolVer;\r\n-\r\n-    protected BaseTransportConfig transportConfig;\r\n-    protected ISdlConnectionListener sessionListener;\r\n-\tprotected LockScreenManager lockScreenMan  = new LockScreenManager();\r\n-\tprotected SdlSecurityBase sdlSecurity = null;\r\n-\tprotected VideoStreamingParameters desiredVideoParams = null;\r\n-\tprotected VideoStreamingParameters acceptedVideoParams = null;\r\n-\r\n-\tprotected byte sessionId;\r\n-\tprotected int sessionHashId = 0;\r\n-\tprotected HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> serviceListeners;\r\n-\tprotected CopyOnWriteArrayList<SessionType> encryptedServices = new CopyOnWriteArrayList<SessionType>();\r\n-\r\n-\r\n-\tSdlConnection _sdlConnection = null;\r\n-\r\n-\tIHeartbeatMonitor _outgoingHeartbeatMonitor = null;\r\n-\tIHeartbeatMonitor _incomingHeartbeatMonitor = null;\r\n-\r\n-    StreamRPCPacketizer mRPCPacketizer = null;\r\n-    AbstractPacketizer mVideoPacketizer = null;\r\n-    StreamPacketizer mAudioPacketizer = null;\r\n-    SdlEncoder mSdlEncoder = null;\r\n-    VirtualDisplayEncoder virtualDisplayEncoder = null;\r\n-    boolean sdlSecurityInitializing = false;\r\n-\r\n-    public static SdlSession createSession(byte wiproVersion, ISdlConnectionListener listener, BaseTransportConfig btConfig) {\r\n-\r\n-        SdlSession session =  new SdlSession();\r\n-        session.wiproProcolVer = wiproVersion;\r\n-        session.sessionListener = listener;\r\n-        session.transportConfig = btConfig;\r\n-\r\n-        return session;\r\n-    }\r\n-\r\n-    public BaseTransportConfig getTransportConfig() {\r\n-        return this.transportConfig;\r\n-    }\r\n-\r\n-    public LockScreenManager getLockScreenMan() {\r\n-        return lockScreenMan;\r\n-    }\r\n-\r\n-\r\n-    public IHeartbeatMonitor getOutgoingHeartbeatMonitor() {\r\n-        return _outgoingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public IHeartbeatMonitor getIncomingHeartbeatMonitor() {\r\n-        return _incomingHeartbeatMonitor;\r\n-    }\r\n-\r\n-    public void setOutgoingHeartbeatMonitor(IHeartbeatMonitor outgoingHeartbeatMonitor) {\r\n-        this._outgoingHeartbeatMonitor = outgoingHeartbeatMonitor;\r\n-        _outgoingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public void setIncomingHeartbeatMonitor(IHeartbeatMonitor incomingHeartbeatMonitor) {\r\n-        this._incomingHeartbeatMonitor = incomingHeartbeatMonitor;\r\n-        _incomingHeartbeatMonitor.setListener(this);\r\n-    }\r\n-\r\n-    public int getSessionHashId() {\r\n-        return this.sessionHashId;\r\n-    }\r\n-\r\n-    public byte getSessionId() {\r\n-        return this.sessionId;\r\n-    }\r\n-\r\n-    public SdlConnection getSdlConnection() {\r\n-        return this._sdlConnection;\r\n-    }\r\n-\r\n-    public int getMtu(){\r\n-        if(this._sdlConnection!=null){\r\n-            return this._sdlConnection.getWiProProtocol().getMtu();\r\n-        }else{\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public long getMtu(SessionType type) {\r\n-        if (this._sdlConnection != null) {\r\n-            return this._sdlConnection.getWiProProtocol().getMtu(type);\r\n-        } else {\r\n-            return 0;\r\n-        }\r\n-    }\r\n-\r\n-    public void close() {\r\n-        if (sdlSecurity != null)\r\n-        {\r\n-            sdlSecurity.resetParams();\r\n-            sdlSecurity.shutDown();\r\n-        }\r\n-\r\n-        if (_sdlConnection != null) { //sessionId == 0 means session is not started.\r\n-            //_sdlConnection.unregisterSession(this);\r\n-\r\n-            if (_sdlConnection.getRegisterCount() == 0) {\r\n-                shareConnections.remove(_sdlConnection);\r\n-            }\r\n-\r\n-            _sdlConnection = null;\r\n-        }\r\n-    }\r\n-\r\n-    public void resetSession(){\r\n-\r\n-    }\r\n-\r\n-    public void startStream(InputStream is, SessionType sType, byte rpcSessionID) throws IOException {\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-    }\r\n-\r\n-    @SuppressLint(\"NewApi\")\r\n-    public OutputStream startStream(SessionType sType, byte rpcSessionID) throws IOException {\r\n-        OutputStream os = new PipedOutputStream();\r\n-        InputStream is = null;\r\n-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.GINGERBREAD) {\r\n-            is = new PipedInputStream((PipedOutputStream) os, BUFF_READ_SIZE);\r\n-        } else {\r\n-            is = new PipedInputStream((PipedOutputStream) os);\r\n-        }\r\n-        if (sType.equals(SessionType.NAV))\r\n-        {\r\n-            // protocol is fixed to RAW\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mVideoPacketizer = packetizer;\r\n-            mVideoPacketizer.start();\r\n-        }\r\n-        else if (sType.equals(SessionType.PCM))\r\n-        {\r\n-            mAudioPacketizer = new StreamPacketizer(this, is, sType, rpcSessionID, this);\r\n-            mAudioPacketizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer.start();\r\n-        }\r\n-        else\r\n-        {\r\n-            os.close();\r\n-            is.close();\r\n-            return null;\r\n-        }\r\n-        return os;\r\n-    }\r\n-\r\n-    public IVideoStreamListener startVideoStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        VideoStreamingProtocol protocol = getAcceptedProtocol();\r\n-        try {\r\n-            switch (protocol) {\r\n-                case RAW: {\r\n-                    StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.NAV, rpcSessionID, this);\r\n-                    packetizer.sdlConnection = this.getSdlConnection();\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                case RTP: {\r\n-                    RTPH264Packetizer packetizer = new RTPH264Packetizer(this, SessionType.NAV, rpcSessionID, this);\r\n-                    mVideoPacketizer = packetizer;\r\n-                    mVideoPacketizer.start();\r\n-                    return packetizer;\r\n-                }\r\n-                default:\r\n-                    DebugTool.logError(TAG, \"Protocol \" + protocol + \" is not supported.\");\r\n-                    return null;\r\n-            }\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    public IAudioStreamListener startAudioStream() {\r\n-        byte rpcSessionID = getSessionId();\r\n-        try {\r\n-            StreamPacketizer packetizer = new StreamPacketizer(this, null, SessionType.PCM, rpcSessionID, this);\r\n-            packetizer.sdlConnection = this.getSdlConnection();\r\n-            mAudioPacketizer = packetizer;\r\n-            mAudioPacketizer.start();\r\n-            return packetizer;\r\n-        } catch (IOException e) {\r\n-            return null;\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void startRPCStream(InputStream is, RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public OutputStream startRPCStream(RPCRequest request, SessionType sType, byte rpcSessionID, byte wiproVersion) {\r\n-        try {\r\n-            OutputStream os = new PipedOutputStream();\r\n-            InputStream is = new PipedInputStream((PipedOutputStream) os);\r\n-            mRPCPacketizer = new StreamRPCPacketizer(null, this, is, request, sType, rpcSessionID, wiproVersion, 0, this);\r\n-            mRPCPacketizer.start();\r\n-            return os;\r\n-        } catch (Exception e) {\r\n-            DebugTool.logError(TAG, \"Unable to start streaming:\" + e.toString());\r\n-        }\r\n-        return null;\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void pauseRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.pause();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void resumeRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.resume();\r\n-        }\r\n-    }\r\n-\r\n-    @Deprecated\r\n-    public void stopRPCStream()\r\n-    {\r\n-        if (mRPCPacketizer != null)\r\n-        {\r\n-            mRPCPacketizer.stop();\r\n-        }\r\n-    }\r\n-\r\n-    public boolean stopAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean stopVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.stop();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean pauseVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.pause();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeAudioStream()\r\n-    {\r\n-        if (mAudioPacketizer != null)\r\n-        {\r\n-            mAudioPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public boolean resumeVideoStream()\r\n-    {\r\n-        if (mVideoPacketizer != null)\r\n-        {\r\n-            mVideoPacketizer.resume();\r\n-            return true;\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-    public Surface createOpenGLInputSurface(int frameRate, int iFrameInterval, int width,\r\n-                                            int height, int bitrate, SessionType sType, byte rpcSessionID) {\r\n-        IVideoStreamListener encoderListener = startVideoStream();\r\n-        if (encoderListener == null) {\r\n-            return null;\r\n-        }\r\n-\r\n-        mSdlEncoder = new SdlEncoder();\r\n-        mSdlEncoder.setFrameRate(frameRate);\r\n-        mSdlEncoder.setFrameInterval(iFrameInterval);\r\n-        mSdlEncoder.setFrameWidth(width);\r\n-        mSdlEncoder.setFrameHeight(height);\r\n-        mSdlEncoder.setBitrate(bitrate);\r\n-        mSdlEncoder.setOutputListener(encoderListener);\r\n-        return mSdlEncoder.prepareEncoder();\r\n-    }\r\n-\r\n-    public void startEncoder () {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.startEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void releaseEncoder() {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.releaseEncoder();\r\n-        }\r\n-    }\r\n-\r\n-    public void drainEncoder(boolean endOfStream) {\r\n-        if(mSdlEncoder != null) {\r\n-            mSdlEncoder.drainEncoder(endOfStream);\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendStreamPacket(ProtocolMessage pm) {\r\n-        sendMessage(pm);\r\n-    }\r\n-\r\n-    public void setSdlSecurity(SdlSecurityBase sec) {\r\n-        sdlSecurity = sec;\r\n-    }\r\n-\r\n-    public SdlSecurityBase getSdlSecurity() {\r\n-        return sdlSecurity;\r\n-    }\r\n-\r\n-    public void startService (SessionType serviceType, byte sessionID, boolean isEncrypted) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-\r\n-        if (isEncrypted)\r\n-        {\r\n-            if (sdlSecurity != null)\r\n-            {\r\n-                List<SessionType> serviceList = sdlSecurity.getServiceList();\r\n-                if (!serviceList.contains(serviceType))\r\n-                    serviceList.add(serviceType);\r\n-\r\n-                if (!sdlSecurityInitializing) {\r\n-                    sdlSecurityInitializing = true;\r\n-                    sdlSecurity.initialize();\r\n-                    return;\r\n-                }\r\n-            }\r\n-        }\r\n-        _sdlConnection.startService(serviceType, sessionID, isEncrypted);\r\n-    }\r\n-\r\n-    public void endService (SessionType serviceType, byte sessionID) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.endService(serviceType, sessionID);\r\n-    }\r\n-\r\n-    protected void processControlService(ProtocolMessage msg) {\r\n-        if (sdlSecurity == null)\r\n-            return;\r\n-        int ilen = msg.getData().length - 12;\r\n-        byte[] data = new byte[ilen];\r\n-        System.arraycopy(msg.getData(), 12, data, 0, ilen);\r\n-\r\n-        byte[] dataToRead = new byte[4096];\r\n-\r\n-        Integer iNumBytes = sdlSecurity.runHandshake(data, dataToRead);\r\n-\r\n-        if (iNumBytes == null || iNumBytes <= 0)\r\n-            return;\r\n-\r\n-        byte[] returnBytes = new byte[iNumBytes];\r\n-        System.arraycopy(dataToRead, 0, returnBytes, 0, iNumBytes);\r\n-        ProtocolMessage protocolMessage = new ProtocolMessage();\r\n-        protocolMessage.setSessionType(SessionType.CONTROL);\r\n-        protocolMessage.setData(returnBytes);\r\n-        protocolMessage.setFunctionID(0x01);\r\n-        protocolMessage.setVersion(wiproProcolVer);\r\n-        protocolMessage.setSessionID(getSessionId());\r\n-\r\n-        //sdlSecurity.hs();\r\n-\r\n-        sendMessage(protocolMessage);\r\n-    }\r\n-\r\n-    public String getBroadcastComment(BaseTransportConfig myTransport) {\r\n-        SdlConnection connection = null;\r\n-        if (myTransport.shareConnection()) {\r\n-            connection = findTheProperConnection(myTransport);\r\n-        } else {\r\n-            connection = this._sdlConnection;\r\n-        }\r\n-\r\n-        if (connection != null)\r\n-            return connection.getBroadcastComment();\r\n-\r\n-        return \"\";\r\n-    }\r\n-\r\n-\r\n-    public void startSession() throws SdlException {\r\n-        SdlConnection connection = null;\r\n-        if (this.transportConfig.shareConnection()) {\r\n-            connection = findTheProperConnection(this.transportConfig);\r\n-\r\n-            if (connection == null) {\r\n-                connection = new SdlConnection(this.transportConfig);\r\n-                shareConnections.add(connection);\r\n-            }\r\n-        } else {\r\n-            connection = new SdlConnection(this.transportConfig);\r\n-        }\r\n-\r\n-        this._sdlConnection = connection;\r\n-        connection.registerSession(this); //Handshake will start when register.\r\n-    }\r\n-\r\n-    protected void initialiseSession() {\r\n-        if (_outgoingHeartbeatMonitor != null) {\r\n-            _outgoingHeartbeatMonitor.start();\r\n-        }\r\n-        if (_incomingHeartbeatMonitor != null) {\r\n-            _incomingHeartbeatMonitor.start();\r\n-        }\r\n-    }\r\n-\r\n-    public void sendMessage(ProtocolMessage msg) {\r\n-        if (_sdlConnection == null)\r\n-            return;\r\n-        _sdlConnection.sendMessage(msg);\r\n-    }\r\n-\r\n-    public TransportType getCurrentTransportType() {\r\n-        if (_sdlConnection == null)\r\n-            return null;\r\n-        return _sdlConnection.getCurrentTransportType();\r\n-    }\r\n-\r\n-    public boolean getIsConnected() {\r\n-        if (_sdlConnection == null)\r\n-            return false;\r\n-        return _sdlConnection != null && _sdlConnection.getIsConnected();\r\n-    }\r\n-\r\n-    public boolean isServiceProtected(SessionType sType) {\r\n-        return encryptedServices.contains(sType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportDisconnected(String info, boolean availablePrimary, BaseTransportConfig transportConfig) {\r\n-        this.sessionListener.onTransportDisconnected(info);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onTransportError(String info, Exception e) {\r\n-        this.sessionListener.onTransportError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolMessageReceived(ProtocolMessage msg) {\r\n-        if (msg.getSessionType().equals(SessionType.CONTROL)) {\r\n-            processControlService(msg);\r\n-            return;\r\n-        }\r\n-\r\n-        this.sessionListener.onProtocolMessageReceived(msg);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onHeartbeatTimedOut(byte sessionID) {\r\n-        this.sessionListener.onHeartbeatTimedOut(sessionID);\r\n-\r\n-    }\r\n-\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStarted(SessionType sessionType,\r\n-                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\r\n-        this.sessionId = sessionID;\r\n-        lockScreenMan.setSessionID(sessionID);\r\n-        if (sessionType.eq(SessionType.RPC)){\r\n-            sessionHashId = hashID;\r\n-            wiproProcolVer = version;\r\n-        }\r\n-        if (isEncrypted)\r\n-            encryptedServices.addIfAbsent(sessionType);\r\n-        this.sessionListener.onProtocolSessionStarted(sessionType, sessionID, version, correlationID, hashID, isEncrypted);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceStarted(this, sessionType, isEncrypted);\r\n-            }\r\n-        }\r\n-        //if (version == 3)\r\n-        initialiseSession();\r\n-\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEnded(SessionType sessionType, byte sessionID,\r\n-                                       String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEnded(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceEnded(this, sessionType);\r\n-            }\r\n-        }\r\n-        encryptedServices.remove(sessionType);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolError(String info, Exception e) {\r\n-        this.sessionListener.onProtocolError(info, e);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void sendHeartbeat(IHeartbeatMonitor monitor) {\r\n-        DebugTool.logInfo(TAG, \"Asked to send heartbeat\");\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection.sendHeartbeat(this);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void heartbeatTimedOut(IHeartbeatMonitor monitor) {\r\n-        if (_sdlConnection != null)\r\n-            _sdlConnection._connectionListener.onHeartbeatTimedOut(this.sessionId);\r\n-        close();\r\n-    }\r\n-\r\n-    private static SdlConnection findTheProperConnection(BaseTransportConfig config) {\r\n-        SdlConnection connection = null;\r\n-\r\n-        int minCount = 0;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == config.getTransportType()) {\r\n-                if (minCount == 0 || minCount >= c.getRegisterCount()) {\r\n-                    connection = c;\r\n-                    minCount = c.getRegisterCount();\r\n-                }\r\n-            }\r\n-        }\r\n-\r\n-        return connection;\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionStartedNACKed(SessionType sessionType,\r\n-                                               byte sessionID, byte version, String correlationID, List<String> rejectedParams) {\r\n-        this.sessionListener.onProtocolSessionStartedNACKed(sessionType,\r\n-                sessionID, version, correlationID, rejectedParams);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"Start \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolSessionEndedNACKed(SessionType sessionType,\r\n-                                             byte sessionID, String correlationID) {\r\n-        this.sessionListener.onProtocolSessionEndedNACKed(sessionType, sessionID, correlationID);\r\n-        if(serviceListeners != null && serviceListeners.containsKey(sessionType)){\r\n-            CopyOnWriteArrayList<ISdlServiceListener> listeners = serviceListeners.get(sessionType);\r\n-            for(ISdlServiceListener listener:listeners){\r\n-                listener.onServiceError(this, sessionType, \"End \"+ sessionType.toString() +\" Service NACK'ed\");\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onProtocolServiceDataACK(SessionType sessionType, int dataSize, byte sessionID) {\r\n-        this.sessionListener.onProtocolServiceDataACK(sessionType, dataSize, sessionID);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onAuthTokenReceived(String authToken, byte sessionId) {\r\n-        this.sessionListener.onAuthTokenReceived(authToken, sessionId);\r\n-    }\r\n-\r\n-    @Override\r\n-    public void onSecurityInitialized() {\r\n-\r\n-        if (_sdlConnection != null && sdlSecurity != null)\r\n-        {\r\n-            List<SessionType> list = sdlSecurity.getServiceList();\r\n-\r\n-            SessionType service;\r\n-            ListIterator<SessionType> iter = list.listIterator();\r\n-\r\n-            while (iter.hasNext()) {\r\n-                service = iter.next();\r\n-\r\n-                if (service != null)\r\n-                    _sdlConnection.startService(service, getSessionId(), true);\r\n-\r\n-                iter.remove();\r\n-            }\r\n-        }\r\n-    }\r\n-\r\n-    public void clearConnection(){\r\n-        _sdlConnection = null;\r\n-    }\r\n-\r\n-    public void checkForOpenMultiplexConnection(SdlConnection connection){\r\n-        removeConnection(connection);\r\n-        connection.unregisterSession(this);\r\n-        _sdlConnection = null;\r\n-        for (SdlConnection c : shareConnections) {\r\n-            if (c.getCurrentTransportType() == TransportType.MULTIPLEX) {\r\n-                if(c.getIsConnected() || ((MultiplexTransport)c._transport).isPendingConnected()){\r\n-                    _sdlConnection = c;\r\n-                    try {\r\n-                        _sdlConnection.registerSession(this);//Handshake will start when register.\r\n-                    } catch (SdlException e) {\r\n-                        e.printStackTrace();\r\n-                    }\r\n-                    return;\r\n-                }\r\n-\r\n-            }\r\n-        }\r\n-    }\r\n-    public static boolean removeConnection(SdlConnection connection){\r\n-        return shareConnections.remove(connection);\r\n-    }\r\n-\r\n-    public void addServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners == null){\r\n-            serviceListeners = new HashMap<>();\r\n-        }\r\n-        if(serviceType != null && sdlServiceListener != null){\r\n-            if(!serviceListeners.containsKey(serviceType)){\r\n-                serviceListeners.put(serviceType,new CopyOnWriteArrayList<ISdlServiceListener>());\r\n-            }\r\n-            serviceListeners.get(serviceType).add(sdlServiceListener);\r\n-        }\r\n-    }\r\n-\r\n-    public boolean removeServiceListener(SessionType serviceType, ISdlServiceListener sdlServiceListener){\r\n-        if(serviceListeners!= null && serviceType != null && sdlServiceListener != null && serviceListeners.containsKey(serviceType)){\r\n-            return serviceListeners.get(serviceType).remove(sdlServiceListener);\r\n-        }\r\n-        return false;\r\n-    }\r\n-\r\n-\r\n-    public HashMap<SessionType, CopyOnWriteArrayList<ISdlServiceListener>> getServiceListeners(){\r\n-        return serviceListeners;\r\n-    }\r\n-\r\n-    public void setDesiredVideoParams(VideoStreamingParameters params){\r\n-        this.desiredVideoParams = params;\r\n-    }\r\n-\r\n-    /**\r\n-     * Returns the currently set desired video streaming parameters. If there haven't been any set,\r\n-     * the default options will be returned and set for this instance.\r\n-     * @return\r\n-     */\r\n-    public VideoStreamingParameters getDesiredVideoParams(){\r\n-        if(desiredVideoParams == null){\r\n-            desiredVideoParams = new VideoStreamingParameters();\r\n-        }\r\n-        return desiredVideoParams;\r\n-    }\r\n-\r\n-    public void setAcceptedVideoParams(VideoStreamingParameters params){\r\n-        this.acceptedVideoParams = params;\r\n-    }\r\n-\r\n-    public VideoStreamingParameters getAcceptedVideoParams(){\r\n-        return acceptedVideoParams;\r\n-    }\r\n-\r\n-    private VideoStreamingProtocol getAcceptedProtocol() {\r\n-        // acquire default protocol (RAW)\r\n-        VideoStreamingProtocol protocol = new VideoStreamingParameters().getFormat().getProtocol();\r\n-\r\n-        if (acceptedVideoParams != null) {\r\n-            VideoStreamingFormat format = acceptedVideoParams.getFormat();\r\n-            if (format != null && format.getProtocol() != null) {\r\n-                protocol = format.getProtocol();\r\n-            }\r\n-        }\r\n-\r\n-        return protocol;\r\n-    }\r\n-\r\n-    public Version getProtocolVersion(){\r\n-        //Since this session version never supported a minor protocol version this should be fine\r\n-        return new Version(wiproProcolVer,0,0);\r\n-    }\r\n-\r\n-    /**\r\n-     * Check to see if a transport is available to start/use the supplied service.\r\n-     * @param sessionType the session that should be checked for transport availability\r\n-     * @return true if there is either a supported\r\n-     *         transport currently connected or a transport is\r\n-     *         available to connect with for the supplied service type.\r\n-     *         <br>false if there is no\r\n-     *         transport connected to support the service type in question and\r\n-     *          no possibility in the foreseeable future.\r\n-     */\r\n-    public boolean isTransportForServiceAvailable(SessionType sessionType){\r\n-        return _sdlConnection!= null\r\n-                && _sdlConnection._transport!= null\r\n-                && _sdlConnection._transport.getIsConnected()\r\n-                && ((sessionType == SessionType.RPC || sessionType == SessionType.CONTROL || sessionType == SessionType.BULK_DATA ) //If this is a service that can run on any transport just return true\r\n-                    || (_sdlConnection._transport.getTransportType() == TransportType.USB || _sdlConnection._transport.getTransportType() == TransportType.TCP));\r\n-    }\r\n-\r\n-\r\n-}\n\\ No newline at end of file\n+/*\n+ * Copyright (c) 2017-2020 Livio, Inc.\n+ * All rights reserved.\n+ *\n+ * Redistribution and use in source and binary forms, with or without\n+ * modification, are permitted provided that the following conditions are met:\n+ *\n+ * Redistributions of source code must retain the above copyright notice, this\n+ * list of conditions and the following disclaimer.\n+ *\n+ * Redistributions in binary form must reproduce the above copyright notice,\n+ * this list of conditions and the following\n+ * disclaimer in the documentation and/or other materials provided with the\n+ * distribution.\n+ *\n+ * Neither the name of the Livio Inc. nor the names of its contributors\n+ * may be used to endorse or promote products derived from this software\n+ * without specific prior written permission.\n+ *\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\n+ * POSSIBILITY OF SUCH DAMAGE.\n+ */\n+\n+package com.smartdevicelink.SdlConnection;\n+\n+import android.content.Context;\n+\n+import com.smartdevicelink.exception.SdlException;\n+import com.smartdevicelink.protocol.ProtocolMessage;\n+import com.smartdevicelink.protocol.SdlPacket;\n+import com.smartdevicelink.protocol.SdlProtocol;\n+import com.smartdevicelink.protocol.SdlProtocolBase;\n+import com.smartdevicelink.protocol.enums.SessionType;\n+import com.smartdevicelink.proxy.interfaces.IAudioStreamListener;\n+import com.smartdevicelink.proxy.interfaces.ISdlServiceListener;\n+import com.smartdevicelink.proxy.interfaces.IVideoStreamListener;\n+import com.smartdevicelink.proxy.rpc.VideoStreamingFormat;\n+import com.smartdevicelink.proxy.rpc.enums.VideoStreamingProtocol;\n+import com.smartdevicelink.streaming.AbstractPacketizer;\n+import com.smartdevicelink.streaming.IStreamListener;\n+import com.smartdevicelink.streaming.StreamPacketizer;\n+import com.smartdevicelink.streaming.video.RTPH264Packetizer;\n+import com.smartdevicelink.streaming.video.VideoStreamingParameters;\n+import com.smartdevicelink.transport.MultiplexTransportConfig;\n+import com.smartdevicelink.transport.TCPTransportConfig;\n+import com.smartdevicelink.transport.enums.TransportType;\n+import com.smartdevicelink.util.DebugTool;\n+import com.smartdevicelink.util.MediaStreamingStatus;\n+import com.smartdevicelink.util.Version;\n+\n+import java.io.IOException;\n+import java.lang.ref.WeakReference;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+public class SdlSession extends BaseSdlSession {\n+    private static final String TAG = \"SdlSession\";\n+\n+    WeakReference<Context> contextWeakReference;\n+    MediaStreamingStatus mediaStreamingStatus;\n+    boolean requiresAudioSupport = false;\n+\n+    public SdlSession(ISdlConnectionListener listener, MultiplexTransportConfig config) {\n+        super(listener, config);\n+        this.transportConfig = config;\n+        if (config != null) {\n+            contextWeakReference = new WeakReference<>(config.getContext());\n+            this.requiresAudioSupport = Boolean.TRUE.equals(config.requiresAudioSupport()); //handle null case\n+\n+        }\n+        this.sessionListener = listener;\n+\n+    }\n+\n+    public SdlSession(ISdlConnectionListener listener, TCPTransportConfig config) {\n+        super(listener, config);\n+        this.transportConfig = config;\n+        this.sessionListener = listener;\n+    }\n+\n+    protected SdlProtocolBase getSdlProtocolImplementation() {\n+        if (transportConfig instanceof MultiplexTransportConfig) {\n+            return new SdlProtocol(this, (MultiplexTransportConfig) transportConfig);\n+        } else if (transportConfig instanceof TCPTransportConfig) {\n+            return new SdlProtocol(this, (TCPTransportConfig) transportConfig);\n+        }\n+\n+        return null;\n+    }\n+\n+    boolean isAudioRequirementMet() {\n+        if (mediaStreamingStatus == null && contextWeakReference != null && contextWeakReference.get() != null) {\n+            mediaStreamingStatus = new MediaStreamingStatus(contextWeakReference.get(), new MediaStreamingStatus.Callback() {\n+                @Override\n+                public void onAudioNoLongerAvailable() {\n+                    close();\n+                    shutdown(\"Audio output no longer available\");\n+                }\n+            });\n+        }\n+\n+        // If requiresAudioSupport is false, or a supported audio output device is available\n+        return !requiresAudioSupport || mediaStreamingStatus.isAudioOutputAvailable();\n+\n+    }\n+\n+\n+    @SuppressWarnings(\"RedundantThrows\")\n+    @Override\n+    public void startSession() throws SdlException {\n+        if (!isAudioRequirementMet()) {\n+            shutdown(\"Audio output not available\");\n+            return;\n+        }\n+\n+        sdlProtocol.start();\n+    }\n+\n+    @Override\n+    public TransportType getCurrentTransportType() {\n+        return TransportType.MULTIPLEX;\n+    }\n+\n+    @Override\n+    public void shutdown(String info) {\n+        DebugTool.logInfo(TAG, \"Shutdown - \" + info);\n+        if (mediaStreamingStatus != null) {\n+            mediaStreamingStatus.clear();\n+        }\n+        super.shutdown(info);\n+\n+    }\n+\n+    /**\n+     * Get the current protocol version used by this session\n+     *\n+     * @return Version that represents the Protocol version being used\n+     */\n+    @Override\n+    public Version getProtocolVersion() {\n+        if (sdlProtocol != null) {\n+            return sdlProtocol.getProtocolVersion();\n+        }\n+        return new Version(1, 0, 0);\n+    }\n+\n+\n+    /* ***********************************************************************************************************************************************************************\n+     * *****************************************************************  IProtocol Listener  ********************************************************************************\n+     *************************************************************************************************************************************************************************/\n+\n+    @Override\n+    public void onProtocolMessageBytesToSend(SdlPacket packet) {\n+        sdlProtocol.sendPacket(packet);\n+    }\n+\n+    @Override\n+    public void onProtocolSessionStarted(SessionType sessionType,\n+                                         byte sessionID, byte version, String correlationID, int hashID, boolean isEncrypted) {\n+\n+        DebugTool.logInfo(TAG, \"Protocol session started\");\n+\n+        this.sessionId = sessionID;\n+        if (sessionType.eq(SessionType.RPC)) {\n+            sessionHashId = hashID;\n+        }\n+        if (isEncrypted)", "originalCommit": "f0ce26d1b840fd90208466a75cf9b7a688b50740", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8423c0782778a7a02e7370e13d10a6ba9240db1e", "url": "https://github.com/smartdevicelink/sdl_java_suite/commit/8423c0782778a7a02e7370e13d10a6ba9240db1e", "message": "Add brackets to singlel ine if", "committedDate": "2020-08-04T20:23:22Z", "type": "commit"}]}