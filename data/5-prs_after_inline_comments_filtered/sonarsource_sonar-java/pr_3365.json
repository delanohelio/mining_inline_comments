{"pr_number": 3365, "pr_title": "SONARJAVA-3480 S5917: DateTimeFormatters should not use mismatched year and week numbers", "pr_createdAt": "2020-12-24T14:25:47Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/3365", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI3MTA3Ng==", "url": "https://github.com/SonarSource/sonar-java/pull/3365#discussion_r549271076", "bodyText": "For completeness, we could add 2 tests for ofPattern: one where the argument is not a string literal, and another where the pattern does not contain any of the character we're looking for", "author": "christophe-zurn-sonarsource", "createdAt": "2020-12-28T09:06:29Z", "path": "java-checks-test-sources/src/main/java/checks/DateTimeFormatterMismatch.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package checks;\n+\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeFormatterBuilder;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.WeekFields;\n+import java.util.Locale;\n+\n+public class DateTimeFormatterMismatch {\n+  public void createUsingPatterns() {\n+    DateTimeFormatter.ofPattern(\"Y-ww\"); // Compliant\n+    DateTimeFormatter.ofPattern(\"YY-ww\"); // Compliant", "originalCommit": "0eea7ccc802d7c40291044097a5927a4cf2baa8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI3MjA3MQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3365#discussion_r549272071", "bodyText": "RSPEC message in that case is Change this year format to use ChronoField.YEAR instead. Is there a reason why the message here is different ? I think the message from RSPEC makes more sense following the primary and secondary locations that we want to highlight", "author": "christophe-zurn-sonarsource", "createdAt": "2020-12-28T09:09:43Z", "path": "java-checks/src/main/java/org/sonar/java/checks/DateTimeFormatterMismatchCheck.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.tree.Arguments;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+\n+@Rule(key = \"S5917\")\n+public class DateTimeFormatterMismatchCheck extends IssuableSubscriptionVisitor {\n+  private static final MethodMatchers OF_PATTERN_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatter\")\n+    .names(\"ofPattern\")\n+    .addParametersMatcher(\"java.lang.String\")\n+    .addParametersMatcher(\"java.lang.String\", \"java.util.Locale\")\n+    .build();\n+\n+  private static final MethodMatchers APPEND_VALUE_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatterBuilder\")\n+    .names(\"appendValue\")\n+    .addParametersMatcher(\"java.time.temporal.TemporalField\", \"int\")\n+    .build();\n+\n+  private static final MethodMatchers DATE_TIME_FORMATTER_BUILDER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatterBuilder\")\n+    .names(\"toFormatter\")\n+    .addParametersMatcher()\n+    .build();\n+\n+  private static final Pattern WEEK_PATTERN = Pattern.compile(\".*ww{1,2}.*\");\n+  private static final Pattern YEAR_OF_ERA_PATTERN = Pattern.compile(\".*[uy]+.*\");\n+\n+  private static final String CHANGE_WEEK_FORMAT_MESSAGE = \"Change this week format to use the week of week-based year instead.\";", "originalCommit": "0eea7ccc802d7c40291044097a5927a4cf2baa8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI3NzU5NQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3365#discussion_r549277595", "bodyText": "Why do we want to check the last expression type here ? We could also try to catch the following cases:\nDateTimeFormatterBuilder builder = new DateTimeFormatterBuilder();\nreturn builder.appendValue(WeekFields.ISO.weekBasedYear(), 4) // Noncompliant\n      .appendLiteral('-')\n      .appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR, 2)\n      .toFormatter();", "author": "christophe-zurn-sonarsource", "createdAt": "2020-12-28T09:26:38Z", "path": "java-checks/src/main/java/org/sonar/java/checks/DateTimeFormatterMismatchCheck.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.tree.Arguments;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+\n+@Rule(key = \"S5917\")\n+public class DateTimeFormatterMismatchCheck extends IssuableSubscriptionVisitor {\n+  private static final MethodMatchers OF_PATTERN_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatter\")\n+    .names(\"ofPattern\")\n+    .addParametersMatcher(\"java.lang.String\")\n+    .addParametersMatcher(\"java.lang.String\", \"java.util.Locale\")\n+    .build();\n+\n+  private static final MethodMatchers APPEND_VALUE_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatterBuilder\")\n+    .names(\"appendValue\")\n+    .addParametersMatcher(\"java.time.temporal.TemporalField\", \"int\")\n+    .build();\n+\n+  private static final MethodMatchers DATE_TIME_FORMATTER_BUILDER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatterBuilder\")\n+    .names(\"toFormatter\")\n+    .addParametersMatcher()\n+    .build();\n+\n+  private static final Pattern WEEK_PATTERN = Pattern.compile(\".*ww{1,2}.*\");\n+  private static final Pattern YEAR_OF_ERA_PATTERN = Pattern.compile(\".*[uy]+.*\");\n+\n+  private static final String CHANGE_WEEK_FORMAT_MESSAGE = \"Change this week format to use the week of week-based year instead.\";\n+  private static final String CHANGE_YEAR_FORMAT_MESSAGE = \"Change this year format to use the week-based year instead.\";\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    MethodInvocationTree invocation = (MethodInvocationTree) tree;\n+    if (OF_PATTERN_MATCHER.matches(invocation)) {\n+      visitPattern(invocation);\n+    } else if (DATE_TIME_FORMATTER_BUILDER.matches(invocation)) {\n+      visitBuildChain(invocation);\n+    }\n+  }\n+\n+  private void visitPattern(MethodInvocationTree invocation) {\n+    Arguments arguments = invocation.arguments();\n+    ExpressionTree argument = arguments.get(0);\n+    if (argument.is(Tree.Kind.STRING_LITERAL)) {\n+      String pattern = ((LiteralTree) argument).value();\n+      if (WEEK_PATTERN.matcher(pattern).matches() && YEAR_OF_ERA_PATTERN.matcher(pattern).matches()) {\n+        reportIssue(invocation, CHANGE_YEAR_FORMAT_MESSAGE);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Walking back through an invocation chain from a call to DateTimeFormatterBuilder.toFormatter looking for calls to appendValue.\n+   * If conflicting week and year settings are detected, an issue is reported\n+   * @param invocation A call to DateTimeFormatterBuilder.toFormatter\n+   */\n+  private void visitBuildChain(MethodInvocationTree invocation) {\n+    boolean usesWeekBasedYear = false;\n+    boolean usesWeekOfWeekBasedYear = false;\n+    Tree wanderer = invocation.methodSelect();\n+    while (wanderer != null && wanderer.is(Tree.Kind.MEMBER_SELECT)) {\n+      ExpressionTree expression = ((MemberSelectExpressionTree) wanderer).expression();\n+      if (!expression.is(Tree.Kind.METHOD_INVOCATION)) {\n+        break;\n+      }\n+      MethodInvocationTree mit = (MethodInvocationTree) expression;\n+      if (APPEND_VALUE_MATCHER.matches(mit)) {\n+        usesWeekBasedYear |= isWeekBasedYearUsed(mit);\n+        usesWeekOfWeekBasedYear |= isWeekOfWeekBasedYearUsed(mit);\n+      }\n+      wanderer = mit.methodSelect();\n+    }\n+    if (wanderer == null) {\n+      return;\n+    }\n+    ExpressionTree lastExpression = ((MemberSelectExpressionTree) wanderer).expression();\n+    if (!lastExpression.is(Tree.Kind.NEW_CLASS)) {\n+      return;\n+    }", "originalCommit": "0eea7ccc802d7c40291044097a5927a4cf2baa8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI3ODQ5MQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3365#discussion_r549278491", "bodyText": "From the RSPEC, I believe the tree we want to report the issue on is not the toFormatter method invocation, but the appendValue on which we have the year, with secondary location being the appendValue invocation on which the weeks are appended.", "author": "christophe-zurn-sonarsource", "createdAt": "2020-12-28T09:29:36Z", "path": "java-checks/src/main/java/org/sonar/java/checks/DateTimeFormatterMismatchCheck.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.tree.Arguments;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+\n+@Rule(key = \"S5917\")\n+public class DateTimeFormatterMismatchCheck extends IssuableSubscriptionVisitor {\n+  private static final MethodMatchers OF_PATTERN_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatter\")\n+    .names(\"ofPattern\")\n+    .addParametersMatcher(\"java.lang.String\")\n+    .addParametersMatcher(\"java.lang.String\", \"java.util.Locale\")\n+    .build();\n+\n+  private static final MethodMatchers APPEND_VALUE_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatterBuilder\")\n+    .names(\"appendValue\")\n+    .addParametersMatcher(\"java.time.temporal.TemporalField\", \"int\")\n+    .build();\n+\n+  private static final MethodMatchers DATE_TIME_FORMATTER_BUILDER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatterBuilder\")\n+    .names(\"toFormatter\")\n+    .addParametersMatcher()\n+    .build();\n+\n+  private static final Pattern WEEK_PATTERN = Pattern.compile(\".*ww{1,2}.*\");\n+  private static final Pattern YEAR_OF_ERA_PATTERN = Pattern.compile(\".*[uy]+.*\");\n+\n+  private static final String CHANGE_WEEK_FORMAT_MESSAGE = \"Change this week format to use the week of week-based year instead.\";\n+  private static final String CHANGE_YEAR_FORMAT_MESSAGE = \"Change this year format to use the week-based year instead.\";\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    MethodInvocationTree invocation = (MethodInvocationTree) tree;\n+    if (OF_PATTERN_MATCHER.matches(invocation)) {\n+      visitPattern(invocation);\n+    } else if (DATE_TIME_FORMATTER_BUILDER.matches(invocation)) {\n+      visitBuildChain(invocation);\n+    }\n+  }\n+\n+  private void visitPattern(MethodInvocationTree invocation) {\n+    Arguments arguments = invocation.arguments();\n+    ExpressionTree argument = arguments.get(0);\n+    if (argument.is(Tree.Kind.STRING_LITERAL)) {\n+      String pattern = ((LiteralTree) argument).value();\n+      if (WEEK_PATTERN.matcher(pattern).matches() && YEAR_OF_ERA_PATTERN.matcher(pattern).matches()) {\n+        reportIssue(invocation, CHANGE_YEAR_FORMAT_MESSAGE);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Walking back through an invocation chain from a call to DateTimeFormatterBuilder.toFormatter looking for calls to appendValue.\n+   * If conflicting week and year settings are detected, an issue is reported\n+   * @param invocation A call to DateTimeFormatterBuilder.toFormatter\n+   */\n+  private void visitBuildChain(MethodInvocationTree invocation) {\n+    boolean usesWeekBasedYear = false;\n+    boolean usesWeekOfWeekBasedYear = false;\n+    Tree wanderer = invocation.methodSelect();\n+    while (wanderer != null && wanderer.is(Tree.Kind.MEMBER_SELECT)) {\n+      ExpressionTree expression = ((MemberSelectExpressionTree) wanderer).expression();\n+      if (!expression.is(Tree.Kind.METHOD_INVOCATION)) {\n+        break;\n+      }\n+      MethodInvocationTree mit = (MethodInvocationTree) expression;\n+      if (APPEND_VALUE_MATCHER.matches(mit)) {\n+        usesWeekBasedYear |= isWeekBasedYearUsed(mit);\n+        usesWeekOfWeekBasedYear |= isWeekOfWeekBasedYearUsed(mit);\n+      }\n+      wanderer = mit.methodSelect();\n+    }\n+    if (wanderer == null) {\n+      return;\n+    }\n+    ExpressionTree lastExpression = ((MemberSelectExpressionTree) wanderer).expression();\n+    if (!lastExpression.is(Tree.Kind.NEW_CLASS)) {\n+      return;\n+    }\n+    if (usesWeekBasedYear && !usesWeekOfWeekBasedYear) {\n+      reportIssue(invocation, CHANGE_WEEK_FORMAT_MESSAGE);\n+    } else if (!usesWeekBasedYear && usesWeekOfWeekBasedYear) {\n+      reportIssue(invocation, CHANGE_YEAR_FORMAT_MESSAGE);", "originalCommit": "0eea7ccc802d7c40291044097a5927a4cf2baa8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI4MDA1NQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3365#discussion_r549280055", "bodyText": "I think we can remove the wanderer != null check here: methodSelect() is not annotated as nullable, so it is assumed never to be null", "author": "christophe-zurn-sonarsource", "createdAt": "2020-12-28T09:34:59Z", "path": "java-checks/src/main/java/org/sonar/java/checks/DateTimeFormatterMismatchCheck.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.tree.Arguments;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+\n+@Rule(key = \"S5917\")\n+public class DateTimeFormatterMismatchCheck extends IssuableSubscriptionVisitor {\n+  private static final MethodMatchers OF_PATTERN_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatter\")\n+    .names(\"ofPattern\")\n+    .addParametersMatcher(\"java.lang.String\")\n+    .addParametersMatcher(\"java.lang.String\", \"java.util.Locale\")\n+    .build();\n+\n+  private static final MethodMatchers APPEND_VALUE_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatterBuilder\")\n+    .names(\"appendValue\")\n+    .addParametersMatcher(\"java.time.temporal.TemporalField\", \"int\")\n+    .build();\n+\n+  private static final MethodMatchers DATE_TIME_FORMATTER_BUILDER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatterBuilder\")\n+    .names(\"toFormatter\")\n+    .addParametersMatcher()\n+    .build();\n+\n+  private static final Pattern WEEK_PATTERN = Pattern.compile(\".*ww{1,2}.*\");\n+  private static final Pattern YEAR_OF_ERA_PATTERN = Pattern.compile(\".*[uy]+.*\");\n+\n+  private static final String CHANGE_WEEK_FORMAT_MESSAGE = \"Change this week format to use the week of week-based year instead.\";\n+  private static final String CHANGE_YEAR_FORMAT_MESSAGE = \"Change this year format to use the week-based year instead.\";\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    MethodInvocationTree invocation = (MethodInvocationTree) tree;\n+    if (OF_PATTERN_MATCHER.matches(invocation)) {\n+      visitPattern(invocation);\n+    } else if (DATE_TIME_FORMATTER_BUILDER.matches(invocation)) {\n+      visitBuildChain(invocation);\n+    }\n+  }\n+\n+  private void visitPattern(MethodInvocationTree invocation) {\n+    Arguments arguments = invocation.arguments();\n+    ExpressionTree argument = arguments.get(0);\n+    if (argument.is(Tree.Kind.STRING_LITERAL)) {\n+      String pattern = ((LiteralTree) argument).value();\n+      if (WEEK_PATTERN.matcher(pattern).matches() && YEAR_OF_ERA_PATTERN.matcher(pattern).matches()) {\n+        reportIssue(invocation, CHANGE_YEAR_FORMAT_MESSAGE);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Walking back through an invocation chain from a call to DateTimeFormatterBuilder.toFormatter looking for calls to appendValue.\n+   * If conflicting week and year settings are detected, an issue is reported\n+   * @param invocation A call to DateTimeFormatterBuilder.toFormatter\n+   */\n+  private void visitBuildChain(MethodInvocationTree invocation) {\n+    boolean usesWeekBasedYear = false;\n+    boolean usesWeekOfWeekBasedYear = false;\n+    Tree wanderer = invocation.methodSelect();\n+    while (wanderer != null && wanderer.is(Tree.Kind.MEMBER_SELECT)) {", "originalCommit": "0eea7ccc802d7c40291044097a5927a4cf2baa8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI4MTk1NA==", "url": "https://github.com/SonarSource/sonar-java/pull/3365#discussion_r549281954", "bodyText": "With these checks, we will currenlty raise FP in the following 2 cases:\n    new DateTimeFormatterBuilder() // Noncompliant - FP\n      .appendValue(WeekFields.ISO.weekBasedYear(), 4)\n      .toFormatter();\n\n    new DateTimeFormatterBuilder() // Noncompliant - FP\n      .appendValue(WeekFields.ISO.weekOfWeekBasedYear(), 2)\n      .toFormatter();\n\nWe should only take into account cases where the year and week are explicitely set to mismatching format", "author": "christophe-zurn-sonarsource", "createdAt": "2020-12-28T09:41:14Z", "path": "java-checks/src/main/java/org/sonar/java/checks/DateTimeFormatterMismatchCheck.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.tree.Arguments;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+\n+@Rule(key = \"S5917\")\n+public class DateTimeFormatterMismatchCheck extends IssuableSubscriptionVisitor {\n+  private static final MethodMatchers OF_PATTERN_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatter\")\n+    .names(\"ofPattern\")\n+    .addParametersMatcher(\"java.lang.String\")\n+    .addParametersMatcher(\"java.lang.String\", \"java.util.Locale\")\n+    .build();\n+\n+  private static final MethodMatchers APPEND_VALUE_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatterBuilder\")\n+    .names(\"appendValue\")\n+    .addParametersMatcher(\"java.time.temporal.TemporalField\", \"int\")\n+    .build();\n+\n+  private static final MethodMatchers DATE_TIME_FORMATTER_BUILDER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatterBuilder\")\n+    .names(\"toFormatter\")\n+    .addParametersMatcher()\n+    .build();\n+\n+  private static final Pattern WEEK_PATTERN = Pattern.compile(\".*ww{1,2}.*\");\n+  private static final Pattern YEAR_OF_ERA_PATTERN = Pattern.compile(\".*[uy]+.*\");\n+\n+  private static final String CHANGE_WEEK_FORMAT_MESSAGE = \"Change this week format to use the week of week-based year instead.\";\n+  private static final String CHANGE_YEAR_FORMAT_MESSAGE = \"Change this year format to use the week-based year instead.\";\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    MethodInvocationTree invocation = (MethodInvocationTree) tree;\n+    if (OF_PATTERN_MATCHER.matches(invocation)) {\n+      visitPattern(invocation);\n+    } else if (DATE_TIME_FORMATTER_BUILDER.matches(invocation)) {\n+      visitBuildChain(invocation);\n+    }\n+  }\n+\n+  private void visitPattern(MethodInvocationTree invocation) {\n+    Arguments arguments = invocation.arguments();\n+    ExpressionTree argument = arguments.get(0);\n+    if (argument.is(Tree.Kind.STRING_LITERAL)) {\n+      String pattern = ((LiteralTree) argument).value();\n+      if (WEEK_PATTERN.matcher(pattern).matches() && YEAR_OF_ERA_PATTERN.matcher(pattern).matches()) {\n+        reportIssue(invocation, CHANGE_YEAR_FORMAT_MESSAGE);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Walking back through an invocation chain from a call to DateTimeFormatterBuilder.toFormatter looking for calls to appendValue.\n+   * If conflicting week and year settings are detected, an issue is reported\n+   * @param invocation A call to DateTimeFormatterBuilder.toFormatter\n+   */\n+  private void visitBuildChain(MethodInvocationTree invocation) {\n+    boolean usesWeekBasedYear = false;\n+    boolean usesWeekOfWeekBasedYear = false;\n+    Tree wanderer = invocation.methodSelect();\n+    while (wanderer != null && wanderer.is(Tree.Kind.MEMBER_SELECT)) {\n+      ExpressionTree expression = ((MemberSelectExpressionTree) wanderer).expression();\n+      if (!expression.is(Tree.Kind.METHOD_INVOCATION)) {\n+        break;\n+      }\n+      MethodInvocationTree mit = (MethodInvocationTree) expression;\n+      if (APPEND_VALUE_MATCHER.matches(mit)) {\n+        usesWeekBasedYear |= isWeekBasedYearUsed(mit);\n+        usesWeekOfWeekBasedYear |= isWeekOfWeekBasedYearUsed(mit);\n+      }\n+      wanderer = mit.methodSelect();\n+    }\n+    if (wanderer == null) {\n+      return;\n+    }\n+    ExpressionTree lastExpression = ((MemberSelectExpressionTree) wanderer).expression();\n+    if (!lastExpression.is(Tree.Kind.NEW_CLASS)) {\n+      return;\n+    }\n+    if (usesWeekBasedYear && !usesWeekOfWeekBasedYear) {\n+      reportIssue(invocation, CHANGE_WEEK_FORMAT_MESSAGE);\n+    } else if (!usesWeekBasedYear && usesWeekOfWeekBasedYear) {", "originalCommit": "0eea7ccc802d7c40291044097a5927a4cf2baa8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0OTI4MjUxOQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3365#discussion_r549282519", "bodyText": "We could use MethodMatchers for checking these invocations", "author": "christophe-zurn-sonarsource", "createdAt": "2020-12-28T09:43:13Z", "path": "java-checks/src/main/java/org/sonar/java/checks/DateTimeFormatterMismatchCheck.java", "diffHunk": "@@ -0,0 +1,145 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.tree.Arguments;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+\n+@Rule(key = \"S5917\")\n+public class DateTimeFormatterMismatchCheck extends IssuableSubscriptionVisitor {\n+  private static final MethodMatchers OF_PATTERN_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatter\")\n+    .names(\"ofPattern\")\n+    .addParametersMatcher(\"java.lang.String\")\n+    .addParametersMatcher(\"java.lang.String\", \"java.util.Locale\")\n+    .build();\n+\n+  private static final MethodMatchers APPEND_VALUE_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatterBuilder\")\n+    .names(\"appendValue\")\n+    .addParametersMatcher(\"java.time.temporal.TemporalField\", \"int\")\n+    .build();\n+\n+  private static final MethodMatchers DATE_TIME_FORMATTER_BUILDER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatterBuilder\")\n+    .names(\"toFormatter\")\n+    .addParametersMatcher()\n+    .build();\n+\n+  private static final Pattern WEEK_PATTERN = Pattern.compile(\".*ww{1,2}.*\");\n+  private static final Pattern YEAR_OF_ERA_PATTERN = Pattern.compile(\".*[uy]+.*\");\n+\n+  private static final String CHANGE_WEEK_FORMAT_MESSAGE = \"Change this week format to use the week of week-based year instead.\";\n+  private static final String CHANGE_YEAR_FORMAT_MESSAGE = \"Change this year format to use the week-based year instead.\";\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    MethodInvocationTree invocation = (MethodInvocationTree) tree;\n+    if (OF_PATTERN_MATCHER.matches(invocation)) {\n+      visitPattern(invocation);\n+    } else if (DATE_TIME_FORMATTER_BUILDER.matches(invocation)) {\n+      visitBuildChain(invocation);\n+    }\n+  }\n+\n+  private void visitPattern(MethodInvocationTree invocation) {\n+    Arguments arguments = invocation.arguments();\n+    ExpressionTree argument = arguments.get(0);\n+    if (argument.is(Tree.Kind.STRING_LITERAL)) {\n+      String pattern = ((LiteralTree) argument).value();\n+      if (WEEK_PATTERN.matcher(pattern).matches() && YEAR_OF_ERA_PATTERN.matcher(pattern).matches()) {\n+        reportIssue(invocation, CHANGE_YEAR_FORMAT_MESSAGE);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Walking back through an invocation chain from a call to DateTimeFormatterBuilder.toFormatter looking for calls to appendValue.\n+   * If conflicting week and year settings are detected, an issue is reported\n+   * @param invocation A call to DateTimeFormatterBuilder.toFormatter\n+   */\n+  private void visitBuildChain(MethodInvocationTree invocation) {\n+    boolean usesWeekBasedYear = false;\n+    boolean usesWeekOfWeekBasedYear = false;\n+    Tree wanderer = invocation.methodSelect();\n+    while (wanderer != null && wanderer.is(Tree.Kind.MEMBER_SELECT)) {\n+      ExpressionTree expression = ((MemberSelectExpressionTree) wanderer).expression();\n+      if (!expression.is(Tree.Kind.METHOD_INVOCATION)) {\n+        break;\n+      }\n+      MethodInvocationTree mit = (MethodInvocationTree) expression;\n+      if (APPEND_VALUE_MATCHER.matches(mit)) {\n+        usesWeekBasedYear |= isWeekBasedYearUsed(mit);\n+        usesWeekOfWeekBasedYear |= isWeekOfWeekBasedYearUsed(mit);\n+      }\n+      wanderer = mit.methodSelect();\n+    }\n+    if (wanderer == null) {\n+      return;\n+    }\n+    ExpressionTree lastExpression = ((MemberSelectExpressionTree) wanderer).expression();\n+    if (!lastExpression.is(Tree.Kind.NEW_CLASS)) {\n+      return;\n+    }\n+    if (usesWeekBasedYear && !usesWeekOfWeekBasedYear) {\n+      reportIssue(invocation, CHANGE_WEEK_FORMAT_MESSAGE);\n+    } else if (!usesWeekBasedYear && usesWeekOfWeekBasedYear) {\n+      reportIssue(invocation, CHANGE_YEAR_FORMAT_MESSAGE);\n+    }\n+  }\n+\n+  private static boolean isWeekBasedYearUsed(MethodInvocationTree invocation) {\n+    Arguments arguments = invocation.arguments();\n+    ExpressionTree argument = arguments.get(0);\n+    if (argument.is(Tree.Kind.METHOD_INVOCATION)) {\n+      MethodInvocationTree call = (MethodInvocationTree) argument;\n+      Symbol symbol = call.symbol();\n+      return symbol.name().equals(\"weekBasedYear\");\n+    }\n+    return false;\n+  }\n+\n+  private static boolean isWeekOfWeekBasedYearUsed(MethodInvocationTree invocation) {", "originalCommit": "0eea7ccc802d7c40291044097a5927a4cf2baa8f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "b8e16f421674c445c9fa6e873d21e98b04231eac", "url": "https://github.com/SonarSource/sonar-java/commit/b8e16f421674c445c9fa6e873d21e98b04231eac", "message": "SONARJAVA-3480 S5917: Generate rule files", "committedDate": "2020-12-29T12:55:35Z", "type": "commit"}, {"oid": "e1fc6de6140e45e2a5143dde49ff6ffc1f359c5b", "url": "https://github.com/SonarSource/sonar-java/commit/e1fc6de6140e45e2a5143dde49ff6ffc1f359c5b", "message": "SONARJAVA-3480 S5917: Report issue on format built using ofPattern", "committedDate": "2020-12-29T12:55:35Z", "type": "commit"}, {"oid": "f0c5ac1345d2dfd9da084cee568f35a35373bb93", "url": "https://github.com/SonarSource/sonar-java/commit/f0c5ac1345d2dfd9da084cee568f35a35373bb93", "message": "SONARJAVA-3480 S5917: Detect mismatch in week and year operator in simple formatter builder chains", "committedDate": "2020-12-29T12:55:35Z", "type": "commit"}, {"oid": "8a62e0b4e30780f01366033bce87f3e01c6270b5", "url": "https://github.com/SonarSource/sonar-java/commit/8a62e0b4e30780f01366033bce87f3e01c6270b5", "message": "SONARJAVA-3480 S5917: Add missing license", "committedDate": "2020-12-29T12:55:35Z", "type": "commit"}, {"oid": "fa279d2553ef46c4f7ab811691130c504eeb10c3", "url": "https://github.com/SonarSource/sonar-java/commit/fa279d2553ef46c4f7ab811691130c504eeb10c3", "message": "SONARJAVA-3480 S5917: Adapt issue message to be more helpful", "committedDate": "2020-12-29T12:55:35Z", "type": "commit"}, {"oid": "e2c09082b35c85206670b76b611df58a5f78aa52", "url": "https://github.com/SonarSource/sonar-java/commit/e2c09082b35c85206670b76b611df58a5f78aa52", "message": "SONARJAVA-3480 S5917: Refactoring", "committedDate": "2020-12-29T12:55:35Z", "type": "commit"}, {"oid": "e72e80ca211b3decb36164a5755fdc205157680a", "url": "https://github.com/SonarSource/sonar-java/commit/e72e80ca211b3decb36164a5755fdc205157680a", "message": "SONARJAVA-3480 Rename check files", "committedDate": "2020-12-29T12:55:35Z", "type": "commit"}, {"oid": "aa2a2b79b61879e0740d79128ed1fd230e6751a8", "url": "https://github.com/SonarSource/sonar-java/commit/aa2a2b79b61879e0740d79128ed1fd230e6751a8", "message": "SONARJAVA-3480 S5917: Enable check", "committedDate": "2020-12-29T12:55:35Z", "type": "commit"}, {"oid": "1c3e39c96d70557463cb3d08dc0c602af591c9b8", "url": "https://github.com/SonarSource/sonar-java/commit/1c3e39c96d70557463cb3d08dc0c602af591c9b8", "message": "SONARJAVA-3480 S5917: Fix rule key", "committedDate": "2020-12-29T12:55:35Z", "type": "commit"}, {"oid": "2a342e57b27c88eded51091c5e22d88a4ab89431", "url": "https://github.com/SonarSource/sonar-java/commit/2a342e57b27c88eded51091c5e22d88a4ab89431", "message": "SONARJAVA-3480 S5917: Add a FN example", "committedDate": "2020-12-29T12:55:36Z", "type": "commit"}, {"oid": "7c5139b6191310bdcabc401a901043278eded293", "url": "https://github.com/SonarSource/sonar-java/commit/7c5139b6191310bdcabc401a901043278eded293", "message": "SONARJAVA-3480 Add new patterns for DateTimeFormatter.ofPattern", "committedDate": "2020-12-29T12:55:36Z", "type": "commit"}, {"oid": "f4debc53d1424be26b3dafa7461d6bd5566045f5", "url": "https://github.com/SonarSource/sonar-java/commit/f4debc53d1424be26b3dafa7461d6bd5566045f5", "message": "SONARJAVA-3480 S5719: Check format pattern stored in final variables", "committedDate": "2020-12-29T12:55:36Z", "type": "commit"}, {"oid": "12431c7334cc6ed9d3297390d4c5fe608e9ebd45", "url": "https://github.com/SonarSource/sonar-java/commit/12431c7334cc6ed9d3297390d4c5fe608e9ebd45", "message": "SONARJAVA-3480: Use matchers to check calls to week based methods", "committedDate": "2020-12-29T12:55:36Z", "type": "commit"}, {"oid": "f9d84df5c0365a83e329da6748a423891d41a52a", "url": "https://github.com/SonarSource/sonar-java/commit/f9d84df5c0365a83e329da6748a423891d41a52a", "message": "SONARJAVA-3480 S5917: Avoid reporting cases where a week or a year is\nset but not both", "committedDate": "2020-12-29T12:55:36Z", "type": "commit"}, {"oid": "724667877c209694c28f31d61e5408f8957e6755", "url": "https://github.com/SonarSource/sonar-java/commit/724667877c209694c28f31d61e5408f8957e6755", "message": "SONARJAVA-3480 S5917: Better handling of nullable variable", "committedDate": "2020-12-29T12:55:36Z", "type": "commit"}, {"oid": "74b17bfa5135c6361a28d67553b28f40b6c75a51", "url": "https://github.com/SonarSource/sonar-java/commit/74b17bfa5135c6361a28d67553b28f40b6c75a51", "message": "SONARJAVA-3480 S5917: Adjust messages, primary and secondary locations to match RSPEC", "committedDate": "2020-12-29T14:31:47Z", "type": "commit"}, {"oid": "edaa6c3174c00a194b06a90d3b88bfdff7026b08", "url": "https://github.com/SonarSource/sonar-java/commit/edaa6c3174c00a194b06a90d3b88bfdff7026b08", "message": "SONARJAVA-3480: Refactoring", "committedDate": "2020-12-29T14:55:56Z", "type": "commit"}, {"oid": "edaa6c3174c00a194b06a90d3b88bfdff7026b08", "url": "https://github.com/SonarSource/sonar-java/commit/edaa6c3174c00a194b06a90d3b88bfdff7026b08", "message": "SONARJAVA-3480: Refactoring", "committedDate": "2020-12-29T14:55:56Z", "type": "forcePushed"}, {"oid": "38248de77ce9e6e62b113f387182463c71a6e665", "url": "https://github.com/SonarSource/sonar-java/commit/38248de77ce9e6e62b113f387182463c71a6e665", "message": "SONARJAVA-3480: Discard calls to toFormatter and focus on calls to appendValue", "committedDate": "2020-12-29T16:27:06Z", "type": "commit"}, {"oid": "4092ae818831caedf0adc208832d47e8111f864a", "url": "https://github.com/SonarSource/sonar-java/commit/4092ae818831caedf0adc208832d47e8111f864a", "message": "SONARJAVA-3480: Prune dead branch", "committedDate": "2020-12-29T16:47:19Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA1ODY3NQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3365#discussion_r550058675", "bodyText": "For completeness, we could add an additional test case to document that we do not consider consecutive calls, which is ok:\nDateTimeFormatterBuilder builder2 = new DateTimeFormatterBuilder();\nbuilder2.appendValue(ChronoField.YEAR, 4); // FN - consecutive calls on builders are not taken into account\nbuilder2.appendLiteral('-');\nbuilder2.appendValue(WeekFields.ISO.weekOfWeekBasedYear(), 2);\nbuilder2.toFormatter();", "author": "christophe-zurn-sonarsource", "createdAt": "2020-12-30T09:05:28Z", "path": "java-checks-test-sources/src/main/java/checks/DateTimeFormatterMismatch.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package checks;\n+\n+import java.time.format.DateTimeFormatter;\n+import java.time.format.DateTimeFormatterBuilder;\n+import java.time.temporal.ChronoField;\n+import java.time.temporal.WeekFields;\n+import java.util.Locale;\n+\n+public class DateTimeFormatterMismatch {\n+  private static final String COMPLIANT_PATTERN = \"Y-ww\";\n+  private static final String NON_COMPLIANT_PATTERN = \"y-ww\";\n+  private static final String IRRELEVANT_PATTERN = \"m\";\n+  private static final String NON_INITIALIZED_PATTERN = null;\n+  private String compliantAndNonFinalPattern = \"Y-ww\";\n+  private String nonCompliantAndNonFinalPattern = \"y-ww\";\n+\n+  public void createUsingPatterns() {\n+    DateTimeFormatter.ofPattern(COMPLIANT_PATTERN); // Compliant\n+    DateTimeFormatter.ofPattern(IRRELEVANT_PATTERN); // Compliant\n+    DateTimeFormatter.ofPattern(NON_INITIALIZED_PATTERN); // Compliant\n+    DateTimeFormatter.ofPattern(compliantAndNonFinalPattern); // Compliant\n+    DateTimeFormatter.ofPattern(nonCompliantAndNonFinalPattern); // Compliant FN\n+    DateTimeFormatter.ofPattern(\"Y-ww\"); // Compliant\n+    DateTimeFormatter.ofPattern(\"YY-ww\"); // Compliant\n+    DateTimeFormatter.ofPattern(\"YYY-ww\"); // Compliant\n+    DateTimeFormatter.ofPattern(\"YYYY-ww\"); // Compliant\n+    DateTimeFormatter.ofPattern(COMPLIANT_PATTERN, Locale.ENGLISH); // Compliant\n+    DateTimeFormatter.ofPattern(IRRELEVANT_PATTERN, Locale.ENGLISH); // Compliant\n+    DateTimeFormatter.ofPattern(NON_INITIALIZED_PATTERN, Locale.ENGLISH); // Compliant\n+    DateTimeFormatter.ofPattern(\"Y-ww\", Locale.ENGLISH); // Compliant\n+    DateTimeFormatter.ofPattern(\"YY-ww\", Locale.ENGLISH); // Compliant\n+    DateTimeFormatter.ofPattern(\"YYY-ww\", Locale.ENGLISH); // Compliant\n+    DateTimeFormatter.ofPattern(\"YYYY-ww\", Locale.ENGLISH); // Compliant\n+\n+\n+    //The bad stuff\n+    DateTimeFormatter.ofPattern(NON_COMPLIANT_PATTERN); // Noncompliant\n+    DateTimeFormatter.ofPattern(\"y-ww\"); // Noncompliant\n+    DateTimeFormatter.ofPattern(\"yy-ww\"); // Noncompliant\n+    DateTimeFormatter.ofPattern(\"yyy-ww\"); // Noncompliant\n+    DateTimeFormatter.ofPattern(\"yyyy-ww\"); // Noncompliant\n+    DateTimeFormatter.ofPattern(NON_COMPLIANT_PATTERN, Locale.ENGLISH); // Noncompliant\n+    DateTimeFormatter.ofPattern(\"y-ww\", Locale.ENGLISH); // Noncompliant\n+    DateTimeFormatter.ofPattern(\"yy-ww\", Locale.ENGLISH); // Noncompliant\n+    DateTimeFormatter.ofPattern(\"yyy-ww\", Locale.ENGLISH); // Noncompliant\n+    DateTimeFormatter.ofPattern(\"yyyy-ww\", Locale.ENGLISH); // Noncompliant\n+\n+\n+    DateTimeFormatter.ofPattern(\"w\"); // Compliant\n+    DateTimeFormatter.ofPattern(\"ww\"); // Compliant\n+    DateTimeFormatter.ofPattern(\"w\", Locale.ENGLISH); // Compliant\n+    DateTimeFormatter.ofPattern(\"ww\", Locale.ENGLISH); // Compliant\n+\n+\n+    DateTimeFormatter.ofPattern(\"u-ww\"); // Noncompliant\n+    DateTimeFormatter.ofPattern(\"uu-ww\"); // Noncompliant\n+    DateTimeFormatter.ofPattern(\"uuuu-ww\"); // Noncompliant\n+    DateTimeFormatter.ofPattern(\"u-ww\", Locale.ENGLISH); // Noncompliant\n+    DateTimeFormatter.ofPattern(\"uu-ww\", Locale.ENGLISH); // Noncompliant\n+    DateTimeFormatter.ofPattern(\"uuuu-ww\", Locale.ENGLISH); // Noncompliant\n+  }\n+\n+  public void createUsingBuilder() {\n+    new DateTimeFormatterBuilder()\n+      .appendValue(ChronoField.YEAR, 4) // Noncompliant [[sc=20;ec=36;secondary=+2]] {{Change this year format to use the week-based year instead.}}\n+      .appendLiteral('-')\n+      .appendValue(WeekFields.ISO.weekOfWeekBasedYear(), 2)\n+      .toFormatter();\n+\n+    new DateTimeFormatterBuilder()\n+      .appendValue(WeekFields.ISO.weekBasedYear(), 4) // Noncompliant [[sc=20;ec=50;secondary=+2]] {{Change this year format to use ChronoField.YEAR instead.}}\n+      .appendLiteral('-')\n+      .appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR, 2)\n+      .toFormatter();\n+\n+    new DateTimeFormatterBuilder() // Compliant\n+      .appendValue(WeekFields.ISO.weekBasedYear(), 4)\n+      .appendLiteral('-')\n+      .appendValue(WeekFields.ISO.weekOfWeekBasedYear(), 2)\n+      .toFormatter();\n+\n+    new DateTimeFormatterBuilder() // Compliant\n+      .appendValue(ChronoField.YEAR, 4)\n+      .appendLiteral('-')\n+      .appendValue(ChronoField.ALIGNED_WEEK_OF_YEAR, 2)\n+      .toFormatter();\n+\n+    DateTimeFormatterBuilder builder = new DateTimeFormatterBuilder()\n+      .appendValue(ChronoField.YEAR, 4) // Noncompliant [[sc=20;ec=36]]\n+      .appendLiteral('-')\n+      .appendValue(WeekFields.ISO.weekOfWeekBasedYear(), 2);\n+\n+    builder.toFormatter();", "originalCommit": "4092ae818831caedf0adc208832d47e8111f864a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA3NDEwMA==", "url": "https://github.com/SonarSource/sonar-java/pull/3365#discussion_r550074100", "bodyText": "For clarity, I suggest to replace this with addWithoutParametersMatcher:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                .addParametersMatcher()\n          \n          \n            \n                .addWithoutParametersMatcher()", "author": "christophe-zurn-sonarsource", "createdAt": "2020-12-30T09:25:50Z", "path": "java-checks/src/main/java/org/sonar/java/checks/DateTimeFormatterMismatchCheck.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.JavaFileScannerContext;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.tree.Arguments;\n+import org.sonar.plugins.java.api.tree.BaseTreeVisitor;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.VariableTree;\n+\n+@Rule(key = \"S5917\")\n+public class DateTimeFormatterMismatchCheck extends IssuableSubscriptionVisitor {\n+  private static final MethodMatchers OF_PATTERN_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatter\")\n+    .names(\"ofPattern\")\n+    .addParametersMatcher(\"java.lang.String\")\n+    .addParametersMatcher(\"java.lang.String\", \"java.util.Locale\")\n+    .build();\n+\n+  private static final MethodMatchers APPEND_VALUE_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatterBuilder\")\n+    .names(\"appendValue\")\n+    .addParametersMatcher(\"java.time.temporal.TemporalField\", \"int\")\n+    .build();\n+\n+  private static final MethodMatchers WEEK_BASED_YEAR_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.temporal.WeekFields\")\n+    .names(\"weekBasedYear\")\n+    .addParametersMatcher()", "originalCommit": "4092ae818831caedf0adc208832d47e8111f864a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA3NDE5MA==", "url": "https://github.com/SonarSource/sonar-java/pull/3365#discussion_r550074190", "bodyText": "For clarity, I suggest to replace this with addWithoutParametersMatcher:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                .addParametersMatcher()\n          \n          \n            \n                .addWithoutParametersMatcher()", "author": "christophe-zurn-sonarsource", "createdAt": "2020-12-30T09:25:56Z", "path": "java-checks/src/main/java/org/sonar/java/checks/DateTimeFormatterMismatchCheck.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.JavaFileScannerContext;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.tree.Arguments;\n+import org.sonar.plugins.java.api.tree.BaseTreeVisitor;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.VariableTree;\n+\n+@Rule(key = \"S5917\")\n+public class DateTimeFormatterMismatchCheck extends IssuableSubscriptionVisitor {\n+  private static final MethodMatchers OF_PATTERN_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatter\")\n+    .names(\"ofPattern\")\n+    .addParametersMatcher(\"java.lang.String\")\n+    .addParametersMatcher(\"java.lang.String\", \"java.util.Locale\")\n+    .build();\n+\n+  private static final MethodMatchers APPEND_VALUE_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatterBuilder\")\n+    .names(\"appendValue\")\n+    .addParametersMatcher(\"java.time.temporal.TemporalField\", \"int\")\n+    .build();\n+\n+  private static final MethodMatchers WEEK_BASED_YEAR_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.temporal.WeekFields\")\n+    .names(\"weekBasedYear\")\n+    .addParametersMatcher()\n+    .build();\n+\n+  private static final MethodMatchers WEEK_OF_WEEK_BASED_YEAR_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.temporal.WeekFields\")\n+    .names(\"weekOfWeekBasedYear\")\n+    .addParametersMatcher()", "originalCommit": "4092ae818831caedf0adc208832d47e8111f864a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA3NTEwMQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3365#discussion_r550075101", "bodyText": "We can make this inner class private", "author": "christophe-zurn-sonarsource", "createdAt": "2020-12-30T09:26:57Z", "path": "java-checks/src/main/java/org/sonar/java/checks/DateTimeFormatterMismatchCheck.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.JavaFileScannerContext;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.tree.Arguments;\n+import org.sonar.plugins.java.api.tree.BaseTreeVisitor;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.VariableTree;\n+\n+@Rule(key = \"S5917\")\n+public class DateTimeFormatterMismatchCheck extends IssuableSubscriptionVisitor {\n+  private static final MethodMatchers OF_PATTERN_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatter\")\n+    .names(\"ofPattern\")\n+    .addParametersMatcher(\"java.lang.String\")\n+    .addParametersMatcher(\"java.lang.String\", \"java.util.Locale\")\n+    .build();\n+\n+  private static final MethodMatchers APPEND_VALUE_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatterBuilder\")\n+    .names(\"appendValue\")\n+    .addParametersMatcher(\"java.time.temporal.TemporalField\", \"int\")\n+    .build();\n+\n+  private static final MethodMatchers WEEK_BASED_YEAR_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.temporal.WeekFields\")\n+    .names(\"weekBasedYear\")\n+    .addParametersMatcher()\n+    .build();\n+\n+  private static final MethodMatchers WEEK_OF_WEEK_BASED_YEAR_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.temporal.WeekFields\")\n+    .names(\"weekOfWeekBasedYear\")\n+    .addParametersMatcher()\n+    .build();\n+\n+  private static final Pattern WEEK_PATTERN = Pattern.compile(\".*ww{1,2}.*\");\n+  private static final Pattern YEAR_OF_ERA_PATTERN = Pattern.compile(\".*[uy]+.*\");\n+\n+  private static final String CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE = \"Change this year format to use the week-based year instead.\";\n+  private static final String CHANGE_YEAR_FORMAT_TO_CHRONOFIELD_MESSAGE = \"Change this year format to use ChronoField.YEAR instead.\";\n+  private static final String SECONDARY_LOCATION_MESSAGE = \"\";\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    MethodInvocationTree invocation = (MethodInvocationTree) tree;\n+    if (OF_PATTERN_MATCHER.matches(invocation)) {\n+      visitPattern(invocation);\n+    } else if (APPEND_VALUE_MATCHER.matches(invocation)) {\n+      ChainVisitor visitor = new ChainVisitor();\n+      invocation.accept(visitor);\n+      if (!visitor.usesWeek || !visitor.usesYear) {\n+        return;\n+      }\n+      if (visitor.usesWeekBasedYear && !visitor.usesWeekOfWeekBasedYear) {\n+        reportIssue(visitor.primary, CHANGE_YEAR_FORMAT_TO_CHRONOFIELD_MESSAGE, visitor.locations, null);\n+      } else if (!visitor.usesWeekBasedYear && visitor.usesWeekOfWeekBasedYear) {\n+        reportIssue(visitor.primary, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE, visitor.locations, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * We currently only check formatters initialized with a String literal or the value of a final variable.\n+   */\n+  private void visitPattern(MethodInvocationTree invocation) {\n+    Arguments arguments = invocation.arguments();\n+    ExpressionTree argument = arguments.get(0);\n+    if (argument.is(Tree.Kind.STRING_LITERAL)) {\n+      String pattern = ((LiteralTree) argument).value();\n+      if (isInfringingPattern(pattern)) {\n+        reportIssue(invocation, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE);\n+      }\n+    } else if (argument.is(Tree.Kind.IDENTIFIER)) {\n+      IdentifierTree identifier = (IdentifierTree) argument;\n+      Symbol symbol = identifier.symbol();\n+      if (!symbol.isFinal()) {\n+        return;\n+      }\n+      Tree declaration = symbol.declaration();\n+      if (declaration == null || !declaration.is(Tree.Kind.VARIABLE)) {\n+        return;\n+      }\n+      VariableTree variable = (VariableTree) declaration;\n+      ExpressionTree initializer = variable.initializer();\n+      if (initializer == null || !initializer.is(Tree.Kind.STRING_LITERAL)) {\n+        return;\n+      }\n+      String pattern = ((LiteralTree) initializer).value();\n+      if (isInfringingPattern(pattern)) {\n+        reportIssue(invocation, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE);\n+      }\n+    }\n+  }\n+\n+  private static boolean isInfringingPattern(String pattern) {\n+    return WEEK_PATTERN.matcher(pattern).matches() && YEAR_OF_ERA_PATTERN.matcher(pattern).matches();\n+  }\n+\n+  public static boolean refersToWeek(ExpressionTree argument) {\n+    return isChronoFieldWeek(argument) || isWeekOfWeekBasedYearUsed(argument);\n+  }\n+\n+  private static boolean isWeekOfWeekBasedYearUsed(ExpressionTree argument) {\n+    if (argument.is(Tree.Kind.METHOD_INVOCATION)) {\n+      MethodInvocationTree call = (MethodInvocationTree) argument;\n+      return WEEK_OF_WEEK_BASED_YEAR_MATCHER.matches(call);\n+    }\n+    return false;\n+  }\n+\n+  public static boolean isChronoFieldWeek(ExpressionTree argument) {\n+    if (argument.is(Tree.Kind.MEMBER_SELECT)) {\n+      MemberSelectExpressionTree select = (MemberSelectExpressionTree) argument;\n+      IdentifierTree identifier = select.identifier();\n+      return identifier.name().equals(\"ALIGNED_WEEK_OF_YEAR\");\n+    }\n+    return false;\n+  }\n+\n+  public static boolean refersToYear(ExpressionTree argument) {\n+    return isChronoFieldYear(argument) || isWeekBasedYearUsed(argument);\n+  }\n+\n+  private static boolean isWeekBasedYearUsed(ExpressionTree argument) {\n+    if (argument.is(Tree.Kind.METHOD_INVOCATION)) {\n+      MethodInvocationTree call = (MethodInvocationTree) argument;\n+      return WEEK_BASED_YEAR_MATCHER.matches(call);\n+    }\n+    return false;\n+  }\n+\n+  public static boolean isChronoFieldYear(ExpressionTree argument) {\n+    if (argument.is(Tree.Kind.MEMBER_SELECT)) {\n+      MemberSelectExpressionTree select = (MemberSelectExpressionTree) argument;\n+      IdentifierTree identifier = select.identifier();\n+      return identifier.name().equals(\"YEAR\");\n+    }\n+    return false;\n+  }\n+\n+  static class ChainVisitor extends BaseTreeVisitor {", "originalCommit": "4092ae818831caedf0adc208832d47e8111f864a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA3NzU0Nw==", "url": "https://github.com/SonarSource/sonar-java/pull/3365#discussion_r550077547", "bodyText": "You can make all these public static methods private, they are not needed to be public, and they can all be moved inside the inner ChainVisitor class", "author": "christophe-zurn-sonarsource", "createdAt": "2020-12-30T09:29:55Z", "path": "java-checks/src/main/java/org/sonar/java/checks/DateTimeFormatterMismatchCheck.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.JavaFileScannerContext;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.tree.Arguments;\n+import org.sonar.plugins.java.api.tree.BaseTreeVisitor;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.VariableTree;\n+\n+@Rule(key = \"S5917\")\n+public class DateTimeFormatterMismatchCheck extends IssuableSubscriptionVisitor {\n+  private static final MethodMatchers OF_PATTERN_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatter\")\n+    .names(\"ofPattern\")\n+    .addParametersMatcher(\"java.lang.String\")\n+    .addParametersMatcher(\"java.lang.String\", \"java.util.Locale\")\n+    .build();\n+\n+  private static final MethodMatchers APPEND_VALUE_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatterBuilder\")\n+    .names(\"appendValue\")\n+    .addParametersMatcher(\"java.time.temporal.TemporalField\", \"int\")\n+    .build();\n+\n+  private static final MethodMatchers WEEK_BASED_YEAR_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.temporal.WeekFields\")\n+    .names(\"weekBasedYear\")\n+    .addParametersMatcher()\n+    .build();\n+\n+  private static final MethodMatchers WEEK_OF_WEEK_BASED_YEAR_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.temporal.WeekFields\")\n+    .names(\"weekOfWeekBasedYear\")\n+    .addParametersMatcher()\n+    .build();\n+\n+  private static final Pattern WEEK_PATTERN = Pattern.compile(\".*ww{1,2}.*\");\n+  private static final Pattern YEAR_OF_ERA_PATTERN = Pattern.compile(\".*[uy]+.*\");\n+\n+  private static final String CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE = \"Change this year format to use the week-based year instead.\";\n+  private static final String CHANGE_YEAR_FORMAT_TO_CHRONOFIELD_MESSAGE = \"Change this year format to use ChronoField.YEAR instead.\";\n+  private static final String SECONDARY_LOCATION_MESSAGE = \"\";\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    MethodInvocationTree invocation = (MethodInvocationTree) tree;\n+    if (OF_PATTERN_MATCHER.matches(invocation)) {\n+      visitPattern(invocation);\n+    } else if (APPEND_VALUE_MATCHER.matches(invocation)) {\n+      ChainVisitor visitor = new ChainVisitor();\n+      invocation.accept(visitor);\n+      if (!visitor.usesWeek || !visitor.usesYear) {\n+        return;\n+      }\n+      if (visitor.usesWeekBasedYear && !visitor.usesWeekOfWeekBasedYear) {\n+        reportIssue(visitor.primary, CHANGE_YEAR_FORMAT_TO_CHRONOFIELD_MESSAGE, visitor.locations, null);\n+      } else if (!visitor.usesWeekBasedYear && visitor.usesWeekOfWeekBasedYear) {\n+        reportIssue(visitor.primary, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE, visitor.locations, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * We currently only check formatters initialized with a String literal or the value of a final variable.\n+   */\n+  private void visitPattern(MethodInvocationTree invocation) {\n+    Arguments arguments = invocation.arguments();\n+    ExpressionTree argument = arguments.get(0);\n+    if (argument.is(Tree.Kind.STRING_LITERAL)) {\n+      String pattern = ((LiteralTree) argument).value();\n+      if (isInfringingPattern(pattern)) {\n+        reportIssue(invocation, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE);\n+      }\n+    } else if (argument.is(Tree.Kind.IDENTIFIER)) {\n+      IdentifierTree identifier = (IdentifierTree) argument;\n+      Symbol symbol = identifier.symbol();\n+      if (!symbol.isFinal()) {\n+        return;\n+      }\n+      Tree declaration = symbol.declaration();\n+      if (declaration == null || !declaration.is(Tree.Kind.VARIABLE)) {\n+        return;\n+      }\n+      VariableTree variable = (VariableTree) declaration;\n+      ExpressionTree initializer = variable.initializer();\n+      if (initializer == null || !initializer.is(Tree.Kind.STRING_LITERAL)) {\n+        return;\n+      }\n+      String pattern = ((LiteralTree) initializer).value();\n+      if (isInfringingPattern(pattern)) {\n+        reportIssue(invocation, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE);\n+      }\n+    }\n+  }\n+\n+  private static boolean isInfringingPattern(String pattern) {\n+    return WEEK_PATTERN.matcher(pattern).matches() && YEAR_OF_ERA_PATTERN.matcher(pattern).matches();\n+  }\n+\n+  public static boolean refersToWeek(ExpressionTree argument) {\n+    return isChronoFieldWeek(argument) || isWeekOfWeekBasedYearUsed(argument);\n+  }\n+\n+  private static boolean isWeekOfWeekBasedYearUsed(ExpressionTree argument) {\n+    if (argument.is(Tree.Kind.METHOD_INVOCATION)) {\n+      MethodInvocationTree call = (MethodInvocationTree) argument;\n+      return WEEK_OF_WEEK_BASED_YEAR_MATCHER.matches(call);\n+    }\n+    return false;\n+  }\n+\n+  public static boolean isChronoFieldWeek(ExpressionTree argument) {\n+    if (argument.is(Tree.Kind.MEMBER_SELECT)) {\n+      MemberSelectExpressionTree select = (MemberSelectExpressionTree) argument;\n+      IdentifierTree identifier = select.identifier();\n+      return identifier.name().equals(\"ALIGNED_WEEK_OF_YEAR\");\n+    }\n+    return false;\n+  }\n+\n+  public static boolean refersToYear(ExpressionTree argument) {\n+    return isChronoFieldYear(argument) || isWeekBasedYearUsed(argument);\n+  }\n+\n+  private static boolean isWeekBasedYearUsed(ExpressionTree argument) {\n+    if (argument.is(Tree.Kind.METHOD_INVOCATION)) {\n+      MethodInvocationTree call = (MethodInvocationTree) argument;\n+      return WEEK_BASED_YEAR_MATCHER.matches(call);\n+    }\n+    return false;\n+  }\n+\n+  public static boolean isChronoFieldYear(ExpressionTree argument) {", "originalCommit": "4092ae818831caedf0adc208832d47e8111f864a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA4MTQ1NA==", "url": "https://github.com/SonarSource/sonar-java/pull/3365#discussion_r550081454", "bodyText": "Can we reverse the condition on this if here and not use a break as this is not necessary anymore", "author": "christophe-zurn-sonarsource", "createdAt": "2020-12-30T09:34:44Z", "path": "java-checks/src/main/java/org/sonar/java/checks/DateTimeFormatterMismatchCheck.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.JavaFileScannerContext;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.tree.Arguments;\n+import org.sonar.plugins.java.api.tree.BaseTreeVisitor;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.VariableTree;\n+\n+@Rule(key = \"S5917\")\n+public class DateTimeFormatterMismatchCheck extends IssuableSubscriptionVisitor {\n+  private static final MethodMatchers OF_PATTERN_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatter\")\n+    .names(\"ofPattern\")\n+    .addParametersMatcher(\"java.lang.String\")\n+    .addParametersMatcher(\"java.lang.String\", \"java.util.Locale\")\n+    .build();\n+\n+  private static final MethodMatchers APPEND_VALUE_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatterBuilder\")\n+    .names(\"appendValue\")\n+    .addParametersMatcher(\"java.time.temporal.TemporalField\", \"int\")\n+    .build();\n+\n+  private static final MethodMatchers WEEK_BASED_YEAR_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.temporal.WeekFields\")\n+    .names(\"weekBasedYear\")\n+    .addParametersMatcher()\n+    .build();\n+\n+  private static final MethodMatchers WEEK_OF_WEEK_BASED_YEAR_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.temporal.WeekFields\")\n+    .names(\"weekOfWeekBasedYear\")\n+    .addParametersMatcher()\n+    .build();\n+\n+  private static final Pattern WEEK_PATTERN = Pattern.compile(\".*ww{1,2}.*\");\n+  private static final Pattern YEAR_OF_ERA_PATTERN = Pattern.compile(\".*[uy]+.*\");\n+\n+  private static final String CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE = \"Change this year format to use the week-based year instead.\";\n+  private static final String CHANGE_YEAR_FORMAT_TO_CHRONOFIELD_MESSAGE = \"Change this year format to use ChronoField.YEAR instead.\";\n+  private static final String SECONDARY_LOCATION_MESSAGE = \"\";\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    MethodInvocationTree invocation = (MethodInvocationTree) tree;\n+    if (OF_PATTERN_MATCHER.matches(invocation)) {\n+      visitPattern(invocation);\n+    } else if (APPEND_VALUE_MATCHER.matches(invocation)) {\n+      ChainVisitor visitor = new ChainVisitor();\n+      invocation.accept(visitor);\n+      if (!visitor.usesWeek || !visitor.usesYear) {\n+        return;\n+      }\n+      if (visitor.usesWeekBasedYear && !visitor.usesWeekOfWeekBasedYear) {\n+        reportIssue(visitor.primary, CHANGE_YEAR_FORMAT_TO_CHRONOFIELD_MESSAGE, visitor.locations, null);\n+      } else if (!visitor.usesWeekBasedYear && visitor.usesWeekOfWeekBasedYear) {\n+        reportIssue(visitor.primary, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE, visitor.locations, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * We currently only check formatters initialized with a String literal or the value of a final variable.\n+   */\n+  private void visitPattern(MethodInvocationTree invocation) {\n+    Arguments arguments = invocation.arguments();\n+    ExpressionTree argument = arguments.get(0);\n+    if (argument.is(Tree.Kind.STRING_LITERAL)) {\n+      String pattern = ((LiteralTree) argument).value();\n+      if (isInfringingPattern(pattern)) {\n+        reportIssue(invocation, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE);\n+      }\n+    } else if (argument.is(Tree.Kind.IDENTIFIER)) {\n+      IdentifierTree identifier = (IdentifierTree) argument;\n+      Symbol symbol = identifier.symbol();\n+      if (!symbol.isFinal()) {\n+        return;\n+      }\n+      Tree declaration = symbol.declaration();\n+      if (declaration == null || !declaration.is(Tree.Kind.VARIABLE)) {\n+        return;\n+      }\n+      VariableTree variable = (VariableTree) declaration;\n+      ExpressionTree initializer = variable.initializer();\n+      if (initializer == null || !initializer.is(Tree.Kind.STRING_LITERAL)) {\n+        return;\n+      }\n+      String pattern = ((LiteralTree) initializer).value();\n+      if (isInfringingPattern(pattern)) {\n+        reportIssue(invocation, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE);\n+      }\n+    }\n+  }\n+\n+  private static boolean isInfringingPattern(String pattern) {\n+    return WEEK_PATTERN.matcher(pattern).matches() && YEAR_OF_ERA_PATTERN.matcher(pattern).matches();\n+  }\n+\n+  public static boolean refersToWeek(ExpressionTree argument) {\n+    return isChronoFieldWeek(argument) || isWeekOfWeekBasedYearUsed(argument);\n+  }\n+\n+  private static boolean isWeekOfWeekBasedYearUsed(ExpressionTree argument) {\n+    if (argument.is(Tree.Kind.METHOD_INVOCATION)) {\n+      MethodInvocationTree call = (MethodInvocationTree) argument;\n+      return WEEK_OF_WEEK_BASED_YEAR_MATCHER.matches(call);\n+    }\n+    return false;\n+  }\n+\n+  public static boolean isChronoFieldWeek(ExpressionTree argument) {\n+    if (argument.is(Tree.Kind.MEMBER_SELECT)) {\n+      MemberSelectExpressionTree select = (MemberSelectExpressionTree) argument;\n+      IdentifierTree identifier = select.identifier();\n+      return identifier.name().equals(\"ALIGNED_WEEK_OF_YEAR\");\n+    }\n+    return false;\n+  }\n+\n+  public static boolean refersToYear(ExpressionTree argument) {\n+    return isChronoFieldYear(argument) || isWeekBasedYearUsed(argument);\n+  }\n+\n+  private static boolean isWeekBasedYearUsed(ExpressionTree argument) {\n+    if (argument.is(Tree.Kind.METHOD_INVOCATION)) {\n+      MethodInvocationTree call = (MethodInvocationTree) argument;\n+      return WEEK_BASED_YEAR_MATCHER.matches(call);\n+    }\n+    return false;\n+  }\n+\n+  public static boolean isChronoFieldYear(ExpressionTree argument) {\n+    if (argument.is(Tree.Kind.MEMBER_SELECT)) {\n+      MemberSelectExpressionTree select = (MemberSelectExpressionTree) argument;\n+      IdentifierTree identifier = select.identifier();\n+      return identifier.name().equals(\"YEAR\");\n+    }\n+    return false;\n+  }\n+\n+  static class ChainVisitor extends BaseTreeVisitor {\n+    private boolean usesWeek = false;\n+    private boolean usesWeekOfWeekBasedYear = false;\n+    private boolean usesYear = false;\n+    private boolean usesWeekBasedYear = false;\n+    private final List<JavaFileScannerContext.Location> locations = new ArrayList<>();\n+    private ExpressionTree primary = null;\n+\n+    @Override\n+    public void visitMethodInvocation(MethodInvocationTree callToAppendValue) {\n+      inspectCall(callToAppendValue);\n+      ExpressionTree wanderer = callToAppendValue.methodSelect();\n+      while (wanderer.is(Tree.Kind.MEMBER_SELECT)) {\n+        ExpressionTree expression = ((MemberSelectExpressionTree) wanderer).expression();\n+        if (!expression.is(Tree.Kind.METHOD_INVOCATION)) {\n+          break;\n+        }\n+        MethodInvocationTree mit = (MethodInvocationTree) expression;\n+        inspectCall(mit);\n+        wanderer = mit.methodSelect();", "originalCommit": "4092ae818831caedf0adc208832d47e8111f864a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDE3MTgzNw==", "url": "https://github.com/SonarSource/sonar-java/pull/3365#discussion_r550171837", "bodyText": "The test can only be moved higher in the while loop condition because the code we will either need to exit the loop or try to access method select on an object that does not support it.", "author": "dorian-burihabwa-sonarsource", "createdAt": "2020-12-30T12:06:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA4MTQ1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA4NDgxMA==", "url": "https://github.com/SonarSource/sonar-java/pull/3365#discussion_r550084810", "bodyText": "I believe it would be easier to read if we had less if/return statements by adding an helper method to retrieve the string value: ex: getStringLiteralValue", "author": "christophe-zurn-sonarsource", "createdAt": "2020-12-30T09:38:56Z", "path": "java-checks/src/main/java/org/sonar/java/checks/DateTimeFormatterMismatchCheck.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.JavaFileScannerContext;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.tree.Arguments;\n+import org.sonar.plugins.java.api.tree.BaseTreeVisitor;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.VariableTree;\n+\n+@Rule(key = \"S5917\")\n+public class DateTimeFormatterMismatchCheck extends IssuableSubscriptionVisitor {\n+  private static final MethodMatchers OF_PATTERN_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatter\")\n+    .names(\"ofPattern\")\n+    .addParametersMatcher(\"java.lang.String\")\n+    .addParametersMatcher(\"java.lang.String\", \"java.util.Locale\")\n+    .build();\n+\n+  private static final MethodMatchers APPEND_VALUE_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatterBuilder\")\n+    .names(\"appendValue\")\n+    .addParametersMatcher(\"java.time.temporal.TemporalField\", \"int\")\n+    .build();\n+\n+  private static final MethodMatchers WEEK_BASED_YEAR_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.temporal.WeekFields\")\n+    .names(\"weekBasedYear\")\n+    .addParametersMatcher()\n+    .build();\n+\n+  private static final MethodMatchers WEEK_OF_WEEK_BASED_YEAR_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.temporal.WeekFields\")\n+    .names(\"weekOfWeekBasedYear\")\n+    .addParametersMatcher()\n+    .build();\n+\n+  private static final Pattern WEEK_PATTERN = Pattern.compile(\".*ww{1,2}.*\");\n+  private static final Pattern YEAR_OF_ERA_PATTERN = Pattern.compile(\".*[uy]+.*\");\n+\n+  private static final String CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE = \"Change this year format to use the week-based year instead.\";\n+  private static final String CHANGE_YEAR_FORMAT_TO_CHRONOFIELD_MESSAGE = \"Change this year format to use ChronoField.YEAR instead.\";\n+  private static final String SECONDARY_LOCATION_MESSAGE = \"\";\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    MethodInvocationTree invocation = (MethodInvocationTree) tree;\n+    if (OF_PATTERN_MATCHER.matches(invocation)) {\n+      visitPattern(invocation);\n+    } else if (APPEND_VALUE_MATCHER.matches(invocation)) {\n+      ChainVisitor visitor = new ChainVisitor();\n+      invocation.accept(visitor);\n+      if (!visitor.usesWeek || !visitor.usesYear) {\n+        return;\n+      }\n+      if (visitor.usesWeekBasedYear && !visitor.usesWeekOfWeekBasedYear) {\n+        reportIssue(visitor.primary, CHANGE_YEAR_FORMAT_TO_CHRONOFIELD_MESSAGE, visitor.locations, null);\n+      } else if (!visitor.usesWeekBasedYear && visitor.usesWeekOfWeekBasedYear) {\n+        reportIssue(visitor.primary, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE, visitor.locations, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * We currently only check formatters initialized with a String literal or the value of a final variable.\n+   */\n+  private void visitPattern(MethodInvocationTree invocation) {\n+    Arguments arguments = invocation.arguments();\n+    ExpressionTree argument = arguments.get(0);\n+    if (argument.is(Tree.Kind.STRING_LITERAL)) {\n+      String pattern = ((LiteralTree) argument).value();\n+      if (isInfringingPattern(pattern)) {\n+        reportIssue(invocation, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE);\n+      }\n+    } else if (argument.is(Tree.Kind.IDENTIFIER)) {\n+      IdentifierTree identifier = (IdentifierTree) argument;\n+      Symbol symbol = identifier.symbol();\n+      if (!symbol.isFinal()) {\n+        return;\n+      }\n+      Tree declaration = symbol.declaration();\n+      if (declaration == null || !declaration.is(Tree.Kind.VARIABLE)) {\n+        return;\n+      }\n+      VariableTree variable = (VariableTree) declaration;\n+      ExpressionTree initializer = variable.initializer();\n+      if (initializer == null || !initializer.is(Tree.Kind.STRING_LITERAL)) {\n+        return;\n+      }\n+      String pattern = ((LiteralTree) initializer).value();\n+      if (isInfringingPattern(pattern)) {\n+        reportIssue(invocation, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE);\n+      }", "originalCommit": "4092ae818831caedf0adc208832d47e8111f864a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDA4NzQ0Nw==", "url": "https://github.com/SonarSource/sonar-java/pull/3365#discussion_r550087447", "bodyText": "This is personal, and you can leave it as is if you prefer, but I'd find it slightly clearer it we renamed this class. Ex ChainedInvocationVisitor", "author": "christophe-zurn-sonarsource", "createdAt": "2020-12-30T09:42:20Z", "path": "java-checks/src/main/java/org/sonar/java/checks/DateTimeFormatterMismatchCheck.java", "diffHunk": "@@ -0,0 +1,216 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.JavaFileScannerContext;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.tree.Arguments;\n+import org.sonar.plugins.java.api.tree.BaseTreeVisitor;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.VariableTree;\n+\n+@Rule(key = \"S5917\")\n+public class DateTimeFormatterMismatchCheck extends IssuableSubscriptionVisitor {\n+  private static final MethodMatchers OF_PATTERN_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatter\")\n+    .names(\"ofPattern\")\n+    .addParametersMatcher(\"java.lang.String\")\n+    .addParametersMatcher(\"java.lang.String\", \"java.util.Locale\")\n+    .build();\n+\n+  private static final MethodMatchers APPEND_VALUE_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatterBuilder\")\n+    .names(\"appendValue\")\n+    .addParametersMatcher(\"java.time.temporal.TemporalField\", \"int\")\n+    .build();\n+\n+  private static final MethodMatchers WEEK_BASED_YEAR_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.temporal.WeekFields\")\n+    .names(\"weekBasedYear\")\n+    .addParametersMatcher()\n+    .build();\n+\n+  private static final MethodMatchers WEEK_OF_WEEK_BASED_YEAR_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.temporal.WeekFields\")\n+    .names(\"weekOfWeekBasedYear\")\n+    .addParametersMatcher()\n+    .build();\n+\n+  private static final Pattern WEEK_PATTERN = Pattern.compile(\".*ww{1,2}.*\");\n+  private static final Pattern YEAR_OF_ERA_PATTERN = Pattern.compile(\".*[uy]+.*\");\n+\n+  private static final String CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE = \"Change this year format to use the week-based year instead.\";\n+  private static final String CHANGE_YEAR_FORMAT_TO_CHRONOFIELD_MESSAGE = \"Change this year format to use ChronoField.YEAR instead.\";\n+  private static final String SECONDARY_LOCATION_MESSAGE = \"\";\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    MethodInvocationTree invocation = (MethodInvocationTree) tree;\n+    if (OF_PATTERN_MATCHER.matches(invocation)) {\n+      visitPattern(invocation);\n+    } else if (APPEND_VALUE_MATCHER.matches(invocation)) {\n+      ChainVisitor visitor = new ChainVisitor();\n+      invocation.accept(visitor);\n+      if (!visitor.usesWeek || !visitor.usesYear) {\n+        return;\n+      }\n+      if (visitor.usesWeekBasedYear && !visitor.usesWeekOfWeekBasedYear) {\n+        reportIssue(visitor.primary, CHANGE_YEAR_FORMAT_TO_CHRONOFIELD_MESSAGE, visitor.locations, null);\n+      } else if (!visitor.usesWeekBasedYear && visitor.usesWeekOfWeekBasedYear) {\n+        reportIssue(visitor.primary, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE, visitor.locations, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * We currently only check formatters initialized with a String literal or the value of a final variable.\n+   */\n+  private void visitPattern(MethodInvocationTree invocation) {\n+    Arguments arguments = invocation.arguments();\n+    ExpressionTree argument = arguments.get(0);\n+    if (argument.is(Tree.Kind.STRING_LITERAL)) {\n+      String pattern = ((LiteralTree) argument).value();\n+      if (isInfringingPattern(pattern)) {\n+        reportIssue(invocation, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE);\n+      }\n+    } else if (argument.is(Tree.Kind.IDENTIFIER)) {\n+      IdentifierTree identifier = (IdentifierTree) argument;\n+      Symbol symbol = identifier.symbol();\n+      if (!symbol.isFinal()) {\n+        return;\n+      }\n+      Tree declaration = symbol.declaration();\n+      if (declaration == null || !declaration.is(Tree.Kind.VARIABLE)) {\n+        return;\n+      }\n+      VariableTree variable = (VariableTree) declaration;\n+      ExpressionTree initializer = variable.initializer();\n+      if (initializer == null || !initializer.is(Tree.Kind.STRING_LITERAL)) {\n+        return;\n+      }\n+      String pattern = ((LiteralTree) initializer).value();\n+      if (isInfringingPattern(pattern)) {\n+        reportIssue(invocation, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE);\n+      }\n+    }\n+  }\n+\n+  private static boolean isInfringingPattern(String pattern) {\n+    return WEEK_PATTERN.matcher(pattern).matches() && YEAR_OF_ERA_PATTERN.matcher(pattern).matches();\n+  }\n+\n+  public static boolean refersToWeek(ExpressionTree argument) {\n+    return isChronoFieldWeek(argument) || isWeekOfWeekBasedYearUsed(argument);\n+  }\n+\n+  private static boolean isWeekOfWeekBasedYearUsed(ExpressionTree argument) {\n+    if (argument.is(Tree.Kind.METHOD_INVOCATION)) {\n+      MethodInvocationTree call = (MethodInvocationTree) argument;\n+      return WEEK_OF_WEEK_BASED_YEAR_MATCHER.matches(call);\n+    }\n+    return false;\n+  }\n+\n+  public static boolean isChronoFieldWeek(ExpressionTree argument) {\n+    if (argument.is(Tree.Kind.MEMBER_SELECT)) {\n+      MemberSelectExpressionTree select = (MemberSelectExpressionTree) argument;\n+      IdentifierTree identifier = select.identifier();\n+      return identifier.name().equals(\"ALIGNED_WEEK_OF_YEAR\");\n+    }\n+    return false;\n+  }\n+\n+  public static boolean refersToYear(ExpressionTree argument) {\n+    return isChronoFieldYear(argument) || isWeekBasedYearUsed(argument);\n+  }\n+\n+  private static boolean isWeekBasedYearUsed(ExpressionTree argument) {\n+    if (argument.is(Tree.Kind.METHOD_INVOCATION)) {\n+      MethodInvocationTree call = (MethodInvocationTree) argument;\n+      return WEEK_BASED_YEAR_MATCHER.matches(call);\n+    }\n+    return false;\n+  }\n+\n+  public static boolean isChronoFieldYear(ExpressionTree argument) {\n+    if (argument.is(Tree.Kind.MEMBER_SELECT)) {\n+      MemberSelectExpressionTree select = (MemberSelectExpressionTree) argument;\n+      IdentifierTree identifier = select.identifier();\n+      return identifier.name().equals(\"YEAR\");\n+    }\n+    return false;\n+  }\n+\n+  static class ChainVisitor extends BaseTreeVisitor {", "originalCommit": "4092ae818831caedf0adc208832d47e8111f864a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9e5880dfaaf407e40c570f8916ac17c9abaa31b2", "url": "https://github.com/SonarSource/sonar-java/commit/9e5880dfaaf407e40c570f8916ac17c9abaa31b2", "message": "SONARJAVA-3480: Changes requested by review", "committedDate": "2020-12-30T12:16:14Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDIxMDkzMg==", "url": "https://github.com/SonarSource/sonar-java/pull/3365#discussion_r550210932", "bodyText": "We should add the Nullable annotation to the Tree declaration parameter", "author": "christophe-zurn-sonarsource", "createdAt": "2020-12-30T14:22:20Z", "path": "java-checks/src/main/java/org/sonar/java/checks/DateTimeFormatterMismatchCheck.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.JavaFileScannerContext;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.tree.Arguments;\n+import org.sonar.plugins.java.api.tree.BaseTreeVisitor;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.VariableTree;\n+\n+@Rule(key = \"S5917\")\n+public class DateTimeFormatterMismatchCheck extends IssuableSubscriptionVisitor {\n+  private static final MethodMatchers OF_PATTERN_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatter\")\n+    .names(\"ofPattern\")\n+    .addParametersMatcher(\"java.lang.String\")\n+    .addParametersMatcher(\"java.lang.String\", \"java.util.Locale\")\n+    .build();\n+\n+  private static final MethodMatchers APPEND_VALUE_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatterBuilder\")\n+    .names(\"appendValue\")\n+    .addParametersMatcher(\"java.time.temporal.TemporalField\", \"int\")\n+    .build();\n+\n+  private static final MethodMatchers WEEK_BASED_YEAR_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.temporal.WeekFields\")\n+    .names(\"weekBasedYear\")\n+    .addWithoutParametersMatcher()\n+    .build();\n+\n+  private static final MethodMatchers WEEK_OF_WEEK_BASED_YEAR_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.temporal.WeekFields\")\n+    .names(\"weekOfWeekBasedYear\")\n+    .addWithoutParametersMatcher()\n+    .build();\n+\n+  private static final Pattern WEEK_PATTERN = Pattern.compile(\".*ww{1,2}.*\");\n+  private static final Pattern YEAR_OF_ERA_PATTERN = Pattern.compile(\".*[uy]+.*\");\n+\n+  private static final String CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE = \"Change this year format to use the week-based year instead.\";\n+  private static final String CHANGE_YEAR_FORMAT_TO_CHRONOFIELD_MESSAGE = \"Change this year format to use ChronoField.YEAR instead.\";\n+  private static final String SECONDARY_LOCATION_MESSAGE = \"\";\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    MethodInvocationTree invocation = (MethodInvocationTree) tree;\n+    if (OF_PATTERN_MATCHER.matches(invocation)) {\n+      visitPattern(invocation);\n+    } else if (APPEND_VALUE_MATCHER.matches(invocation)) {\n+      ChainedInvocationVisitor visitor = new ChainedInvocationVisitor();\n+      invocation.accept(visitor);\n+      if (!visitor.usesWeek || !visitor.usesYear) {\n+        return;\n+      }\n+      if (visitor.usesWeekBasedYear && !visitor.usesWeekOfWeekBasedYear) {\n+        reportIssue(visitor.primary, CHANGE_YEAR_FORMAT_TO_CHRONOFIELD_MESSAGE, visitor.locations, null);\n+      } else if (!visitor.usesWeekBasedYear && visitor.usesWeekOfWeekBasedYear) {\n+        reportIssue(visitor.primary, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE, visitor.locations, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * We currently only check formatters initialized with a String literal or the value of a final variable.\n+   */\n+  private void visitPattern(MethodInvocationTree invocation) {\n+    Arguments arguments = invocation.arguments();\n+    ExpressionTree argument = arguments.get(0);\n+    if (argument.is(Tree.Kind.STRING_LITERAL)) {\n+      String pattern = ((LiteralTree) argument).value();\n+      if (isInfringingPattern(pattern)) {\n+        reportIssue(invocation, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE);\n+      }\n+    } else if (argument.is(Tree.Kind.IDENTIFIER)) {\n+      IdentifierTree identifier = (IdentifierTree) argument;\n+      Symbol symbol = identifier.symbol();\n+      if (!symbol.isFinal()) {\n+        return;\n+      }\n+      Tree declaration = symbol.declaration();\n+      Optional<String> pattern = getStringLiteralValue(declaration);\n+      if (pattern.isPresent() && isInfringingPattern(pattern.get())) {\n+        reportIssue(invocation, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE);\n+      }\n+    }\n+  }\n+\n+  private static Optional<String> getStringLiteralValue(Tree declaration) {", "originalCommit": "9e5880dfaaf407e40c570f8916ac17c9abaa31b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDIxMzg4Nw==", "url": "https://github.com/SonarSource/sonar-java/pull/3365#discussion_r550213887", "bodyText": "For safety, we could also check the experssion underlying type:\nreturn select.symbolType().is(\"java.time.temporal.ChronoField\") && identifier.name().equals(\"ALIGNED_WEEK_OF_YEAR\");", "author": "christophe-zurn-sonarsource", "createdAt": "2020-12-30T14:31:22Z", "path": "java-checks/src/main/java/org/sonar/java/checks/DateTimeFormatterMismatchCheck.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.JavaFileScannerContext;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.tree.Arguments;\n+import org.sonar.plugins.java.api.tree.BaseTreeVisitor;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.VariableTree;\n+\n+@Rule(key = \"S5917\")\n+public class DateTimeFormatterMismatchCheck extends IssuableSubscriptionVisitor {\n+  private static final MethodMatchers OF_PATTERN_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatter\")\n+    .names(\"ofPattern\")\n+    .addParametersMatcher(\"java.lang.String\")\n+    .addParametersMatcher(\"java.lang.String\", \"java.util.Locale\")\n+    .build();\n+\n+  private static final MethodMatchers APPEND_VALUE_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatterBuilder\")\n+    .names(\"appendValue\")\n+    .addParametersMatcher(\"java.time.temporal.TemporalField\", \"int\")\n+    .build();\n+\n+  private static final MethodMatchers WEEK_BASED_YEAR_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.temporal.WeekFields\")\n+    .names(\"weekBasedYear\")\n+    .addWithoutParametersMatcher()\n+    .build();\n+\n+  private static final MethodMatchers WEEK_OF_WEEK_BASED_YEAR_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.temporal.WeekFields\")\n+    .names(\"weekOfWeekBasedYear\")\n+    .addWithoutParametersMatcher()\n+    .build();\n+\n+  private static final Pattern WEEK_PATTERN = Pattern.compile(\".*ww{1,2}.*\");\n+  private static final Pattern YEAR_OF_ERA_PATTERN = Pattern.compile(\".*[uy]+.*\");\n+\n+  private static final String CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE = \"Change this year format to use the week-based year instead.\";\n+  private static final String CHANGE_YEAR_FORMAT_TO_CHRONOFIELD_MESSAGE = \"Change this year format to use ChronoField.YEAR instead.\";\n+  private static final String SECONDARY_LOCATION_MESSAGE = \"\";\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    MethodInvocationTree invocation = (MethodInvocationTree) tree;\n+    if (OF_PATTERN_MATCHER.matches(invocation)) {\n+      visitPattern(invocation);\n+    } else if (APPEND_VALUE_MATCHER.matches(invocation)) {\n+      ChainedInvocationVisitor visitor = new ChainedInvocationVisitor();\n+      invocation.accept(visitor);\n+      if (!visitor.usesWeek || !visitor.usesYear) {\n+        return;\n+      }\n+      if (visitor.usesWeekBasedYear && !visitor.usesWeekOfWeekBasedYear) {\n+        reportIssue(visitor.primary, CHANGE_YEAR_FORMAT_TO_CHRONOFIELD_MESSAGE, visitor.locations, null);\n+      } else if (!visitor.usesWeekBasedYear && visitor.usesWeekOfWeekBasedYear) {\n+        reportIssue(visitor.primary, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE, visitor.locations, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * We currently only check formatters initialized with a String literal or the value of a final variable.\n+   */\n+  private void visitPattern(MethodInvocationTree invocation) {\n+    Arguments arguments = invocation.arguments();\n+    ExpressionTree argument = arguments.get(0);\n+    if (argument.is(Tree.Kind.STRING_LITERAL)) {\n+      String pattern = ((LiteralTree) argument).value();\n+      if (isInfringingPattern(pattern)) {\n+        reportIssue(invocation, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE);\n+      }\n+    } else if (argument.is(Tree.Kind.IDENTIFIER)) {\n+      IdentifierTree identifier = (IdentifierTree) argument;\n+      Symbol symbol = identifier.symbol();\n+      if (!symbol.isFinal()) {\n+        return;\n+      }\n+      Tree declaration = symbol.declaration();\n+      Optional<String> pattern = getStringLiteralValue(declaration);\n+      if (pattern.isPresent() && isInfringingPattern(pattern.get())) {\n+        reportIssue(invocation, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE);\n+      }\n+    }\n+  }\n+\n+  private static Optional<String> getStringLiteralValue(Tree declaration) {\n+    if (declaration == null || !declaration.is(Tree.Kind.VARIABLE)) {\n+      return Optional.empty();\n+    }\n+    VariableTree variable = (VariableTree) declaration;\n+    ExpressionTree initializer = variable.initializer();\n+    if (initializer == null || !initializer.is(Tree.Kind.STRING_LITERAL)) {\n+      return Optional.empty();\n+    }\n+    return Optional.of(((LiteralTree) initializer).value());\n+  }\n+\n+  private static boolean isInfringingPattern(String pattern) {\n+    return WEEK_PATTERN.matcher(pattern).matches() && YEAR_OF_ERA_PATTERN.matcher(pattern).matches();\n+  }\n+\n+  private static boolean refersToWeek(ExpressionTree argument) {\n+    return isChronoFieldWeek(argument) || isWeekOfWeekBasedYearUsed(argument);\n+  }\n+\n+  private static boolean isWeekOfWeekBasedYearUsed(ExpressionTree argument) {\n+    if (argument.is(Tree.Kind.METHOD_INVOCATION)) {\n+      MethodInvocationTree call = (MethodInvocationTree) argument;\n+      return WEEK_OF_WEEK_BASED_YEAR_MATCHER.matches(call);\n+    }\n+    return false;\n+  }\n+\n+  private static boolean isChronoFieldWeek(ExpressionTree argument) {\n+    if (argument.is(Tree.Kind.MEMBER_SELECT)) {\n+      MemberSelectExpressionTree select = (MemberSelectExpressionTree) argument;\n+      IdentifierTree identifier = select.identifier();\n+      return identifier.name().equals(\"ALIGNED_WEEK_OF_YEAR\");", "originalCommit": "9e5880dfaaf407e40c570f8916ac17c9abaa31b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MDIxNDAwMQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3365#discussion_r550214001", "bodyText": "Same here:\nreturn select.symbolType().is(\"java.time.temporal.ChronoField\") && identifier.name().equals(\"YEAR\");", "author": "christophe-zurn-sonarsource", "createdAt": "2020-12-30T14:31:38Z", "path": "java-checks/src/main/java/org/sonar/java/checks/DateTimeFormatterMismatchCheck.java", "diffHunk": "@@ -0,0 +1,221 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.JavaFileScannerContext;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.tree.Arguments;\n+import org.sonar.plugins.java.api.tree.BaseTreeVisitor;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.LiteralTree;\n+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.VariableTree;\n+\n+@Rule(key = \"S5917\")\n+public class DateTimeFormatterMismatchCheck extends IssuableSubscriptionVisitor {\n+  private static final MethodMatchers OF_PATTERN_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatter\")\n+    .names(\"ofPattern\")\n+    .addParametersMatcher(\"java.lang.String\")\n+    .addParametersMatcher(\"java.lang.String\", \"java.util.Locale\")\n+    .build();\n+\n+  private static final MethodMatchers APPEND_VALUE_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.format.DateTimeFormatterBuilder\")\n+    .names(\"appendValue\")\n+    .addParametersMatcher(\"java.time.temporal.TemporalField\", \"int\")\n+    .build();\n+\n+  private static final MethodMatchers WEEK_BASED_YEAR_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.temporal.WeekFields\")\n+    .names(\"weekBasedYear\")\n+    .addWithoutParametersMatcher()\n+    .build();\n+\n+  private static final MethodMatchers WEEK_OF_WEEK_BASED_YEAR_MATCHER = MethodMatchers.create()\n+    .ofTypes(\"java.time.temporal.WeekFields\")\n+    .names(\"weekOfWeekBasedYear\")\n+    .addWithoutParametersMatcher()\n+    .build();\n+\n+  private static final Pattern WEEK_PATTERN = Pattern.compile(\".*ww{1,2}.*\");\n+  private static final Pattern YEAR_OF_ERA_PATTERN = Pattern.compile(\".*[uy]+.*\");\n+\n+  private static final String CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE = \"Change this year format to use the week-based year instead.\";\n+  private static final String CHANGE_YEAR_FORMAT_TO_CHRONOFIELD_MESSAGE = \"Change this year format to use ChronoField.YEAR instead.\";\n+  private static final String SECONDARY_LOCATION_MESSAGE = \"\";\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Collections.singletonList(Tree.Kind.METHOD_INVOCATION);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    MethodInvocationTree invocation = (MethodInvocationTree) tree;\n+    if (OF_PATTERN_MATCHER.matches(invocation)) {\n+      visitPattern(invocation);\n+    } else if (APPEND_VALUE_MATCHER.matches(invocation)) {\n+      ChainedInvocationVisitor visitor = new ChainedInvocationVisitor();\n+      invocation.accept(visitor);\n+      if (!visitor.usesWeek || !visitor.usesYear) {\n+        return;\n+      }\n+      if (visitor.usesWeekBasedYear && !visitor.usesWeekOfWeekBasedYear) {\n+        reportIssue(visitor.primary, CHANGE_YEAR_FORMAT_TO_CHRONOFIELD_MESSAGE, visitor.locations, null);\n+      } else if (!visitor.usesWeekBasedYear && visitor.usesWeekOfWeekBasedYear) {\n+        reportIssue(visitor.primary, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE, visitor.locations, null);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * We currently only check formatters initialized with a String literal or the value of a final variable.\n+   */\n+  private void visitPattern(MethodInvocationTree invocation) {\n+    Arguments arguments = invocation.arguments();\n+    ExpressionTree argument = arguments.get(0);\n+    if (argument.is(Tree.Kind.STRING_LITERAL)) {\n+      String pattern = ((LiteralTree) argument).value();\n+      if (isInfringingPattern(pattern)) {\n+        reportIssue(invocation, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE);\n+      }\n+    } else if (argument.is(Tree.Kind.IDENTIFIER)) {\n+      IdentifierTree identifier = (IdentifierTree) argument;\n+      Symbol symbol = identifier.symbol();\n+      if (!symbol.isFinal()) {\n+        return;\n+      }\n+      Tree declaration = symbol.declaration();\n+      Optional<String> pattern = getStringLiteralValue(declaration);\n+      if (pattern.isPresent() && isInfringingPattern(pattern.get())) {\n+        reportIssue(invocation, CHANGE_YEAR_FORMAT_WEEK_BASED_MESSAGE);\n+      }\n+    }\n+  }\n+\n+  private static Optional<String> getStringLiteralValue(Tree declaration) {\n+    if (declaration == null || !declaration.is(Tree.Kind.VARIABLE)) {\n+      return Optional.empty();\n+    }\n+    VariableTree variable = (VariableTree) declaration;\n+    ExpressionTree initializer = variable.initializer();\n+    if (initializer == null || !initializer.is(Tree.Kind.STRING_LITERAL)) {\n+      return Optional.empty();\n+    }\n+    return Optional.of(((LiteralTree) initializer).value());\n+  }\n+\n+  private static boolean isInfringingPattern(String pattern) {\n+    return WEEK_PATTERN.matcher(pattern).matches() && YEAR_OF_ERA_PATTERN.matcher(pattern).matches();\n+  }\n+\n+  private static boolean refersToWeek(ExpressionTree argument) {\n+    return isChronoFieldWeek(argument) || isWeekOfWeekBasedYearUsed(argument);\n+  }\n+\n+  private static boolean isWeekOfWeekBasedYearUsed(ExpressionTree argument) {\n+    if (argument.is(Tree.Kind.METHOD_INVOCATION)) {\n+      MethodInvocationTree call = (MethodInvocationTree) argument;\n+      return WEEK_OF_WEEK_BASED_YEAR_MATCHER.matches(call);\n+    }\n+    return false;\n+  }\n+\n+  private static boolean isChronoFieldWeek(ExpressionTree argument) {\n+    if (argument.is(Tree.Kind.MEMBER_SELECT)) {\n+      MemberSelectExpressionTree select = (MemberSelectExpressionTree) argument;\n+      IdentifierTree identifier = select.identifier();\n+      return identifier.name().equals(\"ALIGNED_WEEK_OF_YEAR\");\n+    }\n+    return false;\n+  }\n+\n+  private static boolean refersToYear(ExpressionTree argument) {\n+    return isChronoFieldYear(argument) || isWeekBasedYearUsed(argument);\n+  }\n+\n+  private static boolean isWeekBasedYearUsed(ExpressionTree argument) {\n+    if (argument.is(Tree.Kind.METHOD_INVOCATION)) {\n+      MethodInvocationTree call = (MethodInvocationTree) argument;\n+      return WEEK_BASED_YEAR_MATCHER.matches(call);\n+    }\n+    return false;\n+  }\n+\n+  private static boolean isChronoFieldYear(ExpressionTree argument) {\n+    if (argument.is(Tree.Kind.MEMBER_SELECT)) {\n+      MemberSelectExpressionTree select = (MemberSelectExpressionTree) argument;\n+      IdentifierTree identifier = select.identifier();\n+      return identifier.name().equals(\"YEAR\");", "originalCommit": "9e5880dfaaf407e40c570f8916ac17c9abaa31b2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "0900114486158af731caf8553facbb796944b639", "url": "https://github.com/SonarSource/sonar-java/commit/0900114486158af731caf8553facbb796944b639", "message": "SONARJAVA-3480 More changes from  review and code smells cleanup", "committedDate": "2020-12-30T14:47:49Z", "type": "commit"}, {"oid": "be3f88e7e95fabdd9053a675d665f3358f3bc8a1", "url": "https://github.com/SonarSource/sonar-java/commit/be3f88e7e95fabdd9053a675d665f3358f3bc8a1", "message": "SONARJAVA-3480: Add more cases ignored by the rule", "committedDate": "2020-12-30T16:09:38Z", "type": "commit"}]}