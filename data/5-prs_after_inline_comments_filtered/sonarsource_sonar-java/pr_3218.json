{"pr_number": 3218, "pr_title": "SONARJAVA-3525 S2333 supports redundant modifiers on nested interfaces and classes", "pr_createdAt": "2020-09-28T13:54:49Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/3218", "timeline": [{"oid": "ceebf35cc48dc5a16910be8a583d93ac421b6c77", "url": "https://github.com/SonarSource/sonar-java/commit/ceebf35cc48dc5a16910be8a583d93ac421b6c77", "message": "Move S2333 tests files to compiled module", "committedDate": "2020-09-28T12:49:28Z", "type": "commit"}, {"oid": "119fd0414c19dd689fe77fd062450fb5c0e6e3c0", "url": "https://github.com/SonarSource/sonar-java/commit/119fd0414c19dd689fe77fd062450fb5c0e6e3c0", "message": "SONARJAVA-3525 S2333 supports redundant modifiers on nested interfaces and classes", "committedDate": "2020-09-28T15:04:40Z", "type": "commit"}, {"oid": "119fd0414c19dd689fe77fd062450fb5c0e6e3c0", "url": "https://github.com/SonarSource/sonar-java/commit/119fd0414c19dd689fe77fd062450fb5c0e6e3c0", "message": "SONARJAVA-3525 S2333 supports redundant modifiers on nested interfaces and classes", "committedDate": "2020-09-28T15:04:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjQ3MDAzMg==", "url": "https://github.com/SonarSource/sonar-java/pull/3218#discussion_r496470032", "bodyText": "Maybe it would be nice to have a method 'checkRedundantmodifiers' with vararg argument of Modifiers, so you can call it once with a couple of modifiers", "author": "margarita-nedzelska-sonarsource", "createdAt": "2020-09-29T07:17:50Z", "path": "java-checks/src/main/java/org/sonar/java/checks/RedundantModifierCheck.java", "diffHunk": "@@ -64,6 +64,13 @@ public void visitNode(Tree tree) {\n         checkRedundantModifier(modifiers, Modifier.FINAL);\n       } else if(member.is(Kind.CONSTRUCTOR) && tree.is(Kind.ENUM)) {\n         checkRedundantModifier(((MethodTree) member).modifiers(), Modifier.PRIVATE);\n+      } else if (member.is(Kind.CLASS, Kind.INTERFACE) && isInterfaceOrAnnotation(tree)) {\n+        ClassTree nested = (ClassTree) member;\n+        ModifiersTree modifiers = nested.modifiers();\n+        checkRedundantModifier(modifiers, Modifier.PUBLIC);", "originalCommit": "119fd0414c19dd689fe77fd062450fb5c0e6e3c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjUxMjEzMg==", "url": "https://github.com/SonarSource/sonar-java/pull/3218#discussion_r496512132", "bodyText": "In general I'll suggest to refactor it switch {} to have sth like this:\nswitch (member.kind()) {\n        case METHOD:\n          checkMethod(classTree, (MethodTree) member);\n          break;\n        case VARIABLE:\n          checkVariable(classTree, (VariableTree) member);\n          break;\n        case CONSTRUCTOR: ...\n        case CLASS: ...\n        case INTERFACE: ...\n\n      }\n\nTo my mind it will be more readable, too many else if is quite difficult to understand", "author": "margarita-nedzelska-sonarsource", "createdAt": "2020-09-29T08:15:07Z", "path": "java-checks/src/main/java/org/sonar/java/checks/RedundantModifierCheck.java", "diffHunk": "@@ -64,6 +64,13 @@ public void visitNode(Tree tree) {\n         checkRedundantModifier(modifiers, Modifier.FINAL);\n       } else if(member.is(Kind.CONSTRUCTOR) && tree.is(Kind.ENUM)) {\n         checkRedundantModifier(((MethodTree) member).modifiers(), Modifier.PRIVATE);\n+      } else if (member.is(Kind.CLASS, Kind.INTERFACE) && isInterfaceOrAnnotation(tree)) {\n+        ClassTree nested = (ClassTree) member;\n+        ModifiersTree modifiers = nested.modifiers();\n+        checkRedundantModifier(modifiers, Modifier.PUBLIC);\n+        checkRedundantModifier(modifiers, Modifier.STATIC);\n+      } else if (member.is(Kind.INTERFACE) && tree.is(Kind.CLASS, Kind.ENUM)) {\n+        checkRedundantModifier(((ClassTree) member).modifiers(), Modifier.STATIC);", "originalCommit": "119fd0414c19dd689fe77fd062450fb5c0e6e3c0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "f57a30d86c32603ca1d1125321068b342b269adb", "url": "https://github.com/SonarSource/sonar-java/commit/f57a30d86c32603ca1d1125321068b342b269adb", "message": "Refactor code for readability", "committedDate": "2020-09-29T09:49:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYxMDk1OA==", "url": "https://github.com/SonarSource/sonar-java/pull/3218#discussion_r496610958", "bodyText": "Maybe it would be nice to rename it to sth more general like checkNestedType. Cause this method is used on both classes and interfaces, so a little bit confusing.", "author": "margarita-nedzelska-sonarsource", "createdAt": "2020-09-29T10:29:58Z", "path": "java-checks/src/main/java/org/sonar/java/checks/RedundantModifierCheck.java", "diffHunk": "@@ -47,35 +47,71 @@\n   public void visitNode(Tree tree) {\n     ClassTree classTree = (ClassTree) tree;\n     for (Tree member : classTree.members()) {\n-      if (member.is(Tree.Kind.METHOD)) {\n-        MethodTree methodTree = (MethodTree) member;\n-        ModifiersTree modifiers = methodTree.modifiers();\n-        if (isInterfaceOrAnnotation(tree)) {\n-          checkRedundantModifier(modifiers, Modifier.ABSTRACT);\n-          checkRedundantModifier(modifiers, Modifier.PUBLIC);\n-        } else if (ModifiersUtils.hasModifier(classTree.modifiers(), Modifier.FINAL)) {\n-          checkRedundantModifier(modifiers, Modifier.FINAL);\n-        }\n-      } else if (member.is(Tree.Kind.VARIABLE) && isInterfaceOrAnnotation(tree)) {\n-        VariableTree variableTree = (VariableTree) member;\n-        ModifiersTree modifiers = variableTree.modifiers();\n-        checkRedundantModifier(modifiers, Modifier.PUBLIC);\n-        checkRedundantModifier(modifiers, Modifier.STATIC);\n-        checkRedundantModifier(modifiers, Modifier.FINAL);\n-      } else if(member.is(Kind.CONSTRUCTOR) && tree.is(Kind.ENUM)) {\n-        checkRedundantModifier(((MethodTree) member).modifiers(), Modifier.PRIVATE);\n+      switch (member.kind()) {\n+        case METHOD:\n+          checkMethod((MethodTree) member, classTree);\n+          break;\n+        case VARIABLE:\n+          checkVariable((VariableTree) member, classTree);\n+          break;\n+        case CONSTRUCTOR:\n+          if (tree.is(Kind.ENUM)) {\n+            checkRedundantModifier(((MethodTree) member).modifiers(), Modifier.PRIVATE);\n+          }\n+          break;\n+        case INTERFACE:\n+          ClassTree nestedClass = (ClassTree) member;\n+          checkNestedInterface(nestedClass, classTree);\n+          checkNestedClass(nestedClass, classTree);\n+          break;\n+        case CLASS:\n+          checkNestedClass((ClassTree) member, classTree);\n+          break;\n+        default:\n+          // Do nothing for others members\n       }\n     }\n   }\n \n+  private void checkMethod(MethodTree methodTree, ClassTree classTree) {\n+    ModifiersTree modifiers = methodTree.modifiers();\n+    if (isInterfaceOrAnnotation(classTree)) {\n+      checkRedundantModifier(modifiers, Modifier.ABSTRACT, Modifier.PUBLIC);\n+    } else if (ModifiersUtils.hasModifier(classTree.modifiers(), Modifier.FINAL)) {\n+      checkRedundantModifier(modifiers, Modifier.FINAL);\n+    }\n+  }\n+\n+  private void checkVariable(VariableTree variableTree, ClassTree classTree) {\n+    if (isInterfaceOrAnnotation(classTree)) {\n+      ModifiersTree modifiers = variableTree.modifiers();\n+      checkRedundantModifier(modifiers, Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL);\n+    }\n+  }\n+\n+  private void checkNestedClass(ClassTree nested, ClassTree classTree) {", "originalCommit": "f57a30d86c32603ca1d1125321068b342b269adb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYxMTc4Mw==", "url": "https://github.com/SonarSource/sonar-java/pull/3218#discussion_r496611783", "bodyText": "Maybe 'Modifiers'?", "author": "margarita-nedzelska-sonarsource", "createdAt": "2020-09-29T10:31:24Z", "path": "java-checks/src/main/java/org/sonar/java/checks/RedundantModifierCheck.java", "diffHunk": "@@ -47,35 +47,71 @@\n   public void visitNode(Tree tree) {\n     ClassTree classTree = (ClassTree) tree;\n     for (Tree member : classTree.members()) {\n-      if (member.is(Tree.Kind.METHOD)) {\n-        MethodTree methodTree = (MethodTree) member;\n-        ModifiersTree modifiers = methodTree.modifiers();\n-        if (isInterfaceOrAnnotation(tree)) {\n-          checkRedundantModifier(modifiers, Modifier.ABSTRACT);\n-          checkRedundantModifier(modifiers, Modifier.PUBLIC);\n-        } else if (ModifiersUtils.hasModifier(classTree.modifiers(), Modifier.FINAL)) {\n-          checkRedundantModifier(modifiers, Modifier.FINAL);\n-        }\n-      } else if (member.is(Tree.Kind.VARIABLE) && isInterfaceOrAnnotation(tree)) {\n-        VariableTree variableTree = (VariableTree) member;\n-        ModifiersTree modifiers = variableTree.modifiers();\n-        checkRedundantModifier(modifiers, Modifier.PUBLIC);\n-        checkRedundantModifier(modifiers, Modifier.STATIC);\n-        checkRedundantModifier(modifiers, Modifier.FINAL);\n-      } else if(member.is(Kind.CONSTRUCTOR) && tree.is(Kind.ENUM)) {\n-        checkRedundantModifier(((MethodTree) member).modifiers(), Modifier.PRIVATE);\n+      switch (member.kind()) {\n+        case METHOD:\n+          checkMethod((MethodTree) member, classTree);\n+          break;\n+        case VARIABLE:\n+          checkVariable((VariableTree) member, classTree);\n+          break;\n+        case CONSTRUCTOR:\n+          if (tree.is(Kind.ENUM)) {\n+            checkRedundantModifier(((MethodTree) member).modifiers(), Modifier.PRIVATE);\n+          }\n+          break;\n+        case INTERFACE:\n+          ClassTree nestedClass = (ClassTree) member;\n+          checkNestedInterface(nestedClass, classTree);\n+          checkNestedClass(nestedClass, classTree);\n+          break;\n+        case CLASS:\n+          checkNestedClass((ClassTree) member, classTree);\n+          break;\n+        default:\n+          // Do nothing for others members\n       }\n     }\n   }\n \n+  private void checkMethod(MethodTree methodTree, ClassTree classTree) {\n+    ModifiersTree modifiers = methodTree.modifiers();\n+    if (isInterfaceOrAnnotation(classTree)) {\n+      checkRedundantModifier(modifiers, Modifier.ABSTRACT, Modifier.PUBLIC);\n+    } else if (ModifiersUtils.hasModifier(classTree.modifiers(), Modifier.FINAL)) {\n+      checkRedundantModifier(modifiers, Modifier.FINAL);\n+    }\n+  }\n+\n+  private void checkVariable(VariableTree variableTree, ClassTree classTree) {\n+    if (isInterfaceOrAnnotation(classTree)) {\n+      ModifiersTree modifiers = variableTree.modifiers();\n+      checkRedundantModifier(modifiers, Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL);\n+    }\n+  }\n+\n+  private void checkNestedClass(ClassTree nested, ClassTree classTree) {\n+    if (isInterfaceOrAnnotation(classTree)) {\n+      ModifiersTree modifiers = nested.modifiers();\n+      checkRedundantModifier(modifiers, Modifier.PUBLIC, Modifier.STATIC);\n+    }\n+  }\n+\n+  private void checkNestedInterface(ClassTree nested, ClassTree classTree) {\n+    if (classTree.is(Kind.CLASS, Kind.ENUM)) {\n+      checkRedundantModifier(nested.modifiers(), Modifier.STATIC);\n+    }\n+  }\n+\n   private static boolean isInterfaceOrAnnotation(Tree tree) {\n     return tree.is(Tree.Kind.INTERFACE, Tree.Kind.ANNOTATION_TYPE);\n   }\n \n-  private void checkRedundantModifier(ModifiersTree modifiersTree, Modifier modifier) {\n-    ModifierKeywordTree foundModifier = ModifiersUtils.getModifier(modifiersTree, modifier);\n-    if (foundModifier != null) {\n-      reportIssue(foundModifier, \"\\\"\" + modifier.toString().toLowerCase(Locale.US) + \"\\\" is redundant in this context.\");\n+  private void checkRedundantModifier(ModifiersTree modifiersTree, Modifier... modifiers) {", "originalCommit": "f57a30d86c32603ca1d1125321068b342b269adb", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYxMzk3Mw==", "url": "https://github.com/SonarSource/sonar-java/pull/3218#discussion_r496613973", "bodyText": "I'll suggest also to have a String representation of each modifier somewhere in utils or helpers. Cause it's not optimal to have modifier.toString().toLowerCase(Locale.US)  each time we need it.\nAlso, that's up to you, personally I prefer String.format() over String concat.", "author": "margarita-nedzelska-sonarsource", "createdAt": "2020-09-29T10:35:16Z", "path": "java-checks/src/main/java/org/sonar/java/checks/RedundantModifierCheck.java", "diffHunk": "@@ -47,35 +47,71 @@\n   public void visitNode(Tree tree) {\n     ClassTree classTree = (ClassTree) tree;\n     for (Tree member : classTree.members()) {\n-      if (member.is(Tree.Kind.METHOD)) {\n-        MethodTree methodTree = (MethodTree) member;\n-        ModifiersTree modifiers = methodTree.modifiers();\n-        if (isInterfaceOrAnnotation(tree)) {\n-          checkRedundantModifier(modifiers, Modifier.ABSTRACT);\n-          checkRedundantModifier(modifiers, Modifier.PUBLIC);\n-        } else if (ModifiersUtils.hasModifier(classTree.modifiers(), Modifier.FINAL)) {\n-          checkRedundantModifier(modifiers, Modifier.FINAL);\n-        }\n-      } else if (member.is(Tree.Kind.VARIABLE) && isInterfaceOrAnnotation(tree)) {\n-        VariableTree variableTree = (VariableTree) member;\n-        ModifiersTree modifiers = variableTree.modifiers();\n-        checkRedundantModifier(modifiers, Modifier.PUBLIC);\n-        checkRedundantModifier(modifiers, Modifier.STATIC);\n-        checkRedundantModifier(modifiers, Modifier.FINAL);\n-      } else if(member.is(Kind.CONSTRUCTOR) && tree.is(Kind.ENUM)) {\n-        checkRedundantModifier(((MethodTree) member).modifiers(), Modifier.PRIVATE);\n+      switch (member.kind()) {\n+        case METHOD:\n+          checkMethod((MethodTree) member, classTree);\n+          break;\n+        case VARIABLE:\n+          checkVariable((VariableTree) member, classTree);\n+          break;\n+        case CONSTRUCTOR:\n+          if (tree.is(Kind.ENUM)) {\n+            checkRedundantModifier(((MethodTree) member).modifiers(), Modifier.PRIVATE);\n+          }\n+          break;\n+        case INTERFACE:\n+          ClassTree nestedClass = (ClassTree) member;\n+          checkNestedInterface(nestedClass, classTree);\n+          checkNestedClass(nestedClass, classTree);\n+          break;\n+        case CLASS:\n+          checkNestedClass((ClassTree) member, classTree);\n+          break;\n+        default:\n+          // Do nothing for others members\n       }\n     }\n   }\n \n+  private void checkMethod(MethodTree methodTree, ClassTree classTree) {\n+    ModifiersTree modifiers = methodTree.modifiers();\n+    if (isInterfaceOrAnnotation(classTree)) {\n+      checkRedundantModifier(modifiers, Modifier.ABSTRACT, Modifier.PUBLIC);\n+    } else if (ModifiersUtils.hasModifier(classTree.modifiers(), Modifier.FINAL)) {\n+      checkRedundantModifier(modifiers, Modifier.FINAL);\n+    }\n+  }\n+\n+  private void checkVariable(VariableTree variableTree, ClassTree classTree) {\n+    if (isInterfaceOrAnnotation(classTree)) {\n+      ModifiersTree modifiers = variableTree.modifiers();\n+      checkRedundantModifier(modifiers, Modifier.PUBLIC, Modifier.STATIC, Modifier.FINAL);\n+    }\n+  }\n+\n+  private void checkNestedClass(ClassTree nested, ClassTree classTree) {\n+    if (isInterfaceOrAnnotation(classTree)) {\n+      ModifiersTree modifiers = nested.modifiers();\n+      checkRedundantModifier(modifiers, Modifier.PUBLIC, Modifier.STATIC);\n+    }\n+  }\n+\n+  private void checkNestedInterface(ClassTree nested, ClassTree classTree) {\n+    if (classTree.is(Kind.CLASS, Kind.ENUM)) {\n+      checkRedundantModifier(nested.modifiers(), Modifier.STATIC);\n+    }\n+  }\n+\n   private static boolean isInterfaceOrAnnotation(Tree tree) {\n     return tree.is(Tree.Kind.INTERFACE, Tree.Kind.ANNOTATION_TYPE);\n   }\n \n-  private void checkRedundantModifier(ModifiersTree modifiersTree, Modifier modifier) {\n-    ModifierKeywordTree foundModifier = ModifiersUtils.getModifier(modifiersTree, modifier);\n-    if (foundModifier != null) {\n-      reportIssue(foundModifier, \"\\\"\" + modifier.toString().toLowerCase(Locale.US) + \"\\\" is redundant in this context.\");\n+  private void checkRedundantModifier(ModifiersTree modifiersTree, Modifier... modifiers) {\n+    for (Modifier modifier : modifiers) {\n+      ModifierKeywordTree foundModifier = ModifiersUtils.getModifier(modifiersTree, modifier);\n+      if (foundModifier != null) {\n+        reportIssue(foundModifier, \"\\\"\" + modifier.toString().toLowerCase(Locale.US) + \"\\\" is redundant in this context.\");", "originalCommit": "f57a30d86c32603ca1d1125321068b342b269adb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjY4MjcyNg==", "url": "https://github.com/SonarSource/sonar-java/pull/3218#discussion_r496682726", "bodyText": "I agree for the String.format().\n\nit's not optimal to have modifier.toString().toLowerCase(Locale.US)\n\nI refactored the code to have foundModifier.keyword().text(), I feel that it's slightly better (at least, we do not recompute toLowerCase...).\nIn any way, we will only call this code when an issue is reported, so it should not be too frequent.\n@margarita-nedzelska-sonarsource does it look better to you this way?", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-09-29T12:40:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYxMzk3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njc3OTgzMw==", "url": "https://github.com/SonarSource/sonar-java/pull/3218#discussion_r496779833", "bodyText": "LGTM", "author": "margarita-nedzelska-sonarsource", "createdAt": "2020-09-29T14:47:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjYxMzk3Mw=="}], "type": "inlineReview"}, {"oid": "72ba4ac8fb2b59b4d41522bd3e7f59da8d22413e", "url": "https://github.com/SonarSource/sonar-java/commit/72ba4ac8fb2b59b4d41522bd3e7f59da8d22413e", "message": "Fix from review", "committedDate": "2020-09-29T12:35:35Z", "type": "commit"}]}