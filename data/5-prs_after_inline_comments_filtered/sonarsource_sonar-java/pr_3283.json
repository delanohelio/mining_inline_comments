{"pr_number": 3283, "pr_title": "SONARJAVA-3557 Rule S6001: Back references in regular expressions should only refer to capturing groups that are matched before the reference", "pr_createdAt": "2020-11-17T17:43:21Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/3283", "timeline": [{"oid": "8076639e28ea0e7122712115e76528fb8196012c", "url": "https://github.com/SonarSource/sonar-java/commit/8076639e28ea0e7122712115e76528fb8196012c", "message": "SONARJAVA-3557 Rule S6001: Back references in regular expressions...\n\n... should only refer to capturing groups that are matched before the\nreference", "committedDate": "2020-11-17T18:00:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk3MTI4Ng==", "url": "https://github.com/SonarSource/sonar-java/pull/3283#discussion_r526971286", "bodyText": "findIn go through the automaton state successors to find CapturingGroupTrees\nIf we stop before the FinalState it's dangerous, we will not call markBackReferences for all groups.\nFor example:\nA valid regex \"(.)\\\\1(.)\\\\2\" that can match \"aabb\" raises a false-positive.\nBecause findIn visits successors before filling the groupNames, so the back reference \\\\1 is an impossiblePath and we stop the visit.", "author": "alban-auzeill", "createdAt": "2020-11-19T15:21:44Z", "path": "java-checks/src/main/java/org/sonar/java/checks/regex/ImpossibleBackReferenceCheck.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.regex;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.sonar.check.Rule;\n+import org.sonar.java.regex.RegexParseResult;\n+import org.sonar.java.regex.ast.AutomatonState;\n+import org.sonar.java.regex.ast.BackReferenceTree;\n+import org.sonar.java.regex.ast.CapturingGroupTree;\n+import org.sonar.java.regex.ast.RegexBaseVisitor;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+\n+@Rule(key = \"S6001\")\n+public class ImpossibleBackReferenceCheck extends AbstractRegexCheck {\n+\n+  @Override\n+  public void checkRegex(RegexParseResult regexForLiterals, MethodInvocationTree mit) {\n+    ValidBackReferenceFinder finder = new ValidBackReferenceFinder();\n+    finder.findIn(regexForLiterals.getStartState());\n+    CapturingGroupCollector groupCollector = new CapturingGroupCollector();\n+    groupCollector.visit(regexForLiterals);\n+    new ImpossibleBackReferenceFinder(finder.legalBackReferences, groupCollector.capturingGroups)\n+      .visit(regexForLiterals);\n+  }\n+\n+  private static class CapturingGroupCollector extends RegexBaseVisitor {\n+    private final Map<String, CapturingGroupTree> capturingGroups = new HashMap<>();\n+    @Override\n+    public void visitCapturingGroup(CapturingGroupTree group) {\n+      capturingGroups.put(\"\" + group.getGroupNumber(), group);\n+      group.getName().ifPresent(name -> capturingGroups.put(name, group));\n+      super.visitCapturingGroup(group);\n+    }\n+  }\n+\n+  private static class ValidBackReferenceFinder {\n+    private final Set<BackReferenceTree> legalBackReferences = new HashSet<>();\n+    private final Set<String> groupNames = new HashSet<>();\n+    private final Set<AutomatonState> visited = new HashSet<>();\n+\n+    public void findIn(AutomatonState state) {\n+      if (visited.contains(state) || impossiblePath(state)) {", "originalCommit": "8076639e28ea0e7122712115e76528fb8196012c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk4MzY2NA==", "url": "https://github.com/SonarSource/sonar-java/pull/3283#discussion_r526983664", "bodyText": "the parameter visited has the same name as the field, so it could be confused by the reader.", "author": "alban-auzeill", "createdAt": "2020-11-19T15:37:09Z", "path": "java-checks/src/main/java/org/sonar/java/checks/regex/ImpossibleBackReferenceCheck.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.regex;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.sonar.check.Rule;\n+import org.sonar.java.regex.RegexParseResult;\n+import org.sonar.java.regex.ast.AutomatonState;\n+import org.sonar.java.regex.ast.BackReferenceTree;\n+import org.sonar.java.regex.ast.CapturingGroupTree;\n+import org.sonar.java.regex.ast.RegexBaseVisitor;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+\n+@Rule(key = \"S6001\")\n+public class ImpossibleBackReferenceCheck extends AbstractRegexCheck {\n+\n+  @Override\n+  public void checkRegex(RegexParseResult regexForLiterals, MethodInvocationTree mit) {\n+    ValidBackReferenceFinder finder = new ValidBackReferenceFinder();\n+    finder.findIn(regexForLiterals.getStartState());\n+    CapturingGroupCollector groupCollector = new CapturingGroupCollector();\n+    groupCollector.visit(regexForLiterals);\n+    new ImpossibleBackReferenceFinder(finder.legalBackReferences, groupCollector.capturingGroups)\n+      .visit(regexForLiterals);\n+  }\n+\n+  private static class CapturingGroupCollector extends RegexBaseVisitor {\n+    private final Map<String, CapturingGroupTree> capturingGroups = new HashMap<>();\n+    @Override\n+    public void visitCapturingGroup(CapturingGroupTree group) {\n+      capturingGroups.put(\"\" + group.getGroupNumber(), group);\n+      group.getName().ifPresent(name -> capturingGroups.put(name, group));\n+      super.visitCapturingGroup(group);\n+    }\n+  }\n+\n+  private static class ValidBackReferenceFinder {\n+    private final Set<BackReferenceTree> legalBackReferences = new HashSet<>();\n+    private final Set<String> groupNames = new HashSet<>();\n+    private final Set<AutomatonState> visited = new HashSet<>();\n+\n+    public void findIn(AutomatonState state) {\n+      if (visited.contains(state) || impossiblePath(state)) {\n+        return;\n+      }\n+      visited.add(state);\n+      for (AutomatonState succ : state.successors()) {\n+        findIn(succ);\n+      }\n+      if (state instanceof CapturingGroupTree) {\n+        CapturingGroupTree group = (CapturingGroupTree) state;\n+        markBackReferences(group, group.continuation(), new HashSet<>());\n+        groupNames.add(\"\" + group.getGroupNumber());\n+        group.getName().ifPresent(groupNames::add);\n+      }\n+    }\n+\n+    private boolean impossiblePath(AutomatonState state) {\n+      return state instanceof BackReferenceTree && !groupNames.contains(((BackReferenceTree) state).groupName());\n+    }\n+\n+    private void markBackReferences(CapturingGroupTree group, AutomatonState state, Set<AutomatonState> visited) {", "originalCommit": "8076639e28ea0e7122712115e76528fb8196012c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjk5NDczNQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3283#discussion_r526994735", "bodyText": "IMO, the check will find a lot of CapturingGroupTree and a few BackReferenceTree.\nAnd the current algorithm browses the tree to find the groups and from each group browses the tree to mark valid references. From a performance perspective, it's not good to do all those lookups for nothing.\nI would prefer to first use a RegexBaseVisitor to collect all the BackReferenceTree, and to continue only if the list is not empty. Then the collected list can be used at the end instead of ImpossibleBackReferenceFinder visitor.", "author": "alban-auzeill", "createdAt": "2020-11-19T15:51:02Z", "path": "java-checks/src/main/java/org/sonar/java/checks/regex/ImpossibleBackReferenceCheck.java", "diffHunk": "@@ -0,0 +1,128 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.regex;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import org.sonar.check.Rule;\n+import org.sonar.java.regex.RegexParseResult;\n+import org.sonar.java.regex.ast.AutomatonState;\n+import org.sonar.java.regex.ast.BackReferenceTree;\n+import org.sonar.java.regex.ast.CapturingGroupTree;\n+import org.sonar.java.regex.ast.RegexBaseVisitor;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+\n+@Rule(key = \"S6001\")\n+public class ImpossibleBackReferenceCheck extends AbstractRegexCheck {\n+\n+  @Override\n+  public void checkRegex(RegexParseResult regexForLiterals, MethodInvocationTree mit) {\n+    ValidBackReferenceFinder finder = new ValidBackReferenceFinder();\n+    finder.findIn(regexForLiterals.getStartState());\n+    CapturingGroupCollector groupCollector = new CapturingGroupCollector();\n+    groupCollector.visit(regexForLiterals);\n+    new ImpossibleBackReferenceFinder(finder.legalBackReferences, groupCollector.capturingGroups)\n+      .visit(regexForLiterals);", "originalCommit": "8076639e28ea0e7122712115e76528fb8196012c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "67dff30f4b345a5b1c15c3c91da1b1c27c11d97e", "url": "https://github.com/SonarSource/sonar-java/commit/67dff30f4b345a5b1c15c3c91da1b1c27c11d97e", "message": "SONARJAVA-3557 Rule S6001: Back references in regular expressions...\n\n... should only refer to capturing groups that are matched before the\nreference", "committedDate": "2020-11-20T18:59:26Z", "type": "commit"}, {"oid": "9d7bc5524d85bdb40a8c0a5324bd6a14bed00407", "url": "https://github.com/SonarSource/sonar-java/commit/9d7bc5524d85bdb40a8c0a5324bd6a14bed00407", "message": "Rework algorithm to get rid of FPs without FNs", "committedDate": "2020-11-20T18:59:26Z", "type": "forcePushed"}, {"oid": "99a6bb60aa11b6560e4335c638fbba55264d4335", "url": "https://github.com/SonarSource/sonar-java/commit/99a6bb60aa11b6560e4335c638fbba55264d4335", "message": "Rework algorithm to get rid of FPs without FNs", "committedDate": "2020-11-23T13:13:42Z", "type": "commit"}, {"oid": "99a6bb60aa11b6560e4335c638fbba55264d4335", "url": "https://github.com/SonarSource/sonar-java/commit/99a6bb60aa11b6560e4335c638fbba55264d4335", "message": "Rework algorithm to get rid of FPs without FNs", "committedDate": "2020-11-23T13:13:42Z", "type": "forcePushed"}]}