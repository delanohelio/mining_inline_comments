{"pr_number": 3277, "pr_title": "SONARJAVA-3552 Rule S5996: Regex boundaries should not be used in a way that can never match", "pr_createdAt": "2020-11-16T17:59:37Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/3277", "timeline": [{"oid": "566cdadb43bcb57eaf914b29669b873006dfc6c0", "url": "https://github.com/SonarSource/sonar-java/commit/566cdadb43bcb57eaf914b29669b873006dfc6c0", "message": "SONARJAVA-3552 Rule S5996: Regex boundaries should not be used in...\n\n... a way that can never match", "committedDate": "2020-11-16T18:11:39Z", "type": "forcePushed"}, {"oid": "2b300f996cfc57147ff2765d94bf7a2d8c57ec9e", "url": "https://github.com/SonarSource/sonar-java/commit/2b300f996cfc57147ff2765d94bf7a2d8c57ec9e", "message": "SONARJAVA-3552 Rule S5996: Regex boundaries should not be used in...\n\n... a way that can never match", "committedDate": "2020-11-17T10:02:40Z", "type": "forcePushed"}, {"oid": "706e7e240eba90c1757f64ade20b2c9dd66f5108", "url": "https://github.com/SonarSource/sonar-java/commit/706e7e240eba90c1757f64ade20b2c9dd66f5108", "message": "SONARJAVA-3552 Rule S5996: Regex boundaries should not be used in...\n\n... a way that can never match", "committedDate": "2020-11-17T10:05:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAzMTk0OA==", "url": "https://github.com/SonarSource/sonar-java/pull/3277#discussion_r525031948", "bodyText": "Added these two test cases", "author": "sebastian-hungerecker-sonarsource", "createdAt": "2020-11-17T10:06:33Z", "path": "java-checks-test-sources/src/main/java/checks/regex/ImpossibleBoundariesCheck.java", "diffHunk": "@@ -0,0 +1,44 @@\n+package checks.regex;\n+\n+public class ImpossibleBoundariesCheck {\n+\n+  void noncompliant(String str) {\n+    // Noncompliant@+1 [[sc=18;ec=19]] {{Remove or replace this boundary that will never match because it appears before mandatory input.}}\n+    str.matches(\"$[a-z]^\"); // Noncompliant [[sc=24;ec=25]] {{Remove or replace this boundary that will never match because it appears after mandatory input.}}\n+    str.matches(\"$[a-z]\"); // Noncompliant [[sc=18;ec=19]] {{Remove or replace this boundary that will never match because it appears before mandatory input.}}\n+    str.matches(\"$(abc)\"); // Noncompliant [[sc=18;ec=19]]\n+    str.matches(\"[a-z]^\"); // Noncompliant [[sc=23;ec=24]]\n+    str.matches(\"\\\\Z[a-z]\"); // Noncompliant [[sc=18;ec=21]]\n+    str.matches(\"\\\\z[a-z]\"); // Noncompliant [[sc=18;ec=21]]\n+    str.matches(\"[a-z]\\\\A\"); // Noncompliant [[sc=23;ec=26]]\n+    str.matches(\"($)a\"); // Noncompliant [[sc=19;ec=20]]\n+    str.matches(\"a$|$a\"); // Noncompliant [[sc=21;ec=22]]\n+    str.matches(\"^a|a^\"); // Noncompliant [[sc=22;ec=23]]\n+    str.matches(\"a(b|^)\"); // Noncompliant [[sc=22;ec=23]]\n+    str.matches(\"(?=abc^)\"); // Noncompliant [[sc=24;ec=25]]\n+    str.matches(\"abc(?=^abc)\"); // Noncompliant [[sc=24;ec=25]]\n+    str.matches(\"abc(?<=$abc)\"); // Noncompliant [[sc=25;ec=26]]\n+    str.matches(\"abc(?<=abc$)def\"); // Noncompliant [[sc=28;ec=29]]\n+    str.matches(\"(?:abc(X|^))*Y?\"); // Noncompliant [[sc=27;ec=28]]\n+  }\n+\n+  void compliant(String str) {\n+    str.matches(\"^[a-z]$\");\n+    str.matches(\"^$\");\n+    str.matches(\"^(?i)$\");\n+    str.matches(\"^$(?i)\");\n+    str.matches(\"^abc$|^def$\");\n+    str.matches(\"(?i)^abc$\");\n+    str.matches(\"()^abc$\");\n+    str.matches(\"^abc$()\");\n+    str.matches(\"^abc$\\\\b\");\n+    str.matches(\"(?=abc)^abc$\");\n+    str.matches(\"(?=^abc$)abc\");", "originalCommit": "706e7e240eba90c1757f64ade20b2c9dd66f5108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAzMjk1OQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3277#discussion_r525032959", "bodyText": "Removed backtracking edges from the list of traversable edges and added the ||-exception instead, as well as the comment above.", "author": "sebastian-hungerecker-sonarsource", "createdAt": "2020-11-17T10:08:08Z", "path": "java-checks/src/main/java/org/sonar/java/checks/helpers/RegexTreeHelper.java", "diffHunk": "@@ -74,4 +79,29 @@ private static void addCurrentGrapheme(List<RegexCheck.RegexIssueLocation> resul\n     }\n   }\n \n+  public static boolean canReachWithoutConsumingInput(AutomatonState start, AutomatonState goal) {\n+    return canReachWithoutConsumingInput(start, goal, new HashSet<>());\n+  }\n+\n+  private static boolean canReachWithoutConsumingInput(AutomatonState start, AutomatonState goal, Set<AutomatonState> visited) {\n+    if (start == goal) {\n+      return true;\n+    }\n+    if (visited.contains(start)) {\n+      return false;\n+    }\n+    visited.add(start);\n+    for (AutomatonState successor : start.successors()) {\n+      // We don't generally consider elements behind backtracking edges to be 0-input reachable because what comes\n+      // after the edge won't directly follow what's before the edge. However, we do consider the end-of-lookahead\n+      // state itself reachable (but not any state behind it), so that we can check whether the end of the lookahead\n+      // can be reached without input from a given place within the lookahead.\n+      if ((successor.incomingTransitionType() == EPSILON && canReachWithoutConsumingInput(successor, goal, visited))\n+        || (successor instanceof EndOfLookaroundState && successor == goal)) {", "originalCommit": "706e7e240eba90c1757f64ade20b2c9dd66f5108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTAzMzM0Mg==", "url": "https://github.com/SonarSource/sonar-java/pull/3277#discussion_r525033342", "bodyText": "visitLookAround is new.", "author": "sebastian-hungerecker-sonarsource", "createdAt": "2020-11-17T10:08:47Z", "path": "java-checks/src/main/java/org/sonar/java/checks/regex/ImpossibleBoundariesCheck.java", "diffHunk": "@@ -0,0 +1,94 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.regex;\n+\n+import java.util.Collections;\n+import org.sonar.check.Rule;\n+import org.sonar.java.checks.helpers.RegexTreeHelper;\n+import org.sonar.java.regex.RegexParseResult;\n+import org.sonar.java.regex.ast.AutomatonState;\n+import org.sonar.java.regex.ast.BoundaryTree;\n+import org.sonar.java.regex.ast.LookAroundTree;\n+import org.sonar.java.regex.ast.RegexBaseVisitor;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+\n+@Rule(key = \"S5996\")\n+public class ImpossibleBoundariesCheck extends AbstractRegexCheck {\n+\n+  private static final String MESSAGE = \"Remove or replace this boundary that will never match because it appears %s mandatory input.\";\n+\n+  @Override\n+  public void checkRegex(RegexParseResult regexForLiterals, MethodInvocationTree mit) {\n+    new ImpossibleBoundaryFinder().visit(regexForLiterals);\n+  }\n+\n+  private class ImpossibleBoundaryFinder extends RegexBaseVisitor {\n+\n+    private AutomatonState start;\n+    private AutomatonState end;\n+\n+    @Override\n+    public void visit(RegexParseResult regexParseResult) {\n+      start = regexParseResult.getStartState();\n+      end = regexParseResult.getFinalState();\n+      super.visit(regexParseResult);\n+    }\n+\n+    @Override\n+    public void visitLookAround(LookAroundTree tree) {", "originalCommit": "706e7e240eba90c1757f64ade20b2c9dd66f5108", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "a37abcbb704648b5ec1e79070c85436b4e7f6342", "url": "https://github.com/SonarSource/sonar-java/commit/a37abcbb704648b5ec1e79070c85436b4e7f6342", "message": "Fix automaton construction for lookbehinds\n\nIn `a(?<=b)c` or `a(?<!b)c`, `c` should be reachable from `a` without\ngoing through any backtracking edges - those should only be necessary\nto reach `b`.", "committedDate": "2020-11-17T11:38:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTE2MDg1MQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3277#discussion_r525160851", "bodyText": "We should add:\n// FP we raises an issue below because the usage of $ in the middle of a regex is suspicious and redundant\nstr.matches(\"(?m)^1$\\n2\"); // Noncompliant", "author": "alban-auzeill", "createdAt": "2020-11-17T13:41:23Z", "path": "java-checks-test-sources/src/main/java/checks/regex/ImpossibleBoundariesCheck.java", "diffHunk": "@@ -0,0 +1,45 @@\n+package checks.regex;\n+\n+public class ImpossibleBoundariesCheck {\n+\n+  void noncompliant(String str) {\n+    // Noncompliant@+1 [[sc=18;ec=19]] {{Remove or replace this boundary that will never match because it appears before mandatory input.}}\n+    str.matches(\"$[a-z]^\"); // Noncompliant [[sc=24;ec=25]] {{Remove or replace this boundary that will never match because it appears after mandatory input.}}\n+    str.matches(\"$[a-z]\"); // Noncompliant [[sc=18;ec=19]] {{Remove or replace this boundary that will never match because it appears before mandatory input.}}\n+    str.matches(\"$(abc)\"); // Noncompliant [[sc=18;ec=19]]\n+    str.matches(\"[a-z]^\"); // Noncompliant [[sc=23;ec=24]]\n+    str.matches(\"\\\\Z[a-z]\"); // Noncompliant [[sc=18;ec=21]]\n+    str.matches(\"\\\\z[a-z]\"); // Noncompliant [[sc=18;ec=21]]\n+    str.matches(\"[a-z]\\\\A\"); // Noncompliant [[sc=23;ec=26]]\n+    str.matches(\"($)a\"); // Noncompliant [[sc=19;ec=20]]\n+    str.matches(\"a$|$a\"); // Noncompliant [[sc=21;ec=22]]\n+    str.matches(\"^a|a^\"); // Noncompliant [[sc=22;ec=23]]\n+    str.matches(\"a(b|^)\"); // Noncompliant [[sc=22;ec=23]]\n+    str.matches(\"(?=abc^)\"); // Noncompliant [[sc=24;ec=25]]\n+    str.matches(\"abc(?=^abc)\"); // Noncompliant [[sc=24;ec=25]]\n+    str.matches(\"abc(?<=$abc)\"); // Noncompliant [[sc=25;ec=26]]\n+    str.matches(\"abc(?<=abc$)def\"); // Noncompliant [[sc=28;ec=29]]\n+    str.matches(\"(?:abc(X|^))*Y?\"); // Noncompliant [[sc=27;ec=28]]\n+  }", "originalCommit": "a37abcbb704648b5ec1e79070c85436b4e7f6342", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "56e0545dfc40022d9381e9a594d4f963ecc59f62", "url": "https://github.com/SonarSource/sonar-java/commit/56e0545dfc40022d9381e9a594d4f963ecc59f62", "message": "Fix automaton construction for lookbehinds\n\nIn `a(?<=b)c` or `a(?<!b)c`, `c` should be reachable from `a` without\ngoing through any backtracking edges - those should only be necessary\nto reach `b`.", "committedDate": "2020-11-17T14:44:51Z", "type": "forcePushed"}, {"oid": "3554154a3aac6f4c93633bcebd8edaad95d655d3", "url": "https://github.com/SonarSource/sonar-java/commit/3554154a3aac6f4c93633bcebd8edaad95d655d3", "message": "SONARJAVA-3602 JavaCheckVerifier does not support consistent ...\n\n... behavior when having multiple issues reported on the same line", "committedDate": "2020-11-17T14:50:09Z", "type": "commit"}, {"oid": "2f1984f66d27a88d6d682d2eadac9fa30910a6a9", "url": "https://github.com/SonarSource/sonar-java/commit/2f1984f66d27a88d6d682d2eadac9fa30910a6a9", "message": "SONARJAVA-3551 Implement helper to find whether state in regex...\n\n... automaton is reachable without consuming input", "committedDate": "2020-11-17T14:51:44Z", "type": "commit"}, {"oid": "fe636f54d99b511e1f1398c69b30c3318a6b221c", "url": "https://github.com/SonarSource/sonar-java/commit/fe636f54d99b511e1f1398c69b30c3318a6b221c", "message": "SONARJAVA-3552 Rule S5996: Regex boundaries should not be used in...\n\n... a way that can never match", "committedDate": "2020-11-17T14:51:45Z", "type": "commit"}, {"oid": "bca2b9ad097f24e659bbfe52fa11234b33fc0956", "url": "https://github.com/SonarSource/sonar-java/commit/bca2b9ad097f24e659bbfe52fa11234b33fc0956", "message": "Fix automaton construction for lookbehinds\n\nIn `a(?<=b)c` or `a(?<!b)c`, `c` should be reachable from `a` without\ngoing through any backtracking edges - those should only be necessary\nto reach `b`.", "committedDate": "2020-11-17T14:51:45Z", "type": "commit"}, {"oid": "bca2b9ad097f24e659bbfe52fa11234b33fc0956", "url": "https://github.com/SonarSource/sonar-java/commit/bca2b9ad097f24e659bbfe52fa11234b33fc0956", "message": "Fix automaton construction for lookbehinds\n\nIn `a(?<=b)c` or `a(?<!b)c`, `c` should be reachable from `a` without\ngoing through any backtracking edges - those should only be necessary\nto reach `b`.", "committedDate": "2020-11-17T14:51:45Z", "type": "forcePushed"}]}