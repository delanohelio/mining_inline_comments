{"pr_number": 2948, "pr_title": "SONARJAVA-3346 Deprecate S1148 in favor of S4507", "pr_createdAt": "2020-05-06T17:33:25Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/2948", "timeline": [{"oid": "837b76177ce7d09f217cd07e3bdb6307cfaed247", "url": "https://github.com/SonarSource/sonar-java/commit/837b76177ce7d09f217cd07e3bdb6307cfaed247", "message": "SONARJAVA-3346 Deprecate S1148 in favor of S4507", "committedDate": "2020-05-06T18:30:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMyOTU0NQ==", "url": "https://github.com/SonarSource/sonar-java/pull/2948#discussion_r421329545", "bodyText": "\ud83d\ude31 the previous implementation of the rule was complex and not using the MethodMatchers API.\nwe should use a matcher like:\n  private static final MethodMatchers PRINT_STACK_TRACE_MATCHER = MethodMatchers.create()\n    .ofSubTypes(\"java.lang.Throwable\").names(\"printStackTrace\").addWithoutParametersMatcher().build();\n\nthem checkMethodInvocation will become far more easier to read:\n  private void checkMethodInvocation(MethodInvocationTree tree) {\n    if (PRINT_STACK_TRACE_MATCHER.matches(tree)) {\n      reportIssue(ExpressionUtils.methodName(tree), MESSAGE);\n    }\n  }", "author": "alban-auzeill", "createdAt": "2020-05-07T08:28:09Z", "path": "java-checks/src/main/java/org/sonar/java/checks/security/DebugFeatureEnabledCheck.java", "diffHunk": "@@ -19,32 +19,74 @@\n  */\n package org.sonar.java.checks.security;\n \n-import java.util.Collections;\n+import java.util.Arrays;\n+import java.util.Deque;\n+import java.util.LinkedList;\n import java.util.List;\n import java.util.Objects;\n import javax.annotation.CheckForNull;\n import org.sonar.check.Rule;\n import org.sonar.java.checks.helpers.ExpressionsHelper;\n import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n import org.sonar.plugins.java.api.tree.AnnotationTree;\n import org.sonar.plugins.java.api.tree.AssignmentExpressionTree;\n+import org.sonar.plugins.java.api.tree.ClassTree;\n import org.sonar.plugins.java.api.tree.ExpressionTree;\n import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n import org.sonar.plugins.java.api.tree.Tree;\n \n @Rule(key = \"S4507\")\n public class DebugFeatureEnabledCheck extends IssuableSubscriptionVisitor {\n \n   private static final String MESSAGE = \"Make sure this debug feature is deactivated before delivering the code in production.\";\n \n+  private final Deque<Symbol.TypeSymbol> enclosingClass = new LinkedList<>();\n+\n   @Override\n   public List<Tree.Kind> nodesToVisit() {\n-    return Collections.singletonList(Tree.Kind.ANNOTATION);\n+    return Arrays.asList(Tree.Kind.ANNOTATION, Tree.Kind.CLASS, Tree.Kind.METHOD_INVOCATION);\n   }\n \n   @Override\n   public void visitNode(Tree tree) {\n-    AnnotationTree annotation = (AnnotationTree) tree;\n+    switch (tree.kind()) {\n+      case ANNOTATION:\n+        checkAnnotation((AnnotationTree) tree);\n+        break;\n+      case METHOD_INVOCATION:\n+        checkMethodInvocation((MethodInvocationTree) tree);\n+        break;\n+      default:\n+        ClassTree classTree = (ClassTree) tree;\n+        enclosingClass.push(classTree.symbol());\n+        break;\n+    }\n+  }\n+\n+  @Override\n+  public void leaveNode(Tree tree) {\n+    if (tree instanceof ClassTree) {\n+      enclosingClass.pop();\n+    }\n+  }\n+\n+  private void checkMethodInvocation(MethodInvocationTree tree) {\n+    if (tree.methodSelect().is(Tree.Kind.MEMBER_SELECT)) {\n+      MemberSelectExpressionTree memberSelectExpressionTree = (MemberSelectExpressionTree) tree.methodSelect();\n+      IdentifierTree identifierTree = memberSelectExpressionTree.identifier();\n+      if (!enclosingClassExtendsThrowable()\n+        && \"printStackTrace\".equals(identifierTree.name())\n+        && calledOnTypeInheritedFromThrowable(memberSelectExpressionTree.expression())\n+        && tree.arguments().isEmpty()) {\n+        reportIssue(identifierTree, MESSAGE);\n+      }\n+    }\n+  }", "originalCommit": "837b76177ce7d09f217cd07e3bdb6307cfaed247", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzMjg2OQ==", "url": "https://github.com/SonarSource/sonar-java/pull/2948#discussion_r421332869", "bodyText": "With a MethodMatcher:\n\nthe above two methods can be removed\nenclosingClass field can be removed\nnodesToVisit() on  Tree.Kind.CLASS can be removed\nleaveNode() can be removed\n\n\ud83d\ude0e", "author": "alban-auzeill", "createdAt": "2020-05-07T08:33:32Z", "path": "java-checks/src/main/java/org/sonar/java/checks/security/DebugFeatureEnabledCheck.java", "diffHunk": "@@ -67,4 +109,12 @@ private static AssignmentExpressionTree getDebugArgument(ExpressionTree expressi\n     return null;\n   }\n \n+  private boolean enclosingClassExtendsThrowable() {\n+    return enclosingClass.peek() != null && enclosingClass.peek().type().isSubtypeOf(\"java.lang.Throwable\");\n+  }\n+\n+  private static boolean calledOnTypeInheritedFromThrowable(ExpressionTree tree) {\n+    return tree.symbolType().isSubtypeOf(\"java.lang.Throwable\");\n+  }\n+", "originalCommit": "837b76177ce7d09f217cd07e3bdb6307cfaed247", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM5ODY2Mw==", "url": "https://github.com/SonarSource/sonar-java/pull/2948#discussion_r421398663", "bodyText": "The enclosingClassExtendsThrowable method (along witht the enclosingClass field) is there to prevent issues from being reported when calling printWithStackTrace inside classes extending Throwable.\nAs far as I can tell there's no way to say \"Don't match when inside a class inheriting from X\" with MethodMatchers, so that part of the code seems to still be necessary.", "author": "sebastian-hungerecker-sonarsource", "createdAt": "2020-05-07T10:21:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzMjg2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQyNTUwNw==", "url": "https://github.com/SonarSource/sonar-java/pull/2948#discussion_r421425507", "bodyText": "You are right, we need to keep enclosingClass, I didn't understand it correctly previously.", "author": "alban-auzeill", "createdAt": "2020-05-07T11:13:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTMzMjg2OQ=="}], "type": "inlineReview"}, {"oid": "daf4f536d281b4726bb7a422468cc9657327df23", "url": "https://github.com/SonarSource/sonar-java/commit/daf4f536d281b4726bb7a422468cc9657327df23", "message": "SONARJAVA-3346 Deprecate S1148 in favor of S4507", "committedDate": "2020-05-07T10:16:39Z", "type": "commit"}, {"oid": "f54f3223c239a1ca03b9517383150f3ebc62e826", "url": "https://github.com/SonarSource/sonar-java/commit/f54f3223c239a1ca03b9517383150f3ebc62e826", "message": "Simplify code by using MethodMatchers", "committedDate": "2020-05-07T10:16:39Z", "type": "commit"}, {"oid": "f54f3223c239a1ca03b9517383150f3ebc62e826", "url": "https://github.com/SonarSource/sonar-java/commit/f54f3223c239a1ca03b9517383150f3ebc62e826", "message": "Simplify code by using MethodMatchers", "committedDate": "2020-05-07T10:16:39Z", "type": "forcePushed"}]}