{"pr_number": 2842, "pr_title": "SONARJAVA-3260 RSPEC-2612 Setting loose file permissions is security-sensitive", "pr_createdAt": "2020-02-24T17:07:23Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/2842", "timeline": [{"oid": "fd45394fa87554d009ec91cc90ddbe903e3bbb5a", "url": "https://github.com/SonarSource/sonar-java/commit/fd45394fa87554d009ec91cc90ddbe903e3bbb5a", "message": "SONARJAVA-3260 RSPEC-2612 Setting loose file permissions is security-sensitive", "committedDate": "2020-02-25T09:21:40Z", "type": "commit"}, {"oid": "fd45394fa87554d009ec91cc90ddbe903e3bbb5a", "url": "https://github.com/SonarSource/sonar-java/commit/fd45394fa87554d009ec91cc90ddbe903e3bbb5a", "message": "SONARJAVA-3260 RSPEC-2612 Setting loose file permissions is security-sensitive", "committedDate": "2020-02-25T09:21:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgwOTkxMg==", "url": "https://github.com/SonarSource/sonar-java/pull/2842#discussion_r383809912", "bodyText": "We should support the sticky bit, setguid, setuid. Those bits are set using ocal 4 digits:\nruntime.exec(\"chmod 1770 file.json\"); // FP\nruntime.exec(\"chmod 3770 file.json\"); // FP\nruntime.exec(\"chmod 0770 file.json\"); // FP\n\nWe should only consider an isolated octal number:\nruntime.exec(\"chmod 770 file111.json\"); // FP\n\nThis a proposal:\n\"(^|\\\\s)[0-7]{2,3}[1-7](\\\\s|$)\"", "author": "alban-auzeill", "createdAt": "2020-02-25T11:03:49Z", "path": "java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.security;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.java.matcher.MethodMatcher;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+\n+@Rule(key = \"S2612\")\n+public class FilePermissionsCheck extends IssuableSubscriptionVisitor {\n+\n+  private static final String JAVA_LANG_STRING = \"java.lang.String\";\n+  private static final String ISSUE_MESSAGE = \"Make sure this permission is safe.\";\n+  private static final Set<String> POSIX_OTHER_PERMISSIONS = new HashSet<>(Arrays.asList(\"OTHERS_READ\", \"OTHERS_WRITE\", \"OTHERS_EXECUTE\"));\n+  private static final MethodMatcher POSIX_FILE_PERMISSIONS_FROM_STRING = MethodMatcher.create()\n+    .name(\"fromString\")\n+    .typeDefinition(\"java.nio.file.attribute.PosixFilePermissions\")\n+    .parameters(JAVA_LANG_STRING);\n+\n+  private static final MethodMatcher RUNTIME_EXEC = MethodMatcher.create()\n+    .name(\"exec\")\n+    .typeDefinition(\"java.lang.Runtime\")\n+    .withAnyParameters();\n+\n+  // 'other' group not being 0\n+  private static final Pattern CHMOD_OCTAL_PATTERN = Pattern.compile(\"[0-7]{2}[1-7]\");", "originalCommit": "fd45394fa87554d009ec91cc90ddbe903e3bbb5a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzgzNDM3MA==", "url": "https://github.com/SonarSource/sonar-java/pull/2842#discussion_r383834370", "bodyText": "the command could be chmod or /bin/chmod", "author": "alban-auzeill", "createdAt": "2020-02-25T11:57:08Z", "path": "java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.security;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.java.matcher.MethodMatcher;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+\n+@Rule(key = \"S2612\")\n+public class FilePermissionsCheck extends IssuableSubscriptionVisitor {\n+\n+  private static final String JAVA_LANG_STRING = \"java.lang.String\";\n+  private static final String ISSUE_MESSAGE = \"Make sure this permission is safe.\";\n+  private static final Set<String> POSIX_OTHER_PERMISSIONS = new HashSet<>(Arrays.asList(\"OTHERS_READ\", \"OTHERS_WRITE\", \"OTHERS_EXECUTE\"));\n+  private static final MethodMatcher POSIX_FILE_PERMISSIONS_FROM_STRING = MethodMatcher.create()\n+    .name(\"fromString\")\n+    .typeDefinition(\"java.nio.file.attribute.PosixFilePermissions\")\n+    .parameters(JAVA_LANG_STRING);\n+\n+  private static final MethodMatcher RUNTIME_EXEC = MethodMatcher.create()\n+    .name(\"exec\")\n+    .typeDefinition(\"java.lang.Runtime\")\n+    .withAnyParameters();\n+\n+  // 'other' group not being 0\n+  private static final Pattern CHMOD_OCTAL_PATTERN = Pattern.compile(\"[0-7]{2}[1-7]\");\n+  // simplification of all the possible combinations of adding perms to 'other'\n+  private static final Pattern SIMPLIFIED_CHMOD_OTHER_PATTERN = Pattern.compile(\"o[+=](r?w?x?)+\");\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Arrays.asList(Tree.Kind.IDENTIFIER, Tree.Kind.METHOD_INVOCATION);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    if (tree.is(Tree.Kind.IDENTIFIER)) {\n+      check((IdentifierTree) tree);\n+    } else {\n+      check((MethodInvocationTree) tree);\n+    }\n+  }\n+\n+  private void check(IdentifierTree identifier) {\n+    if (isPosixPermission(identifier) && !isBeingRemoved(identifier)) {\n+      reportIssue(identifier, ISSUE_MESSAGE);\n+    }\n+  }\n+\n+  private static boolean isPosixPermission(IdentifierTree identifier) {\n+    return POSIX_OTHER_PERMISSIONS.contains(identifier.name())\n+      && identifier.symbolType().isSubtypeOf(\"java.nio.file.attribute.PosixFilePermission\");\n+  }\n+\n+  private static boolean isBeingRemoved(IdentifierTree identifier) {\n+    Tree parent = identifier.parent();\n+    while (parent != null) {\n+      // Whatever the owner of \"remove\", we assume the property is dropped if calling a method \"remove\"\n+      // (implemented by all classes extending Collection)\n+      if (parent.is(Tree.Kind.METHOD_INVOCATION) && ((MethodInvocationTree) parent).symbol().name().contains(\"remove\")) {\n+        return true;\n+      }\n+      parent = parent.parent();\n+    }\n+    return false;\n+  }\n+\n+  private void check(MethodInvocationTree mit) {\n+    if (POSIX_FILE_PERMISSIONS_FROM_STRING.matches(mit)) {\n+      ExpressionTree arg0 = mit.arguments().get(0);\n+      if (sensitivePermissionsAsString(arg0)) {\n+        reportIssue(arg0, ISSUE_MESSAGE);\n+      }\n+    } else if (RUNTIME_EXEC.matches(mit)) {\n+      ExpressionTree arg0 = mit.arguments().get(0);\n+      if (arg0.symbolType().is(JAVA_LANG_STRING) && sensitiveChmodCommand(arg0)) {\n+        reportIssue(arg0, ISSUE_MESSAGE);\n+      }\n+    }\n+  }\n+\n+  private static boolean sensitivePermissionsAsString(ExpressionTree arg0) {\n+    return arg0.asConstant(String.class)\n+      .filter(chmod -> chmod.length() == 9)\n+      .filter(chmod -> !chmod.endsWith(\"---\"))\n+      .isPresent();\n+  }\n+\n+  private static boolean sensitiveChmodCommand(ExpressionTree arg0) {\n+    return arg0.asConstant(String.class)\n+      .filter(cmd -> cmd.trim().startsWith(\"chmod\"))", "originalCommit": "fd45394fa87554d009ec91cc90ddbe903e3bbb5a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg0NjcxOQ==", "url": "https://github.com/SonarSource/sonar-java/pull/2842#discussion_r383846719", "bodyText": "The exec method accepts a string array in order to separate the command from the arguments, the correct form should be:\nruntime.exec(new String[] {\"chmod\", \"777\", \"file.json\"});\n\nI think that putting a hardcoded filename is a corner case. In real-life examples, I don't expect to see the above example or this one:\nruntime.exec(\"chmod 777 file.json\");\n\nUsually the file name is a variable, and developers probablly use this form:\nruntime.exec(new String[] {\"chmod\", \"777\", filename});\nruntime.exec(new String[] {\"/bin/chmod\", \"--recursive\", \"777\", filename});\n\nLike in those CVEs: Recent Java exploitation trends and malware\nAnd if we want to support exec with a string argument, It should probably be this form:\nruntime.exec(\"chmod 777 \\\"\" + filename + \"\\\"\");", "author": "alban-auzeill", "createdAt": "2020-02-25T12:25:09Z", "path": "java-checks-test-sources/src/main/java/checks/security/FilePermissionsCheck.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package checks.security;\n+\n+import java.io.File;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.attribute.PosixFilePermission;\n+import java.nio.file.attribute.PosixFilePermissions;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+class FilePermissionsCheck {\n+\n+  // using PosixFilePermission to set file permissions 757\n+  public void setPermissions(Path filePath) throws Exception {\n+\n+    Set<PosixFilePermission> perms = new HashSet<>();\n+    // user permission\n+    perms.add(PosixFilePermission.OWNER_READ);\n+    perms.add(PosixFilePermission.OWNER_WRITE);\n+    perms.add(PosixFilePermission.OWNER_EXECUTE);\n+    // group permissions\n+    perms.add(PosixFilePermission.GROUP_READ);\n+    perms.add(PosixFilePermission.GROUP_EXECUTE);\n+    // others permissions\n+    perms.add(PosixFilePermission.OTHERS_READ); // Noncompliant {{Make sure this permission is safe.}}\n+    perms.add(PosixFilePermission.OTHERS_WRITE); // Noncompliant\n+    perms.add(PosixFilePermission.OTHERS_EXECUTE); // Noncompliant\n+\n+    Files.setPosixFilePermissions(filePath, perms);\n+\n+    System.out.println(MyEnum.OTHERS_EXECUTE);\n+  }\n+\n+  public void setPermissionsFromString(Path filePath, String permissions) throws Exception {\n+    Files.setPosixFilePermissions(filePath, PosixFilePermissions.fromString(permissions)); // Compliant: because we can't say something about the content of 'permissions'\n+  }\n+\n+  public void setOthersPermissionsHardCoded(Path filePath) throws Exception {\n+    Files.setPosixFilePermissions(filePath, PosixFilePermissions.fromString(\"rwxrwx---\")); // Compliant\n+\n+    Files.setPosixFilePermissions(filePath, PosixFilePermissions.fromString(\"rwxrwxr--\")); // Noncompliant [[sc=77;ec=88]] {{Make sure this permission is safe.}}\n+    Files.setPosixFilePermissions(filePath, PosixFilePermissions.fromString(\"rwxrwx-w-\")); // Noncompliant\n+    Files.setPosixFilePermissions(filePath, PosixFilePermissions.fromString(\"rwxrwx--x\")); // Noncompliant\n+\n+    Files.setPosixFilePermissions(filePath, PosixFilePermissions.fromString(\"rwxrwxrw-\")); // Noncompliant\n+    Files.setPosixFilePermissions(filePath, PosixFilePermissions.fromString(\"rwxrwxr-x\")); // Noncompliant\n+    Files.setPosixFilePermissions(filePath, PosixFilePermissions.fromString(\"rwxrwx-wx\")); // Noncompliant\n+\n+    Files.setPosixFilePermissions(filePath, PosixFilePermissions.fromString(\"rwxrwxrwx\")); // Noncompliant\n+\n+    Files.setPosixFilePermissions(filePath, PosixFilePermissions.fromString(\"invalid\")); // Compliant\n+  }\n+\n+  public void setPermissionsUsingRuntimeExec(Runtime runtime) throws Exception {\n+    runtime.exec(\"chmod 777 file.json\"); // Noncompliant\n+    runtime.exec(\"chmod 775 file.json\"); // Noncompliant\n+    runtime.exec(\"chmod 774 file.json\"); // Noncompliant\n+    runtime.exec(\"chmod 771 file.json\"); // Noncompliant\n+    runtime.exec(\"chmod 770 file.json\"); // Compliant\n+\n+    runtime.exec(\"chmod 770 777 file1.json file2.json\"); // Noncompliant\n+\n+    runtime.exec(\"chmod 777 file.json\", new String[] {}); // Noncompliant\n+    runtime.exec(\"chmod 777 file.json\", new String[] {}, new File(\"\")); // Noncompliant\n+\n+    runtime.exec(\"chmod o+w file.json\"); // Noncompliant\n+    runtime.exec(\"chmod o=rwx file.json\"); // Noncompliant\n+    runtime.exec(\"chmod o-rwx file.json\"); // Compliant\n+\n+    runtime.exec(\"mvn clean install\"); // Compliant\n+    runtime.exec(new String[] {\"mvn clean install\"}); // Compliant\n+    runtime.exec(new String[] {\"chmod 777 file.json\"}); // FN - not considering arrays", "originalCommit": "fd45394fa87554d009ec91cc90ddbe903e3bbb5a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2MjAyNg==", "url": "https://github.com/SonarSource/sonar-java/pull/2842#discussion_r383862026", "bodyText": "o means others and a means all (including others), this is a false-negative:\nchmod a+rwx file.json\n\no is not always after u g a, this is a false-negative:\nchmod ou+r file.json\n\nAnd unfortunalty, u g o a are optional, and the default value is all, this is a false-negative:\nchmod +rwx file.json\n\nThis a proposal:\n\"(^|\\\\s|,)([ug]*+[ao][ugao]*+)?[+=][sStT]*+[rwxX][rwxXsStT]*+(\\\\s|,|$)\"\n\nAnd some noncompliant examples:\n    runtime.exec(\"chmod +w file.json\"); // Noncompliant\n    runtime.exec(\"chmod a+w file.json\"); // Noncompliant\n    runtime.exec(\"chmod =rwx file.json\"); // Noncompliant\n    runtime.exec(\"chmod u=rwx,g=rx,o=r file.json\"); // Noncompliant", "author": "alban-auzeill", "createdAt": "2020-02-25T12:58:26Z", "path": "java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.security;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.java.matcher.MethodMatcher;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+\n+@Rule(key = \"S2612\")\n+public class FilePermissionsCheck extends IssuableSubscriptionVisitor {\n+\n+  private static final String JAVA_LANG_STRING = \"java.lang.String\";\n+  private static final String ISSUE_MESSAGE = \"Make sure this permission is safe.\";\n+  private static final Set<String> POSIX_OTHER_PERMISSIONS = new HashSet<>(Arrays.asList(\"OTHERS_READ\", \"OTHERS_WRITE\", \"OTHERS_EXECUTE\"));\n+  private static final MethodMatcher POSIX_FILE_PERMISSIONS_FROM_STRING = MethodMatcher.create()\n+    .name(\"fromString\")\n+    .typeDefinition(\"java.nio.file.attribute.PosixFilePermissions\")\n+    .parameters(JAVA_LANG_STRING);\n+\n+  private static final MethodMatcher RUNTIME_EXEC = MethodMatcher.create()\n+    .name(\"exec\")\n+    .typeDefinition(\"java.lang.Runtime\")\n+    .withAnyParameters();\n+\n+  // 'other' group not being 0\n+  private static final Pattern CHMOD_OCTAL_PATTERN = Pattern.compile(\"[0-7]{2}[1-7]\");\n+  // simplification of all the possible combinations of adding perms to 'other'\n+  private static final Pattern SIMPLIFIED_CHMOD_OTHER_PATTERN = Pattern.compile(\"o[+=](r?w?x?)+\");", "originalCommit": "fd45394fa87554d009ec91cc90ddbe903e3bbb5a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2NTUyMA==", "url": "https://github.com/SonarSource/sonar-java/pull/2842#discussion_r383865520", "bodyText": "I would prefer is being added instead of is being removed, we could have some FN but not this kind of FP:\n    Set<PosixFilePermission> posixFilePermissions = Files.getPosixFilePermissions(filePath);\n    if (posixFilePermissions.contains(PosixFilePermission.OTHERS_READ)) { // false-positive\n      // ...\n    }", "author": "alban-auzeill", "createdAt": "2020-02-25T13:05:31Z", "path": "java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.security;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.java.matcher.MethodMatcher;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+\n+@Rule(key = \"S2612\")\n+public class FilePermissionsCheck extends IssuableSubscriptionVisitor {\n+\n+  private static final String JAVA_LANG_STRING = \"java.lang.String\";\n+  private static final String ISSUE_MESSAGE = \"Make sure this permission is safe.\";\n+  private static final Set<String> POSIX_OTHER_PERMISSIONS = new HashSet<>(Arrays.asList(\"OTHERS_READ\", \"OTHERS_WRITE\", \"OTHERS_EXECUTE\"));\n+  private static final MethodMatcher POSIX_FILE_PERMISSIONS_FROM_STRING = MethodMatcher.create()\n+    .name(\"fromString\")\n+    .typeDefinition(\"java.nio.file.attribute.PosixFilePermissions\")\n+    .parameters(JAVA_LANG_STRING);\n+\n+  private static final MethodMatcher RUNTIME_EXEC = MethodMatcher.create()\n+    .name(\"exec\")\n+    .typeDefinition(\"java.lang.Runtime\")\n+    .withAnyParameters();\n+\n+  // 'other' group not being 0\n+  private static final Pattern CHMOD_OCTAL_PATTERN = Pattern.compile(\"[0-7]{2}[1-7]\");\n+  // simplification of all the possible combinations of adding perms to 'other'\n+  private static final Pattern SIMPLIFIED_CHMOD_OTHER_PATTERN = Pattern.compile(\"o[+=](r?w?x?)+\");\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Arrays.asList(Tree.Kind.IDENTIFIER, Tree.Kind.METHOD_INVOCATION);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    if (tree.is(Tree.Kind.IDENTIFIER)) {\n+      check((IdentifierTree) tree);\n+    } else {\n+      check((MethodInvocationTree) tree);\n+    }\n+  }\n+\n+  private void check(IdentifierTree identifier) {\n+    if (isPosixPermission(identifier) && !isBeingRemoved(identifier)) {", "originalCommit": "fd45394fa87554d009ec91cc90ddbe903e3bbb5a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzg2NzIzNg==", "url": "https://github.com/SonarSource/sonar-java/pull/2842#discussion_r383867236", "bodyText": "Nice and easy way to test: chmod.endsWith(\"---\") (you see, from time to time I could agree...\ud83d\ude09)", "author": "alban-auzeill", "createdAt": "2020-02-25T13:09:11Z", "path": "java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java", "diffHunk": "@@ -0,0 +1,121 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.security;\n+\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.java.matcher.MethodMatcher;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+\n+@Rule(key = \"S2612\")\n+public class FilePermissionsCheck extends IssuableSubscriptionVisitor {\n+\n+  private static final String JAVA_LANG_STRING = \"java.lang.String\";\n+  private static final String ISSUE_MESSAGE = \"Make sure this permission is safe.\";\n+  private static final Set<String> POSIX_OTHER_PERMISSIONS = new HashSet<>(Arrays.asList(\"OTHERS_READ\", \"OTHERS_WRITE\", \"OTHERS_EXECUTE\"));\n+  private static final MethodMatcher POSIX_FILE_PERMISSIONS_FROM_STRING = MethodMatcher.create()\n+    .name(\"fromString\")\n+    .typeDefinition(\"java.nio.file.attribute.PosixFilePermissions\")\n+    .parameters(JAVA_LANG_STRING);\n+\n+  private static final MethodMatcher RUNTIME_EXEC = MethodMatcher.create()\n+    .name(\"exec\")\n+    .typeDefinition(\"java.lang.Runtime\")\n+    .withAnyParameters();\n+\n+  // 'other' group not being 0\n+  private static final Pattern CHMOD_OCTAL_PATTERN = Pattern.compile(\"[0-7]{2}[1-7]\");\n+  // simplification of all the possible combinations of adding perms to 'other'\n+  private static final Pattern SIMPLIFIED_CHMOD_OTHER_PATTERN = Pattern.compile(\"o[+=](r?w?x?)+\");\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Arrays.asList(Tree.Kind.IDENTIFIER, Tree.Kind.METHOD_INVOCATION);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    if (tree.is(Tree.Kind.IDENTIFIER)) {\n+      check((IdentifierTree) tree);\n+    } else {\n+      check((MethodInvocationTree) tree);\n+    }\n+  }\n+\n+  private void check(IdentifierTree identifier) {\n+    if (isPosixPermission(identifier) && !isBeingRemoved(identifier)) {\n+      reportIssue(identifier, ISSUE_MESSAGE);\n+    }\n+  }\n+\n+  private static boolean isPosixPermission(IdentifierTree identifier) {\n+    return POSIX_OTHER_PERMISSIONS.contains(identifier.name())\n+      && identifier.symbolType().isSubtypeOf(\"java.nio.file.attribute.PosixFilePermission\");\n+  }\n+\n+  private static boolean isBeingRemoved(IdentifierTree identifier) {\n+    Tree parent = identifier.parent();\n+    while (parent != null) {\n+      // Whatever the owner of \"remove\", we assume the property is dropped if calling a method \"remove\"\n+      // (implemented by all classes extending Collection)\n+      if (parent.is(Tree.Kind.METHOD_INVOCATION) && ((MethodInvocationTree) parent).symbol().name().contains(\"remove\")) {\n+        return true;\n+      }\n+      parent = parent.parent();\n+    }\n+    return false;\n+  }\n+\n+  private void check(MethodInvocationTree mit) {\n+    if (POSIX_FILE_PERMISSIONS_FROM_STRING.matches(mit)) {\n+      ExpressionTree arg0 = mit.arguments().get(0);\n+      if (sensitivePermissionsAsString(arg0)) {\n+        reportIssue(arg0, ISSUE_MESSAGE);\n+      }\n+    } else if (RUNTIME_EXEC.matches(mit)) {\n+      ExpressionTree arg0 = mit.arguments().get(0);\n+      if (arg0.symbolType().is(JAVA_LANG_STRING) && sensitiveChmodCommand(arg0)) {\n+        reportIssue(arg0, ISSUE_MESSAGE);\n+      }\n+    }\n+  }\n+\n+  private static boolean sensitivePermissionsAsString(ExpressionTree arg0) {\n+    return arg0.asConstant(String.class)\n+      .filter(chmod -> chmod.length() == 9)\n+      .filter(chmod -> !chmod.endsWith(\"---\"))", "originalCommit": "fd45394fa87554d009ec91cc90ddbe903e3bbb5a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "744778ff55ddade59a886ec538efa02d417fef42", "url": "https://github.com/SonarSource/sonar-java/commit/744778ff55ddade59a886ec538efa02d417fef42", "message": "fix from review", "committedDate": "2020-02-25T16:46:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAyOTcyOQ==", "url": "https://github.com/SonarSource/sonar-java/pull/2842#discussion_r384029729", "bodyText": "--recursive is just one of the possible options that can be pass to chmod, but there are others and multiple options can be passed.\nNo need to know at which index is the mode argument, we can safely test isSensisitiveChmodMode on all the initializers list (skipping first).", "author": "alban-auzeill", "createdAt": "2020-02-25T17:45:46Z", "path": "java-checks/src/main/java/org/sonar/java/checks/security/FilePermissionsCheck.java", "diffHunk": "@@ -112,10 +122,43 @@ private static boolean sensitivePermissionsAsString(ExpressionTree arg0) {\n       .isPresent();\n   }\n \n-  private static boolean sensitiveChmodCommand(ExpressionTree arg0) {\n-    return arg0.asConstant(String.class)\n-      .filter(cmd -> cmd.trim().startsWith(\"chmod\"))\n-      .filter(cmd -> CHMOD_OCTAL_PATTERN.matcher(cmd).find() || SIMPLIFIED_CHMOD_OTHER_PATTERN.matcher(cmd).find())\n+  private void checkExecSingleStringArgument(ExpressionTree arg0) {\n+    if (chmodCommand(arg0).filter(FilePermissionsCheck::isSensisitiveChmodMode).isPresent()) {\n+      reportIssue(arg0, ISSUE_MESSAGE);\n+    }\n+  }\n+\n+  private void checkExecStringArrayArgument(NewArrayTree newArrayTree) {\n+    List<ExpressionTree> initializers = newArrayTree.initializers();\n+    if (initializers.size() < 3) {\n+      // malformed\n+      return;\n+    }\n+    if (!chmodCommand(initializers.get(0)).isPresent()) {\n+      return;\n+    }\n+    ExpressionTree modeArg = initializers.get(1);\n+    if (initializers.size() > 3 && isRecursiveArgument(modeArg)) {", "originalCommit": "744778ff55ddade59a886ec538efa02d417fef42", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9484b5923991ea8413073372bf65ba3fc0e4d489", "url": "https://github.com/SonarSource/sonar-java/commit/9484b5923991ea8413073372bf65ba3fc0e4d489", "message": "fix", "committedDate": "2020-02-26T10:07:03Z", "type": "commit"}]}