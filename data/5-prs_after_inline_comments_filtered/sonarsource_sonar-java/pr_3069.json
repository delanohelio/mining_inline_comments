{"pr_number": 3069, "pr_title": "SONARJAVA-3412 Rule S5840: Regex patterns and their sub-patterns should not always fail", "pr_createdAt": "2020-07-01T12:32:56Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/3069", "timeline": [{"oid": "877b67c22fae08dd4f7d96fb2c2ecd2292a63bf6", "url": "https://github.com/SonarSource/sonar-java/commit/877b67c22fae08dd4f7d96fb2c2ecd2292a63bf6", "message": "Detect illegal numeric back references", "committedDate": "2020-07-01T11:14:32Z", "type": "commit"}, {"oid": "ca162f1a6c3dcf14ab7b9f2b138a1a1e9e7d56bf", "url": "https://github.com/SonarSource/sonar-java/commit/ca162f1a6c3dcf14ab7b9f2b138a1a1e9e7d56bf", "message": "Check whether anchors are used where they cannot match", "committedDate": "2020-07-01T13:23:54Z", "type": "commit"}, {"oid": "ca162f1a6c3dcf14ab7b9f2b138a1a1e9e7d56bf", "url": "https://github.com/SonarSource/sonar-java/commit/ca162f1a6c3dcf14ab7b9f2b138a1a1e9e7d56bf", "message": "Check whether anchors are used where they cannot match", "committedDate": "2020-07-01T13:23:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODM4NjQzNA==", "url": "https://github.com/SonarSource/sonar-java/pull/3069#discussion_r448386434", "bodyText": "As a general observation, I believe it's better to test the message/location only when it \"matters\". It will avoid having to change it everywhere if you change it, and easily spot in which case you expect something different.\nFor example here, testing the location each time makes sense, however, testing the message seems redundant.", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-07-01T14:04:27Z", "path": "java-checks-test-sources/src/main/java/checks/regex/ImpossibleRegexCheck.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package checks.regex;\n+\n+public class ImpossibleRegexCheck {\n+\n+  void noncompliantBackReferences(String str) {\n+    str.matches(\"\\\\1\"); // Noncompliant [[sc=18;ec=21]] {{Remove this illegal back reference that can never match or rewrite the regex.}}\n+    str.matches(\"\\\\1(.)\"); // Noncompliant [[sc=18;ec=21]] {{Remove this illegal back reference that can never match or rewrite the regex.}}\n+    str.matches(\"(?:\\\\1(.))*\"); // Noncompliant [[sc=21;ec=24]] {{Remove this illegal back reference that can never match or rewrite the regex.}}\n+    str.matches(\"\\\\1|(.)\"); // Noncompliant [[sc=18;ec=21]] {{Remove this illegal back reference that can never match or rewrite the regex.}}\n+    // FP (IntelliJ has this FP too):\n+    str.matches(\"(?:\\\\1|x(.))*\"); // Noncompliant [[sc=21;ec=24]] {{Remove this illegal back reference that can never match or rewrite the regex.}}\n+  }\n+\n+  void compliantBackReferences(String str) {\n+    str.matches(\"(.)\\\\1\");\n+    str.matches(\"(?:x(.)|\\\\1)*\");\n+    str.matches(\"(.)|\\\\1\"); // FN (IntelliJ has this FN too)\n+    // Illegal named back references are handled by the illegal regex rule because they cause an exception rather than\n+    // just failing to match anything\n+    str.matches(\"\\\\k<name>(?<name>.)\");\n+  }\n+\n+  void nonCompliantBoundaries(String str) {", "originalCommit": "ca162f1a6c3dcf14ab7b9f2b138a1a1e9e7d56bf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQxNjA1Mg==", "url": "https://github.com/SonarSource/sonar-java/pull/3069#discussion_r448416052", "bodyText": "Can't we start from the end, and return as soon as we find a consuming index, to avoid useless computation?", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-07-01T14:47:04Z", "path": "java-checks/src/main/java/org/sonar/java/checks/regex/ImpossibleRegexCheck.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.regex;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.sonar.check.Rule;\n+import org.sonar.java.regex.RegexParseResult;\n+import org.sonar.java.regex.ast.BackReferenceTree;\n+import org.sonar.java.regex.ast.BoundaryTree;\n+import org.sonar.java.regex.ast.CapturingGroupTree;\n+import org.sonar.java.regex.ast.DisjunctionTree;\n+import org.sonar.java.regex.ast.GroupTree;\n+import org.sonar.java.regex.ast.LookAroundTree;\n+import org.sonar.java.regex.ast.RegexBaseVisitor;\n+import org.sonar.java.regex.ast.RegexTree;\n+import org.sonar.java.regex.ast.SequenceTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+\n+@Rule(key = \"S5840\")\n+public class ImpossibleRegexCheck extends AbstractRegexCheck {\n+\n+  @Override\n+  public void checkRegex(RegexParseResult regexForLiterals, MethodInvocationTree mit) {\n+    new ImpossiblePatternFinder().visit(regexForLiterals);\n+  }\n+\n+  private static class ImpossibleSubPattern {\n+\n+    RegexTree tree;\n+\n+    String description;\n+\n+    public ImpossibleSubPattern(RegexTree tree, String description) {\n+      this.tree = tree;\n+      this.description = description;\n+    }\n+\n+  }\n+\n+  private class ImpossiblePatternFinder extends RegexBaseVisitor {\n+\n+    int groupCount = 0;\n+\n+    boolean isAtBeginning = true;\n+\n+    boolean isAtEnd = true;\n+\n+    List<ImpossibleSubPattern> impossibleSubPatterns = new ArrayList<>();\n+\n+    @Override\n+    public void visitCapturingGroup(CapturingGroupTree tree) {\n+      groupCount++;\n+      super.visitCapturingGroup(tree);\n+    }\n+\n+    @Override\n+    public void visitBackReference(BackReferenceTree tree) {\n+      if (tree.isNumerical() && tree.groupNumber() > groupCount) {\n+        impossibleSubPatterns.add(new ImpossibleSubPattern(tree, \"illegal back reference\"));\n+      }\n+      super.visitBackReference(tree);\n+    }\n+\n+    @Override\n+    public void visitSequence(SequenceTree tree) {\n+      List<RegexTree> items = tree.getItems();\n+      if (items.isEmpty()) {\n+        return;\n+      }\n+\n+      boolean wasAtEnd = isAtEnd;\n+      isAtEnd = false;\n+      int lastConsumingItemIndex = findLastConsumingIndex(items);\n+      for (int i = 0; i < items.size(); i++) {\n+        if (i >= lastConsumingItemIndex) {\n+          isAtEnd = wasAtEnd;\n+        }\n+        RegexTree item = items.get(i);\n+        visit(item);\n+        if (canConsumeInput(item)) {\n+          isAtBeginning = false;\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public void visitDisjunction(DisjunctionTree tree) {\n+      for (RegexTree alternative : tree.getAlternatives()) {\n+        restoreLocationAfter(() -> visit(alternative));\n+      }\n+    }\n+\n+    @Override\n+    public void visitLookAround(LookAroundTree tree) {\n+      restoreLocationAfter(() -> super.visitLookAround(tree));\n+    }\n+\n+    @Override\n+    public void visitBoundary(BoundaryTree tree) {\n+      switch (tree.type()) {\n+        case LINE_END:\n+        case INPUT_END:\n+        case INPUT_END_FINAL_TERMINATOR:\n+          if (!isAtEnd) {\n+            impossibleSubPatterns.add(new ImpossibleSubPattern(tree, \"boundary\"));\n+          }\n+          break;\n+        case LINE_START:\n+        case INPUT_START:\n+          if (!isAtBeginning) {\n+            impossibleSubPatterns.add(new ImpossibleSubPattern(tree, \"boundary\"));\n+          }\n+          break;\n+        default:\n+          // Do nothing\n+      }\n+    }\n+\n+\n+    @Override\n+    public void after(RegexParseResult result) {\n+      if (impossibleSubPatterns.size() == 1) {\n+        ImpossibleSubPattern pattern = impossibleSubPatterns.get(0);\n+        reportIssue(pattern.tree, \"Remove this \" + pattern.description + \" that can never match or rewrite the regex.\", null, Collections.emptyList());\n+      } else if (impossibleSubPatterns.size() > 1) {\n+        List<RegexIssueLocation> secondaries = impossibleSubPatterns.stream()\n+          .map(pattern -> new RegexIssueLocation(pattern.tree, pattern.description))\n+          .collect(Collectors.toList());\n+        reportIssue(impossibleSubPatterns.get(0).tree, \"Remove these subpatterns that can never match or rewrite the regex.\", null, secondaries);\n+      }\n+    }\n+\n+    void restoreLocationAfter(Runnable action) {\n+      boolean wasAtEnd = isAtEnd;\n+      boolean wasAtBeginning = isAtBeginning;\n+      action.run();\n+      isAtEnd = wasAtEnd;\n+      isAtBeginning = wasAtBeginning;\n+    }\n+\n+    int findLastConsumingIndex(List<RegexTree> items) {\n+      int lastIndex = -1;\n+      for (int i = 0; i < items.size(); i++) {\n+        if (canConsumeInput(items.get(i))) {\n+          lastIndex = i;\n+        }\n+      }", "originalCommit": "ca162f1a6c3dcf14ab7b9f2b138a1a1e9e7d56bf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQxODkxNw==", "url": "https://github.com/SonarSource/sonar-java/pull/3069#discussion_r448418917", "bodyText": "I think we are missing a test with both boundary and backreference that can never match, to test that we have one issue for both.", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-07-01T14:51:07Z", "path": "java-checks-test-sources/src/main/java/checks/regex/ImpossibleRegexCheck.java", "diffHunk": "@@ -0,0 +1,48 @@\n+package checks.regex;\n+\n+public class ImpossibleRegexCheck {\n+\n+  void noncompliantBackReferences(String str) {\n+    str.matches(\"\\\\1\"); // Noncompliant [[sc=18;ec=21]] {{Remove this illegal back reference that can never match or rewrite the regex.}}\n+    str.matches(\"\\\\1(.)\"); // Noncompliant [[sc=18;ec=21]] {{Remove this illegal back reference that can never match or rewrite the regex.}}\n+    str.matches(\"(?:\\\\1(.))*\"); // Noncompliant [[sc=21;ec=24]] {{Remove this illegal back reference that can never match or rewrite the regex.}}\n+    str.matches(\"\\\\1|(.)\"); // Noncompliant [[sc=18;ec=21]] {{Remove this illegal back reference that can never match or rewrite the regex.}}\n+    // FP (IntelliJ has this FP too):\n+    str.matches(\"(?:\\\\1|x(.))*\"); // Noncompliant [[sc=21;ec=24]] {{Remove this illegal back reference that can never match or rewrite the regex.}}\n+  }\n+\n+  void compliantBackReferences(String str) {\n+    str.matches(\"(.)\\\\1\");\n+    str.matches(\"(?:x(.)|\\\\1)*\");\n+    str.matches(\"(.)|\\\\1\"); // FN (IntelliJ has this FN too)\n+    // Illegal named back references are handled by the illegal regex rule because they cause an exception rather than\n+    // just failing to match anything\n+    str.matches(\"\\\\k<name>(?<name>.)\");\n+  }\n+\n+  void nonCompliantBoundaries(String str) {\n+    str.matches(\"$[a-z]^\"); // Noncompliant [[sc=18;ec=19;secondary=24,24]] {{Remove these subpatterns that can never match or rewrite the regex.}}\n+    str.matches(\"$[a-z]\"); // Noncompliant [[sc=18;ec=19]] {{Remove this boundary that can never match or rewrite the regex.}}\n+    str.matches(\"$(abc)\"); // Noncompliant [[sc=18;ec=19]] {{Remove this boundary that can never match or rewrite the regex.}}\n+    str.matches(\"[a-z]^\"); // Noncompliant [[sc=23;ec=24]] {{Remove this boundary that can never match or rewrite the regex.}}\n+    str.matches(\"\\\\Z[a-z]\"); // Noncompliant [[sc=18;ec=21]] {{Remove this boundary that can never match or rewrite the regex.}}\n+    str.matches(\"\\\\z[a-z]\"); // Noncompliant [[sc=18;ec=21]] {{Remove this boundary that can never match or rewrite the regex.}}\n+    str.matches(\"[a-z]\\\\A\"); // Noncompliant [[sc=23;ec=26]] {{Remove this boundary that can never match or rewrite the regex.}}\n+    str.matches(\"($)a\"); // Noncompliant [[sc=19;ec=20]] {{Remove this boundary that can never match or rewrite the regex.}}\n+    str.matches(\"a$|$a\"); // Noncompliant [[sc=21;ec=22]] {{Remove this boundary that can never match or rewrite the regex.}}\n+    str.matches(\"^a|a^\"); // Noncompliant [[sc=22;ec=23]] {{Remove this boundary that can never match or rewrite the regex.}}\n+    str.matches(\"a(b|^)\"); // Noncompliant [[sc=22;ec=23]] {{Remove this boundary that can never match or rewrite the regex.}}\n+    str.matches(\"(?=abc^)\"); // Noncompliant [[sc=24;ec=25]] {{Remove this boundary that can never match or rewrite the regex.}}\n+  }", "originalCommit": "ca162f1a6c3dcf14ab7b9f2b138a1a1e9e7d56bf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0ODQyNTAwMA==", "url": "https://github.com/SonarSource/sonar-java/pull/3069#discussion_r448425000", "bodyText": "It might be personal taste/formatting, but to me, an empty line between variables \"means something\". For example, keeping groupCount  separated make sense since it relates to invalid BackReference detection, but it would make sense to groups these together.", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-07-01T14:59:42Z", "path": "java-checks/src/main/java/org/sonar/java/checks/regex/ImpossibleRegexCheck.java", "diffHunk": "@@ -0,0 +1,185 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.regex;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+import org.sonar.check.Rule;\n+import org.sonar.java.regex.RegexParseResult;\n+import org.sonar.java.regex.ast.BackReferenceTree;\n+import org.sonar.java.regex.ast.BoundaryTree;\n+import org.sonar.java.regex.ast.CapturingGroupTree;\n+import org.sonar.java.regex.ast.DisjunctionTree;\n+import org.sonar.java.regex.ast.GroupTree;\n+import org.sonar.java.regex.ast.LookAroundTree;\n+import org.sonar.java.regex.ast.RegexBaseVisitor;\n+import org.sonar.java.regex.ast.RegexTree;\n+import org.sonar.java.regex.ast.SequenceTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+\n+@Rule(key = \"S5840\")\n+public class ImpossibleRegexCheck extends AbstractRegexCheck {\n+\n+  @Override\n+  public void checkRegex(RegexParseResult regexForLiterals, MethodInvocationTree mit) {\n+    new ImpossiblePatternFinder().visit(regexForLiterals);\n+  }\n+\n+  private static class ImpossibleSubPattern {\n+\n+    RegexTree tree;\n+\n+    String description;\n+\n+    public ImpossibleSubPattern(RegexTree tree, String description) {\n+      this.tree = tree;\n+      this.description = description;\n+    }\n+\n+  }\n+\n+  private class ImpossiblePatternFinder extends RegexBaseVisitor {\n+\n+    int groupCount = 0;\n+\n+    boolean isAtBeginning = true;\n+\n+    boolean isAtEnd = true;", "originalCommit": "ca162f1a6c3dcf14ab7b9f2b138a1a1e9e7d56bf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "db3fa79f15ac536e106c955d19c9786a6739ec1a", "url": "https://github.com/SonarSource/sonar-java/commit/db3fa79f15ac536e106c955d19c9786a6739ec1a", "message": "Fixes from comments", "committedDate": "2020-07-02T08:18:11Z", "type": "commit"}]}