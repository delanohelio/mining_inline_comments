{"pr_number": 2918, "pr_title": "SONARJAVA-3350 S2701: support null literal", "pr_createdAt": "2020-04-23T17:43:05Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/2918", "timeline": [{"oid": "c6b2af9251e486bc00348360059ea704e4aff774", "url": "https://github.com/SonarSource/sonar-java/commit/c6b2af9251e486bc00348360059ea704e4aff774", "message": "SONARJAVA-3350 S2701: support null literal\n\nMake the rule S2701 report issues on null literals as well as Boolean\nliterals. Also improve the message when a null or Boolean literal is\nused with assertEquals and similar methods.", "committedDate": "2020-04-24T14:44:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU2NjEwNA==", "url": "https://github.com/SonarSource/sonar-java/pull/2918#discussion_r415566104", "bodyText": "As a general observation, always think twice about what tree is reported, it will define what is highlighted in the different products, if the tree is too big, it will result in something ugly.\nThis is especially true for method invocation: arguments can be unusually long, a huge lambda, or a huge message for example!\nSince the actual code is reporting on the literal, I believe we should keep this behavior in order to avoid having issues changing line.\nYou can eventually add a secondary location (see #2915 for an example of secondary) to the method identifier to make it clearer! (you can use ExpressionUtils::methodName for this).", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-04-27T07:12:57Z", "path": "java-checks/src/main/java/org/sonar/java/checks/BooleanOrNullLiteralInAssertionsCheck.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import org.sonar.check.Rule;\n+import org.sonar.java.checks.methods.AbstractMethodDetection;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.TypeCastTree;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+@Rule(key = \"S2701\")\n+public class BooleanOrNullLiteralInAssertionsCheck extends AbstractMethodDetection {\n+  private static final String DEFAULT_MESSAGE = \"Remove or correct this assertion.\";\n+  private static final String MESSAGE_WITH_ALTERNATIVE = \"Use %s instead.\";\n+  private static final String ASSERT = \"assert\";\n+  private static final String IS = \"is\";\n+  private static final String ASSERT_THAT = \"assertThat\";\n+\n+  @Override\n+  protected MethodMatchers getMethodInvocationMatchers() {\n+    return MethodMatchers.or(\n+      MethodMatchers.create()\n+        .ofTypes(\n+          \"org.junit.Assert\",\n+          \"org.junit.jupiter.api.Assertions\",\n+          \"junit.framework.Assert\",\n+          \"junit.framework.TestCase\")\n+        .name(name -> name.startsWith(ASSERT))\n+        .withAnyParameters()\n+        .build(),\n+      MethodMatchers.create()\n+        .ofTypes(\"org.fest.assertions.Assertions\")\n+        .names(ASSERT_THAT)\n+        .withAnyParameters()\n+        .build(),\n+      MethodMatchers.create()\n+        .ofSubTypes(\"org.fest.assertions.GenericAssert\")\n+        .name(name -> name.startsWith(IS))\n+        .withAnyParameters()\n+        .build()\n+      );\n+  }\n+\n+  @Override\n+  protected void onMethodInvocationFound(MethodInvocationTree mit) {\n+    switch (mit.symbol().name()) {\n+      case \"assertEquals\":\n+      case \"assertSame\":\n+        checkEqualityAsserts(mit, false);\n+        break;\n+\n+      case \"assertNotEquals\":\n+      case \"assertNotSame\":\n+        checkEqualityAsserts(mit, true);\n+        break;\n+\n+      case \"isEqualTo\":\n+      case \"isSameAs\":\n+        checkFestEqualityAsserts(mit, false);\n+        break;\n+\n+      case \"isNotEqualTo\":\n+      case \"isNotSameAs\":\n+        checkFestEqualityAsserts(mit, true);\n+        break;\n+\n+      case ASSERT_THAT:\n+        // We ignore single-argument calls to assertThat because they will be handled when we get to the\n+        // corresponding is* call\n+        if (mit.arguments().size() > 1) {\n+          checkOtherAsserts(mit);\n+        }\n+        break;\n+\n+      default:\n+        checkOtherAsserts(mit);\n+        break;\n+    }\n+  }\n+\n+  private void checkEqualityAsserts(MethodInvocationTree mit, boolean flipped) {\n+    List<ExpressionTree> literals = mit.arguments().stream()\n+      .filter(BooleanOrNullLiteralInAssertionsCheck::isBoolOrNullLiteral)\n+      .collect(Collectors.toList());\n+    if (literals.size() > 1) {\n+      reportIssue(mit, DEFAULT_MESSAGE);\n+    } else if (literals.size() == 1) {\n+      checkEqualityAssertWithOneLiteral(mit, literals.get(0), flipped, ASSERT);\n+    }\n+  }\n+\n+  private void checkFestEqualityAsserts(MethodInvocationTree mit, boolean flipped) {\n+    if (mit.arguments().isEmpty()) {\n+      return;\n+    }\n+    ExpressionTree expected = mit.arguments().get(0);\n+    ExpressionTree actual = findActualValueForFest(mit);\n+    boolean actualIsLiteral = actual != null && isBoolOrNullLiteral(actual);\n+    if (isBoolOrNullLiteral(expected) && actualIsLiteral) {\n+      reportIssue(mit, DEFAULT_MESSAGE);", "originalCommit": "c6b2af9251e486bc00348360059ea704e4aff774", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4NDc2Mw==", "url": "https://github.com/SonarSource/sonar-java/pull/2918#discussion_r415584763", "bodyText": "I believe you can remove (or extract it for later use) this matcher, it is not useful anymore and you will be able to avoid the check at line 94.", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-04-27T07:44:01Z", "path": "java-checks/src/main/java/org/sonar/java/checks/BooleanOrNullLiteralInAssertionsCheck.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import org.sonar.check.Rule;\n+import org.sonar.java.checks.methods.AbstractMethodDetection;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.TypeCastTree;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+@Rule(key = \"S2701\")\n+public class BooleanOrNullLiteralInAssertionsCheck extends AbstractMethodDetection {\n+  private static final String DEFAULT_MESSAGE = \"Remove or correct this assertion.\";\n+  private static final String MESSAGE_WITH_ALTERNATIVE = \"Use %s instead.\";\n+  private static final String ASSERT = \"assert\";\n+  private static final String IS = \"is\";\n+  private static final String ASSERT_THAT = \"assertThat\";\n+\n+  @Override\n+  protected MethodMatchers getMethodInvocationMatchers() {\n+    return MethodMatchers.or(\n+      MethodMatchers.create()\n+        .ofTypes(\n+          \"org.junit.Assert\",\n+          \"org.junit.jupiter.api.Assertions\",\n+          \"junit.framework.Assert\",\n+          \"junit.framework.TestCase\")\n+        .name(name -> name.startsWith(ASSERT))\n+        .withAnyParameters()\n+        .build(),\n+      MethodMatchers.create()\n+        .ofTypes(\"org.fest.assertions.Assertions\")\n+        .names(ASSERT_THAT)\n+        .withAnyParameters()\n+        .build(),", "originalCommit": "c6b2af9251e486bc00348360059ea704e4aff774", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNTU4NjMyMg==", "url": "https://github.com/SonarSource/sonar-java/pull/2918#discussion_r415586322", "bodyText": "You can use the matcher at line 55 (extracted from the others) to get the same behavior. You can use .addParametersMatcher(MethodMatchers.ANY) in order to be sure that we have one argument.", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-04-27T07:46:23Z", "path": "java-checks/src/main/java/org/sonar/java/checks/BooleanOrNullLiteralInAssertionsCheck.java", "diffHunk": "@@ -0,0 +1,190 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import org.sonar.check.Rule;\n+import org.sonar.java.checks.methods.AbstractMethodDetection;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.MemberSelectExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+import org.sonar.plugins.java.api.tree.TypeCastTree;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+@Rule(key = \"S2701\")\n+public class BooleanOrNullLiteralInAssertionsCheck extends AbstractMethodDetection {\n+  private static final String DEFAULT_MESSAGE = \"Remove or correct this assertion.\";\n+  private static final String MESSAGE_WITH_ALTERNATIVE = \"Use %s instead.\";\n+  private static final String ASSERT = \"assert\";\n+  private static final String IS = \"is\";\n+  private static final String ASSERT_THAT = \"assertThat\";\n+\n+  @Override\n+  protected MethodMatchers getMethodInvocationMatchers() {\n+    return MethodMatchers.or(\n+      MethodMatchers.create()\n+        .ofTypes(\n+          \"org.junit.Assert\",\n+          \"org.junit.jupiter.api.Assertions\",\n+          \"junit.framework.Assert\",\n+          \"junit.framework.TestCase\")\n+        .name(name -> name.startsWith(ASSERT))\n+        .withAnyParameters()\n+        .build(),\n+      MethodMatchers.create()\n+        .ofTypes(\"org.fest.assertions.Assertions\")\n+        .names(ASSERT_THAT)\n+        .withAnyParameters()\n+        .build(),\n+      MethodMatchers.create()\n+        .ofSubTypes(\"org.fest.assertions.GenericAssert\")\n+        .name(name -> name.startsWith(IS))\n+        .withAnyParameters()\n+        .build()\n+      );\n+  }\n+\n+  @Override\n+  protected void onMethodInvocationFound(MethodInvocationTree mit) {\n+    switch (mit.symbol().name()) {\n+      case \"assertEquals\":\n+      case \"assertSame\":\n+        checkEqualityAsserts(mit, false);\n+        break;\n+\n+      case \"assertNotEquals\":\n+      case \"assertNotSame\":\n+        checkEqualityAsserts(mit, true);\n+        break;\n+\n+      case \"isEqualTo\":\n+      case \"isSameAs\":\n+        checkFestEqualityAsserts(mit, false);\n+        break;\n+\n+      case \"isNotEqualTo\":\n+      case \"isNotSameAs\":\n+        checkFestEqualityAsserts(mit, true);\n+        break;\n+\n+      case ASSERT_THAT:\n+        // We ignore single-argument calls to assertThat because they will be handled when we get to the\n+        // corresponding is* call\n+        if (mit.arguments().size() > 1) {\n+          checkOtherAsserts(mit);\n+        }\n+        break;\n+\n+      default:\n+        checkOtherAsserts(mit);\n+        break;\n+    }\n+  }\n+\n+  private void checkEqualityAsserts(MethodInvocationTree mit, boolean flipped) {\n+    List<ExpressionTree> literals = mit.arguments().stream()\n+      .filter(BooleanOrNullLiteralInAssertionsCheck::isBoolOrNullLiteral)\n+      .collect(Collectors.toList());\n+    if (literals.size() > 1) {\n+      reportIssue(mit, DEFAULT_MESSAGE);\n+    } else if (literals.size() == 1) {\n+      checkEqualityAssertWithOneLiteral(mit, literals.get(0), flipped, ASSERT);\n+    }\n+  }\n+\n+  private void checkFestEqualityAsserts(MethodInvocationTree mit, boolean flipped) {\n+    if (mit.arguments().isEmpty()) {\n+      return;\n+    }\n+    ExpressionTree expected = mit.arguments().get(0);\n+    ExpressionTree actual = findActualValueForFest(mit);\n+    boolean actualIsLiteral = actual != null && isBoolOrNullLiteral(actual);\n+    if (isBoolOrNullLiteral(expected) && actualIsLiteral) {\n+      reportIssue(mit, DEFAULT_MESSAGE);\n+    } else if (isBoolOrNullLiteral(expected)) {\n+      checkEqualityAssertWithOneLiteral(mit, expected, flipped, IS);\n+    } else if (actualIsLiteral) {\n+      checkEqualityAssertWithOneLiteral(mit, actual, flipped, IS);\n+    }\n+  }\n+\n+  private static ExpressionTree findActualValueForFest(MethodInvocationTree mit) {\n+    if (mit.symbol().name().equals(ASSERT_THAT) && !mit.arguments().isEmpty()) {", "originalCommit": "c6b2af9251e486bc00348360059ea704e4aff774", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "393adbdde59d4fe57808635c1f9822e6b1e2f4f5", "url": "https://github.com/SonarSource/sonar-java/commit/393adbdde59d4fe57808635c1f9822e6b1e2f4f5", "message": "Make issues only appear on the method name and the literals\n\nAlso refactor the code a bit, so there are only two calls to\nreportIssue - one for each message type. That way the code to\nfind the secondary locations to mark doesn't have to be repeated\nin multiple places.", "committedDate": "2020-04-27T15:28:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQwMjY4NQ==", "url": "https://github.com/SonarSource/sonar-java/pull/2918#discussion_r416402685", "bodyText": "You can test the secondary location position with [[sc=22;ec=32;secondary=21]].\nYou have to use line numbers, so in practice, each time you add a new line above, you will have to update it. This can be annoying, I therefore try to have only a few examples testing secondary location at the beginning,", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-04-28T07:48:15Z", "path": "java-checks-test-sources/src/main/java/checks/BooleanOrNullLiteralInAssertionsCheck.java", "diffHunk": "@@ -4,17 +4,17 @@\n \n class BooleanOrNullLiteralInAssertionsCheck {\n   void booleans() {\n-    org.junit.Assert.assertTrue(true); // Noncompliant [[sc=5;ec=38]] {{Remove or correct this assertion.}}\n+    org.junit.Assert.assertTrue(true); // Noncompliant [[sc=22;ec=32]] {{Remove or correct this assertion.}}", "originalCommit": "393adbdde59d4fe57808635c1f9822e6b1e2f4f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQzNDY1NQ==", "url": "https://github.com/SonarSource/sonar-java/pull/2918#discussion_r416434655", "bodyText": "It's confusing that findLiterals returns a list of ExpressionTree and not LiteralTree.\nSimilarly at line 157 checkEqualityAssertWithOneLiteral has an argument named ExpressionTree literal, while it can be something else than a literal (a typecast).\nWhy not working with LiteralTree everywhere instead (extracting the literal from the cast)?\n(it could also enable you to avoid a second call to isNullLiteral at line 159)", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-04-28T08:38:16Z", "path": "java-checks/src/main/java/org/sonar/java/checks/BooleanOrNullLiteralInAssertionsCheck.java", "diffHunk": "@@ -94,14 +100,26 @@ protected void onMethodInvocationFound(MethodInvocationTree mit) {\n     }\n   }\n \n-  private void checkEqualityAsserts(MethodInvocationTree mit, boolean flipped) {\n-    List<ExpressionTree> literals = mit.arguments().stream()\n+  private static List<ExpressionTree> findLiterals(List<ExpressionTree> expressions) {", "originalCommit": "393adbdde59d4fe57808635c1f9822e6b1e2f4f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQzODU3OQ==", "url": "https://github.com/SonarSource/sonar-java/pull/2918#discussion_r416438579", "bodyText": "Not sure this message suits well all the situations in which it will be displayed! Why not something more generic, an idea could be:  There's no reason to use this literal value here.", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-04-28T08:44:04Z", "path": "java-checks/src/main/java/org/sonar/java/checks/BooleanOrNullLiteralInAssertionsCheck.java", "diffHunk": "@@ -94,14 +100,26 @@ protected void onMethodInvocationFound(MethodInvocationTree mit) {\n     }\n   }\n \n-  private void checkEqualityAsserts(MethodInvocationTree mit, boolean flipped) {\n-    List<ExpressionTree> literals = mit.arguments().stream()\n+  private static List<ExpressionTree> findLiterals(List<ExpressionTree> expressions) {\n+    return expressions.stream()\n       .filter(BooleanOrNullLiteralInAssertionsCheck::isBoolOrNullLiteral)\n+      .collect(Collectors.toCollection(ArrayList::new));\n+  }\n+\n+  private void reportDefaultMessage(IdentifierTree methodName, List<ExpressionTree> literals) {\n+    List<JavaFileScannerContext.Location> literalLocations = literals.stream()\n+      .map(literal -> new JavaFileScannerContext.Location(\"There's no reason to compare literals with each other\", literal))", "originalCommit": "393adbdde59d4fe57808635c1f9822e6b1e2f4f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ0NDA4Ng==", "url": "https://github.com/SonarSource/sonar-java/pull/2918#discussion_r416444086", "bodyText": "Same here concerning the message, while the message totally makes sense for the main location (highlight the method name and advise to use another one), I'm not sure it makes sense for the secondary location.", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-04-28T08:52:33Z", "path": "java-checks/src/main/java/org/sonar/java/checks/BooleanOrNullLiteralInAssertionsCheck.java", "diffHunk": "@@ -150,7 +169,11 @@ private void checkEqualityAssertWithOneLiteral(MethodInvocationTree mit, Express\n       }\n     }\n     String recommendedAssertMethod = assertOrIs + predicate;\n-    reportIssue(mit, String.format(MESSAGE_WITH_ALTERNATIVE, recommendedAssertMethod));\n+    String message = String.format(MESSAGE_WITH_ALTERNATIVE, recommendedAssertMethod);\n+    List<JavaFileScannerContext.Location> secondaryLocation = Collections.singletonList(\n+      new JavaFileScannerContext.Location(message, literal)", "originalCommit": "393adbdde59d4fe57808635c1f9822e6b1e2f4f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ0ODIzMg==", "url": "https://github.com/SonarSource/sonar-java/pull/2918#discussion_r416448232", "bodyText": "You can extract this call in order to not call it twice with the same argument.", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-04-28T08:58:51Z", "path": "java-checks/src/main/java/org/sonar/java/checks/BooleanOrNullLiteralInAssertionsCheck.java", "diffHunk": "@@ -112,12 +130,13 @@ private void checkFestEqualityAsserts(MethodInvocationTree mit, boolean flipped)\n     ExpressionTree expected = mit.arguments().get(0);\n     ExpressionTree actual = findActualValueForFest(mit);\n     boolean actualIsLiteral = actual != null && isBoolOrNullLiteral(actual);\n+    IdentifierTree methodName = ExpressionUtils.methodName(mit);\n     if (isBoolOrNullLiteral(expected) && actualIsLiteral) {\n-      reportIssue(mit, DEFAULT_MESSAGE);\n+      reportDefaultMessage(methodName, Arrays.asList(expected, actual));\n     } else if (isBoolOrNullLiteral(expected)) {", "originalCommit": "393adbdde59d4fe57808635c1f9822e6b1e2f4f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ1MzM1Ng==", "url": "https://github.com/SonarSource/sonar-java/pull/2918#discussion_r416453356", "bodyText": "The method ordering looks strange to me, I would rather go for:\n\ncheckEqualityAsserts\nfindLiterals\nreportDefaultMessage\n\nI may be biased by personal opinion, but it seems to be the commonly agreed convention used in our Java projects.", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-04-28T09:06:35Z", "path": "java-checks/src/main/java/org/sonar/java/checks/BooleanOrNullLiteralInAssertionsCheck.java", "diffHunk": "@@ -94,14 +100,26 @@ protected void onMethodInvocationFound(MethodInvocationTree mit) {\n     }\n   }\n \n-  private void checkEqualityAsserts(MethodInvocationTree mit, boolean flipped) {\n-    List<ExpressionTree> literals = mit.arguments().stream()\n+  private static List<ExpressionTree> findLiterals(List<ExpressionTree> expressions) {\n+    return expressions.stream()\n       .filter(BooleanOrNullLiteralInAssertionsCheck::isBoolOrNullLiteral)\n+      .collect(Collectors.toCollection(ArrayList::new));\n+  }\n+\n+  private void reportDefaultMessage(IdentifierTree methodName, List<ExpressionTree> literals) {", "originalCommit": "393adbdde59d4fe57808635c1f9822e6b1e2f4f5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ2MjQyOQ==", "url": "https://github.com/SonarSource/sonar-java/pull/2918#discussion_r416462429", "bodyText": "Is there any particular reason to use this instead of .collect(Collectors.toList()); ?", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-04-28T09:20:38Z", "path": "java-checks/src/main/java/org/sonar/java/checks/BooleanOrNullLiteralInAssertionsCheck.java", "diffHunk": "@@ -94,14 +100,26 @@ protected void onMethodInvocationFound(MethodInvocationTree mit) {\n     }\n   }\n \n-  private void checkEqualityAsserts(MethodInvocationTree mit, boolean flipped) {\n-    List<ExpressionTree> literals = mit.arguments().stream()\n+  private static List<ExpressionTree> findLiterals(List<ExpressionTree> expressions) {\n+    return expressions.stream()\n       .filter(BooleanOrNullLiteralInAssertionsCheck::isBoolOrNullLiteral)\n+      .collect(Collectors.toCollection(ArrayList::new));", "originalCommit": "393adbdde59d4fe57808635c1f9822e6b1e2f4f5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjUwNTUxNg==", "url": "https://github.com/SonarSource/sonar-java/pull/2918#discussion_r416505516", "bodyText": "The list returned by toList isn't guaranteed to be mutable, but I want a mutable list, so I can add an additional literal to it on line 197. I'll add a comment explaining that.", "author": "sebastian-hungerecker-sonarsource", "createdAt": "2020-04-28T10:29:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxNjQ2MjQyOQ=="}], "type": "inlineReview"}, {"oid": "6f75692f6f80a2389edaabbc18fd86da2b30b4ad", "url": "https://github.com/SonarSource/sonar-java/commit/6f75692f6f80a2389edaabbc18fd86da2b30b4ad", "message": "SONARJAVA-3350 S2701: support null literal\n\nMake the rule S2701 report issues on null literals as well as Boolean\nliterals. Also improve the message when a null or Boolean literal is\nused with assertEquals and similar methods.", "committedDate": "2020-04-29T11:27:04Z", "type": "commit"}, {"oid": "39d640272afe76cc5859eb1708808ad1818242de", "url": "https://github.com/SonarSource/sonar-java/commit/39d640272afe76cc5859eb1708808ad1818242de", "message": "Extract the method matcher for assertThat", "committedDate": "2020-04-29T11:27:04Z", "type": "commit"}, {"oid": "435bd73ef376bb334d6bd1bf3f14878196d6179b", "url": "https://github.com/SonarSource/sonar-java/commit/435bd73ef376bb334d6bd1bf3f14878196d6179b", "message": "Make issues only appear on the method name and the literals\n\nAlso refactor the code a bit, so there are only two calls to\nreportIssue - one for each message type. That way the code to\nfind the secondary locations to mark doesn't have to be repeated\nin multiple places.", "committedDate": "2020-04-29T11:27:04Z", "type": "commit"}, {"oid": "763a8f4042bdbbfbc86edee9b55aec2b7e159531", "url": "https://github.com/SonarSource/sonar-java/commit/763a8f4042bdbbfbc86edee9b55aec2b7e159531", "message": "Remove public access modifier", "committedDate": "2020-04-29T11:27:04Z", "type": "commit"}, {"oid": "96378b500c55605649f4561bfa5dfebf32c7d110", "url": "https://github.com/SonarSource/sonar-java/commit/96378b500c55605649f4561bfa5dfebf32c7d110", "message": "Add tests for secondary locations", "committedDate": "2020-04-29T11:27:04Z", "type": "commit"}, {"oid": "46b7fa5b0f9b2b88b5f6eaf539e8e454d0c7fb85", "url": "https://github.com/SonarSource/sonar-java/commit/46b7fa5b0f9b2b88b5f6eaf539e8e454d0c7fb85", "message": "Return optional literals instead of checking literalness", "committedDate": "2020-04-29T11:27:04Z", "type": "commit"}, {"oid": "f12ff3a1f99fa1289b02b81d45f14912be828486", "url": "https://github.com/SonarSource/sonar-java/commit/f12ff3a1f99fa1289b02b81d45f14912be828486", "message": "Improve secondary messages", "committedDate": "2020-04-29T11:27:04Z", "type": "commit"}, {"oid": "f8d66aed35adea5298cbd0f2f9a39812ada267f5", "url": "https://github.com/SonarSource/sonar-java/commit/f8d66aed35adea5298cbd0f2f9a39812ada267f5", "message": "Reorder methods", "committedDate": "2020-04-29T11:27:04Z", "type": "commit"}, {"oid": "f8d66aed35adea5298cbd0f2f9a39812ada267f5", "url": "https://github.com/SonarSource/sonar-java/commit/f8d66aed35adea5298cbd0f2f9a39812ada267f5", "message": "Reorder methods", "committedDate": "2020-04-29T11:27:04Z", "type": "forcePushed"}]}