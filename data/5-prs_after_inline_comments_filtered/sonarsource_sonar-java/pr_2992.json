{"pr_number": 2992, "pr_title": "SONARJAVA-3351 Rule S5826: Methods setUp() and tearDown() should be correctly annotated starting with JUnit4", "pr_createdAt": "2020-06-09T12:25:06Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/2992", "timeline": [{"oid": "f22d8cd2f3451b6a04f7f823ac9060232138d569", "url": "https://github.com/SonarSource/sonar-java/commit/f22d8cd2f3451b6a04f7f823ac9060232138d569", "message": "SONARJAVA-3351 Deprecate rule S2391: JunitMethodDeclarationCheck", "committedDate": "2020-06-10T07:26:56Z", "type": "forcePushed"}, {"oid": "64ec5d742b2d75ac031538fd3991bd80e3c32621", "url": "https://github.com/SonarSource/sonar-java/commit/64ec5d742b2d75ac031538fd3991bd80e3c32621", "message": "SONARJAVA-3351 Deprecate rule S2391: JunitMethodDeclarationCheck", "committedDate": "2020-06-10T12:09:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYyMzI5OA==", "url": "https://github.com/SonarSource/sonar-java/pull/2992#discussion_r438623298", "bodyText": "It confuses me to not have the static modifier associated with @BeforeClass and @AfterClass. Please, add it \ud83d\ude4f", "author": "alban-auzeill", "createdAt": "2020-06-11T08:24:43Z", "path": "java-checks-test-sources/src/main/java/checks/JUnit45MethodAnnotationCheck.java", "diffHunk": "@@ -0,0 +1,94 @@\n+package checks;\n+\n+class JUnit45MethodAnnotationCheck_JUnit4_compliant1 {\n+  protected Object step() { return null; } // unrelated\n+  protected Object teaDown() { return null; } // typo from tearDown, but could be unrelated\n+  @org.junit.Test void test() { }\n+  @org.junit.Before public void setUp() { }\n+  @org.junit.After public void tearDown() { }\n+}\n+\n+class JUnit45MethodAnnotationCheck_JUnit4 {\n+  @org.junit.Test void test() { }\n+\n+  public void setUp() { } // Noncompliant [[sc=15;ec=20]] {{Annotate this method with JUnit4 '@org.junit.Before' or rename it to avoid confusion.}}\n+  public void tearDown() { }  // Noncompliant {{Annotate this method with JUnit4 '@org.junit.After' or rename it to avoid confusion.}}\n+}\n+\n+class JUnit45MethodAnnotationCheck_JUnit4_compliant {\n+  protected Object step() { return null; } // unrelated\n+  protected Object teaDown() { return null; } // typo from tearDown, but could be unrelated\n+  @org.junit.Test void test() { }\n+  @org.junit.Before public void setUp() { }\n+  @org.junit.After public void tearDown() { }\n+}\n+\n+class JUnit45MethodAnnotationCheck_JUnit4_compliant2 {\n+  @org.junit.Test void test() { }\n+  @org.junit.BeforeClass public void setUp() { }\n+  @org.junit.AfterClass public void tearDown() { }\n+}\n+\n+abstract class AbstractJUnit45MethodAnnotationCheck_JUnit4 {\n+  @org.junit.Before public void setUp() { }\n+}\n+\n+class JUnit45MethodAnnotationCheck_JUnit4_compliant3 extends AbstractJUnit45MethodAnnotationCheck_JUnit4 {\n+  @org.junit.Test void test() { }\n+\n+  @Override\n+  public void setUp() { } // Compliant\n+}\n+\n+class JUnit45MethodAnnotationCheck_JUnit5 {\n+  @org.junit.jupiter.api.Test void test() { }\n+\n+  public void setUp() { } // Noncompliant {{Annotate this method with JUnit5 '@org.junit.jupiter.api.BeforeEach' or rename it to avoid confusion.}}\n+  public void tearDown() { }  // Noncompliant {{Annotate this method with JUnit5 '@org.junit.jupiter.api.AfterEach' or rename it to avoid confusion.}}\n+}\n+\n+class JUnit45MethodAnnotationCheck_JUnit5_compliant {\n+  @org.junit.jupiter.api.Test void test() { }\n+  @org.junit.jupiter.api.BeforeEach public void setUp() { }\n+  @org.junit.jupiter.api.AfterEach public void tearDown() { }\n+}\n+\n+class JUnit45MethodAnnotationCheck_JUnit5_compliant2 {\n+  @org.junit.jupiter.api.Test void test() { }\n+  @org.junit.jupiter.api.BeforeAll public void setUp() { }\n+  @org.junit.jupiter.api.AfterAll public void tearDown() { }\n+}\n+\n+class JUnit45MethodAnnotationCheck_JUnit4_5_mixed {\n+  @org.junit.Test void junit4() { }\n+  @org.junit.jupiter.api.Test void junit5() { }\n+\n+  // use JUnit 4 annotations\n+  @org.junit.Before public void setUp() { } // Noncompliant {{Annotate this method with JUnit5 '@org.junit.jupiter.api.BeforeEach' instead of JUnit4 '@Before'.}}\n+  @org.junit.After public void tearDown() { } // Noncompliant {{Annotate this method with JUnit5 '@org.junit.jupiter.api.AfterEach' instead of JUnit4 '@After'.}}\n+\n+  @org.junit.Before public void before() { } // Noncompliant {{Annotate this method with JUnit5 '@org.junit.jupiter.api.BeforeEach' instead of JUnit4 '@Before'.}}\n+  @org.junit.After public void after() { } // Noncompliant {{Annotate this method with JUnit5 '@org.junit.jupiter.api.AfterEach' instead of JUnit4 '@After'.}}\n+}\n+\n+class JUnit45MethodAnnotationCheck_JUnit4_5_mixed2 {\n+  @org.junit.Test void junit4() { }\n+  @org.junit.jupiter.api.Test void junit5() { }\n+\n+  // use JUnit 4 annotations\n+  @org.junit.BeforeClass public void setUp() { } // Noncompliant {{Annotate this method with JUnit5 '@org.junit.jupiter.api.BeforeAll' instead of JUnit4 '@BeforeClass'.}}\n+  @org.junit.AfterClass public void tearDown() { } // Noncompliant {{Annotate this method with JUnit5 '@org.junit.jupiter.api.AfterAll' instead of JUnit4 '@AfterClass'.}}", "originalCommit": "64ec5d742b2d75ac031538fd3991bd80e3c32621", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODYyNjA0OA==", "url": "https://github.com/SonarSource/sonar-java/pull/2992#discussion_r438626048", "bodyText": "This logic leads to false-positives when a test mix junit4 and junit5:\nclass JUnit4_5_mixed_but_compliant {\n  @org.junit.Test void junit4() { }\n  @org.junit.jupiter.api.Test void junit5() { }\n\n  @org.junit.BeforeClass\n  @org.junit.jupiter.api.BeforeAll\n  public static void setUp() { } // false-positive, please don't ask me to annotate this method with JUnit5 '@org.junit.jupiter.api.BeforeAll' !!!\n\n  @org.junit.AfterClass\n  @org.junit.jupiter.api.AfterAll\n  public void tearDown() { } // false-positive\n}", "author": "alban-auzeill", "createdAt": "2020-06-11T08:29:50Z", "path": "java-checks/src/main/java/org/sonar/java/checks/tests/JUnit45MethodAnnotationCheck.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.tests;\n+\n+import com.google.common.collect.ImmutableMap;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import org.sonar.check.Rule;\n+import org.sonar.java.checks.helpers.UnitTestUtils;\n+import org.sonar.plugins.java.api.IssuableSubscriptionVisitor;\n+import org.sonar.plugins.java.api.semantic.Symbol;\n+import org.sonar.plugins.java.api.semantic.SymbolMetadata;\n+import org.sonar.plugins.java.api.tree.ClassTree;\n+import org.sonar.plugins.java.api.tree.MethodTree;\n+import org.sonar.plugins.java.api.tree.Tree;\n+\n+@Rule(key = \"S5826\")\n+public class JUnit45MethodAnnotationCheck extends IssuableSubscriptionVisitor {\n+\n+  private static final String JUNIT_SETUP = \"setUp\";\n+  private static final String JUNIT_TEARDOWN = \"tearDown\";\n+  private static final String ORG_JUNIT_AFTER = \"org.junit.After\";\n+  private static final String ORG_JUNIT_BEFORE = \"org.junit.Before\";\n+\n+  private static final Map<String, String> JUNIT4_TO_JUNIT5 = ImmutableMap\n+    .<String, String>builder()\n+    .put(ORG_JUNIT_BEFORE, \"org.junit.jupiter.api.BeforeEach\")\n+    .put(\"org.junit.BeforeClass\", \"org.junit.jupiter.api.BeforeAll\")\n+    .put(ORG_JUNIT_AFTER, \"org.junit.jupiter.api.AfterEach\")\n+    .put(\"org.junit.AfterClass\", \"org.junit.jupiter.api.AfterAll\")\n+    .build();\n+\n+  private static final Set<String> JUNIT4_ANNOTATIONS = JUNIT4_TO_JUNIT5.keySet();\n+  private static final Set<String> JUNIT5_ANNOTATIONS = new HashSet<>(JUNIT4_TO_JUNIT5.values());\n+\n+  @Override\n+  public List<Tree.Kind> nodesToVisit() {\n+    return Collections.singletonList(Tree.Kind.CLASS);\n+  }\n+\n+  @Override\n+  public void visitNode(Tree tree) {\n+    ClassTree classTree = (ClassTree) tree;\n+\n+    List<MethodTree> methods = classTree.members().stream()\n+      .filter(member -> member.is(Tree.Kind.METHOD))\n+      .map(MethodTree.class::cast)\n+      .collect(Collectors.toList());\n+\n+    int jUnitVersion = getJUnitVersion(methods);\n+    if (jUnitVersion > 0) {\n+      methods.forEach(methodTree -> checkJUnitMethod(methodTree, jUnitVersion));\n+    }\n+  }\n+\n+  private static int getJUnitVersion(List<MethodTree> methods) {\n+    boolean containsJUnit4Tests = false;\n+    for (MethodTree methodTree : methods) {\n+      SymbolMetadata metadata = methodTree.symbol().metadata();\n+      containsJUnit4Tests |= metadata.isAnnotatedWith(\"org.junit.Test\");\n+      if (UnitTestUtils.hasJUnit5TestAnnotation(methodTree)) {\n+        // While migrating from JUnit4 to JUnit5, classes might end up in mixed state of having tests using both versions.\n+        // If it's the case, we consider the test classes as ultimately targeting 5\n+        return 5;\n+      }\n+    }\n+    return containsJUnit4Tests ? 4 : -1;\n+  }\n+\n+  private void checkJUnitMethod(MethodTree methodTree, int jUnitVersion) {\n+    String name = methodTree.simpleName().name();\n+    if (isSetupTearDown(name) || (jUnitVersion == 5 && isAnnotatedWith(methodTree, ORG_JUNIT_BEFORE, ORG_JUNIT_AFTER))) {\n+      checkSetupTearDownSignature(methodTree, jUnitVersion);\n+    }\n+  }\n+\n+  private void checkSetupTearDownSignature(MethodTree methodTree, int jUnitVersion) {\n+    Symbol.MethodSymbol symbol = methodTree.symbol();\n+    if (symbol.overriddenSymbol() != null) {\n+      // Annotation can be in a parent.\n+      return;\n+    }\n+\n+    SymbolMetadata metadata = symbol.metadata();\n+    Optional<String> junit4Annotation = JUNIT4_ANNOTATIONS.stream().filter(metadata::isAnnotatedWith).findFirst();\n+    if (jUnitVersion == 5 && junit4Annotation.isPresent()) {\n+      String jUnit4Annotation = junit4Annotation.get();\n+      reportIssue(methodTree.simpleName(), String.format(\"Annotate this method with JUnit5 '@%s' instead of JUnit4 '@%s'.\",\n+        JUNIT4_TO_JUNIT5.get(jUnit4Annotation),\n+        jUnit4Annotation.substring(jUnit4Annotation.lastIndexOf('.') + 1)));\n+    } else if (!junit4Annotation.isPresent() && JUNIT5_ANNOTATIONS.stream().noneMatch(metadata::isAnnotatedWith)) {\n+      reportIssue(methodTree.simpleName(), String.format(\"Annotate this method with JUnit%d '@%s' or rename it to avoid confusion.\",\n+        jUnitVersion,\n+        expectedAnnotation(symbol, jUnitVersion)));\n+    }", "originalCommit": "64ec5d742b2d75ac031538fd3991bd80e3c32621", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7d7764ebadbbae33d763a57fed6adee37ee1be16", "url": "https://github.com/SonarSource/sonar-java/commit/7d7764ebadbbae33d763a57fed6adee37ee1be16", "message": "SONARJAVA-3351 Rule S5826: Methods setUp() and tearDown() should be correctly annotated starting with JUnit4", "committedDate": "2020-06-12T08:29:45Z", "type": "commit"}, {"oid": "0afec7745cd4b360534e02ffdbd8f8a02ed64d60", "url": "https://github.com/SonarSource/sonar-java/commit/0afec7745cd4b360534e02ffdbd8f8a02ed64d60", "message": "SONARJAVA-3351 Deprecate rule S2391: JunitMethodDeclarationCheck", "committedDate": "2020-06-12T08:29:45Z", "type": "commit"}, {"oid": "0afec7745cd4b360534e02ffdbd8f8a02ed64d60", "url": "https://github.com/SonarSource/sonar-java/commit/0afec7745cd4b360534e02ffdbd8f8a02ed64d60", "message": "SONARJAVA-3351 Deprecate rule S2391: JunitMethodDeclarationCheck", "committedDate": "2020-06-12T08:29:45Z", "type": "forcePushed"}]}