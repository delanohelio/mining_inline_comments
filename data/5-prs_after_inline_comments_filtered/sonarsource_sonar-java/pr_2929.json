{"pr_number": 2929, "pr_title": "Sonarjava 3361 junit assert true should be simplified", "pr_createdAt": "2020-04-29T15:55:28Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/2929", "timeline": [{"oid": "166af2b430f9cd31bb9b7e0645aee376fc513466", "url": "https://github.com/SonarSource/sonar-java/commit/166af2b430f9cd31bb9b7e0645aee376fc513466", "message": "SONARJAVA-3361 Implemented logic to flag usages of assertTrue that could better be represented by another assertion method (i.e. assert(Not)Equals, assert(Not)Same or assert(Not)Null).", "committedDate": "2020-04-28T09:22:43Z", "type": "commit"}, {"oid": "22f076ec380b0864507b838726b25cc1aea04727", "url": "https://github.com/SonarSource/sonar-java/commit/22f076ec380b0864507b838726b25cc1aea04727", "message": "Merge branch 'master' into SONARJAVA-3361-JUnitAssertTrueShouldBeSimplified", "committedDate": "2020-04-28T11:56:54Z", "type": "commit"}, {"oid": "3d7d61ad6fff9e7d0be378c6bff46ee39f2ae40f", "url": "https://github.com/SonarSource/sonar-java/commit/3d7d61ad6fff9e7d0be378c6bff46ee39f2ae40f", "message": "SONARJAVA-3361 Added support for other JUnit4 assertions, as well as JUnit5 assertions. Added support for assertFalse in addition to assertTrue.", "committedDate": "2020-04-28T15:29:11Z", "type": "commit"}, {"oid": "0a5a43f8170eefc9e3c890125ff338b945a0e9ea", "url": "https://github.com/SonarSource/sonar-java/commit/0a5a43f8170eefc9e3c890125ff338b945a0e9ea", "message": "SONARJAVA-3361 Improved handling of primitive comparisons in assertions. Improved code style.", "committedDate": "2020-04-29T11:53:29Z", "type": "commit"}, {"oid": "cfa804f56c9509f57a74e7967e180a6d30a3051f", "url": "https://github.com/SonarSource/sonar-java/commit/cfa804f56c9509f57a74e7967e180a6d30a3051f", "message": "SONARJAVA-3361 Added new-found issues to rule integration testing.", "committedDate": "2020-04-29T13:59:57Z", "type": "commit"}, {"oid": "d3f8aedf8fbf2a2f703018b5896b29327f7085c9", "url": "https://github.com/SonarSource/sonar-java/commit/d3f8aedf8fbf2a2f703018b5896b29327f7085c9", "message": "SONARJAVA-3361 Improved description and title to include assertFalse. Also made description more generic by talking about 'JUnit's assertTrue() and assertFalse()' instead of 'org.junit.Assert.assertTrue()' (which is only one of the various applicable assert methods).", "committedDate": "2020-04-29T14:29:45Z", "type": "commit"}, {"oid": "a3eef51a0a5fd9402e56c023910ecda03a50450f", "url": "https://github.com/SonarSource/sonar-java/commit/a3eef51a0a5fd9402e56c023910ecda03a50450f", "message": "Removed unnecessary @Nonnull annotations, using Optional instead of null return values.", "committedDate": "2020-04-29T15:53:34Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ0Mjk5MA==", "url": "https://github.com/SonarSource/sonar-java/pull/2929#discussion_r418442990", "bodyText": "Here, we should use a method matcher like: EQUALS_METHODS.matches((MethodInvocationTree) argumentExpression) to not have false-positive with for a method that has a different signature.\nWith the following definition:\nprivate static final MethodMatchers EQUALS_METHODS = MethodMatchers.or(\n  MethodMatchers.create().ofAnyType().names(\"equals\").addParametersMatcher(\"java.lang.Object\").build(),\n  MethodMatchers.create().ofTypes(\"java.util.Objects\").names(\"equals\").addParametersMatcher(\"java.lang.Object\",\"java.lang.Object\").build())", "author": "alban-auzeill", "createdAt": "2020-05-01T07:12:47Z", "path": "java-checks/src/main/java/org/sonar/java/checks/AssertTrueInsteadOfDedicatedAssertCheck.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.annotation.Nullable;\n+import org.sonar.check.Rule;\n+import org.sonar.java.checks.methods.AbstractMethodDetection;\n+import org.sonar.java.model.ExpressionUtils;\n+import org.sonar.plugins.java.api.JavaFileScannerContext;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Type;\n+import org.sonar.plugins.java.api.tree.Arguments;\n+import org.sonar.plugins.java.api.tree.BinaryExpressionTree;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.UnaryExpressionTree;\n+\n+import static org.sonar.plugins.java.api.tree.Tree.Kind.NULL_LITERAL;\n+\n+@Rule(key = \"S5785\")\n+public class AssertTrueInsteadOfDedicatedAssertCheck extends AbstractMethodDetection {\n+\n+  private static final String[] ASSERT_METHOD_NAMES = {\"assertTrue\", \"assertFalse\"};\n+  private static final String[] ASSERTION_CLASSES = {\n+    // JUnit4\n+    \"org.junit.Assert\",\n+    \"junit.framework.TestCase\",\n+    // JUnit4 (deprecated)\n+    \"junit.framework.Assert\",\n+    // JUnit5\n+    \"org.junit.jupiter.api.Assertions\"\n+  };\n+\n+  private enum Assertion {\n+    NULL(\"Null\", \"A null-check\"),\n+    NOT_NULL(\"NotNull\", \"A null-check\"),\n+    SAME(\"Same\", \"An object reference comparison\"),\n+    NOT_SAME(\"NotSame\", \"An object reference comparison\"),\n+    EQUALS(\"Equals\", \"An equals check\"),\n+    NOT_EQUALS(\"NotEquals\", \"An equals check\");\n+\n+    public final String methodName;\n+    public final String actionDescription;\n+\n+    Assertion(String namePostfix, String actionDescription) {\n+      methodName = \"assert\" + namePostfix;\n+      this.actionDescription = actionDescription;\n+    }\n+  }\n+\n+  @Override\n+  protected MethodMatchers getMethodInvocationMatchers() {\n+    return MethodMatchers.create().ofTypes(ASSERTION_CLASSES).names(ASSERT_METHOD_NAMES).withAnyParameters().build();\n+  }\n+\n+  @Override\n+  protected void onMethodInvocationFound(MethodInvocationTree mit) {\n+    if (!hasSemantic()) {\n+      return;\n+    }\n+\n+    Arguments arguments = mit.arguments();\n+\n+    ExpressionTree argumentExpression;\n+    if (hasBooleanArgumentAtPosition(arguments, 0)) {\n+      argumentExpression = arguments.get(0);\n+    } else if (hasBooleanArgumentAtPosition(arguments, arguments.size() - 1)) {\n+      argumentExpression = arguments.get(arguments.size() - 1);\n+    } else {\n+      // We encountered a JUnit5 assert[True|False] method that accepts a BooleanSupplier - not supported.\n+      return;\n+    }\n+\n+    Optional<Assertion> replacementAssertionOpt = getReplacementAssertion(argumentExpression);\n+\n+    if (replacementAssertionOpt.isPresent()) {\n+      IdentifierTree problematicAssertionCallIdentifier = ExpressionUtils.methodName(mit);\n+      if (problematicAssertionCallIdentifier.name().equals(\"assertFalse\")) {\n+        replacementAssertionOpt = complement(replacementAssertionOpt.get());\n+\n+        if (!replacementAssertionOpt.isPresent()) {\n+          return;\n+        }\n+      }\n+\n+      Assertion replacementAssertion = replacementAssertionOpt.get();\n+\n+      List<JavaFileScannerContext.Location> secondaryLocation = Collections.singletonList(new JavaFileScannerContext.Location(\n+        String.format(\"%s is performed here, which is better expressed with %s.\",\n+          replacementAssertion.actionDescription, replacementAssertion.methodName),\n+        argumentExpression));\n+      String message = String.format(\"Use %s instead.\", replacementAssertion.methodName);\n+\n+      reportIssue(problematicAssertionCallIdentifier, message, secondaryLocation, null);\n+    }\n+  }\n+\n+  private static boolean hasBooleanArgumentAtPosition(Arguments arguments, int index) {\n+    return arguments.size() > index && arguments.get(index).symbolType().isPrimitive(Type.Primitives.BOOLEAN);\n+  }\n+\n+  /**\n+   * Returns the assertX method that should be used instead of assertTrue, if applicable.\n+   *\n+   * @param argumentExpression the boolean expression passed to assertTrue\n+   * @return the assertion method to be used instead of assertTrue, or {@code null} if no better assertion method was determined\n+   */\n+  private static Optional<Assertion> getReplacementAssertion(@Nullable ExpressionTree argumentExpression) {\n+    if (argumentExpression == null) {\n+      return Optional.empty();\n+    }\n+\n+    Assertion assertion = null;\n+\n+    switch (argumentExpression.kind()) {\n+      case EQUAL_TO:\n+        if (isCheckForNull((BinaryExpressionTree) argumentExpression)) {\n+          assertion = Assertion.NULL;\n+        } else if (isPrimitiveComparison((BinaryExpressionTree) argumentExpression)) {\n+          assertion = Assertion.EQUALS;\n+        } else {\n+          assertion = Assertion.SAME;\n+        }\n+        break;\n+      case NOT_EQUAL_TO:\n+        if (isCheckForNull((BinaryExpressionTree) argumentExpression)) {\n+          assertion = Assertion.NOT_NULL;\n+        } else if (isPrimitiveComparison((BinaryExpressionTree) argumentExpression)) {\n+          assertion = Assertion.NOT_EQUALS;\n+        } else {\n+          assertion = Assertion.NOT_SAME;\n+        }\n+        break;\n+      case METHOD_INVOCATION:\n+        if (ExpressionUtils.methodName((MethodInvocationTree) argumentExpression).name().equals(\"equals\")) {", "originalCommit": "a3eef51a0a5fd9402e56c023910ecda03a50450f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ2Njk3Mg==", "url": "https://github.com/SonarSource/sonar-java/pull/2929#discussion_r418466972", "bodyText": "IMO it would be simpler to remove this complement method and instead use a map. For example:\n  private static final Map<Assertion, Assertion> COMPLEMENT_MAP = ImmutableMap.<Assertion, Assertion>builder()\n    .put(Assertion.NULL, Assertion.NOT_NULL)\n    .put(Assertion.NOT_NULL, Assertion.NULL)\n    .put(Assertion.SAME, Assertion.NOT_SAME)\n    .put(Assertion.NOT_SAME, Assertion.SAME)\n    .put(Assertion.EQUALS, Assertion.NOT_EQUALS)\n    .put(Assertion.NOT_EQUALS, Assertion.EQUALS)\n    .build();\n\nThen we can replace:\nreplacementAssertionOpt = complement(replacementAssertionOpt.get());\n\nby\nreplacementAssertionOpt = replacementAssertionOpt.map(COMPLEMENT_MAP::get);\n\nand\n      case LOGICAL_COMPLEMENT:\n        return complement(getReplacementAssertion(((UnaryExpressionTree) argumentExpression).expression()).orElse(null));\n\nby\n      case LOGICAL_COMPLEMENT:\n        return getReplacementAssertion(((UnaryExpressionTree) argumentExpression).expression()).map(COMPLEMENT_MAP::get);\n\nAnd about simplification, we could also simplify the second part of the logic in onMethodInvocationFound by not using Optional#isPresent() and  Optional#get(). IMO this pattern loses the adventage of Optional versus null.\nMy proposal is:\n    IdentifierTree problematicAssertionCallIdentifier = ExpressionUtils.methodName(mit);\n    Optional<Assertion> replacementAssertionOpt = getReplacementAssertion(argumentExpression);\n    if (problematicAssertionCallIdentifier.name().equals(\"assertFalse\")) {\n      replacementAssertionOpt = replacementAssertionOpt.map(COMPLEMENT_MAP::get);\n    }\n    replacementAssertionOpt.ifPresent(replacementAssertion -> reportIssue(\n      problematicAssertionCallIdentifier,\n      String.format(\"Use %s instead.\", replacementAssertion.methodName),\n      Collections.singletonList(new JavaFileScannerContext.Location(\n        String.format(\"%s is performed here, which is better expressed with %s.\",\n          replacementAssertion.actionDescription, replacementAssertion.methodName),\n        argumentExpression)),\n      null));\n\nAnd then I would move the responsibility of the message formating in the Assertion enum and replace the end by:\n    replacementAssertionOpt.ifPresent(replacementAssertion -> reportIssue(\n      problematicAssertionCallIdentifier,\n      replacementAssertion.actionMessage(),\n      Collections.singletonList(\n        new JavaFileScannerContext.Location(replacementAssertion.descriptionMessage(), argumentExpression)), null)\n    );\n\nThen I would remove all the logic about hasBooleanArgumentAtPosition, it's not 100% covered and it's hard to cover. By a logic that try to find the first boolean argument:\n  @Override\n  protected void onMethodInvocationFound(MethodInvocationTree mit) {\n    mit.arguments().stream()\n      .filter(argument -> argument.symbolType().isPrimitive(Type.Primitives.BOOLEAN))\n      .findFirst()\n      .ifPresent(argument -> checkBooleanExpressionInAssertMethod(ExpressionUtils.methodName(mit), argument));\n  }\n\n  private void checkBooleanExpressionInAssertMethod(IdentifierTree assertMethodIdentifier, ExpressionTree booleanExpression) {\n    Optional<Assertion> replacementAssertionOpt = getReplacementAssertion(booleanExpression);\n    if (assertMethodIdentifier.name().equals(\"assertFalse\")) {\n      replacementAssertionOpt = replacementAssertionOpt.map(COMPLEMENT_MAP::get);\n    }\n    replacementAssertionOpt.ifPresent(replacementAssertion -> reportIssue(assertMethodIdentifier, replacementAssertion.actionMessage(),\n      Collections.singletonList(new JavaFileScannerContext.Location(replacementAssertion.descriptionMessage(), booleanExpression)), null));\n  }", "author": "alban-auzeill", "createdAt": "2020-05-01T08:51:15Z", "path": "java-checks/src/main/java/org/sonar/java/checks/AssertTrueInsteadOfDedicatedAssertCheck.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.annotation.Nullable;\n+import org.sonar.check.Rule;\n+import org.sonar.java.checks.methods.AbstractMethodDetection;\n+import org.sonar.java.model.ExpressionUtils;\n+import org.sonar.plugins.java.api.JavaFileScannerContext;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Type;\n+import org.sonar.plugins.java.api.tree.Arguments;\n+import org.sonar.plugins.java.api.tree.BinaryExpressionTree;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.UnaryExpressionTree;\n+\n+import static org.sonar.plugins.java.api.tree.Tree.Kind.NULL_LITERAL;\n+\n+@Rule(key = \"S5785\")\n+public class AssertTrueInsteadOfDedicatedAssertCheck extends AbstractMethodDetection {\n+\n+  private static final String[] ASSERT_METHOD_NAMES = {\"assertTrue\", \"assertFalse\"};\n+  private static final String[] ASSERTION_CLASSES = {\n+    // JUnit4\n+    \"org.junit.Assert\",\n+    \"junit.framework.TestCase\",\n+    // JUnit4 (deprecated)\n+    \"junit.framework.Assert\",\n+    // JUnit5\n+    \"org.junit.jupiter.api.Assertions\"\n+  };\n+\n+  private enum Assertion {\n+    NULL(\"Null\", \"A null-check\"),\n+    NOT_NULL(\"NotNull\", \"A null-check\"),\n+    SAME(\"Same\", \"An object reference comparison\"),\n+    NOT_SAME(\"NotSame\", \"An object reference comparison\"),\n+    EQUALS(\"Equals\", \"An equals check\"),\n+    NOT_EQUALS(\"NotEquals\", \"An equals check\");\n+\n+    public final String methodName;\n+    public final String actionDescription;\n+\n+    Assertion(String namePostfix, String actionDescription) {\n+      methodName = \"assert\" + namePostfix;\n+      this.actionDescription = actionDescription;\n+    }\n+  }\n+\n+  @Override\n+  protected MethodMatchers getMethodInvocationMatchers() {\n+    return MethodMatchers.create().ofTypes(ASSERTION_CLASSES).names(ASSERT_METHOD_NAMES).withAnyParameters().build();\n+  }\n+\n+  @Override\n+  protected void onMethodInvocationFound(MethodInvocationTree mit) {\n+    if (!hasSemantic()) {\n+      return;\n+    }\n+\n+    Arguments arguments = mit.arguments();\n+\n+    ExpressionTree argumentExpression;\n+    if (hasBooleanArgumentAtPosition(arguments, 0)) {\n+      argumentExpression = arguments.get(0);\n+    } else if (hasBooleanArgumentAtPosition(arguments, arguments.size() - 1)) {\n+      argumentExpression = arguments.get(arguments.size() - 1);\n+    } else {\n+      // We encountered a JUnit5 assert[True|False] method that accepts a BooleanSupplier - not supported.\n+      return;\n+    }\n+\n+    Optional<Assertion> replacementAssertionOpt = getReplacementAssertion(argumentExpression);\n+\n+    if (replacementAssertionOpt.isPresent()) {\n+      IdentifierTree problematicAssertionCallIdentifier = ExpressionUtils.methodName(mit);\n+      if (problematicAssertionCallIdentifier.name().equals(\"assertFalse\")) {\n+        replacementAssertionOpt = complement(replacementAssertionOpt.get());\n+\n+        if (!replacementAssertionOpt.isPresent()) {\n+          return;\n+        }\n+      }\n+\n+      Assertion replacementAssertion = replacementAssertionOpt.get();\n+\n+      List<JavaFileScannerContext.Location> secondaryLocation = Collections.singletonList(new JavaFileScannerContext.Location(\n+        String.format(\"%s is performed here, which is better expressed with %s.\",\n+          replacementAssertion.actionDescription, replacementAssertion.methodName),\n+        argumentExpression));\n+      String message = String.format(\"Use %s instead.\", replacementAssertion.methodName);\n+\n+      reportIssue(problematicAssertionCallIdentifier, message, secondaryLocation, null);\n+    }\n+  }\n+\n+  private static boolean hasBooleanArgumentAtPosition(Arguments arguments, int index) {\n+    return arguments.size() > index && arguments.get(index).symbolType().isPrimitive(Type.Primitives.BOOLEAN);\n+  }\n+\n+  /**\n+   * Returns the assertX method that should be used instead of assertTrue, if applicable.\n+   *\n+   * @param argumentExpression the boolean expression passed to assertTrue\n+   * @return the assertion method to be used instead of assertTrue, or {@code null} if no better assertion method was determined\n+   */\n+  private static Optional<Assertion> getReplacementAssertion(@Nullable ExpressionTree argumentExpression) {\n+    if (argumentExpression == null) {\n+      return Optional.empty();\n+    }\n+\n+    Assertion assertion = null;\n+\n+    switch (argumentExpression.kind()) {\n+      case EQUAL_TO:\n+        if (isCheckForNull((BinaryExpressionTree) argumentExpression)) {\n+          assertion = Assertion.NULL;\n+        } else if (isPrimitiveComparison((BinaryExpressionTree) argumentExpression)) {\n+          assertion = Assertion.EQUALS;\n+        } else {\n+          assertion = Assertion.SAME;\n+        }\n+        break;\n+      case NOT_EQUAL_TO:\n+        if (isCheckForNull((BinaryExpressionTree) argumentExpression)) {\n+          assertion = Assertion.NOT_NULL;\n+        } else if (isPrimitiveComparison((BinaryExpressionTree) argumentExpression)) {\n+          assertion = Assertion.NOT_EQUALS;\n+        } else {\n+          assertion = Assertion.NOT_SAME;\n+        }\n+        break;\n+      case METHOD_INVOCATION:\n+        if (ExpressionUtils.methodName((MethodInvocationTree) argumentExpression).name().equals(\"equals\")) {\n+          assertion = Assertion.EQUALS;\n+        }\n+        break;\n+      case LOGICAL_COMPLEMENT:\n+        return complement(getReplacementAssertion(((UnaryExpressionTree) argumentExpression).expression()).orElse(null));\n+      default:\n+    }\n+\n+    return Optional.ofNullable(assertion);\n+  }\n+\n+  private static boolean isCheckForNull(BinaryExpressionTree bet) {\n+    return bet.leftOperand().is(NULL_LITERAL) || bet.rightOperand().is(NULL_LITERAL);\n+  }\n+\n+  private static boolean isPrimitiveComparison(BinaryExpressionTree bet) {\n+    return bet.leftOperand().symbolType().isPrimitive() || bet.rightOperand().symbolType().isPrimitive();\n+  }\n+\n+  private static Optional<Assertion> complement(@Nullable Assertion assertion) {\n+    if (assertion == null) {\n+      return Optional.empty();\n+    }\n+\n+    Assertion complement = null;\n+    switch (assertion) {\n+      case NULL:\n+        complement = Assertion.NOT_NULL;\n+        break;\n+      case NOT_NULL:\n+        complement = Assertion.NULL;\n+        break;\n+      case SAME:\n+        complement = Assertion.NOT_SAME;\n+        break;\n+      case NOT_SAME:\n+        complement = Assertion.SAME;\n+        break;\n+      case EQUALS:\n+        complement = Assertion.NOT_EQUALS;\n+        break;\n+      case NOT_EQUALS:\n+        complement = Assertion.EQUALS;\n+        break;\n+    }\n+\n+    return Optional.of(complement);\n+  }", "originalCommit": "a3eef51a0a5fd9402e56c023910ecda03a50450f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ2Nzk3MQ==", "url": "https://github.com/SonarSource/sonar-java/pull/2929#discussion_r418467971", "bodyText": "The test about hasSemantic() is useful for checks that extends IssuableSubscriptionVisitor. But because AbstractMethodDetection already do this test, we don't need it.", "author": "alban-auzeill", "createdAt": "2020-05-01T08:54:40Z", "path": "java-checks/src/main/java/org/sonar/java/checks/AssertTrueInsteadOfDedicatedAssertCheck.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.annotation.Nullable;\n+import org.sonar.check.Rule;\n+import org.sonar.java.checks.methods.AbstractMethodDetection;\n+import org.sonar.java.model.ExpressionUtils;\n+import org.sonar.plugins.java.api.JavaFileScannerContext;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Type;\n+import org.sonar.plugins.java.api.tree.Arguments;\n+import org.sonar.plugins.java.api.tree.BinaryExpressionTree;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.UnaryExpressionTree;\n+\n+import static org.sonar.plugins.java.api.tree.Tree.Kind.NULL_LITERAL;\n+\n+@Rule(key = \"S5785\")\n+public class AssertTrueInsteadOfDedicatedAssertCheck extends AbstractMethodDetection {\n+\n+  private static final String[] ASSERT_METHOD_NAMES = {\"assertTrue\", \"assertFalse\"};\n+  private static final String[] ASSERTION_CLASSES = {\n+    // JUnit4\n+    \"org.junit.Assert\",\n+    \"junit.framework.TestCase\",\n+    // JUnit4 (deprecated)\n+    \"junit.framework.Assert\",\n+    // JUnit5\n+    \"org.junit.jupiter.api.Assertions\"\n+  };\n+\n+  private enum Assertion {\n+    NULL(\"Null\", \"A null-check\"),\n+    NOT_NULL(\"NotNull\", \"A null-check\"),\n+    SAME(\"Same\", \"An object reference comparison\"),\n+    NOT_SAME(\"NotSame\", \"An object reference comparison\"),\n+    EQUALS(\"Equals\", \"An equals check\"),\n+    NOT_EQUALS(\"NotEquals\", \"An equals check\");\n+\n+    public final String methodName;\n+    public final String actionDescription;\n+\n+    Assertion(String namePostfix, String actionDescription) {\n+      methodName = \"assert\" + namePostfix;\n+      this.actionDescription = actionDescription;\n+    }\n+  }\n+\n+  @Override\n+  protected MethodMatchers getMethodInvocationMatchers() {\n+    return MethodMatchers.create().ofTypes(ASSERTION_CLASSES).names(ASSERT_METHOD_NAMES).withAnyParameters().build();\n+  }\n+\n+  @Override\n+  protected void onMethodInvocationFound(MethodInvocationTree mit) {\n+    if (!hasSemantic()) {\n+      return;\n+    }", "originalCommit": "a3eef51a0a5fd9402e56c023910ecda03a50450f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ3MTI1Nw==", "url": "https://github.com/SonarSource/sonar-java/pull/2929#discussion_r418471257", "bodyText": "Let's add a test case to cover this case, and we can even use a false-negative to explicitly show the limitation of this rule:\nAssertions.assertTrue(() -> foo == bar); // false-negative because BooleanSupplier is not supported by this rule", "author": "alban-auzeill", "createdAt": "2020-05-01T09:07:01Z", "path": "java-checks/src/main/java/org/sonar/java/checks/AssertTrueInsteadOfDedicatedAssertCheck.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.annotation.Nullable;\n+import org.sonar.check.Rule;\n+import org.sonar.java.checks.methods.AbstractMethodDetection;\n+import org.sonar.java.model.ExpressionUtils;\n+import org.sonar.plugins.java.api.JavaFileScannerContext;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Type;\n+import org.sonar.plugins.java.api.tree.Arguments;\n+import org.sonar.plugins.java.api.tree.BinaryExpressionTree;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.UnaryExpressionTree;\n+\n+import static org.sonar.plugins.java.api.tree.Tree.Kind.NULL_LITERAL;\n+\n+@Rule(key = \"S5785\")\n+public class AssertTrueInsteadOfDedicatedAssertCheck extends AbstractMethodDetection {\n+\n+  private static final String[] ASSERT_METHOD_NAMES = {\"assertTrue\", \"assertFalse\"};\n+  private static final String[] ASSERTION_CLASSES = {\n+    // JUnit4\n+    \"org.junit.Assert\",\n+    \"junit.framework.TestCase\",\n+    // JUnit4 (deprecated)\n+    \"junit.framework.Assert\",\n+    // JUnit5\n+    \"org.junit.jupiter.api.Assertions\"\n+  };\n+\n+  private enum Assertion {\n+    NULL(\"Null\", \"A null-check\"),\n+    NOT_NULL(\"NotNull\", \"A null-check\"),\n+    SAME(\"Same\", \"An object reference comparison\"),\n+    NOT_SAME(\"NotSame\", \"An object reference comparison\"),\n+    EQUALS(\"Equals\", \"An equals check\"),\n+    NOT_EQUALS(\"NotEquals\", \"An equals check\");\n+\n+    public final String methodName;\n+    public final String actionDescription;\n+\n+    Assertion(String namePostfix, String actionDescription) {\n+      methodName = \"assert\" + namePostfix;\n+      this.actionDescription = actionDescription;\n+    }\n+  }\n+\n+  @Override\n+  protected MethodMatchers getMethodInvocationMatchers() {\n+    return MethodMatchers.create().ofTypes(ASSERTION_CLASSES).names(ASSERT_METHOD_NAMES).withAnyParameters().build();\n+  }\n+\n+  @Override\n+  protected void onMethodInvocationFound(MethodInvocationTree mit) {\n+    if (!hasSemantic()) {\n+      return;\n+    }\n+\n+    Arguments arguments = mit.arguments();\n+\n+    ExpressionTree argumentExpression;\n+    if (hasBooleanArgumentAtPosition(arguments, 0)) {\n+      argumentExpression = arguments.get(0);\n+    } else if (hasBooleanArgumentAtPosition(arguments, arguments.size() - 1)) {\n+      argumentExpression = arguments.get(arguments.size() - 1);\n+    } else {\n+      // We encountered a JUnit5 assert[True|False] method that accepts a BooleanSupplier - not supported.\n+      return;", "originalCommit": "a3eef51a0a5fd9402e56c023910ecda03a50450f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODQ4MDM3OA==", "url": "https://github.com/SonarSource/sonar-java/pull/2929#discussion_r418480378", "bodyText": "argumentExpression can not be null, if we pass a value to getReplacementAssertion coming from methods not annotated by @Nullable or @CheckForNull. It's enough to ensure that it's never null.", "author": "alban-auzeill", "createdAt": "2020-05-01T09:42:02Z", "path": "java-checks/src/main/java/org/sonar/java/checks/AssertTrueInsteadOfDedicatedAssertCheck.java", "diffHunk": "@@ -0,0 +1,205 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Optional;\n+import javax.annotation.Nullable;\n+import org.sonar.check.Rule;\n+import org.sonar.java.checks.methods.AbstractMethodDetection;\n+import org.sonar.java.model.ExpressionUtils;\n+import org.sonar.plugins.java.api.JavaFileScannerContext;\n+import org.sonar.plugins.java.api.semantic.MethodMatchers;\n+import org.sonar.plugins.java.api.semantic.Type;\n+import org.sonar.plugins.java.api.tree.Arguments;\n+import org.sonar.plugins.java.api.tree.BinaryExpressionTree;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.IdentifierTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+import org.sonar.plugins.java.api.tree.UnaryExpressionTree;\n+\n+import static org.sonar.plugins.java.api.tree.Tree.Kind.NULL_LITERAL;\n+\n+@Rule(key = \"S5785\")\n+public class AssertTrueInsteadOfDedicatedAssertCheck extends AbstractMethodDetection {\n+\n+  private static final String[] ASSERT_METHOD_NAMES = {\"assertTrue\", \"assertFalse\"};\n+  private static final String[] ASSERTION_CLASSES = {\n+    // JUnit4\n+    \"org.junit.Assert\",\n+    \"junit.framework.TestCase\",\n+    // JUnit4 (deprecated)\n+    \"junit.framework.Assert\",\n+    // JUnit5\n+    \"org.junit.jupiter.api.Assertions\"\n+  };\n+\n+  private enum Assertion {\n+    NULL(\"Null\", \"A null-check\"),\n+    NOT_NULL(\"NotNull\", \"A null-check\"),\n+    SAME(\"Same\", \"An object reference comparison\"),\n+    NOT_SAME(\"NotSame\", \"An object reference comparison\"),\n+    EQUALS(\"Equals\", \"An equals check\"),\n+    NOT_EQUALS(\"NotEquals\", \"An equals check\");\n+\n+    public final String methodName;\n+    public final String actionDescription;\n+\n+    Assertion(String namePostfix, String actionDescription) {\n+      methodName = \"assert\" + namePostfix;\n+      this.actionDescription = actionDescription;\n+    }\n+  }\n+\n+  @Override\n+  protected MethodMatchers getMethodInvocationMatchers() {\n+    return MethodMatchers.create().ofTypes(ASSERTION_CLASSES).names(ASSERT_METHOD_NAMES).withAnyParameters().build();\n+  }\n+\n+  @Override\n+  protected void onMethodInvocationFound(MethodInvocationTree mit) {\n+    if (!hasSemantic()) {\n+      return;\n+    }\n+\n+    Arguments arguments = mit.arguments();\n+\n+    ExpressionTree argumentExpression;\n+    if (hasBooleanArgumentAtPosition(arguments, 0)) {\n+      argumentExpression = arguments.get(0);\n+    } else if (hasBooleanArgumentAtPosition(arguments, arguments.size() - 1)) {\n+      argumentExpression = arguments.get(arguments.size() - 1);\n+    } else {\n+      // We encountered a JUnit5 assert[True|False] method that accepts a BooleanSupplier - not supported.\n+      return;\n+    }\n+\n+    Optional<Assertion> replacementAssertionOpt = getReplacementAssertion(argumentExpression);\n+\n+    if (replacementAssertionOpt.isPresent()) {\n+      IdentifierTree problematicAssertionCallIdentifier = ExpressionUtils.methodName(mit);\n+      if (problematicAssertionCallIdentifier.name().equals(\"assertFalse\")) {\n+        replacementAssertionOpt = complement(replacementAssertionOpt.get());\n+\n+        if (!replacementAssertionOpt.isPresent()) {\n+          return;\n+        }\n+      }\n+\n+      Assertion replacementAssertion = replacementAssertionOpt.get();\n+\n+      List<JavaFileScannerContext.Location> secondaryLocation = Collections.singletonList(new JavaFileScannerContext.Location(\n+        String.format(\"%s is performed here, which is better expressed with %s.\",\n+          replacementAssertion.actionDescription, replacementAssertion.methodName),\n+        argumentExpression));\n+      String message = String.format(\"Use %s instead.\", replacementAssertion.methodName);\n+\n+      reportIssue(problematicAssertionCallIdentifier, message, secondaryLocation, null);\n+    }\n+  }\n+\n+  private static boolean hasBooleanArgumentAtPosition(Arguments arguments, int index) {\n+    return arguments.size() > index && arguments.get(index).symbolType().isPrimitive(Type.Primitives.BOOLEAN);\n+  }\n+\n+  /**\n+   * Returns the assertX method that should be used instead of assertTrue, if applicable.\n+   *\n+   * @param argumentExpression the boolean expression passed to assertTrue\n+   * @return the assertion method to be used instead of assertTrue, or {@code null} if no better assertion method was determined\n+   */\n+  private static Optional<Assertion> getReplacementAssertion(@Nullable ExpressionTree argumentExpression) {\n+    if (argumentExpression == null) {\n+      return Optional.empty();\n+    }", "originalCommit": "a3eef51a0a5fd9402e56c023910ecda03a50450f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "96954cc1e2b93548176599da101b26cfe7fa9f94", "url": "https://github.com/SonarSource/sonar-java/commit/96954cc1e2b93548176599da101b26cfe7fa9f94", "message": "SONARJAVA-3361 Improved various code quality and logic aspects after review.", "committedDate": "2020-05-04T08:40:18Z", "type": "commit"}, {"oid": "ad3a24692b8c4bc9fea5560cccd828cdbc7f0d90", "url": "https://github.com/SonarSource/sonar-java/commit/ad3a24692b8c4bc9fea5560cccd828cdbc7f0d90", "message": "Merge branch 'master' into SONARJAVA-3361-JUnitAssertTrueShouldBeSimplified", "committedDate": "2020-05-04T08:41:25Z", "type": "commit"}]}