{"pr_number": 3229, "pr_title": "SONARJAVA-3056 Avoid adding VM bootclasspath when possible", "pr_createdAt": "2020-10-01T12:11:20Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/3229", "timeline": [{"oid": "bbd339e15dfe1451516967f3ca3af65ac86fda81", "url": "https://github.com/SonarSource/sonar-java/commit/bbd339e15dfe1451516967f3ca3af65ac86fda81", "message": "SONARJAVA-3056 Do not prepend VM bootclasspath if already provided", "committedDate": "2020-10-01T11:47:16Z", "type": "commit"}, {"oid": "8b85695fd016c23784bc4b5b4a6df0fdbfb42f71", "url": "https://github.com/SonarSource/sonar-java/commit/8b85695fd016c23784bc4b5b4a6df0fdbfb42f71", "message": "SONARJAVA-3056 Add ITs", "committedDate": "2020-10-01T13:33:35Z", "type": "commit"}, {"oid": "8b85695fd016c23784bc4b5b4a6df0fdbfb42f71", "url": "https://github.com/SonarSource/sonar-java/commit/8b85695fd016c23784bc4b5b4a6df0fdbfb42f71", "message": "SONARJAVA-3056 Add ITs", "committedDate": "2020-10-01T13:33:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwNDcwMQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3229#discussion_r498304701", "bodyText": "While nothing is shown here, eclipse tells me that there extra spaces. Could you drop them?", "author": "m-g-sonar", "createdAt": "2020-10-01T14:49:39Z", "path": "java-frontend/src/main/java/org/sonar/java/model/JParser.java", "diffHunk": "@@ -266,12 +160,15 @@ public static CompilationUnitTree parse(\n     }\n \n     astParser.setCompilerOptions(options);\n+    ", "originalCommit": "8b85695fd016c23784bc4b5b4a6df0fdbfb42f71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwNTE5Nw==", "url": "https://github.com/SonarSource/sonar-java/pull/3229#discussion_r498305197", "bodyText": "This causes a code smell, can you mark it as \"won't fix\" if you don't plan to fix it?", "author": "m-g-sonar", "createdAt": "2020-10-01T14:50:20Z", "path": "java-frontend/src/main/java/org/sonar/java/model/JParser.java", "diffHunk": "@@ -20,118 +20,24 @@\n package org.sonar.java.model;\n \n import com.sonar.sslr.api.RecognitionException;\n+import java.io.File;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.annotation.Nullable;\n+import javax.annotation.ParametersAreNonnullByDefault;\n import org.eclipse.jdt.core.JavaCore;\n import org.eclipse.jdt.core.compiler.IProblem;\n import org.eclipse.jdt.core.compiler.InvalidInputException;\n-import org.eclipse.jdt.core.dom.AST;\n-import org.eclipse.jdt.core.dom.ASTNode;\n-import org.eclipse.jdt.core.dom.ASTParser;\n-import org.eclipse.jdt.core.dom.ASTUtils;\n-import org.eclipse.jdt.core.dom.AbstractTypeDeclaration;\n-import org.eclipse.jdt.core.dom.Annotation;\n-import org.eclipse.jdt.core.dom.AnnotationTypeMemberDeclaration;\n-import org.eclipse.jdt.core.dom.AnonymousClassDeclaration;\n-import org.eclipse.jdt.core.dom.ArrayAccess;\n-import org.eclipse.jdt.core.dom.ArrayCreation;\n-import org.eclipse.jdt.core.dom.ArrayInitializer;\n-import org.eclipse.jdt.core.dom.ArrayType;\n-import org.eclipse.jdt.core.dom.AssertStatement;\n-import org.eclipse.jdt.core.dom.Assignment;\n-import org.eclipse.jdt.core.dom.Block;\n-import org.eclipse.jdt.core.dom.BodyDeclaration;\n-import org.eclipse.jdt.core.dom.BooleanLiteral;\n-import org.eclipse.jdt.core.dom.BreakStatement;\n-import org.eclipse.jdt.core.dom.CastExpression;\n-import org.eclipse.jdt.core.dom.CatchClause;\n-import org.eclipse.jdt.core.dom.CharacterLiteral;\n-import org.eclipse.jdt.core.dom.ClassInstanceCreation;\n-import org.eclipse.jdt.core.dom.CompilationUnit;\n-import org.eclipse.jdt.core.dom.ConditionalExpression;\n-import org.eclipse.jdt.core.dom.ConstructorInvocation;\n-import org.eclipse.jdt.core.dom.ContinueStatement;\n-import org.eclipse.jdt.core.dom.CreationReference;\n-import org.eclipse.jdt.core.dom.Dimension;\n-import org.eclipse.jdt.core.dom.DoStatement;\n-import org.eclipse.jdt.core.dom.EmptyStatement;\n-import org.eclipse.jdt.core.dom.EnhancedForStatement;\n-import org.eclipse.jdt.core.dom.EnumConstantDeclaration;\n-import org.eclipse.jdt.core.dom.EnumDeclaration;\n-import org.eclipse.jdt.core.dom.ExportsDirective;\n-import org.eclipse.jdt.core.dom.Expression;\n-import org.eclipse.jdt.core.dom.ExpressionMethodReference;\n-import org.eclipse.jdt.core.dom.ExpressionStatement;\n-import org.eclipse.jdt.core.dom.FieldAccess;\n-import org.eclipse.jdt.core.dom.FieldDeclaration;\n-import org.eclipse.jdt.core.dom.ForStatement;\n-import org.eclipse.jdt.core.dom.IBinding;\n-import org.eclipse.jdt.core.dom.IExtendedModifier;\n-import org.eclipse.jdt.core.dom.IMethodBinding;\n-import org.eclipse.jdt.core.dom.ITypeBinding;\n-import org.eclipse.jdt.core.dom.IVariableBinding;\n-import org.eclipse.jdt.core.dom.IfStatement;\n-import org.eclipse.jdt.core.dom.ImportDeclaration;\n-import org.eclipse.jdt.core.dom.InfixExpression;\n-import org.eclipse.jdt.core.dom.Initializer;\n-import org.eclipse.jdt.core.dom.InstanceofExpression;\n-import org.eclipse.jdt.core.dom.IntersectionType;\n-import org.eclipse.jdt.core.dom.LabeledStatement;\n-import org.eclipse.jdt.core.dom.LambdaExpression;\n-import org.eclipse.jdt.core.dom.MemberValuePair;\n-import org.eclipse.jdt.core.dom.MethodDeclaration;\n-import org.eclipse.jdt.core.dom.MethodInvocation;\n-import org.eclipse.jdt.core.dom.ModuleDeclaration;\n-import org.eclipse.jdt.core.dom.ModuleDirective;\n-import org.eclipse.jdt.core.dom.ModuleModifier;\n-import org.eclipse.jdt.core.dom.Name;\n-import org.eclipse.jdt.core.dom.NameQualifiedType;\n-import org.eclipse.jdt.core.dom.NormalAnnotation;\n-import org.eclipse.jdt.core.dom.NullLiteral;\n-import org.eclipse.jdt.core.dom.NumberLiteral;\n-import org.eclipse.jdt.core.dom.OpensDirective;\n-import org.eclipse.jdt.core.dom.ParameterizedType;\n-import org.eclipse.jdt.core.dom.ParenthesizedExpression;\n-import org.eclipse.jdt.core.dom.PostfixExpression;\n-import org.eclipse.jdt.core.dom.PrefixExpression;\n-import org.eclipse.jdt.core.dom.PrimitiveType;\n-import org.eclipse.jdt.core.dom.ProvidesDirective;\n-import org.eclipse.jdt.core.dom.QualifiedName;\n-import org.eclipse.jdt.core.dom.QualifiedType;\n-import org.eclipse.jdt.core.dom.RecordDeclaration;\n-import org.eclipse.jdt.core.dom.RequiresDirective;\n-import org.eclipse.jdt.core.dom.ReturnStatement;\n-import org.eclipse.jdt.core.dom.SimpleName;\n-import org.eclipse.jdt.core.dom.SimpleType;\n-import org.eclipse.jdt.core.dom.SingleMemberAnnotation;\n-import org.eclipse.jdt.core.dom.SingleVariableDeclaration;\n-import org.eclipse.jdt.core.dom.Statement;\n-import org.eclipse.jdt.core.dom.StringLiteral;\n-import org.eclipse.jdt.core.dom.SuperConstructorInvocation;\n-import org.eclipse.jdt.core.dom.SuperFieldAccess;\n-import org.eclipse.jdt.core.dom.SuperMethodInvocation;\n-import org.eclipse.jdt.core.dom.SuperMethodReference;\n-import org.eclipse.jdt.core.dom.SwitchCase;\n-import org.eclipse.jdt.core.dom.SwitchExpression;\n-import org.eclipse.jdt.core.dom.SwitchStatement;\n-import org.eclipse.jdt.core.dom.SynchronizedStatement;\n-import org.eclipse.jdt.core.dom.TextBlock;\n-import org.eclipse.jdt.core.dom.ThisExpression;\n-import org.eclipse.jdt.core.dom.ThrowStatement;\n-import org.eclipse.jdt.core.dom.TryStatement;\n-import org.eclipse.jdt.core.dom.Type;\n-import org.eclipse.jdt.core.dom.TypeDeclaration;\n-import org.eclipse.jdt.core.dom.TypeDeclarationStatement;\n-import org.eclipse.jdt.core.dom.TypeLiteral;\n-import org.eclipse.jdt.core.dom.TypeMethodReference;\n-import org.eclipse.jdt.core.dom.TypeParameter;\n-import org.eclipse.jdt.core.dom.UnionType;\n-import org.eclipse.jdt.core.dom.UsesDirective;\n-import org.eclipse.jdt.core.dom.VariableDeclaration;\n-import org.eclipse.jdt.core.dom.VariableDeclarationExpression;\n-import org.eclipse.jdt.core.dom.VariableDeclarationFragment;\n-import org.eclipse.jdt.core.dom.VariableDeclarationStatement;\n-import org.eclipse.jdt.core.dom.WhileStatement;\n-import org.eclipse.jdt.core.dom.WildcardType;\n-import org.eclipse.jdt.core.dom.YieldStatement;\n+import org.eclipse.jdt.core.dom.*;", "originalCommit": "8b85695fd016c23784bc4b5b4a6df0fdbfb42f71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwNTY5MA==", "url": "https://github.com/SonarSource/sonar-java/pull/3229#discussion_r498305690", "bodyText": "I feel this set should be a constant", "author": "m-g-sonar", "createdAt": "2020-10-01T14:51:00Z", "path": "java-frontend/src/main/java/org/sonar/java/model/JParser.java", "diffHunk": "@@ -266,12 +160,15 @@ public static CompilationUnitTree parse(\n     }\n \n     astParser.setCompilerOptions(options);\n+    \n+    Set<String> jdkJarsNames = new HashSet<>(Arrays.asList(\"rt.jar\", \"jrt-fs.jar\", \"android.jar\"));", "originalCommit": "8b85695fd016c23784bc4b5b4a6df0fdbfb42f71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwODAxOA==", "url": "https://github.com/SonarSource/sonar-java/pull/3229#discussion_r498308018", "bodyText": "s1 can be inlined here", "author": "m-g-sonar", "createdAt": "2020-10-01T14:53:55Z", "path": "java-frontend/src/test/java/org/sonar/java/model/JParserTest.java", "diffHunk": "@@ -134,6 +140,45 @@ void statement_variable_declaration() {\n     assertSame(s1.type(), s2.type());\n   }\n \n+  @Test\n+  void doesnt_include_running_VM_Bootclasspath_if_jvm_sdk_already_provided_in_classpath(@TempDir Path tempFolder) throws IOException {\n+    VariableTree s1 = parseAndGetVariable(\"class C { void m() { String a; } }\");\n+    assertThat(s1.type().symbolType().fullyQualifiedName()).isEqualTo(\"java.lang.String\");\n+\n+    Path fakeRt = tempFolder.resolve(\"rt.jar\");\n+    Files.createFile(fakeRt);\n+    s1 = parseAndGetVariable(\"class C { void m() { String a; } }\", fakeRt.toFile());\n+    assertThat(s1.type().symbolType().fullyQualifiedName()).isEqualTo(\"Recovered#typeBindingLString;0\");\n+\n+    Path fakeAndroidSdk = tempFolder.resolve(\"android.jar\");\n+    Files.createFile(fakeAndroidSdk);\n+    s1 = parseAndGetVariable(\"class C { void m() { String a; } }\", fakeAndroidSdk.toFile());\n+    assertThat(s1.type().symbolType().fullyQualifiedName()).isEqualTo(\"Recovered#typeBindingLString;0\");\n+\n+    Path fakeJrtFs = tempFolder.resolve(\"lib/jrt-fs.jar\");\n+    Files.createDirectories(fakeJrtFs.getParent());\n+    Files.createFile(fakeJrtFs);\n+    String javaVersion = System.getProperty(\"java.version\");\n+    if (javaVersion != null && javaVersion.startsWith(\"1.8\")) {\n+      File fakeJrtFsFile = fakeJrtFs.toFile();\n+      RecognitionException expected = assertThrows(RecognitionException.class, () -> parseAndGetVariable(\"class C { void m() { String a; } }\", fakeJrtFsFile));\n+      assertThat(expected).hasCauseExactlyInstanceOf(ProviderNotFoundException.class).hasRootCauseMessage(\"Provider \\\"jrt\\\" not found\");\n+    } else {\n+      // Seems that it will still fallback on the parent classloader so there will be no error\n+    }\n+\n+  }\n+\n+  private VariableTree parseAndGetVariable(String code, File... classpath) {\n+    CompilationUnitTree t = JParserTestUtils.parse(\"Foo.java\", code, Arrays.asList(classpath));\n+    ClassTree c = (ClassTree) t.types().get(0);\n+    MethodTree m = (MethodTree) c.members().get(0);\n+    BlockTree s = m.block();\n+    assertNotNull(s);\n+    VariableTree s1 = (VariableTree) s.body().get(0);\n+    return s1;", "originalCommit": "8b85695fd016c23784bc4b5b4a6df0fdbfb42f71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMwODg3Mg==", "url": "https://github.com/SonarSource/sonar-java/pull/3229#discussion_r498308872", "bodyText": "I feel that these are 3 distinct tests. I would test them with a @nested test class", "author": "m-g-sonar", "createdAt": "2020-10-01T14:55:02Z", "path": "java-frontend/src/test/java/org/sonar/java/model/JParserTest.java", "diffHunk": "@@ -134,6 +140,45 @@ void statement_variable_declaration() {\n     assertSame(s1.type(), s2.type());\n   }\n \n+  @Test\n+  void doesnt_include_running_VM_Bootclasspath_if_jvm_sdk_already_provided_in_classpath(@TempDir Path tempFolder) throws IOException {", "originalCommit": "8b85695fd016c23784bc4b5b4a6df0fdbfb42f71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxMDI5NQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3229#discussion_r498310295", "bodyText": "shouldn't we test something there anyway then?", "author": "m-g-sonar", "createdAt": "2020-10-01T14:56:49Z", "path": "java-frontend/src/test/java/org/sonar/java/model/JParserTest.java", "diffHunk": "@@ -134,6 +140,45 @@ void statement_variable_declaration() {\n     assertSame(s1.type(), s2.type());\n   }\n \n+  @Test\n+  void doesnt_include_running_VM_Bootclasspath_if_jvm_sdk_already_provided_in_classpath(@TempDir Path tempFolder) throws IOException {\n+    VariableTree s1 = parseAndGetVariable(\"class C { void m() { String a; } }\");\n+    assertThat(s1.type().symbolType().fullyQualifiedName()).isEqualTo(\"java.lang.String\");\n+\n+    Path fakeRt = tempFolder.resolve(\"rt.jar\");\n+    Files.createFile(fakeRt);\n+    s1 = parseAndGetVariable(\"class C { void m() { String a; } }\", fakeRt.toFile());\n+    assertThat(s1.type().symbolType().fullyQualifiedName()).isEqualTo(\"Recovered#typeBindingLString;0\");\n+\n+    Path fakeAndroidSdk = tempFolder.resolve(\"android.jar\");\n+    Files.createFile(fakeAndroidSdk);\n+    s1 = parseAndGetVariable(\"class C { void m() { String a; } }\", fakeAndroidSdk.toFile());\n+    assertThat(s1.type().symbolType().fullyQualifiedName()).isEqualTo(\"Recovered#typeBindingLString;0\");\n+\n+    Path fakeJrtFs = tempFolder.resolve(\"lib/jrt-fs.jar\");\n+    Files.createDirectories(fakeJrtFs.getParent());\n+    Files.createFile(fakeJrtFs);\n+    String javaVersion = System.getProperty(\"java.version\");\n+    if (javaVersion != null && javaVersion.startsWith(\"1.8\")) {\n+      File fakeJrtFsFile = fakeJrtFs.toFile();\n+      RecognitionException expected = assertThrows(RecognitionException.class, () -> parseAndGetVariable(\"class C { void m() { String a; } }\", fakeJrtFsFile));\n+      assertThat(expected).hasCauseExactlyInstanceOf(ProviderNotFoundException.class).hasRootCauseMessage(\"Provider \\\"jrt\\\" not found\");\n+    } else {\n+      // Seems that it will still fallback on the parent classloader so there will be no error", "originalCommit": "8b85695fd016c23784bc4b5b4a6df0fdbfb42f71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxMTYxNg==", "url": "https://github.com/SonarSource/sonar-java/pull/3229#discussion_r498311616", "bodyText": "as far as I can tell, you are using it only with a single file each time, so let's make the test explicit:\nprivate VariableTree parseAndGetVariable(String code, File jvmSdk) {\n  CompilationUnitTree t = JParserTestUtils.parse(\"Foo.java\", code, Collections.singletonList(jvmSdk));\n  // ...\n}", "author": "m-g-sonar", "createdAt": "2020-10-01T14:58:34Z", "path": "java-frontend/src/test/java/org/sonar/java/model/JParserTest.java", "diffHunk": "@@ -134,6 +140,45 @@ void statement_variable_declaration() {\n     assertSame(s1.type(), s2.type());\n   }\n \n+  @Test\n+  void doesnt_include_running_VM_Bootclasspath_if_jvm_sdk_already_provided_in_classpath(@TempDir Path tempFolder) throws IOException {\n+    VariableTree s1 = parseAndGetVariable(\"class C { void m() { String a; } }\");\n+    assertThat(s1.type().symbolType().fullyQualifiedName()).isEqualTo(\"java.lang.String\");\n+\n+    Path fakeRt = tempFolder.resolve(\"rt.jar\");\n+    Files.createFile(fakeRt);\n+    s1 = parseAndGetVariable(\"class C { void m() { String a; } }\", fakeRt.toFile());\n+    assertThat(s1.type().symbolType().fullyQualifiedName()).isEqualTo(\"Recovered#typeBindingLString;0\");\n+\n+    Path fakeAndroidSdk = tempFolder.resolve(\"android.jar\");\n+    Files.createFile(fakeAndroidSdk);\n+    s1 = parseAndGetVariable(\"class C { void m() { String a; } }\", fakeAndroidSdk.toFile());\n+    assertThat(s1.type().symbolType().fullyQualifiedName()).isEqualTo(\"Recovered#typeBindingLString;0\");\n+\n+    Path fakeJrtFs = tempFolder.resolve(\"lib/jrt-fs.jar\");\n+    Files.createDirectories(fakeJrtFs.getParent());\n+    Files.createFile(fakeJrtFs);\n+    String javaVersion = System.getProperty(\"java.version\");\n+    if (javaVersion != null && javaVersion.startsWith(\"1.8\")) {\n+      File fakeJrtFsFile = fakeJrtFs.toFile();\n+      RecognitionException expected = assertThrows(RecognitionException.class, () -> parseAndGetVariable(\"class C { void m() { String a; } }\", fakeJrtFsFile));\n+      assertThat(expected).hasCauseExactlyInstanceOf(ProviderNotFoundException.class).hasRootCauseMessage(\"Provider \\\"jrt\\\" not found\");\n+    } else {\n+      // Seems that it will still fallback on the parent classloader so there will be no error\n+    }\n+\n+  }\n+\n+  private VariableTree parseAndGetVariable(String code, File... classpath) {", "originalCommit": "8b85695fd016c23784bc4b5b4a6df0fdbfb42f71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODgzNTgzNQ==", "url": "https://github.com/SonarSource/sonar-java/pull/3229#discussion_r498835835", "bodyText": "This allows to provide no arguments as well", "author": "henryju", "createdAt": "2020-10-02T13:53:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxMTYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxMzY5OA==", "url": "https://github.com/SonarSource/sonar-java/pull/3229#discussion_r498313698", "bodyText": "unrequired change", "author": "m-g-sonar", "createdAt": "2020-10-01T15:01:17Z", "path": "its/plugin/tests/src/test/java/com/sonar/it/java/suite/JavaClasspathTest.java", "diffHunk": "@@ -157,7 +163,7 @@ public void should_support_the_old_binaries_and_libraries_properties() {\n \n     assertThat(buildResult.getLogs()).contains(\n       \"sonar.binaries and sonar.libraries are not supported since version 4.0 of the SonarSource Java Analyzer,\" +\n-      \" please use sonar.java.binaries and sonar.java.libraries instead\");\n+        \" please use sonar.java.binaries and sonar.java.libraries instead\");", "originalCommit": "8b85695fd016c23784bc4b5b4a6df0fdbfb42f71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODMxNTM5OA==", "url": "https://github.com/SonarSource/sonar-java/pull/3229#discussion_r498315398", "bodyText": "unrequired change", "author": "m-g-sonar", "createdAt": "2020-10-01T15:03:41Z", "path": "java-frontend/src/test/java/org/sonar/java/model/JParserTest.java", "diffHunk": "@@ -118,8 +125,7 @@ void declaration_enum() {\n     EnumConstantTree c = (EnumConstantTree) t.members().get(0);\n     assertSame(\n       c.simpleName(),\n-      c.initializer().identifier()\n-    );\n+      c.initializer().identifier());", "originalCommit": "8b85695fd016c23784bc4b5b4a6df0fdbfb42f71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "652b9548ee1d0e59036ae77c137fcea436688f9c", "url": "https://github.com/SonarSource/sonar-java/commit/652b9548ee1d0e59036ae77c137fcea436688f9c", "message": "fixup! SONARJAVA-3056 Do not prepend VM bootclasspath if already provided", "committedDate": "2020-10-02T14:03:45Z", "type": "commit"}, {"oid": "0d6133bb577e41f66eb1de560019499d21337e39", "url": "https://github.com/SonarSource/sonar-java/commit/0d6133bb577e41f66eb1de560019499d21337e39", "message": "Try to fix test on Windows", "committedDate": "2020-10-02T14:46:04Z", "type": "commit"}]}