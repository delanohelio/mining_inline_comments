{"pr_number": 2781, "pr_title": "SONARJAVA-3209 Rule S5542: Encryption algorithms should be used with secure mode and padding scheme", "pr_createdAt": "2020-02-03T12:55:52Z", "pr_url": "https://github.com/SonarSource/sonar-java/pull/2781", "timeline": [{"oid": "cbbde2ca4551f8c14fd211b4cd426d88527b08cd", "url": "https://github.com/SonarSource/sonar-java/commit/cbbde2ca4551f8c14fd211b4cd426d88527b08cd", "message": "SONARJAVA-3209 Rule S5542: Encryption algorithms should be used with secure mode and padding scheme", "committedDate": "2020-02-03T14:11:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIwNjQ1NA==", "url": "https://github.com/SonarSource/sonar-java/pull/2781#discussion_r374206454", "bodyText": "Why complicating stuff with variable assignment?\nJust drop all the Cipher cX = statements, they are useless and simply add some noise in test file.", "author": "m-g-sonar", "createdAt": "2020-02-03T16:33:11Z", "path": "java-checks/src/test/files/checks/security/EncryptionAlgorithmCheck.java", "diffHunk": "@@ -0,0 +1,67 @@\n+import javax.crypto.Cipher;\n+import java.security.NoSuchAlgorithmException;\n+import javax.crypto.NoSuchPaddingException;\n+import java.security.NoSuchProviderException;\n+\n+abstract class A {\n+\n+  public void foo(java.util.Properties props) {\n+    /*\n+    should complain:\n+    - everytime ECB mode is used whatever the encryption algorithm\n+       - By default without specifying operation mode ECB is chosen\n+    - when CBC mode is used with PKCS5Padding or PKCS7Padding\n+    - when RSA is used without OAEPWithSHA-1AndMGF1Padding or OAEPWITHSHA-256ANDMGF1PADDING padding scheme\n+    */\n+\n+    try\n+    {\n+      // First case\n+      Cipher c0 = Cipher.getInstance(\"AES\"); // Noncompliant [[sc=38;ec=43]] {{Use secure mode and padding scheme.}}", "originalCommit": "cbbde2ca4551f8c14fd211b4cd426d88527b08cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIwNzA4OQ==", "url": "https://github.com/SonarSource/sonar-java/pull/2781#discussion_r374207089", "bodyText": "usually, in java, brackets are on the same line as the keyword. Can you fix this?", "author": "m-g-sonar", "createdAt": "2020-02-03T16:34:09Z", "path": "java-checks/src/test/files/checks/security/EncryptionAlgorithmCheck.java", "diffHunk": "@@ -0,0 +1,67 @@\n+import javax.crypto.Cipher;\n+import java.security.NoSuchAlgorithmException;\n+import javax.crypto.NoSuchPaddingException;\n+import java.security.NoSuchProviderException;\n+\n+abstract class A {\n+\n+  public void foo(java.util.Properties props) {\n+    /*\n+    should complain:\n+    - everytime ECB mode is used whatever the encryption algorithm\n+       - By default without specifying operation mode ECB is chosen\n+    - when CBC mode is used with PKCS5Padding or PKCS7Padding\n+    - when RSA is used without OAEPWithSHA-1AndMGF1Padding or OAEPWITHSHA-256ANDMGF1PADDING padding scheme\n+    */\n+\n+    try", "originalCommit": "cbbde2ca4551f8c14fd211b4cd426d88527b08cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIwNzc5MQ==", "url": "https://github.com/SonarSource/sonar-java/pull/2781#discussion_r374207791", "bodyText": "Why not replacing by a single catch (Exception e) {}, or simply define foo as throwing Exception ? It would get rid of the try-catch block.", "author": "m-g-sonar", "createdAt": "2020-02-03T16:35:18Z", "path": "java-checks/src/test/files/checks/security/EncryptionAlgorithmCheck.java", "diffHunk": "@@ -0,0 +1,67 @@\n+import javax.crypto.Cipher;\n+import java.security.NoSuchAlgorithmException;\n+import javax.crypto.NoSuchPaddingException;\n+import java.security.NoSuchProviderException;\n+\n+abstract class A {\n+\n+  public void foo(java.util.Properties props) {\n+    /*\n+    should complain:\n+    - everytime ECB mode is used whatever the encryption algorithm\n+       - By default without specifying operation mode ECB is chosen\n+    - when CBC mode is used with PKCS5Padding or PKCS7Padding\n+    - when RSA is used without OAEPWithSHA-1AndMGF1Padding or OAEPWITHSHA-256ANDMGF1PADDING padding scheme\n+    */\n+\n+    try\n+    {\n+      // First case\n+      Cipher c0 = Cipher.getInstance(\"AES\"); // Noncompliant [[sc=38;ec=43]] {{Use secure mode and padding scheme.}}\n+\n+      Cipher c100 = Cipher.getInstance(\"AES/ECB/NoPadding\"); // Noncompliant\n+      Cipher c101 = Cipher.getInstance(\"AES\" + \"/ECB/NoPadding\"); // Noncompliant\n+      Cipher c102 = Cipher.getInstance(\"AES/ECB/NoPadding\", getProvider()); // Noncompliant\n+      Cipher c103 = Cipher.getInstance(\"AES/ECB/NoPadding\", \"someProvider\"); // Noncompliant\n+\n+      Cipher c3 = Cipher.getInstance(\"Blowfish/ECB/PKCS5Padding\"); // Noncompliant\n+      Cipher c4 = Cipher.getInstance(\"DES/ECB/PKCS5Padding\"); // Noncompliant\n+      Cipher c41 = Cipher.getInstance(\"RSA/ECB/OAEPWithSHA-1AndMGF1Padding\"); // Noncompliant\n+\n+      Cipher c5 = Cipher.getInstance(\"AES/GCM/NoPadding\"); // Compliant\n+\n+      // Second case\n+      Cipher c6 = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); // Noncompliant\n+      Cipher c7 = Cipher.getInstance(\"Blowfish/CBC/PKCS5Padding\"); // Noncompliant\n+      Cipher c8 = Cipher.getInstance(\"DES/CBC/PKCS5Padding\"); // Noncompliant\n+      Cipher c9 = Cipher.getInstance(\"AES/CBC/PKCS7Padding\"); // Noncompliant\n+      Cipher c10 = Cipher.getInstance(\"Blowfish/CBC/PKCS7Padding\"); // Noncompliant\n+      Cipher c11 = Cipher.getInstance(\"DES/CBC/PKCS7Padding\"); // Noncompliant\n+\n+      Cipher c112 = Cipher.getInstance(\"DES/CBC/NoPadding\"); // Compliant\n+      Cipher c12 = Cipher.getInstance(\"AES/GCM/NoPadding\"); // Compliant\n+      Cipher c13 = Cipher.getInstance(\"Blowfish/GCM/NoPadding\"); // Compliant\n+\n+      // Third case\n+      Cipher c14 = Cipher.getInstance(\"RSA/NONE/NoPadding\"); // Noncompliant\n+      Cipher c142 = Cipher.getInstance(\"RSA/GCM/NoPadding\"); // Noncompliant\n+\n+      Cipher c15 = Cipher.getInstance(\"RSA/NONE/OAEPWithSHA-1AndMGF1Padding\"); // Compliant\n+      Cipher c16 = Cipher.getInstance(\"RSA/NONE/OAEPWITHSHA-256ANDMGF1PADDING\"); // Compliant\n+\n+      // Other\n+      Cipher.getInstance(null);\n+      Cipher.getInstance(\"\"); // Noncompliant\n+      String algo = props.getProperty(\"myAlgo\", \"AES/ECB/PKCS5Padding\");\n+      Cipher c17 = Cipher.getInstance(algo); // Noncompliant\n+      String s = \"RSA/NONE/NoPadding\";\n+    }\n+    catch(NoSuchAlgorithmException|NoSuchPaddingException e)", "originalCommit": "cbbde2ca4551f8c14fd211b4cd426d88527b08cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIwODM1NA==", "url": "https://github.com/SonarSource/sonar-java/pull/2781#discussion_r374208354", "bodyText": "You can directly use the string is you are using TypeCriteria.is()", "author": "m-g-sonar", "createdAt": "2020-02-03T16:36:16Z", "path": "java-checks/src/main/java/org/sonar/java/checks/security/EncryptionAlgorithmCheck.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.security;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.java.checks.helpers.ExpressionsHelper;\n+import org.sonar.java.checks.helpers.JavaPropertiesHelper;\n+import org.sonar.java.checks.methods.AbstractMethodDetection;\n+import org.sonar.java.matcher.MethodMatcher;\n+import org.sonar.java.matcher.TypeCriteria;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+\n+@Rule(key = \"S5542\")\n+public class EncryptionAlgorithmCheck extends AbstractMethodDetection {\n+\n+  private static final Pattern ALGORITHM_PATTERN = Pattern.compile(\"(.+)/(.+)/(.+)\");\n+\n+  @Override\n+  protected List<MethodMatcher> getMethodInvocationMatchers() {\n+    return Collections.singletonList(\n+      MethodMatcher.create()\n+        .typeDefinition(TypeCriteria.is(\"javax.crypto.Cipher\"))", "originalCommit": "cbbde2ca4551f8c14fd211b4cd426d88527b08cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIxMzAzMA==", "url": "https://github.com/SonarSource/sonar-java/pull/2781#discussion_r374213030", "bodyText": "I'm not quite sure about usage of find() here. If we are searching for the entire string, I would recommend using matches() instead. I don't see any test case which would justify using finding for subsequences rather than on everything.", "author": "m-g-sonar", "createdAt": "2020-02-03T16:44:11Z", "path": "java-checks/src/main/java/org/sonar/java/checks/security/EncryptionAlgorithmCheck.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.security;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.java.checks.helpers.ExpressionsHelper;\n+import org.sonar.java.checks.helpers.JavaPropertiesHelper;\n+import org.sonar.java.checks.methods.AbstractMethodDetection;\n+import org.sonar.java.matcher.MethodMatcher;\n+import org.sonar.java.matcher.TypeCriteria;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+\n+@Rule(key = \"S5542\")\n+public class EncryptionAlgorithmCheck extends AbstractMethodDetection {\n+\n+  private static final Pattern ALGORITHM_PATTERN = Pattern.compile(\"(.+)/(.+)/(.+)\");\n+\n+  @Override\n+  protected List<MethodMatcher> getMethodInvocationMatchers() {\n+    return Collections.singletonList(\n+      MethodMatcher.create()\n+        .typeDefinition(TypeCriteria.is(\"javax.crypto.Cipher\"))\n+        .name(\"getInstance\")\n+        .withAnyParameters());\n+  }\n+\n+  @Override\n+  protected void onMethodInvocationFound(MethodInvocationTree mit) {\n+    if (mit.arguments().isEmpty()) {\n+      return;\n+    }\n+    ExpressionTree firstArgument = mit.arguments().get(0);\n+    ExpressionTree defaultPropertyValue = JavaPropertiesHelper.retrievedPropertyDefaultValue(firstArgument);\n+    ExpressionTree algorithmTree = defaultPropertyValue == null ? firstArgument : defaultPropertyValue;\n+    String algorithmName = ExpressionsHelper.getConstantValueAsString(algorithmTree).value();\n+    if (algorithmName != null && isInsecureAlgorithm(algorithmName)) {\n+      reportIssue(firstArgument, \"Use secure mode and padding scheme.\");\n+    }\n+  }\n+\n+  private static boolean isInsecureAlgorithm(String algorithmName) {\n+    Matcher matcher = ALGORITHM_PATTERN.matcher(algorithmName);\n+    if (matcher.find()) {", "originalCommit": "cbbde2ca4551f8c14fd211b4cd426d88527b08cd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDUyMzMzMg==", "url": "https://github.com/SonarSource/sonar-java/pull/2781#discussion_r374523332", "bodyText": "Good point", "author": "quentin-jaquier-sonarsource", "createdAt": "2020-02-04T08:09:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIxMzAzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDIxNDgyNA==", "url": "https://github.com/SonarSource/sonar-java/pull/2781#discussion_r374214824", "bodyText": "for all these string comparison, please invert the string constant with the variable. See rule S1132.", "author": "m-g-sonar", "createdAt": "2020-02-03T16:47:29Z", "path": "java-checks/src/main/java/org/sonar/java/checks/security/EncryptionAlgorithmCheck.java", "diffHunk": "@@ -0,0 +1,84 @@\n+/*\n+ * SonarQube Java\n+ * Copyright (C) 2012-2020 SonarSource SA\n+ * mailto:info AT sonarsource DOT com\n+ *\n+ * This program is free software; you can redistribute it and/or\n+ * modify it under the terms of the GNU Lesser General Public\n+ * License as published by the Free Software Foundation; either\n+ * version 3 of the License, or (at your option) any later version.\n+ *\n+ * This program is distributed in the hope that it will be useful,\n+ * but WITHOUT ANY WARRANTY; without even the implied warranty of\n+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+ * Lesser General Public License for more details.\n+ *\n+ * You should have received a copy of the GNU Lesser General Public License\n+ * along with this program; if not, write to the Free Software Foundation,\n+ * Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.\n+ */\n+package org.sonar.java.checks.security;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import org.sonar.check.Rule;\n+import org.sonar.java.checks.helpers.ExpressionsHelper;\n+import org.sonar.java.checks.helpers.JavaPropertiesHelper;\n+import org.sonar.java.checks.methods.AbstractMethodDetection;\n+import org.sonar.java.matcher.MethodMatcher;\n+import org.sonar.java.matcher.TypeCriteria;\n+import org.sonar.plugins.java.api.tree.ExpressionTree;\n+import org.sonar.plugins.java.api.tree.MethodInvocationTree;\n+\n+@Rule(key = \"S5542\")\n+public class EncryptionAlgorithmCheck extends AbstractMethodDetection {\n+\n+  private static final Pattern ALGORITHM_PATTERN = Pattern.compile(\"(.+)/(.+)/(.+)\");\n+\n+  @Override\n+  protected List<MethodMatcher> getMethodInvocationMatchers() {\n+    return Collections.singletonList(\n+      MethodMatcher.create()\n+        .typeDefinition(TypeCriteria.is(\"javax.crypto.Cipher\"))\n+        .name(\"getInstance\")\n+        .withAnyParameters());\n+  }\n+\n+  @Override\n+  protected void onMethodInvocationFound(MethodInvocationTree mit) {\n+    if (mit.arguments().isEmpty()) {\n+      return;\n+    }\n+    ExpressionTree firstArgument = mit.arguments().get(0);\n+    ExpressionTree defaultPropertyValue = JavaPropertiesHelper.retrievedPropertyDefaultValue(firstArgument);\n+    ExpressionTree algorithmTree = defaultPropertyValue == null ? firstArgument : defaultPropertyValue;\n+    String algorithmName = ExpressionsHelper.getConstantValueAsString(algorithmTree).value();\n+    if (algorithmName != null && isInsecureAlgorithm(algorithmName)) {\n+      reportIssue(firstArgument, \"Use secure mode and padding scheme.\");\n+    }\n+  }\n+\n+  private static boolean isInsecureAlgorithm(String algorithmName) {\n+    Matcher matcher = ALGORITHM_PATTERN.matcher(algorithmName);\n+    if (matcher.find()) {\n+      String algorithm = matcher.group(1);\n+      String mode = matcher.group(2);\n+      String padding = matcher.group(3);\n+\n+      if (mode.equals(\"ECB\")) {", "originalCommit": "cbbde2ca4551f8c14fd211b4cd426d88527b08cd", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "62c11e2b341145384e1ec85f0dc79578b475c8a0", "url": "https://github.com/SonarSource/sonar-java/commit/62c11e2b341145384e1ec85f0dc79578b475c8a0", "message": "SONARJAVA-3209 Rule S5542: Encryption algorithms should be used with secure mode and padding scheme", "committedDate": "2020-02-04T08:17:41Z", "type": "commit"}, {"oid": "38d9a06c021bef2adadd95d5496be026caa2d7a6", "url": "https://github.com/SonarSource/sonar-java/commit/38d9a06c021bef2adadd95d5496be026caa2d7a6", "message": "Fix from review", "committedDate": "2020-02-04T08:17:41Z", "type": "commit"}, {"oid": "38d9a06c021bef2adadd95d5496be026caa2d7a6", "url": "https://github.com/SonarSource/sonar-java/commit/38d9a06c021bef2adadd95d5496be026caa2d7a6", "message": "Fix from review", "committedDate": "2020-02-04T08:17:41Z", "type": "forcePushed"}]}