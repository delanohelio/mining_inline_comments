{"pr_number": 10653, "pr_title": "JDK15 Load native libraries via jdk.internal.loader.NativeLibraries", "pr_createdAt": "2020-09-21T12:48:18Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10653", "timeline": [{"oid": "70eec2849fd2712c9068e29d9ddd687be6b81791", "url": "https://github.com/eclipse-openj9/openj9/commit/70eec2849fd2712c9068e29d9ddd687be6b81791", "message": "JDK15 Load native libraries via jdk.internal.loader.NativeLibraries\n\n* JDK15 bindNative() first search the nativeLibrary associated with the\nclassloader (like pre-jdk15 levels) for systemClassLoader; if that\ndidn't succeed or the classloader is not systemClassLoader,\nlookupNativeAddress() is invoked with a NULL nativeLibrary;\n* When the incoming nativeLibrary is NULL, lookupNativeAddress() call\ninto java.lang.ClassLoader.findNative() to get native method\nfunctionAddress;\n* After a successful binding, classLoaderRegisterLibrary() skips\nJNI_Onload() which is going to be invoked by NativeLibraries.load()\ninstead;\n* JVM_LoadLibrary() \tinvokes registerBootstrapLibrary() for early\nbootstrap, and j9sl_open_shared_library for later class loading;\n* Change System.load/loadLibrary to ClassLoader.loadLibrary(caller,\nfileName);\n* Added JVM_UnloadLibrary() implementation;\n\n\nSigned-off-by: Jason Feng <fengj@ca.ibm.com>", "committedDate": "2020-09-22T02:00:47Z", "type": "forcePushed"}, {"oid": "f450c671572065ea7d11129d11660599fa48ac1e", "url": "https://github.com/eclipse-openj9/openj9/commit/f450c671572065ea7d11129d11660599fa48ac1e", "message": "JDK15 Load native libraries via jdk.internal.loader.NativeLibraries\n\n* JDK15 bindNative() first search the nativeLibrary associated with the\nclassloader (like pre-jdk15 levels) for systemClassLoader; if that\ndidn't succeed or the classloader is not systemClassLoader,\nlookupNativeAddress() is invoked with a NULL nativeLibrary;\n* When the incoming nativeLibrary is NULL, lookupNativeAddress() call\ninto java.lang.ClassLoader.findNative() to get native method\nfunctionAddress;\n* After a successful binding, classLoaderRegisterLibrary() skips\nJNI_Onload() which is going to be invoked by NativeLibraries.load()\ninstead;\n* JVM_LoadLibrary() \tinvokes registerBootstrapLibrary() for early\nbootstrap, and j9sl_open_shared_library for later class loading;\n* Change System.load/loadLibrary to ClassLoader.loadLibrary(caller,\nfileName);\n* Added JVM_UnloadLibrary() implementation;\n\n\nSigned-off-by: Jason Feng <fengj@ca.ibm.com>", "committedDate": "2020-09-22T02:08:24Z", "type": "forcePushed"}, {"oid": "5c003fd382964bd0e977b4d085c2ae4b3d61d9fa", "url": "https://github.com/eclipse-openj9/openj9/commit/5c003fd382964bd0e977b4d085c2ae4b3d61d9fa", "message": "JDK15 Load native libraries via jdk.internal.loader.NativeLibraries\n\n* JDK15 bindNative() first search the nativeLibrary associated with the\nclassloader (like pre-jdk15 levels) for systemClassLoader; if that\ndidn't succeed or the classloader is not systemClassLoader,\nlookupNativeAddress() is invoked with a NULL nativeLibrary;\n* When the incoming nativeLibrary is NULL, lookupNativeAddress() call\ninto java.lang.ClassLoader.findNative() to get native method\nfunctionAddress;\n* After a successful binding, classLoaderRegisterLibrary() skips\nJNI_Onload() which is going to be invoked by NativeLibraries.load()\ninstead;\n* JVM_LoadLibrary() \tinvokes registerBootstrapLibrary() for early\nbootstrap, and j9sl_open_shared_library for later class loading;\n* Change System.load/loadLibrary to ClassLoader.loadLibrary(caller,\nfileName);\n* Added JVM_UnloadLibrary() implementation;\n\n\nSigned-off-by: Jason Feng <fengj@ca.ibm.com>", "committedDate": "2020-09-22T12:25:24Z", "type": "forcePushed"}, {"oid": "e6ea56ea642e5e1604f45d7949d1ce976bc34409", "url": "https://github.com/eclipse-openj9/openj9/commit/e6ea56ea642e5e1604f45d7949d1ce976bc34409", "message": "JDK15 Load native libraries via jdk.internal.loader.NativeLibraries\n\n* JDK15 bindNative() first search the nativeLibrary associated with the\nclassloader (like pre-jdk15 levels) for systemClassLoader; if that\ndidn't succeed or the classloader is not systemClassLoader,\nlookupNativeAddress() is invoked with a NULL nativeLibrary;\n* When the incoming nativeLibrary is NULL, lookupNativeAddress() call\ninto java.lang.ClassLoader.findNative() to get native method\nfunctionAddress;\n* After a successful binding, classLoaderRegisterLibrary() skips\nJNI_Onload() which is going to be invoked by NativeLibraries.load()\ninstead;\n* JVM_LoadLibrary() \tinvokes registerBootstrapLibrary() for early\nbootstrap, and j9sl_open_shared_library for later class loading;\n* Change System.load/loadLibrary to ClassLoader.loadLibrary(caller,\nfileName);\n* Added JVM_UnloadLibrary() implementation;\n* Added a few tracepoints;\n\nSigned-off-by: Jason Feng <fengj@ca.ibm.com>", "committedDate": "2020-09-22T20:55:51Z", "type": "forcePushed"}, {"oid": "5d77e725e32b07db436088b13141320eeac9b60b", "url": "https://github.com/eclipse-openj9/openj9/commit/5d77e725e32b07db436088b13141320eeac9b60b", "message": "JDK15 Load native libraries via jdk.internal.loader.NativeLibraries\n\n* JDK15 bindNative() first search the nativeLibrary associated with the\nclassloader (like pre-jdk15 levels) for systemClassLoader; if that\ndidn't succeed or the classloader is not systemClassLoader,\nlookupNativeAddress() is invoked with a NULL nativeLibrary;\n* When the incoming nativeLibrary is NULL, lookupNativeAddress() call\ninto java.lang.ClassLoader.findNative() to get native method\nfunctionAddress;\n* After a successful binding, classLoaderRegisterLibrary() skips\nJNI_Onload() which is going to be invoked by NativeLibraries.load()\ninstead;\n* JVM_LoadLibrary() \tinvokes registerBootstrapLibrary() for early\nbootstrap, and j9sl_open_shared_library for later class loading;\n* Change System.load/loadLibrary to ClassLoader.loadLibrary(caller,\nfileName);\n* Added JVM_UnloadLibrary() implementation;\n* Added a few tracepoints;\n\nSigned-off-by: Jason Feng <fengj@ca.ibm.com>", "committedDate": "2020-09-23T15:01:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc3MTEwMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10653#discussion_r493771102", "bodyText": "Why not NLS?", "author": "gacholio", "createdAt": "2020-09-23T17:37:03Z", "path": "jcl/src/java.base/share/classes/java/lang/ClassLoader.java", "diffHunk": "@@ -1982,10 +1999,49 @@ static void loadLibrary(Class<?> caller, String name, boolean fullPath) {\n \n /*[IF Java15]*/\n static void loadLibrary(Class<?> caller, File file) {\n-\tloadLibraryWithPath(file.getAbsolutePath(), caller.getClassLoaderImpl(), null);\n+\tClassLoader loader = (caller == null) ? null : caller.getClassLoader();\n+\tNativeLibraries nls = (loader == null) ? bootstrapClassLoader.nativelibs : loader.nativelibs;\n+\tNativeLibrary nl = nls.loadLibrary(caller, file);\n+\tif (nl == null) {\n+\t\tthrow new UnsatisfiedLinkError(\"Can't load \" + file); //$NON-NLS-1$", "originalCommit": "5d77e725e32b07db436088b13141320eeac9b60b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc5OTM4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10653#discussion_r493799382", "bodyText": "Was lured away by https://github.com/eclipse/openj9/blob/f49490ab44a652e72d6d8f96b38b6095ce0cc97d/jcl/src/java.base/share/classes/java/lang/ClassLoader.java#L1970\nFixed it as well.\nPlease have another look.", "author": "JasonFengJ9", "createdAt": "2020-09-23T18:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc3MTEwMg=="}], "type": "inlineReview"}, {"oid": "e6de2f9b86fcd73d0c2a77e6cff805ff61632928", "url": "https://github.com/eclipse-openj9/openj9/commit/e6de2f9b86fcd73d0c2a77e6cff805ff61632928", "message": "JDK15 Load native libraries via jdk.internal.loader.NativeLibraries\n\n* JDK15 bindNative() first search the nativeLibrary associated with the\nclassloader (like pre-jdk15 levels) for systemClassLoader; if that\ndidn't succeed or the classloader is not systemClassLoader,\nlookupNativeAddress() is invoked with a NULL nativeLibrary;\n* When the incoming nativeLibrary is NULL, lookupNativeAddress() call\ninto java.lang.ClassLoader.findNative() to get native method\nfunctionAddress;\n* After a successful binding, classLoaderRegisterLibrary() skips\nJNI_Onload() which is going to be invoked by NativeLibraries.load()\ninstead;\n* JVM_LoadLibrary() \tinvokes registerBootstrapLibrary() for early\nbootstrap, and j9sl_open_shared_library for later class loading;\n* Change System.load/loadLibrary to ClassLoader.loadLibrary(caller,\nfileName);\n* Added JVM_UnloadLibrary() implementation;\n* Added a few tracepoints;\n\nSigned-off-by: Jason Feng <fengj@ca.ibm.com>", "committedDate": "2020-09-23T18:21:15Z", "type": "commit"}, {"oid": "e6de2f9b86fcd73d0c2a77e6cff805ff61632928", "url": "https://github.com/eclipse-openj9/openj9/commit/e6de2f9b86fcd73d0c2a77e6cff805ff61632928", "message": "JDK15 Load native libraries via jdk.internal.loader.NativeLibraries\n\n* JDK15 bindNative() first search the nativeLibrary associated with the\nclassloader (like pre-jdk15 levels) for systemClassLoader; if that\ndidn't succeed or the classloader is not systemClassLoader,\nlookupNativeAddress() is invoked with a NULL nativeLibrary;\n* When the incoming nativeLibrary is NULL, lookupNativeAddress() call\ninto java.lang.ClassLoader.findNative() to get native method\nfunctionAddress;\n* After a successful binding, classLoaderRegisterLibrary() skips\nJNI_Onload() which is going to be invoked by NativeLibraries.load()\ninstead;\n* JVM_LoadLibrary() \tinvokes registerBootstrapLibrary() for early\nbootstrap, and j9sl_open_shared_library for later class loading;\n* Change System.load/loadLibrary to ClassLoader.loadLibrary(caller,\nfileName);\n* Added JVM_UnloadLibrary() implementation;\n* Added a few tracepoints;\n\nSigned-off-by: Jason Feng <fengj@ca.ibm.com>", "committedDate": "2020-09-23T18:21:15Z", "type": "forcePushed"}]}