{"pr_number": 8657, "pr_title": "Update the Lookup specific code against the JDK14 Spec", "pr_createdAt": "2020-02-25T19:25:04Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/8657", "timeline": [{"oid": "3b68d099961a5b27d3209e711c6ec595f46868b5", "url": "https://github.com/eclipse-openj9/openj9/commit/3b68d099961a5b27d3209e711c6ec595f46868b5", "message": "Update the Lookup specific code against the JDK14 Spec\n\nThe change is to update the code related to MH.Lookup\nto deal with the change of the full privilege access\nand the new concept called previous lookup class introduced\nin JDK14.\n\nFixes: #8571\n\nSigned-off-by: Cheng Jin <jincheng@ca.ibm.com>", "committedDate": "2020-02-25T19:41:19Z", "type": "forcePushed"}, {"oid": "276e2b4557b746f86a4ede7c23e0b543f5acaee7", "url": "https://github.com/eclipse-openj9/openj9/commit/276e2b4557b746f86a4ede7c23e0b543f5acaee7", "message": "Update the Lookup specific code against the JDK14 Spec\n\nThe change is to update the code related to MH.Lookup\nto deal with the change of the full privilege access\nand the new concept called previous lookup class introduced\nin JDK14.\n\nFixes: #8571\n\nSigned-off-by: Cheng Jin <jincheng@ca.ibm.com>", "committedDate": "2020-02-26T00:05:29Z", "type": "forcePushed"}, {"oid": "0a5357a283db7f2a2ad3ff949ff477b30f1697e9", "url": "https://github.com/eclipse-openj9/openj9/commit/0a5357a283db7f2a2ad3ff949ff477b30f1697e9", "message": "Update the Lookup specific code against the JDK14 Spec\n\nThe change is to update the code related to MH.Lookup\nto deal with the change of the full privilege access\nand the new concept called previous lookup class introduced\nin JDK14.\n\nFixes: #8571\n\nSigned-off-by: Cheng Jin <jincheng@ca.ibm.com>", "committedDate": "2020-02-26T05:31:28Z", "type": "forcePushed"}, {"oid": "0fe4d0e8689ef14fd65029c44ecf84272b0f9c5c", "url": "https://github.com/eclipse-openj9/openj9/commit/0fe4d0e8689ef14fd65029c44ecf84272b0f9c5c", "message": "Update the Lookup specific code against the JDK14 Spec\n\nThe change is to update the code related to MH.Lookup\nto deal with the change of the full privilege access\nand the new concept called previous lookup class introduced\nin JDK14.\n\nFixes: #8571\n\nSigned-off-by: Cheng Jin <jincheng@ca.ibm.com>", "committedDate": "2020-02-27T16:18:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI2Mjg2OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r384262868", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tif ( lookupClass.getName().startsWith(\"java.lang.invoke.\")) {  //$NON-NLS-1$\n          \n          \n            \n            \t\t\t\tif (lookupClass.getName().startsWith(\"java.lang.invoke.\")) {  //$NON-NLS-1$", "author": "DanHeidinga", "createdAt": "2020-02-26T03:55:53Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -180,10 +184,41 @@\n \t\tstatic Lookup IMPL_LOOKUP = internalPrivilegedLookup; /* hack for b56 of lambda-dev */\n \t\t\n \t\t/* Access token used in lookups - Object for public lookup */\n+\t\t/*[IF Java14]*/\n+\t\tfinal Class<?> prevAccessClass;\n+\t\t/*[ENDIF] Java14*/\n \t\tfinal Class<?> accessClass;\n \t\tfinal int accessMode;\n \t\tprivate final  boolean performSecurityCheck;\n \t\t\n+\t\t/*[IF Java14]*/\n+\t\tLookup(Class<?> lookupClass, Class<?> prevLookupClass, int lookupMode, boolean doCheck) {\n+\t\t\tthis.performSecurityCheck = doCheck;\n+\t\t\tif (doCheck && (INTERNAL_PRIVILEGED != lookupMode)) {\n+\t\t\t\tif ( lookupClass.getName().startsWith(\"java.lang.invoke.\")) {  //$NON-NLS-1$", "originalCommit": "276e2b4557b746f86a4ede7c23e0b543f5acaee7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ3Mzc3NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r385473774", "bodyText": "Fixed.", "author": "ChengJin01", "createdAt": "2020-02-28T02:07:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI2Mjg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI2NDg1Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r384264852", "bodyText": "@JasonFengJ9 Any thoughts on whether there's a cleaner way to do the jcl preprocessor tags here with less duplication?", "author": "DanHeidinga", "createdAt": "2020-02-26T04:06:19Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -170,7 +170,11 @@\n \t\t\n \t\t/* single cached value of public Lookup object */\n \t\t/*[IF Sidecar19-SE-OpenJ9]\n+\t\t/*[IF Java14]*/\n+\t\tstatic Lookup PUBLIC_LOOKUP = new Lookup(Object.class, Lookup.UNCONDITIONAL);\n+\t\t/*[ELSE]*/\n \t\tstatic Lookup PUBLIC_LOOKUP = new Lookup(Object.class, Lookup.PUBLIC | Lookup.UNCONDITIONAL);\n+\t\t/*[ENDIF] Java14 */\n \t\t/*[ELSE]*/\n \t\tstatic Lookup PUBLIC_LOOKUP = new Lookup(Object.class, Lookup.PUBLIC);", "originalCommit": "276e2b4557b746f86a4ede7c23e0b543f5acaee7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzEyMzU2Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r387123563", "bodyText": "Sincere apology for late response, somehow I didn't catch the git notification (and strangely it didn't show up with mention query in the past).\nI think JPP tags could be organized as following:\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tstatic Lookup PUBLIC_LOOKUP = new Lookup(Object.class, Lookup.PUBLIC);\n          \n          \n            \n            \t\tstatic final int mhMask = \n          \n          \n            \n            \t\t/*[IF Java11]\n          \n          \n            \n            \t\t/*[IF Java14]*/\n          \n          \n            \n            \t\tLookup.UNCONDITIONAL;\n          \n          \n            \n            \t\t/*[ELSE]*/\n          \n          \n            \n            \t\tLookup.PUBLIC | Lookup.UNCONDITIONAL;\n          \n          \n            \n            \t\t/*[ENDIF] Java14 */\n          \n          \n            \n            \t\t/*[ELSE] Java11 */\n          \n          \n            \n            \t\tLookup.PUBLIC;\n          \n          \n            \n            \t\t/*[ENDIF] Java11 */\n          \n          \n            \n            \t\tstatic Lookup PUBLIC_LOOKUP = new Lookup(Object.class, mhMask);\n          \n      \n    \n    \n  \n\nAlternatively static final int mhMask =  could be moved within the JPP decoration to avoid the actual code like\n\t\tstatic final int mhMask = \n\t\tLookup.PUBLIC;", "author": "JasonFengJ9", "createdAt": "2020-03-03T16:05:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI2NDg1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzE4MjE4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r387182188", "bodyText": "I will update the code against the suggestion above by @JasonFengJ9 if there is no other concern on the format.", "author": "ChengJin01", "createdAt": "2020-03-03T17:36:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI2NDg1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI0ODgyNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r387248825", "bodyText": "The code there has been updated as suggested above.", "author": "ChengJin01", "createdAt": "2020-03-03T19:38:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI2NDg1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI2NTE3Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r384265173", "bodyText": "Why doesn't this forward to the new ctor:\n\t\tLookup(Class<?> lookupClass, Class<?> prevLookupClass, int lookupMode, boolean doCheck) {\n?", "author": "DanHeidinga", "createdAt": "2020-02-26T04:08:01Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -180,10 +184,41 @@\n \t\tstatic Lookup IMPL_LOOKUP = internalPrivilegedLookup; /* hack for b56 of lambda-dev */\n \t\t\n \t\t/* Access token used in lookups - Object for public lookup */\n+\t\t/*[IF Java14]*/\n+\t\tfinal Class<?> prevAccessClass;\n+\t\t/*[ENDIF] Java14*/\n \t\tfinal Class<?> accessClass;\n \t\tfinal int accessMode;\n \t\tprivate final  boolean performSecurityCheck;\n \t\t\n+\t\t/*[IF Java14]*/\n+\t\tLookup(Class<?> lookupClass, Class<?> prevLookupClass, int lookupMode, boolean doCheck) {\n+\t\t\tthis.performSecurityCheck = doCheck;\n+\t\t\tif (doCheck && (INTERNAL_PRIVILEGED != lookupMode)) {\n+\t\t\t\tif ( lookupClass.getName().startsWith(\"java.lang.invoke.\")) {  //$NON-NLS-1$\n+\t\t\t\t\t/*[MSG \"K0588\", \"Illegal Lookup object - originated from java.lang.invoke: {0}\"]*/\n+\t\t\t\t\tthrow new IllegalArgumentException(com.ibm.oti.util.Msg.getString(\"K0588\", lookupClass.getName())); //$NON-NLS-1$\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\taccessClass = lookupClass;\n+\t\t\tprevAccessClass = prevLookupClass;\n+\t\t\taccessMode = lookupMode;\n+\t\t}\n+\t\t\n+\t\tLookup(Class<?> lookupClass, Class<?> prevLookupClass, int lookupMode) {\n+\t\t\tthis(lookupClass, prevLookupClass, lookupMode, true);\n+\t\t}\n+\t\t\n+\t\tLookup(Class<?> lookupClass, Class<?> prevLookupClass) {\n+\t\t\tthis(lookupClass, prevLookupClass, FULL_ACCESS_MASK, true);\n+\t\t}\n+\t\t\n+\t\tLookup(Class<?> lookupClass, Class<?> prevLookupClass, boolean performSecurityCheck) {\n+\t\t\t this(lookupClass, prevLookupClass, FULL_ACCESS_MASK, performSecurityCheck);\n+\t\t}\n+\t\t/*[ENDIF] Java14*/\n+\t\t\n \t\tLookup(Class<?> lookupClass, int lookupMode, boolean doCheck) {", "originalCommit": "276e2b4557b746f86a4ede7c23e0b543f5acaee7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ3NDEzMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r385474133", "bodyText": "Agreed and updated as follows:\n\t\tLookup(Class<?> lookupClass, int lookupMode, boolean doCheck) {\n\t\t\tthis(lookupClass, null, lookupMode, doCheck);\n\t\t}", "author": "ChengJin01", "createdAt": "2020-02-28T02:09:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI2NTE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI2NTQ1Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r384265452", "bodyText": "Are all the new forms of these ctors used?  Let's only add the ones we actually need", "author": "DanHeidinga", "createdAt": "2020-02-26T04:09:25Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -180,10 +184,41 @@\n \t\tstatic Lookup IMPL_LOOKUP = internalPrivilegedLookup; /* hack for b56 of lambda-dev */\n \t\t\n \t\t/* Access token used in lookups - Object for public lookup */\n+\t\t/*[IF Java14]*/\n+\t\tfinal Class<?> prevAccessClass;\n+\t\t/*[ENDIF] Java14*/\n \t\tfinal Class<?> accessClass;\n \t\tfinal int accessMode;\n \t\tprivate final  boolean performSecurityCheck;\n \t\t\n+\t\t/*[IF Java14]*/\n+\t\tLookup(Class<?> lookupClass, Class<?> prevLookupClass, int lookupMode, boolean doCheck) {\n+\t\t\tthis.performSecurityCheck = doCheck;\n+\t\t\tif (doCheck && (INTERNAL_PRIVILEGED != lookupMode)) {\n+\t\t\t\tif ( lookupClass.getName().startsWith(\"java.lang.invoke.\")) {  //$NON-NLS-1$\n+\t\t\t\t\t/*[MSG \"K0588\", \"Illegal Lookup object - originated from java.lang.invoke: {0}\"]*/\n+\t\t\t\t\tthrow new IllegalArgumentException(com.ibm.oti.util.Msg.getString(\"K0588\", lookupClass.getName())); //$NON-NLS-1$\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\taccessClass = lookupClass;\n+\t\t\tprevAccessClass = prevLookupClass;\n+\t\t\taccessMode = lookupMode;\n+\t\t}\n+\t\t\n+\t\tLookup(Class<?> lookupClass, Class<?> prevLookupClass, int lookupMode) {\n+\t\t\tthis(lookupClass, prevLookupClass, lookupMode, true);\n+\t\t}\n+\t\t\n+\t\tLookup(Class<?> lookupClass, Class<?> prevLookupClass) {\n+\t\t\tthis(lookupClass, prevLookupClass, FULL_ACCESS_MASK, true);\n+\t\t}\n+\t\t\n+\t\tLookup(Class<?> lookupClass, Class<?> prevLookupClass, boolean performSecurityCheck) {\n+\t\t\t this(lookupClass, prevLookupClass, FULL_ACCESS_MASK, performSecurityCheck);\n+\t\t}", "originalCommit": "276e2b4557b746f86a4ede7c23e0b543f5acaee7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ3NDI3NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r385474274", "bodyText": "Removed unused constructors as suggested above.", "author": "ChengJin01", "createdAt": "2020-02-28T02:09:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI2NTQ1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE4NzQ4Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r385187486", "bodyText": "Suggested change", "author": "DanHeidinga", "createdAt": "2020-02-27T15:30:49Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -558,7 +632,7 @@ private void checkClassAccess(Class<?> targetClass) throws IllegalAccessExceptio\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n-\n+\t\t\t", "originalCommit": "0a5357a283db7f2a2ad3ff949ff477b30f1697e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTQ3NTQ0NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r385475445", "bodyText": "Fixed.", "author": "ChengJin01", "createdAt": "2020-02-28T02:14:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTE4NzQ4Ng=="}], "type": "inlineReview"}, {"oid": "7c16326a5fd04126c45b251a1e701c95d7c6539a", "url": "https://github.com/eclipse-openj9/openj9/commit/7c16326a5fd04126c45b251a1e701c95d7c6539a", "message": "Update the Lookup specific code against the JDK14 Spec\n\nThe change is to update the code related to MH.Lookup\nto deal with the change of the full privilege access\nand the new concept called previous lookup class introduced\nin JDK14.\n\nFixes: #8571\n\nSigned-off-by: Cheng Jin <jincheng@ca.ibm.com>", "committedDate": "2020-02-28T02:07:06Z", "type": "forcePushed"}, {"oid": "b41926919e013e94d5342a580cd7df49ada6e69b", "url": "https://github.com/eclipse-openj9/openj9/commit/b41926919e013e94d5342a580cd7df49ada6e69b", "message": "Update the Lookup specific code against the JDK14 Spec\n\nThe change is to update the code related to MH.Lookup\nto deal with the change of the full privilege access\nand the new concept called previous lookup class introduced\nin JDK14.\n\nFixes: #8571\n\nSigned-off-by: Cheng Jin <jincheng@ca.ibm.com>", "committedDate": "2020-02-28T19:31:08Z", "type": "forcePushed"}, {"oid": "893f1f7dda2a247400c13511aefc4df92fba6253", "url": "https://github.com/eclipse-openj9/openj9/commit/893f1f7dda2a247400c13511aefc4df92fba6253", "message": "Update the Lookup specific code against the JDK14 Spec\n\nThe change is to update the code related to MH.Lookup\nto deal with the change of the full privilege access\nand the new concept called previous lookup class introduced\nin JDK14.\n\nFixes: #8571\n\nSigned-off-by: Cheng Jin <jincheng@ca.ibm.com>", "committedDate": "2020-02-28T20:36:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNTQzMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r386635432", "bodyText": "Use Objects.requireNonNull(lookupClass) here rather than the explicit method call for a null check", "author": "DanHeidinga", "createdAt": "2020-03-02T20:36:00Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -1100,29 +1220,55 @@ public MethodHandle findStaticSetter(Class<?> clazz, String fieldName, Class<?>\n \t\t\treturn handle;\n \t\t}\n \t\t\n+\t\t/*[IF Java14]*/\n \t\t/**\n \t\t * Create a lookup on the request class.  The resulting lookup will have no more \n \t\t * access privileges than the original.\n \t\t * \n \t\t * @param lookupClass - the class to create the lookup on\n \t\t * @return a new MethodHandles.Lookup object\n+\t\t * @throws NullPointerException - if lookupClass is null\n+\t\t * @throws IllegalArgumentException - if the requested Class is a primitive type or an array class\n \t\t */\n-\t\tpublic MethodHandles.Lookup in(Class<?> lookupClass){\n-\t\t\tlookupClass.getClass();\t// implicit null check\n+\t\tpublic MethodHandles.Lookup in(Class<?> lookupClass) throws NullPointerException, IllegalArgumentException {\n+\t\t/*[ELSE]*/\n+\t\t/**\n+\t\t * Create a lookup on the request class.  The resulting lookup will have no more \n+\t\t * access privileges than the original.\n+\t\t * \n+\t\t * @param lookupClass - the class to create the lookup on\n+\t\t * @return a new MethodHandles.Lookup object\n+\t\t */\n+\t\tpublic MethodHandles.Lookup in(Class<?> lookupClass) {\n+\t\t/*[ENDIF] Java14 */\n+\t\t\tif (Objects.isNull(lookupClass)) {", "originalCommit": "893f1f7dda2a247400c13511aefc4df92fba6253", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY1MDM0Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r386650347", "bodyText": "Agreed and fixed.", "author": "ChengJin01", "createdAt": "2020-03-02T21:07:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNTQzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNTY4OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r386635688", "bodyText": "What's the expected behaviour of these cases pre-java14?  We may be able to enable this everywhere", "author": "DanHeidinga", "createdAt": "2020-03-02T20:36:32Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -1100,29 +1220,55 @@ public MethodHandle findStaticSetter(Class<?> clazz, String fieldName, Class<?>\n \t\t\treturn handle;\n \t\t}\n \t\t\n+\t\t/*[IF Java14]*/\n \t\t/**\n \t\t * Create a lookup on the request class.  The resulting lookup will have no more \n \t\t * access privileges than the original.\n \t\t * \n \t\t * @param lookupClass - the class to create the lookup on\n \t\t * @return a new MethodHandles.Lookup object\n+\t\t * @throws NullPointerException - if lookupClass is null\n+\t\t * @throws IllegalArgumentException - if the requested Class is a primitive type or an array class\n \t\t */\n-\t\tpublic MethodHandles.Lookup in(Class<?> lookupClass){\n-\t\t\tlookupClass.getClass();\t// implicit null check\n+\t\tpublic MethodHandles.Lookup in(Class<?> lookupClass) throws NullPointerException, IllegalArgumentException {\n+\t\t/*[ELSE]*/\n+\t\t/**\n+\t\t * Create a lookup on the request class.  The resulting lookup will have no more \n+\t\t * access privileges than the original.\n+\t\t * \n+\t\t * @param lookupClass - the class to create the lookup on\n+\t\t * @return a new MethodHandles.Lookup object\n+\t\t */\n+\t\tpublic MethodHandles.Lookup in(Class<?> lookupClass) {\n+\t\t/*[ENDIF] Java14 */\n+\t\t\tif (Objects.isNull(lookupClass)) {\n+\t\t\t\t/*[MSG \"K0682\", \"The requested lookup class must not be null\"]*/\n+\t\t\t\tthrow new NullPointerException(com.ibm.oti.util.Msg.getString(\"K0682\")); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\t\n+\t\t\t/*[IF Java14]*/\n+\t\t\tif ((lookupClass == void.class) || lookupClass.isPrimitive() || lookupClass.isArray()) {", "originalCommit": "893f1f7dda2a247400c13511aefc4df92fba6253", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY1NDYwNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r386654605", "bodyText": "there is no other check on the requested lookup class except the null-check according to the Spec at Java 11, 12 and 13 at\nhttp://cr.openjdk.java.net/~iris/se/11/build/latest/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#in(java.lang.Class)\nhttp://cr.openjdk.java.net/~iris/se/12/build/latest/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#in(java.lang.Class)\nhttp://cr.openjdk.java.net/~iris/se/13/build/latest/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#in(java.lang.Class)\npublic MethodHandles.Lookup in(Class<?> requestedLookupClass)\n...\nThrows:\n    NullPointerException - if the argument is null\n\nagainst the Java 14 Spec:\npublic MethodHandles.Lookup in(Class<?> requestedLookupClass)\n...\nThrows:\n  --> IllegalArgumentException - if requestedLookupClass is a primitive type or void or array class\n    NullPointerException - if the argument is null\n\nAnd such check is not required in other APIs in Java 14 except Lookup::in.\nSo it should never hurt to enable the check here (only internal tests need to be updated to deal with the check)", "author": "ChengJin01", "createdAt": "2020-03-02T21:16:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNTY4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgwNDk4Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r386804983", "bodyText": "I used jshell to test an RI JDK 10 as it was conveniently available and it doesn't have the check so we can't enable everywhere:\n$ ../../jdk-10.0.2+13/bin/jshell -J-showversion\nopenjdk version \"10.0.2-adoptopenjdk\" 2018-07-17\nOpenJDK Runtime Environment (build 10.0.2-adoptopenjdk+13)\nOpenJDK 64-Bit Server VM (build 10.0.2-adoptopenjdk+13, mixed mode)\n|  Welcome to JShell -- Version 10.0.2-adoptopenjdk\n|  For an introduction type: /help intro\n\njshell> import java.lang.invoke.*\n\njshell> MethodHandles.Lookup l = MethodHandles.lookup();\nl ==> \n\njshell> l.in(void.class)\n$3 ==> void/public\n\njshell> l.in(int.class)\n$4 ==> int/public\n\njshell> l.in(int[].class)\n$5 ==> [I/public", "author": "DanHeidinga", "createdAt": "2020-03-03T05:23:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNTY4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjgxNTU1MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r386815551", "bodyText": "I double-checked on RI/Hotspot at JDK 11, 12, 13 and 14 as follows and it turns out only RI JDK14 does the type check.\n\nJDK11\n\n# jdk_11.0.6_10_hotspot/bin/jshell -J-showversion\nopenjdk version \"11.0.6\" 2020-01-14\nOpenJDK Runtime Environment AdoptOpenJDK (build 11.0.6+10)\nOpenJDK 64-Bit Server VM AdoptOpenJDK (build 11.0.6+10, mixed mode)\nMar 02, 2020 9:54:53 PM java.util.prefs.FileSystemPreferences$1 run\nINFO: Created user preferences directory.\n|  Welcome to JShell -- Version 11.0.6\n|  For an introduction type: /help intro\n\njshell> import java.lang.invoke.*\n\njshell> MethodHandles.Lookup l = MethodHandles.lookup();\nl ==>\njshell> l.in(void.class)\n$3 ==> void/public\n\njshell> l.in(int.class)\n$4 ==> int/public\n\njshell> l.in(int[].class)\n$5 ==> [I/public\n\n\nJDK12\n\n# jdk_12.0.2_10_hotspot/bin/jshell -J-showversion\nopenjdk version \"12.0.2\" 2019-07-16\nOpenJDK Runtime Environment AdoptOpenJDK (build 12.0.2+10)\nOpenJDK 64-Bit Server VM AdoptOpenJDK (build 12.0.2+10, mixed mode, sharing)\n|  Welcome to JShell -- Version 12.0.2\n|  For an introduction type: /help intro\n\njshell> import java.lang.invoke.*\n\njshell> MethodHandles.Lookup l = MethodHandles.lookup();\nl ==>\n\njshell> l.in(void.class)\n$3 ==> void/public\n\njshell> l.in(int.class)\n$4 ==> int/public\n\njshell> l.in(int[].class)\n$5 ==> [I/public\n\n3.JDK13\n# jdk_13.0.2_8_hotspot/bin/jshell -J-showversion\nopenjdk version \"13.0.2\" 2020-01-14\nOpenJDK Runtime Environment AdoptOpenJDK (build 13.0.2+8)\nOpenJDK 64-Bit Server VM AdoptOpenJDK (build 13.0.2+8, mixed mode, sharing)\n|  Welcome to JShell -- Version 13.0.2\n|  For an introduction type: /help intro\n\njshell> import java.lang.invoke.*\n\njshell> MethodHandles.Lookup l = MethodHandles.lookup();\nl ==>\n\njshell> l.in(void.class)\n$3 ==> void/public\n\njshell> l.in(int.class)\n$4 ==> int/public\n\njshell> l.in(int[].class)\n$5 ==> [I/public\n\n4.JDK14\n# jdk14_hotspot_04_14_2020/bin/jshell -J-showversion\njava version \"14.0.1\" 2020-04-14\nJava(TM) SE Runtime Environment (build 14.0.1+4)\nJava HotSpot(TM) 64-Bit Server VM (build 14.0.1+4, mixed mode, sharing)\n|  Welcome to JShell -- Version 14.0.1\n|  For an introduction type: /help intro\n\njshell> import java.lang.invoke.*\n\njshell> MethodHandles.Lookup l = MethodHandles.lookup();\nl ==>\n\njshell> l.in(void.class)\n|  Exception java.lang.IllegalArgumentException: void is a primitive class\n|        at MethodHandles$Lookup.in (MethodHandles.java:1476)\n|        at (#3:1)\n\njshell> l.in(int.class)\n|  Exception java.lang.IllegalArgumentException: int is a primitive class\n|        at MethodHandles$Lookup.in (MethodHandles.java:1476)\n|        at (#4:1)\n\njshell> l.in(int[].class)\n|  Exception java.lang.IllegalArgumentException: class [I is an array class\n|        at MethodHandles$Lookup.in (MethodHandles.java:1478)\n|        at (#5:1)\n\nBased on the results above, I will restore the previous changes back to only have the check enabled on JDK14 and remove the test cases that was updated for the type check.", "author": "ChengJin01", "createdAt": "2020-03-03T06:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNTY4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI0ODMyOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r387248329", "bodyText": "The validity check has only been enabled on JDK14 and the corresponding test case were also disabled on JDK14. Will launch personal builds to see whether it works correctly as expected.", "author": "ChengJin01", "createdAt": "2020-03-03T19:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNTY4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNzI3OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r386637278", "bodyText": "This is a good use case for a switch statement:\nswitch(dropMode) {\ncase PUBLIC:\ncase MODULE:\ncase PACKAGE:\ncase PRIVATE:\ncase PROTECTED:\ncase UNCONDITIONAL:\n  /* dropMode is OK */\n  break;\ndefault:\n\t/*[MSG \"K065R\", \"The requested lookup mode: 0x{0} is not one of the existing access modes: 0x{1}\"]*/\n \tthrow new IllegalArgumentException(com.ibm.oti.util.Msg.getString(\"K065R\", Integer.toHexString(dropMode), Integer.toHexString(fullAccessMode))); \n}", "author": "DanHeidinga", "createdAt": "2020-03-02T20:40:06Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -1865,11 +2082,30 @@ public VarHandle unreflectVarHandle(Field field) throws IllegalAccessException {\n \t\t\t * as it is not set up for lookup objects by default.\n \t\t\t */\n \t\t\tint fullAccessMode = FULL_ACCESS_MASK | MODULE | UNCONDITIONAL;\n+\t\t\t\n+\t\t\tif ((dropMode != PUBLIC)\n+\t\t\t\t\t&& (dropMode != MODULE)\n+\t\t\t\t\t&& (dropMode != PACKAGE)\n+\t\t\t\t\t&& (dropMode != PRIVATE)\n+\t\t\t\t\t&& (dropMode != PROTECTED)\n+\t\t\t\t\t&& (dropMode != UNCONDITIONAL)\n+\t\t\t) {", "originalCommit": "893f1f7dda2a247400c13511aefc4df92fba6253", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjY1NTAyMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r386655022", "bodyText": "Agreed and replaced with switch statement.", "author": "ChengJin01", "createdAt": "2020-03-02T21:17:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjYzNzI3OA=="}], "type": "inlineReview"}, {"oid": "27703cc23fef422b27d5c01d3cc82052108e0d20", "url": "https://github.com/eclipse-openj9/openj9/commit/27703cc23fef422b27d5c01d3cc82052108e0d20", "message": "Update the Lookup specific code against the JDK14 Spec\n\nThe change is to update the code related to MH.Lookup\nto deal with the change of the full privilege access\nand the new concept called previous lookup class introduced\nin JDK14.\n\nFixes: #8571\n\nSigned-off-by: Cheng Jin <jincheng@ca.ibm.com>", "committedDate": "2020-03-02T21:06:38Z", "type": "forcePushed"}, {"oid": "910157e25aa9f5e964ea8bdb7d8fb899320dc27f", "url": "https://github.com/eclipse-openj9/openj9/commit/910157e25aa9f5e964ea8bdb7d8fb899320dc27f", "message": "Update the Lookup specific code against the JDK14 Spec\n\nThe change is to update the code related to MH.Lookup\nto deal with the change of the full privilege access\nand the new concept called previous lookup class introduced\nin JDK14.\n\nFixes: #8571\n\nSigned-off-by: Cheng Jin <jincheng@ca.ibm.com>", "committedDate": "2020-03-02T22:14:19Z", "type": "forcePushed"}, {"oid": "843e3f81590528251d612bedfdc3c563795329ee", "url": "https://github.com/eclipse-openj9/openj9/commit/843e3f81590528251d612bedfdc3c563795329ee", "message": "Update the Lookup specific code against the JDK14 Spec\n\nThe change is to update the code related to MH.Lookup\nto deal with the change of the full privilege access\nand the new concept called previous lookup class introduced\nin JDK14.\n\nFixes: #8571\n\nSigned-off-by: Cheng Jin <jincheng@ca.ibm.com>", "committedDate": "2020-03-03T01:01:59Z", "type": "forcePushed"}, {"oid": "593cac9ef55ab8f867183fb4725e255a898302fd", "url": "https://github.com/eclipse-openj9/openj9/commit/593cac9ef55ab8f867183fb4725e255a898302fd", "message": "Update the Lookup specific code against the JDK14 Spec\n\nThe change is to update the code related to MH.Lookup\nto deal with the change of the full privilege access\nand the new concept called previous lookup class introduced\nin JDK14.\n\nFixes: #8571\n\nSigned-off-by: Cheng Jin <jincheng@ca.ibm.com>", "committedDate": "2020-03-03T19:33:17Z", "type": "forcePushed"}, {"oid": "99faaccd43d84954406e90e6bca82f09878346b3", "url": "https://github.com/eclipse-openj9/openj9/commit/99faaccd43d84954406e90e6bca82f09878346b3", "message": "Update the Lookup specific code against the JDK14 Spec\n\nThe change is to update the code related to MH.Lookup\nto deal with the change of the full privilege access\nand the new concept called previous lookup class introduced\nin JDK14.\n\nFixes: #8571\n\nSigned-off-by: Cheng Jin <jincheng@ca.ibm.com>", "committedDate": "2020-03-03T19:34:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI1MjQwOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r387252408", "bodyText": "nitpick : pls add Java14 here.", "author": "JasonFengJ9", "createdAt": "2020-03-03T19:45:18Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -169,45 +169,60 @@\n \t\tstatic final int VARARGS = 0x80;\n \t\t\n \t\t/* single cached value of public Lookup object */\n-\t\t/*[IF Sidecar19-SE-OpenJ9]\n-\t\tstatic Lookup PUBLIC_LOOKUP = new Lookup(Object.class, Lookup.PUBLIC | Lookup.UNCONDITIONAL);\n+\t\tstatic final int mhMask = \n+\t\t/*[IF Java11]*/\n+\t\t/*[IF Java14]*/\n+\t\tLookup.UNCONDITIONAL;\n \t\t/*[ELSE]*/", "originalCommit": "99faaccd43d84954406e90e6bca82f09878346b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI1MzI5NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r387253294", "bodyText": "Fixed.", "author": "ChengJin01", "createdAt": "2020-03-03T19:46:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzI1MjQwOA=="}], "type": "inlineReview"}, {"oid": "85bb47f369d72e79486efa6a58c216236a787fd2", "url": "https://github.com/eclipse-openj9/openj9/commit/85bb47f369d72e79486efa6a58c216236a787fd2", "message": "Update the Lookup specific code against the JDK14 Spec\n\nThe change is to update the code related to MH.Lookup\nto deal with the change of the full privilege access\nand the new concept called previous lookup class introduced\nin JDK14.\n\nFixes: #8571\n\nSigned-off-by: Cheng Jin <jincheng@ca.ibm.com>", "committedDate": "2020-03-03T19:46:39Z", "type": "forcePushed"}, {"oid": "2e5e67581a539e04a56b75e594345758ba14034d", "url": "https://github.com/eclipse-openj9/openj9/commit/2e5e67581a539e04a56b75e594345758ba14034d", "message": "Update the Lookup specific code against the JDK14 Spec\n\nThe change is to update the code related to MH.Lookup\nto deal with the change of the full privilege access\nand the new concept called previous lookup class introduced\nin JDK14.\n\nFixes: #8571\n\nSigned-off-by: Cheng Jin <jincheng@ca.ibm.com>", "committedDate": "2020-03-04T21:10:37Z", "type": "forcePushed"}, {"oid": "f947deba7532c4d6406cfed387c48f575021151e", "url": "https://github.com/eclipse-openj9/openj9/commit/f947deba7532c4d6406cfed387c48f575021151e", "message": "Update the Lookup specific code against the JDK14 Spec\n\nThe change is to update the code related to MH.Lookup\nto deal with the change of the full privilege access\nand the new concept called previous lookup class introduced\nin JDK14.\n\nFixes: #8571\n\nSigned-off-by: Cheng Jin <jincheng@ca.ibm.com>", "committedDate": "2020-03-05T18:10:34Z", "type": "forcePushed"}, {"oid": "fd6f62fa41d798c471298ee9f0b75576294d96c6", "url": "https://github.com/eclipse-openj9/openj9/commit/fd6f62fa41d798c471298ee9f0b75576294d96c6", "message": "Update the Lookup specific code against the JDK14 Spec\n\nThe change is to update the code related to MH.Lookup\nto deal with the change of the full privilege access\nand the new concept called previous lookup class introduced\nin JDK14.\n\nFixes: #8570, Fixes: #8571\n\nSigned-off-by: Cheng Jin <jincheng@ca.ibm.com>", "committedDate": "2020-03-05T18:16:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzc1NjM1Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r387756353", "bodyText": "void.class.isPrimitive() is true\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tif ((lookupClass == void.class) || lookupClass.isPrimitive() || lookupClass.isArray()) {\n          \n          \n            \n            \t\t\tif (lookupClass.isPrimitive() || lookupClass.isArray()) {", "author": "DanHeidinga", "createdAt": "2020-03-04T15:49:30Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -1100,29 +1233,52 @@ public MethodHandle findStaticSetter(Class<?> clazz, String fieldName, Class<?>\n \t\t\treturn handle;\n \t\t}\n \t\t\n+\t\t/*[IF Java14]*/\n+\t\t/**\n+\t\t * Create a lookup on the request class.  The resulting lookup will have no more \n+\t\t * access privileges than the original.\n+\t\t * \n+\t\t * @param lookupClass - the class to create the lookup on\n+\t\t * @return a new MethodHandles.Lookup object\n+\t\t * @throws NullPointerException - if lookupClass is null\n+\t\t * @throws IllegalArgumentException - if the requested Class is a primitive type or an array class\n+\t\t */\n+\t\tpublic MethodHandles.Lookup in(Class<?> lookupClass) throws NullPointerException, IllegalArgumentException {\n+\t\t/*[ELSE]*/\n \t\t/**\n \t\t * Create a lookup on the request class.  The resulting lookup will have no more \n \t\t * access privileges than the original.\n \t\t * \n \t\t * @param lookupClass - the class to create the lookup on\n \t\t * @return a new MethodHandles.Lookup object\n \t\t */\n-\t\tpublic MethodHandles.Lookup in(Class<?> lookupClass){\n-\t\t\tlookupClass.getClass();\t// implicit null check\n+\t\tpublic MethodHandles.Lookup in(Class<?> lookupClass) {\n+\t\t/*[ENDIF] Java14 */\n+\t\t\tObjects.requireNonNull(lookupClass);\n+\t\t\t\n+\t\t\t/*[IF Java14]*/\n+\t\t\tif ((lookupClass == void.class) || lookupClass.isPrimitive() || lookupClass.isArray()) {", "originalCommit": "85bb47f369d72e79486efa6a58c216236a787fd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU1ODgyMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r388558823", "bodyText": "Agreed and removed lookupClass == void.class against the suggestion above.", "author": "ChengJin01", "createdAt": "2020-03-05T20:52:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Nzc1NjM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQwMDkwOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r388400909", "bodyText": "Why would dropLookupMode ever modify the previousAccessClass?", "author": "DanHeidinga", "createdAt": "2020-03-05T16:15:34Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -1865,47 +2136,109 @@ public VarHandle unreflectVarHandle(Field field) throws IllegalAccessException {\n \t\t\t * as it is not set up for lookup objects by default.\n \t\t\t */\n \t\t\tint fullAccessMode = FULL_ACCESS_MASK | MODULE | UNCONDITIONAL;\n+\t\t\t\n+\t\t\tswitch(dropMode) {\n+\t\t\tcase PUBLIC:\n+\t\t\tcase MODULE:\n+\t\t\tcase PACKAGE:\n+\t\t\tcase PRIVATE:\n+\t\t\tcase PROTECTED:\n+\t\t\tcase UNCONDITIONAL:\n+\t\t\t\t/* dropMode is OK */\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\t/*[MSG \"K065R\", \"The requested lookup mode: 0x{0} is not one of the existing access modes: 0x{1}\"]*/\n+\t\t\t\tthrow new IllegalArgumentException(com.ibm.oti.util.Msg.getString(\"K065R\", Integer.toHexString(dropMode), Integer.toHexString(fullAccessMode))); //$NON-NLS-1$\n+\t\t\t}\n \n+\t\t\t/*[IF Java14]*/\n+\t\t\t/* The lookup object has to discard the protected access by default */\n+\t\t\tint newAccessMode = accessMode & ~PROTECTED;\n+\t\t\t/*[ELSE]*/\n \t\t\t/* The lookup object has to discard the protected and unconditional access by default */\n \t\t\tint newAccessMode = accessMode & ~(PROTECTED | UNCONDITIONAL);\n+\t\t\t/*[ENDIF] Java14*/\n \t\t\t\n-\t\t\tswitch (dropMode) {\n+\t\t\t/* The access mode to be dropped must exist in the current access mode;\n+\t\t\t * otherwise, the new access mode remains unchanged.\n+\t\t\t */\n+\t\t\tswitch (dropMode & newAccessMode) {\n \t\t\tcase PUBLIC:\n \t\t\t\tnewAccessMode = NO_ACCESS;\n \t\t\t\tbreak;\n-\t\t\tcase MODULE:\n-\t\t\t\tnewAccessMode &= ~(MODULE | PACKAGE | PRIVATE);\n-\t\t\t\tbreak;\n \t\t\tcase PACKAGE:\n \t\t\t\tnewAccessMode &= ~(PACKAGE | PRIVATE);\n \t\t\t\tbreak;\n \t\t\tcase PRIVATE:\n \t\t\t\tnewAccessMode &= ~PRIVATE;\n \t\t\t\tbreak;\n-\t\t\tcase PROTECTED:\n \t\t\tcase UNCONDITIONAL:\n+\t\t\t\t/*[IF Java14]*/\n+\t\t\t\tnewAccessMode = NO_ACCESS;\n+\t\t\t\t/*[ENDIF] Java14*/\n \t\t\t\tbreak;\n \t\t\tdefault:\n-\t\t\t\t/*[MSG \"K065R\", \"The requested lookup mode: 0x{0} is not one of the existing access modes: 0x{1}\"]*/\n-\t\t\t\tthrow new IllegalArgumentException(com.ibm.oti.util.Msg.getString(\"K065R\", Integer.toHexString(dropMode), Integer.toHexString(fullAccessMode))); //$NON-NLS-1$\n+\t\t\t\t/* no change in the access mode */\n \t\t\t}\n \t\t\t\n-\t\t\treturn new Lookup(accessClass, newAccessMode); \n+\t\t\t/* The exception is MODULE in which case all access bits involved must be dropped\n+\t\t\t * whether or not the MODULE bit exists in the access mode.\n+\t\t\t */\n+\t\t\tif ((dropMode == MODULE) || ((dropMode & newAccessMode) == MODULE)) {\n+\t\t\t\tnewAccessMode &= ~(MODULE | PACKAGE | PRIVATE);\n+\t\t\t}\n+\t\t\t\n+\t\t\t/*[IF Java14]*/\n+\t\t\t/* There is no previous lookup class for the requested lookup class\n+\t\t\t * if the MODULE or UNCONDITIONAL bit is set in the new access mode.\n+\t\t\t */\n+\t\t\tClass<?> newPrevAccessClass = prevAccessClass;\n+\t\t\tif (((newAccessMode & MODULE) == MODULE)\n+\t\t\t\t|| ((newAccessMode & UNCONDITIONAL) == UNCONDITIONAL)\n+\t\t\t) {\n+\t\t\t\tnewPrevAccessClass = null;\n+\t\t\t}", "originalCommit": "2e5e67581a539e04a56b75e594345758ba14034d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU0NzkxOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r388547918", "bodyText": "at http://cr.openjdk.java.net/~iris/se/14/build/latest/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#UNCONDITIONAL:\npublic static final int UNCONDITIONAL\n...\nIf this lookup mode is set, the previous lookup class is always null. \n<----- this is the new change when setting up UNCONDITIONAL since Java 14\n\nThe newly added description requires to handle previousAccessClass which is not specific to dropLookupMode() but everywhere when the UNCONDITIONAL bit is set initially.", "author": "ChengJin01", "createdAt": "2020-03-05T20:32:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQwMDkwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQxNDY1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r388414656", "bodyText": "void.class.isPrimitive is true so we don't need to first check", "author": "DanHeidinga", "createdAt": "2020-03-05T16:36:21Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -1959,8 +2292,8 @@ static MethodHandle filterArgument(MethodHandle target, int pos, MethodHandle fi\n \t\t\tthrow new NullPointerException(com.ibm.oti.util.Msg.getString(\"K065S\")); //$NON-NLS-1$\n \t\t}\n \t\t\n-\t\tif (targetClass.isPrimitive() || targetClass.isArray()) {\n-\t\t\t/*[MSG \"K065T\", \"The target class: {0} must not be a primitive type or an array class\"]*/\n+\t\tif ((targetClass == void.class) || targetClass.isPrimitive() || targetClass.isArray()) {", "originalCommit": "2e5e67581a539e04a56b75e594345758ba14034d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU1ODk0Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r388558942", "bodyText": "Fixed.", "author": "ChengJin01", "createdAt": "2020-03-05T20:52:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODQxNDY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxMzE1MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r388513151", "bodyText": "Why is this an exception?  I don't see anything about this in the \"Access modes\" table showing dropLookupMode behaviour in https://download.java.net/java/early_access/jdk14/docs/api/java.base/java/lang/invoke/MethodHandles.Lookup.html#access-modes\nIt seems like this should apply to all dropped modes & the change to switch (dropMode & newAccessMode) is unnecessary", "author": "DanHeidinga", "createdAt": "2020-03-05T19:27:41Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -1865,47 +2136,109 @@ public VarHandle unreflectVarHandle(Field field) throws IllegalAccessException {\n \t\t\t * as it is not set up for lookup objects by default.\n \t\t\t */\n \t\t\tint fullAccessMode = FULL_ACCESS_MASK | MODULE | UNCONDITIONAL;\n+\t\t\t\n+\t\t\tswitch(dropMode) {\n+\t\t\tcase PUBLIC:\n+\t\t\tcase MODULE:\n+\t\t\tcase PACKAGE:\n+\t\t\tcase PRIVATE:\n+\t\t\tcase PROTECTED:\n+\t\t\tcase UNCONDITIONAL:\n+\t\t\t\t/* dropMode is OK */\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\t/*[MSG \"K065R\", \"The requested lookup mode: 0x{0} is not one of the existing access modes: 0x{1}\"]*/\n+\t\t\t\tthrow new IllegalArgumentException(com.ibm.oti.util.Msg.getString(\"K065R\", Integer.toHexString(dropMode), Integer.toHexString(fullAccessMode))); //$NON-NLS-1$\n+\t\t\t}\n \n+\t\t\t/*[IF Java14]*/\n+\t\t\t/* The lookup object has to discard the protected access by default */\n+\t\t\tint newAccessMode = accessMode & ~PROTECTED;\n+\t\t\t/*[ELSE]*/\n \t\t\t/* The lookup object has to discard the protected and unconditional access by default */\n \t\t\tint newAccessMode = accessMode & ~(PROTECTED | UNCONDITIONAL);\n+\t\t\t/*[ENDIF] Java14*/\n \t\t\t\n-\t\t\tswitch (dropMode) {\n+\t\t\t/* The access mode to be dropped must exist in the current access mode;\n+\t\t\t * otherwise, the new access mode remains unchanged.\n+\t\t\t */\n+\t\t\tswitch (dropMode & newAccessMode) {\n \t\t\tcase PUBLIC:\n \t\t\t\tnewAccessMode = NO_ACCESS;\n \t\t\t\tbreak;\n-\t\t\tcase MODULE:\n-\t\t\t\tnewAccessMode &= ~(MODULE | PACKAGE | PRIVATE);\n-\t\t\t\tbreak;\n \t\t\tcase PACKAGE:\n \t\t\t\tnewAccessMode &= ~(PACKAGE | PRIVATE);\n \t\t\t\tbreak;\n \t\t\tcase PRIVATE:\n \t\t\t\tnewAccessMode &= ~PRIVATE;\n \t\t\t\tbreak;\n-\t\t\tcase PROTECTED:\n \t\t\tcase UNCONDITIONAL:\n+\t\t\t\t/*[IF Java14]*/\n+\t\t\t\tnewAccessMode = NO_ACCESS;\n+\t\t\t\t/*[ENDIF] Java14*/\n \t\t\t\tbreak;\n \t\t\tdefault:\n-\t\t\t\t/*[MSG \"K065R\", \"The requested lookup mode: 0x{0} is not one of the existing access modes: 0x{1}\"]*/\n-\t\t\t\tthrow new IllegalArgumentException(com.ibm.oti.util.Msg.getString(\"K065R\", Integer.toHexString(dropMode), Integer.toHexString(fullAccessMode))); //$NON-NLS-1$\n+\t\t\t\t/* no change in the access mode */\n \t\t\t}\n \t\t\t\n-\t\t\treturn new Lookup(accessClass, newAccessMode); \n+\t\t\t/* The exception is MODULE in which case all access bits involved must be dropped", "originalCommit": "fd6f62fa41d798c471298ee9f0b75576294d96c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU1MTEwOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r388551108", "bodyText": "As mentioned at #8571 (comment),\n  public void testDropLookupMode() throws Exception {\n        Lookup lookup = MethodHandles.privateLookupIn(m5.type1, m4.lookup);\n        assertTrue((lookup.lookupModes() & MODULE) == 0); <--- MODULE doesn't exist\n        ...\n        Lookup lookup3 = lookup.dropLookupMode(MODULE);\n---> assertTrue(lookup3.lookupModes() == (lookup.lookupModes() & ~(PROTECTED|PRIVATE|PACKAGE)));\n\nHere's the printing message for the test above\n[TestNG] Running:\n  java/lang/invoke/modules/Driver1.java\n\nconfig jdk.test.ModuleAccessTest.setup(): success\n----- testDropLookupMode --------\nm4.lookup.lookupModes() = 31\nm4.lookup.lookupClass() = class d1.D1\nm4.lookup.lookupClass().getModule() = module m4\nm5.type1.getModule() = module m5\n\nlookup = e1.E1/d1.D1\nlookup.lookupClass = class e1.E1\nlookup.lookupClass().getModule() = module m5\nlookup.lookupModes() = 15 <--------------------- 0xF or 1111 <---- MODULE doesn't exist\nlookup.previousLookupClass() = class d1.D1\nlookup.lookupModes() & ~(PROTECTED|PRIVATE|PACKAGE) = 1\nlookup3.lookupModes() = 1 <------------------------------ PUBLIC is left eventually\ntest jdk.test.ModuleAccessTest.testDropLookupMode(): failure\n\nBased on the weird result, the generated lookup  doesn't hold the MODULE bit, in which case it shouldn't drop all PROTECTED|PRIVATE|PACKAGE as if the MODULE bit exists if the previous clarification from Oracle (mode to be dropped must exist in the access mode) is reasonable; Otherwise, Oracle should bring up with another explanation as to how this happens and why.", "author": "ChengJin01", "createdAt": "2020-03-05T20:38:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUxMzE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyMDU4Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r388520582", "bodyText": "Can you add the following code here to make it more clear?\n/* A protected class (must be a member class) is compiled to a public class as\n * the protected flag of this class doesn't exist on the VM level (there is no \n * access flag in the binary form representing 'protected')\n */\n final boolean targetClassIsPublic = (Modifier.isPublic(targetClassModifiers) || Modifier.isProtected(targetClassModifiers));", "author": "DanHeidinga", "createdAt": "2020-03-05T19:41:53Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -535,28 +568,67 @@ private void checkAccess(Class<?> definingClass, Class<?> referenceClass, String\n \t\t */\n \t\tprivate void checkClassAccess(Class<?> targetClass) throws IllegalAccessException {\n \t\t\t/*[IF Sidecar19-SE]*/\n+\t\t\t/*[IF Java14]*/\n+\t\t\tcheckClassModuleVisibility(accessMode, accessClass, prevAccessClass, targetClass);\n+\t\t\t/*[ELSE]*/\n \t\t\tcheckClassModuleVisibility(accessMode, accessClass.getModule(), targetClass);\n+\t\t\t/*[ENDIF] Java14*/\n \t\t\t/*[ENDIF]*/\n+\t\t\t\n \t\t\tif (NO_ACCESS != accessMode) {\n-\t\t\t\t/* target class should always be accessible to the lookup class when they are the same class */\n-\t\t\t\tif (accessClass == targetClass) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\t\n-\t\t\t\tint modifiers = targetClass.getModifiers();\n-\t\t\t\t\n-\t\t\t\t/* A protected class (must be a member class) is compiled to a public class as\n-\t\t\t\t * the protected flag of this class doesn't exist on the VM level (there is no \n-\t\t\t\t * access flag in the binary form representing 'protected')\n-\t\t\t\t */\n-\t\t\t\tif (Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers)) {\n-\t\t\t\t\t/* Already determined that we have more than \"no access\" (public access) */\n+\t\t\t\tint targetClassModifiers = targetClass.getModifiers();", "originalCommit": "fd6f62fa41d798c471298ee9f0b75576294d96c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU1OTIzMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r388559232", "bodyText": "Updated the code as suggested above.", "author": "ChengJin01", "createdAt": "2020-03-05T20:53:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyMDU4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyMDcwMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r388520700", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t&& (Modifier.isPublic(targetClassModifiers) || Modifier.isProtected(targetClassModifiers))\n          \n          \n            \n            \t\t\t\t\t&& targetClassIsPublic", "author": "DanHeidinga", "createdAt": "2020-03-05T19:42:06Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -535,28 +568,67 @@ private void checkAccess(Class<?> definingClass, Class<?> referenceClass, String\n \t\t */\n \t\tprivate void checkClassAccess(Class<?> targetClass) throws IllegalAccessException {\n \t\t\t/*[IF Sidecar19-SE]*/\n+\t\t\t/*[IF Java14]*/\n+\t\t\tcheckClassModuleVisibility(accessMode, accessClass, prevAccessClass, targetClass);\n+\t\t\t/*[ELSE]*/\n \t\t\tcheckClassModuleVisibility(accessMode, accessClass.getModule(), targetClass);\n+\t\t\t/*[ENDIF] Java14*/\n \t\t\t/*[ENDIF]*/\n+\t\t\t\n \t\t\tif (NO_ACCESS != accessMode) {\n-\t\t\t\t/* target class should always be accessible to the lookup class when they are the same class */\n-\t\t\t\tif (accessClass == targetClass) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\t\n-\t\t\t\tint modifiers = targetClass.getModifiers();\n-\t\t\t\t\n-\t\t\t\t/* A protected class (must be a member class) is compiled to a public class as\n-\t\t\t\t * the protected flag of this class doesn't exist on the VM level (there is no \n-\t\t\t\t * access flag in the binary form representing 'protected')\n-\t\t\t\t */\n-\t\t\t\tif (Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers)) {\n-\t\t\t\t\t/* Already determined that we have more than \"no access\" (public access) */\n+\t\t\t\tint targetClassModifiers = targetClass.getModifiers();\n+\t\t\t\t/*[IF Java14]*/\n+\t\t\t\tModule accessModule = accessClass.getModule();\n+\t\t\t\tModule targetModule = targetClass.getModule();\n+\t\t\t\tString targetClassPackageName = targetClass.getPackageName();\n+\n+\t\t\t\tif (((UNCONDITIONAL & accessMode) == UNCONDITIONAL)\n+\t\t\t\t\t&& (Modifier.isPublic(targetClassModifiers) || Modifier.isProtected(targetClassModifiers))", "originalCommit": "fd6f62fa41d798c471298ee9f0b75576294d96c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU1OTMzMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r388559333", "bodyText": "Fixed.", "author": "ChengJin01", "createdAt": "2020-03-05T20:53:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyMDcwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyMDk0NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r388520944", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t/* A protected class (must be a member class) is compiled to a public class as\n          \n          \n            \n            \t\t\t\t\t * the protected flag of this class doesn't exist on the VM level (there is no \n          \n          \n            \n            \t\t\t\t\t * access flag in the binary form representing 'protected')\n          \n          \n            \n            \t\t\t\t\t */\n          \n          \n            \n            \t\t\t\t\tif (Modifier.isPublic(targetClassModifiers) || Modifier.isProtected(targetClassModifiers)) {\n          \n          \n            \n            \t\t\t\t\tif (targetClassIsPublic) {", "author": "DanHeidinga", "createdAt": "2020-03-05T19:42:36Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -535,28 +568,67 @@ private void checkAccess(Class<?> definingClass, Class<?> referenceClass, String\n \t\t */\n \t\tprivate void checkClassAccess(Class<?> targetClass) throws IllegalAccessException {\n \t\t\t/*[IF Sidecar19-SE]*/\n+\t\t\t/*[IF Java14]*/\n+\t\t\tcheckClassModuleVisibility(accessMode, accessClass, prevAccessClass, targetClass);\n+\t\t\t/*[ELSE]*/\n \t\t\tcheckClassModuleVisibility(accessMode, accessClass.getModule(), targetClass);\n+\t\t\t/*[ENDIF] Java14*/\n \t\t\t/*[ENDIF]*/\n+\t\t\t\n \t\t\tif (NO_ACCESS != accessMode) {\n-\t\t\t\t/* target class should always be accessible to the lookup class when they are the same class */\n-\t\t\t\tif (accessClass == targetClass) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\t\n-\t\t\t\tint modifiers = targetClass.getModifiers();\n-\t\t\t\t\n-\t\t\t\t/* A protected class (must be a member class) is compiled to a public class as\n-\t\t\t\t * the protected flag of this class doesn't exist on the VM level (there is no \n-\t\t\t\t * access flag in the binary form representing 'protected')\n-\t\t\t\t */\n-\t\t\t\tif (Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers)) {\n-\t\t\t\t\t/* Already determined that we have more than \"no access\" (public access) */\n+\t\t\t\tint targetClassModifiers = targetClass.getModifiers();\n+\t\t\t\t/*[IF Java14]*/\n+\t\t\t\tModule accessModule = accessClass.getModule();\n+\t\t\t\tModule targetModule = targetClass.getModule();\n+\t\t\t\tString targetClassPackageName = targetClass.getPackageName();\n+\n+\t\t\t\tif (((UNCONDITIONAL & accessMode) == UNCONDITIONAL)\n+\t\t\t\t\t&& (Modifier.isPublic(targetClassModifiers) || Modifier.isProtected(targetClassModifiers))\n+\t\t\t\t\t&& targetModule.isExported(targetClassPackageName)\n+\t\t\t\t) {\n \t\t\t\t\treturn;\n-\t\t\t\t} else {\n-\t\t\t\t\tif (((PACKAGE == (accessMode & PACKAGE)) || Modifier.isPrivate(accessMode)) && isSamePackage(accessClass, targetClass)) {\n+\t\t\t\t} else if ((targetModule != null) && (accessModule != null) \n+\t\t\t\t\t\t&& (accessModule.equals(targetModule) || (!accessModule.isNamed() && !targetModule.isNamed()))\n+\t\t\t\t) {\n+\t\t\t\t\tif (((PRIVATE & accessMode) == PRIVATE)\n+\t\t\t\t\t\t&& ((targetClass == accessClass) || targetClass.isNestmateOf(accessClass))\n+\t\t\t\t\t) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t} else if (((PACKAGE & accessMode) == PACKAGE) && isSamePackage(targetClass, accessClass)) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t} else if (((MODULE & accessMode) == MODULE)\n+\t\t\t\t\t\t&& (Modifier.isPublic(targetClassModifiers) || Modifier.isProtected(targetClassModifiers))\n+\t\t\t\t\t) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t} else if (((PUBLIC & accessMode) == PUBLIC)\n+\t\t\t\t\t\t&& (Modifier.isPublic(targetClassModifiers) || Modifier.isProtected(targetClassModifiers))\n+\t\t\t\t\t\t&& (((prevAccessClass != null) && targetModule.isExported(targetClassPackageName, prevAccessClass.getModule()))\n+\t\t\t\t\t\t\t|| targetModule.isExported(targetClassPackageName))\n+\t\t\t\t\t) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t}\n+\t\t\t\t} else if ((PUBLIC & accessMode) == PUBLIC) {\n+\t\t\t\t/*[ENDIF] Java14*/\n+\t\t\t\t\t/* target class should always be accessible to the lookup class when they are the same class */\n+\t\t\t\t\tif (accessClass == targetClass) {\n \t\t\t\t\t\treturn;\n \t\t\t\t\t}\n+\t\t\t\t\t\n+\t\t\t\t\t/* A protected class (must be a member class) is compiled to a public class as\n+\t\t\t\t\t * the protected flag of this class doesn't exist on the VM level (there is no \n+\t\t\t\t\t * access flag in the binary form representing 'protected')\n+\t\t\t\t\t */\n+\t\t\t\t\tif (Modifier.isPublic(targetClassModifiers) || Modifier.isProtected(targetClassModifiers)) {", "originalCommit": "fd6f62fa41d798c471298ee9f0b75576294d96c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU1OTM4NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r388559385", "bodyText": "Fixed.", "author": "ChengJin01", "createdAt": "2020-03-05T20:53:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyMDk0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyODMyMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r388528320", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\tif (((UNCONDITIONAL & accessMode) == UNCONDITIONAL)\n          \n          \n            \n            \t\t\t\t/* An UNCONDITIONAL lookup has access to public types in any unconditionally exported package */\n          \n          \n            \n            \t\t\t\tif (((UNCONDITIONAL & accessMode) == UNCONDITIONAL)", "author": "DanHeidinga", "createdAt": "2020-03-05T19:55:39Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -535,28 +568,67 @@ private void checkAccess(Class<?> definingClass, Class<?> referenceClass, String\n \t\t */\n \t\tprivate void checkClassAccess(Class<?> targetClass) throws IllegalAccessException {\n \t\t\t/*[IF Sidecar19-SE]*/\n+\t\t\t/*[IF Java14]*/\n+\t\t\tcheckClassModuleVisibility(accessMode, accessClass, prevAccessClass, targetClass);\n+\t\t\t/*[ELSE]*/\n \t\t\tcheckClassModuleVisibility(accessMode, accessClass.getModule(), targetClass);\n+\t\t\t/*[ENDIF] Java14*/\n \t\t\t/*[ENDIF]*/\n+\t\t\t\n \t\t\tif (NO_ACCESS != accessMode) {\n-\t\t\t\t/* target class should always be accessible to the lookup class when they are the same class */\n-\t\t\t\tif (accessClass == targetClass) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\t\n-\t\t\t\tint modifiers = targetClass.getModifiers();\n-\t\t\t\t\n-\t\t\t\t/* A protected class (must be a member class) is compiled to a public class as\n-\t\t\t\t * the protected flag of this class doesn't exist on the VM level (there is no \n-\t\t\t\t * access flag in the binary form representing 'protected')\n-\t\t\t\t */\n-\t\t\t\tif (Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers)) {\n-\t\t\t\t\t/* Already determined that we have more than \"no access\" (public access) */\n+\t\t\t\tint targetClassModifiers = targetClass.getModifiers();\n+\t\t\t\t/*[IF Java14]*/\n+\t\t\t\tModule accessModule = accessClass.getModule();\n+\t\t\t\tModule targetModule = targetClass.getModule();\n+\t\t\t\tString targetClassPackageName = targetClass.getPackageName();\n+\n+\t\t\t\tif (((UNCONDITIONAL & accessMode) == UNCONDITIONAL)", "originalCommit": "fd6f62fa41d798c471298ee9f0b75576294d96c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU1OTg1Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r388559856", "bodyText": "Comments were added for UNCONDITIONAL against the suggestion above.", "author": "ChengJin01", "createdAt": "2020-03-05T20:54:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyODMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyOTg0MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r388529840", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t\t&& (Modifier.isPublic(targetClassModifiers) || Modifier.isProtected(targetClassModifiers))\n          \n          \n            \n            \t\t\t\t\t\t&& (targetClassIsPublic)", "author": "DanHeidinga", "createdAt": "2020-03-05T19:58:20Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -535,28 +568,67 @@ private void checkAccess(Class<?> definingClass, Class<?> referenceClass, String\n \t\t */\n \t\tprivate void checkClassAccess(Class<?> targetClass) throws IllegalAccessException {\n \t\t\t/*[IF Sidecar19-SE]*/\n+\t\t\t/*[IF Java14]*/\n+\t\t\tcheckClassModuleVisibility(accessMode, accessClass, prevAccessClass, targetClass);\n+\t\t\t/*[ELSE]*/\n \t\t\tcheckClassModuleVisibility(accessMode, accessClass.getModule(), targetClass);\n+\t\t\t/*[ENDIF] Java14*/\n \t\t\t/*[ENDIF]*/\n+\t\t\t\n \t\t\tif (NO_ACCESS != accessMode) {\n-\t\t\t\t/* target class should always be accessible to the lookup class when they are the same class */\n-\t\t\t\tif (accessClass == targetClass) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\t\n-\t\t\t\tint modifiers = targetClass.getModifiers();\n-\t\t\t\t\n-\t\t\t\t/* A protected class (must be a member class) is compiled to a public class as\n-\t\t\t\t * the protected flag of this class doesn't exist on the VM level (there is no \n-\t\t\t\t * access flag in the binary form representing 'protected')\n-\t\t\t\t */\n-\t\t\t\tif (Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers)) {\n-\t\t\t\t\t/* Already determined that we have more than \"no access\" (public access) */\n+\t\t\t\tint targetClassModifiers = targetClass.getModifiers();\n+\t\t\t\t/*[IF Java14]*/\n+\t\t\t\tModule accessModule = accessClass.getModule();\n+\t\t\t\tModule targetModule = targetClass.getModule();\n+\t\t\t\tString targetClassPackageName = targetClass.getPackageName();\n+\n+\t\t\t\tif (((UNCONDITIONAL & accessMode) == UNCONDITIONAL)\n+\t\t\t\t\t&& (Modifier.isPublic(targetClassModifiers) || Modifier.isProtected(targetClassModifiers))\n+\t\t\t\t\t&& targetModule.isExported(targetClassPackageName)\n+\t\t\t\t) {\n \t\t\t\t\treturn;\n-\t\t\t\t} else {\n-\t\t\t\t\tif (((PACKAGE == (accessMode & PACKAGE)) || Modifier.isPrivate(accessMode)) && isSamePackage(accessClass, targetClass)) {\n+\t\t\t\t} else if ((targetModule != null) && (accessModule != null) \n+\t\t\t\t\t\t&& (accessModule.equals(targetModule) || (!accessModule.isNamed() && !targetModule.isNamed()))\n+\t\t\t\t) {\n+\t\t\t\t\tif (((PRIVATE & accessMode) == PRIVATE)\n+\t\t\t\t\t\t&& ((targetClass == accessClass) || targetClass.isNestmateOf(accessClass))\n+\t\t\t\t\t) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t} else if (((PACKAGE & accessMode) == PACKAGE) && isSamePackage(targetClass, accessClass)) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t} else if (((MODULE & accessMode) == MODULE)\n+\t\t\t\t\t\t&& (Modifier.isPublic(targetClassModifiers) || Modifier.isProtected(targetClassModifiers))", "originalCommit": "fd6f62fa41d798c471298ee9f0b75576294d96c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU1OTk0Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r388559947", "bodyText": "Fixed.", "author": "ChengJin01", "createdAt": "2020-03-05T20:54:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyOTg0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyOTk2NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r388529964", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\t\t\t\t&& (Modifier.isPublic(targetClassModifiers) || Modifier.isProtected(targetClassModifiers))\n          \n          \n            \n            \t\t\t\t\t\t&& (targetClassIsPublic)", "author": "DanHeidinga", "createdAt": "2020-03-05T19:58:36Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandles.java", "diffHunk": "@@ -535,28 +568,67 @@ private void checkAccess(Class<?> definingClass, Class<?> referenceClass, String\n \t\t */\n \t\tprivate void checkClassAccess(Class<?> targetClass) throws IllegalAccessException {\n \t\t\t/*[IF Sidecar19-SE]*/\n+\t\t\t/*[IF Java14]*/\n+\t\t\tcheckClassModuleVisibility(accessMode, accessClass, prevAccessClass, targetClass);\n+\t\t\t/*[ELSE]*/\n \t\t\tcheckClassModuleVisibility(accessMode, accessClass.getModule(), targetClass);\n+\t\t\t/*[ENDIF] Java14*/\n \t\t\t/*[ENDIF]*/\n+\t\t\t\n \t\t\tif (NO_ACCESS != accessMode) {\n-\t\t\t\t/* target class should always be accessible to the lookup class when they are the same class */\n-\t\t\t\tif (accessClass == targetClass) {\n-\t\t\t\t\treturn;\n-\t\t\t\t}\n-\t\t\t\t\n-\t\t\t\tint modifiers = targetClass.getModifiers();\n-\t\t\t\t\n-\t\t\t\t/* A protected class (must be a member class) is compiled to a public class as\n-\t\t\t\t * the protected flag of this class doesn't exist on the VM level (there is no \n-\t\t\t\t * access flag in the binary form representing 'protected')\n-\t\t\t\t */\n-\t\t\t\tif (Modifier.isPublic(modifiers) || Modifier.isProtected(modifiers)) {\n-\t\t\t\t\t/* Already determined that we have more than \"no access\" (public access) */\n+\t\t\t\tint targetClassModifiers = targetClass.getModifiers();\n+\t\t\t\t/*[IF Java14]*/\n+\t\t\t\tModule accessModule = accessClass.getModule();\n+\t\t\t\tModule targetModule = targetClass.getModule();\n+\t\t\t\tString targetClassPackageName = targetClass.getPackageName();\n+\n+\t\t\t\tif (((UNCONDITIONAL & accessMode) == UNCONDITIONAL)\n+\t\t\t\t\t&& (Modifier.isPublic(targetClassModifiers) || Modifier.isProtected(targetClassModifiers))\n+\t\t\t\t\t&& targetModule.isExported(targetClassPackageName)\n+\t\t\t\t) {\n \t\t\t\t\treturn;\n-\t\t\t\t} else {\n-\t\t\t\t\tif (((PACKAGE == (accessMode & PACKAGE)) || Modifier.isPrivate(accessMode)) && isSamePackage(accessClass, targetClass)) {\n+\t\t\t\t} else if ((targetModule != null) && (accessModule != null) \n+\t\t\t\t\t\t&& (accessModule.equals(targetModule) || (!accessModule.isNamed() && !targetModule.isNamed()))\n+\t\t\t\t) {\n+\t\t\t\t\tif (((PRIVATE & accessMode) == PRIVATE)\n+\t\t\t\t\t\t&& ((targetClass == accessClass) || targetClass.isNestmateOf(accessClass))\n+\t\t\t\t\t) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t} else if (((PACKAGE & accessMode) == PACKAGE) && isSamePackage(targetClass, accessClass)) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t} else if (((MODULE & accessMode) == MODULE)\n+\t\t\t\t\t\t&& (Modifier.isPublic(targetClassModifiers) || Modifier.isProtected(targetClassModifiers))\n+\t\t\t\t\t) {\n+\t\t\t\t\t\treturn;\n+\t\t\t\t\t} else if (((PUBLIC & accessMode) == PUBLIC)\n+\t\t\t\t\t\t&& (Modifier.isPublic(targetClassModifiers) || Modifier.isProtected(targetClassModifiers))", "originalCommit": "fd6f62fa41d798c471298ee9f0b75576294d96c6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODU2MDA1MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/8657#discussion_r388560051", "bodyText": "Fixed.", "author": "ChengJin01", "createdAt": "2020-03-05T20:54:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODUyOTk2NA=="}], "type": "inlineReview"}, {"oid": "2951b122838d308cad558600d5a76b8df0a047ab", "url": "https://github.com/eclipse-openj9/openj9/commit/2951b122838d308cad558600d5a76b8df0a047ab", "message": "Update the Lookup specific code against the JDK14 Spec\n\nThe change is to update the code related to MH.Lookup\nto deal with the change of the full privilege access\nand the new concept called previous lookup class introduced\nin JDK14.\n\nFixes: #8570, Fixes: #8571\n\nSigned-off-by: Cheng Jin <jincheng@ca.ibm.com>", "committedDate": "2020-03-05T20:51:03Z", "type": "forcePushed"}, {"oid": "9d59e822645c3335c4dd726144b3a4a333893cc8", "url": "https://github.com/eclipse-openj9/openj9/commit/9d59e822645c3335c4dd726144b3a4a333893cc8", "message": "Update the Lookup specific code against the JDK14 Spec\n\nThe change is to update the code related to MH.Lookup\nto deal with the change of the full privilege access\nand the new concept called previous lookup class introduced\nin JDK14.\n\nFixes: #8570, Fixes: #8571\n\nSigned-off-by: Cheng Jin <jincheng@ca.ibm.com>", "committedDate": "2020-03-05T21:12:34Z", "type": "commit"}, {"oid": "9d59e822645c3335c4dd726144b3a4a333893cc8", "url": "https://github.com/eclipse-openj9/openj9/commit/9d59e822645c3335c4dd726144b3a4a333893cc8", "message": "Update the Lookup specific code against the JDK14 Spec\n\nThe change is to update the code related to MH.Lookup\nto deal with the change of the full privilege access\nand the new concept called previous lookup class introduced\nin JDK14.\n\nFixes: #8570, Fixes: #8571\n\nSigned-off-by: Cheng Jin <jincheng@ca.ibm.com>", "committedDate": "2020-03-05T21:12:34Z", "type": "forcePushed"}]}