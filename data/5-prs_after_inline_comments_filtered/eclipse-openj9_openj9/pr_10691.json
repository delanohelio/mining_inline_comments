{"pr_number": 10691, "pr_title": "Move MethodType static helpers to new helper Class", "pr_createdAt": "2020-09-24T17:31:05Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10691", "timeline": [{"oid": "9b3c4c377c768caaba2e93be43279701bb6a538b", "url": "https://github.com/eclipse-openj9/openj9/commit/9b3c4c377c768caaba2e93be43279701bb6a538b", "message": "Move MethodType static helpers to new helper Class\n\nstatic methods:\n- vmResolveFromMethodDescriptorString()\n- parseIntoClass()\n- nonPrimitiveClassFromString()\n- getBytecodeStringName()\n- unwrapPrimitive()\n- wrapPrimitive()\n\nstatic fields:\n- primitivesArray\n- WRAPPER_SET\n\nCo-authored-by: Babneet Singh <sbabneet@ca.ibm.com>\nSigned-off-by: Jack Lu <Jack.S.Lu@ibm.com>", "committedDate": "2020-09-24T18:21:44Z", "type": "forcePushed"}, {"oid": "c3517c80b98807713a795c9be67f635d444b7dbb", "url": "https://github.com/eclipse-openj9/openj9/commit/c3517c80b98807713a795c9be67f635d444b7dbb", "message": "Move MethodType static helpers to new helper Class\n\nstatic methods:\n- vmResolveFromMethodDescriptorString()\n- parseIntoClass()\n- nonPrimitiveClassFromString()\n- getBytecodeStringName()\n- unwrapPrimitive()\n- wrapPrimitive()\n\nstatic fields:\n- primitivesArray\n- WRAPPER_SET\n\nCo-authored-by: Babneet Singh <sbabneet@ca.ibm.com>\nSigned-off-by: Jack Lu <Jack.S.Lu@ibm.com>", "committedDate": "2020-10-01T15:34:11Z", "type": "forcePushed"}, {"oid": "8246d30360835322912ee88e824d026b50a66660", "url": "https://github.com/eclipse-openj9/openj9/commit/8246d30360835322912ee88e824d026b50a66660", "message": "remove redundent entry MT.vmResolveFromMethodDescriptorString\n\nCo-authored-by: Babneet Singh <sbabneet@ca.ibm.com>\nSigned-off-by: Jack Lu <Jack.S.Lu@ibm.com>", "committedDate": "2020-10-06T17:31:28Z", "type": "forcePushed"}, {"oid": "5477fb0906f759dabf1e31b419f497aff2170688", "url": "https://github.com/eclipse-openj9/openj9/commit/5477fb0906f759dabf1e31b419f497aff2170688", "message": "remove redundent entry MT.vmResolveFromMethodDescriptorString\n\nCo-authored-by: Babneet Singh <sbabneet@ca.ibm.com>\nSigned-off-by: Jack Lu <Jack.S.Lu@ibm.com>", "committedDate": "2020-10-06T17:36:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyOTcwNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r501329705", "bodyText": "One extra empty line.", "author": "babsingh", "createdAt": "2020-10-07T21:49:19Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodType.java", "diffHunk": "@@ -75,32 +75,11 @@\n /*[ENDIF]*/\n {\n \tstatic final Class<?>[] EMTPY_PARAMS = new Class<?>[0];\n-\tstatic final Set<Class<?>> WRAPPER_SET;\n-\tstatic {\n-\t\tClass<?>[] wrappers = {Byte.class, Character.class, Double.class, Float.class, Integer.class, Long.class, Short.class, Boolean.class };\n-\t\tWRAPPER_SET = Collections.unmodifiableSet(new HashSet<Class<?>>(Arrays.asList(wrappers)));\n-\t}\n \n /*[IF Sidecar19-SE-OpenJ9]*/\t\n \tprivate MethodTypeForm form;\n /*[ENDIF]*/\t\n-\t\n-\t/*[IF ]*/\n-\t/* Do not include 'primitives.put(\"V\", void.class)' as void.class is not yet loaded when\n-\t * MethodType gets loaded and this will cause the VM not to start.  See the code\n-\t * in Class#getPrimitiveClass() for the issue. */\n-\t/*[ENDIF]*/\n-\tstatic final Class<?>[] primitivesArray = new Class<?>[26];\n-\tstatic {\n-\t\tprimitivesArray['B' - 'A'] = byte.class;\n-\t\tprimitivesArray['C' - 'A'] = char.class;\n-\t\tprimitivesArray['D' - 'A'] = double.class;\n-\t\tprimitivesArray['F' - 'A'] = float.class;\n-\t\tprimitivesArray['I' - 'A'] = int.class;\n-\t\tprimitivesArray['J' - 'A'] = long.class;\n-\t\tprimitivesArray['S' - 'A'] = short.class;\n-\t\tprimitivesArray['Z' - 'A'] = boolean.class;\n-\t}\n+\n \t", "originalCommit": "c9ea728638f31bdb3e11d7e90068addd3233991a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMyOTk0OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r501329949", "bodyText": "Two extra empty lines.", "author": "babsingh", "createdAt": "2020-10-07T21:49:52Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodType.java", "diffHunk": "@@ -411,31 +390,7 @@ private static final MethodType fromMethodDescriptorStringAppendArg(String metho\n \t\treturn methodType(returnType, types);\n \t}\n \t\n-\t/**\n-\t * This helper calls MethodType.fromMethodDescriptorString(...) or \n-\t * MethodType.fromMethodDescriptorStringAppendArg(...) but throws \n-\t * NoClassDefFoundError instead of TypeNotPresentException during \n-\t * the VM resolve stage.\n-\t *\n-\t * @param methodDescriptor - the method descriptor string\n-\t * @param loader - the ClassLoader to be used\n-\t * @param appendArgumentType - an extra argument type\n-\t *\n-\t * @return a MethodType object representing the method descriptor string\n-\t *\n-\t * @throws IllegalArgumentException - if the string is not well-formed\n-\t * @throws NoClassDefFoundError - if a named type cannot be found\n-\t */\n-\tstatic final MethodType vmResolveFromMethodDescriptorString(String methodDescriptor, ClassLoader loader, Class<?> appendArgumentType) throws Throwable {\n-\t\ttry {\n-\t\t\tif (null == appendArgumentType) {\n-\t\t\t\treturn MethodType.fromMethodDescriptorString(methodDescriptor, loader);\n-\t\t\t}\n-\t\t\treturn MethodType.fromMethodDescriptorStringAppendArg(methodDescriptor, loader, appendArgumentType);\n-\t\t} catch (TypeNotPresentException e) {\n-\t\t\tthrow throwNoClassDefFoundError(e);\n-\t\t}\n-\t}\n+\n ", "originalCommit": "c9ea728638f31bdb3e11d7e90068addd3233991a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMDQ3Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r501330476", "bodyText": "Is git a typo?", "author": "babsingh", "createdAt": "2020-10-07T21:51:01Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodType.java", "diffHunk": "@@ -1070,133 +959,11 @@ public MethodType appendParameterTypes(List<Class<?>> classes) throws IllegalArg\n \t\tcombinedParameters.addAll(classes);\n \t\treturn methodType(returnType, combinedParameters);\n \t}\n-\t\n-\t/**\n-\t * Returns the appropriate wrapper class or the original class\n-\t * @param primitiveClass The class to convert to a wrapper class\n-\t * @return The wrapper class or the original class if no wrapper is available\n-\t */\n-\tstatic Class<?> wrapPrimitive(Class<?> primitveClass) {\n-\t\tif (primitveClass.isPrimitive()) {\n-\t\t\tif (int.class == primitveClass){ //I\n-\t\t\t\treturn Integer.class;\n-\t\t\t}\n-\t\t\tif (long.class == primitveClass){ //J\n-\t\t\t\treturn Long.class;\n-\t\t\t}\n-\t\t\tif (byte.class == primitveClass){\t//B\n-\t\t\t\treturn Byte.class;\n-\t\t\t}\n-\t\t\tif (char.class == primitveClass){ //C\n-\t\t\t\treturn Character.class;\n-\t\t\t}\n-\t\t\tif (double.class == primitveClass){ //D\n-\t\t\t\treturn Double.class;\n-\t\t\t}\n-\t\t\tif (float.class == primitveClass){ //F\n-\t\t\t\treturn Float.class;\n-\t\t\t}\n-\t\t\tif (boolean.class == primitveClass){ //Z\n-\t\t\t\treturn Boolean.class;\n-\t\t\t}\n-\t\t\tif (void.class == primitveClass) {\n-\t\t\t\treturn Void.class;\n-\t\t\t}\n-\t\t\tif (short.class == primitveClass){ //S\n-\t\t\t\treturn Short.class;\n-\t\t\t}\n-\t\t}\n-\t\treturn primitveClass;\n-\t}\n-\t\n-\t\n-\t/**\n-\t * Takes a class and returns the corresponding primitive if one exists.\n-\t * @param wrapperClass The class to check for primitive classes.\n-\t * @return The corresponding primitive class or the input class.\n-\t */\n-\t/*[IF ]*/\n-\t/* Note that Void.class is not handled by this method as it is only viewed as a\n-\t * wrapper when it is the return class.\n-\t */\n-\t/*[ENDIF]*/\n-\tstatic Class<?> unwrapPrimitive(Class<?> wrapperClass){\n-\t\tif (Integer.class == wrapperClass) { //I\n-\t\t\treturn int.class;\n-\t\t}\n-\t\tif (Long.class == wrapperClass) { //J\n-\t\t\treturn long.class;\n-\t\t}\n-\t\tif (Byte.class == wrapperClass) {\t//B\n-\t\t\treturn byte.class;\n-\t\t}\n-\t\tif (Character.class == wrapperClass) { //C\n-\t\t\treturn char.class;\n-\t\t}\n-\t\tif (Double.class == wrapperClass) { //D\n-\t\t\treturn double.class;\n-\t\t}\n-\t\tif (Float.class == wrapperClass) { //F\n-\t\t\treturn float.class;\n-\t\t}\n-\t\tif (Short.class == wrapperClass) { //S\n-\t\t\treturn short.class;\n-\t\t}\n-\t\tif (Boolean.class == wrapperClass) { //Z\n-\t\t\treturn boolean.class;\n-\t\t}\n-\t\treturn wrapperClass;\n-\t}\n-\t\n-\t/* The string returned by this method should be in sync with Class.descriptorString() */\n-\tstatic String getBytecodeStringName(Class<?> c){\n-\t\tif (c.isPrimitive()) {\n-\t\t\tif (c == int.class) {\n-\t\t\t\treturn \"I\"; //$NON-NLS-1$\n-\t\t\t} else if (c == long.class) {\n-\t\t\t\treturn \"J\"; //$NON-NLS-1$\n-\t\t\t} else if (c == byte.class) {\n-\t\t\t\treturn \"B\"; //$NON-NLS-1$\n-\t\t\t} else if (c == boolean.class) {\n-\t\t\t\treturn \"Z\"; //$NON-NLS-1$\n-\t\t\t} else if (c == void.class) {\n-\t\t\t\treturn \"V\"; //$NON-NLS-1$\n-\t\t\t} else if (c == char.class) {\n-\t\t\t\treturn \"C\"; //$NON-NLS-1$\n-\t\t\t} else if (c == double.class) {\n-\t\t\t\treturn \"D\"; //$NON-NLS-1$\n-\t\t\t} else if (c == float.class) {\n-\t\t\t\treturn \"F\"; //$NON-NLS-1$\n-\t\t\t} else if (c == short.class) {\n-\t\t\t\treturn \"S\"; //$NON-NLS-1$\n-\t\t\t}\n-\t\t}\n-\t\tClass<?> clazz = c;\n-\t\tif (c.isArray()) {\n-\t\t\tclazz = c.getComponentType();\n-\t\t\twhile (clazz.isArray()) {\n-\t\t\t\tclazz = clazz.getComponentType();\n-\t\t\t}\n-\t\t}\n-\t\tString name = c.getName().replace('.', '/');\n-\t\t/*[IF Java15]*/\n-\t\tif (clazz.isHidden()) {\n-\t\t\t/* keep the last \".\" before romaddress for hidden classes */\n-\t\t\tint index = name.lastIndexOf('/');\n-\t\t\tname = name.substring(0, index) + '.' + name.substring(index + 1,name.length());\n-\t\t}\n-\t\t/*[ENDIF] Java15 */\n-\t\t\n-\t\tif (c.isArray()) {\n-\t\t\treturn name;\n-\t\t}\n-\t\treturn \"L\"+ name + \";\"; //$NON-NLS-1$ //$NON-NLS-2$\n-\t}\n-\t\n+\n \t/*\n \t * Implements JSR 292 serialization spec.\n \t * Write the MethodType without writing the field names.\n-\t * Format:\n+\t * Format:git", "originalCommit": "c9ea728638f31bdb3e11d7e90068addd3233991a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTQxNzM2NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r501417365", "bodyText": "yes!", "author": "fengxue-IS", "createdAt": "2020-10-08T02:48:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMDQ3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIzODU5MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r504238591", "bodyText": "typo is still present", "author": "DanHeidinga", "createdAt": "2020-10-13T20:27:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMDQ3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMTAyOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r501331028", "bodyText": "Inconsistent spacing\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\tif (Byte.class == wrapperClass) {\t//B\n          \n          \n            \n            \t\tif (Byte.class == wrapperClass) { //B", "author": "babsingh", "createdAt": "2020-10-07T21:52:10Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodTypeHelper.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*[INCLUDE-IF Sidecar18-SE]*/\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+package java.lang.invoke;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import com.ibm.oti.util.Msg;\n+\n+/**\n+ * MethodTypeHelper - static methods\n+ * \n+ * @since Java 11\n+ */\n+public final class MethodTypeHelper {\n+\tstatic final Set<Class<?>> WRAPPER_SET;\n+\tstatic {\n+\t\tClass<?>[] wrappers = {Byte.class, Character.class, Double.class, Float.class, Integer.class, Long.class, Short.class, Boolean.class };\n+\t\tWRAPPER_SET = Collections.unmodifiableSet(new HashSet<Class<?>>(Arrays.asList(wrappers)));\n+\t}\n+\n+\t/*[IF ]*/\n+\t/* Do not include 'primitives.put(\"V\", void.class)' as void.class is not yet loaded when\n+\t * MethodType gets loaded and this will cause the VM not to start.  See the code\n+\t * in Class#getPrimitiveClass() for the issue. */\n+\t/*[ENDIF]*/\n+\tstatic final Class<?>[] primitivesArray = new Class<?>[26];\n+\tstatic {\n+\t\tprimitivesArray['B' - 'A'] = byte.class;\n+\t\tprimitivesArray['C' - 'A'] = char.class;\n+\t\tprimitivesArray['D' - 'A'] = double.class;\n+\t\tprimitivesArray['F' - 'A'] = float.class;\n+\t\tprimitivesArray['I' - 'A'] = int.class;\n+\t\tprimitivesArray['J' - 'A'] = long.class;\n+\t\tprimitivesArray['S' - 'A'] = short.class;\n+\t\tprimitivesArray['Z' - 'A'] = boolean.class;\n+\t}\n+\n+\t/**\n+\t * Returns the appropriate wrapper class or the original class\n+\t * @param primitiveClass The class to convert to a wrapper class\n+\t * @return The wrapper class or the original class if no wrapper is available\n+\t */\n+\tstatic Class<?> wrapPrimitive(Class<?> primitveClass) {\n+\t\tif (primitveClass.isPrimitive()) {\n+\t\t\tif (int.class == primitveClass){ //I\n+\t\t\t\treturn Integer.class;\n+\t\t\t}\n+\t\t\tif (long.class == primitveClass){ //J\n+\t\t\t\treturn Long.class;\n+\t\t\t}\n+\t\t\tif (byte.class == primitveClass){\t//B\n+\t\t\t\treturn Byte.class;\n+\t\t\t}\n+\t\t\tif (char.class == primitveClass){ //C\n+\t\t\t\treturn Character.class;\n+\t\t\t}\n+\t\t\tif (double.class == primitveClass){ //D\n+\t\t\t\treturn Double.class;\n+\t\t\t}\n+\t\t\tif (float.class == primitveClass){ //F\n+\t\t\t\treturn Float.class;\n+\t\t\t}\n+\t\t\tif (boolean.class == primitveClass){ //Z\n+\t\t\t\treturn Boolean.class;\n+\t\t\t}\n+\t\t\tif (void.class == primitveClass) {\n+\t\t\t\treturn Void.class;\n+\t\t\t}\n+\t\t\tif (short.class == primitveClass){ //S\n+\t\t\t\treturn Short.class;\n+\t\t\t}\n+\t\t}\n+\t\treturn primitveClass;\n+\t}\n+\t\n+\t/**\n+\t * Takes a class and returns the corresponding primitive if one exists.\n+\t * @param wrapperClass The class to check for primitive classes.\n+\t * @return The corresponding primitive class or the input class.\n+\t */\n+\t/*[IF ]*/\n+\t/* Note that Void.class is not handled by this method as it is only viewed as a\n+\t * wrapper when it is the return class.\n+\t */\n+\t/*[ENDIF]*/\n+\tstatic Class<?> unwrapPrimitive(Class<?> wrapperClass){\n+\t\tif (Integer.class == wrapperClass) { //I\n+\t\t\treturn int.class;\n+\t\t}\n+\t\tif (Long.class == wrapperClass) { //J\n+\t\t\treturn long.class;\n+\t\t}\n+\t\tif (Byte.class == wrapperClass) {\t//B", "originalCommit": "c9ea728638f31bdb3e11d7e90068addd3233991a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMTI0Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r501331243", "bodyText": "Inconsistent spacing\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tif (byte.class == primitveClass){\t//B\n          \n          \n            \n            \t\t\tif (byte.class == primitveClass){ //B", "author": "babsingh", "createdAt": "2020-10-07T21:52:37Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodTypeHelper.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*[INCLUDE-IF Sidecar18-SE]*/\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+package java.lang.invoke;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import com.ibm.oti.util.Msg;\n+\n+/**\n+ * MethodTypeHelper - static methods\n+ * \n+ * @since Java 11\n+ */\n+public final class MethodTypeHelper {\n+\tstatic final Set<Class<?>> WRAPPER_SET;\n+\tstatic {\n+\t\tClass<?>[] wrappers = {Byte.class, Character.class, Double.class, Float.class, Integer.class, Long.class, Short.class, Boolean.class };\n+\t\tWRAPPER_SET = Collections.unmodifiableSet(new HashSet<Class<?>>(Arrays.asList(wrappers)));\n+\t}\n+\n+\t/*[IF ]*/\n+\t/* Do not include 'primitives.put(\"V\", void.class)' as void.class is not yet loaded when\n+\t * MethodType gets loaded and this will cause the VM not to start.  See the code\n+\t * in Class#getPrimitiveClass() for the issue. */\n+\t/*[ENDIF]*/\n+\tstatic final Class<?>[] primitivesArray = new Class<?>[26];\n+\tstatic {\n+\t\tprimitivesArray['B' - 'A'] = byte.class;\n+\t\tprimitivesArray['C' - 'A'] = char.class;\n+\t\tprimitivesArray['D' - 'A'] = double.class;\n+\t\tprimitivesArray['F' - 'A'] = float.class;\n+\t\tprimitivesArray['I' - 'A'] = int.class;\n+\t\tprimitivesArray['J' - 'A'] = long.class;\n+\t\tprimitivesArray['S' - 'A'] = short.class;\n+\t\tprimitivesArray['Z' - 'A'] = boolean.class;\n+\t}\n+\n+\t/**\n+\t * Returns the appropriate wrapper class or the original class\n+\t * @param primitiveClass The class to convert to a wrapper class\n+\t * @return The wrapper class or the original class if no wrapper is available\n+\t */\n+\tstatic Class<?> wrapPrimitive(Class<?> primitveClass) {\n+\t\tif (primitveClass.isPrimitive()) {\n+\t\t\tif (int.class == primitveClass){ //I\n+\t\t\t\treturn Integer.class;\n+\t\t\t}\n+\t\t\tif (long.class == primitveClass){ //J\n+\t\t\t\treturn Long.class;\n+\t\t\t}\n+\t\t\tif (byte.class == primitveClass){\t//B", "originalCommit": "c9ea728638f31bdb3e11d7e90068addd3233991a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIzODg0OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r504238848", "bodyText": "still present", "author": "DanHeidinga", "createdAt": "2020-10-13T20:28:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMTI0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMTQ0OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r501331449", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tstatic String getBytecodeStringName(Class<?> c){\n          \n          \n            \n            \tstatic String getBytecodeStringName(Class<?> c) {", "author": "babsingh", "createdAt": "2020-10-07T21:53:06Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodTypeHelper.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*[INCLUDE-IF Sidecar18-SE]*/\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+package java.lang.invoke;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import com.ibm.oti.util.Msg;\n+\n+/**\n+ * MethodTypeHelper - static methods\n+ * \n+ * @since Java 11\n+ */\n+public final class MethodTypeHelper {\n+\tstatic final Set<Class<?>> WRAPPER_SET;\n+\tstatic {\n+\t\tClass<?>[] wrappers = {Byte.class, Character.class, Double.class, Float.class, Integer.class, Long.class, Short.class, Boolean.class };\n+\t\tWRAPPER_SET = Collections.unmodifiableSet(new HashSet<Class<?>>(Arrays.asList(wrappers)));\n+\t}\n+\n+\t/*[IF ]*/\n+\t/* Do not include 'primitives.put(\"V\", void.class)' as void.class is not yet loaded when\n+\t * MethodType gets loaded and this will cause the VM not to start.  See the code\n+\t * in Class#getPrimitiveClass() for the issue. */\n+\t/*[ENDIF]*/\n+\tstatic final Class<?>[] primitivesArray = new Class<?>[26];\n+\tstatic {\n+\t\tprimitivesArray['B' - 'A'] = byte.class;\n+\t\tprimitivesArray['C' - 'A'] = char.class;\n+\t\tprimitivesArray['D' - 'A'] = double.class;\n+\t\tprimitivesArray['F' - 'A'] = float.class;\n+\t\tprimitivesArray['I' - 'A'] = int.class;\n+\t\tprimitivesArray['J' - 'A'] = long.class;\n+\t\tprimitivesArray['S' - 'A'] = short.class;\n+\t\tprimitivesArray['Z' - 'A'] = boolean.class;\n+\t}\n+\n+\t/**\n+\t * Returns the appropriate wrapper class or the original class\n+\t * @param primitiveClass The class to convert to a wrapper class\n+\t * @return The wrapper class or the original class if no wrapper is available\n+\t */\n+\tstatic Class<?> wrapPrimitive(Class<?> primitveClass) {\n+\t\tif (primitveClass.isPrimitive()) {\n+\t\t\tif (int.class == primitveClass){ //I\n+\t\t\t\treturn Integer.class;\n+\t\t\t}\n+\t\t\tif (long.class == primitveClass){ //J\n+\t\t\t\treturn Long.class;\n+\t\t\t}\n+\t\t\tif (byte.class == primitveClass){\t//B\n+\t\t\t\treturn Byte.class;\n+\t\t\t}\n+\t\t\tif (char.class == primitveClass){ //C\n+\t\t\t\treturn Character.class;\n+\t\t\t}\n+\t\t\tif (double.class == primitveClass){ //D\n+\t\t\t\treturn Double.class;\n+\t\t\t}\n+\t\t\tif (float.class == primitveClass){ //F\n+\t\t\t\treturn Float.class;\n+\t\t\t}\n+\t\t\tif (boolean.class == primitveClass){ //Z\n+\t\t\t\treturn Boolean.class;\n+\t\t\t}\n+\t\t\tif (void.class == primitveClass) {\n+\t\t\t\treturn Void.class;\n+\t\t\t}\n+\t\t\tif (short.class == primitveClass){ //S\n+\t\t\t\treturn Short.class;\n+\t\t\t}\n+\t\t}\n+\t\treturn primitveClass;\n+\t}\n+\t\n+\t/**\n+\t * Takes a class and returns the corresponding primitive if one exists.\n+\t * @param wrapperClass The class to check for primitive classes.\n+\t * @return The corresponding primitive class or the input class.\n+\t */\n+\t/*[IF ]*/\n+\t/* Note that Void.class is not handled by this method as it is only viewed as a\n+\t * wrapper when it is the return class.\n+\t */\n+\t/*[ENDIF]*/\n+\tstatic Class<?> unwrapPrimitive(Class<?> wrapperClass){\n+\t\tif (Integer.class == wrapperClass) { //I\n+\t\t\treturn int.class;\n+\t\t}\n+\t\tif (Long.class == wrapperClass) { //J\n+\t\t\treturn long.class;\n+\t\t}\n+\t\tif (Byte.class == wrapperClass) {\t//B\n+\t\t\treturn byte.class;\n+\t\t}\n+\t\tif (Character.class == wrapperClass) { //C\n+\t\t\treturn char.class;\n+\t\t}\n+\t\tif (Double.class == wrapperClass) { //D\n+\t\t\treturn double.class;\n+\t\t}\n+\t\tif (Float.class == wrapperClass) { //F\n+\t\t\treturn float.class;\n+\t\t}\n+\t\tif (Short.class == wrapperClass) { //S\n+\t\t\treturn short.class;\n+\t\t}\n+\t\tif (Boolean.class == wrapperClass) { //Z\n+\t\t\treturn boolean.class;\n+\t\t}\n+\t\treturn wrapperClass;\n+\t}\n+\n+\t/* The string returned by this method should be in sync with Class.descriptorString() */\n+\tstatic String getBytecodeStringName(Class<?> c){", "originalCommit": "c9ea728638f31bdb3e11d7e90068addd3233991a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTMzMTU3NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r501331574", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \tstatic Class<?> unwrapPrimitive(Class<?> wrapperClass){\n          \n          \n            \n            \tstatic Class<?> unwrapPrimitive(Class<?> wrapperClass) {", "author": "babsingh", "createdAt": "2020-10-07T21:53:24Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodTypeHelper.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*[INCLUDE-IF Sidecar18-SE]*/\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+package java.lang.invoke;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import com.ibm.oti.util.Msg;\n+\n+/**\n+ * MethodTypeHelper - static methods\n+ * \n+ * @since Java 11\n+ */\n+public final class MethodTypeHelper {\n+\tstatic final Set<Class<?>> WRAPPER_SET;\n+\tstatic {\n+\t\tClass<?>[] wrappers = {Byte.class, Character.class, Double.class, Float.class, Integer.class, Long.class, Short.class, Boolean.class };\n+\t\tWRAPPER_SET = Collections.unmodifiableSet(new HashSet<Class<?>>(Arrays.asList(wrappers)));\n+\t}\n+\n+\t/*[IF ]*/\n+\t/* Do not include 'primitives.put(\"V\", void.class)' as void.class is not yet loaded when\n+\t * MethodType gets loaded and this will cause the VM not to start.  See the code\n+\t * in Class#getPrimitiveClass() for the issue. */\n+\t/*[ENDIF]*/\n+\tstatic final Class<?>[] primitivesArray = new Class<?>[26];\n+\tstatic {\n+\t\tprimitivesArray['B' - 'A'] = byte.class;\n+\t\tprimitivesArray['C' - 'A'] = char.class;\n+\t\tprimitivesArray['D' - 'A'] = double.class;\n+\t\tprimitivesArray['F' - 'A'] = float.class;\n+\t\tprimitivesArray['I' - 'A'] = int.class;\n+\t\tprimitivesArray['J' - 'A'] = long.class;\n+\t\tprimitivesArray['S' - 'A'] = short.class;\n+\t\tprimitivesArray['Z' - 'A'] = boolean.class;\n+\t}\n+\n+\t/**\n+\t * Returns the appropriate wrapper class or the original class\n+\t * @param primitiveClass The class to convert to a wrapper class\n+\t * @return The wrapper class or the original class if no wrapper is available\n+\t */\n+\tstatic Class<?> wrapPrimitive(Class<?> primitveClass) {\n+\t\tif (primitveClass.isPrimitive()) {\n+\t\t\tif (int.class == primitveClass){ //I\n+\t\t\t\treturn Integer.class;\n+\t\t\t}\n+\t\t\tif (long.class == primitveClass){ //J\n+\t\t\t\treturn Long.class;\n+\t\t\t}\n+\t\t\tif (byte.class == primitveClass){\t//B\n+\t\t\t\treturn Byte.class;\n+\t\t\t}\n+\t\t\tif (char.class == primitveClass){ //C\n+\t\t\t\treturn Character.class;\n+\t\t\t}\n+\t\t\tif (double.class == primitveClass){ //D\n+\t\t\t\treturn Double.class;\n+\t\t\t}\n+\t\t\tif (float.class == primitveClass){ //F\n+\t\t\t\treturn Float.class;\n+\t\t\t}\n+\t\t\tif (boolean.class == primitveClass){ //Z\n+\t\t\t\treturn Boolean.class;\n+\t\t\t}\n+\t\t\tif (void.class == primitveClass) {\n+\t\t\t\treturn Void.class;\n+\t\t\t}\n+\t\t\tif (short.class == primitveClass){ //S\n+\t\t\t\treturn Short.class;\n+\t\t\t}\n+\t\t}\n+\t\treturn primitveClass;\n+\t}\n+\t\n+\t/**\n+\t * Takes a class and returns the corresponding primitive if one exists.\n+\t * @param wrapperClass The class to check for primitive classes.\n+\t * @return The corresponding primitive class or the input class.\n+\t */\n+\t/*[IF ]*/\n+\t/* Note that Void.class is not handled by this method as it is only viewed as a\n+\t * wrapper when it is the return class.\n+\t */\n+\t/*[ENDIF]*/\n+\tstatic Class<?> unwrapPrimitive(Class<?> wrapperClass){", "originalCommit": "c9ea728638f31bdb3e11d7e90068addd3233991a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "56326b1ea40bd9d3f9aaa46a8a60daeccfdbabfc", "url": "https://github.com/eclipse-openj9/openj9/commit/56326b1ea40bd9d3f9aaa46a8a60daeccfdbabfc", "message": "Correct vmconstantpool MethodType references\n\n- set correct flag for MethodTypeHelper classref\n- remove redundent entry MT.vmResolveFromMethodDescriptorString\n\nCo-authored-by: Babneet Singh <sbabneet@ca.ibm.com>\nSigned-off-by: Jack Lu <Jack.S.Lu@ibm.com>", "committedDate": "2020-10-08T02:46:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcxNjA1OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r501716059", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            public final class MethodTypeHelper {\n          \n          \n            \n            final class MethodTypeHelper {\n          \n      \n    \n    \n  \n\nThis can't be a public class in the java.* package.", "author": "DanHeidinga", "createdAt": "2020-10-08T13:22:39Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodTypeHelper.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*[INCLUDE-IF Sidecar18-SE]*/\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+package java.lang.invoke;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import com.ibm.oti.util.Msg;\n+\n+/**\n+ * MethodTypeHelper - static methods\n+ * \n+ * @since Java 11\n+ */\n+public final class MethodTypeHelper {", "originalCommit": "56326b1ea40bd9d3f9aaa46a8a60daeccfdbabfc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDIzMjUzMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10691#discussion_r504232532", "bodyText": "fixed", "author": "fengxue-IS", "createdAt": "2020-10-13T20:19:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTcxNjA1OQ=="}], "type": "inlineReview"}, {"oid": "78a0a87e0a3adce1e387bc9e6439ed28e1cfe480", "url": "https://github.com/eclipse-openj9/openj9/commit/78a0a87e0a3adce1e387bc9e6439ed28e1cfe480", "message": "remove redundent entry MT.vmResolveFromMethodDescriptorString\n\nCo-authored-by: Babneet Singh <sbabneet@ca.ibm.com>\nSigned-off-by: Jack Lu <Jack.S.Lu@ibm.com>", "committedDate": "2020-10-13T20:18:23Z", "type": "forcePushed"}, {"oid": "93b4fe28f9648d4394c4c02d0cb19605bc719d74", "url": "https://github.com/eclipse-openj9/openj9/commit/93b4fe28f9648d4394c4c02d0cb19605bc719d74", "message": "remove redundent entry MT.vmResolveFromMethodDescriptorString\n\nCo-authored-by: Babneet Singh <sbabneet@ca.ibm.com>\nSigned-off-by: Jack Lu <Jack.S.Lu@ibm.com>", "committedDate": "2020-10-13T20:47:04Z", "type": "forcePushed"}, {"oid": "a82af634f8e31d820cf5b2a00b9edda1b5f0902b", "url": "https://github.com/eclipse-openj9/openj9/commit/a82af634f8e31d820cf5b2a00b9edda1b5f0902b", "message": "Move MethodType static helpers to new helper Class\n\nstatic methods:\n- vmResolveFromMethodDescriptorString()\n- parseIntoClass()\n- nonPrimitiveClassFromString()\n- getBytecodeStringName()\n- unwrapPrimitive()\n- wrapPrimitive()\n\nstatic fields:\n- primitivesArray\n- WRAPPER_SET\n\nCo-authored-by: Babneet Singh <sbabneet@ca.ibm.com>\nSigned-off-by: Jack Lu <Jack.S.Lu@ibm.com>", "committedDate": "2020-10-13T20:50:15Z", "type": "commit"}, {"oid": "7b1b663336a5dacfb3cf493b58b50347e866ef68", "url": "https://github.com/eclipse-openj9/openj9/commit/7b1b663336a5dacfb3cf493b58b50347e866ef68", "message": "remove redundent entry MT.vmResolveFromMethodDescriptorString\n\nCo-authored-by: Babneet Singh <sbabneet@ca.ibm.com>\nSigned-off-by: Jack Lu <Jack.S.Lu@ibm.com>", "committedDate": "2020-10-13T20:50:21Z", "type": "commit"}, {"oid": "7b1b663336a5dacfb3cf493b58b50347e866ef68", "url": "https://github.com/eclipse-openj9/openj9/commit/7b1b663336a5dacfb3cf493b58b50347e866ef68", "message": "remove redundent entry MT.vmResolveFromMethodDescriptorString\n\nCo-authored-by: Babneet Singh <sbabneet@ca.ibm.com>\nSigned-off-by: Jack Lu <Jack.S.Lu@ibm.com>", "committedDate": "2020-10-13T20:50:21Z", "type": "forcePushed"}]}