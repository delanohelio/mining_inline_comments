{"pr_number": 9811, "pr_title": "Minimize contention between \"finders\" using SCC JCL helper", "pr_createdAt": "2020-06-05T15:27:54Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/9811", "timeline": [{"oid": "46efbacf5e5d8e43a994d6ec92ef6b60c3e53e3d", "url": "https://github.com/eclipse-openj9/openj9/commit/46efbacf5e5d8e43a994d6ec92ef6b60c3e53e3d", "message": "Minimize contention between \"finders\" using SCC JCL helper.\n\nThere are 2 issues with findSharedClass() in SCC Helpers being\nsynchronized:\n\nA. For classLoader with isParallelCapable = true, the parallel \nclass loading capability is lost.\nB. In the case that there are multiple custom Classloaders setting \nthe app ClassLoader as the parent, they all delegate to the app\nClassLoader first when finding classes. So all of them need to go \nthrough the synchronized method appClassloader.findSharedClass() \none by one, which becomes a bottleneck.\n\nThe changes here are:\n1. Change findSharedClass() as well as storeSharedClass() to be\nnon-synchronized.\n\n2. Use a readWriteLock in SharedClassURLClasspathHelperImpl \ninstead.\n\n3. Do not enter classTableMutex and class segmentMutex in the \nnative implementation of findSharedClass() in shared.c, as\nentering these mutexes is essentially making findSharedClass()\nsynchronized in the native level.\n\n4. Enter class segmentMutex only when necessary in \nhookFindSharedClass() and cacheMap::findROMClass().\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>", "committedDate": "2020-06-05T15:30:53Z", "type": "forcePushed"}, {"oid": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d", "url": "https://github.com/eclipse-openj9/openj9/commit/1b70681c95131a2d4c73bc2d203ff2cd8436e53d", "message": "Minimize contention between \"finders\" using SCC JCL helper\n\nThere are 2 issues with findSharedClass() in SCC Helpers being\nsynchronized:\n\nA. For classLoader with isParallelCapable = true, the parallel \nclass loading capability is lost.\nB. In the case that there are multiple custom Classloaders setting \nthe app ClassLoader as the parent, they all delegate to the app\nClassLoader first when finding classes. So all of them need to go \nthrough the synchronized method appClassloader.findSharedClass() \none by one, which becomes a bottleneck.\n\nThe changes here are:\n1. Change findSharedClass() as well as storeSharedClass() to be\nnon-synchronized.\n\n2. Use a readWriteLock in SharedClassURLClasspathHelperImpl \ninstead.\n\n3. Do not enter classTableMutex and class segmentMutex in the \nnative implementation of findSharedClass() in shared.c, as\nentering these mutexes is essentially making findSharedClass()\nsynchronized in the native level.\n\n4. Enter class segmentMutex only when necessary in \nhookFindSharedClass() and cacheMap::findROMClass().\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>", "committedDate": "2020-06-05T16:10:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyNDEwNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436124104", "bodyText": "This needs to move back before if (confirmedCount <= foundAtIndex)", "author": "pshipton", "createdAt": "2020-06-05T19:34:50Z", "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -166,53 +175,62 @@ public synchronized boolean storeSharedClass(String partition, Class<?> clazz, i\n \t\t\tprintVerboseError(Msg.getString(\"K05a3\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (urlCount==0) {\n-\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n+\t\t\n \t\tif (foundAtIndex<0) {\n \t\t\t/*[MSG \"K05a7\", \"foundAtIndex cannot be <0 for storeSharedClass. Returning false.\"]*/\n \t\t\tprintVerboseError(Msg.getString(\"K05a7\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (foundAtIndex>=urlCount) {\n-\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (invalidURLExists) {\n-\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n-\t\t\t * shared class cache and is considered invalid.\n-\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n-\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n-\t\t\t * since it is bound to fail when creating classpath entries.\n-\t\t\t */\t\t\t\n-\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (!validated[foundAtIndex]) {\n-\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n-\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tvalidated[foundAtIndex]=true;\n-\t\t}\n \t\tClassLoader actualLoader = getClassLoader();\n \t\tif (!validateClassLoader(actualLoader, clazz)) {\n \t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n \t\t\treturn false;\n \t\t}\n-\t\tif (confirmedCount <= foundAtIndex) {\n-\t\t\tconfirmedCount = foundAtIndex+1;\n-\t\t\t/*[MSG \"K05aa\", \"Number of confirmed entries is now {0}\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05aa\", confirmedCount)); //$NON-NLS-1$\n-\t\t}\n-\t\treturn storeSharedClassImpl2(this.id, partition, actualLoader, this.urls, this.urlCount, foundAtIndex, clazz, nativeFlags);\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tif (urlCount==0) {\n+\t\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (foundAtIndex>=urlCount) {\n+\t\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (invalidURLExists) {\n+\t\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n+\t\t\t\t * shared class cache and is considered invalid.\n+\t\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n+\t\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n+\t\t\t\t * since it is bound to fail when creating classpath entries.\n+\t\t\t\t */\t\t\t\n+\t\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (confirmedCount <= foundAtIndex) {\n+\t\t\t\tconfirmedCount = foundAtIndex+1;\n+\t\t\t\t/*[MSG \"K05aa\", \"Number of confirmed entries is now {0}\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05aa\", confirmedCount)); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\tif (!validated[foundAtIndex]) {", "originalCommit": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk2MDkyNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436960927", "bodyText": "Fixed.", "author": "hangshao0", "createdAt": "2020-06-08T19:50:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEyNDEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNjY3Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436136673", "bodyText": "readLock() should be sufficient.", "author": "pshipton", "createdAt": "2020-06-05T19:57:55Z", "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -228,137 +246,160 @@ private synchronized void growURLs(int toMinSize) {\n \t}\n \n \t@Override\n-\tpublic synchronized void addClasspathEntry(URL cpe) {\n+\tpublic void addClasspathEntry(URL cpe) {\n \t\tClassLoader loader = getClassLoader();\n \t\tif (loader != null) {\n \t\t\tif (cpe==null) {\n \t\t\t\t/*[MSG \"K05ac\", \"URL is null for addClasspathEntry.\"]*/\n \t\t\t\tprintVerboseError(Msg.getString(\"K05ac\")); //$NON-NLS-1$\n \t\t\t\treturn;\n \t\t\t}\n-\t\t\t/* If array is not big enough, grow it */\n-\t\t\tif (urls.length < (urlCount+1)) {\n-\t\t\t\tgrowURLs(urlCount+1);\n-\t\t\t}\n-\t\t\torigurls[urlCount] = cpe;\n-\t\t\turls[urlCount] = convertJarURL(cpe);\n-\t\t\tif (!validateURL(urls[urlCount], false)) {\n-\t\t\t\tinvalidURLExists = true;\n+\t\t\tURL convertedurl = convertJarURL(cpe);\n+\t\t\tboolean invalidUrl = false;\n+\t\t\tif (!validateURL(convertedurl, false)) {\n+\t\t\t\tinvalidUrl = true;\n \t\t\t}\n-\t\t\tnotifyClasspathChange2(loader);\n-\t\t\tif (!invalidURLExists) {\n-\t\t\t\tnotifyClasspathChange3(id, loader, urls, urlCount, (urlCount + 1), true);\n+\t\t\turlcpReadWriteLock.writeLock().lock();\n+\t\t\ttry {\n+\t\t\t\t/* If array is not big enough, grow it */\n+\t\t\t\tif (urls.length < (urlCount+1)) {\n+\t\t\t\t\tgrowURLs(urlCount+1);\n+\t\t\t\t}\n+\t\t\t\torigurls[urlCount] = cpe;\n+\t\t\t\turls[urlCount] = convertedurl;\n+\t\t\t\tinvalidURLExists = invalidUrl;\n+\t\t\t\tnotifyClasspathChange2(loader);\n+\t\t\t\tif (!invalidURLExists) {\n+\t\t\t\t\tnotifyClasspathChange3(id, loader, urls, urlCount, (urlCount + 1), true);\n+\t\t\t\t}\n+\t\t\t\t++urlCount;\n+\t\t\t} finally {\n+\t\t\t\turlcpReadWriteLock.writeLock().unlock();\n \t\t\t}\n-\t\t\t++urlCount;\n \t\t}\n \t}\n \n \t/* Function required by the factory */\n-\tsynchronized URL[] getClasspath() {\n+\tURL[] getClasspath() {\n \t\tURL[] correctLengthArray = new URL[urlCount];\n-\t\tSystem.arraycopy(origurls, 0, correctLengthArray, 0, urlCount);\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tSystem.arraycopy(origurls, 0, correctLengthArray, 0, urlCount);\n+\t\t} finally {\n+\t\t\turlcpReadWriteLock.readLock().unlock();\n+\t\t}\n \t\treturn correctLengthArray;\n \t}\n \n \t@Override\n-\tpublic synchronized void confirmAllEntries() {\n-\t\tconfirmedCount = urlCount;\n+\tpublic void confirmAllEntries() {\n+\t\turlcpReadWriteLock.writeLock().lock();", "originalCommit": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3MDk1Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436170952", "bodyText": "Field confirmedCount is updated by this function. readLock() only is fine ?", "author": "hangshao0", "createdAt": "2020-06-05T21:24:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNjY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3NjQ0MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436176440", "bodyText": "I think so. urlCount is only modified with the writeLock(), so all readers will just get the same value.", "author": "pshipton", "createdAt": "2020-06-05T21:40:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNjY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3ODI5Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436178296", "bodyText": "Note that storeSharedClass() is also modifying confirmedCount using the readLock().", "author": "pshipton", "createdAt": "2020-06-05T21:46:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNjY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE5NTQ1OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436195458", "bodyText": "Actually this does seems problematic, I think confirmAllEntries() should stay as it is, and storeSharedClass() needs a fix.", "author": "pshipton", "createdAt": "2020-06-05T22:41:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNjY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk1OTU0Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436959542", "bodyText": "Added a new function increaseConfirmedCount() that increases confirmedCount inside writeLock().", "author": "hangshao0", "createdAt": "2020-06-08T19:47:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzNjY3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTc1NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436139755", "bodyText": "newJarFileCheck() needs internal synchronization. Also the SharedClassFilter doesn't mention synchronization, but removing synchronized changes the behavior for calling acceptFind() and acceptStore(), these calls should remain protected.", "author": "pshipton", "createdAt": "2020-06-05T20:05:26Z", "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLHelperImpl.java", "diffHunk": "@@ -103,7 +103,7 @@ public boolean setMinimizeUpdateChecks() {\n \t}\n \n \t@Override\n-\tpublic synchronized byte[] findSharedClass(String partition, URL path, String className) {\n+\tpublic byte[] findSharedClass(String partition, URL path, String className) {", "originalCommit": "1b70681c95131a2d4c73bc2d203ff2cd8436e53d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE2NTMwNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436165307", "bodyText": "Also the SharedClassFilter doesn't mention synchronization, but removing synchronized changes the behavior for calling acceptFind() and acceptStore(), these calls should remain protected.\n\nYou mean removing synchronized from getSharingFilter()/setSharingFilter(), then protect the calls of getSharingFilter(), setSharingFilter(), acceptFind() and acceptStore() within readWriteLock ?", "author": "hangshao0", "createdAt": "2020-06-05T21:09:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTc1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3NDU0MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436174541", "bodyText": "newJarFileCheck() needs internal synchronization.\n\nI am thinking about changing jarFileNameCache from a regular Set to ConcurrentHashMap.newKeySet().", "author": "hangshao0", "createdAt": "2020-06-05T21:35:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTc1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3NDkyMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436174923", "bodyText": "It doesn't need to use the readWriteLock(), but something should keep the synchronized behavior of calling acceptFind() and acceptStore() the same. Similarly, getSharingFilter()/setSharingFilter() are fine the way they are since they are already synchronized.", "author": "pshipton", "createdAt": "2020-06-05T21:36:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTc1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjE3NzAwMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436177001", "bodyText": "I am thinking about changing jarFileNameCache from a regular Set to ConcurrentHashMap.newKeySet()\n\nAs long as it doesn't cause a measurable increase in footprint.", "author": "pshipton", "createdAt": "2020-06-05T21:42:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTc1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk2MDM4MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436960381", "bodyText": "Changed jarFileNameCache to a concurrent Set and wrap acceptFind()/acceptStore() inside a synchronized block.", "author": "hangshao0", "createdAt": "2020-06-08T19:49:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjEzOTc1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk3NjcyNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436976726", "bodyText": "Better to keep the old behavior and synchronize on the instance of SharedClassURLHelperImpl than to start synchronizing on the user supplied object, which could have unexpected side effects. Or best is to synchronize on an internal Object.", "author": "pshipton", "createdAt": "2020-06-08T20:21:07Z", "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLHelperImpl.java", "diffHunk": "@@ -126,12 +125,14 @@ public boolean setMinimizeUpdateChecks() {\n \t\tSharedClassFilter theFilter = getSharingFilter();\n \t\tboolean doFind, doStore;\n \t\tif (theFilter!=null) {\n-\t\t\tdoFind = theFilter.acceptFind(className);\n-\t\t\t/* Don't invoke the store filter if the cache is full */\n-\t\t\tif (nativeFlags[CACHE_FULL_FLAG] == 0) {\n-\t\t\t\tdoStore = theFilter.acceptStore(className);\n-\t\t\t} else {\n-\t\t\t\tdoStore = true;\n+\t\t\tsynchronized(theFilter) {", "originalCommit": "7849dead8a04a198c372dc35dcfc218aa5db8cd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk3OTMwOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436979308", "bodyText": "Note the same synchronization changes are also needed in SharedClassURLClasspathHelperImpl and SharedClassTokenHelperImpl.", "author": "pshipton", "createdAt": "2020-06-08T20:26:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk3NjcyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwNzIwOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r437007209", "bodyText": "I didn't find proper internal obj to sync in SharedClassURLHelperImpl and SharedClassTokenHelperImpl, so I am synchronizing on this.", "author": "hangshao0", "createdAt": "2020-06-08T21:18:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk3NjcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4MzYzOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r436983638", "bodyText": "This is another writer.", "author": "pshipton", "createdAt": "2020-06-08T20:33:21Z", "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -166,53 +175,66 @@ public synchronized boolean storeSharedClass(String partition, Class<?> clazz, i\n \t\t\tprintVerboseError(Msg.getString(\"K05a3\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (urlCount==0) {\n-\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n+\t\t\n \t\tif (foundAtIndex<0) {\n \t\t\t/*[MSG \"K05a7\", \"foundAtIndex cannot be <0 for storeSharedClass. Returning false.\"]*/\n \t\t\tprintVerboseError(Msg.getString(\"K05a7\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (foundAtIndex>=urlCount) {\n-\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (invalidURLExists) {\n-\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n-\t\t\t * shared class cache and is considered invalid.\n-\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n-\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n-\t\t\t * since it is bound to fail when creating classpath entries.\n-\t\t\t */\t\t\t\n-\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (!validated[foundAtIndex]) {\n-\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n-\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tvalidated[foundAtIndex]=true;\n-\t\t}\n \t\tClassLoader actualLoader = getClassLoader();\n \t\tif (!validateClassLoader(actualLoader, clazz)) {\n \t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n \t\t\treturn false;\n \t\t}\n-\t\tif (confirmedCount <= foundAtIndex) {\n-\t\t\tconfirmedCount = foundAtIndex+1;\n-\t\t\t/*[MSG \"K05aa\", \"Number of confirmed entries is now {0}\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05aa\", confirmedCount)); //$NON-NLS-1$\n+\t\tboolean storeRet = false;\n+\t\tboolean incConfirmedCount = false;\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tif (urlCount==0) {\n+\t\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (foundAtIndex>=urlCount) {\n+\t\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (invalidURLExists) {\n+\t\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n+\t\t\t\t * shared class cache and is considered invalid.\n+\t\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n+\t\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n+\t\t\t\t * since it is bound to fail when creating classpath entries.\n+\t\t\t\t */\t\t\t\n+\t\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (!validated[foundAtIndex]) {\n+\t\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n+\t\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tvalidated[foundAtIndex]=true;", "originalCommit": "7849dead8a04a198c372dc35dcfc218aa5db8cd0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwMzQ3NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r437003475", "bodyText": "Fixed.", "author": "hangshao0", "createdAt": "2020-06-08T21:11:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjk4MzYzOA=="}], "type": "inlineReview"}, {"oid": "cf41616c6fd61ef9d10289c8261bcfda7f53c33f", "url": "https://github.com/eclipse-openj9/openj9/commit/cf41616c6fd61ef9d10289c8261bcfda7f53c33f", "message": "Minimize contention between \"finders\" using SCC JCL helper\n\n1. Delete obsolete comments on functions requiring class segment\nmutex.\n2. Wrap getBootstrapClasspathItem() inside class segment mutex.\n3. Add a new API to increase\nSharedClassURLClasspathHelperImpl.confirmedCount.\n4. Change SharedClassURLHelperImpl.jarFileNameCache from a regular \nSet to a concurrent Set.\n5. Wrap acceptFind() and acceptStore() in a synchronized block.\n6. Do not need to wrap callFindLocallyDefinedClass() inside class\nsegment mutex.\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>", "committedDate": "2020-06-08T21:08:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwOTQzOA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r437009438", "bodyText": "Might as well combine updating validated and confirmedCount to use a single writeLock().lock().", "author": "pshipton", "createdAt": "2020-06-08T21:23:15Z", "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -166,53 +177,70 @@ public synchronized boolean storeSharedClass(String partition, Class<?> clazz, i\n \t\t\tprintVerboseError(Msg.getString(\"K05a3\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (urlCount==0) {\n-\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n+\t\t\n \t\tif (foundAtIndex<0) {\n \t\t\t/*[MSG \"K05a7\", \"foundAtIndex cannot be <0 for storeSharedClass. Returning false.\"]*/\n \t\t\tprintVerboseError(Msg.getString(\"K05a7\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (foundAtIndex>=urlCount) {\n-\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (invalidURLExists) {\n-\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n-\t\t\t * shared class cache and is considered invalid.\n-\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n-\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n-\t\t\t * since it is bound to fail when creating classpath entries.\n-\t\t\t */\t\t\t\n-\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\tClassLoader actualLoader = getClassLoader();\n+\t\tif (!validateClassLoader(actualLoader, clazz)) {\n+\t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n \t\t\treturn false;\n \t\t}\n-\t\tif (!validated[foundAtIndex]) {\n-\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n-\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n+\t\tboolean storeRet = false;\n+\t\tboolean incConfirmedCount = false;\n+\t\tboolean urlValidated = false;\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tif (urlCount==0) {\n+\t\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n \t\t\t\treturn false;\n \t\t\t}\n-\t\t\tvalidated[foundAtIndex]=true;\n+\t\t\tif (foundAtIndex>=urlCount) {\n+\t\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (invalidURLExists) {\n+\t\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n+\t\t\t\t * shared class cache and is considered invalid.\n+\t\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n+\t\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n+\t\t\t\t * since it is bound to fail when creating classpath entries.\n+\t\t\t\t */\t\t\t\n+\t\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (!validated[foundAtIndex]) {\n+\t\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n+\t\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t} \n+\t\t\t\turlValidated = true;\n+\t\t\t}\n+\t\t\tif (confirmedCount <= foundAtIndex) {\n+\t\t\t\tincConfirmedCount = true;\n+\t\t\t}\n+\t\t\tstoreRet = storeSharedClassImpl2(this.id, partition, actualLoader, this.urls, this.urlCount, foundAtIndex, clazz, nativeFlags);\n+\t\t} finally {\n+\t\t\turlcpReadWriteLock.readLock().unlock();\n \t\t}\n-\t\tClassLoader actualLoader = getClassLoader();\n-\t\tif (!validateClassLoader(actualLoader, clazz)) {\n-\t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n-\t\t\treturn false;\n+\t\tif (urlValidated) {", "originalCommit": "cf41616c6fd61ef9d10289c8261bcfda7f53c33f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAxMzc0Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r437013743", "bodyText": "I added setValidatedAtIndex(), but I am wondering if we really need that. I guess the previous code that sets validated[foundAtIndex]=true; inside readLock should be fine, we just may have multiple threads setting it to true, which won't have any negative impact.", "author": "hangshao0", "createdAt": "2020-06-08T21:32:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwOTQzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyMzAxMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r437023011", "bodyText": "I'm ok with that.", "author": "pshipton", "createdAt": "2020-06-08T21:54:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwOTQzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAyNTgwMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r437025802", "bodyText": "setValidatedAtIndex() removed.", "author": "hangshao0", "createdAt": "2020-06-08T22:01:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzAwOTQzOA=="}], "type": "inlineReview"}, {"oid": "2446d4de57f5c06cfc09bff1620630a893755df9", "url": "https://github.com/eclipse-openj9/openj9/commit/2446d4de57f5c06cfc09bff1620630a893755df9", "message": "Minimize contention between \"finders\" using SCC JCL helper\n\n1. Delete obsolete comments on functions requiring class segment\nmutex.\n2. Wrap getBootstrapClasspathItem() inside class segment mutex.\n3. Add a new API to increase\nSharedClassURLClasspathHelperImpl.confirmedCount.\n4. Change SharedClassURLHelperImpl.jarFileNameCache from a regular \nSet to a concurrent Set.\n5. Wrap acceptFind() and acceptStore() in a synchronized block.\n6. Do not need to wrap callFindLocallyDefinedClass() inside class\nsegment mutex.\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>", "committedDate": "2020-06-08T21:59:03Z", "type": "forcePushed"}, {"oid": "b37b5ef92cf08713207384362e796f99a46aa5bd", "url": "https://github.com/eclipse-openj9/openj9/commit/b37b5ef92cf08713207384362e796f99a46aa5bd", "message": "_identifiedClasspaths should be used inside _identifiedMutex\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>", "committedDate": "2020-06-10T21:01:29Z", "type": "forcePushed"}, {"oid": "979d5b7c97340f72db2d679e287235a889eb808b", "url": "https://github.com/eclipse-openj9/openj9/commit/979d5b7c97340f72db2d679e287235a889eb808b", "message": "_identifiedClasspaths should be used inside _identifiedMutex\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>", "committedDate": "2020-06-11T16:08:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNTEzMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438935133", "bodyText": "Pls use ! instead of false ==", "author": "pshipton", "createdAt": "2020-06-11T17:00:11Z", "path": "jcl/src/openj9.sharedclasses/share/classes/com/ibm/oti/shared/SharedClassURLClasspathHelperImpl.java", "diffHunk": "@@ -166,53 +177,66 @@ public synchronized boolean storeSharedClass(String partition, Class<?> clazz, i\n \t\t\tprintVerboseError(Msg.getString(\"K05a3\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (urlCount==0) {\n-\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n+\t\t\n \t\tif (foundAtIndex<0) {\n \t\t\t/*[MSG \"K05a7\", \"foundAtIndex cannot be <0 for storeSharedClass. Returning false.\"]*/\n \t\t\tprintVerboseError(Msg.getString(\"K05a7\")); //$NON-NLS-1$\n \t\t\treturn false;\n \t\t}\n-\t\tif (foundAtIndex>=urlCount) {\n-\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n-\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (invalidURLExists) {\n-\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n-\t\t\t * shared class cache and is considered invalid.\n-\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n-\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n-\t\t\t * since it is bound to fail when creating classpath entries.\n-\t\t\t */\t\t\t\n-\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n-\t\t\treturn false;\n-\t\t}\n-\t\tif (!validated[foundAtIndex]) {\n-\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n-\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n-\t\t\t\treturn false;\n-\t\t\t}\n-\t\t\tvalidated[foundAtIndex]=true;\n-\t\t}\n \t\tClassLoader actualLoader = getClassLoader();\n \t\tif (!validateClassLoader(actualLoader, clazz)) {\n \t\t\t/* Attempt to call storeSharedClass with class defined by a different classloader */\n \t\t\treturn false;\n \t\t}\n-\t\tif (confirmedCount <= foundAtIndex) {\n-\t\t\tconfirmedCount = foundAtIndex+1;\n-\t\t\t/*[MSG \"K05aa\", \"Number of confirmed entries is now {0}\"]*/\n-\t\t\tprintVerboseInfo(Msg.getString(\"K05aa\", confirmedCount)); //$NON-NLS-1$\n+\t\tboolean storeRet = false;\n+\t\tboolean incConfirmedCount = false;\n+\t\turlcpReadWriteLock.readLock().lock();\n+\t\ttry {\n+\t\t\tif (urlCount==0) {\n+\t\t\t\t/*[MSG \"K05a6\", \"Classpath has zero elements. Cannot call storeSharedClass without classpath. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a6\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (foundAtIndex>=urlCount) {\n+\t\t\t\t/*[MSG \"K05a8\", \"foundAtIndex cannot be >= urls in classpath for storeSharedClass. Returning false.\"]*/\n+\t\t\t\tprintVerboseError(Msg.getString(\"K05a8\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (invalidURLExists) {\n+\t\t\t\t/* Any URL which has its protocol other than 'jar:' or 'file:' is not supported by\n+\t\t\t\t * shared class cache and is considered invalid.\n+\t\t\t\t * invalidURLExists = true indicates classpath contains an invalid URL,\n+\t\t\t\t * As such there is no point in calling native method storeSharedClassImpl2() \n+\t\t\t\t * since it is bound to fail when creating classpath entries.\n+\t\t\t\t */\t\t\t\n+\t\t\t\t/*[MSG \"K05a9\", \"Classpath contains an invalid URL. Returning false.\"]*/\n+\t\t\t\tprintVerboseInfo(Msg.getString(\"K05a9\")); //$NON-NLS-1$\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (!validated[foundAtIndex]) {\n+\t\t\t\t/* Because we only check each element once, we can afford to also check whether the URL exists */\n+\t\t\t\tif (!validateURL(urls[foundAtIndex], true)) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t\tvalidated[foundAtIndex]=true;\n+\t\t\t}\n+\t\t\tif (confirmedCount <= foundAtIndex) {\n+\t\t\t\tincConfirmedCount = true;\n+\t\t\t}\n+\t\t\tstoreRet = storeSharedClassImpl2(this.id, partition, actualLoader, this.urls, this.urlCount, foundAtIndex, clazz, nativeFlags);\n+\t\t} finally {\n+\t\t\turlcpReadWriteLock.readLock().unlock();\n+\t\t}\n+\t\tif (incConfirmedCount) {\n+\t\t\tincreaseConfirmedCount(foundAtIndex + 1);\n \t\t}\n-\t\treturn storeSharedClassImpl2(this.id, partition, actualLoader, this.urls, this.urlCount, foundAtIndex, clazz, nativeFlags);\n+\t\treturn storeRet;\n \t}\n \n-\tprivate synchronized void growURLs(int toMinSize) {\n+\tprivate void growURLs(int toMinSize) {\n+\t\tif (false == urlcpReadWriteLock.writeLock().isHeldByCurrentThread()) {", "originalCommit": "979d5b7c97340f72db2d679e287235a889eb808b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODk5ODMzNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/9811#discussion_r438998334", "bodyText": "Fixed.", "author": "hangshao0", "createdAt": "2020-06-11T18:47:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODkzNTEzMw=="}], "type": "inlineReview"}, {"oid": "d33af83f4ae4240ff1b32b87b4632a4b5501c501", "url": "https://github.com/eclipse-openj9/openj9/commit/d33af83f4ae4240ff1b32b87b4632a4b5501c501", "message": "_identifiedClasspaths should be used inside _identifiedMutex\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>", "committedDate": "2020-06-11T18:46:03Z", "type": "forcePushed"}, {"oid": "77b14cc5395285f662f8394988726fbb3cf1be4f", "url": "https://github.com/eclipse-openj9/openj9/commit/77b14cc5395285f662f8394988726fbb3cf1be4f", "message": "Minimize contention between \"finders\" using SCC JCL helper\n\nThere are 2 issues with findSharedClass() in SCC Helpers being\nsynchronized:\n\nA. For classLoader with isParallelCapable = true, the parallel \nclass loading capability is lost.\nB. In the case that there are multiple custom Classloaders setting \nthe app ClassLoader as the parent, they all delegate to the app\nClassLoader first when finding classes. So all of them need to go \nthrough the synchronized method appClassloader.findSharedClass() \none by one, which becomes a bottleneck.\n\nThe changes here are:\n1. Change findSharedClass() as well as storeSharedClass() to be\nnon-synchronized.\n\n2. Use a readWriteLock in SharedClassURLClasspathHelperImpl \ninstead.\n\n3. Do not enter classTableMutex and class segmentMutex in the \nnative implementation of findSharedClass() in shared.c, as\nentering these mutexes is essentially making findSharedClass()\nsynchronized in the native level.\n\n4. Enter class segmentMutex only when necessary in \nhookFindSharedClass() and cacheMap::findROMClass().\n\n5. Do not need to wrap callFindLocallyDefinedClass() inside class\nsegment mutex.\n\n6. Change SharedClassURLHelperImpl.jarFileNameCache from a regular \nSet to a concurrent Set.\n\n7. _identifiedClasspaths should be used inside _identifiedMutex.\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>", "committedDate": "2020-06-11T20:31:22Z", "type": "commit"}, {"oid": "77b14cc5395285f662f8394988726fbb3cf1be4f", "url": "https://github.com/eclipse-openj9/openj9/commit/77b14cc5395285f662f8394988726fbb3cf1be4f", "message": "Minimize contention between \"finders\" using SCC JCL helper\n\nThere are 2 issues with findSharedClass() in SCC Helpers being\nsynchronized:\n\nA. For classLoader with isParallelCapable = true, the parallel \nclass loading capability is lost.\nB. In the case that there are multiple custom Classloaders setting \nthe app ClassLoader as the parent, they all delegate to the app\nClassLoader first when finding classes. So all of them need to go \nthrough the synchronized method appClassloader.findSharedClass() \none by one, which becomes a bottleneck.\n\nThe changes here are:\n1. Change findSharedClass() as well as storeSharedClass() to be\nnon-synchronized.\n\n2. Use a readWriteLock in SharedClassURLClasspathHelperImpl \ninstead.\n\n3. Do not enter classTableMutex and class segmentMutex in the \nnative implementation of findSharedClass() in shared.c, as\nentering these mutexes is essentially making findSharedClass()\nsynchronized in the native level.\n\n4. Enter class segmentMutex only when necessary in \nhookFindSharedClass() and cacheMap::findROMClass().\n\n5. Do not need to wrap callFindLocallyDefinedClass() inside class\nsegment mutex.\n\n6. Change SharedClassURLHelperImpl.jarFileNameCache from a regular \nSet to a concurrent Set.\n\n7. _identifiedClasspaths should be used inside _identifiedMutex.\n\nSigned-off-by: Hang Shao <hangshao@ca.ibm.com>", "committedDate": "2020-06-11T20:31:22Z", "type": "forcePushed"}]}