{"pr_number": 10830, "pr_title": "Add support for OpenJDK (OJDK) MethodHandle (MH) in MethodHandleResolver", "pr_createdAt": "2020-10-07T22:43:25Z", "pr_url": "https://github.com/eclipse-openj9/openj9/pull/10830", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc1ODYwMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r501758603", "bodyText": "Why does OpenJDK methodHandles not need this access check?", "author": "DanHeidinga", "createdAt": "2020-10-08T14:18:56Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandleHelper.java", "diffHunk": "@@ -0,0 +1,699 @@\n+/*[INCLUDE-IF Sidecar18-SE]*/\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+package java.lang.invoke;\n+\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+import com.ibm.oti.util.Msg;\n+import com.ibm.oti.vm.VM;\n+import com.ibm.oti.vm.VMLangAccess;\n+\n+/*[IF Sidecar19-SE]\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.reflect.ConstantPool;\n+/*[ELSE]*/\n+import sun.misc.Unsafe;\n+import sun.reflect.ConstantPool;\n+/*[ENDIF]*/\n+\n+import com.ibm.jit.JITHelpers;\n+\n+/**\n+ * Static methods for the MethodHandle class.\n+ */\n+public final class MethodHandleHelper {\n+\tstatic final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+\tstatic final JITHelpers JITHELPERS = JITHelpers.getHelpers();\n+\t\n+\tprivate static final int BSM_ARGUMENT_SIZE = Short.SIZE / Byte.SIZE;\n+\tprivate static final int BSM_ARGUMENT_COUNT_OFFSET = BSM_ARGUMENT_SIZE;\n+\tprivate static final int BSM_ARGUMENTS_OFFSET = BSM_ARGUMENT_SIZE * 2;\n+\tprivate static final int BSM_LOOKUP_ARGUMENT_INDEX = 0;\n+\tprivate static final int BSM_NAME_ARGUMENT_INDEX = 1;\n+\tprivate static final int BSM_TYPE_ARGUMENT_INDEX = 2;\n+\tprivate static final int BSM_OPTIONAL_ARGUMENTS_START_INDEX = 3;\n+\n+\t/*\n+\t * Return the result of J9_CP_TYPE(J9Class->romClass->cpShapeDescription, index)\n+\t */\n+\tprivate static final native int getCPTypeAt(Object internalRamClass, int index);\n+\n+\t/*\n+\t * sun.reflect.ConstantPool doesn't have a getMethodTypeAt method.  This is the \n+\t * equivalent for MethodType.\n+\t */\n+\tprivate static final native MethodType getCPMethodTypeAt(Object internalRamClass, int index);\n+\n+\t/*\n+\t * sun.reflect.ConstantPool doesn't have a getMethodHandleAt method.  This is the \n+\t * equivalent for MethodHandle.\n+\t */\n+\tprivate static final native MethodHandle getCPMethodHandleAt(Object internalRamClass, int index);\n+\n+\t\n+\t/**\n+\t * Get the class name from a constant pool class element, which is located\n+\t * at the specified <i>index</i> in <i>clazz</i>'s constant pool.\n+\t * \n+\t * @param   an instance of class - its constant pool is accessed\n+\t * @param   the constant pool index\n+\t * \n+\t * @return  instance of String which contains the class name or NULL in\n+\t *          case of error\n+\t * \n+\t * @throws  NullPointerException if <i>clazz</i> is null\n+\t * @throws  IllegalArgumentException if <i>index</i> has wrong constant pool type\n+\t */\n+\tprivate static final native String getCPClassNameAt(Class<?> clazz, int index);\n+\t\n+/*[IF Java11]*/\n+\t/*\n+\t * sun.reflect.ConstantPool doesn't have a getConstantDynamicAt method.  This is the \n+\t * equivalent for ConstantDynamic.\n+\t */\n+\tprivate static final native Object getCPConstantDynamicAt(Object internalRamClass, int index);\n+\n+\t@SuppressWarnings(\"unused\")\n+\tprivate static final Object resolveConstantDynamic(long j9class, String name, String fieldDescriptor, long bsmData) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\tObject result = null;\n+\n+\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\n+\t\tClass<?> typeClass = fromFieldDescriptorString(fieldDescriptor, access.getClassloader(classObject));\n+\n+\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\tif (null == bsm) {\n+\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t}\n+\t\tObject[] staticArgs = new Object[bsmArgCount];\n+\n+\t\t/* Static optional arguments */\n+\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires the first parameter of the bootstrap method to be java.lang.invoke.MethodHandles.Lookup\n+\t\t * else fail resolution with BootstrapMethodError\n+\t\t */\n+\t\tif (bsmTypeArgCount < 1 || MethodHandles.Lookup.class != bsm.type().parameterType(0)) {\n+\t\t\t/*[MSG \"K0A01\", \"Constant_Dynamic references bootstrap method '{0}' does not have java.lang.invoke.MethodHandles.Lookup as first parameter.\"]*/\n+\t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm)); //$NON-NLS-1$\n+\t\t}\n+\n+\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\tstaticArgs[i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t}\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires that exceptions from BSM invocation be wrapped in a BootstrapMethodError\n+\t\t * unless the exception thrown is a sub-class of Error.\n+\t\t * Exceptions thrown before invocation should be passed through unwrapped.\n+\t\t */\n+\t\ttry {\n+\t\t\tresult = MethodHandleNatives.linkDynamicConstant(classObject, 0, bsm, name, typeClass, (Object)staticArgs);\n+\t\t\t/* result validation */\n+\t\t\tresult = MethodHandles.identity(typeClass).invoke(result);\n+\t\t} catch(Throwable e) {\n+\t\t\tif (e instanceof Error) {\n+\t\t\t\tthrow e;\n+\t\t\t} else {\n+\t\t\t\t/*[MSG \"K0A00\", \"Failed to resolve Constant Dynamic entry with j9class: {0}, name: {1}, descriptor: {2}, bsmData: {3}\"]*/\n+\t\t\t\tString msg = Msg.getString(\"K0A00\", new Object[] {String.valueOf(j9class), name, fieldDescriptor, String.valueOf(bsmData)}); //$NON-NLS-1$\n+\t\t\t\tthrow new BootstrapMethodError(msg, e);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn result;\n+/*[ELSE]*/\n+\t\tObject result = null;\n+\n+\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\n+\t\tClass<?> typeClass = fromFieldDescriptorString(fieldDescriptor, access.getClassloader(classObject));\n+\n+\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\tif (null == bsm) {\n+\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t}\n+\t\tObject[] staticArgs = new Object[BSM_OPTIONAL_ARGUMENTS_START_INDEX + bsmArgCount];\n+\t\t/* Mandatory arguments */\n+\t\tstaticArgs[BSM_LOOKUP_ARGUMENT_INDEX] = new MethodHandles.Lookup(classObject, false);\n+\t\tstaticArgs[BSM_NAME_ARGUMENT_INDEX] = name;\n+\t\tstaticArgs[BSM_TYPE_ARGUMENT_INDEX] = typeClass;\n+\n+\t\t/* Static optional arguments */\n+\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires the first parameter of the bootstrap method to be java.lang.invoke.MethodHandles.Lookup\n+\t\t * else fail resolution with BootstrapMethodError\n+\t\t */\n+\t\tif (bsmTypeArgCount < 1 || MethodHandles.Lookup.class != bsm.type().parameterType(0)) {\n+\t\t\t/*[MSG \"K0A01\", \"Constant_Dynamic references bootstrap method '{0}' does not have java.lang.invoke.MethodHandles.Lookup as first parameter.\"]*/\n+\t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm.getMethodName())); //$NON-NLS-1$\n+\t\t}\n+\n+\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\tstaticArgs[BSM_OPTIONAL_ARGUMENTS_START_INDEX + i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t}\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires that exceptions from BSM invocation be wrapped in a BootstrapMethodError\n+\t\t * unless the exception thrown is a sub-class of Error.\n+\t\t * Exceptions thrown before invocation should be passed through unwrapped.\n+\t\t */\n+\t\ttry {\n+\t\t\tresult = (Object)invokeBsm(bsm, staticArgs);\n+\t\t\t/* result validation */\n+\t\t\tresult = MethodHandles.identity(typeClass).invoke(result);\n+\t\t} catch(Throwable e) {\n+\t\t\tif (e instanceof Error) {\n+\t\t\t\tthrow e;\n+\t\t\t} else {\n+\t\t\t\t/*[MSG \"K0A00\", \"Failed to resolve Constant Dynamic entry with j9class: {0}, name: {1}, descriptor: {2}, bsmData: {3}\"]*/\n+\t\t\t\tString msg = Msg.getString(\"K0A00\", new Object[] {String.valueOf(j9class), name, fieldDescriptor, String.valueOf(bsmData)}); //$NON-NLS-1$\n+\t\t\t\tthrow new BootstrapMethodError(msg, e);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn result;\n+/*[ENDIF] OPENJDK_METHODHANDLES*/\n+\t}\n+/*[ENDIF] Java11*/\n+\n+\t/*[IF ]*/\n+\t/*\n+\t * Used to preserve the new objectRef on the stack when avoiding the call-in for\n+\t * constructorHandles.  Must return 'this' so stackmapper will keep the object\n+\t * alive.\n+\t */\n+\t/*[ENDIF]*/\n+\t@SuppressWarnings(\"unused\")\n+\t@VMCONSTANTPOOL_METHOD\n+\tprivate static Object constructorPlaceHolder(Object newObjectRef) {\n+\t\treturn newObjectRef;\n+\t}\n+\n+\t/**\n+\t * Invoke bootstrap method with its static arguments\n+\t * @param bsm\n+\t * @param staticArgs\n+\t * @return result of bsm invocation\n+\t * @throws Throwable any throwable will be handled by the caller\n+\t */\n+\tprivate static final Object invokeBsm(MethodHandle bsm, Object[] staticArgs) throws Throwable {\n+\t\tObject result = null;\n+\t\t/* Take advantage of the per-MH asType cache */\n+\t\tswitch(staticArgs.length) {\n+\t\tcase 3:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2]);\n+\t\t\tbreak;\n+\t\tcase 4:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2], staticArgs[3]);\n+\t\t\tbreak;\n+\t\tcase 5:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2], staticArgs[3], staticArgs[4]);\n+\t\t\tbreak;\n+\t\tcase 6:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2], staticArgs[3], staticArgs[4], staticArgs[5]);\n+\t\t\tbreak;\n+\t\tcase 7:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2], staticArgs[3], staticArgs[4], staticArgs[5], staticArgs[6]);\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tresult = bsm.invokeWithArguments(staticArgs);\n+\t\t\tbreak;\n+\t\t}\n+\t\treturn result;\n+\t}\n+\t\n+\t@SuppressWarnings(\"unused\")\n+\tprivate static final Object resolveInvokeDynamic(long j9class, String name, String methodDescriptor, long bsmData) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\tObject[] result = new Object[2];\n+\t\tMethodType type = null;\n+\n+\t\ttry {\n+\t\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\t\t\t\n+\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(methodDescriptor, access.getClassloader(classObject), null);\n+\n+\t\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\t\tif (null == bsm) {\n+\t\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\tObject[] staticArgs = new Object[bsmArgCount];\n+\n+\t\t\t/* Static optional arguments */\n+\t\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\t\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\t\tstaticArgs[i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t\t}\n+\n+\t\t\tObject[] appendixResult = new Object[1];\n+\t\t\tappendixResult[0] = null;\n+\t\t\ttry {\n+\t\t\t\tMemberName mname = MethodHandleNatives.linkCallSite(classObject, 0, bsm, name, type, (Object)staticArgs, appendixResult);\n+\n+\t\t\t\tresult[0] = mname;\n+\t\t\t\tresult[1] = appendixResult[0];\n+\t\t\t} catch (Throwable e) {\n+\t\t\t\tif (e instanceof Error) {\n+\t\t\t\t\tresult[0] = e;\n+\t\t\t\t} else {\n+\t\t\t\t\tresult[0] = new BootstrapMethodError(e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable e) {\n+\t\t\tresult[0] = e;\n+\t\t}\n+\n+\t\treturn (Object)result;\n+/*[ELSE]*/\t\n+\t\tMethodHandle result = null;\n+\t\tMethodType type = null;\n+\n+/*[IF !Java11]*/\n+\t\ttry {\n+/*[ENDIF]*/\n+\t\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\t\t\t\n+\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(methodDescriptor, access.getClassloader(classObject), null);\n+\t\t\tfinal MethodHandles.Lookup lookup = new MethodHandles.Lookup(classObject, false);\n+\t\t\ttry {\n+\t\t\t\tlookup.accessCheckArgRetTypes(type);\n+\t\t\t} catch (IllegalAccessException e) {\n+\t\t\t\tIllegalAccessError err = new IllegalAccessError();\n+\t\t\t\terr.initCause(e);\n+\t\t\t\tthrow err;\n+\t\t\t}\n+\t\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\t\tif (null == bsm) {\n+\t\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\tObject[] staticArgs = new Object[BSM_OPTIONAL_ARGUMENTS_START_INDEX + bsmArgCount];\n+\t\t\t/* Mandatory arguments */\n+\t\t\tstaticArgs[BSM_LOOKUP_ARGUMENT_INDEX] = lookup;\n+\t\t\tstaticArgs[BSM_NAME_ARGUMENT_INDEX] = name;\n+\t\t\tstaticArgs[BSM_TYPE_ARGUMENT_INDEX] = type;\n+\t\t\n+\t\t\t/* Static optional arguments */\n+\t\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\t\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\t\tstaticArgs[BSM_OPTIONAL_ARGUMENTS_START_INDEX + i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t\t}\n+\n+/*[IF Java11]*/\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires that exceptions from BSM invocation be wrapped in a BootstrapMethodError\n+\t\t * unless the exception thrown is a sub-class of Error.\n+\t\t * Exceptions thrown before invocation should be passed through unwrapped.\n+\t\t */\n+\t\ttry {\n+/*[ENDIF]*/\n+\t\t\tCallSite cs = (CallSite)invokeBsm(bsm, staticArgs);\n+\t\t\tif (cs != null) {\n+\t\t\t\tMethodType callsiteType = cs.type();\n+\t\t\t\tif (callsiteType != type) {\n+\t\t\t\t\tthrow WrongMethodTypeException.newWrongMethodTypeException(type, callsiteType);\n+\t\t\t\t}\n+\t\t\t\tresult = cs.dynamicInvoker();\n+\t\t\t} \n+\t\t\t/*[IF Java11]*/\n+\t\t\telse {\n+\t\t\t\t/* The result of the resolution of a dynamically-computed call site must not be null. */\n+\t\t\t\t/*[MSG \"K0A02\", \"Bootstrap method returned null.\"]*/\n+\t\t\t\tthrow new ClassCastException(Msg.getString(\"K0A02\")); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\t/*[ENDIF]*/\n+\t\t} catch(Throwable e) {\n+\n+\t\t\t/*[IF Sidecar19-SE]*/\n+\t\t\tif (e instanceof Error) {\n+\t\t\t\tthrow e;\n+\t\t\t}\n+\t\t\t/*[ENDIF]*/\n+\n+\t\t\tif (type == null) {\n+\t\t\t\tthrow new BootstrapMethodError(e);\n+\t\t\t}\n+\t\t\t\n+\t\t\t/* create an exceptionHandle with appropriate drop adapter and install that */\n+\t\t\ttry {\n+\t\t\t\tMethodHandle thrower = MethodHandles.throwException(type.returnType(), BootstrapMethodError.class);\n+\t\t\t\tMethodHandle constructor = MethodHandles.Lookup.IMPL_LOOKUP.findConstructor(BootstrapMethodError.class, MethodType.methodType(void.class, Throwable.class));\n+\t\t\t\tresult = MethodHandles.foldArguments(thrower, constructor.bindTo(e));\n+\t\t\t\tresult = MethodHandles.dropArguments(result, 0, type.parameterList()); \n+\t\t\t} catch (IllegalAccessException iae) {\n+\t\t\t\tthrow new Error(iae);\n+\t\t\t} catch (NoSuchMethodException nsme) {\n+\t\t\t\tthrow new Error(nsme);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn result;\n+/*[ENDIF] OPENJDK_METHODHANDLES*/\n+\t}\n+\n+\t@SuppressWarnings(\"unused\")\n+\t@VMCONSTANTPOOL_METHOD\n+\tprivate static final MethodHandle sendResolveMethodHandle(\n+\t\t\tint cpRefKind,\n+\t\t\tClass<?> currentClass,\n+\t\t\tClass<?> referenceClazz,\n+\t\t\tString name,\n+\t\t\tString typeDescriptor,\n+\t\t\tClassLoader loader) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\ttry {\n+\t\t\tMethodHandles.Lookup lookup = new MethodHandles.Lookup(currentClass);\n+\t\t\tMethodType type = null;\n+\t\t\tMethodHandle result = null;\n+\n+\t\t\tswitch (cpRefKind) {\n+\t\t\tcase 1: /* getField */\n+\t\t\t\tresult = lookup.findGetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 2: /* getStatic */\n+\t\t\t\tresult = lookup.findStaticGetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 3: /* putField */\n+\t\t\t\tresult = lookup.findSetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 4: /* putStatic */\n+\t\t\t\tresult = lookup.findStaticSetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 5: /* invokeVirtual */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tresult = lookup.findVirtual(referenceClazz, name, type);\n+\t\t\t\tbreak;\n+\t\t\tcase 6: /* invokeStatic */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tresult = lookup.findStatic(referenceClazz, name, type);\n+\t\t\t\tbreak;\n+\t\t\tcase 7: /* invokeSpecial */ \n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tresult = lookup.findSpecial(referenceClazz, name, type, currentClass);\n+\t\t\t\tbreak;\n+\t\t\tcase 8: /* newInvokeSpecial */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tresult = lookup.findConstructor(referenceClazz, type);\n+\t\t\t\tbreak;\n+\t\t\tcase 9: /* invokeInterface */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tresult = lookup.findVirtual(referenceClazz, name, type);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\t/* Can never happen */\n+\t\t\t\tthrow new UnsupportedOperationException();\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t} catch (IllegalAccessException iae) {\n+\t\t\t// Java spec expects an IllegalAccessError instead of IllegalAccessException thrown when an application attempts \n+\t\t\t// (not reflectively) to access or modify a field, or to invoke a method that it doesn't have access to.\n+\t\t\tthrow new IllegalAccessError(iae.getMessage()).initCause(iae);\n+\t\t}\n+/*[ELSE]*/\n+\t\ttry {\n+\t\t\tMethodHandles.Lookup lookup = new MethodHandles.Lookup(currentClass, false);\n+\t\t\tMethodType type = null;\n+\t\t\tMethodHandle result = null;\n+\n+\t\t\tswitch (cpRefKind) {\n+\t\t\tcase 1: /* getField */\n+\t\t\t\tresult = lookup.findGetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 2: /* getStatic */\n+\t\t\t\tresult = lookup.findStaticGetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 3: /* putField */\n+\t\t\t\tresult = lookup.findSetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 4: /* putStatic */\n+\t\t\t\tresult = lookup.findStaticSetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 5: /* invokeVirtual */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tlookup.accessCheckArgRetTypes(type);\n+\t\t\t\tresult = lookup.findVirtual(referenceClazz, name, type);\n+\t\t\t\tbreak;\n+\t\t\tcase 6: /* invokeStatic */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tlookup.accessCheckArgRetTypes(type);\n+\t\t\t\tresult = lookup.findStatic(referenceClazz, name, type);\n+\t\t\t\tbreak;\n+\t\t\tcase 7: /* invokeSpecial */ \n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tlookup.accessCheckArgRetTypes(type);\n+\t\t\t\tresult = lookup.findSpecial(referenceClazz, name, type, currentClass);\n+\t\t\t\tbreak;\n+\t\t\tcase 8: /* newInvokeSpecial */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tlookup.accessCheckArgRetTypes(type);\n+\t\t\t\tresult = lookup.findConstructor(referenceClazz, type);\n+\t\t\t\tbreak;\n+\t\t\tcase 9: /* invokeInterface */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tlookup.accessCheckArgRetTypes(type);\n+\t\t\t\tresult = lookup.findVirtual(referenceClazz, name, type);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\t/* Can never happen */\n+\t\t\t\tthrow new UnsupportedOperationException();\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t} catch (IllegalAccessException iae) {\n+\t\t\t// Java spec expects an IllegalAccessError instead of IllegalAccessException thrown when an application attempts \n+\t\t\t// (not reflectively) to access or modify a field, or to invoke a method that it doesn't have access to.\n+\t\t\tthrow new IllegalAccessError(iae.getMessage()).initCause(iae);\n+\t\t}\n+/*[ENDIF] OPENJDK_METHODHANDLES*/\n+\t}\n+\t\n+\t/* Convert the field type descriptor into a MethodType so we can reuse the parsing logic in \n+\t * #fromMethodDescriptorString().  The verifier checks to ensure that the typeDescriptor is\n+\t * a valid field descriptor so adding the \"()V\" around it is valid.\n+\t */\n+\tprivate static final Class<?> resolveFieldHandleHelper(String typeDescriptor, Lookup lookup, ClassLoader loader) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\tMethodType mt = MethodType.vmResolveFromMethodDescriptorString(\"(\" + typeDescriptor + \")V\", loader, null); //$NON-NLS-1$ //$NON-NLS-2$\n+\t\treturn mt.parameterType(0);\n+/*[ELSE]*/\n+\t\tMethodType mt = MethodType.vmResolveFromMethodDescriptorString(\"(\" + typeDescriptor + \")V\", loader, null); //$NON-NLS-1$ //$NON-NLS-2$\n+\t\tlookup.accessCheckArgRetTypes(mt);", "originalCommit": "628621af13063ff19389e32968006a10049e2edc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc3MDcwMw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r501770703", "bodyText": "And similar to the comment about - make it clear what the difference is:\n/*[IF OPENJDK_METHODHANDLES]*/\n/* TODO: Investigate if an equivalent for lookup.accessCheckArgRetTypes is\n * needed for OJDK MH. If needed, find an alternative for\n * lookup.accessCheckArgRetTypes.\n */\n/*[ELSE]*/\nlookup.accessCheckArgRetTypes(type);\n/*[ENDIF]*/\n\nand keep the rest of the code common", "author": "DanHeidinga", "createdAt": "2020-10-08T14:33:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc1ODYwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI1Mzk0Ng==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r504253946", "bodyText": "Comment added. sendResolveMethodHandle and resolveFieldHandleHelper shared between J9 and OJDK MH using preprocessor flags.", "author": "babsingh", "createdAt": "2020-10-13T20:57:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc1ODYwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc2MzA5NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r501763095", "bodyText": "Why do we have both sendResolveMethodHandle code for OpenJDK MHs and a new resolveMethodHandle method?  Is there a relationship between them?  Should there be?", "author": "DanHeidinga", "createdAt": "2020-10-08T14:24:24Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandleHelper.java", "diffHunk": "@@ -0,0 +1,699 @@\n+/*[INCLUDE-IF Sidecar18-SE]*/\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+package java.lang.invoke;\n+\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+import com.ibm.oti.util.Msg;\n+import com.ibm.oti.vm.VM;\n+import com.ibm.oti.vm.VMLangAccess;\n+\n+/*[IF Sidecar19-SE]\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.reflect.ConstantPool;\n+/*[ELSE]*/\n+import sun.misc.Unsafe;\n+import sun.reflect.ConstantPool;\n+/*[ENDIF]*/\n+\n+import com.ibm.jit.JITHelpers;\n+\n+/**\n+ * Static methods for the MethodHandle class.\n+ */\n+public final class MethodHandleHelper {\n+\tstatic final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+\tstatic final JITHelpers JITHELPERS = JITHelpers.getHelpers();\n+\t\n+\tprivate static final int BSM_ARGUMENT_SIZE = Short.SIZE / Byte.SIZE;\n+\tprivate static final int BSM_ARGUMENT_COUNT_OFFSET = BSM_ARGUMENT_SIZE;\n+\tprivate static final int BSM_ARGUMENTS_OFFSET = BSM_ARGUMENT_SIZE * 2;\n+\tprivate static final int BSM_LOOKUP_ARGUMENT_INDEX = 0;\n+\tprivate static final int BSM_NAME_ARGUMENT_INDEX = 1;\n+\tprivate static final int BSM_TYPE_ARGUMENT_INDEX = 2;\n+\tprivate static final int BSM_OPTIONAL_ARGUMENTS_START_INDEX = 3;\n+\n+\t/*\n+\t * Return the result of J9_CP_TYPE(J9Class->romClass->cpShapeDescription, index)\n+\t */\n+\tprivate static final native int getCPTypeAt(Object internalRamClass, int index);\n+\n+\t/*\n+\t * sun.reflect.ConstantPool doesn't have a getMethodTypeAt method.  This is the \n+\t * equivalent for MethodType.\n+\t */\n+\tprivate static final native MethodType getCPMethodTypeAt(Object internalRamClass, int index);\n+\n+\t/*\n+\t * sun.reflect.ConstantPool doesn't have a getMethodHandleAt method.  This is the \n+\t * equivalent for MethodHandle.\n+\t */\n+\tprivate static final native MethodHandle getCPMethodHandleAt(Object internalRamClass, int index);\n+\n+\t\n+\t/**\n+\t * Get the class name from a constant pool class element, which is located\n+\t * at the specified <i>index</i> in <i>clazz</i>'s constant pool.\n+\t * \n+\t * @param   an instance of class - its constant pool is accessed\n+\t * @param   the constant pool index\n+\t * \n+\t * @return  instance of String which contains the class name or NULL in\n+\t *          case of error\n+\t * \n+\t * @throws  NullPointerException if <i>clazz</i> is null\n+\t * @throws  IllegalArgumentException if <i>index</i> has wrong constant pool type\n+\t */\n+\tprivate static final native String getCPClassNameAt(Class<?> clazz, int index);\n+\t\n+/*[IF Java11]*/\n+\t/*\n+\t * sun.reflect.ConstantPool doesn't have a getConstantDynamicAt method.  This is the \n+\t * equivalent for ConstantDynamic.\n+\t */\n+\tprivate static final native Object getCPConstantDynamicAt(Object internalRamClass, int index);\n+\n+\t@SuppressWarnings(\"unused\")\n+\tprivate static final Object resolveConstantDynamic(long j9class, String name, String fieldDescriptor, long bsmData) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\tObject result = null;\n+\n+\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\n+\t\tClass<?> typeClass = fromFieldDescriptorString(fieldDescriptor, access.getClassloader(classObject));\n+\n+\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\tif (null == bsm) {\n+\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t}\n+\t\tObject[] staticArgs = new Object[bsmArgCount];\n+\n+\t\t/* Static optional arguments */\n+\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires the first parameter of the bootstrap method to be java.lang.invoke.MethodHandles.Lookup\n+\t\t * else fail resolution with BootstrapMethodError\n+\t\t */\n+\t\tif (bsmTypeArgCount < 1 || MethodHandles.Lookup.class != bsm.type().parameterType(0)) {\n+\t\t\t/*[MSG \"K0A01\", \"Constant_Dynamic references bootstrap method '{0}' does not have java.lang.invoke.MethodHandles.Lookup as first parameter.\"]*/\n+\t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm)); //$NON-NLS-1$\n+\t\t}\n+\n+\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\tstaticArgs[i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t}\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires that exceptions from BSM invocation be wrapped in a BootstrapMethodError\n+\t\t * unless the exception thrown is a sub-class of Error.\n+\t\t * Exceptions thrown before invocation should be passed through unwrapped.\n+\t\t */\n+\t\ttry {\n+\t\t\tresult = MethodHandleNatives.linkDynamicConstant(classObject, 0, bsm, name, typeClass, (Object)staticArgs);\n+\t\t\t/* result validation */\n+\t\t\tresult = MethodHandles.identity(typeClass).invoke(result);\n+\t\t} catch(Throwable e) {\n+\t\t\tif (e instanceof Error) {\n+\t\t\t\tthrow e;\n+\t\t\t} else {\n+\t\t\t\t/*[MSG \"K0A00\", \"Failed to resolve Constant Dynamic entry with j9class: {0}, name: {1}, descriptor: {2}, bsmData: {3}\"]*/\n+\t\t\t\tString msg = Msg.getString(\"K0A00\", new Object[] {String.valueOf(j9class), name, fieldDescriptor, String.valueOf(bsmData)}); //$NON-NLS-1$\n+\t\t\t\tthrow new BootstrapMethodError(msg, e);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn result;\n+/*[ELSE]*/\n+\t\tObject result = null;\n+\n+\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\n+\t\tClass<?> typeClass = fromFieldDescriptorString(fieldDescriptor, access.getClassloader(classObject));\n+\n+\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\tif (null == bsm) {\n+\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t}\n+\t\tObject[] staticArgs = new Object[BSM_OPTIONAL_ARGUMENTS_START_INDEX + bsmArgCount];\n+\t\t/* Mandatory arguments */\n+\t\tstaticArgs[BSM_LOOKUP_ARGUMENT_INDEX] = new MethodHandles.Lookup(classObject, false);\n+\t\tstaticArgs[BSM_NAME_ARGUMENT_INDEX] = name;\n+\t\tstaticArgs[BSM_TYPE_ARGUMENT_INDEX] = typeClass;\n+\n+\t\t/* Static optional arguments */\n+\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires the first parameter of the bootstrap method to be java.lang.invoke.MethodHandles.Lookup\n+\t\t * else fail resolution with BootstrapMethodError\n+\t\t */\n+\t\tif (bsmTypeArgCount < 1 || MethodHandles.Lookup.class != bsm.type().parameterType(0)) {\n+\t\t\t/*[MSG \"K0A01\", \"Constant_Dynamic references bootstrap method '{0}' does not have java.lang.invoke.MethodHandles.Lookup as first parameter.\"]*/\n+\t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm.getMethodName())); //$NON-NLS-1$\n+\t\t}\n+\n+\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\tstaticArgs[BSM_OPTIONAL_ARGUMENTS_START_INDEX + i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t}\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires that exceptions from BSM invocation be wrapped in a BootstrapMethodError\n+\t\t * unless the exception thrown is a sub-class of Error.\n+\t\t * Exceptions thrown before invocation should be passed through unwrapped.\n+\t\t */\n+\t\ttry {\n+\t\t\tresult = (Object)invokeBsm(bsm, staticArgs);\n+\t\t\t/* result validation */\n+\t\t\tresult = MethodHandles.identity(typeClass).invoke(result);\n+\t\t} catch(Throwable e) {\n+\t\t\tif (e instanceof Error) {\n+\t\t\t\tthrow e;\n+\t\t\t} else {\n+\t\t\t\t/*[MSG \"K0A00\", \"Failed to resolve Constant Dynamic entry with j9class: {0}, name: {1}, descriptor: {2}, bsmData: {3}\"]*/\n+\t\t\t\tString msg = Msg.getString(\"K0A00\", new Object[] {String.valueOf(j9class), name, fieldDescriptor, String.valueOf(bsmData)}); //$NON-NLS-1$\n+\t\t\t\tthrow new BootstrapMethodError(msg, e);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn result;\n+/*[ENDIF] OPENJDK_METHODHANDLES*/\n+\t}\n+/*[ENDIF] Java11*/\n+\n+\t/*[IF ]*/\n+\t/*\n+\t * Used to preserve the new objectRef on the stack when avoiding the call-in for\n+\t * constructorHandles.  Must return 'this' so stackmapper will keep the object\n+\t * alive.\n+\t */\n+\t/*[ENDIF]*/\n+\t@SuppressWarnings(\"unused\")\n+\t@VMCONSTANTPOOL_METHOD\n+\tprivate static Object constructorPlaceHolder(Object newObjectRef) {\n+\t\treturn newObjectRef;\n+\t}\n+\n+\t/**\n+\t * Invoke bootstrap method with its static arguments\n+\t * @param bsm\n+\t * @param staticArgs\n+\t * @return result of bsm invocation\n+\t * @throws Throwable any throwable will be handled by the caller\n+\t */\n+\tprivate static final Object invokeBsm(MethodHandle bsm, Object[] staticArgs) throws Throwable {\n+\t\tObject result = null;\n+\t\t/* Take advantage of the per-MH asType cache */\n+\t\tswitch(staticArgs.length) {\n+\t\tcase 3:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2]);\n+\t\t\tbreak;\n+\t\tcase 4:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2], staticArgs[3]);\n+\t\t\tbreak;\n+\t\tcase 5:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2], staticArgs[3], staticArgs[4]);\n+\t\t\tbreak;\n+\t\tcase 6:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2], staticArgs[3], staticArgs[4], staticArgs[5]);\n+\t\t\tbreak;\n+\t\tcase 7:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2], staticArgs[3], staticArgs[4], staticArgs[5], staticArgs[6]);\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tresult = bsm.invokeWithArguments(staticArgs);\n+\t\t\tbreak;\n+\t\t}\n+\t\treturn result;\n+\t}\n+\t\n+\t@SuppressWarnings(\"unused\")\n+\tprivate static final Object resolveInvokeDynamic(long j9class, String name, String methodDescriptor, long bsmData) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\tObject[] result = new Object[2];\n+\t\tMethodType type = null;\n+\n+\t\ttry {\n+\t\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\t\t\t\n+\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(methodDescriptor, access.getClassloader(classObject), null);\n+\n+\t\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\t\tif (null == bsm) {\n+\t\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\tObject[] staticArgs = new Object[bsmArgCount];\n+\n+\t\t\t/* Static optional arguments */\n+\t\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\t\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\t\tstaticArgs[i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t\t}\n+\n+\t\t\tObject[] appendixResult = new Object[1];\n+\t\t\tappendixResult[0] = null;\n+\t\t\ttry {\n+\t\t\t\tMemberName mname = MethodHandleNatives.linkCallSite(classObject, 0, bsm, name, type, (Object)staticArgs, appendixResult);\n+\n+\t\t\t\tresult[0] = mname;\n+\t\t\t\tresult[1] = appendixResult[0];\n+\t\t\t} catch (Throwable e) {\n+\t\t\t\tif (e instanceof Error) {\n+\t\t\t\t\tresult[0] = e;\n+\t\t\t\t} else {\n+\t\t\t\t\tresult[0] = new BootstrapMethodError(e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable e) {\n+\t\t\tresult[0] = e;\n+\t\t}\n+\n+\t\treturn (Object)result;\n+/*[ELSE]*/\t\n+\t\tMethodHandle result = null;\n+\t\tMethodType type = null;\n+\n+/*[IF !Java11]*/\n+\t\ttry {\n+/*[ENDIF]*/\n+\t\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\t\t\t\n+\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(methodDescriptor, access.getClassloader(classObject), null);\n+\t\t\tfinal MethodHandles.Lookup lookup = new MethodHandles.Lookup(classObject, false);\n+\t\t\ttry {\n+\t\t\t\tlookup.accessCheckArgRetTypes(type);\n+\t\t\t} catch (IllegalAccessException e) {\n+\t\t\t\tIllegalAccessError err = new IllegalAccessError();\n+\t\t\t\terr.initCause(e);\n+\t\t\t\tthrow err;\n+\t\t\t}\n+\t\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\t\tif (null == bsm) {\n+\t\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\tObject[] staticArgs = new Object[BSM_OPTIONAL_ARGUMENTS_START_INDEX + bsmArgCount];\n+\t\t\t/* Mandatory arguments */\n+\t\t\tstaticArgs[BSM_LOOKUP_ARGUMENT_INDEX] = lookup;\n+\t\t\tstaticArgs[BSM_NAME_ARGUMENT_INDEX] = name;\n+\t\t\tstaticArgs[BSM_TYPE_ARGUMENT_INDEX] = type;\n+\t\t\n+\t\t\t/* Static optional arguments */\n+\t\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\t\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\t\tstaticArgs[BSM_OPTIONAL_ARGUMENTS_START_INDEX + i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t\t}\n+\n+/*[IF Java11]*/\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires that exceptions from BSM invocation be wrapped in a BootstrapMethodError\n+\t\t * unless the exception thrown is a sub-class of Error.\n+\t\t * Exceptions thrown before invocation should be passed through unwrapped.\n+\t\t */\n+\t\ttry {\n+/*[ENDIF]*/\n+\t\t\tCallSite cs = (CallSite)invokeBsm(bsm, staticArgs);\n+\t\t\tif (cs != null) {\n+\t\t\t\tMethodType callsiteType = cs.type();\n+\t\t\t\tif (callsiteType != type) {\n+\t\t\t\t\tthrow WrongMethodTypeException.newWrongMethodTypeException(type, callsiteType);\n+\t\t\t\t}\n+\t\t\t\tresult = cs.dynamicInvoker();\n+\t\t\t} \n+\t\t\t/*[IF Java11]*/\n+\t\t\telse {\n+\t\t\t\t/* The result of the resolution of a dynamically-computed call site must not be null. */\n+\t\t\t\t/*[MSG \"K0A02\", \"Bootstrap method returned null.\"]*/\n+\t\t\t\tthrow new ClassCastException(Msg.getString(\"K0A02\")); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\t/*[ENDIF]*/\n+\t\t} catch(Throwable e) {\n+\n+\t\t\t/*[IF Sidecar19-SE]*/\n+\t\t\tif (e instanceof Error) {\n+\t\t\t\tthrow e;\n+\t\t\t}\n+\t\t\t/*[ENDIF]*/\n+\n+\t\t\tif (type == null) {\n+\t\t\t\tthrow new BootstrapMethodError(e);\n+\t\t\t}\n+\t\t\t\n+\t\t\t/* create an exceptionHandle with appropriate drop adapter and install that */\n+\t\t\ttry {\n+\t\t\t\tMethodHandle thrower = MethodHandles.throwException(type.returnType(), BootstrapMethodError.class);\n+\t\t\t\tMethodHandle constructor = MethodHandles.Lookup.IMPL_LOOKUP.findConstructor(BootstrapMethodError.class, MethodType.methodType(void.class, Throwable.class));\n+\t\t\t\tresult = MethodHandles.foldArguments(thrower, constructor.bindTo(e));\n+\t\t\t\tresult = MethodHandles.dropArguments(result, 0, type.parameterList()); \n+\t\t\t} catch (IllegalAccessException iae) {\n+\t\t\t\tthrow new Error(iae);\n+\t\t\t} catch (NoSuchMethodException nsme) {\n+\t\t\t\tthrow new Error(nsme);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn result;\n+/*[ENDIF] OPENJDK_METHODHANDLES*/\n+\t}\n+\n+\t@SuppressWarnings(\"unused\")\n+\t@VMCONSTANTPOOL_METHOD\n+\tprivate static final MethodHandle sendResolveMethodHandle(\n+\t\t\tint cpRefKind,\n+\t\t\tClass<?> currentClass,\n+\t\t\tClass<?> referenceClazz,\n+\t\t\tString name,\n+\t\t\tString typeDescriptor,\n+\t\t\tClassLoader loader) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/", "originalCommit": "628621af13063ff19389e32968006a10049e2edc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgyMTI4MA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r501821280", "bodyText": "resolveMethodHandle generates the bytecodes for a MethodHandle (MH) to be invoked.\nsendResolveMethodHandle stays the same, and it finds the MH based on the MH CP Ref kind.\nThey do not have a relationship.\n+@fengxue-IS, to validate the above statements.", "author": "babsingh", "createdAt": "2020-10-08T15:40:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc2MzA5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg1ODY2Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r501858663", "bodyText": "resolveMethodHandle is used to generate memberName adapter for a invokehandle bytecode (invocation),\nsendResolveMethodHandle is used for ldc bytecode that loads a MH (constant loading)", "author": "fengxue-IS", "createdAt": "2020-10-08T16:36:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc2MzA5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTg4NjU5OQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r501886599", "bodyText": "Can one of them be renamed to make the different use cases clear?  It would also be good to comment them with this information so it's evident from the code when / why each should be used", "author": "DanHeidinga", "createdAt": "2020-10-08T17:22:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc2MzA5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI1MTgyOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r504251829", "bodyText": "resolveMethodHandle renamed to linkCallerMethod.", "author": "babsingh", "createdAt": "2020-10-13T20:53:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc2MzA5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc2OTk2NA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r501769964", "bodyText": "If the only difference between the two cases - openj9 mh & openjdk mh - is this call, it's better to keep the 90% the same code the same and add preprocessor tags around this.\nIt also makes it clear that this is the piece that's different, and allows adding a comment to indicate the access checks haven't occurred here\nie:\n/*[IF OPENJDK_METHODHANDLES]*/\n/* TODO: Investigate if an equivalent for lookup.accessCheckArgRetTypes is\n * needed for OJDK MH. If needed, find an alternative for\n * lookup.accessCheckArgRetTypes.\n */\n/*[ELSE]*/\nlookup.accessCheckArgRetTypes(type);\n/*[ENDIF]*/", "author": "DanHeidinga", "createdAt": "2020-10-08T14:32:54Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandleHelper.java", "diffHunk": "@@ -0,0 +1,699 @@\n+/*[INCLUDE-IF Sidecar18-SE]*/\n+/*******************************************************************************\n+ * Copyright (c) 2020, 2020 IBM Corp. and others\n+ *\n+ * This program and the accompanying materials are made available under\n+ * the terms of the Eclipse Public License 2.0 which accompanies this\n+ * distribution and is available at https://www.eclipse.org/legal/epl-2.0/\n+ * or the Apache License, Version 2.0 which accompanies this distribution and\n+ * is available at https://www.apache.org/licenses/LICENSE-2.0.\n+ *\n+ * This Source Code may also be made available under the following\n+ * Secondary Licenses when the conditions for such availability set\n+ * forth in the Eclipse Public License, v. 2.0 are satisfied: GNU\n+ * General Public License, version 2 with the GNU Classpath\n+ * Exception [1] and GNU General Public License, version 2 with the\n+ * OpenJDK Assembly Exception [2].\n+ *\n+ * [1] https://www.gnu.org/software/classpath/license.html\n+ * [2] http://openjdk.java.net/legal/assembly-exception.html\n+ *\n+ * SPDX-License-Identifier: EPL-2.0 OR Apache-2.0 OR GPL-2.0 WITH Classpath-exception-2.0 OR LicenseRef-GPL-2.0 WITH Assembly-exception\n+ *******************************************************************************/\n+package java.lang.invoke;\n+\n+import java.lang.invoke.MethodHandles.Lookup;\n+import java.util.ArrayList;\n+import java.util.Objects;\n+\n+import com.ibm.oti.util.Msg;\n+import com.ibm.oti.vm.VM;\n+import com.ibm.oti.vm.VMLangAccess;\n+\n+/*[IF Sidecar19-SE]\n+import jdk.internal.misc.Unsafe;\n+import jdk.internal.reflect.ConstantPool;\n+/*[ELSE]*/\n+import sun.misc.Unsafe;\n+import sun.reflect.ConstantPool;\n+/*[ENDIF]*/\n+\n+import com.ibm.jit.JITHelpers;\n+\n+/**\n+ * Static methods for the MethodHandle class.\n+ */\n+public final class MethodHandleHelper {\n+\tstatic final Unsafe UNSAFE = Unsafe.getUnsafe();\n+\n+\tstatic final JITHelpers JITHELPERS = JITHelpers.getHelpers();\n+\t\n+\tprivate static final int BSM_ARGUMENT_SIZE = Short.SIZE / Byte.SIZE;\n+\tprivate static final int BSM_ARGUMENT_COUNT_OFFSET = BSM_ARGUMENT_SIZE;\n+\tprivate static final int BSM_ARGUMENTS_OFFSET = BSM_ARGUMENT_SIZE * 2;\n+\tprivate static final int BSM_LOOKUP_ARGUMENT_INDEX = 0;\n+\tprivate static final int BSM_NAME_ARGUMENT_INDEX = 1;\n+\tprivate static final int BSM_TYPE_ARGUMENT_INDEX = 2;\n+\tprivate static final int BSM_OPTIONAL_ARGUMENTS_START_INDEX = 3;\n+\n+\t/*\n+\t * Return the result of J9_CP_TYPE(J9Class->romClass->cpShapeDescription, index)\n+\t */\n+\tprivate static final native int getCPTypeAt(Object internalRamClass, int index);\n+\n+\t/*\n+\t * sun.reflect.ConstantPool doesn't have a getMethodTypeAt method.  This is the \n+\t * equivalent for MethodType.\n+\t */\n+\tprivate static final native MethodType getCPMethodTypeAt(Object internalRamClass, int index);\n+\n+\t/*\n+\t * sun.reflect.ConstantPool doesn't have a getMethodHandleAt method.  This is the \n+\t * equivalent for MethodHandle.\n+\t */\n+\tprivate static final native MethodHandle getCPMethodHandleAt(Object internalRamClass, int index);\n+\n+\t\n+\t/**\n+\t * Get the class name from a constant pool class element, which is located\n+\t * at the specified <i>index</i> in <i>clazz</i>'s constant pool.\n+\t * \n+\t * @param   an instance of class - its constant pool is accessed\n+\t * @param   the constant pool index\n+\t * \n+\t * @return  instance of String which contains the class name or NULL in\n+\t *          case of error\n+\t * \n+\t * @throws  NullPointerException if <i>clazz</i> is null\n+\t * @throws  IllegalArgumentException if <i>index</i> has wrong constant pool type\n+\t */\n+\tprivate static final native String getCPClassNameAt(Class<?> clazz, int index);\n+\t\n+/*[IF Java11]*/\n+\t/*\n+\t * sun.reflect.ConstantPool doesn't have a getConstantDynamicAt method.  This is the \n+\t * equivalent for ConstantDynamic.\n+\t */\n+\tprivate static final native Object getCPConstantDynamicAt(Object internalRamClass, int index);\n+\n+\t@SuppressWarnings(\"unused\")\n+\tprivate static final Object resolveConstantDynamic(long j9class, String name, String fieldDescriptor, long bsmData) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\tObject result = null;\n+\n+\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\n+\t\tClass<?> typeClass = fromFieldDescriptorString(fieldDescriptor, access.getClassloader(classObject));\n+\n+\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\tif (null == bsm) {\n+\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t}\n+\t\tObject[] staticArgs = new Object[bsmArgCount];\n+\n+\t\t/* Static optional arguments */\n+\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires the first parameter of the bootstrap method to be java.lang.invoke.MethodHandles.Lookup\n+\t\t * else fail resolution with BootstrapMethodError\n+\t\t */\n+\t\tif (bsmTypeArgCount < 1 || MethodHandles.Lookup.class != bsm.type().parameterType(0)) {\n+\t\t\t/*[MSG \"K0A01\", \"Constant_Dynamic references bootstrap method '{0}' does not have java.lang.invoke.MethodHandles.Lookup as first parameter.\"]*/\n+\t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm)); //$NON-NLS-1$\n+\t\t}\n+\n+\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\tstaticArgs[i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t}\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires that exceptions from BSM invocation be wrapped in a BootstrapMethodError\n+\t\t * unless the exception thrown is a sub-class of Error.\n+\t\t * Exceptions thrown before invocation should be passed through unwrapped.\n+\t\t */\n+\t\ttry {\n+\t\t\tresult = MethodHandleNatives.linkDynamicConstant(classObject, 0, bsm, name, typeClass, (Object)staticArgs);\n+\t\t\t/* result validation */\n+\t\t\tresult = MethodHandles.identity(typeClass).invoke(result);\n+\t\t} catch(Throwable e) {\n+\t\t\tif (e instanceof Error) {\n+\t\t\t\tthrow e;\n+\t\t\t} else {\n+\t\t\t\t/*[MSG \"K0A00\", \"Failed to resolve Constant Dynamic entry with j9class: {0}, name: {1}, descriptor: {2}, bsmData: {3}\"]*/\n+\t\t\t\tString msg = Msg.getString(\"K0A00\", new Object[] {String.valueOf(j9class), name, fieldDescriptor, String.valueOf(bsmData)}); //$NON-NLS-1$\n+\t\t\t\tthrow new BootstrapMethodError(msg, e);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn result;\n+/*[ELSE]*/\n+\t\tObject result = null;\n+\n+\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\n+\t\tClass<?> typeClass = fromFieldDescriptorString(fieldDescriptor, access.getClassloader(classObject));\n+\n+\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\tif (null == bsm) {\n+\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t}\n+\t\tObject[] staticArgs = new Object[BSM_OPTIONAL_ARGUMENTS_START_INDEX + bsmArgCount];\n+\t\t/* Mandatory arguments */\n+\t\tstaticArgs[BSM_LOOKUP_ARGUMENT_INDEX] = new MethodHandles.Lookup(classObject, false);\n+\t\tstaticArgs[BSM_NAME_ARGUMENT_INDEX] = name;\n+\t\tstaticArgs[BSM_TYPE_ARGUMENT_INDEX] = typeClass;\n+\n+\t\t/* Static optional arguments */\n+\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires the first parameter of the bootstrap method to be java.lang.invoke.MethodHandles.Lookup\n+\t\t * else fail resolution with BootstrapMethodError\n+\t\t */\n+\t\tif (bsmTypeArgCount < 1 || MethodHandles.Lookup.class != bsm.type().parameterType(0)) {\n+\t\t\t/*[MSG \"K0A01\", \"Constant_Dynamic references bootstrap method '{0}' does not have java.lang.invoke.MethodHandles.Lookup as first parameter.\"]*/\n+\t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm.getMethodName())); //$NON-NLS-1$\n+\t\t}\n+\n+\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\tstaticArgs[BSM_OPTIONAL_ARGUMENTS_START_INDEX + i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t}\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires that exceptions from BSM invocation be wrapped in a BootstrapMethodError\n+\t\t * unless the exception thrown is a sub-class of Error.\n+\t\t * Exceptions thrown before invocation should be passed through unwrapped.\n+\t\t */\n+\t\ttry {\n+\t\t\tresult = (Object)invokeBsm(bsm, staticArgs);\n+\t\t\t/* result validation */\n+\t\t\tresult = MethodHandles.identity(typeClass).invoke(result);\n+\t\t} catch(Throwable e) {\n+\t\t\tif (e instanceof Error) {\n+\t\t\t\tthrow e;\n+\t\t\t} else {\n+\t\t\t\t/*[MSG \"K0A00\", \"Failed to resolve Constant Dynamic entry with j9class: {0}, name: {1}, descriptor: {2}, bsmData: {3}\"]*/\n+\t\t\t\tString msg = Msg.getString(\"K0A00\", new Object[] {String.valueOf(j9class), name, fieldDescriptor, String.valueOf(bsmData)}); //$NON-NLS-1$\n+\t\t\t\tthrow new BootstrapMethodError(msg, e);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn result;\n+/*[ENDIF] OPENJDK_METHODHANDLES*/\n+\t}\n+/*[ENDIF] Java11*/\n+\n+\t/*[IF ]*/\n+\t/*\n+\t * Used to preserve the new objectRef on the stack when avoiding the call-in for\n+\t * constructorHandles.  Must return 'this' so stackmapper will keep the object\n+\t * alive.\n+\t */\n+\t/*[ENDIF]*/\n+\t@SuppressWarnings(\"unused\")\n+\t@VMCONSTANTPOOL_METHOD\n+\tprivate static Object constructorPlaceHolder(Object newObjectRef) {\n+\t\treturn newObjectRef;\n+\t}\n+\n+\t/**\n+\t * Invoke bootstrap method with its static arguments\n+\t * @param bsm\n+\t * @param staticArgs\n+\t * @return result of bsm invocation\n+\t * @throws Throwable any throwable will be handled by the caller\n+\t */\n+\tprivate static final Object invokeBsm(MethodHandle bsm, Object[] staticArgs) throws Throwable {\n+\t\tObject result = null;\n+\t\t/* Take advantage of the per-MH asType cache */\n+\t\tswitch(staticArgs.length) {\n+\t\tcase 3:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2]);\n+\t\t\tbreak;\n+\t\tcase 4:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2], staticArgs[3]);\n+\t\t\tbreak;\n+\t\tcase 5:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2], staticArgs[3], staticArgs[4]);\n+\t\t\tbreak;\n+\t\tcase 6:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2], staticArgs[3], staticArgs[4], staticArgs[5]);\n+\t\t\tbreak;\n+\t\tcase 7:\n+\t\t\tresult = bsm.invoke(staticArgs[0], staticArgs[1], staticArgs[2], staticArgs[3], staticArgs[4], staticArgs[5], staticArgs[6]);\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tresult = bsm.invokeWithArguments(staticArgs);\n+\t\t\tbreak;\n+\t\t}\n+\t\treturn result;\n+\t}\n+\t\n+\t@SuppressWarnings(\"unused\")\n+\tprivate static final Object resolveInvokeDynamic(long j9class, String name, String methodDescriptor, long bsmData) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\tObject[] result = new Object[2];\n+\t\tMethodType type = null;\n+\n+\t\ttry {\n+\t\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\t\t\t\n+\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(methodDescriptor, access.getClassloader(classObject), null);\n+\n+\t\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\t\tif (null == bsm) {\n+\t\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\tObject[] staticArgs = new Object[bsmArgCount];\n+\n+\t\t\t/* Static optional arguments */\n+\t\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\t\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\t\tstaticArgs[i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t\t}\n+\n+\t\t\tObject[] appendixResult = new Object[1];\n+\t\t\tappendixResult[0] = null;\n+\t\t\ttry {\n+\t\t\t\tMemberName mname = MethodHandleNatives.linkCallSite(classObject, 0, bsm, name, type, (Object)staticArgs, appendixResult);\n+\n+\t\t\t\tresult[0] = mname;\n+\t\t\t\tresult[1] = appendixResult[0];\n+\t\t\t} catch (Throwable e) {\n+\t\t\t\tif (e instanceof Error) {\n+\t\t\t\t\tresult[0] = e;\n+\t\t\t\t} else {\n+\t\t\t\t\tresult[0] = new BootstrapMethodError(e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable e) {\n+\t\t\tresult[0] = e;\n+\t\t}\n+\n+\t\treturn (Object)result;\n+/*[ELSE]*/\t\n+\t\tMethodHandle result = null;\n+\t\tMethodType type = null;\n+\n+/*[IF !Java11]*/\n+\t\ttry {\n+/*[ENDIF]*/\n+\t\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\t\t\t\n+\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(methodDescriptor, access.getClassloader(classObject), null);\n+\t\t\tfinal MethodHandles.Lookup lookup = new MethodHandles.Lookup(classObject, false);\n+\t\t\ttry {\n+\t\t\t\tlookup.accessCheckArgRetTypes(type);\n+\t\t\t} catch (IllegalAccessException e) {\n+\t\t\t\tIllegalAccessError err = new IllegalAccessError();\n+\t\t\t\terr.initCause(e);\n+\t\t\t\tthrow err;\n+\t\t\t}\n+\t\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\t\tif (null == bsm) {\n+\t\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\tObject[] staticArgs = new Object[BSM_OPTIONAL_ARGUMENTS_START_INDEX + bsmArgCount];\n+\t\t\t/* Mandatory arguments */\n+\t\t\tstaticArgs[BSM_LOOKUP_ARGUMENT_INDEX] = lookup;\n+\t\t\tstaticArgs[BSM_NAME_ARGUMENT_INDEX] = name;\n+\t\t\tstaticArgs[BSM_TYPE_ARGUMENT_INDEX] = type;\n+\t\t\n+\t\t\t/* Static optional arguments */\n+\t\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\t\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\t\tstaticArgs[BSM_OPTIONAL_ARGUMENTS_START_INDEX + i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t\t}\n+\n+/*[IF Java11]*/\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires that exceptions from BSM invocation be wrapped in a BootstrapMethodError\n+\t\t * unless the exception thrown is a sub-class of Error.\n+\t\t * Exceptions thrown before invocation should be passed through unwrapped.\n+\t\t */\n+\t\ttry {\n+/*[ENDIF]*/\n+\t\t\tCallSite cs = (CallSite)invokeBsm(bsm, staticArgs);\n+\t\t\tif (cs != null) {\n+\t\t\t\tMethodType callsiteType = cs.type();\n+\t\t\t\tif (callsiteType != type) {\n+\t\t\t\t\tthrow WrongMethodTypeException.newWrongMethodTypeException(type, callsiteType);\n+\t\t\t\t}\n+\t\t\t\tresult = cs.dynamicInvoker();\n+\t\t\t} \n+\t\t\t/*[IF Java11]*/\n+\t\t\telse {\n+\t\t\t\t/* The result of the resolution of a dynamically-computed call site must not be null. */\n+\t\t\t\t/*[MSG \"K0A02\", \"Bootstrap method returned null.\"]*/\n+\t\t\t\tthrow new ClassCastException(Msg.getString(\"K0A02\")); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\t/*[ENDIF]*/\n+\t\t} catch(Throwable e) {\n+\n+\t\t\t/*[IF Sidecar19-SE]*/\n+\t\t\tif (e instanceof Error) {\n+\t\t\t\tthrow e;\n+\t\t\t}\n+\t\t\t/*[ENDIF]*/\n+\n+\t\t\tif (type == null) {\n+\t\t\t\tthrow new BootstrapMethodError(e);\n+\t\t\t}\n+\t\t\t\n+\t\t\t/* create an exceptionHandle with appropriate drop adapter and install that */\n+\t\t\ttry {\n+\t\t\t\tMethodHandle thrower = MethodHandles.throwException(type.returnType(), BootstrapMethodError.class);\n+\t\t\t\tMethodHandle constructor = MethodHandles.Lookup.IMPL_LOOKUP.findConstructor(BootstrapMethodError.class, MethodType.methodType(void.class, Throwable.class));\n+\t\t\t\tresult = MethodHandles.foldArguments(thrower, constructor.bindTo(e));\n+\t\t\t\tresult = MethodHandles.dropArguments(result, 0, type.parameterList()); \n+\t\t\t} catch (IllegalAccessException iae) {\n+\t\t\t\tthrow new Error(iae);\n+\t\t\t} catch (NoSuchMethodException nsme) {\n+\t\t\t\tthrow new Error(nsme);\n+\t\t\t}\n+\t\t}\n+\t\t\n+\t\treturn result;\n+/*[ENDIF] OPENJDK_METHODHANDLES*/\n+\t}\n+\n+\t@SuppressWarnings(\"unused\")\n+\t@VMCONSTANTPOOL_METHOD\n+\tprivate static final MethodHandle sendResolveMethodHandle(\n+\t\t\tint cpRefKind,\n+\t\t\tClass<?> currentClass,\n+\t\t\tClass<?> referenceClazz,\n+\t\t\tString name,\n+\t\t\tString typeDescriptor,\n+\t\t\tClassLoader loader) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\ttry {\n+\t\t\tMethodHandles.Lookup lookup = new MethodHandles.Lookup(currentClass);\n+\t\t\tMethodType type = null;\n+\t\t\tMethodHandle result = null;\n+\n+\t\t\tswitch (cpRefKind) {\n+\t\t\tcase 1: /* getField */\n+\t\t\t\tresult = lookup.findGetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 2: /* getStatic */\n+\t\t\t\tresult = lookup.findStaticGetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 3: /* putField */\n+\t\t\t\tresult = lookup.findSetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 4: /* putStatic */\n+\t\t\t\tresult = lookup.findStaticSetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 5: /* invokeVirtual */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tresult = lookup.findVirtual(referenceClazz, name, type);\n+\t\t\t\tbreak;\n+\t\t\tcase 6: /* invokeStatic */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tresult = lookup.findStatic(referenceClazz, name, type);\n+\t\t\t\tbreak;\n+\t\t\tcase 7: /* invokeSpecial */ \n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tresult = lookup.findSpecial(referenceClazz, name, type, currentClass);\n+\t\t\t\tbreak;\n+\t\t\tcase 8: /* newInvokeSpecial */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tresult = lookup.findConstructor(referenceClazz, type);\n+\t\t\t\tbreak;\n+\t\t\tcase 9: /* invokeInterface */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tresult = lookup.findVirtual(referenceClazz, name, type);\n+\t\t\t\tbreak;\n+\t\t\tdefault:\n+\t\t\t\t/* Can never happen */\n+\t\t\t\tthrow new UnsupportedOperationException();\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t} catch (IllegalAccessException iae) {\n+\t\t\t// Java spec expects an IllegalAccessError instead of IllegalAccessException thrown when an application attempts \n+\t\t\t// (not reflectively) to access or modify a field, or to invoke a method that it doesn't have access to.\n+\t\t\tthrow new IllegalAccessError(iae.getMessage()).initCause(iae);\n+\t\t}\n+/*[ELSE]*/\n+\t\ttry {\n+\t\t\tMethodHandles.Lookup lookup = new MethodHandles.Lookup(currentClass, false);\n+\t\t\tMethodType type = null;\n+\t\t\tMethodHandle result = null;\n+\n+\t\t\tswitch (cpRefKind) {\n+\t\t\tcase 1: /* getField */\n+\t\t\t\tresult = lookup.findGetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 2: /* getStatic */\n+\t\t\t\tresult = lookup.findStaticGetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 3: /* putField */\n+\t\t\t\tresult = lookup.findSetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 4: /* putStatic */\n+\t\t\t\tresult = lookup.findStaticSetter(referenceClazz, name, resolveFieldHandleHelper(typeDescriptor, lookup, loader));\n+\t\t\t\tbreak;\n+\t\t\tcase 5: /* invokeVirtual */\n+\t\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+\t\t\t\tlookup.accessCheckArgRetTypes(type);", "originalCommit": "628621af13063ff19389e32968006a10049e2edc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI1NDIyMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r504254221", "bodyText": "Comment added. sendResolveMethodHandle and resolveFieldHandleHelper shared between J9 and OJDK MH using preprocessor flags.", "author": "babsingh", "createdAt": "2020-10-13T20:57:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc2OTk2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc4NDkzNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r501784935", "bodyText": "Which PR has the code that does the invokedynamic?  I need to review that and this code at the same time to have any chance of telling if it's correct or not", "author": "DanHeidinga", "createdAt": "2020-10-08T14:51:43Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandleHelper.java", "diffHunk": "@@ -206,7 +206,54 @@ private static final Object invokeBsm(MethodHandle bsm, Object[] staticArgs) thr\n \t}\n \t\n \t@SuppressWarnings(\"unused\")\n-\tprivate static final MethodHandle resolveInvokeDynamic(long j9class, String name, String methodDescriptor, long bsmData) throws Throwable {\n+\tprivate static final Object resolveInvokeDynamic(long j9class, String name, String methodDescriptor, long bsmData) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\tObject[] result = new Object[2];\n+\t\tMethodType type = null;\n+\n+\t\ttry {\n+\t\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\t\t\t\n+\t\t\ttype = MethodType.vmResolveFromMethodDescriptorString(methodDescriptor, access.getClassloader(classObject), null);\n+\n+\t\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\t\tif (null == bsm) {\n+\t\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t\t}\n+\t\t\tObject[] staticArgs = new Object[bsmArgCount];\n+\n+\t\t\t/* Static optional arguments */\n+\t\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\t\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\t\tstaticArgs[i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t\t}\n+\n+\t\t\tObject[] appendixResult = new Object[1];\n+\t\t\tappendixResult[0] = null;\n+\t\t\ttry {\n+\t\t\t\tMemberName mname = MethodHandleNatives.linkCallSite(classObject, 0, bsm, name, type, (Object)staticArgs, appendixResult);\n+\n+\t\t\t\tresult[0] = mname;\n+\t\t\t\tresult[1] = appendixResult[0];\n+\t\t\t} catch (Throwable e) {\n+\t\t\t\tif (e instanceof Error) {\n+\t\t\t\t\tresult[0] = e;\n+\t\t\t\t} else {\n+\t\t\t\t\tresult[0] = new BootstrapMethodError(e);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} catch (Throwable e) {\n+\t\t\tresult[0] = e;", "originalCommit": "903a7cb3c4ca3cec1c5a9c3b187eed65bd932781", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc4OTQ5Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r501789497", "bodyText": "#10762: Has the changes for resolvesupport.cpp, callin.cpp, ...\n#10733: Has the BytecodeInterpreter changes for invokedynamic, invokehandle and new INLs", "author": "babsingh", "createdAt": "2020-10-08T14:57:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc4NDkzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTgwMDY5Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r501800693", "bodyText": "Looking at the bytecode changes, this requires a type check on every invokedynamic in the interpreter which I assume the JIT can avoid by checking at compile time:\nhttps://github.com/eclipse/openj9/blob/2e5ef9cf8a015cc34f59e10516c69b97bdfc3364/runtime/vm/BytecodeInterpreter.hpp#L8022-L8025\nWith the original J9 implementation, we resolved to a MH that dropped the incoming args and then threw the exception.  Can we not play the same trick here with the OJDK implementation?", "author": "DanHeidinga", "createdAt": "2020-10-08T15:12:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc4NDkzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTkyNjkxNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r501926915", "bodyText": "@DanHeidinga The OJDK implementation generates adapter method (memberName) to invoke a method handle.\nIf we want to use similar trick as current OpenJ9 impl, then we need to find a way to generate a MN that points to a method which accepts vararg input and throw last argument (ie. we place the exception object in the appendix slot).\nWe will have to investigate how to create such memberName in java.\n@babsingh do you have further insight on this?", "author": "fengxue-IS", "createdAt": "2020-10-08T18:26:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc4NDkzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTk2ODAxNA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r501968014", "bodyText": "No new insights. We should investigate/find how to generate a MN that points to a method which accepts vararg input and throw last argument (i.e. we place the exception object in the appendix slot). Adding this as a TODO task for the future once this PR is merged. I will also leave a comment in the code.", "author": "babsingh", "createdAt": "2020-10-08T19:39:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc4NDkzNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY3NjEzNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r505676136", "bodyText": "Added a TODO comment for the above task.", "author": "babsingh", "createdAt": "2020-10-15T16:24:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc4NDkzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc4NzAzNg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r501787036", "bodyText": "Is the only difference between the old and new paths that the new path calls linkDynamicConstant and the old calls result = (Object)invokeBsm(bsm, staticArgs);?  If so, please keep the 90% the same code the same and only preprocess to chose the correct call here", "author": "DanHeidinga", "createdAt": "2020-10-08T14:54:28Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandleHelper.java", "diffHunk": "@@ -98,6 +98,62 @@\n \n \t@SuppressWarnings(\"unused\")\n \tprivate static final Object resolveConstantDynamic(long j9class, String name, String fieldDescriptor, long bsmData) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\tObject result = null;\n+\n+\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\tObject internalRamClass = access.createInternalRamClass(j9class);\n+\t\tClass<?> classObject = getClassFromJ9Class(j9class);\n+\n+\t\tClass<?> typeClass = fromFieldDescriptorString(fieldDescriptor, access.getClassloader(classObject));\n+\n+\t\tint bsmIndex = UNSAFE.getShort(bsmData);\n+\t\tint bsmArgCount = UNSAFE.getShort(bsmData + BSM_ARGUMENT_COUNT_OFFSET);\n+\t\tlong bsmArgs = bsmData + BSM_ARGUMENTS_OFFSET;\n+\t\tMethodHandle bsm = getCPMethodHandleAt(internalRamClass, bsmIndex);\n+\t\tif (null == bsm) {\n+\t\t\t/*[MSG \"K05cd\", \"unable to resolve 'bootstrap_method_ref' in '{0}' at index {1}\"]*/\n+\t\t\tthrow new NullPointerException(Msg.getString(\"K05cd\", classObject.toString(), bsmIndex)); //$NON-NLS-1$\n+\t\t}\n+\t\tObject[] staticArgs = new Object[bsmArgCount];\n+\n+\t\t/* Static optional arguments */\n+\t\tint bsmTypeArgCount = bsm.type().parameterCount();\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires the first parameter of the bootstrap method to be java.lang.invoke.MethodHandles.Lookup\n+\t\t * else fail resolution with BootstrapMethodError\n+\t\t */\n+\t\tif (bsmTypeArgCount < 1 || MethodHandles.Lookup.class != bsm.type().parameterType(0)) {\n+\t\t\t/*[MSG \"K0A01\", \"Constant_Dynamic references bootstrap method '{0}' does not have java.lang.invoke.MethodHandles.Lookup as first parameter.\"]*/\n+\t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm)); //$NON-NLS-1$\n+\t\t}\n+\n+\t\tfor (int i = 0; i < bsmArgCount; i++) {\n+\t\t\tstaticArgs[i] = getAdditionalBsmArg(access, internalRamClass, classObject, bsm, bsmArgs, bsmTypeArgCount, i);\n+\t\t}\n+\n+\t\t/* JVMS JDK11 5.4.3.6 Dynamically-Computed Constant and Call Site Resolution\n+\t\t * requires that exceptions from BSM invocation be wrapped in a BootstrapMethodError\n+\t\t * unless the exception thrown is a sub-class of Error.\n+\t\t * Exceptions thrown before invocation should be passed through unwrapped.\n+\t\t */\n+\t\ttry {\n+\t\t\tresult = MethodHandleNatives.linkDynamicConstant(classObject, 0, bsm, name, typeClass, (Object)staticArgs);", "originalCommit": "89c5941d8f83c487c8edff2edc4277fb9a5ae718", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI1MzIzMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r504253230", "bodyText": "resolveConstantDynamic shared between J9 and OJDK MH using preprocessor flags.", "author": "babsingh", "createdAt": "2020-10-13T20:55:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTc4NzAzNg=="}], "type": "inlineReview"}, {"oid": "9bc3a7e58c4694499420deb5d74bc3d12e992fa7", "url": "https://github.com/eclipse-openj9/openj9/commit/9bc3a7e58c4694499420deb5d74bc3d12e992fa7", "message": "Disabling invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-10-13T20:23:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI0MDgxMQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r504240811", "bodyText": "What is the difference in output between the bsm's toString() and bsm.getMethodName()?", "author": "DanHeidinga", "createdAt": "2020-10-13T20:31:58Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandleResolver.java", "diffHunk": "@@ -129,21 +125,41 @@ private static final Object resolveConstantDynamic(long j9class, String name, St\n \t\t */\n \t\tif (bsmTypeArgCount < 1 || MethodHandles.Lookup.class != bsm.type().parameterType(0)) {\n \t\t\t/*[MSG \"K0A01\", \"Constant_Dynamic references bootstrap method '{0}' does not have java.lang.invoke.MethodHandles.Lookup as first parameter.\"]*/\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm)); //$NON-NLS-1$\n+/*[ELSE] OPENJDK_METHODHANDLES*/\n \t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm.getMethodName())); //$NON-NLS-1$", "originalCommit": "9bc3a7e58c4694499420deb5d74bc3d12e992fa7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyNTMyMA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r504925320", "bodyText": "bsm is a MethodHandle. OpenJDK MH doesn't have getMethodName. So, I replaced it with just bsm for the time being. MethodHandleInfo.getName() is an alternative, which would return the method name.\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            \t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm)); //$NON-NLS-1$\n          \n          \n            \n            /*[ELSE] OPENJDK_METHODHANDLES*/\n          \n          \n            \n            \t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm.getMethodName())); //$NON-NLS-1$\n          \n          \n            \n            \t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", Lookup.IMPL_LOOKUP.revealDirect(bsm).getName())); //$NON-NLS-1$\n          \n          \n            \n            /*[ELSE] OPENJDK_METHODHANDLES*/\n          \n          \n            \n            \t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm.getMethodName())); //$NON-NLS-1$", "author": "babsingh", "createdAt": "2020-10-14T19:37:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI0MDgxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY3NTcyOQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r505675729", "bodyText": "Changed to Lookup.IMPL_LOOKUP.revealDirect(bsm).getName() (OpenJDK), which is equivalent to MH.getMethodName() (OpenJ9).", "author": "babsingh", "createdAt": "2020-10-15T16:24:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI0MDgxMQ=="}], "type": "inlineReview"}, {"oid": "0684d74d066d85e8bada0b5c386d4094d0eaf8fc", "url": "https://github.com/eclipse-openj9/openj9/commit/0684d74d066d85e8bada0b5c386d4094d0eaf8fc", "message": "Disable invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-10-13T20:34:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI0MzE3Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r504243173", "bodyText": "The false indicates the Lookup object should skip the package check.  How does the equivalent behaviour get exposed in the OJDK Lookups?", "author": "DanHeidinga", "createdAt": "2020-10-13T20:36:30Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandleResolver.java", "diffHunk": "@@ -307,7 +373,14 @@ private static final MethodHandle sendResolveMethodHandle(\n \t\t\tString typeDescriptor,\n \t\t\tClassLoader loader) throws Throwable {\n \t\ttry {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\t\t/* OpenJDK Lookup does not have a constructor Lookup(Class<?>, boolean). So, it has been replaced\n+\t\t\t * with Lookup(Class<?>). */\n+\t\t\tMethodHandles.Lookup lookup = new MethodHandles.Lookup(currentClass);\n+/*[ELSE] OPENJDK_METHODHANDLES*/\n \t\t\tMethodHandles.Lookup lookup = new MethodHandles.Lookup(currentClass, false);\n+/*[ENDIF] OPENJDK_METHODHANDLES*/", "originalCommit": "0684d74d066d85e8bada0b5c386d4094d0eaf8fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDkyMzY5Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r504923697", "bodyText": "OpenJ9 does the package check for java.lang.invoke. (IAE) in the constructor, and it depends on the user input.\nIn OpenJDK, the package check is only done for the below methods before creating a new Lookup instance, and no user input is required:\n- public Lookup in(Class<?>)\n- public static Lookup privateLookupIn(Class<?>, Lookup)\n- public Lookup dropLookupMode(int)\n\nSo, OpenJDK does handle the package check.", "author": "babsingh", "createdAt": "2020-10-14T19:34:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI0MzE3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA2MDU3OA==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r506060578", "bodyText": "Does this pass all the required tests?", "author": "DanHeidinga", "createdAt": "2020-10-16T05:30:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI0MzE3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NjU0Mw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r506676543", "bodyText": "The builds with full testing haven't been enabled yet. I have added this as a TODO in #10913. Once the builds are enabled, I will confirm this. Based upon the available OpenJDK Lookup constructors and micro-test results, new MethodHandles.Lookup(Class<?>) (in OpenJDK) should be identical to new MethodHandles.Lookup(Class<?>, boolean) (in OpenJ9).", "author": "babsingh", "createdAt": "2020-10-16T19:19:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI0MzE3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI0MzU5Mg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r504243592", "bodyText": "please javadoc this function", "author": "DanHeidinga", "createdAt": "2020-10-13T20:37:15Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandleResolver.java", "diffHunk": "@@ -525,4 +622,25 @@ static long getJ9ClassFromClass(Class<?> c) {\n \t\t\treturn JITHELPERS.getJ9ClassFromClass64(c);\n \t\t}\n \t}\n+\n+\t@SuppressWarnings(\"unused\")\n+\tprivate static final Object linkCallerMethod(Class<?> callerClass, int refKind, Class<?> defc, String name, String type) throws Throwable {", "originalCommit": "0684d74d066d85e8bada0b5c386d4094d0eaf8fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTY3NDUyNQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r505674525", "bodyText": "added documentation.", "author": "babsingh", "createdAt": "2020-10-15T16:22:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNDI0MzU5Mg=="}], "type": "inlineReview"}, {"oid": "4c3ef5f82c4a32f94a443ec8b9c20d5d602c1ff4", "url": "https://github.com/eclipse-openj9/openj9/commit/4c3ef5f82c4a32f94a443ec8b9c20d5d602c1ff4", "message": "Disable invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-10-13T20:40:46Z", "type": "forcePushed"}, {"oid": "6d9aeb17944dc352db929d3543198ace345a2db7", "url": "https://github.com/eclipse-openj9/openj9/commit/6d9aeb17944dc352db929d3543198ace345a2db7", "message": "Disable invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-10-13T20:43:32Z", "type": "forcePushed"}, {"oid": "2534b206ab18a2809b3cbe65414b762a975dce39", "url": "https://github.com/eclipse-openj9/openj9/commit/2534b206ab18a2809b3cbe65414b762a975dce39", "message": "Disable invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-10-15T16:09:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA1NTgwNw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r506055807", "bodyText": "This is an error path that is very very unlikely to happen in production.  Use the common code sequence for both OJ9 & OJDK implementations\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n            /*[IF OPENJDK_METHODHANDLES]*/\n          \n          \n            \n            \t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", Lookup.IMPL_LOOKUP.revealDirect(bsm).getName())); //$NON-NLS-1$\n          \n          \n            \n            /*[ELSE] OPENJDK_METHODHANDLES*/\n          \n          \n            \n            \t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm.getMethodName())); //$NON-NLS-1$\n          \n          \n            \n            /*[ENDIF] OPENJDK_METHODHANDLES*/\n          \n          \n            \n            \t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", Lookup.IMPL_LOOKUP.revealDirect(bsm).getName())); //$NON-NLS-1$", "author": "DanHeidinga", "createdAt": "2020-10-16T05:12:59Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandleResolver.java", "diffHunk": "@@ -129,21 +125,41 @@ private static final Object resolveConstantDynamic(long j9class, String name, St\n \t\t */\n \t\tif (bsmTypeArgCount < 1 || MethodHandles.Lookup.class != bsm.type().parameterType(0)) {\n \t\t\t/*[MSG \"K0A01\", \"Constant_Dynamic references bootstrap method '{0}' does not have java.lang.invoke.MethodHandles.Lookup as first parameter.\"]*/\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", Lookup.IMPL_LOOKUP.revealDirect(bsm).getName())); //$NON-NLS-1$\n+/*[ELSE] OPENJDK_METHODHANDLES*/\n \t\t\tthrow new BootstrapMethodError(Msg.getString(\"K0A01\", bsm.getMethodName())); //$NON-NLS-1$\n+/*[ENDIF] OPENJDK_METHODHANDLES*/", "originalCommit": "2534b206ab18a2809b3cbe65414b762a975dce39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NDkwMg==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r506674902", "bodyText": "Updated to use the common code sequence.", "author": "babsingh", "createdAt": "2020-10-16T19:16:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA1NTgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA2MTY1MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r506061651", "bodyText": "Does this throw IllegalAccessException or IllegalAccessError for MHs that fail access checking?  The spec expects the Error version but at least with the OJ9 handles, we java code threw the Exception and we had to convert to the Error", "author": "DanHeidinga", "createdAt": "2020-10-16T05:34:16Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandleResolver.java", "diffHunk": "@@ -525,4 +623,46 @@ static long getJ9ClassFromClass(Class<?> c) {\n \t\t\treturn JITHELPERS.getJ9ClassFromClass64(c);\n \t\t}\n \t}\n+\n+\t/**\n+\t * Used during the invokehandle bytecode for resolving calls to the polymorphic\n+\t * MethodHandle and VarHandle methods. The resolution yields two values, which\n+\t * are returned in a two element array. The first array element is a MemberName\n+\t * object, which specifies the caller method to be invoked. The second array\n+\t * element is a MethodType object if the defining class is a MethodHandle and\n+\t * an AccessDescriptor object if the defining class is a VarHandle.\n+\t *\n+\t * This is only used for the OpenJDK MethodHandles, and an InternalError will\n+\t * be thrown if it is used for the OpenJ9 MethodHandles.\n+\t *\n+\t * @param callerClass the caller class\n+\t * @param refKind the reference kind used by the CONSTANT_MethodHandle entries\n+\t * @param definingClass the defining class\n+\t * @param name contains the method name\n+\t * @param type contains the method description\n+\t *\n+\t * @return a two element array, which contains the resolved values\n+\t *\n+\t * @throws InternalError if invoked for the OpenJ9 MethodHandles\n+\t */\n+\t@SuppressWarnings(\"unused\")\n+\tprivate static final Object linkCallerMethod(Class<?> callerClass, int refKind, Class<?> definingClass, String name, String type) throws Throwable {\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\tVMLangAccess access = VM.getVMLangAccess();\n+\t\tMethodType mt = MethodType.fromMethodDescriptorString(type, access.getClassloader(callerClass));\n+\n+\t\tObject[] result = new Object[2];\n+\t\tObject[] appendixResult = new Object[1];\n+\n+\t\t/* result[0] contains the MemberName object, which specifies the caller method (generated bytecodes). */\n+\t\tresult[0] = MethodHandleNatives.linkMethod(callerClass, refKind, definingClass, name, mt, appendixResult);", "originalCommit": "2534b206ab18a2809b3cbe65414b762a975dce39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY5MjQ3Nw==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r506692477", "bodyText": "MethodHandleNatives.linkMethod doesn't throw IllegalAccessException or IllegalAccessError.\nMHs that fail access checking should be handled by sendResolveMethodHandle. We have disabled the access checks since we don't have an alternative for accessCheckArgRetTypes. After looking at the code recently, I think sendResolveMethodHandle (in OpenJ9) should be replaced with MethodHandleNatives.linkMethodHandleConstant (in OpenJDK) since it handles all the error checking related to resolving a CONSTANT_MethodHandle entry. Added replacing sendResolveMethodHandle with MHN.linkMethodHandleConstant as a TODO in #10913.", "author": "babsingh", "createdAt": "2020-10-16T19:56:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA2MTY1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA2MjA5NQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r506062095", "bodyText": "Thanks for updating this comment - it's much clearer.  Is there an issue to track addressing this?", "author": "DanHeidinga", "createdAt": "2020-10-16T05:35:41Z", "path": "jcl/src/java.base/share/classes/java/lang/invoke/MethodHandleResolver.java", "diffHunk": "@@ -326,27 +400,47 @@ private static final MethodHandle sendResolveMethodHandle(\n \t\t\t\tbreak;\n \t\t\tcase 5: /* invokeVirtual */\n \t\t\t\ttype = MethodTypeHelper.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\t\t\t/* TODO: Investigate if an equivalent for lookup.accessCheckArgRetTypes is needed for OpenJDK MH. */\n+/*[ELSE] OPENJDK_METHODHANDLES*/\n \t\t\t\tlookup.accessCheckArgRetTypes(type);\n+/*[ENDIF] OPENJDK_METHODHANDLES*/\n \t\t\t\tresult = lookup.findVirtual(referenceClazz, name, type);\n \t\t\t\tbreak;\n \t\t\tcase 6: /* invokeStatic */\n \t\t\t\ttype = MethodTypeHelper.vmResolveFromMethodDescriptorString(typeDescriptor, loader, null);\n+/*[IF OPENJDK_METHODHANDLES]*/\n+\t\t\t\t/* TODO: Investigate if an equivalent for lookup.accessCheckArgRetTypes is needed for OpenJDK MH. */", "originalCommit": "2534b206ab18a2809b3cbe65414b762a975dce39", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY3NTE1MQ==", "url": "https://github.com/eclipse-openj9/openj9/pull/10830#discussion_r506675151", "bodyText": "Created #10913 to track all TODOs for the MethodHandleResolver class.", "author": "babsingh", "createdAt": "2020-10-16T19:16:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjA2MjA5NQ=="}], "type": "inlineReview"}, {"oid": "94b67ffab1c70fdb3689bc8c08af5ce149385312", "url": "https://github.com/eclipse-openj9/openj9/commit/94b67ffab1c70fdb3689bc8c08af5ce149385312", "message": "Disable invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-10-16T14:54:54Z", "type": "forcePushed"}, {"oid": "72d4325132269e1622894b3a8b315fc0e04815f5", "url": "https://github.com/eclipse-openj9/openj9/commit/72d4325132269e1622894b3a8b315fc0e04815f5", "message": "Disable invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-10-19T17:57:45Z", "type": "forcePushed"}, {"oid": "bddd2b936f8b01e725d8046846428cfe7c79fc56", "url": "https://github.com/eclipse-openj9/openj9/commit/bddd2b936f8b01e725d8046846428cfe7c79fc56", "message": "Add support for OpenJDK (OJDK) MethodHandle (MH) in MethodHandleResolver\n\n1. Update sendResolveMethodHandle and resolveFieldHandleHelper for OJDK MH\n\nFor OJDK MH, the usage of accessCheckArgRetTypes has been commented from\nsendResolveMethodHandle and resolveFieldHandleHelper since this method\nis not available in OpenJDK Lookup.\n\nTODO: Investigate if an equivalent for lookup.accessCheckArgRetTypes is\nneeded for OJDK MH. If needed, find an alternative for\nlookup.accessCheckArgRetTypes.\n\nOpenJDK Lookup does not have constructor Lookup(Class<?>, boolean). So,\nit has been replaced with constructor Lookup(Class<?>) in\nsendResolveMethodHandle.\n\n2. Add support to resolve invokedynamic under OpenJDK MethodHandles\n\nMethodHandleNatives.linkCallSite is used to resolve invokedynamic.\n\nThe resolved values are returned in a two element array. The first array\nelement is a MemberName object, and the second array element is a\nMethodHandle object.\n\nThe return type of resolveInvokeDynamic is changed to Object in order to\nsupport both the OpenJ9 and OpenJDK implementations for resolving\ninvokedynamic. For OpenJDK MethodHandles, the two element array is\ncasted to an Object before being returned. For OpenJ9 MethodHandles, the\nMethodHandle object automatically qualifies as an Object. The change in\nreturn type is reflected in vmconstantpool.xml.\n\n3. Add support to resolve constantdynamic under OpenJDK MethodHandles\n\nFor OpenJDK MethodHandles, MethodHandleNatives.linkDynamicConstant is\nused to resolve constantdynamic.\n\nThe resolve value is returned in the form of an Object, which is\nidentical to the OpenJ9 implementation.\n\n4. Add the implementation for linkCallerMethod\n\nlinkCallerMethod was previously named as resolveMethodHandle.\n\nIt's a wrapper for MethodHandleNatives.linkMethod. It is used in\ninvokehandle for MethodHandle and VarHandle polymorphic methods. The\nresolution yields two values. The two values are returned in a two\nelement array. The first array element is a MemberName object, which\nspecifies the caller method to be invoked. The second array element is a\nMethodType object if the defining class is a MethodHandle and an\nAccessDescriptor object if the defining class is a VarHandle.\n\nlinkCallerMethod is only needed for OJDK MH. InternalError will be\nthrown if it is invoked for OpenJ9 MH.\n\n5. Disable invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-10-20T23:09:03Z", "type": "commit"}, {"oid": "bddd2b936f8b01e725d8046846428cfe7c79fc56", "url": "https://github.com/eclipse-openj9/openj9/commit/bddd2b936f8b01e725d8046846428cfe7c79fc56", "message": "Add support for OpenJDK (OJDK) MethodHandle (MH) in MethodHandleResolver\n\n1. Update sendResolveMethodHandle and resolveFieldHandleHelper for OJDK MH\n\nFor OJDK MH, the usage of accessCheckArgRetTypes has been commented from\nsendResolveMethodHandle and resolveFieldHandleHelper since this method\nis not available in OpenJDK Lookup.\n\nTODO: Investigate if an equivalent for lookup.accessCheckArgRetTypes is\nneeded for OJDK MH. If needed, find an alternative for\nlookup.accessCheckArgRetTypes.\n\nOpenJDK Lookup does not have constructor Lookup(Class<?>, boolean). So,\nit has been replaced with constructor Lookup(Class<?>) in\nsendResolveMethodHandle.\n\n2. Add support to resolve invokedynamic under OpenJDK MethodHandles\n\nMethodHandleNatives.linkCallSite is used to resolve invokedynamic.\n\nThe resolved values are returned in a two element array. The first array\nelement is a MemberName object, and the second array element is a\nMethodHandle object.\n\nThe return type of resolveInvokeDynamic is changed to Object in order to\nsupport both the OpenJ9 and OpenJDK implementations for resolving\ninvokedynamic. For OpenJDK MethodHandles, the two element array is\ncasted to an Object before being returned. For OpenJ9 MethodHandles, the\nMethodHandle object automatically qualifies as an Object. The change in\nreturn type is reflected in vmconstantpool.xml.\n\n3. Add support to resolve constantdynamic under OpenJDK MethodHandles\n\nFor OpenJDK MethodHandles, MethodHandleNatives.linkDynamicConstant is\nused to resolve constantdynamic.\n\nThe resolve value is returned in the form of an Object, which is\nidentical to the OpenJ9 implementation.\n\n4. Add the implementation for linkCallerMethod\n\nlinkCallerMethod was previously named as resolveMethodHandle.\n\nIt's a wrapper for MethodHandleNatives.linkMethod. It is used in\ninvokehandle for MethodHandle and VarHandle polymorphic methods. The\nresolution yields two values. The two values are returned in a two\nelement array. The first array element is a MemberName object, which\nspecifies the caller method to be invoked. The second array element is a\nMethodType object if the defining class is a MethodHandle and an\nAccessDescriptor object if the defining class is a VarHandle.\n\nlinkCallerMethod is only needed for OJDK MH. InternalError will be\nthrown if it is invoked for OpenJ9 MH.\n\n5. Disable invokeBsm for OJDK MH\n\ninvokeBsm is unused for OpenJDK MethodHandles.\n\nCo-authored-by: Jack Lu <Jack.S.Lu@ibm.com>\nSigned-off-by: Babneet Singh <sbabneet@ca.ibm.com>", "committedDate": "2020-10-20T23:09:03Z", "type": "forcePushed"}]}