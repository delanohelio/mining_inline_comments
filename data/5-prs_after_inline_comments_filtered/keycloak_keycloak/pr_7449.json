{"pr_number": 7449, "pr_title": "[KEYCLOAK-14255] - More improvements to CLI", "pr_createdAt": "2020-09-25T00:21:50Z", "pr_url": "https://github.com/keycloak/keycloak/pull/7449", "timeline": [{"oid": "1f6e2fdb95830200d6de17dddfa7d0a8331c2542", "url": "https://github.com/keycloak/keycloak/commit/1f6e2fdb95830200d6de17dddfa7d0a8331c2542", "message": "[KEYCLOAK-14255] - More improvements to CLI", "committedDate": "2020-09-25T00:21:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc3Mjg3NQ==", "url": "https://github.com/keycloak/keycloak/pull/7449#discussion_r494772875", "bodyText": "Nitpick: There is no need for this import? It seems it is not used anywhere. But I don't consider this as a PR blocker :)", "author": "mposolda", "createdAt": "2020-09-25T06:26:03Z", "path": "quarkus/runtime/src/main/java/org/keycloak/configuration/PropertyMappers.java", "diffHunk": "@@ -25,6 +25,7 @@\n import java.util.function.Predicate;\n import java.util.stream.Collectors;\n \n+import com.google.common.base.Ascii;", "originalCommit": "1f6e2fdb95830200d6de17dddfa7d0a8331c2542", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDc4Mjg0OA==", "url": "https://github.com/keycloak/keycloak/pull/7449#discussion_r494782848", "bodyText": "Instead of this hardcoded list, we can maybe have some collection of those commands? Also it may be nice to have some class like \"QuarkusConstants\", so that we can use something like \"!QuarkusConstants.KC_CONFIG_FILE.equals(name)\" instead of \"!\"kc.config.file\".equals(name) ?\nHowever I don't consider this as a blocker for this PR, but rather something for later :-)", "author": "mposolda", "createdAt": "2020-09-25T06:51:03Z", "path": "quarkus/runtime/src/main/java/org/keycloak/quarkus/KeycloakRecorder.java", "diffHunk": "@@ -106,57 +109,102 @@ public void configSessionFactory(\n         QuarkusKeycloakSessionFactory.setInstance(new QuarkusKeycloakSessionFactory(factories, defaultProviders, reaugmented));\n     }\n \n-    public void setBuildTimeProperties(Map<String, String> buildTimeProperties, Boolean rebuild, String configArgs) {\n+    /**\n+     * <p>Validate the build time properties with any property passed during runtime in order to advertise any difference with the\n+     * server image state.\n+     * \n+     * <p>This method also keep the build time properties available at runtime.\n+     * \n+     * \n+     * @param buildTimeProperties the build time properties set when running the last re-augmentation\n+     * @param rebuild indicates whether or not the server was re-augmented\n+     * @param configArgs the configuration args if provided when the server was re-augmented\n+     */\n+    public void validateAndSetBuildTimeProperties(Map<String, String> buildTimeProperties, Boolean rebuild, String configArgs) {\n         BUILD_TIME_PROPERTIES = buildTimeProperties;\n         String configHelpText = configArgs;\n \n         for (String propertyName : getConfig().getPropertyNames()) {\n-            if (!propertyName.startsWith(MicroProfileConfigProvider.NS_KEYCLOAK_PREFIX)) {\n+            // we should only validate if there is a server image and if the property is a runtime property\n+            if (!shouldValidate(propertyName, rebuild)) {\n                 continue;\n             }\n \n-            String buildValue = Environment.getBuiltTimeProperty(propertyName).orElseGet(new Supplier<String>() {\n-                @Override \n-                public String get() {\n-                    return Environment.getBuiltTimeProperty(PropertyMappers.toCLIFormat(propertyName)).orElse(null);\n-                }\n+            // try to resolve any property set using profiles\n+            if (propertyName.startsWith(\"%\")) {\n+                propertyName = propertyName.substring(propertyName.indexOf('.') + 1);\n+            }\n+\n+            String finalPropertyName = propertyName;\n+            String buildValue = Environment.getBuiltTimeProperty(PropertyMappers.toCLIFormat(finalPropertyName))\n+                    .orElseGet(new Supplier<String>() {\n+                        @Override \n+                        public String get() {\n+                            return Environment.getBuiltTimeProperty(finalPropertyName).orElse(null);\n+                        }\n             });\n \n             ConfigValue value = getConfig().getConfigValue(propertyName);\n+            \n+            // if no value found we try to resolve using the CLI format\n+            if (value == null || value.getValue() == null) {\n+                value = getConfig().getConfigValue(PropertyMappers.toCLIFormat(propertyName));\n+            }\n \n-            if (buildValue != null && isRuntimeValue(value) && !buildValue.equalsIgnoreCase(value.getValue())) {\n+            if (value.getValue() != null && !value.getValue().equalsIgnoreCase(buildValue)) {\n                 if (configHelpText != null) {\n-                    String currentProp = \"--\" + PropertyMappers.toCLIFormat(propertyName).substring(3) + \"=\" + buildValue;\n-                    String newProp = \"--\" + PropertyMappers.toCLIFormat(propertyName).substring(3) + \"=\" + value.getValue();\n-                    \n-                    if (configHelpText.contains(currentProp)) {\n-                        LOGGER.warnf(\"The new value [%s] of the property [%s] in [%s] differs from the value [%s] set into the server image. The new value will override the value set into the server image.\", value.getValue(), propertyName, value.getConfigSourceName(), buildValue);\n-                        configHelpText = configHelpText.replaceAll(currentProp, newProp);\n-                    } else if (!configHelpText.contains(\"--\" + PropertyMappers.toCLIFormat(propertyName).substring(3))) {\n-                        configHelpText += newProp;\n+                    if (buildValue != null) {\n+                        String currentProp =\n+                                \"--\" + PropertyMappers.toCLIFormat(propertyName).substring(3) + \"=\" + buildValue;\n+                        String newProp =\n+                                \"--\" + PropertyMappers.toCLIFormat(propertyName).substring(3) + \"=\" + value.getValue();\n+\n+                        if (configHelpText.contains(currentProp)) {\n+                            LOGGER.warnf(\"The new value [%s] of the property [%s] in [%s] differs from the value [%s] set into the server image. The new value will override the value set into the server image.\",\n+                                    value.getValue(), propertyName, value.getConfigSourceName(), buildValue);\n+                            configHelpText = configHelpText.replaceAll(currentProp, newProp);\n+                        } else if (!configHelpText\n+                                .contains(\"--\" + PropertyMappers.toCLIFormat(propertyName).substring(3))) {\n+                            LOGGER.warnf(\"The new value [%s] of the property [%s] in [%s] differs from the value [%s] set into the server image. The new value will override the value set into the server image.\",\n+                                    value.getValue(), propertyName, value.getConfigSourceName(), buildValue);\n+                            configHelpText += \" \" + newProp;\n+                        }\n+                    } else if (!BUILD_TIME_PROPERTIES.keySet().stream()\n+                            .anyMatch(new Predicate<String>() {\n+                                @Override\n+                                public boolean test(String s) {\n+                                    return PropertyMappers.canonicalFormat(finalPropertyName)\n+                                            .equalsIgnoreCase(PropertyMappers.canonicalFormat(s));\n+                                }\n+                            })) {\n+                        String prop = \"--\" + PropertyMappers.toCLIFormat(propertyName).substring(3) + \"=\" + value.getValue();\n+\n+                        if (!configHelpText.contains(prop)) {\n+                            LOGGER.warnf(\"New property [%s] set with value [%s] in [%s]. This property is not persisted into the server image.\",\n+                                    propertyName, value.getValue(), value.getConfigSourceName(), buildValue);\n+                            configHelpText += \" \" + prop;\n+                        }\n                     }\n                 }\n-            } else if (configHelpText != null && rebuild && isRuntimeValue(value)) {\n-                String prop = \"--\" + PropertyMappers.toCLIFormat(propertyName).substring(3) + \"=\" + value.getValue();\n-\n-                if (!configHelpText.contains(prop)) {\n-                    LOGGER.infof(\"New property [%s] set with value [%s] in [%s]. This property is not persisted into the server image.\",\n-                            propertyName, value.getValue(), value.getConfigSourceName(), buildValue);\n-                    configHelpText += \" \" + prop;\n-                }\n             }\n         }\n \n         if (configArgs != null && !configArgs.equals(configHelpText)) {\n-            LOGGER.infof(\"Please, run the 'config' command if you want to configure the server image with the new property values:\\n\\t%s config %s\", Environment.getCommand(), String.join(\" \", configHelpText.split(\",\")));\n+            LOGGER.warnf(\"Please, run the 'config' command if you want to persist the new configuration into the server image:\\n\\n\\t%s config %s\\n\", Environment.getCommand(), String.join(\" \", configHelpText.split(\",\")));\n         }\n     }\n \n-    private boolean isRuntimeValue(ConfigValue value) {\n-        String name = value.getName();\n-        return value.getValue() != null && !PropertyMappers.isBuildTimeProperty(name)\n-                && !\"kc.version\".equals(name) && !\"kc.config.args\".equals(\n-                name) && !\"kc.home.dir\".equals(name);\n+    private boolean shouldValidate(String name, boolean rebuild) {\n+        return rebuild && name.contains(MicroProfileConfigProvider.NS_KEYCLOAK_PREFIX) \n+                && (!PropertyMappers.isBuildTimeProperty(name)\n+                && !\"kc.version\".equals(name) ", "originalCommit": "1f6e2fdb95830200d6de17dddfa7d0a8331c2542", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}