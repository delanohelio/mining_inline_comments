{"pr_number": 7425, "pr_title": "KEYCLOAK-15450 Complement methods for accessing realms with Stream va\u2026", "pr_createdAt": "2020-09-16T08:06:03Z", "pr_url": "https://github.com/keycloak/keycloak/pull/7425", "timeline": [{"oid": "da136dd1571ad99b0a5f0a36758da71ce4ba7446", "url": "https://github.com/keycloak/keycloak/commit/da136dd1571ad99b0a5f0a36758da71ce4ba7446", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-16T10:08:47Z", "type": "forcePushed"}, {"oid": "6101e3407d7623782ac5f8ae90fb027c5db991b3", "url": "https://github.com/keycloak/keycloak/commit/6101e3407d7623782ac5f8ae90fb027c5db991b3", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-17T09:33:48Z", "type": "forcePushed"}, {"oid": "06efa3fd25351830973019b7751bf2c5ca2db07a", "url": "https://github.com/keycloak/keycloak/commit/06efa3fd25351830973019b7751bf2c5ca2db07a", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-18T13:22:01Z", "type": "forcePushed"}, {"oid": "00135c2a18266dc541801d2943e4a7c5daead89f", "url": "https://github.com/keycloak/keycloak/commit/00135c2a18266dc541801d2943e4a7c5daead89f", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-21T14:09:42Z", "type": "forcePushed"}, {"oid": "2a2b4c2ec3bf985020dc1218dde17f434d30883a", "url": "https://github.com/keycloak/keycloak/commit/2a2b4c2ec3bf985020dc1218dde17f434d30883a", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-22T06:19:23Z", "type": "forcePushed"}, {"oid": "14be7cb2d43201a72828a8823a4f3f6a1cadce39", "url": "https://github.com/keycloak/keycloak/commit/14be7cb2d43201a72828a8823a4f3f6a1cadce39", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-22T14:43:14Z", "type": "forcePushed"}, {"oid": "4ebf4e5aa8ab0213289079f015de237a51a072fe", "url": "https://github.com/keycloak/keycloak/commit/4ebf4e5aa8ab0213289079f015de237a51a072fe", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-22T14:45:39Z", "type": "forcePushed"}, {"oid": "524f0e993521ba2a1a8fc01cfb6d49b6fae8db2f", "url": "https://github.com/keycloak/keycloak/commit/524f0e993521ba2a1a8fc01cfb6d49b6fae8db2f", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-23T15:10:35Z", "type": "forcePushed"}, {"oid": "6609c3586be187dd2ed5e7b6a2a87f7a71d36e12", "url": "https://github.com/keycloak/keycloak/commit/6609c3586be187dd2ed5e7b6a2a87f7a71d36e12", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-25T16:27:17Z", "type": "forcePushed"}, {"oid": "c1f6dc034b30016ebd69d3672846633fabc5333f", "url": "https://github.com/keycloak/keycloak/commit/c1f6dc034b30016ebd69d3672846633fabc5333f", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-29T08:24:13Z", "type": "forcePushed"}, {"oid": "d09343696edde423ae7cec4360ecd4d6c1ecdd6a", "url": "https://github.com/keycloak/keycloak/commit/d09343696edde423ae7cec4360ecd4d6c1ecdd6a", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-29T12:31:39Z", "type": "forcePushed"}, {"oid": "c7c7d987c91c52b392e23f41db53541ddeceac38", "url": "https://github.com/keycloak/keycloak/commit/c7c7d987c91c52b392e23f41db53541ddeceac38", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-29T16:05:59Z", "type": "forcePushed"}, {"oid": "59cbfa8d184508e14dd79edf317cde79547d2251", "url": "https://github.com/keycloak/keycloak/commit/59cbfa8d184508e14dd79edf317cde79547d2251", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-29T18:25:58Z", "type": "forcePushed"}, {"oid": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "url": "https://github.com/keycloak/keycloak/commit/ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-09-30T13:59:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU3MjEwNA==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497572104", "bodyText": "I'm usually not a fan of star imports, but not sure what the code policy in keycloak is.", "author": "sguilhen", "createdAt": "2020-09-30T14:49:32Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -17,14 +17,9 @@\n \n package org.keycloak.storage.ldap;\n \n-import java.util.ArrayList;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n+import java.util.*;", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU3MjYwNg==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497572606", "bodyText": "Same, not sure if we should be changing that.", "author": "sguilhen", "createdAt": "2020-09-30T14:50:11Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -58,10 +53,7 @@\n import org.keycloak.storage.ldap.idm.query.internal.LDAPQueryConditionsBuilder;\n import org.keycloak.storage.ldap.idm.store.ldap.LDAPIdentityStore;\n import org.keycloak.storage.ldap.kerberos.LDAPProviderKerberosConfig;\n-import org.keycloak.storage.ldap.mappers.LDAPStorageMapper;\n-import org.keycloak.storage.ldap.mappers.LDAPStorageMapperManager;\n-import org.keycloak.storage.ldap.mappers.PasswordUpdateCallback;\n-import org.keycloak.storage.ldap.mappers.LDAPOperationDecorator;\n+import org.keycloak.storage.ldap.mappers.*;", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU3OTM4NQ==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497579385", "bodyText": "If I'm reading this right, this change works because there can be only one enabled default required action provider for the real. Is that the case?", "author": "sguilhen", "createdAt": "2020-09-30T14:58:28Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProvider.java", "diffHunk": "@@ -286,11 +283,13 @@ public UserModel addUser(RealmModel realm, String username) {\n \n         realm.getDefaultGroupsStream().forEach(proxy::joinGroup);\n \n-        for (RequiredActionProviderModel r : realm.getRequiredActionProviders()) {\n-            if (r.isEnabled() && r.isDefaultAction()) {\n-                proxy.addRequiredAction(r.getAlias());\n-            }\n-        }\n+        Optional<String> requiredAction = realm.getRequiredActionProvidersStream()\n+                .filter(RequiredActionProviderModel::isEnabled)\n+                .filter(RequiredActionProviderModel::isDefaultAction)\n+                .map(RequiredActionProviderModel::getAlias)\n+                .findFirst();\n+        if (requiredAction.isPresent())\n+            proxy.addRequiredAction(requiredAction.get());", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA4Nzk3Nw==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498087977", "bodyText": "Looking more into this, I think I wrongly understood the original method. I'm changing it to realm.getRequiredActionProvidersStream() .filter(RequiredActionProviderModel::isEnabled) .filter(RequiredActionProviderModel::isDefaultAction) .map(RequiredActionProviderModel::getAlias) .forEach(proxy::addRequiredAction);  which should have the same semantic.", "author": "martin-kanis", "createdAt": "2020-10-01T08:55:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU3OTM4NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODQ1NzM5NA==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498457394", "bodyText": "Yeah, I agree with you here. I remember seeing something very similar in another class, I'll try to locate it so you can fix both places if needed", "author": "sguilhen", "createdAt": "2020-10-01T19:06:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU3OTM4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU4Nzc2MA==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497587760", "bodyText": "Suggestion: This can be replaced by LDAPConfigDecorator.isInstance() in a single statement\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                return mapperFactory instanceof LDAPConfigDecorator;\n          \n          \n            \n                                LDAPConfigDecorator.isInstance(session.getKeycloakSessionFactory()\n          \n          \n            \n                                        .getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId()));", "author": "sguilhen", "createdAt": "2020-09-30T15:09:10Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProviderFactory.java", "diffHunk": "@@ -241,17 +233,19 @@ public LDAPStorageProvider create(KeycloakSession session, ComponentModel model)\n     // Check if it's some performance overhead to create this map in every request. But probably not...\n     protected Map<ComponentModel, LDAPConfigDecorator> getLDAPConfigDecorators(KeycloakSession session, ComponentModel ldapModel) {\n         RealmModel realm = session.realms().getRealm(ldapModel.getParentId());\n-        List<ComponentModel> mapperComponents = realm.getComponents(ldapModel.getId(), LDAPStorageMapper.class.getName());\n-\n-        Map<ComponentModel, LDAPConfigDecorator> result = new HashMap<>();\n-        for (ComponentModel mapperModel : mapperComponents) {\n-            LDAPStorageMapperFactory mapperFactory = (LDAPStorageMapperFactory) session.getKeycloakSessionFactory().getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId());\n-            if (mapperFactory instanceof LDAPConfigDecorator) {\n-                result.put(mapperModel, (LDAPConfigDecorator) mapperFactory);\n-            }\n-        }\n-\n-        return result;\n+        return realm.getComponentsStream(ldapModel.getId(), LDAPStorageMapper.class.getName())\n+                .filter(mapperModel -> {\n+                    LDAPStorageMapperFactory mapperFactory = (LDAPStorageMapperFactory) session.getKeycloakSessionFactory()\n+                            .getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId());\n+                    return mapperFactory instanceof LDAPConfigDecorator;", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA4MTgzNg==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498081836", "bodyText": "maybe like this? mapperModel -> session.getKeycloakSessionFactory() .getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId()) instanceof LDAPConfigDecorator", "author": "martin-kanis", "createdAt": "2020-10-01T08:45:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzU4Nzc2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY3OTk1Mw==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497679953", "bodyText": "I'm not 100% sure, but couldn't this be handled with\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                                    HashMap::putAll);\n          \n          \n            \n                                    .collect(Collectors.toMap(Function.identity, mapperModel -> (LDAPConfigDecorator) session.getKeycloakSessionFactory()\n          \n          \n            \n                                            .getProviderFactory(LDAPStorageManager.class, mapperModel.getProviderId())));\n          \n      \n    \n    \n  \n\nJust suggesting something off the top of myhead, syntax might be a bit off", "author": "sguilhen", "createdAt": "2020-09-30T17:24:31Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProviderFactory.java", "diffHunk": "@@ -241,17 +233,19 @@ public LDAPStorageProvider create(KeycloakSession session, ComponentModel model)\n     // Check if it's some performance overhead to create this map in every request. But probably not...\n     protected Map<ComponentModel, LDAPConfigDecorator> getLDAPConfigDecorators(KeycloakSession session, ComponentModel ldapModel) {\n         RealmModel realm = session.realms().getRealm(ldapModel.getParentId());\n-        List<ComponentModel> mapperComponents = realm.getComponents(ldapModel.getId(), LDAPStorageMapper.class.getName());\n-\n-        Map<ComponentModel, LDAPConfigDecorator> result = new HashMap<>();\n-        for (ComponentModel mapperModel : mapperComponents) {\n-            LDAPStorageMapperFactory mapperFactory = (LDAPStorageMapperFactory) session.getKeycloakSessionFactory().getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId());\n-            if (mapperFactory instanceof LDAPConfigDecorator) {\n-                result.put(mapperModel, (LDAPConfigDecorator) mapperFactory);\n-            }\n-        }\n-\n-        return result;\n+        return realm.getComponentsStream(ldapModel.getId(), LDAPStorageMapper.class.getName())\n+                .filter(mapperModel -> {\n+                    LDAPStorageMapperFactory mapperFactory = (LDAPStorageMapperFactory) session.getKeycloakSessionFactory()\n+                            .getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId());\n+                    return mapperFactory instanceof LDAPConfigDecorator;\n+                })\n+                .collect(HashMap::new,\n+                        (map, mapperModel) -> {\n+                            LDAPStorageMapperFactory mapperFactory = (LDAPStorageMapperFactory) session.getKeycloakSessionFactory()\n+                                    .getProviderFactory(LDAPStorageMapper.class, mapperModel.getProviderId());\n+                            map.put(mapperModel, (LDAPConfigDecorator) mapperFactory);\n+                        },\n+                        HashMap::putAll);", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA4MTEyMg==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498081122", "bodyText": "Yeah, I used your suggestion.", "author": "martin-kanis", "createdAt": "2020-10-01T08:44:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY3OTk1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzczOTM4Mg==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497739382", "bodyText": "Question: since this returns a sorted stream, shouldn't every use of this method that consumes the stream with forEach use forEachOrdered instead? If order was relevant in the original list-based implementation I believe we need to pay attention to that.\nAlso, if order is important shouldn't the Javadoc in the interface mention that the returned stream is sorted and that if order is important forEachOrdered should be used when consuming the stream?", "author": "sguilhen", "createdAt": "2020-09-30T19:10:16Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java", "diffHunk": "@@ -1725,15 +1669,13 @@ public AuthenticationFlowModel addAuthenticationFlow(AuthenticationFlowModel mod\n     }\n \n     @Override\n-    public List<AuthenticationExecutionModel> getAuthenticationExecutions(String flowId) {\n+    public Stream<AuthenticationExecutionModel> getAuthenticationExecutionsStream(String flowId) {\n         AuthenticationFlowEntity flow = em.getReference(AuthenticationFlowEntity.class, flowId);\n \n         return flow.getExecutions().stream()\n                 .filter(e -> getId().equals(e.getRealm().getId()))\n                 .map(this::entityToModel)\n-                .sorted(AuthenticationExecutionModel.ExecutionComparator.SINGLETON)\n-                .collect(Collectors.collectingAndThen(\n-                        Collectors.toList(), Collections::unmodifiableList));\n+                .sorted(AuthenticationExecutionModel.ExecutionComparator.SINGLETON);", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODEwNjgyOQ==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498106829", "bodyText": "I think you are right. I switched to forEachOrdered from forEach in each usage. One concern which I have is whether the corresponding methods in infinispan/RealmAdapter will preserve the ordering in case the data was cached.", "author": "martin-kanis", "createdAt": "2020-10-01T09:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzczOTM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE4NDYwMA==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498184600", "bodyText": "Yeah, I was also wondering about that.", "author": "sguilhen", "createdAt": "2020-10-01T11:52:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzczOTM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzczOTY2NA==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497739664", "bodyText": "Same here regarding the sorted stream.", "author": "sguilhen", "createdAt": "2020-09-30T19:10:48Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java", "diffHunk": "@@ -1973,15 +1909,10 @@ public void updateRequiredActionProvider(RequiredActionProviderModel model) {\n     }\n \n     @Override\n-    public List<RequiredActionProviderModel> getRequiredActionProviders() {\n-        Collection<RequiredActionProviderEntity> entities = realm.getRequiredActionProviders();\n-        if (entities.isEmpty()) return Collections.EMPTY_LIST;\n-        List<RequiredActionProviderModel> actions = new LinkedList<>();\n-        for (RequiredActionProviderEntity entity : entities) {\n-            actions.add(entityToModel(entity));\n-        }\n-        Collections.sort(actions, RequiredActionProviderModel.RequiredActionComparator.SINGLETON);\n-        return Collections.unmodifiableList(actions);\n+    public Stream<RequiredActionProviderModel> getRequiredActionProvidersStream() {\n+        return realm.getRequiredActionProviders().stream()\n+                .map(this::entityToModel)\n+                .sorted(RequiredActionProviderModel.RequiredActionComparator.SINGLETON);", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc3NDI0OQ==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497774249", "bodyText": "shouldn't this be else if (e.isAlternative()) instead?", "author": "sguilhen", "createdAt": "2020-09-30T20:16:14Z", "path": "services/src/main/java/org/keycloak/authentication/ClientAuthenticationFlow.java", "diffHunk": "@@ -106,19 +104,22 @@ public Response processFlow() {\n     }\n \n     protected List<AuthenticationExecutionModel> findExecutionsToRun() {\n-        List<AuthenticationExecutionModel> executions = processor.getRealm().getAuthenticationExecutions(flow.getId());\n-        List<AuthenticationExecutionModel> executionsToRun = new ArrayList<>();\n-\n-        for (AuthenticationExecutionModel execution : executions) {\n-            if (execution.isRequired()) {\n-                executionsToRun = Arrays.asList(execution);\n-                break;\n-            }\n+        List<AuthenticationExecutionModel> executionsToRun = new LinkedList<>();\n+        List<AuthenticationExecutionModel> finalExecutionsToRun = executionsToRun;\n+        Optional<AuthenticationExecutionModel> first = processor.getRealm().getAuthenticationExecutionsStream(flow.getId())\n+                .filter(e -> {\n+                    if (e.isRequired()) {\n+                        return true;\n+                    } else {", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODEwMjYxMw==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498102613", "bodyText": "Yeah, good catch!", "author": "martin-kanis", "createdAt": "2020-10-01T09:20:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc3NDI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc5Njg2Mg==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497796862", "bodyText": "Is this change here for performance reasons?", "author": "sguilhen", "createdAt": "2020-09-30T20:59:19Z", "path": "services/src/main/java/org/keycloak/authentication/authenticators/conditional/ConditionalUserConfiguredAuthenticator.java", "diffHunk": "@@ -1,7 +1,8 @@\n package org.keycloak.authentication.authenticators.conditional;\n \n-import java.util.ArrayList;\n+import java.util.LinkedList;", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA4MDQzOA==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498080438", "bodyText": "Correct", "author": "martin-kanis", "createdAt": "2020-10-01T08:43:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzc5Njg2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg2Mjg0Mg==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497862842", "bodyText": "is this method used? Search for usages came up empty. Probably intended to be used in the first filter at the top of the file?", "author": "sguilhen", "createdAt": "2020-09-30T23:53:33Z", "path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/TokenEndpoint.java", "diffHunk": "@@ -1349,6 +1343,18 @@ private String generateS256CodeChallenge(String codeVerifier) throws Exception {\n         return codeVerifierEncoded;\n     }\n \n+    private boolean isExternal(IdentityProviderModel idpModel, String issuer) {\n+        IdentityProviderFactory factory = IdentityBrokerService.getIdentityProviderFactory(session, idpModel);\n+        IdentityProvider idp = factory.create(session, idpModel);\n+        if (idp instanceof ExchangeExternalToken) {\n+            ExchangeExternalToken external = (ExchangeExternalToken) idp;\n+            if (idpModel.getAlias().equals(issuer) || external.isIssuer(issuer, formParams)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA4MDMxMg==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498080312", "bodyText": "It was unsuccessful attempt to put that filter inside a method and I forgot to remove it at the end.", "author": "martin-kanis", "createdAt": "2020-10-01T08:43:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzg2Mjg0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk1MTM2MA==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497951360", "bodyText": "Is this used in this class?", "author": "sguilhen", "createdAt": "2020-10-01T02:33:55Z", "path": "services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java", "diffHunk": "@@ -3,6 +3,7 @@\n import com.fasterxml.jackson.annotation.JsonIgnore;\n import org.jboss.logging.Logger;\n import org.jboss.resteasy.annotations.cache.NoCache;\n+import org.keycloak.TokenVerifier;", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk1MjQxNA==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497952414", "bodyText": "Just out of curiosity, why the usage of flatMap here?", "author": "sguilhen", "createdAt": "2020-10-01T02:38:33Z", "path": "services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java", "diffHunk": "@@ -228,29 +226,23 @@ public CredentialTypeMetadata getMetadata() {\n     // Going through all authentication flows and their authentication executions to see if there is any authenticator of the corresponding\n     // credential type.\n     private Set<String> getEnabledCredentialTypes(List<CredentialProvider> credentialProviders) {\n-        Set<String> enabledCredentialTypes = new HashSet<>();\n-\n-        for (AuthenticationFlowModel flow : realm.getAuthenticationFlows()) {\n-            // Ignore DISABLED executions and flows\n-            if (isFlowEffectivelyDisabled(flow)) continue;\n-\n-            for (AuthenticationExecutionModel execution : realm.getAuthenticationExecutions(flow.getId())) {\n-                if (execution.getAuthenticator() != null && DISABLED != execution.getRequirement()) {\n-                    AuthenticatorFactory authenticatorFactory = (AuthenticatorFactory) session.getKeycloakSessionFactory().getProviderFactory(Authenticator.class, execution.getAuthenticator());\n-                    if (authenticatorFactory != null && authenticatorFactory.getReferenceCategory() != null) {\n-                        enabledCredentialTypes.add(authenticatorFactory.getReferenceCategory());\n-                    }\n-                }\n-            }\n-        }\n+        Stream<String> enabledCredentialTypes = realm.getAuthenticationFlowsStream()\n+                .filter(((Predicate<AuthenticationFlowModel>) this::isFlowEffectivelyDisabled).negate())\n+                .flatMap(flow ->", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA3OTA0NQ==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498079045", "bodyText": "We have here a stream of streams and we need to return just flat set of strings.", "author": "martin-kanis", "createdAt": "2020-10-01T08:40:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk1MjQxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE4MzYzNg==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498183636", "bodyText": "Yeah, but that could have been handled with map only, no? I was mainly curious why flatMap (instead of map) is used since I don't see the need to ensure the underlying stream gets closed, but I might be missing something.", "author": "sguilhen", "createdAt": "2020-10-01T11:50:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk1MjQxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDUzODEyNw==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r500538127", "bodyText": "Sorry @martin-kanis, I misinterpreted the code. You are right, we have a stream of streams, so we need to flatten them into a single one. Nothing to change here.", "author": "sguilhen", "createdAt": "2020-10-06T19:17:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk1MjQxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk2NTY3Mw==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r497965673", "bodyText": "Is it necessary to call collect here?", "author": "sguilhen", "createdAt": "2020-10-01T03:37:25Z", "path": "services/src/main/java/org/keycloak/services/resources/admin/IdentityProviderResource.java", "diffHunk": "@@ -133,10 +125,8 @@ public Response delete() {\n         session.users().preRemove(realm, identityProviderModel);\n         this.realm.removeIdentityProviderByAlias(alias);\n \n-        Set<IdentityProviderMapperModel> mappers = this.realm.getIdentityProviderMappersByAlias(alias);\n-        for (IdentityProviderMapperModel mapper : mappers) {\n-            this.realm.removeIdentityProviderMapper(mapper);\n-        }\n+        realm.getIdentityProviderMappersByAliasStream(alias)\n+                .collect(Collectors.toList()).forEach(realm::removeIdentityProviderMapper);", "originalCommit": "ecb1aa1fcbffe3aee331dfca61ddc21161a948e9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODA3OTUwNA==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498079504", "bodyText": "Yes, otherwise it throws ConcurrentModificationException.", "author": "martin-kanis", "createdAt": "2020-10-01T08:41:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk2NTY3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5ODE4NDA3MQ==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r498184071", "bodyText": "Ah ok, thanks!", "author": "sguilhen", "createdAt": "2020-10-01T11:51:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Nzk2NTY3Mw=="}], "type": "inlineReview"}, {"oid": "0d1b52ca25d277ae58f6db932c1ab9babcb7d68b", "url": "https://github.com/keycloak/keycloak/commit/0d1b52ca25d277ae58f6db932c1ab9babcb7d68b", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-01T07:46:11Z", "type": "forcePushed"}, {"oid": "3dc79672e3752ba00839f2543d30aa12f4842385", "url": "https://github.com/keycloak/keycloak/commit/3dc79672e3752ba00839f2543d30aa12f4842385", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-01T09:38:25Z", "type": "forcePushed"}, {"oid": "46fc6d69d097d08688d912ad4fe7d699085aed78", "url": "https://github.com/keycloak/keycloak/commit/46fc6d69d097d08688d912ad4fe7d699085aed78", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-01T15:02:34Z", "type": "forcePushed"}, {"oid": "8e15cbaf9bdfa768868caccfebcba91f728ac6a2", "url": "https://github.com/keycloak/keycloak/commit/8e15cbaf9bdfa768868caccfebcba91f728ac6a2", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-01T19:35:39Z", "type": "forcePushed"}, {"oid": "224b86d3acae4e23ed71157cf6ca2982fa45bec5", "url": "https://github.com/keycloak/keycloak/commit/224b86d3acae4e23ed71157cf6ca2982fa45bec5", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-02T09:29:20Z", "type": "forcePushed"}, {"oid": "da00a88cb2315f11f9d5279b56a85bba954cbddf", "url": "https://github.com/keycloak/keycloak/commit/da00a88cb2315f11f9d5279b56a85bba954cbddf", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-02T12:20:26Z", "type": "forcePushed"}, {"oid": "74b8ce308cc023d69a2e3cd8df6c2e77f3ff3460", "url": "https://github.com/keycloak/keycloak/commit/74b8ce308cc023d69a2e3cd8df6c2e77f3ff3460", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-02T16:10:02Z", "type": "forcePushed"}, {"oid": "cf356b30bda94a2ed0d7f999a3268276b36ae822", "url": "https://github.com/keycloak/keycloak/commit/cf356b30bda94a2ed0d7f999a3268276b36ae822", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-05T16:40:32Z", "type": "forcePushed"}, {"oid": "e48ead63ab0b0542f2098d7c5227dfcf0d833620", "url": "https://github.com/keycloak/keycloak/commit/e48ead63ab0b0542f2098d7c5227dfcf0d833620", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-05T19:24:29Z", "type": "forcePushed"}, {"oid": "416b096d687466a6a31c20bbb65a1e86682b6c66", "url": "https://github.com/keycloak/keycloak/commit/416b096d687466a6a31c20bbb65a1e86682b6c66", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-06T05:52:33Z", "type": "forcePushed"}, {"oid": "130e5c87b145f4da7631d38e6d4b496461b288e5", "url": "https://github.com/keycloak/keycloak/commit/130e5c87b145f4da7631d38e6d4b496461b288e5", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-06T08:02:25Z", "type": "forcePushed"}, {"oid": "f3dfc34234153377a8ab4d41836d16a19c273ff1", "url": "https://github.com/keycloak/keycloak/commit/f3dfc34234153377a8ab4d41836d16a19c273ff1", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-06T10:56:31Z", "type": "forcePushed"}, {"oid": "e53827dedd14ebf38a5f9e2060dad84c9839c51e", "url": "https://github.com/keycloak/keycloak/commit/e53827dedd14ebf38a5f9e2060dad84c9839c51e", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-06T12:36:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYwMjU0NQ==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r502602545", "bodyText": "Star import that was reverted in previous classes is used here", "author": "sguilhen", "createdAt": "2020-10-09T18:25:17Z", "path": "federation/ldap/src/main/java/org/keycloak/storage/ldap/LDAPStorageProviderFactory.java", "diffHunk": "@@ -47,24 +47,17 @@\n import org.keycloak.storage.ldap.idm.query.internal.LDAPQuery;\n import org.keycloak.storage.ldap.idm.query.internal.LDAPQueryConditionsBuilder;\n import org.keycloak.storage.ldap.idm.store.ldap.LDAPIdentityStore;\n-import org.keycloak.storage.ldap.mappers.FullNameLDAPStorageMapper;\n-import org.keycloak.storage.ldap.mappers.FullNameLDAPStorageMapperFactory;\n-import org.keycloak.storage.ldap.mappers.HardcodedLDAPAttributeMapper;\n-import org.keycloak.storage.ldap.mappers.HardcodedLDAPAttributeMapperFactory;\n-import org.keycloak.storage.ldap.mappers.LDAPConfigDecorator;\n-import org.keycloak.storage.ldap.mappers.LDAPStorageMapper;\n-import org.keycloak.storage.ldap.mappers.LDAPStorageMapperFactory;\n-import org.keycloak.storage.ldap.mappers.UserAttributeLDAPStorageMapper;\n-import org.keycloak.storage.ldap.mappers.UserAttributeLDAPStorageMapperFactory;\n+import org.keycloak.storage.ldap.mappers.*;", "originalCommit": "e53827dedd14ebf38a5f9e2060dad84c9839c51e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYwNTk1OQ==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r502605959", "bodyText": "Javadoc for new method?", "author": "sguilhen", "createdAt": "2020-10-09T18:32:15Z", "path": "server-spi-private/src/main/java/org/keycloak/events/EventQuery.java", "diffHunk": "@@ -43,6 +45,13 @@\n \n     EventQuery maxResults(int results);\n \n-    List<Event> getResultList();\n+    /**\n+     * @deprecated Use {@link #getResultStream() getResultStream} instead.\n+     */\n+    @Deprecated\n+    default List<Event> getResultList() {\n+        return getResultStream().collect(Collectors.toList());\n+    }\n \n+    Stream<Event> getResultStream();", "originalCommit": "e53827dedd14ebf38a5f9e2060dad84c9839c51e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYwNjEzNQ==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r502606135", "bodyText": "Javadoc for new method?", "author": "sguilhen", "createdAt": "2020-10-09T18:32:37Z", "path": "server-spi-private/src/main/java/org/keycloak/events/admin/AdminEventQuery.java", "diffHunk": "@@ -127,8 +129,12 @@\n \n     /**\n      * Executes the query and returns the results\n-     * \n-     * @return\n+     * @deprecated Use {@link #getResultStream() getResultStream} instead.\n      */\n-    List<AdminEvent> getResultList();\n+    @Deprecated\n+    default List<AdminEvent> getResultList() {\n+        return getResultStream().collect(Collectors.toList());\n+    }\n+\n+    Stream<AdminEvent> getResultStream();", "originalCommit": "e53827dedd14ebf38a5f9e2060dad84c9839c51e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjYyNjAxMw==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r502626013", "bodyText": "Star import", "author": "sguilhen", "createdAt": "2020-10-09T19:15:21Z", "path": "services/src/main/java/org/keycloak/authentication/ClientAuthenticationFlow.java", "diffHunk": "@@ -27,9 +27,7 @@\n import org.keycloak.services.ServicesLogger;\n \n import javax.ws.rs.core.Response;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.List;\n+import java.util.*;", "originalCommit": "e53827dedd14ebf38a5f9e2060dad84c9839c51e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY4MjcxNw==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r502682717", "bodyText": "Why are these changes part of this PR? What does it have to do with the realms?", "author": "sguilhen", "createdAt": "2020-10-09T21:39:46Z", "path": "services/src/main/java/org/keycloak/credential/UserCredentialStoreManager.java", "diffHunk": "@@ -347,50 +334,38 @@ private UserStorageCredentialConfigured isConfiguredThroughUserStorage(RealmMode\n \n     @Override\n     public boolean isConfiguredLocally(RealmModel realm, UserModel user, String type) {\n-        List<CredentialInputValidator> credentialProviders = getCredentialProviders(session, realm, CredentialInputValidator.class);\n-        for (CredentialInputValidator validator : credentialProviders) {\n-            if (validator.supportsCredentialType(type) && validator.isConfiguredFor(realm, user, type)) {\n-                return true;\n-            }\n-\n-        }\n-        return false;\n+        return getCredentialProviders(session, CredentialInputValidator.class)\n+                .anyMatch(validator -> validator.supportsCredentialType(type) && validator.isConfiguredFor(realm, user, type));\n     }\n \n     @Override\n     public CredentialValidationOutput authenticate(KeycloakSession session, RealmModel realm, CredentialInput input) {\n-        List<CredentialAuthentication> list = UserStorageManager.getEnabledStorageProviders(session, realm, CredentialAuthentication.class);\n-        for (CredentialAuthentication auth : list) {\n-            if (auth.supportsCredentialAuthenticationFor(input.getType())) {\n-                CredentialValidationOutput output = auth.authenticate(realm, input);\n-                if (output != null) return output;\n-            }\n-        }\n+        CredentialValidationOutput output = authenticate(\n+                UserStorageManager.getEnabledStorageProviders(session, realm, CredentialAuthentication.class),\n+                realm, input);\n \n-        list = getCredentialProviders(session, realm, CredentialAuthentication.class);\n-        for (CredentialAuthentication auth : list) {\n-            if (auth.supportsCredentialAuthenticationFor(input.getType())) {\n-                CredentialValidationOutput output = auth.authenticate(realm, input);\n-                if (output != null) return output;\n-            }\n-        }\n+        return (output != null) ? output : authenticate(getCredentialProviders(session, CredentialAuthentication.class),\n+                realm, input);\n+    }\n \n-        return null;\n+    public CredentialValidationOutput authenticate(Stream<CredentialAuthentication> storageProviders,\n+                                                       RealmModel realm, CredentialInput input) {\n+        return storageProviders\n+                .filter(auth -> auth.supportsCredentialAuthenticationFor(input.getType()))\n+                .map(auth -> auth.authenticate(realm, input))\n+                .filter(Objects::nonNull)\n+                .findFirst()\n+                .orElse(null);\n     }\n \n     @Override\n     public void onCache(RealmModel realm, CachedUserModel user, UserModel delegate) {\n-        List<OnUserCache> credentialProviders = getCredentialProviders(session, realm, OnUserCache.class);\n-        for (OnUserCache validator : credentialProviders) {\n-            validator.onCache(realm, user, delegate);\n-        }\n+        getCredentialProviders(session, OnUserCache.class).forEach(validator -> validator.onCache(realm, user, delegate));\n     }\n \n     @Override\n     public List<String> getConfiguredUserStorageCredentialTypes(RealmModel realm, UserModel user) {\n-        List<CredentialProvider> credentialProviders = getCredentialProviders(session, realm, CredentialProvider.class);\n-\n-        return credentialProviders.stream().map(CredentialProvider::getType)\n+        return getCredentialProviders(session, CredentialProvider.class).map(CredentialProvider::getType)\n                 .filter(credentialType -> UserStorageCredentialConfigured.CONFIGURED == isConfiguredThroughUserStorage(realm, user, credentialType))\n                 .collect(Collectors.toList());\n     }", "originalCommit": "e53827dedd14ebf38a5f9e2060dad84c9839c51e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzExNjg0MA==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r503116840", "bodyText": "As part of RealmModel streamification I changed RealmModel.getUserStorageProviders to use streams. Then I refactored all the code which use that method. In this case it's used in UserCredentialStoreManager.authenticate (indirectly via UserStorageManager.getEnabledStorageProviders) which also uses getCredentialProviders. Changing getCredentialProviders to streams helped me to simplify the code. Does it make sense to you or you prefer to revert this part?", "author": "martin-kanis", "createdAt": "2020-10-12T08:16:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY4MjcxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY4NTM0MA==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r502685340", "bodyText": "Star import", "author": "sguilhen", "createdAt": "2020-10-09T21:50:38Z", "path": "services/src/main/java/org/keycloak/services/resources/account/AccountFormService.java", "diffHunk": "@@ -102,15 +101,8 @@\n import java.net.URI;\n import java.nio.charset.StandardCharsets;\n import java.security.MessageDigest;\n-import java.util.ArrayList;\n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.HashSet;\n-import java.util.Iterator;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Set;\n-import java.util.UUID;\n+import java.util.*;", "originalCommit": "e53827dedd14ebf38a5f9e2060dad84c9839c51e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjY4NjU1MA==", "url": "https://github.com/keycloak/keycloak/pull/7425#discussion_r502686550", "bodyText": "Star import", "author": "sguilhen", "createdAt": "2020-10-09T21:56:20Z", "path": "services/src/main/java/org/keycloak/services/resources/admin/AuthenticationManagementResource.java", "diffHunk": "@@ -64,12 +64,10 @@\n import javax.ws.rs.core.MediaType;\n import javax.ws.rs.core.Response;\n import javax.ws.rs.core.UriBuilder;\n-import java.util.Collections;\n-import java.util.HashMap;\n-import java.util.LinkedList;\n-import java.util.List;\n-import java.util.Map;\n-import java.util.Optional;\n+import java.util.*;", "originalCommit": "e53827dedd14ebf38a5f9e2060dad84c9839c51e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1fbb7e49687f67317d20c229039c9b7692dc8a33", "url": "https://github.com/keycloak/keycloak/commit/1fbb7e49687f67317d20c229039c9b7692dc8a33", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-12T08:17:44Z", "type": "commit"}, {"oid": "1fbb7e49687f67317d20c229039c9b7692dc8a33", "url": "https://github.com/keycloak/keycloak/commit/1fbb7e49687f67317d20c229039c9b7692dc8a33", "message": "KEYCLOAK-15450 Complement methods for accessing realms with Stream variants", "committedDate": "2020-10-12T08:17:44Z", "type": "forcePushed"}]}