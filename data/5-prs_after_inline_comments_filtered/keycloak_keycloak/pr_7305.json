{"pr_number": 7305, "pr_title": "KEYCLOAK-14811 KEYCLOAK-14812 RoleProvider, RoleStorageManager", "pr_createdAt": "2020-07-30T12:44:32Z", "pr_url": "https://github.com/keycloak/keycloak/pull/7305", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk5MDczMA==", "url": "https://github.com/keycloak/keycloak/pull/7305#discussion_r462990730", "bodyText": "This method doesn't exist in RoleProvider interface.", "author": "mhajas", "createdAt": "2020-07-30T13:21:03Z", "path": "services/src/main/java/org/keycloak/storage/RoleStorageManager.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.storage;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Stream;\n+import org.jboss.logging.Logger;\n+import org.keycloak.common.util.reflections.Types;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelException;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.storage.role.RoleLookupProvider;\n+import org.keycloak.storage.role.RoleStorageProvider;\n+import org.keycloak.storage.role.RoleStorageProviderFactory;\n+import org.keycloak.storage.role.RoleStorageProviderModel;\n+import org.keycloak.utils.ServicesUtils;\n+\n+public class RoleStorageManager implements RoleProvider {\n+    private static final Logger logger = Logger.getLogger(RoleStorageManager.class);\n+\n+    protected KeycloakSession session;\n+\n+    private final long roleStorageProviderTimeout;\n+\n+    public RoleStorageManager(KeycloakSession session, long roleStorageProviderTimeout) {\n+        this.session = session;\n+        this.roleStorageProviderTimeout = roleStorageProviderTimeout;\n+    }\n+\n+    public static boolean isStorageProviderEnabled(RealmModel realm, String providerId) {\n+        RoleStorageProviderModel model = getStorageProviderModel(realm, providerId);\n+        return model.isEnabled();\n+    }\n+\n+    public static RoleStorageProviderModel getStorageProviderModel(RealmModel realm, String componentId) {\n+        ComponentModel model = realm.getComponent(componentId);\n+        if (model == null) return null;\n+        return new RoleStorageProviderModel(model);\n+    }\n+\n+    public static RoleStorageProvider getStorageProvider(KeycloakSession session, RealmModel realm, String componentId) {\n+        ComponentModel model = realm.getComponent(componentId);\n+        if (model == null) return null;\n+        RoleStorageProviderModel storageModel = new RoleStorageProviderModel(model);\n+        RoleStorageProviderFactory factory = (RoleStorageProviderFactory)session.getKeycloakSessionFactory().getProviderFactory(RoleStorageProvider.class, model.getProviderId());\n+        if (factory == null) {\n+            throw new ModelException(\"Could not find RoletStorageProviderFactory for: \" + model.getProviderId());\n+        }\n+        return getStorageProviderInstance(session, storageModel, factory);\n+    }\n+\n+\n+    public static List<RoleStorageProviderModel> getStorageProviders(RealmModel realm) {\n+        return realm.getRoleStorageProviders();\n+    }\n+\n+    public static RoleStorageProvider getStorageProviderInstance(KeycloakSession session, RoleStorageProviderModel model, RoleStorageProviderFactory factory) {\n+        RoleStorageProvider instance = (RoleStorageProvider)session.getAttribute(model.getId());\n+        if (instance != null) return instance;\n+        instance = factory.create(session, model);\n+        if (instance == null) {\n+            throw new IllegalStateException(\"RoleStorageProvideFactory (of type \" + factory.getClass().getName() + \") produced a null instance\");\n+        }\n+        session.enlistForClose(instance);\n+        session.setAttribute(model.getId(), instance);\n+        return instance;\n+    }\n+\n+\n+    public static <T> List<T> getStorageProviders(KeycloakSession session, RealmModel realm, Class<T> type) {\n+        List<T> list = new LinkedList<>();\n+        for (RoleStorageProviderModel model : getStorageProviders(realm)) {\n+            RoleStorageProviderFactory factory = (RoleStorageProviderFactory) session.getKeycloakSessionFactory().getProviderFactory(RoleStorageProvider.class, model.getProviderId());\n+            if (factory == null) {\n+                logger.warnv(\"Configured RoleStorageProvider {0} of provider id {1} does not exist in realm {2}\", model.getName(), model.getProviderId(), realm.getName());\n+                continue;\n+            }\n+            if (Types.supports(type, factory, RoleStorageProviderFactory.class)) {\n+                list.add(type.cast(getStorageProviderInstance(session, model, factory)));\n+            }\n+\n+\n+        }\n+        return list;\n+    }\n+\n+\n+    public static <T> List<T> getEnabledStorageProviders(KeycloakSession session, RealmModel realm, Class<T> type) {\n+        List<T> list = new LinkedList<>();\n+        for (RoleStorageProviderModel model : getStorageProviders(realm)) {\n+            if (!model.isEnabled()) continue;\n+            RoleStorageProviderFactory factory = (RoleStorageProviderFactory) session.getKeycloakSessionFactory().getProviderFactory(RoleStorageProvider.class, model.getProviderId());\n+            if (factory == null) {\n+                logger.warnv(\"Configured RoleStorageProvider {0} of provider id {1} does not exist in realm {2}\", model.getName(), model.getProviderId(), realm.getName());\n+                continue;\n+            }\n+            if (Types.supports(type, factory, RoleStorageProviderFactory.class)) {\n+                list.add(type.cast(getStorageProviderInstance(session, model, factory)));\n+            }\n+        }\n+        return list;\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String name) {\n+        return session.roleLocalStorage().addRealmRole(realm, name);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {\n+        return session.roleLocalStorage().addRealmRole(realm, id, name);\n+    }\n+\n+    @Override\n+    public RoleModel getRealmRole(RealmModel realm, String name) {\n+        RoleModel realmRole = session.roleLocalStorage().getRealmRole(realm, name);\n+        if (realmRole != null) return realmRole;\n+        for (RoleLookupProvider enabledStorageProvider : getEnabledStorageProviders(session, realm, RoleLookupProvider.class)) {\n+            realmRole = enabledStorageProvider.getRealmRole(realm, name);\n+            if (realmRole != null) return realmRole;\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public RoleModel getRoleById(RealmModel realm, String id) {\n+        StorageId storageId = new StorageId(id);\n+        if (storageId.getProviderId() == null) {\n+            return session.roleLocalStorage().getRoleById(realm, id);\n+        }\n+        RoleLookupProvider provider = (RoleLookupProvider)getStorageProvider(session, realm, storageId.getProviderId());\n+        if (provider == null) return null;\n+        if (! isStorageProviderEnabled(realm, storageId.getProviderId())) return null;\n+        return provider.getRoleById(realm, id);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {\n+        return session.roleLocalStorage().getRealmRolesStream(realm, first, max);\n+    }\n+\n+    /**\n+     * Obtaining roles from an external role storage is time-bounded. In case the external role storage\n+     * isn't available at least roles from a local storage are returned. For this purpose\n+     * the {@link org.keycloak.services.DefaultKeycloakSessionFactory#getRoleStorageProviderTimeout()} property is used.\n+     * Default value is 3000 milliseconds and it's configurable.\n+     * See {@link org.keycloak.services.DefaultKeycloakSessionFactory} for details.\n+     */\n+    @Override\n+    public Stream<RoleModel> searchForRolesStream(RealmModel realm, String search, Integer first, Integer max) {\n+        Stream<RoleModel> local = session.roleLocalStorage().searchForRolesStream(realm, search, first, max);\n+        Stream<RoleModel> ext = getEnabledStorageProviders(session, realm, RoleLookupProvider.class).stream()\n+                .flatMap(ServicesUtils.timeBound(session,\n+                        roleStorageProviderTimeout,\n+                        p -> ((RoleLookupProvider) p).searchForRolesStream(realm, search, first, max)));\n+\n+        return Stream.concat(local, ext);\n+    }\n+\n+    @Override", "originalCommit": "949396acc6b1cd44a6d6c7f858273c5fb95e5498", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk5MDk1Mg==", "url": "https://github.com/keycloak/keycloak/pull/7305#discussion_r462990952", "bodyText": "We should use removeRole(role).", "author": "mhajas", "createdAt": "2020-07-30T13:21:24Z", "path": "services/src/main/java/org/keycloak/storage/RoleStorageManager.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.storage;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Stream;\n+import org.jboss.logging.Logger;\n+import org.keycloak.common.util.reflections.Types;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelException;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.storage.role.RoleLookupProvider;\n+import org.keycloak.storage.role.RoleStorageProvider;\n+import org.keycloak.storage.role.RoleStorageProviderFactory;\n+import org.keycloak.storage.role.RoleStorageProviderModel;\n+import org.keycloak.utils.ServicesUtils;\n+\n+public class RoleStorageManager implements RoleProvider {\n+    private static final Logger logger = Logger.getLogger(RoleStorageManager.class);\n+\n+    protected KeycloakSession session;\n+\n+    private final long roleStorageProviderTimeout;\n+\n+    public RoleStorageManager(KeycloakSession session, long roleStorageProviderTimeout) {\n+        this.session = session;\n+        this.roleStorageProviderTimeout = roleStorageProviderTimeout;\n+    }\n+\n+    public static boolean isStorageProviderEnabled(RealmModel realm, String providerId) {\n+        RoleStorageProviderModel model = getStorageProviderModel(realm, providerId);\n+        return model.isEnabled();\n+    }\n+\n+    public static RoleStorageProviderModel getStorageProviderModel(RealmModel realm, String componentId) {\n+        ComponentModel model = realm.getComponent(componentId);\n+        if (model == null) return null;\n+        return new RoleStorageProviderModel(model);\n+    }\n+\n+    public static RoleStorageProvider getStorageProvider(KeycloakSession session, RealmModel realm, String componentId) {\n+        ComponentModel model = realm.getComponent(componentId);\n+        if (model == null) return null;\n+        RoleStorageProviderModel storageModel = new RoleStorageProviderModel(model);\n+        RoleStorageProviderFactory factory = (RoleStorageProviderFactory)session.getKeycloakSessionFactory().getProviderFactory(RoleStorageProvider.class, model.getProviderId());\n+        if (factory == null) {\n+            throw new ModelException(\"Could not find RoletStorageProviderFactory for: \" + model.getProviderId());\n+        }\n+        return getStorageProviderInstance(session, storageModel, factory);\n+    }\n+\n+\n+    public static List<RoleStorageProviderModel> getStorageProviders(RealmModel realm) {\n+        return realm.getRoleStorageProviders();\n+    }\n+\n+    public static RoleStorageProvider getStorageProviderInstance(KeycloakSession session, RoleStorageProviderModel model, RoleStorageProviderFactory factory) {\n+        RoleStorageProvider instance = (RoleStorageProvider)session.getAttribute(model.getId());\n+        if (instance != null) return instance;\n+        instance = factory.create(session, model);\n+        if (instance == null) {\n+            throw new IllegalStateException(\"RoleStorageProvideFactory (of type \" + factory.getClass().getName() + \") produced a null instance\");\n+        }\n+        session.enlistForClose(instance);\n+        session.setAttribute(model.getId(), instance);\n+        return instance;\n+    }\n+\n+\n+    public static <T> List<T> getStorageProviders(KeycloakSession session, RealmModel realm, Class<T> type) {\n+        List<T> list = new LinkedList<>();\n+        for (RoleStorageProviderModel model : getStorageProviders(realm)) {\n+            RoleStorageProviderFactory factory = (RoleStorageProviderFactory) session.getKeycloakSessionFactory().getProviderFactory(RoleStorageProvider.class, model.getProviderId());\n+            if (factory == null) {\n+                logger.warnv(\"Configured RoleStorageProvider {0} of provider id {1} does not exist in realm {2}\", model.getName(), model.getProviderId(), realm.getName());\n+                continue;\n+            }\n+            if (Types.supports(type, factory, RoleStorageProviderFactory.class)) {\n+                list.add(type.cast(getStorageProviderInstance(session, model, factory)));\n+            }\n+\n+\n+        }\n+        return list;\n+    }\n+\n+\n+    public static <T> List<T> getEnabledStorageProviders(KeycloakSession session, RealmModel realm, Class<T> type) {\n+        List<T> list = new LinkedList<>();\n+        for (RoleStorageProviderModel model : getStorageProviders(realm)) {\n+            if (!model.isEnabled()) continue;\n+            RoleStorageProviderFactory factory = (RoleStorageProviderFactory) session.getKeycloakSessionFactory().getProviderFactory(RoleStorageProvider.class, model.getProviderId());\n+            if (factory == null) {\n+                logger.warnv(\"Configured RoleStorageProvider {0} of provider id {1} does not exist in realm {2}\", model.getName(), model.getProviderId(), realm.getName());\n+                continue;\n+            }\n+            if (Types.supports(type, factory, RoleStorageProviderFactory.class)) {\n+                list.add(type.cast(getStorageProviderInstance(session, model, factory)));\n+            }\n+        }\n+        return list;\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String name) {\n+        return session.roleLocalStorage().addRealmRole(realm, name);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {\n+        return session.roleLocalStorage().addRealmRole(realm, id, name);\n+    }\n+\n+    @Override\n+    public RoleModel getRealmRole(RealmModel realm, String name) {\n+        RoleModel realmRole = session.roleLocalStorage().getRealmRole(realm, name);\n+        if (realmRole != null) return realmRole;\n+        for (RoleLookupProvider enabledStorageProvider : getEnabledStorageProviders(session, realm, RoleLookupProvider.class)) {\n+            realmRole = enabledStorageProvider.getRealmRole(realm, name);\n+            if (realmRole != null) return realmRole;\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public RoleModel getRoleById(RealmModel realm, String id) {\n+        StorageId storageId = new StorageId(id);\n+        if (storageId.getProviderId() == null) {\n+            return session.roleLocalStorage().getRoleById(realm, id);\n+        }\n+        RoleLookupProvider provider = (RoleLookupProvider)getStorageProvider(session, realm, storageId.getProviderId());\n+        if (provider == null) return null;\n+        if (! isStorageProviderEnabled(realm, storageId.getProviderId())) return null;\n+        return provider.getRoleById(realm, id);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {\n+        return session.roleLocalStorage().getRealmRolesStream(realm, first, max);\n+    }\n+\n+    /**\n+     * Obtaining roles from an external role storage is time-bounded. In case the external role storage\n+     * isn't available at least roles from a local storage are returned. For this purpose\n+     * the {@link org.keycloak.services.DefaultKeycloakSessionFactory#getRoleStorageProviderTimeout()} property is used.\n+     * Default value is 3000 milliseconds and it's configurable.\n+     * See {@link org.keycloak.services.DefaultKeycloakSessionFactory} for details.\n+     */\n+    @Override\n+    public Stream<RoleModel> searchForRolesStream(RealmModel realm, String search, Integer first, Integer max) {\n+        Stream<RoleModel> local = session.roleLocalStorage().searchForRolesStream(realm, search, first, max);\n+        Stream<RoleModel> ext = getEnabledStorageProviders(session, realm, RoleLookupProvider.class).stream()\n+                .flatMap(ServicesUtils.timeBound(session,\n+                        roleStorageProviderTimeout,\n+                        p -> ((RoleLookupProvider) p).searchForRolesStream(realm, search, first, max)));\n+\n+        return Stream.concat(local, ext);\n+    }\n+\n+    @Override\n+    public boolean removeRole(RealmModel realm, RoleModel role) {\n+        if (!StorageId.isLocalStorage(role.getId())) {\n+            throw new RuntimeException(\"Federated roles do not support this operation\");\n+        }\n+        return session.roleLocalStorage().removeRole(realm, role);", "originalCommit": "949396acc6b1cd44a6d6c7f858273c5fb95e5498", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2Mjk5MTk2OA==", "url": "https://github.com/keycloak/keycloak/pull/7305#discussion_r462991968", "bodyText": "This class doesn't implement methods removeRoles(realm/client).", "author": "mhajas", "createdAt": "2020-07-30T13:22:58Z", "path": "services/src/main/java/org/keycloak/storage/RoleStorageManager.java", "diffHunk": "@@ -0,0 +1,239 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.storage;\n+\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.stream.Stream;\n+import org.jboss.logging.Logger;\n+import org.keycloak.common.util.reflections.Types;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelException;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.storage.role.RoleLookupProvider;\n+import org.keycloak.storage.role.RoleStorageProvider;\n+import org.keycloak.storage.role.RoleStorageProviderFactory;\n+import org.keycloak.storage.role.RoleStorageProviderModel;\n+import org.keycloak.utils.ServicesUtils;\n+\n+public class RoleStorageManager implements RoleProvider {", "originalCommit": "949396acc6b1cd44a6d6c7f858273c5fb95e5498", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8b35d72ca5b9f70ebdb0b664d9a3552616ed66a9", "url": "https://github.com/keycloak/keycloak/commit/8b35d72ca5b9f70ebdb0b664d9a3552616ed66a9", "message": "KEYCLOAK-14812 Create RoleStorageManager", "committedDate": "2020-07-30T12:38:20Z", "type": "forcePushed"}, {"oid": "4411c1050a2382207fab950aed3979ef02976ab1", "url": "https://github.com/keycloak/keycloak/commit/4411c1050a2382207fab950aed3979ef02976ab1", "message": "KEYCLOAK-14811 Create RoleProvider and make it independent of ClientProvider and RealmProvider", "committedDate": "2020-07-30T18:01:28Z", "type": "commit"}, {"oid": "91c0d257a359ef74864d303ec4735238a0410e69", "url": "https://github.com/keycloak/keycloak/commit/91c0d257a359ef74864d303ec4735238a0410e69", "message": "KEYCLOAK-14812 Create RoleStorageManager", "committedDate": "2020-07-30T18:01:28Z", "type": "forcePushed"}, {"oid": "e27dafc6d931aea37701740864b2eba147fec5c4", "url": "https://github.com/keycloak/keycloak/commit/e27dafc6d931aea37701740864b2eba147fec5c4", "message": "KEYCLOAK-14812 Create RoleStorageManager", "committedDate": "2020-07-31T15:15:28Z", "type": "commit"}, {"oid": "e27dafc6d931aea37701740864b2eba147fec5c4", "url": "https://github.com/keycloak/keycloak/commit/e27dafc6d931aea37701740864b2eba147fec5c4", "message": "KEYCLOAK-14812 Create RoleStorageManager", "committedDate": "2020-07-31T15:15:28Z", "type": "forcePushed"}]}