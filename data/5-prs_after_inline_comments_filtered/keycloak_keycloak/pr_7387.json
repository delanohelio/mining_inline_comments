{"pr_number": 7387, "pr_title": "KEYCLOAK-14974 Map group storage provider", "pr_createdAt": "2020-09-01T09:56:08Z", "pr_url": "https://github.com/keycloak/keycloak/pull/7387", "timeline": [{"oid": "86a9fbce6a5b360ae340f9b17a994bd283432426", "url": "https://github.com/keycloak/keycloak/commit/86a9fbce6a5b360ae340f9b17a994bd283432426", "message": "KEYCLOAK-14974 Map storage provider", "committedDate": "2020-09-01T11:08:29Z", "type": "forcePushed"}, {"oid": "5d302dede1a13853d371fad3b16026bcad2c7734", "url": "https://github.com/keycloak/keycloak/commit/5d302dede1a13853d371fad3b16026bcad2c7734", "message": "KEYCLOAK-14974 Map storage provider", "committedDate": "2020-09-02T10:03:23Z", "type": "forcePushed"}, {"oid": "24cdda75db274a04f4b84f27f41b694687a0286c", "url": "https://github.com/keycloak/keycloak/commit/24cdda75db274a04f4b84f27f41b694687a0286c", "message": "Add log to UserStorageConsentTest", "committedDate": "2020-09-02T12:47:58Z", "type": "forcePushed"}, {"oid": "f8f7d0430a80ea7ae1eb65eb50848b428d9048b4", "url": "https://github.com/keycloak/keycloak/commit/f8f7d0430a80ea7ae1eb65eb50848b428d9048b4", "message": "KEYCLOAK-14974 Map group storage provider", "committedDate": "2020-09-08T12:35:44Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUyOTg1NQ==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r485529855", "bodyText": "This seems to be a fix of an unrelated bug? LGTM, just want to double check the reason.", "author": "hmlnarik", "createdAt": "2020-09-09T11:12:42Z", "path": "model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/RealmCacheSession.java", "diffHunk": "@@ -962,7 +962,8 @@ public Long getGroupsCountByNameContaining(RealmModel realm, String search) {\n     @Override\n     public Stream<GroupModel> getTopLevelGroupsStream(RealmModel realm, Integer first, Integer max) {\n         String cacheKey = getTopGroupsQueryCacheKey(realm.getId() + first + max);\n-        boolean queryDB = invalidations.contains(cacheKey) || listInvalidations.contains(realm.getId() + first + max);\n+        boolean queryDB = invalidations.contains(cacheKey) || listInvalidations.contains(realm.getId() + first + max)\n+                || listInvalidations.contains(realm.getId());", "originalCommit": "f8f7d0430a80ea7ae1eb65eb50848b428d9048b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1NTExMA==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r486155110", "bodyText": "Thank you for pointing this out. It just looked suspicious to me, as getRealmRolesStream(RealmModel realm) is using this, I think also this method should check it.", "author": "mhajas", "createdAt": "2020-09-10T08:21:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUyOTg1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUzMjk2Ng==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r485532966", "bodyText": "first and max should be treated separately", "author": "hmlnarik", "createdAt": "2020-09-09T11:18:50Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java", "diffHunk": "@@ -472,24 +472,23 @@ public Long getGroupsCountByNameContaining(RealmModel realm, String search) {\n \n     @Override\n     public Stream<GroupModel> getTopLevelGroupsStream(RealmModel realm) {\n-        RealmEntity ref = em.getReference(RealmEntity.class, realm.getId());\n-\n-        return ref.getGroups().stream()\n-                .filter(g -> GroupEntity.TOP_PARENT_ID.equals(g.getParentId()))\n-                .map(g -> session.groups().getGroupById(realm, g.getId()))\n-                .sorted(Comparator.comparing(GroupModel::getName));\n+        return getTopLevelGroupsStream(realm, null, null);\n     }\n \n     @Override\n     public Stream<GroupModel> getTopLevelGroupsStream(RealmModel realm, Integer first, Integer max) {\n-        Stream<String> groupIds =  em.createNamedQuery(\"getTopLevelGroupIds\", String.class)\n+        TypedQuery<String> groupsQuery =  em.createNamedQuery(\"getTopLevelGroupIds\", String.class)\n                 .setParameter(\"realm\", realm.getId())\n-                .setParameter(\"parent\", GroupEntity.TOP_PARENT_ID)\n-                .setFirstResult(first)\n-                .setMaxResults(max)\n-                .getResultStream();\n+                .setParameter(\"parent\", GroupEntity.TOP_PARENT_ID);\n \n-        return closing(groupIds.map(realm::getGroupById));\n+        if (first != null && max != null) {", "originalCommit": "f8f7d0430a80ea7ae1eb65eb50848b428d9048b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE1OTQwOA==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r486159408", "bodyText": "This something we should probably unify across the whole codebase because I saw more approaches to this (for example).. Maybe we should add this to the cleanup task.\nI did it this way because it is used here, but I will fix: https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/services/resources/admin/GroupsResource.java#L84", "author": "mhajas", "createdAt": "2020-09-10T08:28:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUzMjk2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU2MDc1MQ==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r486560751", "bodyText": "Absolutely agree, we should follow single approach to these parameters. Thanks for fixing.", "author": "hmlnarik", "createdAt": "2020-09-10T18:44:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUzMjk2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUzMzIxNg==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r485533216", "bodyText": "Can this Comparator be extracted to a constant (and similarly for other Comparators in this PR)?", "author": "hmlnarik", "createdAt": "2020-09-09T11:19:26Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java", "diffHunk": "@@ -472,24 +472,23 @@ public Long getGroupsCountByNameContaining(RealmModel realm, String search) {\n \n     @Override\n     public Stream<GroupModel> getTopLevelGroupsStream(RealmModel realm) {\n-        RealmEntity ref = em.getReference(RealmEntity.class, realm.getId());\n-\n-        return ref.getGroups().stream()\n-                .filter(g -> GroupEntity.TOP_PARENT_ID.equals(g.getParentId()))\n-                .map(g -> session.groups().getGroupById(realm, g.getId()))\n-                .sorted(Comparator.comparing(GroupModel::getName));\n+        return getTopLevelGroupsStream(realm, null, null);\n     }\n \n     @Override\n     public Stream<GroupModel> getTopLevelGroupsStream(RealmModel realm, Integer first, Integer max) {\n-        Stream<String> groupIds =  em.createNamedQuery(\"getTopLevelGroupIds\", String.class)\n+        TypedQuery<String> groupsQuery =  em.createNamedQuery(\"getTopLevelGroupIds\", String.class)\n                 .setParameter(\"realm\", realm.getId())\n-                .setParameter(\"parent\", GroupEntity.TOP_PARENT_ID)\n-                .setFirstResult(first)\n-                .setMaxResults(max)\n-                .getResultStream();\n+                .setParameter(\"parent\", GroupEntity.TOP_PARENT_ID);\n \n-        return closing(groupIds.map(realm::getGroupById));\n+        if (first != null && max != null) {\n+            groupsQuery = groupsQuery.setFirstResult(first).setMaxResults(max);\n+        }\n+\n+        return closing(groupsQuery.getResultStream()\n+                .map(realm::getGroupById)\n+                .sorted(Comparator.comparing(GroupModel::getName))", "originalCommit": "f8f7d0430a80ea7ae1eb65eb50848b428d9048b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjE3MDU5Ng==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r486170596", "bodyText": "Sure", "author": "mhajas", "createdAt": "2020-09-10T08:46:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUzMzIxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUzODU3Mg==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r485538572", "bodyText": "Where did the pagination go?", "author": "hmlnarik", "createdAt": "2020-09-09T11:30:17Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/UserAdapter.java", "diffHunk": "@@ -357,7 +359,7 @@ public void setEmailVerified(boolean verified) {\n         user.setEmailVerified(verified);\n     }\n \n-    private TypedQuery<String> createGetGroupsQuery(String search, Integer first, Integer max) {\n+    private TypedQuery<String> createGetGroupsQuery() {", "originalCommit": "f8f7d0430a80ea7ae1eb65eb50848b428d9048b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUzOTUyMw==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r485539523", "bodyText": "This will lead to performance drop. Can group filtering and limits be supported better in the JPA layer?", "author": "hmlnarik", "createdAt": "2020-09-09T11:32:07Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/UserAdapter.java", "diffHunk": "@@ -391,38 +384,33 @@ public void setEmailVerified(boolean verified) {\n \n         List<Predicate> predicates = new ArrayList<>();\n         predicates.add(builder.equal(root.get(\"user\"), getEntity()));\n-        if (Objects.nonNull(search) && !search.isEmpty()) {\n-            Join<UserGroupMembershipEntity, GroupEntity> join = root.join(\"group\");\n-            predicates.add(builder.like(join.get(\"name\"), builder.literal(\"%\" + search + \"%\")));\n-        }\n \n         queryBuilder.select(builder.count(root));\n         queryBuilder.where(predicates.toArray(new Predicate[0]));\n         return em.createQuery(queryBuilder);\n     }\n \n-    private Stream<GroupModel> getGroupModels(Stream<String> groupIds) {\n-        return groupIds.map(realm::getGroupById);\n-    }\n-\n     @Override\n     public Stream<GroupModel> getGroupsStream() {\n-        return closing(getGroupModels(createGetGroupsQuery(null, null, null).getResultStream()));\n+        return session.groups().getGroupsStream(realm, closing(createGetGroupsQuery().getResultStream()));\n     }\n \n     @Override\n     public Stream<GroupModel> getGroupsStream(String search, int first, int max) {\n-        return closing(getGroupModels(createGetGroupsQuery(search, first, max).getResultStream()));\n+        return getGroupsStream()\n+                .filter(groupModel -> search == null || groupModel.getName().toLowerCase().contains(search.toLowerCase()))\n+                .skip(first).limit(max);", "originalCommit": "f8f7d0430a80ea7ae1eb65eb50848b428d9048b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTUzOTczOQ==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r485539739", "bodyText": "Same as above", "author": "hmlnarik", "createdAt": "2020-09-09T11:32:34Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/UserAdapter.java", "diffHunk": "@@ -391,38 +384,33 @@ public void setEmailVerified(boolean verified) {\n \n         List<Predicate> predicates = new ArrayList<>();\n         predicates.add(builder.equal(root.get(\"user\"), getEntity()));\n-        if (Objects.nonNull(search) && !search.isEmpty()) {\n-            Join<UserGroupMembershipEntity, GroupEntity> join = root.join(\"group\");\n-            predicates.add(builder.like(join.get(\"name\"), builder.literal(\"%\" + search + \"%\")));\n-        }\n \n         queryBuilder.select(builder.count(root));\n         queryBuilder.where(predicates.toArray(new Predicate[0]));\n         return em.createQuery(queryBuilder);\n     }\n \n-    private Stream<GroupModel> getGroupModels(Stream<String> groupIds) {\n-        return groupIds.map(realm::getGroupById);\n-    }\n-\n     @Override\n     public Stream<GroupModel> getGroupsStream() {\n-        return closing(getGroupModels(createGetGroupsQuery(null, null, null).getResultStream()));\n+        return session.groups().getGroupsStream(realm, closing(createGetGroupsQuery().getResultStream()));\n     }\n \n     @Override\n     public Stream<GroupModel> getGroupsStream(String search, int first, int max) {\n-        return closing(getGroupModels(createGetGroupsQuery(search, first, max).getResultStream()));\n+        return getGroupsStream()\n+                .filter(groupModel -> search == null || groupModel.getName().toLowerCase().contains(search.toLowerCase()))\n+                .skip(first).limit(max);\n     }\n \n     @Override\n     public long getGroupsCount() {\n-        return createCountGroupsQuery(null).getSingleResult();\n+        return createCountGroupsQuery().getSingleResult();\n     }\n \n     @Override\n     public long getGroupsCountByNameContaining(String search) {\n-        return createCountGroupsQuery(search).getSingleResult();\n+        if (search == null) return getGroupsCount();\n+        return getGroupsStream().filter(groupModel -> groupModel.getName().contains(search)).count();", "originalCommit": "f8f7d0430a80ea7ae1eb65eb50848b428d9048b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU0MDkzMA==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r485540930", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public Collection<String> getDefaultGroups() {\n          \n          \n            \n                public Collection<String> getDefaultGroupIds() {", "author": "hmlnarik", "createdAt": "2020-09-09T11:34:42Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/entities/RealmEntity.java", "diffHunk": "@@ -467,28 +465,17 @@ public void setDefaultRoles(Collection<RoleEntity> defaultRoles) {\n         this.defaultRoles = defaultRoles;\n     }\n \n-    public Collection<GroupEntity> getDefaultGroups() {\n+    public Collection<String> getDefaultGroups() {", "originalCommit": "f8f7d0430a80ea7ae1eb65eb50848b428d9048b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU0MTAwMg==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r485541002", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected Collection<String> defaultGroups;\n          \n          \n            \n                protected Collection<String> defaultGroupIds;", "author": "hmlnarik", "createdAt": "2020-09-09T11:34:49Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/entities/RealmEntity.java", "diffHunk": "@@ -161,12 +161,10 @@\n     @JoinTable(name=\"REALM_DEFAULT_ROLES\", joinColumns = { @JoinColumn(name=\"REALM_ID\")}, inverseJoinColumns = { @JoinColumn(name=\"ROLE_ID\")})\n     protected Collection<RoleEntity> defaultRoles;\n \n-    @OneToMany(fetch = FetchType.LAZY, cascade ={CascadeType.REMOVE}, orphanRemoval = true)\n-    @JoinTable(name=\"REALM_DEFAULT_GROUPS\", joinColumns = { @JoinColumn(name=\"REALM_ID\")}, inverseJoinColumns = { @JoinColumn(name=\"GROUP_ID\")})\n-    protected Collection<GroupEntity> defaultGroups;\n-\n-    @OneToMany(fetch = FetchType.LAZY, cascade ={CascadeType.REMOVE}, orphanRemoval = true, mappedBy = \"realm\")\n-    protected Collection<GroupEntity> groups;\n+    @ElementCollection\n+    @Column(name=\"GROUP_ID\")\n+    @CollectionTable(name=\"REALM_DEFAULT_GROUPS\", joinColumns={ @JoinColumn(name=\"REALM_ID\") })\n+    protected Collection<String> defaultGroups;", "originalCommit": "f8f7d0430a80ea7ae1eb65eb50848b428d9048b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU0MTEzNA==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r485541134", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                public void setDefaultGroups(Collection<String> defaultGroups) {\n          \n          \n            \n                public void setDefaultGroupIds(Collection<String> defaultGroups) {", "author": "hmlnarik", "createdAt": "2020-09-09T11:35:03Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/entities/RealmEntity.java", "diffHunk": "@@ -467,28 +465,17 @@ public void setDefaultRoles(Collection<RoleEntity> defaultRoles) {\n         this.defaultRoles = defaultRoles;\n     }\n \n-    public Collection<GroupEntity> getDefaultGroups() {\n+    public Collection<String> getDefaultGroups() {\n         if (defaultGroups == null) {\n             defaultGroups = new LinkedList<>();\n         }\n         return defaultGroups;\n     }\n \n-    public void setDefaultGroups(Collection<GroupEntity> defaultGroups) {\n+    public void setDefaultGroups(Collection<String> defaultGroups) {", "originalCommit": "f8f7d0430a80ea7ae1eb65eb50848b428d9048b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU0NjMxNw==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r485546317", "bodyText": "evaluate as much as possible outside anonymous function, here e.g. search.toLowerCase()", "author": "hmlnarik", "createdAt": "2020-09-09T11:44:57Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/UserAdapter.java", "diffHunk": "@@ -391,38 +384,33 @@ public void setEmailVerified(boolean verified) {\n \n         List<Predicate> predicates = new ArrayList<>();\n         predicates.add(builder.equal(root.get(\"user\"), getEntity()));\n-        if (Objects.nonNull(search) && !search.isEmpty()) {\n-            Join<UserGroupMembershipEntity, GroupEntity> join = root.join(\"group\");\n-            predicates.add(builder.like(join.get(\"name\"), builder.literal(\"%\" + search + \"%\")));\n-        }\n \n         queryBuilder.select(builder.count(root));\n         queryBuilder.where(predicates.toArray(new Predicate[0]));\n         return em.createQuery(queryBuilder);\n     }\n \n-    private Stream<GroupModel> getGroupModels(Stream<String> groupIds) {\n-        return groupIds.map(realm::getGroupById);\n-    }\n-\n     @Override\n     public Stream<GroupModel> getGroupsStream() {\n-        return closing(getGroupModels(createGetGroupsQuery(null, null, null).getResultStream()));\n+        return session.groups().getGroupsStream(realm, closing(createGetGroupsQuery().getResultStream()));\n     }\n \n     @Override\n     public Stream<GroupModel> getGroupsStream(String search, int first, int max) {\n-        return closing(getGroupModels(createGetGroupsQuery(search, first, max).getResultStream()));\n+        return getGroupsStream()\n+                .filter(groupModel -> search == null || groupModel.getName().toLowerCase().contains(search.toLowerCase()))", "originalCommit": "f8f7d0430a80ea7ae1eb65eb50848b428d9048b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU0OTI3MA==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r485549270", "bodyText": "To improve performance, can Stream<GroupModel> getGroupsStream(RealmModel realm, Stream<String> ids) be implemented in JPA layer instead of relying on the default implementation?", "author": "hmlnarik", "createdAt": "2020-09-09T11:50:33Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/UserAdapter.java", "diffHunk": "@@ -391,38 +384,33 @@ public void setEmailVerified(boolean verified) {\n \n         List<Predicate> predicates = new ArrayList<>();\n         predicates.add(builder.equal(root.get(\"user\"), getEntity()));\n-        if (Objects.nonNull(search) && !search.isEmpty()) {\n-            Join<UserGroupMembershipEntity, GroupEntity> join = root.join(\"group\");\n-            predicates.add(builder.like(join.get(\"name\"), builder.literal(\"%\" + search + \"%\")));\n-        }\n \n         queryBuilder.select(builder.count(root));\n         queryBuilder.where(predicates.toArray(new Predicate[0]));\n         return em.createQuery(queryBuilder);\n     }\n \n-    private Stream<GroupModel> getGroupModels(Stream<String> groupIds) {\n-        return groupIds.map(realm::getGroupById);\n-    }\n-\n     @Override\n     public Stream<GroupModel> getGroupsStream() {\n-        return closing(getGroupModels(createGetGroupsQuery(null, null, null).getResultStream()));\n+        return session.groups().getGroupsStream(realm, closing(createGetGroupsQuery().getResultStream()));", "originalCommit": "f8f7d0430a80ea7ae1eb65eb50848b428d9048b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU1Mjg3NA==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r485552874", "bodyText": "What are available values of first and max? Could they be e.g. negative? Feel free to add JavaDoc", "author": "hmlnarik", "createdAt": "2020-09-09T11:57:20Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/UserAdapter.java", "diffHunk": "@@ -391,38 +384,33 @@ public void setEmailVerified(boolean verified) {\n \n         List<Predicate> predicates = new ArrayList<>();\n         predicates.add(builder.equal(root.get(\"user\"), getEntity()));\n-        if (Objects.nonNull(search) && !search.isEmpty()) {\n-            Join<UserGroupMembershipEntity, GroupEntity> join = root.join(\"group\");\n-            predicates.add(builder.like(join.get(\"name\"), builder.literal(\"%\" + search + \"%\")));\n-        }\n \n         queryBuilder.select(builder.count(root));\n         queryBuilder.where(predicates.toArray(new Predicate[0]));\n         return em.createQuery(queryBuilder);\n     }\n \n-    private Stream<GroupModel> getGroupModels(Stream<String> groupIds) {\n-        return groupIds.map(realm::getGroupById);\n-    }\n-\n     @Override\n     public Stream<GroupModel> getGroupsStream() {\n-        return closing(getGroupModels(createGetGroupsQuery(null, null, null).getResultStream()));\n+        return session.groups().getGroupsStream(realm, closing(createGetGroupsQuery().getResultStream()));\n     }\n \n     @Override\n     public Stream<GroupModel> getGroupsStream(String search, int first, int max) {", "originalCommit": "f8f7d0430a80ea7ae1eb65eb50848b428d9048b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU1MzE4NQ==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r485553185", "bodyText": "May first and max be negative?", "author": "hmlnarik", "createdAt": "2020-09-09T11:57:50Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/UserAdapter.java", "diffHunk": "@@ -391,38 +384,33 @@ public void setEmailVerified(boolean verified) {\n \n         List<Predicate> predicates = new ArrayList<>();\n         predicates.add(builder.equal(root.get(\"user\"), getEntity()));\n-        if (Objects.nonNull(search) && !search.isEmpty()) {\n-            Join<UserGroupMembershipEntity, GroupEntity> join = root.join(\"group\");\n-            predicates.add(builder.like(join.get(\"name\"), builder.literal(\"%\" + search + \"%\")));\n-        }\n \n         queryBuilder.select(builder.count(root));\n         queryBuilder.where(predicates.toArray(new Predicate[0]));\n         return em.createQuery(queryBuilder);\n     }\n \n-    private Stream<GroupModel> getGroupModels(Stream<String> groupIds) {\n-        return groupIds.map(realm::getGroupById);\n-    }\n-\n     @Override\n     public Stream<GroupModel> getGroupsStream() {\n-        return closing(getGroupModels(createGetGroupsQuery(null, null, null).getResultStream()));\n+        return session.groups().getGroupsStream(realm, closing(createGetGroupsQuery().getResultStream()));\n     }\n \n     @Override\n     public Stream<GroupModel> getGroupsStream(String search, int first, int max) {\n-        return closing(getGroupModels(createGetGroupsQuery(search, first, max).getResultStream()));\n+        return getGroupsStream()\n+                .filter(groupModel -> search == null || groupModel.getName().toLowerCase().contains(search.toLowerCase()))\n+                .skip(first).limit(max);", "originalCommit": "f8f7d0430a80ea7ae1eb65eb50848b428d9048b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTU5NzgwMA==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r485597800", "bodyText": "Add Javadoc", "author": "hmlnarik", "createdAt": "2020-09-09T13:09:44Z", "path": "server-spi/src/main/java/org/keycloak/models/GroupProvider.java", "diffHunk": "@@ -64,6 +65,10 @@ default GroupModel getGroupById(String id, RealmModel realm) {\n      */\n     Stream<GroupModel> getGroupsStream(RealmModel realm);\n \n+    default Stream<GroupModel> getGroupsStream(RealmModel realm, Stream<String> ids) {", "originalCommit": "f8f7d0430a80ea7ae1eb65eb50848b428d9048b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYyNjQzMA==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r485626430", "bodyText": "Add JavaDoc", "author": "hmlnarik", "createdAt": "2020-09-09T13:49:14Z", "path": "server-spi/src/main/java/org/keycloak/models/GroupProvider.java", "diffHunk": "@@ -231,4 +236,6 @@ default GroupModel createGroup(RealmModel realm, String name, GroupModel toParen\n      * @param subGroup Group.\n      */\n     void addTopLevelGroup(RealmModel realm, GroupModel subGroup);\n+\n+    void preRemove(RealmModel realm, RoleModel role);", "originalCommit": "f8f7d0430a80ea7ae1eb65eb50848b428d9048b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTYzODEwNw==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r485638107", "bodyText": "Nit: could be written as well as\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                        Set<GroupModel> subgroups = groupsPathGroup.getSubGroupsStream().collect(Collectors.toSet()); \n          \n          \n            \n                        for (GroupModel groupModel : subgroups) {\n          \n          \n            \n                            realm.removeGroup(groupModel);\n          \n          \n            \n                        }\n          \n          \n            \n            groupsPathGroup.getSubGroupsStream().collect(Collectors.toSet()).forEach(realm::removeGroup);", "author": "hmlnarik", "createdAt": "2020-09-09T14:04:21Z", "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/ldap/LDAPGroupMapperSyncWithGroupsPathTest.java", "diffHunk": "@@ -92,7 +95,13 @@ public void before() {\n             RealmModel realm = ctx.getRealm();\n \n             GroupModel groupsPathGroup = KeycloakModelUtils.findGroupByPath(realm, LDAP_GROUPS_PATH);\n-            groupsPathGroup.getSubGroupsStream().forEach(realm::removeGroup);\n+            \n+            // Subgroup stream needs to be collected, because otherwise we can end up with finding group with id that is\n+            // already removed\n+            Set<GroupModel> subgroups = groupsPathGroup.getSubGroupsStream().collect(Collectors.toSet()); \n+            for (GroupModel groupModel : subgroups) {\n+                realm.removeGroup(groupModel);\n+            }", "originalCommit": "f8f7d0430a80ea7ae1eb65eb50848b428d9048b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4NDIxNA==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r486084214", "bodyText": "I believe this method will soon become overused from other parts as well (e.g. users). Could you clearly mark by comments that this particular command is there due to GroupProvider? This will become useful once we work on https://issues.redhat.com/browse/KEYCLOAK-14750.", "author": "hmlnarik", "createdAt": "2020-09-10T06:00:24Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java", "diffHunk": "@@ -547,22 +543,24 @@ public GroupModel createGroup(RealmModel realm, String id, String name, GroupMod\n         GroupEntity groupEntity = new GroupEntity();\n         groupEntity.setId(id);\n         groupEntity.setName(name);\n-        RealmEntity realmEntity = em.getReference(RealmEntity.class, realm.getId());\n-        groupEntity.setRealm(realmEntity.getId());\n+        groupEntity.setRealm(realm.getId());\n         groupEntity.setParentId(toParent == null? GroupEntity.TOP_PARENT_ID : toParent.getId());\n         em.persist(groupEntity);\n         em.flush();\n-        realmEntity.getGroups().add(groupEntity);\n \n-        GroupAdapter adapter = new GroupAdapter(realm, em, groupEntity);\n-        return adapter;\n+        return new GroupAdapter(realm, em, groupEntity);\n     }\n \n     @Override\n     public void addTopLevelGroup(RealmModel realm, GroupModel subGroup) {\n         subGroup.setParent(null);\n     }\n \n+    @Override\n+    public void preRemove(RealmModel realm, RoleModel role) {\n+        em.createNamedQuery(\"deleteGroupRoleMappingsByRole\").setParameter(\"roleId\", role.getId()).executeUpdate();", "originalCommit": "f8f7d0430a80ea7ae1eb65eb50848b428d9048b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU2MjA3Mg==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r486562072", "bodyText": "I meant really only to mark the lines within the method like\n\n  \n    \n  \n    \n\n  \n  This file contains bidirectional Unicode text that may be interpreted or compiled differently than what appears below. To review, open the file in an editor that reveals hidden Unicode characters. Learn more about bidirectional Unicode characters\n\n\n  \n\n\n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    em.createNamedQuery(\"deleteGroupRoleMappingsByRole\").setParameter(\"roleId\", role.getId()).executeUpdate();\n          \n          \n            \n                    // GroupProvider interface method implementation starts here\n          \n          \n            \n                    em.createNamedQuery(\"deleteGroupRoleMappingsByRole\").setParameter(\"roleId\", role.getId()).executeUpdate();\n          \n          \n            \n                    // GroupProvider interface method implementation ends here\n          \n      \n    \n    \n  \n\nApologies for not being clear before", "author": "hmlnarik", "createdAt": "2020-09-10T18:47:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4NDIxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg2NjQzNA==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r486866434", "bodyText": "No apologies needed, I should have got this. Fixed", "author": "mhajas", "createdAt": "2020-09-11T08:44:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4NDIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4NTMwMw==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r486085303", "bodyText": "Extract app.getId() to a local variable before the stream.", "author": "hmlnarik", "createdAt": "2020-09-10T06:03:48Z", "path": "model/map/src/main/java/org/keycloak/models/map/group/MapGroupAdapter.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.group;\n+\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.GroupModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.RoleModel;\n+\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+\n+public class MapGroupAdapter extends AbstractGroupModel<MapGroupEntity> {\n+    public MapGroupAdapter(KeycloakSession session, RealmModel realm, MapGroupEntity entity) {\n+        super(session, realm, entity);\n+    }\n+\n+    @Override\n+    public String getId() {\n+        return entity.getId().toString();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return entity.getName();\n+    }\n+\n+    @Override\n+    public void setName(String name) {\n+        entity.setName(name);\n+    }\n+\n+    @Override\n+    public void setSingleAttribute(String name, String value) {\n+        entity.setAttribute(name, Collections.singletonList(value));\n+    }\n+\n+    @Override\n+    public void setAttribute(String name, List<String> values) {\n+        entity.setAttribute(name, values);\n+    }\n+\n+    @Override\n+    public void removeAttribute(String name) {\n+        entity.removeAttribute(name);\n+    }\n+\n+    @Override\n+    public String getFirstAttribute(String name) {\n+        List<String> attributeValues = this.entity.getAttribute(name);\n+        if (attributeValues == null) {\n+            return null;\n+        }\n+\n+        return attributeValues.get(0);\n+    }\n+\n+    @Override\n+    public Stream<String> getAttributeStream(String name) {\n+        List<String> attributes = entity.getAttribute(name);\n+        if (attributes == null || attributes.isEmpty()) return Stream.empty();\n+        return attributes.stream();\n+    }\n+\n+    @Override\n+    public Map<String, List<String>> getAttributes() {\n+        return entity.getAttributes();\n+    }\n+\n+    @Override\n+    public GroupModel getParent() {\n+        String parentId = getParentId();\n+        if (parentId == null) {\n+            return null;\n+        }\n+\n+        return session.groups().getGroupById(realm, parentId);\n+    }\n+\n+    @Override\n+    public String getParentId() {\n+        return entity.getParentId();\n+    }\n+\n+    @Override\n+    public Stream<GroupModel> getSubGroupsStream() {\n+        return session.groups().getGroupsStream(realm)\n+                .filter(groupModel -> getId().equals(groupModel.getParentId()));\n+    }\n+\n+    @Override\n+    public void setParent(GroupModel group) {\n+        if (group == null) {\n+            entity.setParentId(null);\n+            return;\n+        }\n+        \n+        if (!getId().equals(group.getId())) {\n+            entity.setParentId(group.getId());\n+        }\n+    }\n+\n+    @Override\n+    public void addChild(GroupModel subGroup) {\n+        subGroup.setParent(this);\n+    }\n+\n+    @Override\n+    public void removeChild(GroupModel subGroup) {\n+        if (getId().equals(subGroup.getParentId())) {\n+            subGroup.setParent(null);\n+        }\n+    }\n+\n+    @Override\n+    public Set<RoleModel> getRealmRoleMappings() {\n+        return getRoleMappings().stream()\n+                .filter(roleModel -> roleModel.getContainer() instanceof RealmModel)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    @Override\n+    public Set<RoleModel> getClientRoleMappings(ClientModel app) {\n+        return getRoleMappings().stream()\n+                .filter(roleModel -> roleModel.getContainer() instanceof ClientModel)\n+                .filter(roleModel -> roleModel.getContainer().getId().equals(app.getId()))", "originalCommit": "f8f7d0430a80ea7ae1eb65eb50848b428d9048b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4NjcwMg==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r486086702", "bodyText": "Extract role.getId()", "author": "hmlnarik", "createdAt": "2020-09-10T06:07:53Z", "path": "model/map/src/main/java/org/keycloak/models/map/group/MapGroupProvider.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.group;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.GroupModel;\n+import org.keycloak.models.GroupProvider;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.common.Serialization;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.storage.MapStorage;\n+\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+\n+public class MapGroupProvider implements GroupProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapGroupProvider.class);\n+    private static final Predicate<MapGroupEntity> ALWAYS_FALSE = c -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapGroupEntity> tx;\n+    private final MapStorage<UUID, MapGroupEntity> groupStore;\n+\n+    public MapGroupProvider(KeycloakSession session, MapStorage<UUID, MapGroupEntity> groupStore) {\n+        this.session = session;\n+        this.groupStore = groupStore;\n+        this.tx = new MapKeycloakTransaction<>(groupStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private MapGroupEntity registerEntityForChanges(MapGroupEntity origEntity) {\n+        final MapGroupEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapGroupEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Function<MapGroupEntity, GroupModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+        return origEntity -> new MapGroupAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private Predicate<MapGroupEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapGroupProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    @Override\n+    public GroupModel getGroupById(RealmModel realm, String id) {\n+        if (id == null) {\n+            return null;\n+        }\n+\n+        LOG.tracef(\"getGroupById(%s, %s)%s\", realm, id, getShortStackTrace());\n+\n+\n+        UUID uid;\n+        try {\n+            uid = UUID.fromString(id);\n+        } catch (IllegalArgumentException ex) {\n+            return null;\n+        }\n+        \n+        MapGroupEntity entity = tx.get(uid, groupStore::get);\n+        return (entity == null || ! entityRealmFilter(realm).test(entity))\n+                ? null\n+                : entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    private Stream<MapGroupEntity> getNotRemovedUpdatedGroupsStream() {\n+        Stream<MapGroupEntity> updatedAndNotRemovedGroupsStream = groupStore.entrySet().stream()\n+                .map(tx::getUpdated)    // If the client has been removed, tx.get will return null, otherwise it will return me.getValue()\n+                .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(groupStore.keySet()), updatedAndNotRemovedGroupsStream);\n+    }\n+\n+    private Stream<MapGroupEntity> getUnsortedGroupEntitiesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedGroupsStream()\n+                .filter(entityRealmFilter(realm));\n+    }\n+\n+    @Override\n+    public Stream<GroupModel> getGroupsStream(RealmModel realm) {\n+        LOG.tracef(\"getGroupsStream(%s)%s\", realm, getShortStackTrace());\n+        return getUnsortedGroupEntitiesStream(realm)\n+                .map(entityToAdapterFunc(realm))\n+                .sorted(Comparator.comparing(GroupModel::getName))\n+                ;\n+    }\n+\n+    @Override\n+    public Long getGroupsCount(RealmModel realm, Boolean onlyTopGroups) {\n+        LOG.tracef(\"getGroupsCount(%s, %s)%s\", realm, onlyTopGroups, getShortStackTrace());\n+        Stream<MapGroupEntity> groupModelStream = getUnsortedGroupEntitiesStream(realm);\n+\n+        if (onlyTopGroups) {\n+            groupModelStream = groupModelStream.filter(groupEntity -> Objects.isNull(groupEntity.getParentId()));\n+        }\n+        \n+        return groupModelStream.count();\n+    }\n+\n+    @Override\n+    public Long getGroupsCountByNameContaining(RealmModel realm, String search) {\n+        return searchForGroupByNameStream(realm, search, null, null).count();\n+    }\n+\n+    @Override\n+    public Stream<GroupModel> getGroupsByRoleStream(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n+        LOG.tracef(\"getGroupsByRole(%s, %s, %d, %d)%s\", realm, role, firstResult, maxResults, getShortStackTrace());\n+        Stream<GroupModel> groupModelStream = getGroupsStream(realm).filter(groupModel -> groupModel.hasRole(role));\n+\n+        if (firstResult > 0) {\n+            groupModelStream = groupModelStream.skip(firstResult);\n+        }\n+        \n+        if (maxResults > 0) {\n+            groupModelStream = groupModelStream.limit(maxResults);\n+        }\n+\n+        return groupModelStream;\n+    }\n+\n+    @Override\n+    public Stream<GroupModel> getTopLevelGroupsStream(RealmModel realm) {\n+        LOG.tracef(\"getTopLevelGroupsStream(%s)%s\", realm, getShortStackTrace());\n+        return getGroupsStream(realm)\n+                .filter(groupModel -> Objects.isNull(groupModel.getParentId()));\n+    }\n+\n+    @Override\n+    public Stream<GroupModel> getTopLevelGroupsStream(RealmModel realm, Integer firstResult, Integer maxResults) {\n+        Stream<GroupModel> groupModelStream = getTopLevelGroupsStream(realm);\n+        \n+        if (firstResult != null) {\n+            groupModelStream = groupModelStream.skip(firstResult);\n+        }\n+        \n+        if (maxResults != null) {\n+            groupModelStream = groupModelStream.limit(maxResults);\n+        }\n+        \n+        return groupModelStream;\n+        \n+    }\n+\n+    @Override\n+    public Stream<GroupModel> searchForGroupByNameStream(RealmModel realm, String search, Integer firstResult, Integer maxResults) {\n+        LOG.tracef(\"searchForGroupByNameStream(%s, %s, %d, %d)%s\", realm, search, firstResult, maxResults, getShortStackTrace());\n+        Stream<GroupModel> groupModelStream = getGroupsStream(realm)\n+                .filter(groupModel -> groupModel.getName().contains(search));\n+\n+        if (firstResult != null) {\n+            groupModelStream = groupModelStream.skip(firstResult);\n+        }\n+\n+        if (maxResults != null) {\n+            groupModelStream = groupModelStream.limit(maxResults);\n+        }\n+\n+        return groupModelStream;\n+    }\n+\n+    @Override\n+    public GroupModel createGroup(RealmModel realm, String id, String name, GroupModel toParent) {\n+        LOG.tracef(\"createGroup(%s, %s, %s, %s)%s\", realm, id, name, toParent, getShortStackTrace());\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        // Check Db constraint: uniqueConstraints = { @UniqueConstraint(columnNames = {\"REALM_ID\", \"PARENT_GROUP\", \"NAME\"})}\n+        if (getUnsortedGroupEntitiesStream(realm)\n+                .anyMatch(groupEntity -> \n+                        Objects.equals(groupEntity.getParentId(), toParent == null ? null : toParent.getId()) &&\n+                        Objects.equals(groupEntity.getName(), name))) {\n+            throw new ModelDuplicateException(\"Group with name '\" + name + \"' in realm \" + realm.getName() + \" already exists for requested parent\" );\n+        }\n+\n+        MapGroupEntity entity = new MapGroupEntity(entityId, realm.getId());\n+        entity.setName(name);\n+        entity.setParentId(toParent == null ? null : toParent.getId());\n+        if (tx.get(entity.getId(), groupStore::get) != null) {\n+            throw new ModelDuplicateException(\"Group exists: \" + entityId);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+\n+        return entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public boolean removeGroup(RealmModel realm, GroupModel group) {\n+        LOG.tracef(\"removeGroup(%s, %s)%s\", realm, group, getShortStackTrace());\n+        if (group == null) return false;\n+\n+        // TODO: Sending an event (, user group removal and realm default groups) should be extracted to store layer\n+        session.getKeycloakSessionFactory().publish(new GroupModel.GroupRemovedEvent() {\n+\n+            @Override\n+            public RealmModel getRealm() {\n+                return realm;\n+            }\n+\n+            @Override\n+            public GroupModel getGroup() {\n+                return group;\n+            }\n+\n+            @Override\n+            public KeycloakSession getKeycloakSession() {\n+                return session;\n+            }\n+        });\n+\n+        session.users().preRemove(realm, group);\n+        realm.removeDefaultGroup(group);\n+\n+        group.getSubGroupsStream().forEach(subGroup -> session.groups().removeGroup(realm, subGroup));\n+\n+        // TODO: ^^^^^^^ Up to here\n+\n+        tx.remove(UUID.fromString(group.getId()));\n+        \n+        return true;\n+    }\n+\n+    /* TODO: investigate following two methods, it seems they could be moved to model layer */\n+\n+    @Override\n+    public void moveGroup(RealmModel realm, GroupModel group, GroupModel toParent) {\n+        LOG.tracef(\"moveGroup(%s, %s, %s)%s\", realm, group, toParent, getShortStackTrace());\n+        if (toParent != null && group.getId().equals(toParent.getId())) {\n+            return;\n+        }\n+        if (group.getParentId() != null) {\n+            group.getParent().removeChild(group);\n+        }\n+        group.setParent(toParent);\n+        if (toParent != null) toParent.addChild(group);\n+        else session.groups().addTopLevelGroup(realm, group);\n+    }\n+\n+    @Override\n+    public void addTopLevelGroup(RealmModel realm, GroupModel subGroup) {\n+        LOG.tracef(\"addTopLevelGroup(%s, %s)%s\", realm, subGroup, getShortStackTrace());\n+        subGroup.setParent(null);\n+    }\n+\n+    @Override\n+    public void preRemove(RealmModel realm, RoleModel role) {\n+        LOG.tracef(\"preRemove(%s, %s)%s\", realm, role, getShortStackTrace());\n+        getUnsortedGroupEntitiesStream(realm)\n+                .filter(groupEntity -> groupEntity.getGrantedRoles().contains(role.getId()))", "originalCommit": "f8f7d0430a80ea7ae1eb65eb50848b428d9048b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4Njc3OA==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r486086778", "bodyText": "Extract groupEntity.getId().toString()", "author": "hmlnarik", "createdAt": "2020-09-10T06:08:09Z", "path": "model/map/src/main/java/org/keycloak/models/map/group/MapGroupProvider.java", "diffHunk": "@@ -0,0 +1,286 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.group;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.GroupModel;\n+import org.keycloak.models.GroupProvider;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.common.Serialization;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.storage.MapStorage;\n+\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+\n+public class MapGroupProvider implements GroupProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapGroupProvider.class);\n+    private static final Predicate<MapGroupEntity> ALWAYS_FALSE = c -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapGroupEntity> tx;\n+    private final MapStorage<UUID, MapGroupEntity> groupStore;\n+\n+    public MapGroupProvider(KeycloakSession session, MapStorage<UUID, MapGroupEntity> groupStore) {\n+        this.session = session;\n+        this.groupStore = groupStore;\n+        this.tx = new MapKeycloakTransaction<>(groupStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private MapGroupEntity registerEntityForChanges(MapGroupEntity origEntity) {\n+        final MapGroupEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapGroupEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Function<MapGroupEntity, GroupModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+        return origEntity -> new MapGroupAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private Predicate<MapGroupEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapGroupProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    @Override\n+    public GroupModel getGroupById(RealmModel realm, String id) {\n+        if (id == null) {\n+            return null;\n+        }\n+\n+        LOG.tracef(\"getGroupById(%s, %s)%s\", realm, id, getShortStackTrace());\n+\n+\n+        UUID uid;\n+        try {\n+            uid = UUID.fromString(id);\n+        } catch (IllegalArgumentException ex) {\n+            return null;\n+        }\n+        \n+        MapGroupEntity entity = tx.get(uid, groupStore::get);\n+        return (entity == null || ! entityRealmFilter(realm).test(entity))\n+                ? null\n+                : entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    private Stream<MapGroupEntity> getNotRemovedUpdatedGroupsStream() {\n+        Stream<MapGroupEntity> updatedAndNotRemovedGroupsStream = groupStore.entrySet().stream()\n+                .map(tx::getUpdated)    // If the client has been removed, tx.get will return null, otherwise it will return me.getValue()\n+                .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(groupStore.keySet()), updatedAndNotRemovedGroupsStream);\n+    }\n+\n+    private Stream<MapGroupEntity> getUnsortedGroupEntitiesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedGroupsStream()\n+                .filter(entityRealmFilter(realm));\n+    }\n+\n+    @Override\n+    public Stream<GroupModel> getGroupsStream(RealmModel realm) {\n+        LOG.tracef(\"getGroupsStream(%s)%s\", realm, getShortStackTrace());\n+        return getUnsortedGroupEntitiesStream(realm)\n+                .map(entityToAdapterFunc(realm))\n+                .sorted(Comparator.comparing(GroupModel::getName))\n+                ;\n+    }\n+\n+    @Override\n+    public Long getGroupsCount(RealmModel realm, Boolean onlyTopGroups) {\n+        LOG.tracef(\"getGroupsCount(%s, %s)%s\", realm, onlyTopGroups, getShortStackTrace());\n+        Stream<MapGroupEntity> groupModelStream = getUnsortedGroupEntitiesStream(realm);\n+\n+        if (onlyTopGroups) {\n+            groupModelStream = groupModelStream.filter(groupEntity -> Objects.isNull(groupEntity.getParentId()));\n+        }\n+        \n+        return groupModelStream.count();\n+    }\n+\n+    @Override\n+    public Long getGroupsCountByNameContaining(RealmModel realm, String search) {\n+        return searchForGroupByNameStream(realm, search, null, null).count();\n+    }\n+\n+    @Override\n+    public Stream<GroupModel> getGroupsByRoleStream(RealmModel realm, RoleModel role, int firstResult, int maxResults) {\n+        LOG.tracef(\"getGroupsByRole(%s, %s, %d, %d)%s\", realm, role, firstResult, maxResults, getShortStackTrace());\n+        Stream<GroupModel> groupModelStream = getGroupsStream(realm).filter(groupModel -> groupModel.hasRole(role));\n+\n+        if (firstResult > 0) {\n+            groupModelStream = groupModelStream.skip(firstResult);\n+        }\n+        \n+        if (maxResults > 0) {\n+            groupModelStream = groupModelStream.limit(maxResults);\n+        }\n+\n+        return groupModelStream;\n+    }\n+\n+    @Override\n+    public Stream<GroupModel> getTopLevelGroupsStream(RealmModel realm) {\n+        LOG.tracef(\"getTopLevelGroupsStream(%s)%s\", realm, getShortStackTrace());\n+        return getGroupsStream(realm)\n+                .filter(groupModel -> Objects.isNull(groupModel.getParentId()));\n+    }\n+\n+    @Override\n+    public Stream<GroupModel> getTopLevelGroupsStream(RealmModel realm, Integer firstResult, Integer maxResults) {\n+        Stream<GroupModel> groupModelStream = getTopLevelGroupsStream(realm);\n+        \n+        if (firstResult != null) {\n+            groupModelStream = groupModelStream.skip(firstResult);\n+        }\n+        \n+        if (maxResults != null) {\n+            groupModelStream = groupModelStream.limit(maxResults);\n+        }\n+        \n+        return groupModelStream;\n+        \n+    }\n+\n+    @Override\n+    public Stream<GroupModel> searchForGroupByNameStream(RealmModel realm, String search, Integer firstResult, Integer maxResults) {\n+        LOG.tracef(\"searchForGroupByNameStream(%s, %s, %d, %d)%s\", realm, search, firstResult, maxResults, getShortStackTrace());\n+        Stream<GroupModel> groupModelStream = getGroupsStream(realm)\n+                .filter(groupModel -> groupModel.getName().contains(search));\n+\n+        if (firstResult != null) {\n+            groupModelStream = groupModelStream.skip(firstResult);\n+        }\n+\n+        if (maxResults != null) {\n+            groupModelStream = groupModelStream.limit(maxResults);\n+        }\n+\n+        return groupModelStream;\n+    }\n+\n+    @Override\n+    public GroupModel createGroup(RealmModel realm, String id, String name, GroupModel toParent) {\n+        LOG.tracef(\"createGroup(%s, %s, %s, %s)%s\", realm, id, name, toParent, getShortStackTrace());\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        // Check Db constraint: uniqueConstraints = { @UniqueConstraint(columnNames = {\"REALM_ID\", \"PARENT_GROUP\", \"NAME\"})}\n+        if (getUnsortedGroupEntitiesStream(realm)\n+                .anyMatch(groupEntity -> \n+                        Objects.equals(groupEntity.getParentId(), toParent == null ? null : toParent.getId()) &&\n+                        Objects.equals(groupEntity.getName(), name))) {\n+            throw new ModelDuplicateException(\"Group with name '\" + name + \"' in realm \" + realm.getName() + \" already exists for requested parent\" );\n+        }\n+\n+        MapGroupEntity entity = new MapGroupEntity(entityId, realm.getId());\n+        entity.setName(name);\n+        entity.setParentId(toParent == null ? null : toParent.getId());\n+        if (tx.get(entity.getId(), groupStore::get) != null) {\n+            throw new ModelDuplicateException(\"Group exists: \" + entityId);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+\n+        return entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public boolean removeGroup(RealmModel realm, GroupModel group) {\n+        LOG.tracef(\"removeGroup(%s, %s)%s\", realm, group, getShortStackTrace());\n+        if (group == null) return false;\n+\n+        // TODO: Sending an event (, user group removal and realm default groups) should be extracted to store layer\n+        session.getKeycloakSessionFactory().publish(new GroupModel.GroupRemovedEvent() {\n+\n+            @Override\n+            public RealmModel getRealm() {\n+                return realm;\n+            }\n+\n+            @Override\n+            public GroupModel getGroup() {\n+                return group;\n+            }\n+\n+            @Override\n+            public KeycloakSession getKeycloakSession() {\n+                return session;\n+            }\n+        });\n+\n+        session.users().preRemove(realm, group);\n+        realm.removeDefaultGroup(group);\n+\n+        group.getSubGroupsStream().forEach(subGroup -> session.groups().removeGroup(realm, subGroup));\n+\n+        // TODO: ^^^^^^^ Up to here\n+\n+        tx.remove(UUID.fromString(group.getId()));\n+        \n+        return true;\n+    }\n+\n+    /* TODO: investigate following two methods, it seems they could be moved to model layer */\n+\n+    @Override\n+    public void moveGroup(RealmModel realm, GroupModel group, GroupModel toParent) {\n+        LOG.tracef(\"moveGroup(%s, %s, %s)%s\", realm, group, toParent, getShortStackTrace());\n+        if (toParent != null && group.getId().equals(toParent.getId())) {\n+            return;\n+        }\n+        if (group.getParentId() != null) {\n+            group.getParent().removeChild(group);\n+        }\n+        group.setParent(toParent);\n+        if (toParent != null) toParent.addChild(group);\n+        else session.groups().addTopLevelGroup(realm, group);\n+    }\n+\n+    @Override\n+    public void addTopLevelGroup(RealmModel realm, GroupModel subGroup) {\n+        LOG.tracef(\"addTopLevelGroup(%s, %s)%s\", realm, subGroup, getShortStackTrace());\n+        subGroup.setParent(null);\n+    }\n+\n+    @Override\n+    public void preRemove(RealmModel realm, RoleModel role) {\n+        LOG.tracef(\"preRemove(%s, %s)%s\", realm, role, getShortStackTrace());\n+        getUnsortedGroupEntitiesStream(realm)\n+                .filter(groupEntity -> groupEntity.getGrantedRoles().contains(role.getId()))\n+                .map(groupEntity -> session.groups().getGroupById(realm, groupEntity.getId().toString()))", "originalCommit": "f8f7d0430a80ea7ae1eb65eb50848b428d9048b4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjMwNjI3MA==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r486306270", "bodyText": "Do you mean to add another map function call, with changing groupEntity stream to String stream?", "author": "mhajas", "createdAt": "2020-09-10T12:45:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4Njc3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU1ODc4OQ==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r486558789", "bodyText": "Ah, sorry, ignore this one. :-)", "author": "hmlnarik", "createdAt": "2020-09-10T18:40:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4Njc3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4NzY0NQ==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r486087645", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    realm.getDefaultGroups().add(group.getId());\n          \n          \n            \n                    groupsIds.add(group.getId());", "author": "hmlnarik", "createdAt": "2020-09-10T06:10:35Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java", "diffHunk": "@@ -793,38 +793,30 @@ public void removeDefaultRoles(String... defaultRoles) {\n \n     @Override\n     public Stream<GroupModel> getDefaultGroupsStream() {\n-        Collection<GroupEntity> entities = realm.getDefaultGroups();\n+        Collection<String> entities = realm.getDefaultGroups();\n         if (entities == null || entities.isEmpty()) return Stream.empty();\n-        return entities.stream().map(GroupEntity::getId).map(this::getGroupById);\n+        return entities.stream().map(this::getGroupById);\n     }\n \n     @Override\n     public void addDefaultGroup(GroupModel group) {\n-        Collection<GroupEntity> entities = realm.getDefaultGroups();\n-        for (GroupEntity entity : entities) {\n-            if (entity.getId().equals(group.getId())) return;\n-        }\n-        GroupEntity groupEntity = GroupAdapter.toEntity(group, em);\n-        realm.getDefaultGroups().add(groupEntity);\n-        em.flush();\n+        Collection<String> groupsIds = realm.getDefaultGroups();\n+        if (groupsIds.contains(group.getId())) return;\n \n+        realm.getDefaultGroups().add(group.getId());", "originalCommit": "f8f7d0430a80ea7ae1eb65eb50848b428d9048b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjA4ODA5Ng==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r486088096", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (groupIds.contains(group.getId())) {\n          \n          \n            \n                        groupIds.remove(group.getId());\n          \n          \n            \n                    if (groupIds.remove(group.getId())) {", "author": "hmlnarik", "createdAt": "2020-09-10T06:11:45Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java", "diffHunk": "@@ -793,38 +793,30 @@ public void removeDefaultRoles(String... defaultRoles) {\n \n     @Override\n     public Stream<GroupModel> getDefaultGroupsStream() {\n-        Collection<GroupEntity> entities = realm.getDefaultGroups();\n+        Collection<String> entities = realm.getDefaultGroups();\n         if (entities == null || entities.isEmpty()) return Stream.empty();\n-        return entities.stream().map(GroupEntity::getId).map(this::getGroupById);\n+        return entities.stream().map(this::getGroupById);\n     }\n \n     @Override\n     public void addDefaultGroup(GroupModel group) {\n-        Collection<GroupEntity> entities = realm.getDefaultGroups();\n-        for (GroupEntity entity : entities) {\n-            if (entity.getId().equals(group.getId())) return;\n-        }\n-        GroupEntity groupEntity = GroupAdapter.toEntity(group, em);\n-        realm.getDefaultGroups().add(groupEntity);\n-        em.flush();\n+        Collection<String> groupsIds = realm.getDefaultGroups();\n+        if (groupsIds.contains(group.getId())) return;\n \n+        realm.getDefaultGroups().add(group.getId());\n+        em.flush();\n     }\n \n     @Override\n     public void removeDefaultGroup(GroupModel group) {\n-        GroupEntity found = null;\n-        for (GroupEntity defaultGroup : realm.getDefaultGroups()) {\n-            if (defaultGroup.getId().equals(group.getId())) {\n-                found = defaultGroup;\n-                break;\n-            }\n-        }\n-        if (found != null) {\n-            realm.getDefaultGroups().remove(found);\n+        Collection<String> groupIds = realm.getDefaultGroups();\n+\n+        if (groupIds.contains(group.getId())) {\n+            groupIds.remove(group.getId());", "originalCommit": "f8f7d0430a80ea7ae1eb65eb50848b428d9048b4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ5NTczNQ==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r486495735", "bodyText": "Maybe we could rename the comparator to something what would tell more about it. Something like COMPARE_BY_NAME? It'd look like\n.sorted(GroupModel.COMPARE_BY_NAME);\n\nin the codebase and imo it describes exactly what it does wdyt?", "author": "vramik", "createdAt": "2020-09-10T16:58:37Z", "path": "server-spi/src/main/java/org/keycloak/models/GroupModel.java", "diffHunk": "@@ -35,6 +36,9 @@\n         GroupModel getGroup();\n         KeycloakSession getKeycloakSession();\n     }\n+    \n+    Comparator<GroupModel> COMPARATOR = Comparator.comparing(GroupModel::getName);", "originalCommit": "0a9ba5b2fe4b1420712f466ae5e6a9b7ec695cd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg2NDg5Mg==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r486864892", "bodyText": "Sounds good, added", "author": "mhajas", "createdAt": "2020-09-11T08:41:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQ5NTczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU3NDA0NQ==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r486574045", "bodyText": "Is this check here useful/necessary? realm.getDefaultGroupIds() never returns null and if I understand it correctly calling .map on empty stream is not expensive operation. @mhajas, @hmlnarik wdyt?", "author": "vramik", "createdAt": "2020-09-10T19:09:12Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java", "diffHunk": "@@ -793,38 +793,29 @@ public void removeDefaultRoles(String... defaultRoles) {\n \n     @Override\n     public Stream<GroupModel> getDefaultGroupsStream() {\n-        Collection<GroupEntity> entities = realm.getDefaultGroups();\n+        Collection<String> entities = realm.getDefaultGroupIds();\n         if (entities == null || entities.isEmpty()) return Stream.empty();", "originalCommit": "0a9ba5b2fe4b1420712f466ae5e6a9b7ec695cd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk1NzYxOA==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r486957618", "bodyText": "The RealmModel.getDefaultGroupIds() has to state that it never returns null to have this as a contract.", "author": "hmlnarik", "createdAt": "2020-09-11T10:30:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU3NDA0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTIwMTE1NQ==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r489201155", "bodyText": "The getDefaultGroupIds() here is called on the RealmEntity (not public interface) not on the RealmModel. Do we still need to add the never returns null claim?", "author": "mhajas", "createdAt": "2020-09-16T06:47:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU3NDA0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjU5NTY0MA==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r486595640", "bodyText": "nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                            .map(tx::getUpdated)    // If the client has been removed, tx.get will return null, otherwise it will return me.getValue()\n          \n          \n            \n                            .map(tx::getUpdated)    // If the group has been removed, tx.get will return null, otherwise it will return me.getValue()", "author": "vramik", "createdAt": "2020-09-10T19:51:31Z", "path": "model/map/src/main/java/org/keycloak/models/map/group/MapGroupProvider.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.group;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.GroupModel;\n+import org.keycloak.models.GroupProvider;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.common.Serialization;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.storage.MapStorage;\n+\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+\n+public class MapGroupProvider implements GroupProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapGroupProvider.class);\n+    private static final Predicate<MapGroupEntity> ALWAYS_FALSE = c -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapGroupEntity> tx;\n+    private final MapStorage<UUID, MapGroupEntity> groupStore;\n+\n+    public MapGroupProvider(KeycloakSession session, MapStorage<UUID, MapGroupEntity> groupStore) {\n+        this.session = session;\n+        this.groupStore = groupStore;\n+        this.tx = new MapKeycloakTransaction<>(groupStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private MapGroupEntity registerEntityForChanges(MapGroupEntity origEntity) {\n+        final MapGroupEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapGroupEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Function<MapGroupEntity, GroupModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+        return origEntity -> new MapGroupAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private Predicate<MapGroupEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapGroupProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    @Override\n+    public GroupModel getGroupById(RealmModel realm, String id) {\n+        if (id == null) {\n+            return null;\n+        }\n+\n+        LOG.tracef(\"getGroupById(%s, %s)%s\", realm, id, getShortStackTrace());\n+\n+\n+        UUID uid;\n+        try {\n+            uid = UUID.fromString(id);\n+        } catch (IllegalArgumentException ex) {\n+            return null;\n+        }\n+        \n+        MapGroupEntity entity = tx.get(uid, groupStore::get);\n+        return (entity == null || ! entityRealmFilter(realm).test(entity))\n+                ? null\n+                : entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    private Stream<MapGroupEntity> getNotRemovedUpdatedGroupsStream() {\n+        Stream<MapGroupEntity> updatedAndNotRemovedGroupsStream = groupStore.entrySet().stream()\n+                .map(tx::getUpdated)    // If the client has been removed, tx.get will return null, otherwise it will return me.getValue()", "originalCommit": "0a9ba5b2fe4b1420712f466ae5e6a9b7ec695cd2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwMDU3Nw==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r486600577", "bodyText": "I don't understand the comment, could you please explain?", "author": "vramik", "createdAt": "2020-09-10T20:01:25Z", "path": "model/map/src/main/java/org/keycloak/models/map/group/MapGroupProvider.java", "diffHunk": "@@ -0,0 +1,308 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.group;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.GroupModel;\n+import org.keycloak.models.GroupProvider;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.common.Serialization;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.storage.MapStorage;\n+\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+\n+public class MapGroupProvider implements GroupProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapGroupProvider.class);\n+    private static final Predicate<MapGroupEntity> ALWAYS_FALSE = c -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapGroupEntity> tx;\n+    private final MapStorage<UUID, MapGroupEntity> groupStore;\n+\n+    public MapGroupProvider(KeycloakSession session, MapStorage<UUID, MapGroupEntity> groupStore) {\n+        this.session = session;\n+        this.groupStore = groupStore;\n+        this.tx = new MapKeycloakTransaction<>(groupStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private MapGroupEntity registerEntityForChanges(MapGroupEntity origEntity) {\n+        final MapGroupEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapGroupEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Function<MapGroupEntity, GroupModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+        return origEntity -> new MapGroupAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private Predicate<MapGroupEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapGroupProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    @Override\n+    public GroupModel getGroupById(RealmModel realm, String id) {\n+        if (id == null) {\n+            return null;\n+        }\n+\n+        LOG.tracef(\"getGroupById(%s, %s)%s\", realm, id, getShortStackTrace());\n+\n+\n+        UUID uid;\n+        try {\n+            uid = UUID.fromString(id);\n+        } catch (IllegalArgumentException ex) {\n+            return null;\n+        }\n+        \n+        MapGroupEntity entity = tx.get(uid, groupStore::get);\n+        return (entity == null || ! entityRealmFilter(realm).test(entity))\n+                ? null\n+                : entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    private Stream<MapGroupEntity> getNotRemovedUpdatedGroupsStream() {\n+        Stream<MapGroupEntity> updatedAndNotRemovedGroupsStream = groupStore.entrySet().stream()\n+                .map(tx::getUpdated)    // If the client has been removed, tx.get will return null, otherwise it will return me.getValue()\n+                .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(groupStore.keySet()), updatedAndNotRemovedGroupsStream);\n+    }\n+\n+    private Stream<MapGroupEntity> getUnsortedGroupEntitiesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedGroupsStream()\n+                .filter(entityRealmFilter(realm));\n+    }\n+\n+    @Override\n+    public Stream<GroupModel> getGroupsStream(RealmModel realm) {\n+        LOG.tracef(\"getGroupsStream(%s)%s\", realm, getShortStackTrace());\n+        return getUnsortedGroupEntitiesStream(realm)\n+                .map(entityToAdapterFunc(realm))\n+                .sorted(GroupModel.COMPARATOR)\n+                ;\n+    }\n+\n+    @Override\n+    public Stream<GroupModel> getGroupsStream(RealmModel realm, Stream<String> ids, String search, Integer first, Integer max) {\n+        Stream<GroupModel> groupModelStream = ids.map(id -> session.groups().getGroupById(realm, id))\n+                .sorted(Comparator.comparing(GroupModel::getName));\n+\n+        if (search != null) {\n+            String s = search.toLowerCase();\n+            groupModelStream = groupModelStream.filter(groupModel -> groupModel.getName().toLowerCase().contains(s));\n+        }\n+\n+        if (first != null && first > 0) {\n+            groupModelStream = groupModelStream.skip(first);\n+        }\n+\n+        if (max != null && max > 0) {\n+            groupModelStream = groupModelStream.limit(max);\n+        }\n+\n+        return groupModelStream;\n+    }\n+\n+    @Override\n+    public Long getGroupsCount(RealmModel realm, Boolean onlyTopGroups) {\n+        LOG.tracef(\"getGroupsCount(%s, %s)%s\", realm, onlyTopGroups, getShortStackTrace());\n+        Stream<MapGroupEntity> groupModelStream = getUnsortedGroupEntitiesStream(realm);\n+\n+        if (onlyTopGroups) {\n+            groupModelStream = groupModelStream.filter(groupEntity -> Objects.isNull(groupEntity.getParentId()));\n+        }\n+        \n+        return groupModelStream.count();\n+    }\n+\n+    @Override\n+    public Long getGroupsCountByNameContaining(RealmModel realm, String search) {\n+        return searchForGroupByNameStream(realm, search, null, null).count();\n+    }\n+\n+    @Override\n+    public Stream<GroupModel> getGroupsByRoleStream(RealmModel realm, RoleModel role, Integer firstResult, Integer maxResults) {\n+        LOG.tracef(\"getGroupsByRole(%s, %s, %d, %d)%s\", realm, role, firstResult, maxResults, getShortStackTrace());\n+        Stream<GroupModel> groupModelStream = getGroupsStream(realm).filter(groupModel -> groupModel.hasRole(role));\n+\n+        if (firstResult != null && firstResult > 0) {\n+            groupModelStream = groupModelStream.skip(firstResult);\n+        }\n+        \n+        if (maxResults != null && maxResults > 0) {\n+            groupModelStream = groupModelStream.limit(maxResults);\n+        }\n+\n+        return groupModelStream;\n+    }\n+\n+    @Override\n+    public Stream<GroupModel> getTopLevelGroupsStream(RealmModel realm) {\n+        LOG.tracef(\"getTopLevelGroupsStream(%s)%s\", realm, getShortStackTrace());\n+        return getGroupsStream(realm)\n+                .filter(groupModel -> Objects.isNull(groupModel.getParentId()));\n+    }\n+\n+    @Override\n+    public Stream<GroupModel> getTopLevelGroupsStream(RealmModel realm, Integer firstResult, Integer maxResults) {\n+        Stream<GroupModel> groupModelStream = getTopLevelGroupsStream(realm);\n+        \n+        if (firstResult != null && firstResult > 0) {\n+            groupModelStream = groupModelStream.skip(firstResult);\n+        }\n+        \n+        if (maxResults != null && maxResults > 0) {\n+            groupModelStream = groupModelStream.limit(maxResults);\n+        }\n+        \n+        return groupModelStream;\n+        \n+    }\n+\n+    @Override\n+    public Stream<GroupModel> searchForGroupByNameStream(RealmModel realm, String search, Integer firstResult, Integer maxResults) {\n+        LOG.tracef(\"searchForGroupByNameStream(%s, %s, %d, %d)%s\", realm, search, firstResult, maxResults, getShortStackTrace());\n+        Stream<GroupModel> groupModelStream = getGroupsStream(realm)\n+                .filter(groupModel -> groupModel.getName().contains(search));\n+\n+        if (firstResult != null) {\n+            groupModelStream = groupModelStream.skip(firstResult);\n+        }\n+\n+        if (maxResults != null) {\n+            groupModelStream = groupModelStream.limit(maxResults);\n+        }\n+\n+        return groupModelStream;\n+    }\n+\n+    @Override\n+    public GroupModel createGroup(RealmModel realm, String id, String name, GroupModel toParent) {\n+        LOG.tracef(\"createGroup(%s, %s, %s, %s)%s\", realm, id, name, toParent, getShortStackTrace());\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        // Check Db constraint: uniqueConstraints = { @UniqueConstraint(columnNames = {\"REALM_ID\", \"PARENT_GROUP\", \"NAME\"})}", "originalCommit": "0a9ba5b2fe4b1420712f466ae5e6a9b7ec695cd2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njg3NjI2Mw==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r486876263", "bodyText": "The thing here is, that in the database we have a constraint that checks there are no two groups with the same name and parent. Here, we need to do it manually.", "author": "mhajas", "createdAt": "2020-09-11T08:57:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwMDU3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk1NjUwOA==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r486956508", "bodyText": "This note has to be present in GroupProvider.createGroup JavaDocs", "author": "hmlnarik", "createdAt": "2020-09-11T10:28:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjYwMDU3Nw=="}], "type": "inlineReview"}, {"oid": "5d19d7f2fa63031166a42765e3c1fa2a2a6021ae", "url": "https://github.com/keycloak/keycloak/commit/5d19d7f2fa63031166a42765e3c1fa2a2a6021ae", "message": "KEYCLOAK-14974 Addressing comments", "committedDate": "2020-09-11T09:48:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjkzMjgwMA==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r486932800", "bodyText": "@hmlnarik @vramik Should we have a count query here? This would mean we need another count method in GroupProvider which is matching this method: session.groups().getGroupsStream(realm, closing(createGetGroupsQuery().getResultStream()), search, first, max)", "author": "mhajas", "createdAt": "2020-09-11T09:54:27Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/UserAdapter.java", "diffHunk": "@@ -391,38 +384,31 @@ public void setEmailVerified(boolean verified) {\n \n         List<Predicate> predicates = new ArrayList<>();\n         predicates.add(builder.equal(root.get(\"user\"), getEntity()));\n-        if (Objects.nonNull(search) && !search.isEmpty()) {\n-            Join<UserGroupMembershipEntity, GroupEntity> join = root.join(\"group\");\n-            predicates.add(builder.like(join.get(\"name\"), builder.literal(\"%\" + search + \"%\")));\n-        }\n \n         queryBuilder.select(builder.count(root));\n         queryBuilder.where(predicates.toArray(new Predicate[0]));\n         return em.createQuery(queryBuilder);\n     }\n \n-    private Stream<GroupModel> getGroupModels(Stream<String> groupIds) {\n-        return groupIds.map(realm::getGroupById);\n-    }\n-\n     @Override\n     public Stream<GroupModel> getGroupsStream() {\n-        return closing(getGroupModels(createGetGroupsQuery(null, null, null).getResultStream()));\n+        return getGroupsStream(null, null, null);\n     }\n \n     @Override\n-    public Stream<GroupModel> getGroupsStream(String search, int first, int max) {\n-        return closing(getGroupModels(createGetGroupsQuery(search, first, max).getResultStream()));\n+    public Stream<GroupModel> getGroupsStream(String search, Integer first, Integer max) {\n+        return session.groups().getGroupsStream(realm, closing(createGetGroupsQuery().getResultStream()), search, first, max);\n     }\n \n     @Override\n     public long getGroupsCount() {\n-        return createCountGroupsQuery(null).getSingleResult();\n+        return createCountGroupsQuery().getSingleResult();\n     }\n \n     @Override\n     public long getGroupsCountByNameContaining(String search) {\n-        return createCountGroupsQuery(search).getSingleResult();\n+        if (search == null) return getGroupsCount();\n+        return getGroupsStream(search, null, null).count();", "originalCommit": "5d19d7f2fa63031166a42765e3c1fa2a2a6021ae", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Njk3MjYxMQ==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r486972611", "bodyText": "Yes", "author": "hmlnarik", "createdAt": "2020-09-11T11:04:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjkzMjgwMA=="}], "type": "inlineReview"}, {"oid": "0879939d0552394aef1909f27a35123f24fbab22", "url": "https://github.com/keycloak/keycloak/commit/0879939d0552394aef1909f27a35123f24fbab22", "message": "KEYCLOAK-14974 Addressing comments", "committedDate": "2020-09-14T08:03:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgyMzUzMw==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r487823533", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                protected Collection<String> defaultGroupIds;\n          \n          \n            \n                protected Set<String> defaultGroupIds;", "author": "vramik", "createdAt": "2020-09-14T10:54:26Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/entities/RealmEntity.java", "diffHunk": "@@ -161,12 +161,10 @@\n     @JoinTable(name=\"REALM_DEFAULT_ROLES\", joinColumns = { @JoinColumn(name=\"REALM_ID\")}, inverseJoinColumns = { @JoinColumn(name=\"ROLE_ID\")})\n     protected Collection<RoleEntity> defaultRoles;\n \n-    @OneToMany(fetch = FetchType.LAZY, cascade ={CascadeType.REMOVE}, orphanRemoval = true)\n-    @JoinTable(name=\"REALM_DEFAULT_GROUPS\", joinColumns = { @JoinColumn(name=\"REALM_ID\")}, inverseJoinColumns = { @JoinColumn(name=\"GROUP_ID\")})\n-    protected Collection<GroupEntity> defaultGroups;\n-\n-    @OneToMany(fetch = FetchType.LAZY, cascade ={CascadeType.REMOVE}, orphanRemoval = true, mappedBy = \"realm\")\n-    protected Collection<GroupEntity> groups;\n+    @ElementCollection\n+    @Column(name=\"GROUP_ID\")\n+    @CollectionTable(name=\"REALM_DEFAULT_GROUPS\", joinColumns={ @JoinColumn(name=\"REALM_ID\") })\n+    protected Collection<String> defaultGroupIds;", "originalCommit": "0879939d0552394aef1909f27a35123f24fbab22", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzkxMzc2MA==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r487913760", "bodyText": "Done", "author": "mhajas", "createdAt": "2020-09-14T13:30:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzgyMzUzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk2NDg3OQ==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r487964879", "bodyText": "There need to be two queries, one with and one without search parameter, for performance reasons to prevent seq scan in case of no search", "author": "hmlnarik", "createdAt": "2020-09-14T14:16:49Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java", "diffHunk": "@@ -415,15 +415,51 @@ public void moveGroup(RealmModel realm, GroupModel group, GroupModel toParent) {\n         group.setParent(toParent);\n         if (toParent != null) toParent.addChild(group);\n         else session.groups().addTopLevelGroup(realm, group);\n+\n+        // TODO: Remove em.flush(), currently this needs to be there to translate ConstraintViolationException to\n+        //  DuplicateModelException {@link PersistenceExceptionConverter} is not called if the\n+        //  ConstraintViolationException is not thrown in method called directly from EntityManager\n+        em.flush();\n     }\n \n     @Override\n     public Stream<GroupModel> getGroupsStream(RealmModel realm) {\n-        RealmEntity ref = em.getReference(RealmEntity.class, realm.getId());\n+        return closing(em.createNamedQuery(\"getGroupIdsByRealm\", String.class)\n+                .setParameter(\"realm\", realm.getId())\n+                .getResultStream())\n+                .map(g -> session.groups().getGroupById(realm, g));\n+    }\n+\n+    @Override\n+    public Stream<GroupModel> getGroupsStream(RealmModel realm, Stream<String> ids, String search, Integer first, Integer max) {\n+        if (search == null) search = \"\";\n+\n+        TypedQuery<String> query = em.createNamedQuery(\"getGroupIdsByNameContainingFromIdList\", String.class)\n+                .setParameter(\"realm\", realm.getId())\n+                .setParameter(\"search\", search)", "originalCommit": "f1087032f0cd47f0b363bea6ef6e9f1601d67a1d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk2NzQzMQ==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r487967431", "bodyText": "same as above", "author": "hmlnarik", "createdAt": "2020-09-14T14:19:07Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaRealmProvider.java", "diffHunk": "@@ -415,15 +415,51 @@ public void moveGroup(RealmModel realm, GroupModel group, GroupModel toParent) {\n         group.setParent(toParent);\n         if (toParent != null) toParent.addChild(group);\n         else session.groups().addTopLevelGroup(realm, group);\n+\n+        // TODO: Remove em.flush(), currently this needs to be there to translate ConstraintViolationException to\n+        //  DuplicateModelException {@link PersistenceExceptionConverter} is not called if the\n+        //  ConstraintViolationException is not thrown in method called directly from EntityManager\n+        em.flush();\n     }\n \n     @Override\n     public Stream<GroupModel> getGroupsStream(RealmModel realm) {\n-        RealmEntity ref = em.getReference(RealmEntity.class, realm.getId());\n+        return closing(em.createNamedQuery(\"getGroupIdsByRealm\", String.class)\n+                .setParameter(\"realm\", realm.getId())\n+                .getResultStream())\n+                .map(g -> session.groups().getGroupById(realm, g));\n+    }\n+\n+    @Override\n+    public Stream<GroupModel> getGroupsStream(RealmModel realm, Stream<String> ids, String search, Integer first, Integer max) {\n+        if (search == null) search = \"\";\n+\n+        TypedQuery<String> query = em.createNamedQuery(\"getGroupIdsByNameContainingFromIdList\", String.class)\n+                .setParameter(\"realm\", realm.getId())\n+                .setParameter(\"search\", search)\n+                .setParameter(\"ids\", ids.collect(Collectors.toList()));\n+\n+        if (first != null && first > 0) {\n+            query = query.setFirstResult(first);\n+        }\n+\n+        if (max != null && max > 0) {\n+            query = query.setMaxResults(max);\n+        }\n+\n+        return closing(query.getResultStream())\n+                .map(g -> session.groups().getGroupById(realm, g));\n+    }\n \n-        return ref.getGroups().stream()\n-                .map(g -> session.groups().getGroupById(realm, g.getId()))\n-                .sorted(Comparator.comparing(GroupModel::getName));\n+    @Override\n+    public Long getGroupsCount(RealmModel realm, Stream<String> ids, String search) {\n+        if (search == null) search = \"\";\n+\n+        return em.createNamedQuery(\"getGroupCountByNameContainingFromIdList\", Long.class)", "originalCommit": "f1087032f0cd47f0b363bea6ef6e9f1601d67a1d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAwMTc2MA==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r488001760", "bodyText": "I believe there is no need for such a function. We should probably throw an exception here if the search is null. It doesn't make sense to search for a count of groups with ids (we can just use the size of ids list). In the adapter layer, we should make sure no such call is made.", "author": "mhajas", "createdAt": "2020-09-14T15:01:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk2NzQzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAwNzcyMg==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r488007722", "bodyText": "Looked at it again and an exception is probably not the best, but we can just call ids.count() or in case of the upper ids.map(id -> session.groups().getGroupById(realm, id)), it should be probably faster, WDYT?", "author": "mhajas", "createdAt": "2020-09-14T15:08:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk2NzQzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwMjAxMw==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r488902013", "bodyText": "Generally this would be faster but less precise. It is possible that the ID list is obsolete since there is no guarantee of referential integrity across the group store and other stores. Hence it still makes sense to perform the query.", "author": "hmlnarik", "createdAt": "2020-09-15T19:06:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk2NzQzMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA0MjI4Nw==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r490042287", "bodyText": "I see, ok I fixed", "author": "mhajas", "createdAt": "2020-09-17T07:51:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk2NzQzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk3NDEzOA==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r487974138", "bodyText": "This change needs to be accompanied with a change that interprets 409 correctly in admin UI. Is it the case?", "author": "hmlnarik", "createdAt": "2020-09-14T14:25:53Z", "path": "services/src/main/java/org/keycloak/services/resources/admin/GroupResource.java", "diffHunk": "@@ -146,10 +146,6 @@ public void deleteGroup() {\n     public Response addChild(GroupRepresentation rep) {\n         this.auth.groups().requireManage(group);\n \n-        if (group.getSubGroupsStream().map(GroupModel::getName).anyMatch(Predicate.isEqual(rep.getName()))) {", "originalCommit": "d17bb31adb48e2bb41c3fdc4a3f251aa1d002766", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODAxMTQ2Ng==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r488011466", "bodyText": "I believe it should work the same. Look at the next line, there was:\nreturn ErrorResponse.exists(\"Parent already contains subgroup named '\" + rep.getName() + \"'\");\nwhich should be the same 409, but I will check.", "author": "mhajas", "createdAt": "2020-09-14T15:13:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Nzk3NDEzOA=="}], "type": "inlineReview"}, {"oid": "00e0406dad18e39879cf98fd6bab6a6474a93c31", "url": "https://github.com/keycloak/keycloak/commit/00e0406dad18e39879cf98fd6bab6a6474a93c31", "message": "KEYCLOAK-14974 Fix realm removing issue", "committedDate": "2020-09-15T08:09:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwMjgwMw==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r488902803", "bodyText": "Nit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                 * @param search Case insensitive string which will be searched. Ignored if null.\n          \n          \n            \n                 * @param search Case insensitive string which will be searched for. Ignored if null.", "author": "hmlnarik", "createdAt": "2020-09-15T19:07:34Z", "path": "server-spi/src/main/java/org/keycloak/models/GroupProvider.java", "diffHunk": "@@ -81,7 +81,7 @@ default GroupModel getGroupById(String id, RealmModel realm) {\n      *\n      * @param realm Realm.\n      * @param ids List of ids.\n-     * @param search Searched string. Ignored if null.\n+     * @param search Case insensitive string which will be searched. Ignored if null.", "originalCommit": "50f020207fa4bca7763b68c1f3dbbd8ce6224b66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTUzODgyNw==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r489538827", "bodyText": "Is it case sensitive or insensitive? Can it be null?", "author": "hmlnarik", "createdAt": "2020-09-16T15:42:43Z", "path": "server-spi/src/main/java/org/keycloak/models/UserModel.java", "diffHunk": "@@ -137,11 +137,29 @@\n                 .collect(Collectors.toCollection(LinkedHashSet::new));\n     }\n \n-    default Stream<GroupModel> getGroupsStream(String search, int first, int max) {\n-        return getGroupsStream()\n-                .filter(group -> search == null || group.getName().toLowerCase().contains(search.toLowerCase()))\n-                .skip(first)\n-                .limit(max);\n+    /**\n+     * Returns a paginated stream of groups within this.realm with search in the name\n+     *\n+     * @param search Searched string.", "originalCommit": "50f020207fa4bca7763b68c1f3dbbd8ce6224b66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTU0MDMwMw==", "url": "https://github.com/keycloak/keycloak/pull/7387#discussion_r489540303", "bodyText": "Is this necessary?", "author": "hmlnarik", "createdAt": "2020-09-16T15:44:54Z", "path": "model/infinispan/src/main/java/org/keycloak/models/cache/infinispan/entities/CachedUser.java", "diffHunk": "@@ -28,6 +28,7 @@\n import java.util.Collections;\n import java.util.LinkedHashSet;\n import java.util.Set;\n+import java.util.function.Function;", "originalCommit": "50f020207fa4bca7763b68c1f3dbbd8ce6224b66", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cc8ce77b7cf20005674a412ce8cbc0aa06920f29", "url": "https://github.com/keycloak/keycloak/commit/cc8ce77b7cf20005674a412ce8cbc0aa06920f29", "message": "KEYCLOAK-14974 Rebase on upstream", "committedDate": "2020-09-17T08:01:07Z", "type": "forcePushed"}, {"oid": "f4eb6e31ac02e1fede1c8e92061e81520d2c4730", "url": "https://github.com/keycloak/keycloak/commit/f4eb6e31ac02e1fede1c8e92061e81520d2c4730", "message": "KEYCLOAK-14974 Rebase on upstream", "committedDate": "2020-09-21T08:01:54Z", "type": "forcePushed"}, {"oid": "5e6f79e4ca46a29d36728f1eb2a5a83895a94b67", "url": "https://github.com/keycloak/keycloak/commit/5e6f79e4ca46a29d36728f1eb2a5a83895a94b67", "message": "KEYCLOAK-14974 Map group storage provider", "committedDate": "2020-09-21T11:14:16Z", "type": "commit"}, {"oid": "5e6f79e4ca46a29d36728f1eb2a5a83895a94b67", "url": "https://github.com/keycloak/keycloak/commit/5e6f79e4ca46a29d36728f1eb2a5a83895a94b67", "message": "KEYCLOAK-14974 Map group storage provider", "committedDate": "2020-09-21T11:14:16Z", "type": "forcePushed"}]}