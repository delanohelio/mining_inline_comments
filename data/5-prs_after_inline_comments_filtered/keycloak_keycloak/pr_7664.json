{"pr_number": 7664, "pr_title": "KEYCLOAK-14192 Client Policy - Condition : Author of a client - User Role", "pr_createdAt": "2020-12-04T14:46:04Z", "pr_url": "https://github.com/keycloak/keycloak/pull/7664", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQwNzk4MQ==", "url": "https://github.com/keycloak/keycloak/pull/7664#discussion_r537407981", "bodyText": "It seems that this won't take composite roles into account? Perhaps just \"user.hasRole\" is better as it takes composite roles and also groups into account. For example case when user is member of group \"g\" and this group has role \"foo\" assigned, then the user is considered to be in role \"foo\" due the indirection through the group.", "author": "mposolda", "createdAt": "2020-12-07T10:48:41Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/condition/ClientUpdateSourceRolesCondition.java", "diffHunk": "@@ -0,0 +1,134 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.condition;\n+\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.representations.JsonWebToken;\n+import org.keycloak.services.clientpolicy.AdminClientRegisterContext;\n+import org.keycloak.services.clientpolicy.AdminClientUpdateContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyLogger;\n+import org.keycloak.services.clientpolicy.ClientPolicyVote;\n+import org.keycloak.services.clientpolicy.ClientUpdateContext;\n+import org.keycloak.services.clientpolicy.DynamicClientRegisterContext;\n+import org.keycloak.services.clientpolicy.DynamicClientUpdateContext;\n+\n+public class ClientUpdateSourceRolesCondition implements ClientPolicyConditionProvider {\n+\n+    private static final Logger logger = Logger.getLogger(ClientUpdateSourceRolesCondition.class);\n+\n+    private final KeycloakSession session;\n+    private final ComponentModel componentModel;\n+\n+    public ClientUpdateSourceRolesCondition(KeycloakSession session, ComponentModel componentModel) {\n+        this.session = session;\n+        this.componentModel = componentModel;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return componentModel.getName();\n+    }\n+\n+    @Override\n+    public String getProviderId() {\n+        return componentModel.getProviderId();\n+    }\n+\n+    @Override\n+    public ClientPolicyVote applyPolicy(ClientPolicyContext context) throws ClientPolicyException {\n+        switch (context.getEvent()) {\n+        case REGISTER:\n+            if (context instanceof AdminClientRegisterContext) {\n+                return getVoteForRolesMatched(((ClientUpdateContext)context).getAuthenticatedUser());\n+            } else if (context instanceof DynamicClientRegisterContext) {\n+                return getVoteForRolesMatched(((ClientUpdateContext)context).getToken());\n+            } else {\n+                throw new ClientPolicyException(OAuthErrorException.SERVER_ERROR, \"unexpected context type.\");\n+            }\n+        case UPDATE:\n+            if (context instanceof AdminClientUpdateContext) {\n+                return getVoteForRolesMatched(((ClientUpdateContext)context).getAuthenticatedUser());\n+            } else if (context instanceof DynamicClientUpdateContext) {\n+                return getVoteForRolesMatched(((ClientUpdateContext)context).getToken());\n+            } else {\n+                throw new ClientPolicyException(OAuthErrorException.SERVER_ERROR, \"unexpected context type.\");\n+            }\n+        default:\n+            return ClientPolicyVote.ABSTAIN;\n+        }\n+    }\n+\n+    private ClientPolicyVote getVoteForRolesMatched(UserModel user) {\n+        if (isRolesMatched(user)) return ClientPolicyVote.YES;\n+        return ClientPolicyVote.NO;\n+    }\n+\n+    private ClientPolicyVote getVoteForRolesMatched(JsonWebToken token) {\n+        if (token == null) return ClientPolicyVote.NO;\n+        if(isRoleMatched(token.getSubject())) return ClientPolicyVote.YES;\n+        return ClientPolicyVote.NO;\n+    }\n+\n+    private boolean isRoleMatched(String subjectId) {\n+        if (subjectId == null) return false;\n+        return isRolesMatched(session.users().getUserById(subjectId, session.getContext().getRealm()));\n+    }\n+\n+    private boolean isRolesMatched(UserModel user) {\n+        if (user == null) return false;\n+\n+        Set<String> expectedRoles = instantiateRolesForMatching();\n+        if (expectedRoles == null) return false;\n+\n+        // user.getRoleMappingsStream() never returns null according to {@link UserModel.getRoleMappingsStream}\n+        Set<String> roles = user.getRoleMappingsStream().map(RoleModel::getName).collect(Collectors.toSet());", "originalCommit": "78b245cf084a137e6818a958a5f60d75d9478ecd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODE2Mjc0NA==", "url": "https://github.com/keycloak/keycloak/pull/7664#discussion_r538162744", "bodyText": "Yes. I understood the point not only treating the ordinal role but also the composit role. I'll use user.hasRole instaed of user.getRoleMappingsStream.", "author": "tnorimat", "createdAt": "2020-12-08T09:11:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzQwNzk4MQ=="}], "type": "inlineReview"}, {"oid": "eb23f7dcdf8a53c29dd3b28f0cec489b2f332784", "url": "https://github.com/keycloak/keycloak/commit/eb23f7dcdf8a53c29dd3b28f0cec489b2f332784", "message": "KEYCLOAK-14192 Client Policy - Condition : Author of a client - User Role", "committedDate": "2020-12-08T09:13:44Z", "type": "commit"}, {"oid": "eb23f7dcdf8a53c29dd3b28f0cec489b2f332784", "url": "https://github.com/keycloak/keycloak/commit/eb23f7dcdf8a53c29dd3b28f0cec489b2f332784", "message": "KEYCLOAK-14192 Client Policy - Condition : Author of a client - User Role", "committedDate": "2020-12-08T09:13:44Z", "type": "forcePushed"}]}