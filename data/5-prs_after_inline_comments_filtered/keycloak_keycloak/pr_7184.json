{"pr_number": 7184, "pr_title": "[KEYCLOAK-13942] - Invalidate pre-defined paths when paths are invalidated", "pr_createdAt": "2020-06-18T17:09:17Z", "pr_url": "https://github.com/keycloak/keycloak/pull/7184", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYxNTAzNA==", "url": "https://github.com/keycloak/keycloak/pull/7184#discussion_r449615034", "bodyText": "Hello @pedroigor, is it correct, that this way all paths defined only in enforcerConfig are removed after cache expiration? I tried to play with ServletPolicyEnforcerTest and changed cache lifespan to 5ms.\nNow I tried to run ServletPolicyEnforcerTest#testPattern1 and it fails during the first login. I described behavior in comments here.", "author": "mhajas", "createdAt": "2020-07-03T14:39:06Z", "path": "adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/authorization/PathCache.java", "diffHunk": "@@ -115,12 +123,19 @@ private PathConfig removeIfExpired(CacheEntry cached) {\n             return null;\n         }\n \n+        PathConfig config = cached.value();\n+\n         if (cached.isExpired()) {\n             remove(cached.key());\n+            \n+            if (config != null && config.getPath() != null) {\n+                // also remove from pre-defined paths map so that changes on the server are properly reflected\n+                paths.remove(config.getPath());", "originalCommit": "2b04595f1467ce1a24fe1e2ba098ea20d8d41dea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI3NzUxMQ==", "url": "https://github.com/keycloak/keycloak/pull/7184#discussion_r450277511", "bodyText": "Yes, the idea is to remove from any reference to paths, including those defined in the deployment configuration. The reason is that without it, you'll never get the application reflecting the latest changes made to resources/paths from the server. I'll look your comments.", "author": "pedroigor", "createdAt": "2020-07-06T14:52:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYxNTAzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDI4Mzc0OQ==", "url": "https://github.com/keycloak/keycloak/pull/7184#discussion_r450283749", "bodyText": "@mhajas I see your point in that comment. And the reason is that lazy-load-paths is set to false so the resource will never be fetched again.\nI guess we should only remove if that flag is marked as true so that the application can fetch again resources from server.\nBut your comment raises another question if you have paths with a specific configuration in your deployment configuration, they'll also be lost ... Let me create some tests based on your findings.", "author": "pedroigor", "createdAt": "2020-07-06T15:01:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYxNTAzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDQ3MDkzMQ==", "url": "https://github.com/keycloak/keycloak/pull/7184#discussion_r450470931", "bodyText": "@mhajas Could you check now ? I also updated tests.", "author": "pedroigor", "createdAt": "2020-07-06T20:46:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTYxNTAzNA=="}], "type": "inlineReview"}, {"oid": "f9b172921e381dd710eaf60b80850d0093f5db07", "url": "https://github.com/keycloak/keycloak/commit/f9b172921e381dd710eaf60b80850d0093f5db07", "message": "[KEYCLOAK-13942] - Invalidate pre-defined paths when paths are invalidated", "committedDate": "2020-07-06T20:45:35Z", "type": "forcePushed"}, {"oid": "51b3467752a18015fe411b5d4f2d89fad425a600", "url": "https://github.com/keycloak/keycloak/commit/51b3467752a18015fe411b5d4f2d89fad425a600", "message": "[KEYCLOAK-13942] - Invalidate pre-defined paths when paths are invalidated", "committedDate": "2020-07-06T21:46:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3NTMwOQ==", "url": "https://github.com/keycloak/keycloak/pull/7184#discussion_r450975309", "bodyText": "This is unused", "author": "mhajas", "createdAt": "2020-07-07T16:01:25Z", "path": "adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/authorization/PathCache.java", "diffHunk": "@@ -42,14 +43,17 @@\n \n     private final long maxAge;\n     private final boolean enabled;\n+    private final Map<String, PathConfig> paths;\n+    private final PolicyEnforcerConfig config;", "originalCommit": "51b3467752a18015fe411b5d4f2d89fad425a600", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3NzMxNg==", "url": "https://github.com/keycloak/keycloak/pull/7184#discussion_r450977316", "bodyText": "Why are we doing lazy loading even if lazy loading is disabled and cache is enabled?: || enforcerConfig.getPathCacheConfig() != null?", "author": "mhajas", "createdAt": "2020-07-07T16:04:37Z", "path": "adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/authorization/PolicyEnforcer.java", "diffHunk": "@@ -263,20 +267,35 @@ public PathConfig matches(String targetUri) {\n             pathConfig = super.matches(targetUri);\n \n             if (enforcerConfig.getLazyLoadPaths() || enforcerConfig.getPathCacheConfig() != null) {", "originalCommit": "51b3467752a18015fe411b5d4f2d89fad425a600", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc5NzIxNA==", "url": "https://github.com/keycloak/keycloak/pull/7184#discussion_r451797214", "bodyText": "To be honest, I don't know the exact reason. This is also something I would like to check and possibly remove so that we only fetch resources if lazy load is enabled. There must be some use case in test that relies on it.\nWe can create a JIRA and look at that more closely.", "author": "pedroigor", "createdAt": "2020-07-08T20:09:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3NzMxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3OTg0NQ==", "url": "https://github.com/keycloak/keycloak/pull/7184#discussion_r450979845", "bodyText": "Could you please elaborate a little bit more on why is this condition necessary? I would understand it without the exclamation mark in the last condition, but not with it. Maybe in some example situation when this happens.", "author": "mhajas", "createdAt": "2020-07-07T16:08:31Z", "path": "adapters/oidc/adapter-core/src/main/java/org/keycloak/adapters/authorization/PolicyEnforcer.java", "diffHunk": "@@ -263,20 +267,35 @@ public PathConfig matches(String targetUri) {\n             pathConfig = super.matches(targetUri);\n \n             if (enforcerConfig.getLazyLoadPaths() || enforcerConfig.getPathCacheConfig() != null) {\n-                if ((pathConfig == null || (pathConfig.getPath().contains(\"*\")))) {\n+                if ((pathConfig == null || pathConfig.isInvalidated() || pathConfig.getPath().contains(\"*\"))) {\n                     try {\n                         List<ResourceRepresentation> matchingResources = authzClient.protection().resource().findByMatchingUri(targetUri);\n \n-                        if (!matchingResources.isEmpty()) {\n+                        if (matchingResources.isEmpty()) {\n+                            // if this config is invalidated (e.g.: due to cache expiration) we remove and return null\n+                            if (pathConfig != null && pathConfig.isInvalidated()) {\n+                                paths.remove(targetUri);\n+                                return null;\n+                            }\n+                        } else {\n                             Map<String, Map<String, Object>> cipConfig = null;\n                             PolicyEnforcerConfig.EnforcementMode enforcementMode = PolicyEnforcerConfig.EnforcementMode.ENFORCING;\n+                            ResourceRepresentation targetResource = matchingResources.get(0);\n \n                             if (pathConfig != null) {\n                                 cipConfig = pathConfig.getClaimInformationPointConfig();\n                                 enforcementMode = pathConfig.getEnforcementMode();\n+                            } else {\n+                                for (PathConfig existingPath : paths.values()) {\n+                                    if (existingPath.getId().equals(targetResource.getId()) \n+                                            && existingPath.isStatic()\n+                                            && !PolicyEnforcerConfig.EnforcementMode.DISABLED.equals(existingPath.getEnforcementMode())) {", "originalCommit": "51b3467752a18015fe411b5d4f2d89fad425a600", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc5NjQ3Mw==", "url": "https://github.com/keycloak/keycloak/pull/7184#discussion_r451796473", "bodyText": "If the path definition is not explicitly disabled in the configuration (enforcing or permissive) then we go with the invalidation. Otherwise, paths disabled in the configuration are going to be overridden when re-fetched and not be disabled anymore.\nYou can see this flag in action by removing and running the adapter tests. I don't recall now the name of the test but one of them should fail because of this.", "author": "pedroigor", "createdAt": "2020-07-08T20:07:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDk3OTg0NQ=="}], "type": "inlineReview"}, {"oid": "d095372c56a9f5f57b27ebb23ceb2dd81a938dd4", "url": "https://github.com/keycloak/keycloak/commit/d095372c56a9f5f57b27ebb23ceb2dd81a938dd4", "message": "[KEYCLOAK-13942] - Invalidate pre-defined paths when paths are invalidated", "committedDate": "2020-07-08T20:19:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NzE3MDg3MQ==", "url": "https://github.com/keycloak/keycloak/pull/7184#discussion_r457170871", "bodyText": "Hey @pedroigor, this test is failing on this line.", "author": "mhajas", "createdAt": "2020-07-20T08:26:48Z", "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/adapter/example/authorization/LifespanAdapterTest.java", "diffHunk": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright 2018 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.testsuite.adapter.example.authorization;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+\n+import javax.ws.rs.core.Response;\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.hamcrest.Matchers;\n+import org.jboss.arquillian.container.test.api.Deployment;\n+import org.jboss.shrinkwrap.api.spec.WebArchive;\n+import org.junit.Test;\n+import org.keycloak.admin.client.resource.AuthorizationResource;\n+import org.keycloak.admin.client.resource.RealmResource;\n+import org.keycloak.admin.client.resource.UserResource;\n+import org.keycloak.representations.idm.UserRepresentation;\n+import org.keycloak.representations.idm.authorization.PolicyRepresentation;\n+import org.keycloak.representations.idm.authorization.ResourceRepresentation;\n+import org.keycloak.testsuite.adapter.page.PhotozClientAuthzTestApp;\n+import org.keycloak.testsuite.arquillian.annotation.AppServerContainer;\n+import org.keycloak.testsuite.util.javascript.ResponseValidator;\n+import org.keycloak.testsuite.utils.arquillian.ContainerConstants;\n+import org.keycloak.util.JsonSerialization;\n+\n+/**\n+ * @author <a href=\"mailto:psilva@redhat.com\">Pedro Igor</a>\n+ */\n+@AppServerContainer(ContainerConstants.APP_SERVER_WILDFLY)\n+@AppServerContainer(ContainerConstants.APP_SERVER_WILDFLY_DEPRECATED)\n+@AppServerContainer(ContainerConstants.APP_SERVER_EAP)\n+@AppServerContainer(ContainerConstants.APP_SERVER_EAP6)\n+@AppServerContainer(ContainerConstants.APP_SERVER_EAP71)\n+@AppServerContainer(ContainerConstants.APP_SERVER_UNDERTOW)\n+public class LifespanAdapterTest extends AbstractPhotozExampleAdapterTest {\n+\n+    @Deployment(name = PhotozClientAuthzTestApp.DEPLOYMENT_NAME)\n+    public static WebArchive deploymentClient() throws IOException {\n+        return exampleDeployment(PhotozClientAuthzTestApp.DEPLOYMENT_NAME);\n+    }\n+\n+    @Deployment(name = RESOURCE_SERVER_ID, managed = false, testable = false)\n+    public static WebArchive deploymentResourceServer() throws IOException {\n+        return exampleDeployment(RESOURCE_SERVER_ID,\n+              webArchive -> webArchive.addAsWebInfResource(new File(TEST_APPS_HOME_DIR + \"/photoz/keycloak-cache-lifespan-authz-service.json\"), \"keycloak.json\"));\n+    }\n+\n+    @Test\n+    public void testPathConfigInvalidation() throws Exception {\n+        loginToClientPage(aliceUser);\n+        assertSuccess();\n+\n+        ResourceRepresentation resource = getAuthorizationResource().resources().findByName(\"Profile Resource\").get(0);\n+        AuthorizationResource authorizationResource = getAuthorizationResource();\n+\n+        authorizationResource.resources().resource(resource.getId()).remove();\n+\n+        loginToClientPage(aliceUser);\n+\n+        // should throw an error because the resource was removed and cache entry did not expire yet\n+        clientPage.viewProfile(new ResponseValidator() {\n+            @Override\n+            public void validate(Map<String, Object> response) {\n+                Object res = response.get(\"res\");\n+                assertThat(res, Matchers.notNullValue());\n+                assertThat(res.toString(), Matchers.not(Matchers.containsString(\"userName\")));\n+            }\n+        });\n+\n+        setTimeOffsetOfAdapter(20);\n+\n+        loginToClientPage(aliceUser);\n+        assertSuccess();\n+        setTimeOffsetOfAdapter(0);\n+\n+        try (Response response = authorizationResource.resources().create(resource)) {\n+            resource = response.readEntity(ResourceRepresentation.class);\n+        }\n+\n+        loginToClientPage(aliceUser);\n+        assertSuccess();\n+\n+        RealmResource realm = this.realmsResouce().realm(REALM_NAME);\n+        UserRepresentation userRepresentation = realm.users().search(aliceUser.getUsername()).get(0);\n+        UserResource userResource = realm.users().get(userRepresentation.getId());\n+        \n+        userRepresentation.setEmail(\"alice@anotherdomain.org\");\n+        \n+        userResource.update(userRepresentation);\n+        loginToClientPage(aliceUser);\n+        assertTicket();\n+\n+        try {\n+            PolicyRepresentation resourceInstancePermission = new PolicyRepresentation();\n+\n+            resourceInstancePermission.setName(\"View User Permission\");\n+            resourceInstancePermission.setType(\"resource\");\n+\n+            Map<String, String> config = new HashMap<>();\n+\n+            config.put(\"resources\", JsonSerialization.writeValueAsString(Arrays.asList(resource.getId())));\n+            config.put(\"applyPolicies\", JsonSerialization.writeValueAsString(Arrays.asList(\"Only From @keycloak.org or Admin\")));\n+\n+            resourceInstancePermission.setConfig(config);\n+            authorizationResource.policies().create(resourceInstancePermission);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Error creating policy.\", e);\n+        }\n+\n+        loginToClientPage(aliceUser);\n+        // should throw an error because the resource was removed and cache entry did not expire yet\n+        clientPage.viewProfile(new ResponseValidator() {\n+            @Override\n+            public void validate(Map<String, Object> response) {\n+                Object res = response.get(\"res\");\n+                assertThat(res, Matchers.notNullValue());\n+                assertThat(res.toString(), Matchers.not(Matchers.containsString(\"userName\")));\n+            }\n+        });\n+\n+        userRepresentation.setEmail(\"alice@keycloak.org\");\n+\n+        userResource.update(userRepresentation);\n+        loginToClientPage(aliceUser);\n+        assertSuccess();\n+    }\n+\n+    private void assertSuccess() {\n+        clientPage.viewProfile((ResponseValidator) response -> {\n+            Object res = response.get(\"res\");\n+            assertThat(res, Matchers.notNullValue());\n+            assertThat(res.toString(), Matchers.containsString(\"userName\"));\n+        });\n+    }\n+\n+    private void assertTicket() {\n+        clientPage.viewProfile((ResponseValidator) response -> {\n+            Object headers = response.get(\"responseHeaders\");\n+            assertThat(headers, Matchers.notNullValue());\n+            assertThat(headers.toString(), Matchers.containsString(\"WWW-Authenticate: UMA\"));", "originalCommit": "d095372c56a9f5f57b27ebb23ceb2dd81a938dd4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9a961b50b37d007b634ae633077c7c7a0f8e9364", "url": "https://github.com/keycloak/keycloak/commit/9a961b50b37d007b634ae633077c7c7a0f8e9364", "message": "[KEYCLOAK-13942] - Invalidate pre-defined paths when paths are invalidated", "committedDate": "2020-10-28T20:42:30Z", "type": "forcePushed"}, {"oid": "9efb2facc6780d0d6ff6524433e240697efdc412", "url": "https://github.com/keycloak/keycloak/commit/9efb2facc6780d0d6ff6524433e240697efdc412", "message": "[KEYCLOAK-13942] - Invalidate pre-defined paths when paths are invalidated", "committedDate": "2021-02-11T12:21:40Z", "type": "forcePushed"}, {"oid": "be23f13bd0d14f22afd0ca1f18459d2eae3e163b", "url": "https://github.com/keycloak/keycloak/commit/be23f13bd0d14f22afd0ca1f18459d2eae3e163b", "message": "[KEYCLOAK-13942] - Invalidate pre-defined paths when paths are invalidated", "committedDate": "2021-02-17T16:30:36Z", "type": "commit"}, {"oid": "be23f13bd0d14f22afd0ca1f18459d2eae3e163b", "url": "https://github.com/keycloak/keycloak/commit/be23f13bd0d14f22afd0ca1f18459d2eae3e163b", "message": "[KEYCLOAK-13942] - Invalidate pre-defined paths when paths are invalidated", "committedDate": "2021-02-17T16:30:36Z", "type": "forcePushed"}]}