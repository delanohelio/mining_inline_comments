{"pr_number": 7645, "pr_title": "KEYCLOAK-15847 Add MapUserProvider", "pr_createdAt": "2020-11-26T15:50:35Z", "pr_url": "https://github.com/keycloak/keycloak/pull/7645", "timeline": [{"oid": "63c2c90dc52f776f070c49204c0582809db089c4", "url": "https://github.com/keycloak/keycloak/commit/63c2c90dc52f776f070c49204c0582809db089c4", "message": "KEYCLOAK-15847 Add MapUserProvider", "committedDate": "2020-11-26T15:57:27Z", "type": "forcePushed"}, {"oid": "1d1d9e83439ef636785f5549efdf1cdaadc579ba", "url": "https://github.com/keycloak/keycloak/commit/1d1d9e83439ef636785f5549efdf1cdaadc579ba", "message": "KEYCLOAK-15847 Add MapUserProvider", "committedDate": "2020-11-27T09:18:06Z", "type": "forcePushed"}, {"oid": "e08a2518cfcc9456a6022a90e982f591577ae0a4", "url": "https://github.com/keycloak/keycloak/commit/e08a2518cfcc9456a6022a90e982f591577ae0a4", "message": "KEYCLOAK-15847 Add MapUserProvider", "committedDate": "2020-11-27T09:23:03Z", "type": "forcePushed"}, {"oid": "8df17fe710c6b7ad8c41a65a18137885f2692c53", "url": "https://github.com/keycloak/keycloak/commit/8df17fe710c6b7ad8c41a65a18137885f2692c53", "message": "KEYCLOAK-15847 Add MapUserProvider", "committedDate": "2020-11-27T09:59:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg5MjczMA==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r535892730", "bodyText": "This file should remain unchanged.", "author": "hmlnarik", "createdAt": "2020-12-04T07:35:02Z", "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/federation/BackwardsCompatibilityUserStorage.java", "diffHunk": "@@ -334,7 +334,7 @@ public int getUsersCount(RealmModel realm) {\n     }\n \n     @Override\n-    public Stream<UserModel> searchForUserStream(String search, RealmModel realm, int firstResult, int maxResults) {\n+    public Stream<UserModel> searchForUserStream(String search, RealmModel realm, Integer firstResult, Integer maxResults) {", "originalCommit": "bae9cf0feb576039b88009062309846d02e19f96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4Mzc1OQ==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r535983759", "bodyText": "Are you sure? I changed int -> Integer for all stream variant, hence we won't break backward compatibility, because stream variants are new and old implementations won't be affected. However, since all implementations in our code implement XXX.Stream variants of interfaces we should change them. Does it make sense? Or I should change to int even new methods.", "author": "mhajas", "createdAt": "2020-12-04T10:08:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg5MjczMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA5MTA1NA==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r536091054", "bodyText": "Ah, I missed that this is the stream variant, you're right. Sorry for false alarm!", "author": "hmlnarik", "createdAt": "2020-12-04T13:14:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg5MjczMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg5NDA5Nw==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r535894097", "bodyText": "They should not. Even if rare in practice, latest version of RFC 5336 says that the local part of email is case-sensitive. OTOH, most email servers (e.g. GMail, Postfix) ignore letter case.\nIs this because of search? Then we need to stress that it needs to be searchable, but that will be done later in the search operation of the underlying storage.", "author": "hmlnarik", "createdAt": "2020-12-04T07:37:57Z", "path": "server-spi/src/main/java/org/keycloak/models/UserModel.java", "diffHunk": "@@ -143,6 +158,11 @@\n \n     String getEmail();\n \n+    /**\n+     * Sets email for this user, email should be switched to lowercase before setting.", "originalCommit": "bae9cf0feb576039b88009062309846d02e19f96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk4NjgxOA==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r535986818", "bodyText": "This is because JPA layer is doing it this way.\nIf we decide to change this to not use lowercase, we should probably do this in separate Jira across whole codebase.", "author": "mhajas", "createdAt": "2020-12-04T10:13:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg5NDA5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNjA5MDcwMg==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r536090702", "bodyText": "JPA is doing it this way to ensure that letter case is ignored for usernames. However, it should not be mandated to be done on the level of the storage. It should only be mandated that search ignores the letter case.", "author": "hmlnarik", "createdAt": "2020-12-04T13:14:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTg5NDA5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkwMzE0Ng==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r535903146", "bodyText": "First sentence should explain the purpose of this method, and state what it does not should only come after that.", "author": "hmlnarik", "createdAt": "2020-12-04T07:56:37Z", "path": "server-spi-private/src/main/java/org/keycloak/events/EventListenerProvider.java", "diffHunk": "@@ -18,15 +18,52 @@\n package org.keycloak.events;\n \n import org.keycloak.events.admin.AdminEvent;\n+import org.keycloak.models.KeycloakTransaction;\n import org.keycloak.provider.Provider;\n \n /**\n  * @author <a href=\"mailto:sthorger@redhat.com\">Stian Thorgersen</a>\n+ *\n+ * Note that invocation of any of {@code onEvent} methods doesn't mean that the event happened at the moment but that it\n+ * will happen during the main transaction commit. This means the execution, corresponding to the triggered event,\n+ * may end up with a failure. Therefore, each implementation of this interface should consider using an internal\n+ * {@link KeycloakTransaction} for firing events only in case the main transaction ends up successfuly. This can be\n+ * achieved by enlisting the internal transaction to {@link org.keycloak.models.KeycloakTransactionManager} using the\n+ * {@link org.keycloak.models.KeycloakTransactionManager#enlistAfterCompletion(KeycloakTransaction)} method.\n+ *\n  */\n public interface EventListenerProvider extends Provider {\n \n+    /**\n+     *\n+     * Invocation of this method doesn't mean the execution described by the event will truly happen. It can be", "originalCommit": "bae9cf0feb576039b88009062309846d02e19f96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkwMzE5OA==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r535903198", "bodyText": "same as above", "author": "hmlnarik", "createdAt": "2020-12-04T07:56:46Z", "path": "server-spi-private/src/main/java/org/keycloak/events/EventListenerProvider.java", "diffHunk": "@@ -18,15 +18,52 @@\n package org.keycloak.events;\n \n import org.keycloak.events.admin.AdminEvent;\n+import org.keycloak.models.KeycloakTransaction;\n import org.keycloak.provider.Provider;\n \n /**\n  * @author <a href=\"mailto:sthorger@redhat.com\">Stian Thorgersen</a>\n+ *\n+ * Note that invocation of any of {@code onEvent} methods doesn't mean that the event happened at the moment but that it\n+ * will happen during the main transaction commit. This means the execution, corresponding to the triggered event,\n+ * may end up with a failure. Therefore, each implementation of this interface should consider using an internal\n+ * {@link KeycloakTransaction} for firing events only in case the main transaction ends up successfuly. This can be\n+ * achieved by enlisting the internal transaction to {@link org.keycloak.models.KeycloakTransactionManager} using the\n+ * {@link org.keycloak.models.KeycloakTransactionManager#enlistAfterCompletion(KeycloakTransaction)} method.\n+ *\n  */\n public interface EventListenerProvider extends Provider {\n \n+    /**\n+     *\n+     * Invocation of this method doesn't mean the execution described by the event will truly happen. It can be\n+     * rolled back by the {@link org.keycloak.models.KeycloakTransactionManager} in case of some failure. It is \n+     * recommended to use this method just for saving events to be able to fire them only in case of the successful\n+     * transaction.\n+     * \n+     * Note that this method should be always invoked in time when the main transaction is active, therefore it can be\n+     * used, for example, to make some changes in the database, ldap storage etc.\n+     * \n+     * \n+     * @param event to be triggered\n+     */\n     void onEvent(Event event);\n \n+    /**\n+     *\n+     * Invocation of this method doesn't mean the execution described by the event will truly happen. It can be", "originalCommit": "bae9cf0feb576039b88009062309846d02e19f96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkwNDc4Ng==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r535904786", "bodyText": "First paragraph should explain what is purpose of this interface, when it would be called etc. This explanation should only come after that.", "author": "hmlnarik", "createdAt": "2020-12-04T07:59:49Z", "path": "server-spi-private/src/main/java/org/keycloak/events/EventListenerProvider.java", "diffHunk": "@@ -18,15 +18,52 @@\n package org.keycloak.events;\n \n import org.keycloak.events.admin.AdminEvent;\n+import org.keycloak.models.KeycloakTransaction;\n import org.keycloak.provider.Provider;\n \n /**\n  * @author <a href=\"mailto:sthorger@redhat.com\">Stian Thorgersen</a>\n+ *\n+ * Note that invocation of any of {@code onEvent} methods doesn't mean that the event happened at the moment but that it", "originalCommit": "bae9cf0feb576039b88009062309846d02e19f96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkwNTg5NA==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r535905894", "bodyText": "Firing an event should be precondition for this interface's methods to be invoked. Maybe persisting would express the intention? (same in the javadocs below)", "author": "hmlnarik", "createdAt": "2020-12-04T08:01:58Z", "path": "server-spi-private/src/main/java/org/keycloak/events/EventListenerProvider.java", "diffHunk": "@@ -18,15 +18,52 @@\n package org.keycloak.events;\n \n import org.keycloak.events.admin.AdminEvent;\n+import org.keycloak.models.KeycloakTransaction;\n import org.keycloak.provider.Provider;\n \n /**\n  * @author <a href=\"mailto:sthorger@redhat.com\">Stian Thorgersen</a>\n+ *\n+ * Note that invocation of any of {@code onEvent} methods doesn't mean that the event happened at the moment but that it\n+ * will happen during the main transaction commit. This means the execution, corresponding to the triggered event,\n+ * may end up with a failure. Therefore, each implementation of this interface should consider using an internal\n+ * {@link KeycloakTransaction} for firing events only in case the main transaction ends up successfuly. This can be", "originalCommit": "bae9cf0feb576039b88009062309846d02e19f96", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTk5MTcxNA==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r535991714", "bodyText": "WDYT?\nTherefore, each implementation of this interface should consider persisting events and act upon them only when the main transaction was successful. This can be achieved by enlisting the internal transaction to {@link org.keycloak.models.KeycloakTransactionManager} using the {@link org.keycloak.models.KeycloakTransactionManager#enlistAfterCompletion(KeycloakTransaction)} method.", "author": "mhajas", "createdAt": "2020-12-04T10:20:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkwNTg5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkxMTQyMw==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r535911423", "bodyText": "It should not, there is demand for case-sensitive username support. See e.g. https://issues.redhat.com/browse/KEYCLOAK-5699.\nFor this moment, Keycloak uses case-insensitive usernames. Is this because of search? Then we need to stress that it needs to be case-insensitive searchable, but that will be done later in the search operation of the underlying storage.", "author": "hmlnarik", "createdAt": "2020-12-04T08:12:32Z", "path": "server-spi/src/main/java/org/keycloak/models/UserModel.java", "diffHunk": "@@ -56,7 +59,13 @@\n     // No default method here to allow Abstract subclasses where the username is provided in a different manner\n     String getUsername();\n \n-    // No default method here to allow Abstract subclasses where the username is provided in a different manner\n+    /**\n+     * Sets username for this user, username should be switched to lowercase before setting.", "originalCommit": "bae9cf0feb576039b88009062309846d02e19f96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkxMTcyNg==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r535911726", "bodyText": "There should be check for action != null (even though I appreciate it's not there in the original JPA variant)", "author": "hmlnarik", "createdAt": "2020-12-04T08:13:09Z", "path": "server-spi/src/main/java/org/keycloak/models/UserModel.java", "diffHunk": "@@ -129,9 +138,15 @@\n \n     void removeRequiredAction(String action);\n \n-    void addRequiredAction(RequiredAction action);\n+    default void addRequiredAction(RequiredAction action) {\n+        String actionName = action.name();", "originalCommit": "bae9cf0feb576039b88009062309846d02e19f96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTkxODMzOQ==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r535918339", "bodyText": "Should compare irrespective of case?", "author": "hmlnarik", "createdAt": "2020-12-04T08:25:21Z", "path": "model/map/src/main/java/org/keycloak/models/map/user/MapUserEntity.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.user;\n+\n+import java.util.Comparator;\n+import java.util.UUID;\n+\n+public class MapUserEntity extends AbstractUserEntity<UUID> {\n+\n+    public static final Comparator<MapUserEntity> COMPARE_BY_USERNAME = Comparator.comparing(MapUserEntity::getUsername);", "originalCommit": "bae9cf0feb576039b88009062309846d02e19f96", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c13e24d57064e1c494faeb5213ae61225f70f6c0", "url": "https://github.com/keycloak/keycloak/commit/c13e24d57064e1c494faeb5213ae61225f70f6c0", "message": "KEYCLOAK-15847 Add MapUserProvider", "committedDate": "2020-12-08T11:13:19Z", "type": "forcePushed"}, {"oid": "2414212e6ac1e91ad9c902eb5833dfc62cb89084", "url": "https://github.com/keycloak/keycloak/commit/2414212e6ac1e91ad9c902eb5833dfc62cb89084", "message": "KEYCLOAK-15847 Add MapUserProvider", "committedDate": "2020-12-08T11:14:46Z", "type": "commit"}, {"oid": "2414212e6ac1e91ad9c902eb5833dfc62cb89084", "url": "https://github.com/keycloak/keycloak/commit/2414212e6ac1e91ad9c902eb5833dfc62cb89084", "message": "KEYCLOAK-15847 Add MapUserProvider", "committedDate": "2020-12-08T11:14:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY3MzUxNg==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r533673516", "bodyText": "Shouldn't this method (right at the bottom, before returning the results stream) be using the paginateQuery method you've added to validate the firstResult and maxResults params?", "author": "sguilhen", "createdAt": "2020-12-01T19:40:15Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java", "diffHunk": "@@ -810,7 +797,7 @@ public int getUsersCount(Map<String, String> params, RealmModel realm, Set<Strin\n     }\n \n     @Override\n-    public Stream<UserModel> searchForUserStream(Map<String, String> attributes, RealmModel realm, int firstResult, int maxResults) {\n+    public Stream<UserModel> searchForUserStream(Map<String, String> attributes, RealmModel realm, Integer firstResult, Integer maxResults) {", "originalCommit": "8df17fe710c6b7ad8c41a65a18137885f2692c53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA4NTM3OA==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539085378", "bodyText": "done.", "author": "mhajas", "createdAt": "2020-12-09T08:00:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY3MzUxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY3NDA1NQ==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r533674055", "bodyText": "Just a question: where are we now deleting the federated identity?", "author": "sguilhen", "createdAt": "2020-12-01T19:41:09Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/JpaUserProvider.java", "diffHunk": "@@ -152,18 +162,10 @@ private void removeUser(UserEntity user) {\n         String id = user.getId();\n         em.createNamedQuery(\"deleteUserRoleMappingsByUser\").setParameter(\"user\", user).executeUpdate();\n         em.createNamedQuery(\"deleteUserGroupMembershipsByUser\").setParameter(\"user\", user).executeUpdate();\n-        em.createNamedQuery(\"deleteFederatedIdentityByUser\").setParameter(\"user\", user).executeUpdate();", "originalCommit": "8df17fe710c6b7ad8c41a65a18137885f2692c53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA3NzE1Nw==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539077157", "bodyText": "Yop you are right, with the second comment. If I understood it correctly the way it was before was causing some exception, that is why there was needed to call flush() twice and also clear().", "author": "mhajas", "createdAt": "2020-12-09T07:45:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY3NDA1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMzY3NTE1NA==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r533675154", "bodyText": "I guess this answers my question above about the federated identities. :)", "author": "sguilhen", "createdAt": "2020-12-01T19:43:06Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/entities/UserEntity.java", "diffHunk": "@@ -110,7 +110,7 @@\n     @BatchSize(size = 20)\n     protected Collection<CredentialEntity> credentials;\n \n-    @OneToMany(mappedBy=\"user\")\n+    @OneToMany(cascade = CascadeType.REMOVE, orphanRemoval = true, mappedBy=\"user\")", "originalCommit": "8df17fe710c6b7ad8c41a65a18137885f2692c53", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODY4MzU4OQ==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538683589", "bodyText": "This has now to implement UserCredentialStore.Streams", "author": "sguilhen", "createdAt": "2020-12-08T18:15:02Z", "path": "model/map/src/main/java/org/keycloak/models/map/user/MapUserProvider.java", "diffHunk": "@@ -0,0 +1,875 @@\n+package org.keycloak.models.map.user;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.jboss.logging.Logger;\n+import org.keycloak.authorization.AuthorizationProvider;\n+import org.keycloak.authorization.store.ResourceStore;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.credential.CredentialModel;\n+import org.keycloak.credential.UserCredentialStore;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.FederatedIdentityModel;\n+import org.keycloak.models.GroupModel;\n+import org.keycloak.models.IdentityProviderModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.ModelException;\n+import org.keycloak.models.ProtocolMapperModel;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.RequiredActionProviderModel;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserProvider;\n+import org.keycloak.models.map.common.Serialization;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.storage.MapStorage;\n+import org.keycloak.models.utils.DefaultRoles;\n+import org.keycloak.storage.StorageId;\n+import org.keycloak.storage.UserStorageProvider;\n+import org.keycloak.storage.client.ClientStorageProvider;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import static org.keycloak.models.UserModel.EMAIL;\n+import static org.keycloak.models.UserModel.EMAIL_VERIFIED;\n+import static org.keycloak.models.UserModel.FIRST_NAME;\n+import static org.keycloak.models.UserModel.LAST_NAME;\n+import static org.keycloak.models.UserModel.USERNAME;\n+\n+public class MapUserProvider implements UserProvider.Streams, UserCredentialStore {", "originalCommit": "2414212e6ac1e91ad9c902eb5833dfc62cb89084", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA4MDc5Nw==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539080797", "bodyText": "done", "author": "mhajas", "createdAt": "2020-12-09T07:52:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODY4MzU4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMTI1OQ==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538711259", "bodyText": "Out of curiosity, why a registered entity in a getter?", "author": "sguilhen", "createdAt": "2020-12-08T18:41:48Z", "path": "model/map/src/main/java/org/keycloak/models/map/user/MapUserProvider.java", "diffHunk": "@@ -0,0 +1,875 @@\n+package org.keycloak.models.map.user;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.jboss.logging.Logger;\n+import org.keycloak.authorization.AuthorizationProvider;\n+import org.keycloak.authorization.store.ResourceStore;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.credential.CredentialModel;\n+import org.keycloak.credential.UserCredentialStore;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.FederatedIdentityModel;\n+import org.keycloak.models.GroupModel;\n+import org.keycloak.models.IdentityProviderModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.ModelException;\n+import org.keycloak.models.ProtocolMapperModel;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.RequiredActionProviderModel;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserProvider;\n+import org.keycloak.models.map.common.Serialization;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.storage.MapStorage;\n+import org.keycloak.models.utils.DefaultRoles;\n+import org.keycloak.storage.StorageId;\n+import org.keycloak.storage.UserStorageProvider;\n+import org.keycloak.storage.client.ClientStorageProvider;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import static org.keycloak.models.UserModel.EMAIL;\n+import static org.keycloak.models.UserModel.EMAIL_VERIFIED;\n+import static org.keycloak.models.UserModel.FIRST_NAME;\n+import static org.keycloak.models.UserModel.LAST_NAME;\n+import static org.keycloak.models.UserModel.USERNAME;\n+\n+public class MapUserProvider implements UserProvider.Streams, UserCredentialStore {\n+\n+    private static final Logger LOG = Logger.getLogger(MapUserProvider.class);\n+    private static final Predicate<MapUserEntity> ALWAYS_FALSE = c -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapUserEntity> tx;\n+    private final MapStorage<UUID, MapUserEntity> userStore;\n+\n+    public MapUserProvider(KeycloakSession session, MapStorage<UUID, MapUserEntity> store) {\n+        this.session = session;\n+        this.userStore = store;\n+        this.tx = new MapKeycloakTransaction<>(userStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private MapUserEntity registerEntityForChanges(MapUserEntity origEntity) {\n+        MapUserEntity res = tx.get(origEntity.getId(), id -> Serialization.from(origEntity));\n+        tx.putIfChanged(origEntity.getId(), res, MapUserEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Function<MapUserEntity, UserModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+        return origEntity -> new MapUserAdapter(session, realm, registerEntityForChanges(origEntity)) {\n+\n+            @Override\n+            public boolean checkEmailUniqueness(RealmModel realm, String email) {\n+                return getUserByEmail(email, realm) != null;\n+            }\n+\n+            @Override\n+            public boolean checkUsernameUniqueness(RealmModel realm, String username) {\n+                return getUserByUsername(username, realm) != null;\n+            }\n+        };\n+    }\n+\n+    private Predicate<MapUserEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapUserProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private ModelException userDoesntExistException() {\n+        return new ModelException(\"Specified user doesn't exist.\");\n+    }\n+\n+    private Optional<MapUserEntity> getEntityById(RealmModel realm, String id) {\n+        try {\n+            return getEntityById(realm, UUID.fromString(id));\n+        } catch (IllegalArgumentException ex) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private MapUserEntity getEntityByIdOrThrow(RealmModel realm, String id) {\n+        return getEntityById(realm, id)\n+                .orElseThrow(this::userDoesntExistException);\n+    }\n+\n+    private Optional<MapUserEntity> getEntityById(RealmModel realm, UUID id) {\n+        MapUserEntity mapUserEntity = tx.get(id, userStore::get);\n+        if (mapUserEntity != null && entityRealmFilter(realm).test(mapUserEntity)) {\n+            return Optional.of(mapUserEntity);\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    private Optional<MapUserEntity> getRegisteredEntityById(RealmModel realm, String id) {\n+        return getEntityById(realm, id).map(this::registerEntityForChanges);\n+    }\n+\n+    private Stream<MapUserEntity> getNotRemovedUpdatedUsersStream() {\n+        Stream<MapUserEntity> updatedAndNotRemovedUsersStream = userStore.entrySet().stream()\n+                .map(tx::getUpdated)    // If the group has been removed, tx.get will return null, otherwise it will return me.getValue()\n+                .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(), updatedAndNotRemovedUsersStream);\n+    }\n+\n+    private Stream<MapUserEntity> getUnsortedUserEntitiesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedUsersStream()\n+                .filter(entityRealmFilter(realm));\n+    }\n+    \n+    private <T> Stream<T> paginatedStream(Stream<T> originalStream, Integer first, Integer max) {\n+        if (first != null && first > 0) {\n+            originalStream = originalStream.skip(first);\n+        }\n+\n+        if (max != null && max >= 0) {\n+            originalStream = originalStream.limit(max);\n+        }\n+\n+        return originalStream;\n+    }\n+\n+    @Override\n+    public void addFederatedIdentity(RealmModel realm, UserModel user, FederatedIdentityModel socialLink) {\n+        if (user == null || user.getId() == null) {\n+            return;\n+        }\n+        LOG.tracef(\"addFederatedIdentity(%s, %s, %s)%s\", realm, user.getId(), socialLink.getIdentityProvider(), getShortStackTrace());\n+\n+        getRegisteredEntityById(realm, user.getId())\n+                .ifPresent(userEntity ->\n+                        userEntity.addFederatedIdentity(UserFederatedIdentityEntity.fromModel(socialLink)));\n+    }\n+\n+    @Override\n+    public boolean removeFederatedIdentity(RealmModel realm, UserModel user, String socialProvider) {\n+        LOG.tracef(\"removeFederatedIdentity(%s, %s, %s)%s\", realm, user.getId(), socialProvider, getShortStackTrace());\n+        return getRegisteredEntityById(realm, user.getId())\n+                .map(entity -> entity.removeFederatedIdentity(socialProvider))\n+                .orElse(false);\n+    }\n+\n+    @Override\n+    public void preRemove(RealmModel realm, IdentityProviderModel provider) {\n+        String socialProvider = provider.getAlias();\n+        LOG.tracef(\"preRemove[RealmModel realm, IdentityProviderModel provider](%s, %s)%s\", realm, socialProvider, getShortStackTrace());\n+        getUnsortedUserEntitiesStream(realm)\n+                .map(this::registerEntityForChanges)\n+                .forEach(userEntity -> userEntity.removeFederatedIdentity(socialProvider));\n+    }\n+\n+    @Override\n+    public void updateFederatedIdentity(RealmModel realm, UserModel federatedUser, FederatedIdentityModel federatedIdentityModel) {\n+        LOG.tracef(\"updateFederatedIdentity(%s, %s, %s)%s\", realm, federatedUser.getId(), federatedIdentityModel.getIdentityProvider(), getShortStackTrace());\n+        getRegisteredEntityById(realm, federatedUser.getId())\n+                .ifPresent(entity -> entity.updateFederatedIdentity(UserFederatedIdentityEntity.fromModel(federatedIdentityModel)));\n+    }\n+\n+    @Override\n+    public Stream<FederatedIdentityModel> getFederatedIdentitiesStream(UserModel user, RealmModel realm) {\n+        LOG.tracef(\"getFederatedIdentitiesStream(%s, %s)%s\", realm, user.getId(), getShortStackTrace());\n+        return getEntityById(realm, user.getId())\n+                .map(AbstractUserEntity::getFederatedIdentities).orElseGet(Stream::empty)\n+                .map(UserFederatedIdentityEntity::toModel);\n+    }\n+\n+    @Override\n+    public FederatedIdentityModel getFederatedIdentity(UserModel user, String socialProvider, RealmModel realm) {\n+        LOG.tracef(\"getFederatedIdentity(%s, %s, %s)%s\", realm, user.getId(), socialProvider, getShortStackTrace());\n+        return getRegisteredEntityById(realm, user.getId())", "originalCommit": "2414212e6ac1e91ad9c902eb5833dfc62cb89084", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA4MDcxNg==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539080716", "bodyText": "I thought this is necessary to have support for storing changes done to the model, however this is not possible as FederatedIdentityModel is not doing any changes to the entity. I will update this and I will also check whole provider for such usages of getRegisteredEntityById.", "author": "mhajas", "createdAt": "2020-12-09T07:51:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODcxMTI1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczMDQ5Mg==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538730492", "bodyText": "Typo? \"Consent or not found... \"", "author": "sguilhen", "createdAt": "2020-12-08T19:04:17Z", "path": "model/map/src/main/java/org/keycloak/models/map/user/MapUserProvider.java", "diffHunk": "@@ -0,0 +1,875 @@\n+package org.keycloak.models.map.user;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.jboss.logging.Logger;\n+import org.keycloak.authorization.AuthorizationProvider;\n+import org.keycloak.authorization.store.ResourceStore;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.credential.CredentialModel;\n+import org.keycloak.credential.UserCredentialStore;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.FederatedIdentityModel;\n+import org.keycloak.models.GroupModel;\n+import org.keycloak.models.IdentityProviderModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.ModelException;\n+import org.keycloak.models.ProtocolMapperModel;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.RequiredActionProviderModel;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserProvider;\n+import org.keycloak.models.map.common.Serialization;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.storage.MapStorage;\n+import org.keycloak.models.utils.DefaultRoles;\n+import org.keycloak.storage.StorageId;\n+import org.keycloak.storage.UserStorageProvider;\n+import org.keycloak.storage.client.ClientStorageProvider;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import static org.keycloak.models.UserModel.EMAIL;\n+import static org.keycloak.models.UserModel.EMAIL_VERIFIED;\n+import static org.keycloak.models.UserModel.FIRST_NAME;\n+import static org.keycloak.models.UserModel.LAST_NAME;\n+import static org.keycloak.models.UserModel.USERNAME;\n+\n+public class MapUserProvider implements UserProvider.Streams, UserCredentialStore {\n+\n+    private static final Logger LOG = Logger.getLogger(MapUserProvider.class);\n+    private static final Predicate<MapUserEntity> ALWAYS_FALSE = c -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapUserEntity> tx;\n+    private final MapStorage<UUID, MapUserEntity> userStore;\n+\n+    public MapUserProvider(KeycloakSession session, MapStorage<UUID, MapUserEntity> store) {\n+        this.session = session;\n+        this.userStore = store;\n+        this.tx = new MapKeycloakTransaction<>(userStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private MapUserEntity registerEntityForChanges(MapUserEntity origEntity) {\n+        MapUserEntity res = tx.get(origEntity.getId(), id -> Serialization.from(origEntity));\n+        tx.putIfChanged(origEntity.getId(), res, MapUserEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Function<MapUserEntity, UserModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+        return origEntity -> new MapUserAdapter(session, realm, registerEntityForChanges(origEntity)) {\n+\n+            @Override\n+            public boolean checkEmailUniqueness(RealmModel realm, String email) {\n+                return getUserByEmail(email, realm) != null;\n+            }\n+\n+            @Override\n+            public boolean checkUsernameUniqueness(RealmModel realm, String username) {\n+                return getUserByUsername(username, realm) != null;\n+            }\n+        };\n+    }\n+\n+    private Predicate<MapUserEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapUserProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private ModelException userDoesntExistException() {\n+        return new ModelException(\"Specified user doesn't exist.\");\n+    }\n+\n+    private Optional<MapUserEntity> getEntityById(RealmModel realm, String id) {\n+        try {\n+            return getEntityById(realm, UUID.fromString(id));\n+        } catch (IllegalArgumentException ex) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private MapUserEntity getEntityByIdOrThrow(RealmModel realm, String id) {\n+        return getEntityById(realm, id)\n+                .orElseThrow(this::userDoesntExistException);\n+    }\n+\n+    private Optional<MapUserEntity> getEntityById(RealmModel realm, UUID id) {\n+        MapUserEntity mapUserEntity = tx.get(id, userStore::get);\n+        if (mapUserEntity != null && entityRealmFilter(realm).test(mapUserEntity)) {\n+            return Optional.of(mapUserEntity);\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    private Optional<MapUserEntity> getRegisteredEntityById(RealmModel realm, String id) {\n+        return getEntityById(realm, id).map(this::registerEntityForChanges);\n+    }\n+\n+    private Stream<MapUserEntity> getNotRemovedUpdatedUsersStream() {\n+        Stream<MapUserEntity> updatedAndNotRemovedUsersStream = userStore.entrySet().stream()\n+                .map(tx::getUpdated)    // If the group has been removed, tx.get will return null, otherwise it will return me.getValue()\n+                .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(), updatedAndNotRemovedUsersStream);\n+    }\n+\n+    private Stream<MapUserEntity> getUnsortedUserEntitiesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedUsersStream()\n+                .filter(entityRealmFilter(realm));\n+    }\n+    \n+    private <T> Stream<T> paginatedStream(Stream<T> originalStream, Integer first, Integer max) {\n+        if (first != null && first > 0) {\n+            originalStream = originalStream.skip(first);\n+        }\n+\n+        if (max != null && max >= 0) {\n+            originalStream = originalStream.limit(max);\n+        }\n+\n+        return originalStream;\n+    }\n+\n+    @Override\n+    public void addFederatedIdentity(RealmModel realm, UserModel user, FederatedIdentityModel socialLink) {\n+        if (user == null || user.getId() == null) {\n+            return;\n+        }\n+        LOG.tracef(\"addFederatedIdentity(%s, %s, %s)%s\", realm, user.getId(), socialLink.getIdentityProvider(), getShortStackTrace());\n+\n+        getRegisteredEntityById(realm, user.getId())\n+                .ifPresent(userEntity ->\n+                        userEntity.addFederatedIdentity(UserFederatedIdentityEntity.fromModel(socialLink)));\n+    }\n+\n+    @Override\n+    public boolean removeFederatedIdentity(RealmModel realm, UserModel user, String socialProvider) {\n+        LOG.tracef(\"removeFederatedIdentity(%s, %s, %s)%s\", realm, user.getId(), socialProvider, getShortStackTrace());\n+        return getRegisteredEntityById(realm, user.getId())\n+                .map(entity -> entity.removeFederatedIdentity(socialProvider))\n+                .orElse(false);\n+    }\n+\n+    @Override\n+    public void preRemove(RealmModel realm, IdentityProviderModel provider) {\n+        String socialProvider = provider.getAlias();\n+        LOG.tracef(\"preRemove[RealmModel realm, IdentityProviderModel provider](%s, %s)%s\", realm, socialProvider, getShortStackTrace());\n+        getUnsortedUserEntitiesStream(realm)\n+                .map(this::registerEntityForChanges)\n+                .forEach(userEntity -> userEntity.removeFederatedIdentity(socialProvider));\n+    }\n+\n+    @Override\n+    public void updateFederatedIdentity(RealmModel realm, UserModel federatedUser, FederatedIdentityModel federatedIdentityModel) {\n+        LOG.tracef(\"updateFederatedIdentity(%s, %s, %s)%s\", realm, federatedUser.getId(), federatedIdentityModel.getIdentityProvider(), getShortStackTrace());\n+        getRegisteredEntityById(realm, federatedUser.getId())\n+                .ifPresent(entity -> entity.updateFederatedIdentity(UserFederatedIdentityEntity.fromModel(federatedIdentityModel)));\n+    }\n+\n+    @Override\n+    public Stream<FederatedIdentityModel> getFederatedIdentitiesStream(UserModel user, RealmModel realm) {\n+        LOG.tracef(\"getFederatedIdentitiesStream(%s, %s)%s\", realm, user.getId(), getShortStackTrace());\n+        return getEntityById(realm, user.getId())\n+                .map(AbstractUserEntity::getFederatedIdentities).orElseGet(Stream::empty)\n+                .map(UserFederatedIdentityEntity::toModel);\n+    }\n+\n+    @Override\n+    public FederatedIdentityModel getFederatedIdentity(UserModel user, String socialProvider, RealmModel realm) {\n+        LOG.tracef(\"getFederatedIdentity(%s, %s, %s)%s\", realm, user.getId(), socialProvider, getShortStackTrace());\n+        return getRegisteredEntityById(realm, user.getId())\n+                .map(userEntity -> userEntity.getFederatedIdentity(socialProvider))\n+                .map(UserFederatedIdentityEntity::toModel)\n+                .orElse(null);\n+    }\n+\n+    @Override\n+    public UserModel getUserByFederatedIdentity(FederatedIdentityModel socialLink, RealmModel realm) {\n+        LOG.tracef(\"getUserByFederatedIdentity(%s, %s)%s\", realm, socialLink, getShortStackTrace());\n+        return getUnsortedUserEntitiesStream(realm)\n+                .filter(userEntity -> Objects.nonNull(userEntity.getFederatedIdentity(socialLink.getIdentityProvider())))\n+                .filter(userEntity -> Objects.equals(userEntity.getFederatedIdentity(socialLink.getIdentityProvider()).getUserId(), socialLink.getUserId()))\n+                .collect(Collectors.collectingAndThen(\n+                        Collectors.toList(),\n+                        list -> {\n+                            if (list.size() == 0) {\n+                                return null;\n+                            } else if (list.size() != 1) {\n+                                throw new IllegalStateException(\"More results found for identityProvider=\" + socialLink.getIdentityProvider() +\n+                                        \", userId=\" + socialLink.getUserId() + \", results=\" + list);\n+                            }\n+\n+                            return entityToAdapterFunc(realm).apply(list.get(0));\n+                        }));\n+    }\n+\n+    @Override\n+    public void addConsent(RealmModel realm, String userId, UserConsentModel consent) {\n+        LOG.tracef(\"addConsent(%s, %s, %s)%s\", realm, userId, consent, getShortStackTrace());\n+\n+        UserConsentEntity consentEntity = UserConsentEntity.fromModel(consent);\n+        getRegisteredEntityById(realm, userId).ifPresent(userEntity -> userEntity.addUserConsent(consentEntity));\n+    }\n+\n+    @Override\n+    public UserConsentModel getConsentByClient(RealmModel realm, String userId, String clientInternalId) {\n+        LOG.tracef(\"getConsentByClient(%s, %s, %s)%s\", realm, userId, clientInternalId, getShortStackTrace());\n+        return getEntityById(realm, userId)\n+                .map(userEntity -> userEntity.getUserConsent(clientInternalId))\n+                .map(consent -> UserConsentEntity.toModel(realm, consent))\n+                .orElse(null);\n+    }\n+\n+    @Override\n+    public Stream<UserConsentModel> getConsentsStream(RealmModel realm, String userId) {\n+        LOG.tracef(\"getConsentByClientStream(%s, %s)%s\", realm, userId, getShortStackTrace());\n+        return getRegisteredEntityById(realm, userId)\n+                .map(AbstractUserEntity::getUserConsents)\n+                .orElse(Stream.empty())\n+                .map(consent -> UserConsentEntity.toModel(realm, consent));\n+    }\n+\n+    @Override\n+    public void updateConsent(RealmModel realm, String userId, UserConsentModel consent) {\n+        LOG.tracef(\"updateConsent(%s, %s, %s)%s\", realm, userId, consent, getShortStackTrace());\n+\n+        MapUserEntity user = getEntityByIdOrThrow(realm, userId);\n+        UserConsentEntity userConsentEntity = user.getUserConsent(consent.getClient().getId());\n+        if (userConsentEntity == null) {\n+            throw new ModelException(\"Consent or not found for client [\" + consent.getClient().getId() + \"] and user [\" + userId + \"]\");", "originalCommit": "2414212e6ac1e91ad9c902eb5833dfc62cb89084", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA4MzM4Mg==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539083382", "bodyText": "done", "author": "mhajas", "createdAt": "2020-12-09T07:57:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczMDQ5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczMDYzMQ==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538730631", "bodyText": "Not sure if I fully understand how all this works but shouldn't this update happen in a transaction?", "author": "sguilhen", "createdAt": "2020-12-08T19:04:30Z", "path": "model/map/src/main/java/org/keycloak/models/map/user/MapUserProvider.java", "diffHunk": "@@ -0,0 +1,875 @@\n+package org.keycloak.models.map.user;\n+\n+import org.apache.commons.lang.StringUtils;\n+import org.jboss.logging.Logger;\n+import org.keycloak.authorization.AuthorizationProvider;\n+import org.keycloak.authorization.store.ResourceStore;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.credential.CredentialModel;\n+import org.keycloak.credential.UserCredentialStore;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.FederatedIdentityModel;\n+import org.keycloak.models.GroupModel;\n+import org.keycloak.models.IdentityProviderModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.ModelException;\n+import org.keycloak.models.ProtocolMapperModel;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.RequiredActionProviderModel;\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserProvider;\n+import org.keycloak.models.map.common.Serialization;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.storage.MapStorage;\n+import org.keycloak.models.utils.DefaultRoles;\n+import org.keycloak.storage.StorageId;\n+import org.keycloak.storage.UserStorageProvider;\n+import org.keycloak.storage.client.ClientStorageProvider;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import static org.keycloak.models.UserModel.EMAIL;\n+import static org.keycloak.models.UserModel.EMAIL_VERIFIED;\n+import static org.keycloak.models.UserModel.FIRST_NAME;\n+import static org.keycloak.models.UserModel.LAST_NAME;\n+import static org.keycloak.models.UserModel.USERNAME;\n+\n+public class MapUserProvider implements UserProvider.Streams, UserCredentialStore {\n+\n+    private static final Logger LOG = Logger.getLogger(MapUserProvider.class);\n+    private static final Predicate<MapUserEntity> ALWAYS_FALSE = c -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapUserEntity> tx;\n+    private final MapStorage<UUID, MapUserEntity> userStore;\n+\n+    public MapUserProvider(KeycloakSession session, MapStorage<UUID, MapUserEntity> store) {\n+        this.session = session;\n+        this.userStore = store;\n+        this.tx = new MapKeycloakTransaction<>(userStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private MapUserEntity registerEntityForChanges(MapUserEntity origEntity) {\n+        MapUserEntity res = tx.get(origEntity.getId(), id -> Serialization.from(origEntity));\n+        tx.putIfChanged(origEntity.getId(), res, MapUserEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Function<MapUserEntity, UserModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+        return origEntity -> new MapUserAdapter(session, realm, registerEntityForChanges(origEntity)) {\n+\n+            @Override\n+            public boolean checkEmailUniqueness(RealmModel realm, String email) {\n+                return getUserByEmail(email, realm) != null;\n+            }\n+\n+            @Override\n+            public boolean checkUsernameUniqueness(RealmModel realm, String username) {\n+                return getUserByUsername(username, realm) != null;\n+            }\n+        };\n+    }\n+\n+    private Predicate<MapUserEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapUserProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private ModelException userDoesntExistException() {\n+        return new ModelException(\"Specified user doesn't exist.\");\n+    }\n+\n+    private Optional<MapUserEntity> getEntityById(RealmModel realm, String id) {\n+        try {\n+            return getEntityById(realm, UUID.fromString(id));\n+        } catch (IllegalArgumentException ex) {\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private MapUserEntity getEntityByIdOrThrow(RealmModel realm, String id) {\n+        return getEntityById(realm, id)\n+                .orElseThrow(this::userDoesntExistException);\n+    }\n+\n+    private Optional<MapUserEntity> getEntityById(RealmModel realm, UUID id) {\n+        MapUserEntity mapUserEntity = tx.get(id, userStore::get);\n+        if (mapUserEntity != null && entityRealmFilter(realm).test(mapUserEntity)) {\n+            return Optional.of(mapUserEntity);\n+        }\n+\n+        return Optional.empty();\n+    }\n+\n+    private Optional<MapUserEntity> getRegisteredEntityById(RealmModel realm, String id) {\n+        return getEntityById(realm, id).map(this::registerEntityForChanges);\n+    }\n+\n+    private Stream<MapUserEntity> getNotRemovedUpdatedUsersStream() {\n+        Stream<MapUserEntity> updatedAndNotRemovedUsersStream = userStore.entrySet().stream()\n+                .map(tx::getUpdated)    // If the group has been removed, tx.get will return null, otherwise it will return me.getValue()\n+                .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(), updatedAndNotRemovedUsersStream);\n+    }\n+\n+    private Stream<MapUserEntity> getUnsortedUserEntitiesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedUsersStream()\n+                .filter(entityRealmFilter(realm));\n+    }\n+    \n+    private <T> Stream<T> paginatedStream(Stream<T> originalStream, Integer first, Integer max) {\n+        if (first != null && first > 0) {\n+            originalStream = originalStream.skip(first);\n+        }\n+\n+        if (max != null && max >= 0) {\n+            originalStream = originalStream.limit(max);\n+        }\n+\n+        return originalStream;\n+    }\n+\n+    @Override\n+    public void addFederatedIdentity(RealmModel realm, UserModel user, FederatedIdentityModel socialLink) {\n+        if (user == null || user.getId() == null) {\n+            return;\n+        }\n+        LOG.tracef(\"addFederatedIdentity(%s, %s, %s)%s\", realm, user.getId(), socialLink.getIdentityProvider(), getShortStackTrace());\n+\n+        getRegisteredEntityById(realm, user.getId())\n+                .ifPresent(userEntity ->\n+                        userEntity.addFederatedIdentity(UserFederatedIdentityEntity.fromModel(socialLink)));\n+    }\n+\n+    @Override\n+    public boolean removeFederatedIdentity(RealmModel realm, UserModel user, String socialProvider) {\n+        LOG.tracef(\"removeFederatedIdentity(%s, %s, %s)%s\", realm, user.getId(), socialProvider, getShortStackTrace());\n+        return getRegisteredEntityById(realm, user.getId())\n+                .map(entity -> entity.removeFederatedIdentity(socialProvider))\n+                .orElse(false);\n+    }\n+\n+    @Override\n+    public void preRemove(RealmModel realm, IdentityProviderModel provider) {\n+        String socialProvider = provider.getAlias();\n+        LOG.tracef(\"preRemove[RealmModel realm, IdentityProviderModel provider](%s, %s)%s\", realm, socialProvider, getShortStackTrace());\n+        getUnsortedUserEntitiesStream(realm)\n+                .map(this::registerEntityForChanges)\n+                .forEach(userEntity -> userEntity.removeFederatedIdentity(socialProvider));\n+    }\n+\n+    @Override\n+    public void updateFederatedIdentity(RealmModel realm, UserModel federatedUser, FederatedIdentityModel federatedIdentityModel) {\n+        LOG.tracef(\"updateFederatedIdentity(%s, %s, %s)%s\", realm, federatedUser.getId(), federatedIdentityModel.getIdentityProvider(), getShortStackTrace());\n+        getRegisteredEntityById(realm, federatedUser.getId())\n+                .ifPresent(entity -> entity.updateFederatedIdentity(UserFederatedIdentityEntity.fromModel(federatedIdentityModel)));\n+    }\n+\n+    @Override\n+    public Stream<FederatedIdentityModel> getFederatedIdentitiesStream(UserModel user, RealmModel realm) {\n+        LOG.tracef(\"getFederatedIdentitiesStream(%s, %s)%s\", realm, user.getId(), getShortStackTrace());\n+        return getEntityById(realm, user.getId())\n+                .map(AbstractUserEntity::getFederatedIdentities).orElseGet(Stream::empty)\n+                .map(UserFederatedIdentityEntity::toModel);\n+    }\n+\n+    @Override\n+    public FederatedIdentityModel getFederatedIdentity(UserModel user, String socialProvider, RealmModel realm) {\n+        LOG.tracef(\"getFederatedIdentity(%s, %s, %s)%s\", realm, user.getId(), socialProvider, getShortStackTrace());\n+        return getRegisteredEntityById(realm, user.getId())\n+                .map(userEntity -> userEntity.getFederatedIdentity(socialProvider))\n+                .map(UserFederatedIdentityEntity::toModel)\n+                .orElse(null);\n+    }\n+\n+    @Override\n+    public UserModel getUserByFederatedIdentity(FederatedIdentityModel socialLink, RealmModel realm) {\n+        LOG.tracef(\"getUserByFederatedIdentity(%s, %s)%s\", realm, socialLink, getShortStackTrace());\n+        return getUnsortedUserEntitiesStream(realm)\n+                .filter(userEntity -> Objects.nonNull(userEntity.getFederatedIdentity(socialLink.getIdentityProvider())))\n+                .filter(userEntity -> Objects.equals(userEntity.getFederatedIdentity(socialLink.getIdentityProvider()).getUserId(), socialLink.getUserId()))\n+                .collect(Collectors.collectingAndThen(\n+                        Collectors.toList(),\n+                        list -> {\n+                            if (list.size() == 0) {\n+                                return null;\n+                            } else if (list.size() != 1) {\n+                                throw new IllegalStateException(\"More results found for identityProvider=\" + socialLink.getIdentityProvider() +\n+                                        \", userId=\" + socialLink.getUserId() + \", results=\" + list);\n+                            }\n+\n+                            return entityToAdapterFunc(realm).apply(list.get(0));\n+                        }));\n+    }\n+\n+    @Override\n+    public void addConsent(RealmModel realm, String userId, UserConsentModel consent) {\n+        LOG.tracef(\"addConsent(%s, %s, %s)%s\", realm, userId, consent, getShortStackTrace());\n+\n+        UserConsentEntity consentEntity = UserConsentEntity.fromModel(consent);\n+        getRegisteredEntityById(realm, userId).ifPresent(userEntity -> userEntity.addUserConsent(consentEntity));\n+    }\n+\n+    @Override\n+    public UserConsentModel getConsentByClient(RealmModel realm, String userId, String clientInternalId) {\n+        LOG.tracef(\"getConsentByClient(%s, %s, %s)%s\", realm, userId, clientInternalId, getShortStackTrace());\n+        return getEntityById(realm, userId)\n+                .map(userEntity -> userEntity.getUserConsent(clientInternalId))\n+                .map(consent -> UserConsentEntity.toModel(realm, consent))\n+                .orElse(null);\n+    }\n+\n+    @Override\n+    public Stream<UserConsentModel> getConsentsStream(RealmModel realm, String userId) {\n+        LOG.tracef(\"getConsentByClientStream(%s, %s)%s\", realm, userId, getShortStackTrace());\n+        return getRegisteredEntityById(realm, userId)\n+                .map(AbstractUserEntity::getUserConsents)\n+                .orElse(Stream.empty())\n+                .map(consent -> UserConsentEntity.toModel(realm, consent));\n+    }\n+\n+    @Override\n+    public void updateConsent(RealmModel realm, String userId, UserConsentModel consent) {\n+        LOG.tracef(\"updateConsent(%s, %s, %s)%s\", realm, userId, consent, getShortStackTrace());\n+\n+        MapUserEntity user = getEntityByIdOrThrow(realm, userId);\n+        UserConsentEntity userConsentEntity = user.getUserConsent(consent.getClient().getId());\n+        if (userConsentEntity == null) {\n+            throw new ModelException(\"Consent or not found for client [\" + consent.getClient().getId() + \"] and user [\" + userId + \"]\");\n+        }\n+\n+        userConsentEntity.setGrantedClientScopesIds(\n+                consent.getGrantedClientScopes().stream()\n+                        .map(ClientScopeModel::getId)\n+                        .collect(Collectors.toSet())\n+        );\n+\n+        userConsentEntity.setLastUpdatedDate(Time.currentTimeMillis());", "originalCommit": "2414212e6ac1e91ad9c902eb5833dfc62cb89084", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA4NTI2MA==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539085260", "bodyText": "Well this is the opposite scenario than before. This is where we need the registered entity, otherwise it won't be done in transaction. Nice catch! I changed the method getEntityByIdOrThrow to getRegisteredEntityByIdOrThrow.", "author": "mhajas", "createdAt": "2020-12-09T08:00:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODczMDYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTE3MjE2Nw==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r535172167", "bodyText": "This is really nit, probably forgotten here.", "author": "vramik", "createdAt": "2020-12-03T12:09:23Z", "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/forms/LoginTest.java", "diffHunk": "@@ -89,11 +90,11 @@\n  * @author <a href=\"mailto:sthorger@redhat.com\">Stian Thorgersen</a>\n  */\n public class LoginTest extends AbstractTestRealmKeycloakTest {\n-\n+    ", "originalCommit": "8df17fe710c6b7ad8c41a65a18137885f2692c53", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA4NzE2MA==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539087160", "bodyText": "I always thought that when I see this in a commit it is something that was there before, and Intellij is automatically fixing it. I hope it is not always the other way around, that I accidentally added it. Thanks for spotting this I will be checking this in future commits.", "author": "mhajas", "createdAt": "2020-12-09T08:03:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTE3MjE2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NDAwNQ==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538754005", "bodyText": "Should we also update UserPropertyFileStorage from testsuite-providers to implement stream-Integer variant instead of the deprecated one?", "author": "vramik", "createdAt": "2020-12-08T19:40:43Z", "path": "server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java", "diffHunk": "@@ -214,7 +214,7 @@ default int getUsersCount(RealmModel realm, boolean includeServiceAccount) {\n      * @param firstResult\n      * @param maxResults\n      * @return\n-     * @deprecated Use {@link #searchForUserStream(String, RealmModel, int, int) searchForUserStream} instead.\n+     * @deprecated Use {@link #searchForUserStream(String, RealmModel, Integer, Integer) searchForUserStream} instead.\n      */\n     @Deprecated\n     List<UserModel> searchForUser(String search, RealmModel realm, int firstResult, int maxResults);", "originalCommit": "2414212e6ac1e91ad9c902eb5833dfc62cb89084", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5MDk1OQ==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539090959", "bodyText": "This is good question, I am not sure. @hmlnarik wanted to leave BackwardsCompatibilityUserStorage as is to implement the old variant. Not sure about the others. There are more providers in testsuite that implement old variants. If we decide to make all except for BackwardsCompatibilityUserStorage implement Streams variants I can make it part of Cleanup PR. @hmlnarik @sguilhen WDYT?", "author": "mhajas", "createdAt": "2020-12-09T08:09:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NDAwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI1NTY2MA==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539255660", "bodyText": "At this moment, either option is open. It would be better to follow @vramik's suggestion if that does not represent a big amount of work at this point. In the opposite case, we can postpone this for either cleanup or even later when removing the interaces.", "author": "hmlnarik", "createdAt": "2020-12-09T12:13:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NDAwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI1NzkwNg==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539257906", "bodyText": "I will make it part of https://issues.redhat.com/browse/KEYCLOAK-15524. Does it work for you @vramik @hmlnarik?", "author": "mhajas", "createdAt": "2020-12-09T12:16:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NDAwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTI1OTI2Mg==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539259262", "bodyText": "It works for me.", "author": "vramik", "createdAt": "2020-12-09T12:18:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1NDAwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1ODI2MQ==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538758261", "bodyText": "This is really nit, probably forgotten here.", "author": "vramik", "createdAt": "2020-12-08T19:47:35Z", "path": "testsuite/integration-arquillian/servers/auth-server/services/testsuite-providers/src/main/java/org/keycloak/testsuite/events/TestEventsListenerProvider.java", "diffHunk": "@@ -19,30 +19,36 @@\n \n import org.keycloak.events.Event;\n import org.keycloak.events.EventListenerProvider;\n+import org.keycloak.events.EventListenerTransaction;\n import org.keycloak.events.admin.AdminEvent;\n+import org.keycloak.models.KeycloakSession;\n \n import java.util.concurrent.BlockingQueue;\n import java.util.concurrent.LinkedBlockingQueue;\n \n /**\n  * @author <a href=\"mailto:mstrukel@redhat.com\">Marko Strukelj</a>\n  */\n-public class EventsListenerProvider implements EventListenerProvider {\n+public class TestEventsListenerProvider implements EventListenerProvider {\n \n     private static final BlockingQueue<Event> events = new LinkedBlockingQueue<Event>();\n     private static final BlockingQueue<AdminEvent> adminEvents = new LinkedBlockingQueue<>();\n+    private final EventListenerTransaction tx = new EventListenerTransaction((event, includeRepre) -> adminEvents.add(event), events::add);\n+\n+    public TestEventsListenerProvider(KeycloakSession session) {\n+        session.getTransactionManager().enlistAfterCompletion(tx);\n+    }\n \n     @Override\n     public void onEvent(Event event) {\n-        events.add(event);\n+        tx.addEvent(event);\n     }\n \n     @Override\n     public void onEvent(AdminEvent event, boolean includeRepresentation) {\n-        // Save the copy for case when same AdminEventBuilder is used more times during same transaction to avoid overwriting previously referenced event\n-        adminEvents.add(copy(event));\n+        tx.addAdminEvent(event, includeRepresentation);\n     }\n-\n+    ", "originalCommit": "2414212e6ac1e91ad9c902eb5833dfc62cb89084", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5MjI2Mw==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539092263", "bodyText": "done", "author": "mhajas", "createdAt": "2020-12-09T08:10:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc1ODI2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2MzUwNQ==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538763505", "bodyText": "missing copyright", "author": "vramik", "createdAt": "2020-12-08T19:55:58Z", "path": "model/map/src/main/java/org/keycloak/models/map/user/MapUserProvider.java", "diffHunk": "@@ -0,0 +1,875 @@\n+package org.keycloak.models.map.user;", "originalCommit": "2414212e6ac1e91ad9c902eb5833dfc62cb89084", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5MjM3OA==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539092378", "bodyText": "done", "author": "mhajas", "createdAt": "2020-12-09T08:11:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2MzUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2NDk3Ng==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538764976", "bodyText": "missing copyright", "author": "vramik", "createdAt": "2020-12-08T19:58:15Z", "path": "model/map/src/main/test/java/org/keycloak/models/map/user/AbstractUserEntityCredentialsOrderTest.java", "diffHunk": "@@ -0,0 +1,68 @@\n+package org.keycloak.models.map.user;", "originalCommit": "2414212e6ac1e91ad9c902eb5833dfc62cb89084", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5NTMxMQ==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539095311", "bodyText": "done", "author": "mhajas", "createdAt": "2020-12-09T08:15:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2NDk3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2NTExMg==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538765112", "bodyText": "missing copyright", "author": "vramik", "createdAt": "2020-12-08T19:58:29Z", "path": "server-spi-private/src/main/java/org/keycloak/events/EventListenerProvider.java", "diffHunk": "@@ -18,15 +18,54 @@\n package org.keycloak.events;", "originalCommit": "2414212e6ac1e91ad9c902eb5833dfc62cb89084", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5NjMyOA==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539096328", "bodyText": "It is there. Should I update it somehow?", "author": "mhajas", "createdAt": "2020-12-09T08:16:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2NTExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5NzQ5Nw==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539097497", "bodyText": "Sorry I've overlooked this one, please ignore.", "author": "vramik", "createdAt": "2020-12-09T08:18:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2NTExMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5ODc3MQ==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539098771", "bodyText": "np", "author": "mhajas", "createdAt": "2020-12-09T08:20:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2NTExMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2NTI3MQ==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538765271", "bodyText": "missing copyright", "author": "vramik", "createdAt": "2020-12-08T19:58:44Z", "path": "server-spi-private/src/main/java/org/keycloak/events/EventListenerTransaction.java", "diffHunk": "@@ -0,0 +1,62 @@\n+package org.keycloak.events;", "originalCommit": "2414212e6ac1e91ad9c902eb5833dfc62cb89084", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5NzIwNA==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539097204", "bodyText": "done", "author": "mhajas", "createdAt": "2020-12-09T08:18:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2NTI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2NzAwNg==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538767006", "bodyText": "This import is not necessary here.", "author": "vramik", "createdAt": "2020-12-08T20:01:30Z", "path": "testsuite/model/src/test/java/org/keycloak/testsuite/model/UserModelTest.java", "diffHunk": "@@ -37,13 +37,17 @@\n import java.util.stream.IntStream;\n import org.hamcrest.Matchers;\n import org.junit.Test;\n+import org.keycloak.testsuite.federation.UserMapStorage;", "originalCommit": "2414212e6ac1e91ad9c902eb5833dfc62cb89084", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5NzI3MA==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539097270", "bodyText": "done", "author": "mhajas", "createdAt": "2020-12-09T08:18:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2NzAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2NzA4OQ==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538767089", "bodyText": "dtto", "author": "vramik", "createdAt": "2020-12-08T20:01:39Z", "path": "testsuite/model/src/test/java/org/keycloak/testsuite/model/UserModelTest.java", "diffHunk": "@@ -37,13 +37,17 @@\n import java.util.stream.IntStream;\n import org.hamcrest.Matchers;\n import org.junit.Test;\n+import org.keycloak.testsuite.federation.UserMapStorage;\n+\n import static org.hamcrest.Matchers.hasItem;\n import static org.hamcrest.Matchers.hasSize;\n import static org.hamcrest.Matchers.is;\n import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNull;\n import static org.junit.Assert.assertThat;\n import static org.junit.Assert.assertTrue;\n import static org.junit.Assume.assumeThat;\n+import static org.junit.Assume.assumeTrue;", "originalCommit": "2414212e6ac1e91ad9c902eb5833dfc62cb89084", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5NzMxNQ==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539097315", "bodyText": "done", "author": "mhajas", "createdAt": "2020-12-09T08:18:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2NzA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2ODcwNQ==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538768705", "bodyText": "If I understand it correctly the test is actually changed to test something else than before, right? Can you please explain to me what has changed?", "author": "vramik", "createdAt": "2020-12-08T20:04:20Z", "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/federation/ldap/LDAPBinaryAttributesTest.java", "diffHunk": "@@ -156,18 +158,16 @@ public void test03WritableMapper() {\n         // Assert he is found including jpegPhoto\n         joe = getUserAndAssertPhoto(\"joephoto\", true);\n \n+        // Assert that local storage doesn't contain LDAPConstants.JPEG_PHOTO, it should be stored in the LDAP\n+        String joeId = joe.getId();\n+        testingClient.server().run(session -> {\n+            RealmModel test = session.realms().getRealmByName(\"test\");\n+            UserModel userById = session.userLocalStorage().getUserById(joeId, test);\n+\n+            assertThat(userById.getAttributes().get(LDAPConstants.JPEG_PHOTO), is(nullValue()));\n+        });\n \n-        // Try to update him with some big non-LDAP mapped attribute. It will fail\n-        try {\n-            joe.getAttributes().put(\"someOtherPhoto\", Arrays.asList(JPEG_PHOTO_BASE64));\n-            adminClient.realm(\"test\").users().get(joe.getId()).update(joe);\n-            Assert.fail(\"Not expected to successfully update user\");\n-        } catch (ClientErrorException cee) {\n-            // Expected\n-        }", "originalCommit": "2414212e6ac1e91ad9c902eb5833dfc62cb89084", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEwNTAwOA==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539105008", "bodyText": "This test is testing that attribute with name LDAPConstants.JPEG_PHOTO is not stored in local storage but in LDAP because of the mapper created on line 147. The original implementation was relying on the fact that the database is not even able to store such a long value > 255 character (probably depending on DB). This means that if storing of  LDAPConstants.JPEG_PHOTO attribute passed it was not stored in DB but in LDAP. However, if we try to store attribute someOtherPhoto with the same value, it will throw ClientErrorException because this time DB will refuse the value.\nHowever, with Map storage we can store such values, therefore this test was not working correctly. I changed it so that we are not testing based on DB refusing the value, but we just check local storage for the attribute not to be present there.", "author": "mhajas", "createdAt": "2020-12-09T08:30:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2ODcwNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEwODYxMw==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539108613", "bodyText": "It makes perfect sense to me now, thank you for explanation.", "author": "vramik", "createdAt": "2020-12-09T08:36:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc2ODcwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MTI0Nw==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538771247", "bodyText": "missing copyright", "author": "vramik", "createdAt": "2020-12-08T20:08:45Z", "path": "model/map/src/main/java/org/keycloak/models/map/user/UserCredentialEntity.java", "diffHunk": "@@ -0,0 +1,103 @@\n+package org.keycloak.models.map.user;", "originalCommit": "2414212e6ac1e91ad9c902eb5833dfc62cb89084", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5Nzg2MA==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539097860", "bodyText": "done", "author": "mhajas", "createdAt": "2020-12-09T08:19:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MTI0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MTM4Mw==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538771383", "bodyText": "missing copyright", "author": "vramik", "createdAt": "2020-12-08T20:08:58Z", "path": "model/map/src/main/java/org/keycloak/models/map/user/UserConsentEntity.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package org.keycloak.models.map.user;", "originalCommit": "2414212e6ac1e91ad9c902eb5833dfc62cb89084", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5ODA2MA==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539098060", "bodyText": "done", "author": "mhajas", "createdAt": "2020-12-09T08:19:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MTM4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MTUxMg==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538771512", "bodyText": "missing copyright", "author": "vramik", "createdAt": "2020-12-08T20:09:10Z", "path": "model/map/src/main/java/org/keycloak/models/map/user/UserFederatedIdentityEntity.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package org.keycloak.models.map.user;", "originalCommit": "2414212e6ac1e91ad9c902eb5833dfc62cb89084", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5ODEyMg==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539098122", "bodyText": "done", "author": "mhajas", "createdAt": "2020-12-09T08:19:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3MTUxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NDM5NQ==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538774395", "bodyText": "nit: the javadoc's params are not aligned with actual method contract", "author": "vramik", "createdAt": "2020-12-08T20:14:01Z", "path": "server-spi/src/main/java/org/keycloak/storage/user/UserQueryProvider.java", "diffHunk": "@@ -405,17 +405,17 @@ default int getUsersCount(RealmModel realm, boolean includeServiceAccount) {\n      * @return a non-null {@link Stream} of users that have the specified role.\n      */\n     default Stream<UserModel> getRoleMembersStream(RealmModel realm, RoleModel role) {\n-        return Stream.empty();\n+        return getRoleMembersStream(realm, role, null, null);\n     }\n \n     /**\n      * Search for users that have a specific role with a specific roleId.\n      *\n+     * @param role", "originalCommit": "2414212e6ac1e91ad9c902eb5833dfc62cb89084", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTA5NTIwMQ==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539095201", "bodyText": "I will update all javadocs as part of Cleanup task. I believe it will be ready soon after merging this one. See https://issues.redhat.com/browse/KEYCLOAK-15524", "author": "mhajas", "createdAt": "2020-12-09T08:15:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NDM5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NjY1OA==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r538776658", "bodyText": "out of curiosity: can you please explain to me why we need to send admin event before commiting the transaction?", "author": "vramik", "createdAt": "2020-12-08T20:17:39Z", "path": "services/src/main/java/org/keycloak/services/resources/admin/ClientScopeResource.java", "diffHunk": "@@ -101,10 +101,11 @@ public Response update(final ClientScopeRepresentation rep) {\n \n         try {\n             RepresentationToModel.updateClientScope(rep, clientScope);\n+            adminEvent.operation(OperationType.UPDATE).resourcePath(session.getContext().getUri()).representation(rep).success();", "originalCommit": "2414212e6ac1e91ad9c902eb5833dfc62cb89084", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTEyMzQ1NQ==", "url": "https://github.com/keycloak/keycloak/pull/7645#discussion_r539123455", "bodyText": "I changed whole event processing a little, see javadoc in EventListenerProvider.\nTLDR: All events are now fired only after successful transaction not in the moment when success() function is called like it was before.\nI am not sure what was the exact reason her for moving it before commit, but it makes sense since we send all events in afterTransaction.", "author": "mhajas", "createdAt": "2020-12-09T08:58:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODc3NjY1OA=="}], "type": "inlineReview"}, {"oid": "c0ddcec30e6e57cb6a58bfc6695942242c91ef29", "url": "https://github.com/keycloak/keycloak/commit/c0ddcec30e6e57cb6a58bfc6695942242c91ef29", "message": "KEYCLOAK-15847 Incorporate Stefan's suggestions", "committedDate": "2020-12-09T08:01:35Z", "type": "commit"}, {"oid": "e9842f4581ba691ca33a4ba2619d660c438e3038", "url": "https://github.com/keycloak/keycloak/commit/e9842f4581ba691ca33a4ba2619d660c438e3038", "message": "KEYCLOAK-15847 Incorporate Vlasta's suggestions", "committedDate": "2020-12-09T08:59:05Z", "type": "commit"}]}