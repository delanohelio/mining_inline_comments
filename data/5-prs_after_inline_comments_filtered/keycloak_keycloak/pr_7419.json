{"pr_number": 7419, "pr_title": "KEYCLOAK-14204 FAPI-RW Client Policy - Executor : Enforce Request Object satisfying high security level", "pr_createdAt": "2020-09-15T05:30:20Z", "pr_url": "https://github.com/keycloak/keycloak/pull/7419", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NzU4Nw==", "url": "https://github.com/keycloak/keycloak/pull/7419#discussion_r489247587", "bodyText": "Does this method needs to be public? Perhaps \"private\" is sufficient?", "author": "mposolda", "createdAt": "2020-09-16T08:11:58Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/SecureRequestObjectExecutor.java", "diffHunk": "@@ -0,0 +1,508 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.common.util.StreamUtil;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.connections.httpclient.HttpClientProvider;\n+import org.keycloak.constants.AdapterConstants;\n+import org.keycloak.jose.jws.JWSInput;\n+import org.keycloak.jose.jws.JWSInputException;\n+import org.keycloak.models.Constants;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.JsonWebToken;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.clientpolicy.AuthorizationRequestContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyLogger;\n+import org.keycloak.util.JsonSerialization;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.JsonNode;\n+\n+public class SecureRequestObjectExecutor implements ClientPolicyExecutorProvider {\n+\n+    private static final Logger logger = Logger.getLogger(SecureRequestObjectExecutor.class);\n+\n+    private final KeycloakSession session;\n+    private final ComponentModel componentModel;\n+\n+    private AuthorizationEndpointRequestObject parsedRequestObject;\n+\n+    public static final String INVALID_REQUEST_OBJECT = \"invalid_request_object\";\n+\n+    public SecureRequestObjectExecutor(KeycloakSession session, ComponentModel componentModel) {\n+        this.session = session;\n+        this.componentModel = componentModel;\n+    }\n+\n+    @Override\n+    public void executeOnEvent(ClientPolicyContext context) throws ClientPolicyException {\n+        switch (context.getEvent()) {\n+            case AUTHORIZATION_REQUEST:\n+                AuthorizationRequestContext authorizationRequestContext = (AuthorizationRequestContext)context;\n+                executeOnAuthorizationRequest(authorizationRequestContext.getparsedResponseType(),\n+                    authorizationRequestContext.getAuthorizationEndpointRequest(),\n+                    authorizationRequestContext.getRedirectUri());\n+                break;\n+            default:\n+                return;\n+        }\n+    }\n+\n+    public void executeOnAuthorizationRequest(", "originalCommit": "c2d7b4cc045d80e81ad42135c84f0bcf3f257546", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk1MTg3Mg==", "url": "https://github.com/keycloak/keycloak/pull/7419#discussion_r489951872", "bodyText": "@mposolda Yes, I'll change its visibility to \"private\".", "author": "tnorimat", "createdAt": "2020-09-17T04:04:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NzU4Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkzNzg5OA==", "url": "https://github.com/keycloak/keycloak/pull/7419#discussion_r491937898", "bodyText": "Thanks!", "author": "mposolda", "createdAt": "2020-09-21T10:25:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI0NzU4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI2MDA5NA==", "url": "https://github.com/keycloak/keycloak/pull/7419#discussion_r489260094", "bodyText": "Not sure about \"hardcoded\" enforcing of https this way? This should be perhaps driven by Realm SSLRequired check (even though it is primarily intended for the requests to Keycloak server) ? In general, the OAuth/OIDC recommends \"https\" almost everywhere, however IMO it will be nice if there is a way to relax on this requirement for development purposes if possible. Or is FAPI strictly enforcing \"https\" here?", "author": "mposolda", "createdAt": "2020-09-16T08:32:17Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/SecureRequestObjectExecutor.java", "diffHunk": "@@ -0,0 +1,508 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.common.util.StreamUtil;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.connections.httpclient.HttpClientProvider;\n+import org.keycloak.constants.AdapterConstants;\n+import org.keycloak.jose.jws.JWSInput;\n+import org.keycloak.jose.jws.JWSInputException;\n+import org.keycloak.models.Constants;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.JsonWebToken;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.clientpolicy.AuthorizationRequestContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyLogger;\n+import org.keycloak.util.JsonSerialization;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.JsonNode;\n+\n+public class SecureRequestObjectExecutor implements ClientPolicyExecutorProvider {\n+\n+    private static final Logger logger = Logger.getLogger(SecureRequestObjectExecutor.class);\n+\n+    private final KeycloakSession session;\n+    private final ComponentModel componentModel;\n+\n+    private AuthorizationEndpointRequestObject parsedRequestObject;\n+\n+    public static final String INVALID_REQUEST_OBJECT = \"invalid_request_object\";\n+\n+    public SecureRequestObjectExecutor(KeycloakSession session, ComponentModel componentModel) {\n+        this.session = session;\n+        this.componentModel = componentModel;\n+    }\n+\n+    @Override\n+    public void executeOnEvent(ClientPolicyContext context) throws ClientPolicyException {\n+        switch (context.getEvent()) {\n+            case AUTHORIZATION_REQUEST:\n+                AuthorizationRequestContext authorizationRequestContext = (AuthorizationRequestContext)context;\n+                executeOnAuthorizationRequest(authorizationRequestContext.getparsedResponseType(),\n+                    authorizationRequestContext.getAuthorizationEndpointRequest(),\n+                    authorizationRequestContext.getRedirectUri());\n+                break;\n+            default:\n+                return;\n+        }\n+    }\n+\n+    public void executeOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Authz Endpoint - authz request\");\n+\n+        // Only support GET\n+        MultivaluedMap<String, String> params = session.getContext().getUri().getQueryParameters();\n+        String requestParam = params.getFirst(OIDCLoginProtocol.REQUEST_PARAM);\n+        String requestUriParam = params.getFirst(OIDCLoginProtocol.REQUEST_URI_PARAM);\n+\n+        // check whether whether request object exists\n+        if (requestParam == null && requestUriParam == null) {\n+            ClientPolicyLogger.log(logger, \"request object not exist.\");\n+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, \"Invalid parameter\");\n+        }\n+\n+        // check whether request_uri is https scheme\n+        if (requestUriParam != null && !requestUriParam.startsWith(\"https://\")) {", "originalCommit": "c2d7b4cc045d80e81ad42135c84f0bcf3f257546", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk1NjQ5Mg==", "url": "https://github.com/keycloak/keycloak/pull/7419#discussion_r489956492", "bodyText": "@mposolda I see, I'll remove this hardcorded https check. The existing AuthorizationEndpoint check and return error before executing client policy.", "author": "tnorimat", "createdAt": "2020-09-17T04:12:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI2MDA5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTkzODAyMw==", "url": "https://github.com/keycloak/keycloak/pull/7419#discussion_r491938023", "bodyText": "@tnorimat Thanks", "author": "mposolda", "createdAt": "2020-09-21T10:25:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI2MDA5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI2NzE4NQ==", "url": "https://github.com/keycloak/keycloak/pull/7419#discussion_r489267185", "bodyText": "Is it possible to re-use AuthzEndpointRequestParser.KNOWN_REQ_PARAMS to avoid duplicities through the codebase?", "author": "mposolda", "createdAt": "2020-09-16T08:42:25Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/SecureRequestObjectExecutor.java", "diffHunk": "@@ -0,0 +1,508 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.common.util.StreamUtil;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.connections.httpclient.HttpClientProvider;\n+import org.keycloak.constants.AdapterConstants;\n+import org.keycloak.jose.jws.JWSInput;\n+import org.keycloak.jose.jws.JWSInputException;\n+import org.keycloak.models.Constants;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.JsonWebToken;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.clientpolicy.AuthorizationRequestContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyLogger;\n+import org.keycloak.util.JsonSerialization;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.JsonNode;\n+\n+public class SecureRequestObjectExecutor implements ClientPolicyExecutorProvider {\n+\n+    private static final Logger logger = Logger.getLogger(SecureRequestObjectExecutor.class);\n+\n+    private final KeycloakSession session;\n+    private final ComponentModel componentModel;\n+\n+    private AuthorizationEndpointRequestObject parsedRequestObject;\n+\n+    public static final String INVALID_REQUEST_OBJECT = \"invalid_request_object\";\n+\n+    public SecureRequestObjectExecutor(KeycloakSession session, ComponentModel componentModel) {\n+        this.session = session;\n+        this.componentModel = componentModel;\n+    }\n+\n+    @Override\n+    public void executeOnEvent(ClientPolicyContext context) throws ClientPolicyException {\n+        switch (context.getEvent()) {\n+            case AUTHORIZATION_REQUEST:\n+                AuthorizationRequestContext authorizationRequestContext = (AuthorizationRequestContext)context;\n+                executeOnAuthorizationRequest(authorizationRequestContext.getparsedResponseType(),\n+                    authorizationRequestContext.getAuthorizationEndpointRequest(),\n+                    authorizationRequestContext.getRedirectUri());\n+                break;\n+            default:\n+                return;\n+        }\n+    }\n+\n+    public void executeOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Authz Endpoint - authz request\");\n+\n+        // Only support GET\n+        MultivaluedMap<String, String> params = session.getContext().getUri().getQueryParameters();\n+        String requestParam = params.getFirst(OIDCLoginProtocol.REQUEST_PARAM);\n+        String requestUriParam = params.getFirst(OIDCLoginProtocol.REQUEST_URI_PARAM);\n+\n+        // check whether whether request object exists\n+        if (requestParam == null && requestUriParam == null) {\n+            ClientPolicyLogger.log(logger, \"request object not exist.\");\n+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, \"Invalid parameter\");\n+        }\n+\n+        // check whether request_uri is https scheme\n+        if (requestUriParam != null && !requestUriParam.startsWith(\"https://\")) {\n+            ClientPolicyLogger.log(logger, \"request_uri scheme is not https.\");\n+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, \"Invalid parameter: request_uri\");\n+        }\n+\n+        // check whether request object can be retrieved from request_uri\n+        String retrievedRequestObject = null;\n+        if (requestParam != null) {\n+            retrievedRequestObject = requestParam;\n+        } else {\n+            try (InputStream is = session.getProvider(HttpClientProvider.class).get(requestUriParam)) {\n+                retrievedRequestObject = StreamUtil.readString(is);\n+            } catch (IOException e) {\n+                ClientPolicyLogger.log(logger, \"failed to retrieve request object from request_uri.\");\n+                throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, \"Invalid parameter: request_uri\");\n+            }\n+        }\n+\n+        // check whether request object can be parsed successfully\n+        JWSInput input;\n+        try {\n+            input = new JWSInput(retrievedRequestObject);\n+            parsedRequestObject = JsonSerialization.readValue(input.getContent(), AuthorizationEndpointRequestObject.class);\n+        } catch (JWSInputException | IOException e) {\n+            ClientPolicyLogger.log(logger, \"failed to parse request object.\");\n+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, \"Invalid request object\");\n+        }\n+\n+        if (logger.isTraceEnabled()) {\n+            DumpQueryParameters();\n+            DumpRequestObject();\n+        }\n+\n+        // check whether scope exists in both query parameter and request object\n+        if (params.getFirst(OIDCLoginProtocol.SCOPE_PARAM) == null || parsedRequestObject.getScope() == null) {\n+            ClientPolicyLogger.log(logger, \"scope does not exists.\");\n+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, \"Missing parameter : scope\");\n+        }\n+\n+        // check whether \"exp\" claim exists\n+        if (parsedRequestObject.getExp() == null) {\n+            ClientPolicyLogger.log(logger, \"exp claim not incuded.\");\n+            throw new ClientPolicyException(INVALID_REQUEST_OBJECT, \"Missing parameter : exp\");\n+        }\n+\n+        // check whether request object not expired\n+        long exp = parsedRequestObject.getExp().longValue();\n+        if (Time.currentTime() > exp) { // TODO: Time.currentTime() is int while exp is long...\n+            ClientPolicyLogger.log(logger, \"request object expired.\");\n+            throw new ClientPolicyException(INVALID_REQUEST_OBJECT, \"Request Expired\");\n+        }\n+\n+        // check whether \"aud\" claim exists\n+        String[] aud = parsedRequestObject.getAudience();\n+        if (aud == null) {\n+            ClientPolicyLogger.log(logger, \"aud claim not incuded.\");\n+            throw new ClientPolicyException(INVALID_REQUEST_OBJECT, \"Missing parameter : aud\");\n+        }\n+\n+        // check whether \"aud\" claim points to this keycloak as authz server\n+        String iss = Urls.realmIssuer(session.getContext().getUri().getBaseUri(), session.getContext().getRealm().getName());\n+        if (!Arrays.asList(aud).contains(iss)) {\n+            ClientPolicyLogger.log(logger, \"aud not points to the intended realm.\");\n+            throw new ClientPolicyException(INVALID_REQUEST_OBJECT, \"Invalid parameter : aud\");\n+        }\n+\n+        // confirm whether all parameters in query string are included in the request object, and have the same values\n+        // argument \"request\" are parameters overridden by parameters in request object\n+        if (KNOWN_REQ_PARAMS.stream().filter(s->params.containsKey(s)).anyMatch(s->!isSameParameterIncluded(s, params.getFirst(s), parsedRequestObject))) {\n+            ClientPolicyLogger.log(logger, \"not all parameters in query string are included in the request object, and have the same values.\");\n+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, \"Invalid parameter\");\n+        }\n+\n+        ClientPolicyLogger.log(logger, \"Passed.\");\n+    }\n+\n+    private static final Set<String> KNOWN_REQ_PARAMS = new HashSet<>();", "originalCommit": "c2d7b4cc045d80e81ad42135c84f0bcf3f257546", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTk2MjAwNw==", "url": "https://github.com/keycloak/keycloak/pull/7419#discussion_r489962007", "bodyText": "@mposolda Yes, I'll change the visibility of AuthzEndpointRequestParser and use AuthzEndpointRequestParser.KNOWN_REQ_PARAMS directly.", "author": "tnorimat", "createdAt": "2020-09-17T04:23:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTI2NzE4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM2MDUwNQ==", "url": "https://github.com/keycloak/keycloak/pull/7419#discussion_r489360505", "bodyText": "Is this the FAPI requirement that just GET methods are supported? The OIDC supports the POST requests to OIDC Authorization endpoint as well.", "author": "mposolda", "createdAt": "2020-09-16T11:21:26Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/SecureRequestObjectExecutor.java", "diffHunk": "@@ -0,0 +1,508 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.common.util.StreamUtil;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.connections.httpclient.HttpClientProvider;\n+import org.keycloak.constants.AdapterConstants;\n+import org.keycloak.jose.jws.JWSInput;\n+import org.keycloak.jose.jws.JWSInputException;\n+import org.keycloak.models.Constants;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.JsonWebToken;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.clientpolicy.AuthorizationRequestContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyLogger;\n+import org.keycloak.util.JsonSerialization;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.JsonNode;\n+\n+public class SecureRequestObjectExecutor implements ClientPolicyExecutorProvider {\n+\n+    private static final Logger logger = Logger.getLogger(SecureRequestObjectExecutor.class);\n+\n+    private final KeycloakSession session;\n+    private final ComponentModel componentModel;\n+\n+    private AuthorizationEndpointRequestObject parsedRequestObject;\n+\n+    public static final String INVALID_REQUEST_OBJECT = \"invalid_request_object\";\n+\n+    public SecureRequestObjectExecutor(KeycloakSession session, ComponentModel componentModel) {\n+        this.session = session;\n+        this.componentModel = componentModel;\n+    }\n+\n+    @Override\n+    public void executeOnEvent(ClientPolicyContext context) throws ClientPolicyException {\n+        switch (context.getEvent()) {\n+            case AUTHORIZATION_REQUEST:\n+                AuthorizationRequestContext authorizationRequestContext = (AuthorizationRequestContext)context;\n+                executeOnAuthorizationRequest(authorizationRequestContext.getparsedResponseType(),\n+                    authorizationRequestContext.getAuthorizationEndpointRequest(),\n+                    authorizationRequestContext.getRedirectUri());\n+                break;\n+            default:\n+                return;\n+        }\n+    }\n+\n+    public void executeOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Authz Endpoint - authz request\");\n+\n+        // Only support GET\n+        MultivaluedMap<String, String> params = session.getContext().getUri().getQueryParameters();", "originalCommit": "c2d7b4cc045d80e81ad42135c84f0bcf3f257546", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA0NDg0OQ==", "url": "https://github.com/keycloak/keycloak/pull/7419#discussion_r490044849", "bodyText": "@mposolda I see, I'll revise code to treat POST method.", "author": "tnorimat", "createdAt": "2020-09-17T07:56:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTM2MDUwNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxMDY4Mw==", "url": "https://github.com/keycloak/keycloak/pull/7419#discussion_r489410683", "bodyText": "If we move most of the claims to the \"otherClaims\" and not explicitly contain them as properties of the AuthorizationEndpointRequestObject  (See my comment above), then this algorithm can be perhaps easier without explicitly naming every property. Just dumping the \"otherClaims\" map will do the thing.", "author": "mposolda", "createdAt": "2020-09-16T12:50:20Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/SecureRequestObjectExecutor.java", "diffHunk": "@@ -0,0 +1,508 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.common.util.StreamUtil;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.connections.httpclient.HttpClientProvider;\n+import org.keycloak.constants.AdapterConstants;\n+import org.keycloak.jose.jws.JWSInput;\n+import org.keycloak.jose.jws.JWSInputException;\n+import org.keycloak.models.Constants;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.JsonWebToken;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.clientpolicy.AuthorizationRequestContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyLogger;\n+import org.keycloak.util.JsonSerialization;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.JsonNode;\n+\n+public class SecureRequestObjectExecutor implements ClientPolicyExecutorProvider {\n+\n+    private static final Logger logger = Logger.getLogger(SecureRequestObjectExecutor.class);\n+\n+    private final KeycloakSession session;\n+    private final ComponentModel componentModel;\n+\n+    private AuthorizationEndpointRequestObject parsedRequestObject;\n+\n+    public static final String INVALID_REQUEST_OBJECT = \"invalid_request_object\";\n+\n+    public SecureRequestObjectExecutor(KeycloakSession session, ComponentModel componentModel) {\n+        this.session = session;\n+        this.componentModel = componentModel;\n+    }\n+\n+    @Override\n+    public void executeOnEvent(ClientPolicyContext context) throws ClientPolicyException {\n+        switch (context.getEvent()) {\n+            case AUTHORIZATION_REQUEST:\n+                AuthorizationRequestContext authorizationRequestContext = (AuthorizationRequestContext)context;\n+                executeOnAuthorizationRequest(authorizationRequestContext.getparsedResponseType(),\n+                    authorizationRequestContext.getAuthorizationEndpointRequest(),\n+                    authorizationRequestContext.getRedirectUri());\n+                break;\n+            default:\n+                return;\n+        }\n+    }\n+\n+    public void executeOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Authz Endpoint - authz request\");\n+\n+        // Only support GET\n+        MultivaluedMap<String, String> params = session.getContext().getUri().getQueryParameters();\n+        String requestParam = params.getFirst(OIDCLoginProtocol.REQUEST_PARAM);\n+        String requestUriParam = params.getFirst(OIDCLoginProtocol.REQUEST_URI_PARAM);\n+\n+        // check whether whether request object exists\n+        if (requestParam == null && requestUriParam == null) {\n+            ClientPolicyLogger.log(logger, \"request object not exist.\");\n+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, \"Invalid parameter\");\n+        }\n+\n+        // check whether request_uri is https scheme\n+        if (requestUriParam != null && !requestUriParam.startsWith(\"https://\")) {\n+            ClientPolicyLogger.log(logger, \"request_uri scheme is not https.\");\n+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, \"Invalid parameter: request_uri\");\n+        }\n+\n+        // check whether request object can be retrieved from request_uri\n+        String retrievedRequestObject = null;\n+        if (requestParam != null) {\n+            retrievedRequestObject = requestParam;\n+        } else {\n+            try (InputStream is = session.getProvider(HttpClientProvider.class).get(requestUriParam)) {\n+                retrievedRequestObject = StreamUtil.readString(is);\n+            } catch (IOException e) {\n+                ClientPolicyLogger.log(logger, \"failed to retrieve request object from request_uri.\");\n+                throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, \"Invalid parameter: request_uri\");\n+            }\n+        }\n+\n+        // check whether request object can be parsed successfully\n+        JWSInput input;\n+        try {\n+            input = new JWSInput(retrievedRequestObject);\n+            parsedRequestObject = JsonSerialization.readValue(input.getContent(), AuthorizationEndpointRequestObject.class);\n+        } catch (JWSInputException | IOException e) {\n+            ClientPolicyLogger.log(logger, \"failed to parse request object.\");\n+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, \"Invalid request object\");\n+        }\n+\n+        if (logger.isTraceEnabled()) {\n+            DumpQueryParameters();\n+            DumpRequestObject();\n+        }\n+\n+        // check whether scope exists in both query parameter and request object\n+        if (params.getFirst(OIDCLoginProtocol.SCOPE_PARAM) == null || parsedRequestObject.getScope() == null) {\n+            ClientPolicyLogger.log(logger, \"scope does not exists.\");\n+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, \"Missing parameter : scope\");\n+        }\n+\n+        // check whether \"exp\" claim exists\n+        if (parsedRequestObject.getExp() == null) {\n+            ClientPolicyLogger.log(logger, \"exp claim not incuded.\");\n+            throw new ClientPolicyException(INVALID_REQUEST_OBJECT, \"Missing parameter : exp\");\n+        }\n+\n+        // check whether request object not expired\n+        long exp = parsedRequestObject.getExp().longValue();\n+        if (Time.currentTime() > exp) { // TODO: Time.currentTime() is int while exp is long...\n+            ClientPolicyLogger.log(logger, \"request object expired.\");\n+            throw new ClientPolicyException(INVALID_REQUEST_OBJECT, \"Request Expired\");\n+        }\n+\n+        // check whether \"aud\" claim exists\n+        String[] aud = parsedRequestObject.getAudience();\n+        if (aud == null) {\n+            ClientPolicyLogger.log(logger, \"aud claim not incuded.\");\n+            throw new ClientPolicyException(INVALID_REQUEST_OBJECT, \"Missing parameter : aud\");\n+        }\n+\n+        // check whether \"aud\" claim points to this keycloak as authz server\n+        String iss = Urls.realmIssuer(session.getContext().getUri().getBaseUri(), session.getContext().getRealm().getName());\n+        if (!Arrays.asList(aud).contains(iss)) {\n+            ClientPolicyLogger.log(logger, \"aud not points to the intended realm.\");\n+            throw new ClientPolicyException(INVALID_REQUEST_OBJECT, \"Invalid parameter : aud\");\n+        }\n+\n+        // confirm whether all parameters in query string are included in the request object, and have the same values\n+        // argument \"request\" are parameters overridden by parameters in request object\n+        if (KNOWN_REQ_PARAMS.stream().filter(s->params.containsKey(s)).anyMatch(s->!isSameParameterIncluded(s, params.getFirst(s), parsedRequestObject))) {\n+            ClientPolicyLogger.log(logger, \"not all parameters in query string are included in the request object, and have the same values.\");\n+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, \"Invalid parameter\");\n+        }\n+\n+        ClientPolicyLogger.log(logger, \"Passed.\");\n+    }\n+\n+    private static final Set<String> KNOWN_REQ_PARAMS = new HashSet<>();\n+    static {\n+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.CLIENT_ID_PARAM);\n+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.RESPONSE_TYPE_PARAM);\n+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.RESPONSE_MODE_PARAM);\n+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.REDIRECT_URI_PARAM);\n+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.STATE_PARAM);\n+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.SCOPE_PARAM);\n+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.LOGIN_HINT_PARAM);\n+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.PROMPT_PARAM);\n+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.NONCE_PARAM);\n+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.MAX_AGE_PARAM);\n+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.UI_LOCALES_PARAM);\n+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.REQUEST_PARAM);\n+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.REQUEST_URI_PARAM);\n+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.CLAIMS_PARAM);\n+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.ACR_PARAM);\n+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.CODE_CHALLENGE_PARAM);\n+        KNOWN_REQ_PARAMS.add(OIDCLoginProtocol.CODE_CHALLENGE_METHOD_PARAM);\n+        KNOWN_REQ_PARAMS.add(OAuth2Constants.DISPLAY);\n+    }\n+\n+    private boolean isSameParameterIncluded(String param, String value, AuthorizationEndpointRequestObject request) {\n+        if (OIDCLoginProtocol.CLIENT_ID_PARAM.equals(param)) {\n+            return request.getClientId() != null && request.getClientId().equals(value);\n+        } else if (OIDCLoginProtocol.RESPONSE_TYPE_PARAM.equals(param)) {\n+            return request.getResponseType() != null && request.getResponseType().equals(value);\n+        } else if (OIDCLoginProtocol.RESPONSE_MODE_PARAM.equals(param)) {\n+            return request.getResponseMode() != null && request.getResponseMode().equals(value);\n+        } else if (OIDCLoginProtocol.REDIRECT_URI_PARAM.equals(param)) {\n+            return request.getRedirectUriParam() != null && request.getRedirectUriParam().equals(value);\n+        } else if (OIDCLoginProtocol.STATE_PARAM.equals(param)) {\n+            return request.getState() != null && request.getState().equals(value);\n+        } else if (OIDCLoginProtocol.SCOPE_PARAM.equals(param)) {\n+            return request.getScope() != null && request.getScope().equals(value);\n+        } else if (OIDCLoginProtocol.LOGIN_HINT_PARAM.equals(param)) {\n+            return request.getLoginHint() != null && request.getLoginHint().equals(value);\n+        } else if (OIDCLoginProtocol.PROMPT_PARAM.equals(param)) {\n+            return request.getPrompt() != null && request.getPrompt().equals(value);\n+        } else if (OIDCLoginProtocol.NONCE_PARAM.equals(param)) {\n+            return request.getNonce() != null && request.getNonce().equals(value);\n+        } else if (OIDCLoginProtocol.MAX_AGE_PARAM.equals(param)) {\n+            return request.getMax_age() != null && request.getMax_age().toString().equals(value);\n+        } else if (OIDCLoginProtocol.UI_LOCALES_PARAM.equals(param)) {\n+            return request.getUiLocales() != null && request.getUiLocales().equals(value);\n+        } else if (OIDCLoginProtocol.CLAIMS_PARAM.equals(param)) { // TODO : need some canonicalization for comparing in its meaning, not simply compare in its representation\n+            return request.getClaims() != null && request.getClaims().toString().equals(value);\n+        } else if (OIDCLoginProtocol.ACR_PARAM.equals(param)) {\n+            return request.getAcr() != null && request.getAcr().equals(value);\n+        } else if (OIDCLoginProtocol.CODE_CHALLENGE_PARAM.equals(param)) {\n+            return request.getCodeChallenge() != null && request.getCodeChallenge().equals(value);\n+        } else if (OIDCLoginProtocol.CODE_CHALLENGE_METHOD_PARAM.equals(param)) {\n+            return request.getCodeChallengeMethod() != null && request.getCodeChallengeMethod().equals(value);\n+        }\n+        return true;\n+    }\n+\n+\tpublic static class AuthorizationEndpointRequestObject extends JsonWebToken {\n+\n+        @JsonProperty(OIDCLoginProtocol.CLIENT_ID_PARAM)\n+        String clientId;\n+\n+        @JsonProperty(OIDCLoginProtocol.RESPONSE_TYPE_PARAM)\n+        String responseType;\n+\n+        @JsonProperty(OIDCLoginProtocol.RESPONSE_MODE_PARAM)\n+        String responseMode;\n+\n+        @JsonProperty(OIDCLoginProtocol.REDIRECT_URI_PARAM)\n+        String redirectUriParam;\n+\n+        @JsonProperty(OIDCLoginProtocol.STATE_PARAM)\n+        String state;\n+\n+        @JsonProperty(OIDCLoginProtocol.SCOPE_PARAM)\n+        String scope;\n+\n+        @JsonProperty(OIDCLoginProtocol.LOGIN_HINT_PARAM)\n+        String loginHint;\n+\n+        @JsonProperty(OIDCLoginProtocol.PROMPT_PARAM)\n+        String prompt;\n+\n+        @JsonProperty(OIDCLoginProtocol.NONCE_PARAM)\n+        String nonce;\n+\n+        Integer max_age;\n+\n+        @JsonProperty(OIDCLoginProtocol.UI_LOCALES_PARAM)\n+        String uiLocales;\n+\n+        @JsonProperty(OIDCLoginProtocol.CLAIMS_PARAM)\n+        JsonNode claims;\n+\n+        @JsonProperty(OIDCLoginProtocol.ACR_PARAM)\n+        String acr;\n+\n+        @JsonProperty(OAuth2Constants.DISPLAY)\n+        String display;\n+\n+        @JsonProperty(OIDCLoginProtocol.CODE_CHALLENGE_PARAM)\n+        String codeChallenge;\n+\n+        @JsonProperty(OIDCLoginProtocol.CODE_CHALLENGE_METHOD_PARAM)\n+        String codeChallengeMethod;\n+\n+        @JsonProperty(AdapterConstants.KC_IDP_HINT)\n+        String idpHint;\n+\n+        @JsonProperty(Constants.KC_ACTION)\n+        String action;\n+\n+        public String getClientId() {\n+            return clientId;\n+        }\n+\n+        public void setClientId(String clientId) {\n+            this.clientId =  clientId;\n+        }\n+\n+        public String getResponseType() {\n+            return responseType;\n+        }\n+\n+        public void setResponseType(String responseType) {\n+            this.responseType = responseType;\n+        }\n+\n+        public String getResponseMode() {\n+            return responseMode;\n+        }\n+\n+        public void setResponseMode(String responseMode) {\n+            this.responseMode = responseMode;\n+        }\n+\n+        public String getRedirectUriParam() {\n+            return redirectUriParam;\n+        }\n+\n+        public void setRedirectUriParam(String redirectUriParam) {\n+            this.redirectUriParam = redirectUriParam;\n+        }\n+\n+        public String getState() {\n+            return state;\n+        }\n+\n+        public void setState(String state) {\n+            this.state = state;\n+        }\n+\n+        public String getScope() {\n+            return scope;\n+        }\n+\n+        public void setScope(String scope) {\n+            this.scope = scope;\n+        }\n+\n+        public String getLoginHint() {\n+            return loginHint;\n+        }\n+\n+        public void setLoginHint(String loginHint) {\n+            this.loginHint = loginHint;\n+        }\n+\n+        public String getPrompt() {\n+            return prompt;\n+        }\n+\n+        public void setPrompt(String prompt) {\n+            this.prompt = prompt;\n+        }\n+\n+        public String getNonce() {\n+            return nonce;\n+        }\n+\n+        public void getNonce(String nonce) {\n+            this.nonce = nonce;\n+        }\n+\n+        public Integer getMax_age() {\n+            return max_age;\n+        }\n+\n+        public void setMax_age(Integer max_age) {\n+            this.max_age = max_age;\n+        }\n+\n+        public String getUiLocales() {\n+            return uiLocales;\n+        }\n+\n+        public void setUiLocales(String uiLocales) {\n+            this.uiLocales = uiLocales;\n+        }\n+\n+        public JsonNode getClaims() {\n+            return claims;\n+        }\n+\n+        public void setClaims(JsonNode claims) {\n+            this.claims = claims;\n+        }\n+\n+        public String getAcr() {\n+            return acr;\n+        }\n+\n+        public void setAcr(String acr) {\n+            this.acr = acr;\n+        }\n+\n+        public String getCodeChallenge() {\n+            return codeChallenge;\n+        }\n+\n+        public void setCodeChallenge(String codeChallenge) {\n+            this.codeChallenge = codeChallenge;\n+        }\n+\n+        public String getCodeChallengeMethod() {\n+            return codeChallengeMethod;\n+        }\n+\n+        public void setCodeChallengeMethod(String codeChallengeMethod) {\n+            this.codeChallengeMethod = codeChallengeMethod;\n+        }\n+\n+        public String getDisplay() {\n+            return display;\n+        }\n+\n+        public void setDisplay(String display) {\n+            this.display = display;\n+        }\n+\n+        public String getIdpHint() {\n+            return idpHint;\n+        }\n+\n+        public void setIdpHint(String idpHint) {\n+            this.idpHint = idpHint;\n+        }\n+\n+        public String getAction() {\n+            return action;\n+        }\n+\n+        public void setAction(String action) {\n+            this.action = action;\n+        }\n+\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return componentModel.getName();\n+    }\n+\n+    @Override\n+    public String getProviderId() {\n+        return componentModel.getProviderId();\n+    }\n+\n+    private void DumpQueryParameters() {\n+        MultivaluedMap<String, String> params = session.getContext().getUri().getQueryParameters();\n+        params.keySet().forEach(s->ClientPolicyLogger.logv(logger, \"Query Parameter : {0} = {1}\", s, params.getFirst(s)));\n+    }\n+\n+    private void DumpRequestObject() {\n+        if (parsedRequestObject.getId() != null) ", "originalCommit": "c2d7b4cc045d80e81ad42135c84f0bcf3f257546", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDcwMDcwNA==", "url": "https://github.com/keycloak/keycloak/pull/7419#discussion_r490700704", "bodyText": "@mposolda Instead of using dedicated AuthorizationEndpointRequestObject, I'll use bearer JsonNode for parsedRequestObject.", "author": "tnorimat", "createdAt": "2020-09-18T04:51:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxMDY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxMDk5OA==", "url": "https://github.com/keycloak/keycloak/pull/7419#discussion_r489410998", "bodyText": "The algorithm here and in the \"isSameParameterIncluded\" is a bit uneffective IMO. It iterates through all the OIDC supported parameters and calls very big amount of \"if\" and \"equals\" inside \"isSameParameterIncluded\" . Also will require change in the code upon any new supported OIDC parameter and whole \"isSameParameterIncluded\" does not scale etc.\nMaybe it is possible to leverage the fact that OIDC query parameter names are the same as parameters inside \"request\" object. Instead of adding all the passed \"request\" parameters as properties of the AuthorizationEndpointRequestObject, it may be better to just keep lots of those properties as generic properties in the \"otherClaims\" map. Then the algorithm should be possibly made more effective like for example something like this:\nfor (Map.Entry<String, List<String>> param : params.entrySet()) {\n    if (KNOWN_REQ_PARAMS.contains(param.getKey()) {\n        String requestValue = parsedRequestObject.getOtherClaim().get(param.getKey());\n        if (requestValue == null || requestValue.equals(param.getValue() {\n            // Throw error here. It can contain the name of the failing parameter in the trace logging message, which is advantage IMO\n        }\n    }\n}", "author": "mposolda", "createdAt": "2020-09-16T12:50:49Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/SecureRequestObjectExecutor.java", "diffHunk": "@@ -0,0 +1,508 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.common.util.StreamUtil;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.connections.httpclient.HttpClientProvider;\n+import org.keycloak.constants.AdapterConstants;\n+import org.keycloak.jose.jws.JWSInput;\n+import org.keycloak.jose.jws.JWSInputException;\n+import org.keycloak.models.Constants;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.JsonWebToken;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.clientpolicy.AuthorizationRequestContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyLogger;\n+import org.keycloak.util.JsonSerialization;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.JsonNode;\n+\n+public class SecureRequestObjectExecutor implements ClientPolicyExecutorProvider {\n+\n+    private static final Logger logger = Logger.getLogger(SecureRequestObjectExecutor.class);\n+\n+    private final KeycloakSession session;\n+    private final ComponentModel componentModel;\n+\n+    private AuthorizationEndpointRequestObject parsedRequestObject;\n+\n+    public static final String INVALID_REQUEST_OBJECT = \"invalid_request_object\";\n+\n+    public SecureRequestObjectExecutor(KeycloakSession session, ComponentModel componentModel) {\n+        this.session = session;\n+        this.componentModel = componentModel;\n+    }\n+\n+    @Override\n+    public void executeOnEvent(ClientPolicyContext context) throws ClientPolicyException {\n+        switch (context.getEvent()) {\n+            case AUTHORIZATION_REQUEST:\n+                AuthorizationRequestContext authorizationRequestContext = (AuthorizationRequestContext)context;\n+                executeOnAuthorizationRequest(authorizationRequestContext.getparsedResponseType(),\n+                    authorizationRequestContext.getAuthorizationEndpointRequest(),\n+                    authorizationRequestContext.getRedirectUri());\n+                break;\n+            default:\n+                return;\n+        }\n+    }\n+\n+    public void executeOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Authz Endpoint - authz request\");\n+\n+        // Only support GET\n+        MultivaluedMap<String, String> params = session.getContext().getUri().getQueryParameters();\n+        String requestParam = params.getFirst(OIDCLoginProtocol.REQUEST_PARAM);\n+        String requestUriParam = params.getFirst(OIDCLoginProtocol.REQUEST_URI_PARAM);\n+\n+        // check whether whether request object exists\n+        if (requestParam == null && requestUriParam == null) {\n+            ClientPolicyLogger.log(logger, \"request object not exist.\");\n+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, \"Invalid parameter\");\n+        }\n+\n+        // check whether request_uri is https scheme\n+        if (requestUriParam != null && !requestUriParam.startsWith(\"https://\")) {\n+            ClientPolicyLogger.log(logger, \"request_uri scheme is not https.\");\n+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, \"Invalid parameter: request_uri\");\n+        }\n+\n+        // check whether request object can be retrieved from request_uri\n+        String retrievedRequestObject = null;\n+        if (requestParam != null) {\n+            retrievedRequestObject = requestParam;\n+        } else {\n+            try (InputStream is = session.getProvider(HttpClientProvider.class).get(requestUriParam)) {\n+                retrievedRequestObject = StreamUtil.readString(is);\n+            } catch (IOException e) {\n+                ClientPolicyLogger.log(logger, \"failed to retrieve request object from request_uri.\");\n+                throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, \"Invalid parameter: request_uri\");\n+            }\n+        }\n+\n+        // check whether request object can be parsed successfully\n+        JWSInput input;\n+        try {\n+            input = new JWSInput(retrievedRequestObject);\n+            parsedRequestObject = JsonSerialization.readValue(input.getContent(), AuthorizationEndpointRequestObject.class);\n+        } catch (JWSInputException | IOException e) {\n+            ClientPolicyLogger.log(logger, \"failed to parse request object.\");\n+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, \"Invalid request object\");\n+        }\n+\n+        if (logger.isTraceEnabled()) {\n+            DumpQueryParameters();\n+            DumpRequestObject();\n+        }\n+\n+        // check whether scope exists in both query parameter and request object\n+        if (params.getFirst(OIDCLoginProtocol.SCOPE_PARAM) == null || parsedRequestObject.getScope() == null) {\n+            ClientPolicyLogger.log(logger, \"scope does not exists.\");\n+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, \"Missing parameter : scope\");\n+        }\n+\n+        // check whether \"exp\" claim exists\n+        if (parsedRequestObject.getExp() == null) {\n+            ClientPolicyLogger.log(logger, \"exp claim not incuded.\");\n+            throw new ClientPolicyException(INVALID_REQUEST_OBJECT, \"Missing parameter : exp\");\n+        }\n+\n+        // check whether request object not expired\n+        long exp = parsedRequestObject.getExp().longValue();\n+        if (Time.currentTime() > exp) { // TODO: Time.currentTime() is int while exp is long...\n+            ClientPolicyLogger.log(logger, \"request object expired.\");\n+            throw new ClientPolicyException(INVALID_REQUEST_OBJECT, \"Request Expired\");\n+        }\n+\n+        // check whether \"aud\" claim exists\n+        String[] aud = parsedRequestObject.getAudience();\n+        if (aud == null) {\n+            ClientPolicyLogger.log(logger, \"aud claim not incuded.\");\n+            throw new ClientPolicyException(INVALID_REQUEST_OBJECT, \"Missing parameter : aud\");\n+        }\n+\n+        // check whether \"aud\" claim points to this keycloak as authz server\n+        String iss = Urls.realmIssuer(session.getContext().getUri().getBaseUri(), session.getContext().getRealm().getName());\n+        if (!Arrays.asList(aud).contains(iss)) {\n+            ClientPolicyLogger.log(logger, \"aud not points to the intended realm.\");\n+            throw new ClientPolicyException(INVALID_REQUEST_OBJECT, \"Invalid parameter : aud\");\n+        }\n+\n+        // confirm whether all parameters in query string are included in the request object, and have the same values\n+        // argument \"request\" are parameters overridden by parameters in request object\n+        if (KNOWN_REQ_PARAMS.stream().filter(s->params.containsKey(s)).anyMatch(s->!isSameParameterIncluded(s, params.getFirst(s), parsedRequestObject))) {", "originalCommit": "c2d7b4cc045d80e81ad42135c84f0bcf3f257546", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYxMzYxMw==", "url": "https://github.com/keycloak/keycloak/pull/7419#discussion_r490613613", "bodyText": "@mposolda Just mentioned above, Instead of using dedicated AuthorizationEndpointRequestObject, I'll use bearer JsonNode for parsedRequestObject, which can simplify isSameParameterIncluded as you pointed out.", "author": "tnorimat", "createdAt": "2020-09-17T23:19:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxMDk5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxNDM2MA==", "url": "https://github.com/keycloak/keycloak/pull/7419#discussion_r489414360", "bodyText": "This means that when \"request_uri\" is used, then there will be 2 HTTP requests needed to \"request_uri\" during single AuthorizationEndpoint request. Because it is also loaded and parsed in the AuthzEndpointRequestObjectParser.\nAlso even if \"request\" object is used (and not \"request_uri\"), the parsing of \"request\" object is duplicated currently etc.\nI hope it is possible to somehow share the loading/parsing of the \"request\" object with the AuthzEndpointRequestObjectParser? This would mean that it would need to be done only once per AuthorizationEndpoint request and also will avoid some code duplications. Maybe parsed \"request\" can be saved as attribute of KeycloakSession for example?", "author": "mposolda", "createdAt": "2020-09-16T12:55:59Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/SecureRequestObjectExecutor.java", "diffHunk": "@@ -0,0 +1,508 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.common.util.StreamUtil;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.connections.httpclient.HttpClientProvider;\n+import org.keycloak.constants.AdapterConstants;\n+import org.keycloak.jose.jws.JWSInput;\n+import org.keycloak.jose.jws.JWSInputException;\n+import org.keycloak.models.Constants;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.JsonWebToken;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.clientpolicy.AuthorizationRequestContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyLogger;\n+import org.keycloak.util.JsonSerialization;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.fasterxml.jackson.databind.JsonNode;\n+\n+public class SecureRequestObjectExecutor implements ClientPolicyExecutorProvider {\n+\n+    private static final Logger logger = Logger.getLogger(SecureRequestObjectExecutor.class);\n+\n+    private final KeycloakSession session;\n+    private final ComponentModel componentModel;\n+\n+    private AuthorizationEndpointRequestObject parsedRequestObject;\n+\n+    public static final String INVALID_REQUEST_OBJECT = \"invalid_request_object\";\n+\n+    public SecureRequestObjectExecutor(KeycloakSession session, ComponentModel componentModel) {\n+        this.session = session;\n+        this.componentModel = componentModel;\n+    }\n+\n+    @Override\n+    public void executeOnEvent(ClientPolicyContext context) throws ClientPolicyException {\n+        switch (context.getEvent()) {\n+            case AUTHORIZATION_REQUEST:\n+                AuthorizationRequestContext authorizationRequestContext = (AuthorizationRequestContext)context;\n+                executeOnAuthorizationRequest(authorizationRequestContext.getparsedResponseType(),\n+                    authorizationRequestContext.getAuthorizationEndpointRequest(),\n+                    authorizationRequestContext.getRedirectUri());\n+                break;\n+            default:\n+                return;\n+        }\n+    }\n+\n+    public void executeOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Authz Endpoint - authz request\");\n+\n+        // Only support GET\n+        MultivaluedMap<String, String> params = session.getContext().getUri().getQueryParameters();\n+        String requestParam = params.getFirst(OIDCLoginProtocol.REQUEST_PARAM);\n+        String requestUriParam = params.getFirst(OIDCLoginProtocol.REQUEST_URI_PARAM);\n+\n+        // check whether whether request object exists\n+        if (requestParam == null && requestUriParam == null) {\n+            ClientPolicyLogger.log(logger, \"request object not exist.\");\n+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, \"Invalid parameter\");\n+        }\n+\n+        // check whether request_uri is https scheme\n+        if (requestUriParam != null && !requestUriParam.startsWith(\"https://\")) {\n+            ClientPolicyLogger.log(logger, \"request_uri scheme is not https.\");\n+            throw new ClientPolicyException(OAuthErrorException.INVALID_REQUEST, \"Invalid parameter: request_uri\");\n+        }\n+\n+        // check whether request object can be retrieved from request_uri\n+        String retrievedRequestObject = null;\n+        if (requestParam != null) {\n+            retrievedRequestObject = requestParam;\n+        } else {\n+            try (InputStream is = session.getProvider(HttpClientProvider.class).get(requestUriParam)) {", "originalCommit": "c2d7b4cc045d80e81ad42135c84f0bcf3f257546", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDA0Nzg0NA==", "url": "https://github.com/keycloak/keycloak/pull/7419#discussion_r490047844", "bodyText": "@mposolda To avoid loading and parsing request object, how about the following ?\n\nAuthzEndpointRequestObjectParser do verification that currently SecureRequestObjectExecutor do and storing its result\nSecureRequestObjectExecutor check this stored result and throw an appropriate ClientPolicyException.", "author": "tnorimat", "createdAt": "2020-09-17T08:01:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxNDM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDExOTc3NQ==", "url": "https://github.com/keycloak/keycloak/pull/7419#discussion_r490119775", "bodyText": "Also, I'll investigate the way you suggested, namely parsed \"request\" being saved as attribute of KeycloakSession that is used for validation on SecureRequestObjectExecutor.", "author": "tnorimat", "createdAt": "2020-09-17T09:55:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxNDM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDUyNzE4Mw==", "url": "https://github.com/keycloak/keycloak/pull/7419#discussion_r490527183", "bodyText": "@tnorimat It seems to me that some basic verifications like those lines https://github.com/Hitachi/keycloak/blob/KEYCLOAK-14204/services/src/main/java/org/keycloak/services/clientpolicy/executor/SecureRequestObjectExecutor.java#L90-L105 can be still kept on SecureRequestObjectExecutor. However the downloading from \"request_uri\" and parsing \"request\" can be done on AuthzEndpointRequestObjectParser and then saved as attribute in the KeycloakSession. If there is some issue in downloading the \"request_uri\" or parsing the \"request\" object, then the exception will be thrown earlier in the AuthzEndpointRequestObjectParser (not in the SecureRequestObjectExecutor), which is fine IMO.", "author": "mposolda", "createdAt": "2020-09-17T19:59:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxNDM2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDYxNDEwMA==", "url": "https://github.com/keycloak/keycloak/pull/7419#discussion_r490614100", "bodyText": "@mposolda I see, I'll leave these lines you pointed out as they are. Only using the parsed result on AuthzEndpointRequestObjectParser .", "author": "tnorimat", "createdAt": "2020-09-17T23:20:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTQxNDM2MA=="}], "type": "inlineReview"}, {"oid": "09c87edf7d9affb5afa64195caa6c611985d3c83", "url": "https://github.com/keycloak/keycloak/commit/09c87edf7d9affb5afa64195caa6c611985d3c83", "message": "KEYCLOAK-14204 FAPI-RW Client Policy - Executor : Enforce Request Object satisfying high security level", "committedDate": "2020-09-18T04:49:35Z", "type": "forcePushed"}, {"oid": "2119b64032c47885ab77ebb80887821c6741b774", "url": "https://github.com/keycloak/keycloak/commit/2119b64032c47885ab77ebb80887821c6741b774", "message": "KEYCLOAK-14204 FAPI-RW Client Policy - Executor : Enforce Request Object satisfying high security level", "committedDate": "2020-09-20T05:53:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk0MjMyOQ==", "url": "https://github.com/keycloak/keycloak/pull/7419#discussion_r491942329", "bodyText": "I am not sure about introducing constant AUTHZ_REQUEST_PARAMS and the attribute in KeycloakSession for this. It seems to me that requestParameters can be quite useful thing in general for ClientExecutors, so maybe the requestPArameters can be added directly as a field to the AuthorizationRequestContext class? The AuthorizationRequestContext is created from AuthorizationEndpoint.process method, which has access to the request parameters, so it should work fine?\nOn the other hand, the \"request\" object itself (AUTHZ_REQUEST_OBJECT) is not be so widely used IMO, so I agree to keep it as an attribute in KeycloakSession as you did in this PR.", "author": "mposolda", "createdAt": "2020-09-21T10:34:18Z", "path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/request/AuthzEndpointRequestParser.java", "diffHunk": "@@ -46,8 +46,11 @@\n      */\n     public static final int ADDITIONAL_REQ_PARAMS_MAX_SIZE = 200;\n \n+    public static final String AUTHZ_REQUEST_PARAMS = \"RawRequesParameters\";", "originalCommit": "2119b64032c47885ab77ebb80887821c6741b774", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzIwNDU0OA==", "url": "https://github.com/keycloak/keycloak/pull/7419#discussion_r493204548", "bodyText": "@mposolda Yes, I agree with you. I'll add requestParameters to AuthorizationRequestContext while request object is kept on as an attribute.", "author": "tnorimat", "createdAt": "2020-09-23T05:23:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTk0MjMyOQ=="}], "type": "inlineReview"}, {"oid": "b0f041f7a075c78e0423f469ae105483b36acb36", "url": "https://github.com/keycloak/keycloak/commit/b0f041f7a075c78e0423f469ae105483b36acb36", "message": "KEYCLOAK-14204 FAPI-RW Client Policy - Executor : Enforce Request Object satisfying high security level", "committedDate": "2020-09-24T07:21:53Z", "type": "forcePushed"}, {"oid": "60b8ea4e10ecc7823a7c7b9c4a2bfaf7d348327e", "url": "https://github.com/keycloak/keycloak/commit/60b8ea4e10ecc7823a7c7b9c4a2bfaf7d348327e", "message": "KEYCLOAK-14204 FAPI-RW Client Policy - Executor : Enforce Request Object satisfying high security level", "committedDate": "2020-09-25T00:42:57Z", "type": "commit"}, {"oid": "60b8ea4e10ecc7823a7c7b9c4a2bfaf7d348327e", "url": "https://github.com/keycloak/keycloak/commit/60b8ea4e10ecc7823a7c7b9c4a2bfaf7d348327e", "message": "KEYCLOAK-14204 FAPI-RW Client Policy - Executor : Enforce Request Object satisfying high security level", "committedDate": "2020-09-25T00:42:57Z", "type": "forcePushed"}]}