{"pr_number": 6690, "pr_title": "KEYCLOAK-12469 KEYCLOAK-12185 Implement nice design to the screen wit\u2026", "pr_createdAt": "2020-01-22T14:27:15Z", "pr_url": "https://github.com/keycloak/keycloak/pull/6690", "timeline": [{"oid": "fa8c7e6d1ee1c1f0c399bdf97da64824cf19808f", "url": "https://github.com/keycloak/keycloak/commit/fa8c7e6d1ee1c1f0c399bdf97da64824cf19808f", "message": "KEYCLOAK-12469 KEYCLOAK-12185 Implement nice design to the screen with authentication mechanisms. Add methods to Authentication SPI to retrieve metadata for labels and CSS", "committedDate": "2020-01-23T14:13:28Z", "type": "forcePushed"}, {"oid": "6873ce26facdb3f28444d8360352a5624611d2b7", "url": "https://github.com/keycloak/keycloak/commit/6873ce26facdb3f28444d8360352a5624611d2b7", "message": "KEYCLOAK-12469 KEYCLOAK-12185 Add CredentialTypeMetadata. Implement the screen with authentication mechanisms and implement Account REST Credentials API by use the credential type metadata", "committedDate": "2020-01-27T21:14:47Z", "type": "forcePushed"}, {"oid": "c840db0925a2ee3ad4b1170c960f19210ca42557", "url": "https://github.com/keycloak/keycloak/commit/c840db0925a2ee3ad4b1170c960f19210ca42557", "message": "KEYCLOAK-12469 Incorporate feedback", "committedDate": "2020-01-28T21:09:31Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ2MTk2Nw==", "url": "https://github.com/keycloak/keycloak/pull/6690#discussion_r372461967", "bodyText": "A credential is marked as enabled even when corresponding authenticator is not actually used in any flow.\nSteps to reproduce:\n\nCreate a flow with WebAuthn authenticator.\nDon't bind this flow anywhere, i.e. leave Browser Flow bound to its default flow.\nExpected: WebAuthn credential type is NOT returned.\nActual: It is returned even though it's not actually used.", "author": "vmuzikar", "createdAt": "2020-01-29T15:44:00Z", "path": "services/src/main/java/org/keycloak/services/resources/account/AccountCredentialResource.java", "diffHunk": "@@ -113,104 +126,103 @@ public boolean isRemoveable() {\n             return removeable;\n         }\n \n-        public List<CredentialModel> getUserCredentials() {\n+        public List<CredentialRepresentation> getUserCredentials() {\n             return userCredentials;\n         }\n-        \n+\n+        @JsonIgnore\n+        public CredentialTypeMetadata getMetadata() {\n+            return metadata;\n+        }\n     }\n-    \n+\n+\n+    /**\n+     * Retrieve the list of credentials available to the current logged in user. It will return only credentials of enabled types,\n+     * which user can use to authenticate in some authentication flow.\n+     *\n+     * @param type Allows to filter just single credential type, which will be specified as this parameter. If null, it will return all credential types\n+     * @param userCredentials specifies if user credentials should be returned. Defaults to true.\n+     * @return\n+     */\n     @GET\n     @NoCache\n     @Produces(javax.ws.rs.core.MediaType.APPLICATION_JSON)\n-    public List<CredentialContainer> dummyCredentialTypes(){\n+    public List<CredentialContainer> credentialTypes(@QueryParam(TYPE) String type,\n+                                                     @QueryParam(USER_CREDENTIALS) Boolean userCredentials) {\n         auth.requireOneOf(AccountRoles.MANAGE_ACCOUNT, AccountRoles.VIEW_PROFILE);\n-        List<CredentialModel> models = session.userCredentialManager().getStoredCredentials(realm, user);\n-        \n-        List<CredentialModel> passwordUserCreds = new java.util.ArrayList<>();\n-        passwordUserCreds.add(models.get(0));\n-        \n-        List<CredentialModel> otpUserCreds = new java.util.ArrayList<>();\n-        if (models.size() > 1) otpUserCreds.add(models.get(1));\n-        if (models.size() > 2) otpUserCreds.add(models.get(2));\n-        \n-        List<CredentialModel> webauthnUserCreds = new java.util.ArrayList<>();\n-        CredentialModel webauthnCred = new CredentialModel();\n-        webauthnCred.setId(\"bogus-id\");\n-        webauthnCred.setUserLabel(\"yubikey key\");\n-        webauthnCred.setCreatedDate(1579122652382L);\n-        webauthnUserCreds.add(webauthnCred);\n-        \n-        List<CredentialModel> webauthnStrongUserCreds = new java.util.ArrayList<>();\n-        CredentialModel webauthnStrongCred = new CredentialModel();\n-        webauthnStrongCred.setId(\"bogus-id-for-webauthnStrong\");\n-        webauthnStrongCred.setUserLabel(\"My very strong key with required PIN\");\n-        webauthnStrongCred.setCreatedDate(1579122652382L);\n-        webauthnUserCreds.add(webauthnStrongCred);\n-        \n-        CredentialContainer password = new CredentialContainer(\n-                                        \"password\",\n-                                        \"password\",\n-                                        \"passwordHelptext\",\n-                                        true,\n-                                        null, // no create action\n-                                        \"UPDATE_PASSWORD\",\n-                                        false,\n-                                        passwordUserCreds\n-                                        );\n-        CredentialContainer otp = new CredentialContainer(\n-                                        \"two-factor\",\n-                                        \"otp\",\n-                                        \"otpHelptext\",\n-                                        true,\n-                                        \"CONFIGURE_TOTP\", \n-                                        null, // no update action\n-                                        true,\n-                                        otpUserCreds\n-                                        );\n-        CredentialContainer webAuthn = new CredentialContainer(\n-                                        \"two-factor\",\n-                                        \"webauthn\",\n-                                        \"webauthnHelptext\",\n-                                        true,\n-                                        \"CONFIGURE_WEBAUTHN\", \n-                                        null, // no update action\n-                                        true,\n-                                        webauthnUserCreds\n-                                        );\n-        CredentialContainer passwordless = new CredentialContainer(\n-                                        \"passwordless\",\n-                                        \"webauthn-passwordless\",\n-                                        \"webauthn-passwordlessHelptext\",\n-                                        true,\n-                                        \"CONFIGURE_WEBAUTHN_STRONG\", \n-                                        null, // no update action\n-                                        true,\n-                                        webauthnStrongUserCreds\n-                                        );\n-        \n-        List<CredentialContainer> dummyCreds = new java.util.ArrayList<>();\n-        dummyCreds.add(password);\n-        dummyCreds.add(otp);\n-        dummyCreds.add(webAuthn);\n-        dummyCreds.add(passwordless);\n-        \n-        return dummyCreds;\n+\n+        boolean filterUserCredentials = userCredentials != null && !userCredentials;\n+\n+        List<CredentialContainer> credentialTypes = new LinkedList<>();\n+        List<CredentialProvider> credentialProviders = UserCredentialStoreManager.getCredentialProviders(session, realm, CredentialProvider.class);\n+        Set<String> enabledCredentialTypes = getEnabledCredentialTypes(credentialProviders);\n+\n+        List<CredentialModel> models = filterUserCredentials ? null : session.userCredentialManager().getStoredCredentials(realm, user);\n+\n+        // Don't return secrets from REST endpoint\n+        if (models != null) {\n+            for (CredentialModel credential : models) {\n+                credential.setSecretData(null);\n+            }\n+        }\n+\n+        for (CredentialProvider credentialProvider : credentialProviders) {\n+            String credentialProviderType = credentialProvider.getType();\n+\n+            // Filter just by single type\n+            if (type != null && !type.equals(credentialProviderType)) {\n+                continue;\n+            }\n+\n+            boolean enabled = enabledCredentialTypes.contains(credentialProviderType);\n+\n+            // Filter disabled credential types\n+            if (!enabled) {\n+                continue;\n+            }\n+\n+            CredentialTypeMetadata metadata = credentialProvider.getCredentialTypeMetadata();\n+\n+            List<CredentialRepresentation> userCredentialModels = filterUserCredentials ? null : models.stream()\n+                    .filter(credentialModel -> credentialProvider.getType().equals(credentialModel.getType()))\n+                    .map(ModelToRepresentation::toRepresentation)\n+                    .collect(Collectors.toList());\n+\n+            CredentialContainer credType = new CredentialContainer(metadata, userCredentialModels);\n+            credentialTypes.add(credType);\n+        }\n+\n+        credentialTypes.sort(Comparator.comparing(CredentialContainer::getMetadata));\n+\n+        return credentialTypes;\n     }\n-//\n-//\n-//    @GET\n-//    @Path(\"registrators\")\n-//    @NoCache\n-//    @Produces(javax.ws.rs.core.MediaType.APPLICATION_JSON)\n-//    public List<String> getCredentialRegistrators(){\n-//        auth.requireOneOf(AccountRoles.MANAGE_ACCOUNT, AccountRoles.VIEW_PROFILE);\n-//\n-//        return session.getContext().getRealm().getRequiredActionProviders().stream()\n-//                .map(RequiredActionProviderModel::getProviderId)\n-//                .filter(providerId ->  session.getProvider(RequiredActionProvider.class, providerId) instanceof CredentialRegistrator)\n-//                .collect(Collectors.toList());\n-//    }\n-//\n+\n+    // Going through all authentication flows and their authentication executions to see if there is any authenticator of the corresponding\n+    // credential type.\n+    private Set<String> getEnabledCredentialTypes(List<CredentialProvider> credentialProviders) {", "originalCommit": "c840db0925a2ee3ad4b1170c960f19210ca42557", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjY0MTc5Nw==", "url": "https://github.com/keycloak/keycloak/pull/6690#discussion_r372641797", "bodyText": "This is true and I was also thinking about this. Problem is, that there can be various corner cases. For example:\n\nFlow with WebAuthn authenticator could be configured as \"First broker login\" flow\nFlow with WebAuthn authenticator could be configured as \"Authetnication flow binding override\" for any client (and some of our users has 10K clients in the realm).\n\nI suppose that when admin configured some flow with WebAuthn authenticator, he actually wants to use WebAuthn somewhere. So I've just used this algorithm as some compromise between accuracy and performance (EG avoid to loop through all the clients and their binding overrides etc). I hope it works as good compromise if we properly document it?", "author": "mposolda", "createdAt": "2020-01-29T21:33:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ2MTk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjc4OTg4OA==", "url": "https://github.com/keycloak/keycloak/pull/6690#discussion_r372789888", "bodyText": "@mposolda Thanks for the explanation. That's right and now makes a complete sense.", "author": "vmuzikar", "createdAt": "2020-01-30T07:18:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ2MTk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg0NTYwMQ==", "url": "https://github.com/keycloak/keycloak/pull/6690#discussion_r372845601", "bodyText": "Thinking about this a bit more I believe it might be a problem for OTP. Yes, for WebAuthn this approach works but what if admin doesn't want to enable OTP? Users will always see the OTP option in the account console because the OTP authenticator is always present in the built-in browser flow which can't be deleted. Or am I missing something?", "author": "vmuzikar", "createdAt": "2020-01-30T09:41:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ2MTk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg2MTg5Nw==", "url": "https://github.com/keycloak/keycloak/pull/6690#discussion_r372861897", "bodyText": "Yes. I think in case that OTP authenticator is disabled or it is used in the disabled subflow, it won't be used. That should work fine for built-in browser flow as well, but we need to document it. WDYT? I will need to update PR for this as it currently doesn't take \"disabled\" into account.\nIt will be ideal if there is some way for disable some credential types entirely in some simple way - maybe just switch in admin console or something like that, which will simply allow to enable/disable \"otp\" or \"webauthn\" credential etc. But that won't be for 9.0.0...", "author": "mposolda", "createdAt": "2020-01-30T10:13:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ2MTk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3Mjg3NTQ1MQ==", "url": "https://github.com/keycloak/keycloak/pull/6690#discussion_r372875451", "bodyText": "Yes. I think in case that OTP authenticator is disabled or it is used in the disabled subflow, it won't be used. That should work fine for built-in browser flow as well, but we need to document it. WDYT? I will need to update PR for this as it currently doesn't take \"disabled\" into account.\n\n+1\n\nIt will be ideal if there is some way for disable some credential types entirely in some simple way - maybe just switch in admin console or something like that, which will simply allow to enable/disable \"otp\" or \"webauthn\" credential etc. But that won't be for 9.0.0...\n\n+1000 :D\nHowever, we might want to wait with that for the new Admin Console where auth flows should be redesigned anyway.", "author": "vmuzikar", "createdAt": "2020-01-30T10:41:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ2MTk2Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE0MTY3MA==", "url": "https://github.com/keycloak/keycloak/pull/6690#discussion_r373141670", "bodyText": "I've updated the PR to behave like that and don't consider disabled authenticators. Added test that it is possible to disable OTP and not return it from account REST credential endpoint", "author": "mposolda", "createdAt": "2020-01-30T19:15:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MjQ2MTk2Nw=="}], "type": "inlineReview"}, {"oid": "a91964f5412929b9e8b1cc67f6b8867d4ec1d14f", "url": "https://github.com/keycloak/keycloak/commit/a91964f5412929b9e8b1cc67f6b8867d4ec1d14f", "message": "KEYCLOAK-12469 Adjust with latest master - Added WebAuthn Passwordless credential support", "committedDate": "2020-01-30T09:39:46Z", "type": "forcePushed"}, {"oid": "1b1db21bd71071052b2ad6f23f5207d3441a16f7", "url": "https://github.com/keycloak/keycloak/commit/1b1db21bd71071052b2ad6f23f5207d3441a16f7", "message": "KEYCLOAK-12469 KEYCLOAK-12185 Add CredentialTypeMetadata. Implement the screen with authentication mechanisms and implement Account REST Credentials API by use the credential type metadata", "committedDate": "2020-01-30T18:37:49Z", "type": "commit"}, {"oid": "ae85879f850a23c0eaa3635102cab09b0332e05c", "url": "https://github.com/keycloak/keycloak/commit/ae85879f850a23c0eaa3635102cab09b0332e05c", "message": "KEYCLOAK-12469 Incorporate feedback", "committedDate": "2020-01-30T18:37:49Z", "type": "commit"}, {"oid": "0087463ff8811e3bdded6518539756a4ce1c909c", "url": "https://github.com/keycloak/keycloak/commit/0087463ff8811e3bdded6518539756a4ce1c909c", "message": "KEYCLOAK-12469 Adjust with latest master - Added WebAuthn Passwordless credential support", "committedDate": "2020-01-30T18:37:49Z", "type": "commit"}, {"oid": "2d6df0f521257365a5262821b4f3829c483bc931", "url": "https://github.com/keycloak/keycloak/commit/2d6df0f521257365a5262821b4f3829c483bc931", "message": "KEYCLOAK-12469 Incorporate feedback - Dont consider disabled executions. Dont return disabled/unregistered actions. Update helpText for webauthn passwordless. Add javadoc", "committedDate": "2020-01-30T18:37:49Z", "type": "commit"}, {"oid": "2d6df0f521257365a5262821b4f3829c483bc931", "url": "https://github.com/keycloak/keycloak/commit/2d6df0f521257365a5262821b4f3829c483bc931", "message": "KEYCLOAK-12469 Incorporate feedback - Dont consider disabled executions. Dont return disabled/unregistered actions. Update helpText for webauthn passwordless. Add javadoc", "committedDate": "2020-01-30T18:37:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE4NDY4MQ==", "url": "https://github.com/keycloak/keycloak/pull/6690#discussion_r373184681", "bodyText": "Should this be providerID?  For instance, the create action for OTP is \"CONFIGURE_TOTP\".", "author": "ssilvert", "createdAt": "2020-01-30T20:46:29Z", "path": "server-spi/src/main/java/org/keycloak/credential/CredentialTypeMetadata.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.keycloak.credential;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.RequiredActionProviderModel;\n+\n+/**\n+ * @author <a href=\"mailto:mposolda@redhat.com\">Marek Posolda</a>\n+ */\n+public class CredentialTypeMetadata implements Comparable<CredentialTypeMetadata> {\n+\n+    private static final Logger logger = Logger.getLogger(CredentialTypeMetadata.class);\n+\n+    public static final String DEFAULT_ICON_CSS_CLASS = \"kcAuthenticatorDefaultClass\";\n+\n+    private String type;\n+\n+    private String displayName;\n+\n+    private String helpText;\n+\n+    private String iconCssClass = DEFAULT_ICON_CSS_CLASS;\n+\n+    private String createAction;\n+\n+    private String updateAction;\n+\n+    private Boolean removeable;\n+\n+    private Category category;\n+\n+\n+    public enum Category {\n+        PASSWORD(\"password\", 1),\n+        TWO_FACTOR(\"two-factor\", 2),\n+        PASSWORDLESS(\"passwordless\", 3);\n+\n+        private String categoryName;\n+        private int order;\n+\n+        Category(String categoryName, int order) {\n+            this.categoryName = categoryName;\n+            this.order = order;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return categoryName;\n+        }\n+\n+        public int compareWith(Category that) {\n+            return order - that.order;\n+        }\n+\n+    }\n+\n+\n+    private CredentialTypeMetadata() {\n+    }\n+\n+\n+    // GETTERS\n+\n+    /**\n+     * @return credential type like for example \"password\", \"otp\" or \"webauthn\"\n+     */\n+    public String getType() {\n+        return type;\n+    }\n+\n+   /**\n+     * @return the label, which will be shown to the end user on various screens, like login screen with available authentication mechanisms.\n+     * This label will reference this particular authenticator type.\n+     * It should be clear to end users. For example, implementations can return \"Authenticator Application\" for OTP or \"Security Key\" for WebAuthn.\n+     *\n+     * Alternatively, this method can return a message key, so that it is possible to localize it for various languages.\n+     */\n+    public String getDisplayName() {\n+        return displayName;\n+    }\n+\n+    /**\n+     * @return the text, which will be shown to the user on various screens, like login screen with available authentication mechanisms.\n+     * This text will reference this particular authenticator type.\n+     * For example for OTP, the returned text could be \"Enter a verification code from authenticator application\" .\n+     *\n+     * Alternatively, this method can return a message key, so that it is possible to localize it for various languages.\n+     */\n+    public String getHelpText() {\n+        return helpText;\n+    }\n+\n+    /**\n+     * Return the icon CSS, which can be used to display icon, which represents this particular authenticator.\n+     *\n+     * The icon will be displayed on various places. For example the \"Select authenticator\" screen during login, where user can select from\n+     * various authentication mechanisms for two-factor or passwordless authentication.\n+     *\n+     * The returned value can be either:\n+     * - Key of the property, which will reference the actual CSS in the themes.properties file. For example if you return \"kcAuthenticatorWebAuthnClass\"\n+     *   from this method, then your themes.properties should have the property like for example \"kcAuthenticatorWebAuthnClass=fa fa-key list-view-pf-icon-lg\" .\n+     *   This would mean that \"fa fa-key list-view-pf-icon-lg\" will be the actual CSS used.\n+     * - the icon CSS class directly. For example you can return \"fa fa-key list-view-pf-icon-lg\" directly for the above example with WebAuthn.\n+     *   This alternative is fine just if your authenticator can use same CSS class for all the themes.\n+     *\n+     * If you don't expect your authenticator to need icon (for example it will never be shown in the \"select authenticator\" screen), then\n+     * it is fine to keep the default value.\n+     */\n+    public String getIconCssClass() {\n+        return iconCssClass;\n+    }\n+\n+    /**\n+     * @return the providerID of the required action, which can be used by the user to create new credential of our type. Null if there is no", "originalCommit": "2d6df0f521257365a5262821b4f3829c483bc931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIzNDMxNQ==", "url": "https://github.com/keycloak/keycloak/pull/6690#discussion_r373234315", "bodyText": "Yes, \"CONFIGURE_TOTP\" is the providerID of the required action provider. When requiredAction/AIA is triggered, Keycloak uses the providerID like \"CONFIGURE_TOTP\" to lookup required action provider - in this case class UpdateTotp. In case of WebAuthn, the name of the action is \"webauthn-register\" , which is provider id of WebAuthnRegisterFactory.\nBy default, the alias and providerId of RequiredActionProviderModels attached to the realm is the same, but it may not be necessarily true. Keycloak uses providerId to lookup the requiredAction, not the alias or name of requiredAction.\nHowever if you have any better idea to this javadoc, we can discuss it.", "author": "mposolda", "createdAt": "2020-01-30T22:44:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE4NDY4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI2MTU0Mw==", "url": "https://github.com/keycloak/keycloak/pull/6690#discussion_r373261543", "bodyText": "This is fine.  I just didn't remember it being the providerId.  I was thinking the action name was separate.", "author": "ssilvert", "createdAt": "2020-01-31T00:16:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE4NDY4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE4NTA5OQ==", "url": "https://github.com/keycloak/keycloak/pull/6690#discussion_r373185099", "bodyText": "Same here.  Not really a providerID.  It's the action used to trigger the AIA.  In the case of password, it's \"UPDATE_PASSWORD\".", "author": "ssilvert", "createdAt": "2020-01-30T20:47:28Z", "path": "server-spi/src/main/java/org/keycloak/credential/CredentialTypeMetadata.java", "diffHunk": "@@ -0,0 +1,282 @@\n+/*\n+ * Copyright 2019 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ *\n+ */\n+\n+package org.keycloak.credential;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.RequiredActionProviderModel;\n+\n+/**\n+ * @author <a href=\"mailto:mposolda@redhat.com\">Marek Posolda</a>\n+ */\n+public class CredentialTypeMetadata implements Comparable<CredentialTypeMetadata> {\n+\n+    private static final Logger logger = Logger.getLogger(CredentialTypeMetadata.class);\n+\n+    public static final String DEFAULT_ICON_CSS_CLASS = \"kcAuthenticatorDefaultClass\";\n+\n+    private String type;\n+\n+    private String displayName;\n+\n+    private String helpText;\n+\n+    private String iconCssClass = DEFAULT_ICON_CSS_CLASS;\n+\n+    private String createAction;\n+\n+    private String updateAction;\n+\n+    private Boolean removeable;\n+\n+    private Category category;\n+\n+\n+    public enum Category {\n+        PASSWORD(\"password\", 1),\n+        TWO_FACTOR(\"two-factor\", 2),\n+        PASSWORDLESS(\"passwordless\", 3);\n+\n+        private String categoryName;\n+        private int order;\n+\n+        Category(String categoryName, int order) {\n+            this.categoryName = categoryName;\n+            this.order = order;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return categoryName;\n+        }\n+\n+        public int compareWith(Category that) {\n+            return order - that.order;\n+        }\n+\n+    }\n+\n+\n+    private CredentialTypeMetadata() {\n+    }\n+\n+\n+    // GETTERS\n+\n+    /**\n+     * @return credential type like for example \"password\", \"otp\" or \"webauthn\"\n+     */\n+    public String getType() {\n+        return type;\n+    }\n+\n+   /**\n+     * @return the label, which will be shown to the end user on various screens, like login screen with available authentication mechanisms.\n+     * This label will reference this particular authenticator type.\n+     * It should be clear to end users. For example, implementations can return \"Authenticator Application\" for OTP or \"Security Key\" for WebAuthn.\n+     *\n+     * Alternatively, this method can return a message key, so that it is possible to localize it for various languages.\n+     */\n+    public String getDisplayName() {\n+        return displayName;\n+    }\n+\n+    /**\n+     * @return the text, which will be shown to the user on various screens, like login screen with available authentication mechanisms.\n+     * This text will reference this particular authenticator type.\n+     * For example for OTP, the returned text could be \"Enter a verification code from authenticator application\" .\n+     *\n+     * Alternatively, this method can return a message key, so that it is possible to localize it for various languages.\n+     */\n+    public String getHelpText() {\n+        return helpText;\n+    }\n+\n+    /**\n+     * Return the icon CSS, which can be used to display icon, which represents this particular authenticator.\n+     *\n+     * The icon will be displayed on various places. For example the \"Select authenticator\" screen during login, where user can select from\n+     * various authentication mechanisms for two-factor or passwordless authentication.\n+     *\n+     * The returned value can be either:\n+     * - Key of the property, which will reference the actual CSS in the themes.properties file. For example if you return \"kcAuthenticatorWebAuthnClass\"\n+     *   from this method, then your themes.properties should have the property like for example \"kcAuthenticatorWebAuthnClass=fa fa-key list-view-pf-icon-lg\" .\n+     *   This would mean that \"fa fa-key list-view-pf-icon-lg\" will be the actual CSS used.\n+     * - the icon CSS class directly. For example you can return \"fa fa-key list-view-pf-icon-lg\" directly for the above example with WebAuthn.\n+     *   This alternative is fine just if your authenticator can use same CSS class for all the themes.\n+     *\n+     * If you don't expect your authenticator to need icon (for example it will never be shown in the \"select authenticator\" screen), then\n+     * it is fine to keep the default value.\n+     */\n+    public String getIconCssClass() {\n+        return iconCssClass;\n+    }\n+\n+    /**\n+     * @return the providerID of the required action, which can be used by the user to create new credential of our type. Null if there is no\n+     * action for creating credential. For example we're creating credential in case of \"otp\" type, but we're updating credential\n+     * in case of type \"password\"\n+     */\n+    public String getCreateAction() {\n+        return createAction;\n+    }\n+\n+    /**\n+     * @return the providerID of the required action, which can be used by the user to update credential of our type. Null if there is no", "originalCommit": "2d6df0f521257365a5262821b4f3829c483bc931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzIzNDc0Mg==", "url": "https://github.com/keycloak/keycloak/pull/6690#discussion_r373234742", "bodyText": "Yes, the \"UPDATE_PASSWORD\" is the providerId of requiredAction for update password - it's java class is UpdatePassword. Same case like for \"createAction\".\nHowever if you have any better idea to this javadoc, we can discuss it. Any suggestion?", "author": "mposolda", "createdAt": "2020-01-30T22:45:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE4NTA5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzI2MTY1Ng==", "url": "https://github.com/keycloak/keycloak/pull/6690#discussion_r373261656", "bodyText": "NP", "author": "ssilvert", "createdAt": "2020-01-31T00:16:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzE4NTA5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQwNzg5Mw==", "url": "https://github.com/keycloak/keycloak/pull/6690#discussion_r373407893", "bodyText": "Just a small nitpick. Should we revert the first broker flow too, or is it intentional that we don't do that?", "author": "vmuzikar", "createdAt": "2020-01-31T10:20:23Z", "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/account/AccountRestServiceTest.java", "diffHunk": "@@ -277,6 +300,198 @@ private void updatePassword(String currentPass, String newPass, String confirmat\n         assertEquals(expectedStatus, status);\n     }\n \n+    @Test\n+    public void testCredentialsGet() throws IOException {\n+        configureBrowserFlowWithWebAuthnAuthenticator(\"browser-webauthn\");\n+\n+        List<AccountCredentialResource.CredentialContainer> credentials = getCredentials();\n+\n+        Assert.assertEquals(4, credentials.size());\n+\n+        AccountCredentialResource.CredentialContainer password = credentials.get(0);\n+        assertCredentialContainerExpected(password, PasswordCredentialModel.TYPE, CredentialTypeMetadata.Category.PASSWORD.toString(),\n+                \"password\", \"password-help-text\", \"kcAuthenticatorPasswordClass\",\n+                null, UserModel.RequiredAction.UPDATE_PASSWORD.toString(), false, 1);\n+\n+        CredentialRepresentation password1 = password.getUserCredentials().get(0);\n+        Assert.assertNull(password1.getSecretData());\n+        Assert.assertNotNull(password1.getCredentialData());\n+\n+        AccountCredentialResource.CredentialContainer otp = credentials.get(1);\n+        assertCredentialContainerExpected(otp, OTPCredentialModel.TYPE, CredentialTypeMetadata.Category.TWO_FACTOR.toString(),\n+                \"otp-display-name\", \"otp-help-text\", \"kcAuthenticatorOTPClass\",\n+                UserModel.RequiredAction.CONFIGURE_TOTP.toString(), null, true, 0);\n+\n+        // WebAuthn credentials will be returned, but createAction will be still null because requiredAction \"webauthn register\" not yet registered\n+        AccountCredentialResource.CredentialContainer webauthn = credentials.get(2);\n+        assertCredentialContainerExpected(webauthn, WebAuthnCredentialModel.TYPE_TWOFACTOR, CredentialTypeMetadata.Category.TWO_FACTOR.toString(),\n+                \"webauthn-display-name\", \"webauthn-help-text\", \"kcAuthenticatorWebAuthnClass\",\n+                null, null, true, 0);\n+\n+        AccountCredentialResource.CredentialContainer webauthnPasswordless = credentials.get(3);\n+        assertCredentialContainerExpected(webauthnPasswordless, WebAuthnCredentialModel.TYPE_PASSWORDLESS, CredentialTypeMetadata.Category.PASSWORDLESS.toString(),\n+                \"webauthn-passwordless-display-name\", \"webauthn-passwordless-help-text\", \"kcAuthenticatorWebAuthnPasswordlessClass\",\n+                null, null, true, 0);\n+\n+        // Register requiredActions for WebAuthn\n+        RequiredActionProviderSimpleRepresentation requiredAction = new RequiredActionProviderSimpleRepresentation();\n+        requiredAction.setId(\"12345\");\n+        requiredAction.setName(WebAuthnRegisterFactory.PROVIDER_ID);\n+        requiredAction.setProviderId(WebAuthnRegisterFactory.PROVIDER_ID);\n+        testRealm().flows().registerRequiredAction(requiredAction);\n+\n+        requiredAction = new RequiredActionProviderSimpleRepresentation();\n+        requiredAction.setId(\"6789\");\n+        requiredAction.setName(WebAuthnPasswordlessRegisterFactory.PROVIDER_ID);\n+        requiredAction.setProviderId(WebAuthnPasswordlessRegisterFactory.PROVIDER_ID);\n+        testRealm().flows().registerRequiredAction(requiredAction);\n+\n+        // requiredActions should be available\n+        credentials = getCredentials();\n+        Assert.assertEquals(WebAuthnRegisterFactory.PROVIDER_ID, credentials.get(2).getCreateAction());\n+        Assert.assertEquals(WebAuthnPasswordlessRegisterFactory.PROVIDER_ID, credentials.get(3).getCreateAction());\n+\n+        // disable WebAuthn passwordless required action. It won't be returned then\n+        RequiredActionProviderRepresentation requiredActionRep = testRealm().flows().getRequiredAction(WebAuthnPasswordlessRegisterFactory.PROVIDER_ID);\n+        requiredActionRep.setEnabled(false);\n+        testRealm().flows().updateRequiredAction(WebAuthnRegisterFactory.PROVIDER_ID, requiredActionRep);\n+\n+        credentials = getCredentials();\n+        Assert.assertNull(credentials.get(2).getCreateAction());\n+\n+        // Test that WebAuthn won't be returned when removed from the authentication flow\n+        removeWebAuthnFlow(\"browser-webauthn\");\n+\n+        credentials = getCredentials();\n+\n+        Assert.assertEquals(2, credentials.size());\n+        Assert.assertEquals(PasswordCredentialModel.TYPE, credentials.get(0).getType());\n+        Assert.assertNotNull(OTPCredentialModel.TYPE, credentials.get(1).getType());\n+\n+        // Test password-only\n+        credentials = SimpleHttp.doGet(getAccountUrl(\"credentials?\" + AccountCredentialResource.TYPE + \"=password\"), httpClient)\n+                .auth(tokenUtil.getToken()).asJson(new TypeReference<List<AccountCredentialResource.CredentialContainer>>() {});\n+        Assert.assertEquals(1, credentials.size());\n+        password = credentials.get(0);\n+        Assert.assertEquals(PasswordCredentialModel.TYPE, password.getType());\n+        Assert.assertEquals(1, password.getUserCredentials().size());\n+\n+        // Test password-only and user-credentials\n+        credentials = SimpleHttp.doGet(getAccountUrl(\"credentials?\" + AccountCredentialResource.TYPE + \"=password&\" +\n+                AccountCredentialResource.USER_CREDENTIALS + \"=false\"), httpClient)\n+                .auth(tokenUtil.getToken()).asJson(new TypeReference<List<AccountCredentialResource.CredentialContainer>>() {});\n+        Assert.assertEquals(1, credentials.size());\n+        password = credentials.get(0);\n+        Assert.assertEquals(PasswordCredentialModel.TYPE, password.getType());\n+        Assert.assertNull(password.getUserCredentials());\n+    }\n+\n+    // Send REST request to get all credential containers and credentials of current user\n+    private List<AccountCredentialResource.CredentialContainer> getCredentials() throws IOException {\n+        return SimpleHttp.doGet(getAccountUrl(\"credentials\"), httpClient)\n+                .auth(tokenUtil.getToken()).asJson(new TypeReference<List<AccountCredentialResource.CredentialContainer>>() {});\n+    }\n+\n+    @Test\n+    public void testCredentialsGetDisabledOtp() throws IOException {\n+        // Disable OTP in all built-in flows\n+\n+        // Disable parent subflow - that should treat OTP execution as disabled too\n+        AuthenticationExecutionModel.Requirement currentBrowserReq = setExecutionRequirement(DefaultAuthenticationFlows.BROWSER_FLOW,\n+                \"Browser - Conditional OTP\", AuthenticationExecutionModel.Requirement.DISABLED);\n+\n+        // Disable OTP directly in first-broker-login and direct-grant\n+        AuthenticationExecutionModel.Requirement currentFBLReq = setExecutionRequirement(DefaultAuthenticationFlows.FIRST_BROKER_LOGIN_FLOW,\n+                \"OTP Form\", AuthenticationExecutionModel.Requirement.DISABLED);\n+        AuthenticationExecutionModel.Requirement currentDirectGrantReq = setExecutionRequirement(DefaultAuthenticationFlows.DIRECT_GRANT_FLOW,\n+                \"Direct Grant - Conditional OTP\", AuthenticationExecutionModel.Requirement.DISABLED);\n+        try {\n+            // Test that OTP credential is not included. Only password\n+            List<AccountCredentialResource.CredentialContainer> credentials = getCredentials();\n+\n+            Assert.assertEquals(1, credentials.size());\n+            Assert.assertEquals(PasswordCredentialModel.TYPE, credentials.get(0).getType());\n+\n+            // Enable browser subflow. OTP should be available then\n+            setExecutionRequirement(DefaultAuthenticationFlows.BROWSER_FLOW,\n+                    \"Browser - Conditional OTP\", currentBrowserReq);\n+            credentials = getCredentials();\n+            Assert.assertEquals(2, credentials.size());\n+            Assert.assertEquals(OTPCredentialModel.TYPE, credentials.get(1).getType());\n+\n+            // Disable browser subflow and enable FirstBrokerLogin. OTP should be available then\n+            setExecutionRequirement(DefaultAuthenticationFlows.BROWSER_FLOW,\n+                    \"Browser - Conditional OTP\", AuthenticationExecutionModel.Requirement.DISABLED);\n+            setExecutionRequirement(DefaultAuthenticationFlows.FIRST_BROKER_LOGIN_FLOW,\n+                    \"OTP Form\", currentFBLReq);\n+            credentials = getCredentials();\n+            Assert.assertEquals(2, credentials.size());\n+            Assert.assertEquals(OTPCredentialModel.TYPE, credentials.get(1).getType());\n+        } finally {\n+            // Revert flows", "originalCommit": "2d6df0f521257365a5262821b4f3829c483bc931", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0NTU1OQ==", "url": "https://github.com/keycloak/keycloak/pull/6690#discussion_r373445559", "bodyText": "It was reverted already on line 425 in this test.\nIn general, the AccountRestService test would start to fail if some stuff is not properly reverted :)", "author": "mposolda", "createdAt": "2020-01-31T11:57:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQwNzg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0NjE4MA==", "url": "https://github.com/keycloak/keycloak/pull/6690#discussion_r373446180", "bodyText": "@mposolda Ah, right. I missed that. :)", "author": "vmuzikar", "createdAt": "2020-01-31T11:59:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQwNzg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQ0NjM4Nw==", "url": "https://github.com/keycloak/keycloak/pull/6690#discussion_r373446387", "bodyText": "@vmuzikar Thanks!\n\n@mposolda Thanks for the update! Found one non-blocking nitpick. Other than that LGTM!\n\n\nDon't consider disabled authenticators when checking if particular credential type is enabled. For example if OTP Authenticator is disabled in the browser flow (and firstBrokerLogin flow), then OTP credential will be considered disabled as well and not available in the account console. This is per feedback by @vmuzikar .\n\n\nWe just must not forget to properly document this as it's not quite intuitive.\n\n+1, added comment to https://issues.redhat.com/browse/KEYCLOAK-12753 explicitly about this to not forget when working on docs.\n\nAlso, found one more non-related issue during the testing: https://issues.redhat.com/browse/KEYCLOAK-12858", "author": "mposolda", "createdAt": "2020-01-31T12:00:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3MzQwNzg5Mw=="}], "type": "inlineReview"}]}