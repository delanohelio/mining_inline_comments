{"pr_number": 7444, "pr_title": " KEYCLOAK-14977 create MapRoleProvider", "pr_createdAt": "2020-09-23T17:24:23Z", "pr_url": "https://github.com/keycloak/keycloak/pull/7444", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc3MDY5Mw==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r493770693", "bodyText": "When realm is being deleted I get ConcurrentModificationException here. It seems the problem is that while we iterate over underlying collection we also remove from it.", "author": "vramik", "createdAt": "2020-09-23T17:36:21Z", "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,336 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {\n+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addRealmRole(%s, %s, %s)%s\", realm.getName(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, realm.getId());\n+        entity.setName(name);\n+        entity.setRealmId(realm.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {\n+        Stream<RoleModel> s = getRealmRolesStream(realm);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(realm));\n+    }\n+\n+    @Override\n+    public RoleModel addClientRole(ClientModel client, String id, String name) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addClientRole(%s, %s, %s)%s\", client.getClientId(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, client.getId());\n+        entity.setName(name);\n+        entity.setClientRole(true);\n+        entity.setClientId(client.getId());\n+        entity.setRealmId(client.getRealm().getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(client.getRealm()).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client, Integer first, Integer max) {\n+        Stream<RoleModel> s = getClientRolesStream(client);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(client.getRealm()))\n+                .filter(entityClientFilter(client))\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(client.getRealm()));\n+    }\n+    @Override\n+    public boolean removeRole(RoleModel role) {\n+        LOG.tracef(\"removeRole(%s(%s))%s\", role.getName(), role.getId(), getShortStackTrace());\n+\n+        RealmModel realm = role.isClientRole() ? ((ClientModel)role.getContainer()).getRealm() : (RealmModel)role.getContainer();\n+\n+        session.users().preRemove(realm, role);\n+\n+        realm.removeDefaultRoles(role.getName());\n+        \n+        //remove role from realm-roles composites\n+        try (Stream<RoleModel> baseStream = getRealmRolesStream(realm).filter(RoleModel::isComposite)) {\n+            StreamUtils.leftInnerJoinStream(baseStream, RoleModel::getCompositesStream)\n+              .filter(pair -> role.equals(pair.getV()))\n+              .forEach(pair -> pair.getK().removeCompositeRole(role));", "originalCommit": "d1d75597b9d722e48e2b3fe5ec78187ed3c96d4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MzgwMDU2Mw==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r493800563", "bodyText": "Here a .collect is necessary before forEach since the stream of composite roles is still being read in the RoleModel::getCompositesStream above. Basically the same update as in #7436", "author": "hmlnarik", "createdAt": "2020-09-23T18:26:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mzc3MDY5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIxODQyOA==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r500218428", "bodyText": "Here we can get rid of lambda by this:\n.map(RoleModel::getId)\n.forEach(realm.getDefaultRolesIds()::remove);", "author": "mhajas", "createdAt": "2020-10-06T12:01:02Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java", "diffHunk": "@@ -716,74 +716,46 @@ public void updateRequiredCredentials(Set<String> creds) {\n         return Collections.unmodifiableList(requiredCredentialModels);\n     }\n \n-\n     @Override\n     public Stream<String> getDefaultRolesStream() {\n-        Collection<RoleEntity> entities = realm.getDefaultRoles();\n-        if (entities == null || entities.isEmpty()) return Stream.empty();\n-        return entities.stream().map(RoleEntity::getName);\n+        return realm.getDefaultRolesIds().stream().map(this::getRoleNameById);\n+    }\n+\n+    private String getRoleNameById(String id) {\n+        return getRoleById(id).getName();\n     }\n \n     @Override\n     public void addDefaultRole(String name) {\n-        RoleModel role = getRole(name);\n-        if (role == null) {\n-            role = addRole(name);\n-        }\n-        Collection<RoleEntity> entities = realm.getDefaultRoles();\n-        for (RoleEntity entity : entities) {\n-            if (entity.getId().equals(role.getId())) {\n-                return;\n-            }\n+        if (realm.getDefaultRolesIds().add(getOrAddRoleId(name))) {\n+            em.flush();\n         }\n-        RoleEntity roleEntity = RoleAdapter.toRoleEntity(role, em);\n-        entities.add(roleEntity);\n-        em.flush();\n     }\n \n-    public static boolean contains(String str, String[] array) {\n-        for (String s : array) {\n-            if (str.equals(s)) return true;\n+    private String getOrAddRoleId(String name) {\n+        RoleModel role = getRole(name);\n+        if (role == null) {\n+            role = addRole(name);\n         }\n-        return false;\n+        return role.getId();\n     }\n \n     @Override\n     public void updateDefaultRoles(String[] defaultRoles) {\n-        Collection<RoleEntity> entities = realm.getDefaultRoles();\n-        Set<String> already = new HashSet<String>();\n-        List<RoleEntity> remove = new ArrayList<RoleEntity>();\n-        for (RoleEntity rel : entities) {\n-            if (!contains(rel.getName(), defaultRoles)) {\n-                remove.add(rel);\n-            } else {\n-                already.add(rel.getName());\n-            }\n-        }\n-        for (RoleEntity entity : remove) {\n-            entities.remove(entity);\n-        }\n-        em.flush();\n-        for (String roleName : defaultRoles) {\n-            if (!already.contains(roleName)) {\n-                addDefaultRole(roleName);\n-            }\n-        }\n+        Set<String> newDefaultRolesIds = Arrays.stream(defaultRoles)\n+                .map(this::getOrAddRoleId)\n+                .collect(Collectors.toSet());\n+        realm.getDefaultRolesIds().retainAll(newDefaultRolesIds);\n+        realm.getDefaultRolesIds().addAll(newDefaultRolesIds);\n         em.flush();\n     }\n \n     @Override\n     public void removeDefaultRoles(String... defaultRoles) {\n-        Collection<RoleEntity> entities = realm.getDefaultRoles();\n-        List<RoleEntity> remove = new ArrayList<RoleEntity>();\n-        for (RoleEntity rel : entities) {\n-            if (contains(rel.getName(), defaultRoles)) {\n-                remove.add(rel);\n-            }\n-        }\n-        for (RoleEntity entity : remove) {\n-            entities.remove(entity);\n-        }\n+        Arrays.stream(defaultRoles)\n+                .map(this::getRole)\n+                .filter(Objects::nonNull)\n+                .forEach(role -> realm.getDefaultRolesIds().remove(role.getId()));", "originalCommit": "f669ad6e428e45a08896d0dafbbc800de7ec7c4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIyMTUzMg==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r500221532", "bodyText": "Is there any advantage of having this function static? Also, do we need the model instanceof RoleAdapter check? Is there any way this would be called from something which is not an instance of jpa.RoleAdapter?", "author": "mhajas", "createdAt": "2020-10-06T12:06:36Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RoleAdapter.java", "diffHunk": "@@ -214,7 +201,7 @@ public int hashCode() {\n         return getId().hashCode();\n     }\n \n-    public static RoleEntity toRoleEntity(RoleModel model, EntityManager em) {\n+    private static RoleEntity toRoleEntity(RoleModel model, EntityManager em) {", "originalCommit": "f669ad6e428e45a08896d0dafbbc800de7ec7c4e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE3NTY5OA==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r507175698", "bodyText": "It doesn't have to be static any more, thanks. The check is although still necessary. model could be instance of infinispan.RoleAdapter", "author": "vramik", "createdAt": "2020-10-18T15:18:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIyMTUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNzE5ODQ2MA==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r507198460", "bodyText": "static is better since there is one parameter less to pass (this).", "author": "hmlnarik", "createdAt": "2020-10-18T18:48:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIyMTUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwODI4MTk0MA==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r508281940", "bodyText": "It doesn't have to be static any more, thanks. The check is although still necessary. model could be instance of infinispan.RoleAdapter\n\nI see it now, thanks for explanation. I thought the model can't be anything else than jpa.RoleAdapter.\n\nstatic is better since there is one parameter less to pass (this).\n\nWell if it would be non-static, there are still 2 parameter because we can get rid of EntityManager, since it is part of this. Looking at it again, I would say it is not a big difference between static and non-static here, but maybe I am missing something. We can leave it as it is.", "author": "mhajas", "createdAt": "2020-10-20T07:49:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIyMTUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTA5NzgyNQ==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r509097825", "bodyText": "You're right. The rule for static is still valid but in this case, if the em is removed, it would make no difference.", "author": "hmlnarik", "createdAt": "2020-10-21T08:43:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIyMTUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwOTMwNzQ2OA==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r509307468", "bodyText": "I've left it as private non static method.", "author": "vramik", "createdAt": "2020-10-21T13:54:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDIyMTUzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI1NzUwNA==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r500257504", "bodyText": "Here we should check that there is no client role with the name for the client. This is enforced here for the jpa layer.", "author": "mhajas", "createdAt": "2020-10-06T13:03:36Z", "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {\n+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addRealmRole(%s, %s, %s)%s\", realm.getName(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, realm.getId());\n+        entity.setName(name);\n+        entity.setRealmId(realm.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {\n+        Stream<RoleModel> s = getRealmRolesStream(realm);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(this::isRealmRole)\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(realm));\n+    }\n+\n+    private boolean isRealmRole(MapRoleEntity role) {\n+        return ! role.isClientRole();\n+    }\n+\n+    @Override\n+    public RoleModel addClientRole(ClientModel client, String id, String name) {", "originalCommit": "f669ad6e428e45a08896d0dafbbc800de7ec7c4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI1ODU2NQ==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r500258565", "bodyText": "Here we should check that there is no realm role with the name for the realm. This is enforced here for the jpa layer.", "author": "mhajas", "createdAt": "2020-10-06T13:05:05Z", "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {\n+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {", "originalCommit": "f669ad6e428e45a08896d0dafbbc800de7ec7c4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI2MDMxNQ==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r500260315", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (first != null && first >= 0) {\n          \n          \n            \n                    if (first != null && first > 0) {", "author": "mhajas", "createdAt": "2020-10-06T13:07:31Z", "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {\n+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addRealmRole(%s, %s, %s)%s\", realm.getName(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, realm.getId());\n+        entity.setName(name);\n+        entity.setRealmId(realm.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {\n+        Stream<RoleModel> s = getRealmRolesStream(realm);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(this::isRealmRole)\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(realm));\n+    }\n+\n+    private boolean isRealmRole(MapRoleEntity role) {\n+        return ! role.isClientRole();\n+    }\n+\n+    @Override\n+    public RoleModel addClientRole(ClientModel client, String id, String name) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addClientRole(%s, %s, %s)%s\", client.getClientId(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, client.getRealm().getId());\n+        entity.setName(name);\n+        entity.setClientRole(true);\n+        entity.setClientId(client.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(client.getRealm()).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client, Integer first, Integer max) {\n+        Stream<RoleModel> s = getClientRolesStream(client);\n+        if (first != null && first >= 0) {", "originalCommit": "f669ad6e428e45a08896d0dafbbc800de7ec7c4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI2MDczOQ==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r500260739", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (first != null && first >= 0) {\n          \n          \n            \n                    if (first != null && first > 0) {", "author": "mhajas", "createdAt": "2020-10-06T13:08:10Z", "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {\n+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addRealmRole(%s, %s, %s)%s\", realm.getName(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, realm.getId());\n+        entity.setName(name);\n+        entity.setRealmId(realm.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {\n+        Stream<RoleModel> s = getRealmRolesStream(realm);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(this::isRealmRole)\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(realm));\n+    }\n+\n+    private boolean isRealmRole(MapRoleEntity role) {\n+        return ! role.isClientRole();\n+    }\n+\n+    @Override\n+    public RoleModel addClientRole(ClientModel client, String id, String name) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addClientRole(%s, %s, %s)%s\", client.getClientId(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, client.getRealm().getId());\n+        entity.setName(name);\n+        entity.setClientRole(true);\n+        entity.setClientId(client.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(client.getRealm()).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client, Integer first, Integer max) {\n+        Stream<RoleModel> s = getClientRolesStream(client);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(client.getRealm()))\n+                .filter(entityClientFilter(client))\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(client.getRealm()));\n+    }\n+    @Override\n+    public boolean removeRole(RoleModel role) {\n+        LOG.tracef(\"removeRole(%s(%s))%s\", role.getName(), role.getId(), getShortStackTrace());\n+\n+        RealmModel realm = role.isClientRole() ? ((ClientModel)role.getContainer()).getRealm() : (RealmModel)role.getContainer();\n+\n+        session.users().preRemove(realm, role);\n+\n+        realm.removeDefaultRoles(role.getName());\n+        \n+        //remove role from realm-roles composites\n+        try (Stream<RoleModel> baseStream = getRealmRolesStream(realm).filter(RoleModel::isComposite)) {\n+            StreamUtils.leftInnerJoinStream(baseStream, RoleModel::getCompositesStream)\n+                .filter(pair -> role.equals(pair.getV()))\n+                .collect(Collectors.toSet())\n+                .forEach(pair -> pair.getK().removeCompositeRole(role));\n+        }\n+        \n+        //remove role from client-roles composites\n+        session.clients().getClientsStream(realm).forEach(client -> {\n+            client.deleteScopeMapping(role);\n+            client.removeDefaultRoles(role.getName());\n+            try (Stream<RoleModel> baseStream = getClientRolesStream(client).filter(RoleModel::isComposite)) {\n+                StreamUtils.leftInnerJoinStream(baseStream, RoleModel::getCompositesStream)\n+                    .filter(pair -> role.equals(pair.getV()))\n+                    .collect(Collectors.toSet())\n+                    .forEach(pair -> pair.getK().removeCompositeRole(role));\n+            }\n+        });\n+\n+        // TODO: Sending an event should be extracted to store layer\n+        session.getKeycloakSessionFactory().publish(new RoleContainerModel.RoleRemovedEvent() {\n+            @Override\n+            public RoleModel getRole() {\n+                return role;\n+            }\n+\n+            @Override\n+            public KeycloakSession getKeycloakSession() {\n+                return session;\n+            }\n+        });\n+        // TODO: ^^^^^^^ Up to here\n+\n+        tx.remove(UUID.fromString(role.getId()));\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public void removeRoles(RealmModel realm) {\n+        getRealmRolesStream(realm).forEach(this::removeRole);\n+    }\n+\n+    @Override\n+    public void removeRoles(ClientModel client) {\n+        getClientRolesStream(client).forEach(this::removeRole);\n+    }\n+\n+    @Override\n+    public RoleModel getRealmRole(RealmModel realm, String name) {\n+        if (name == null) {\n+            return null;\n+        }\n+        LOG.tracef(\"getRealmRole(%s, %s)%s\", realm, name, getShortStackTrace());\n+\n+        String roleNameLower = name.toLowerCase();\n+\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(entity -> entity.getName()!= null && Objects.equals(entity.getName().toLowerCase(), roleNameLower))\n+                .map(entityToAdapterFunc(realm))\n+                .findFirst()\n+                .orElse(null);\n+    }\n+\n+    @Override\n+    public RoleModel getClientRole(ClientModel client, String name) {\n+        if (name == null) {\n+            return null;\n+        }\n+        LOG.tracef(\"getClientRole(%s, %s)%s\", client, name, getShortStackTrace());\n+\n+        String roleNameLower = name.toLowerCase();\n+\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(client.getRealm()))\n+                .filter(entityClientFilter(client))\n+                .filter(entity -> entity.getName()!= null && Objects.equals(entity.getName().toLowerCase(), roleNameLower))\n+                .map(entityToAdapterFunc(client.getRealm()))\n+                .findFirst()\n+                .orElse(null);\n+    }\n+\n+    @Override\n+    public RoleModel getRoleById(RealmModel realm, String id) {\n+        if (id == null) {\n+            return null;\n+        }\n+\n+        LOG.tracef(\"getRoleById(%s, %s)%s\", realm, id, getShortStackTrace());\n+\n+        MapRoleEntity entity = tx.get(UUID.fromString(id), roleStore::get);\n+        return (entity == null || ! entityRealmFilter(realm).test(entity))\n+          ? null\n+          : entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> searchForRolesStream(RealmModel realm, String search, Integer first, Integer max) {\n+        if (search == null) {\n+            return Stream.empty();\n+        }\n+        String searchLower = search.toLowerCase();\n+        Stream<MapRoleEntity> s = getNotRemovedUpdatedRolesStream()\n+            .filter(entityRealmFilter(realm))\n+            .filter(entity -> \n+                (entity.getName() != null && entity.getName().toLowerCase().contains(searchLower)) || \n+                (entity.getDescription() != null && entity.getDescription().toLowerCase().contains(searchLower))\n+            )\n+            .sorted(COMPARE_BY_NAME);\n+\n+        if (first != null && first >= 0) {", "originalCommit": "f669ad6e428e45a08896d0dafbbc800de7ec7c4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMDI2MDg2Mw==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r500260863", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    if (first != null && first >= 0) {\n          \n          \n            \n                    if (first != null && first > 0) {", "author": "mhajas", "createdAt": "2020-10-06T13:08:21Z", "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,344 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {\n+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addRealmRole(%s, %s, %s)%s\", realm.getName(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, realm.getId());\n+        entity.setName(name);\n+        entity.setRealmId(realm.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {\n+        Stream<RoleModel> s = getRealmRolesStream(realm);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(this::isRealmRole)\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(realm));\n+    }\n+\n+    private boolean isRealmRole(MapRoleEntity role) {\n+        return ! role.isClientRole();\n+    }\n+\n+    @Override\n+    public RoleModel addClientRole(ClientModel client, String id, String name) {\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addClientRole(%s, %s, %s)%s\", client.getClientId(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, client.getRealm().getId());\n+        entity.setName(name);\n+        entity.setClientRole(true);\n+        entity.setClientId(client.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(client.getRealm()).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client, Integer first, Integer max) {\n+        Stream<RoleModel> s = getClientRolesStream(client);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(client.getRealm()))\n+                .filter(entityClientFilter(client))\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(client.getRealm()));\n+    }\n+    @Override\n+    public boolean removeRole(RoleModel role) {\n+        LOG.tracef(\"removeRole(%s(%s))%s\", role.getName(), role.getId(), getShortStackTrace());\n+\n+        RealmModel realm = role.isClientRole() ? ((ClientModel)role.getContainer()).getRealm() : (RealmModel)role.getContainer();\n+\n+        session.users().preRemove(realm, role);\n+\n+        realm.removeDefaultRoles(role.getName());\n+        \n+        //remove role from realm-roles composites\n+        try (Stream<RoleModel> baseStream = getRealmRolesStream(realm).filter(RoleModel::isComposite)) {\n+            StreamUtils.leftInnerJoinStream(baseStream, RoleModel::getCompositesStream)\n+                .filter(pair -> role.equals(pair.getV()))\n+                .collect(Collectors.toSet())\n+                .forEach(pair -> pair.getK().removeCompositeRole(role));\n+        }\n+        \n+        //remove role from client-roles composites\n+        session.clients().getClientsStream(realm).forEach(client -> {\n+            client.deleteScopeMapping(role);\n+            client.removeDefaultRoles(role.getName());\n+            try (Stream<RoleModel> baseStream = getClientRolesStream(client).filter(RoleModel::isComposite)) {\n+                StreamUtils.leftInnerJoinStream(baseStream, RoleModel::getCompositesStream)\n+                    .filter(pair -> role.equals(pair.getV()))\n+                    .collect(Collectors.toSet())\n+                    .forEach(pair -> pair.getK().removeCompositeRole(role));\n+            }\n+        });\n+\n+        // TODO: Sending an event should be extracted to store layer\n+        session.getKeycloakSessionFactory().publish(new RoleContainerModel.RoleRemovedEvent() {\n+            @Override\n+            public RoleModel getRole() {\n+                return role;\n+            }\n+\n+            @Override\n+            public KeycloakSession getKeycloakSession() {\n+                return session;\n+            }\n+        });\n+        // TODO: ^^^^^^^ Up to here\n+\n+        tx.remove(UUID.fromString(role.getId()));\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public void removeRoles(RealmModel realm) {\n+        getRealmRolesStream(realm).forEach(this::removeRole);\n+    }\n+\n+    @Override\n+    public void removeRoles(ClientModel client) {\n+        getClientRolesStream(client).forEach(this::removeRole);\n+    }\n+\n+    @Override\n+    public RoleModel getRealmRole(RealmModel realm, String name) {\n+        if (name == null) {\n+            return null;\n+        }\n+        LOG.tracef(\"getRealmRole(%s, %s)%s\", realm, name, getShortStackTrace());\n+\n+        String roleNameLower = name.toLowerCase();\n+\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(entity -> entity.getName()!= null && Objects.equals(entity.getName().toLowerCase(), roleNameLower))\n+                .map(entityToAdapterFunc(realm))\n+                .findFirst()\n+                .orElse(null);\n+    }\n+\n+    @Override\n+    public RoleModel getClientRole(ClientModel client, String name) {\n+        if (name == null) {\n+            return null;\n+        }\n+        LOG.tracef(\"getClientRole(%s, %s)%s\", client, name, getShortStackTrace());\n+\n+        String roleNameLower = name.toLowerCase();\n+\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(client.getRealm()))\n+                .filter(entityClientFilter(client))\n+                .filter(entity -> entity.getName()!= null && Objects.equals(entity.getName().toLowerCase(), roleNameLower))\n+                .map(entityToAdapterFunc(client.getRealm()))\n+                .findFirst()\n+                .orElse(null);\n+    }\n+\n+    @Override\n+    public RoleModel getRoleById(RealmModel realm, String id) {\n+        if (id == null) {\n+            return null;\n+        }\n+\n+        LOG.tracef(\"getRoleById(%s, %s)%s\", realm, id, getShortStackTrace());\n+\n+        MapRoleEntity entity = tx.get(UUID.fromString(id), roleStore::get);\n+        return (entity == null || ! entityRealmFilter(realm).test(entity))\n+          ? null\n+          : entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> searchForRolesStream(RealmModel realm, String search, Integer first, Integer max) {\n+        if (search == null) {\n+            return Stream.empty();\n+        }\n+        String searchLower = search.toLowerCase();\n+        Stream<MapRoleEntity> s = getNotRemovedUpdatedRolesStream()\n+            .filter(entityRealmFilter(realm))\n+            .filter(entity -> \n+                (entity.getName() != null && entity.getName().toLowerCase().contains(searchLower)) || \n+                (entity.getDescription() != null && entity.getDescription().toLowerCase().contains(searchLower))\n+            )\n+            .sorted(COMPARE_BY_NAME);\n+\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+\n+        return s.map(entityToAdapterFunc(realm));\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> searchForClientRolesStream(ClientModel client, String search, Integer first, Integer max) {\n+        if (search == null) {\n+            return Stream.empty();\n+        }\n+        String searchLower = search.toLowerCase();\n+        Stream<MapRoleEntity> s = getNotRemovedUpdatedRolesStream()\n+            .filter(entityRealmFilter(client.getRealm()))\n+            .filter(entityClientFilter(client))\n+            .filter(entity -> \n+                (entity.getName() != null && entity.getName().toLowerCase().contains(searchLower)) || \n+                (entity.getDescription() != null && entity.getDescription().toLowerCase().contains(searchLower))\n+            )\n+            .sorted(COMPARE_BY_NAME);\n+\n+        if (first != null && first >= 0) {", "originalCommit": "f669ad6e428e45a08896d0dafbbc800de7ec7c4e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "78794c591f81f4b63b84105725fc1dddd167f750", "url": "https://github.com/keycloak/keycloak/commit/78794c591f81f4b63b84105725fc1dddd167f750", "message": "KEYCLOAK-14977 fixes", "committedDate": "2020-10-21T07:33:55Z", "type": "forcePushed"}, {"oid": "99b7d897c8cb54e060bf7671409ef6f0b160624f", "url": "https://github.com/keycloak/keycloak/commit/99b7d897c8cb54e060bf7671409ef6f0b160624f", "message": "KEYCLOAK-14977 fixes", "committedDate": "2020-10-21T13:36:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxMTMxMQ==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r511911311", "bodyText": "We can remove EntityManager parameter since it is not static anymore.", "author": "mhajas", "createdAt": "2020-10-26T12:07:29Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RoleAdapter.java", "diffHunk": "@@ -214,7 +201,7 @@ public int hashCode() {\n         return getId().hashCode();\n     }\n \n-    public static RoleEntity toRoleEntity(RoleModel model, EntityManager em) {\n+    private RoleEntity toRoleEntity(RoleModel model, EntityManager em) {", "originalCommit": "884f3011ecd10bf7cb45e6cc925feefce588f25f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxNDM0MQ==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r511914341", "bodyText": "Should this be String instead of K? Just wondering if it is possible to have a composite role with roles from some external RoleProvider. Therefore the role id would be something like f:......... Is it possible?", "author": "mhajas", "createdAt": "2020-10-26T12:13:40Z", "path": "model/map/src/main/java/org/keycloak/models/map/role/AbstractRoleEntity.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.role;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import org.keycloak.models.map.common.AbstractEntity;\n+\n+public abstract class AbstractRoleEntity<K> implements AbstractEntity<K> {\n+\n+    private K id;\n+    private String realmId;\n+\n+    private String name;\n+    private String description;\n+    private boolean clientRole;\n+    private String clientId;\n+    private Set<K> compositeRoles = new HashSet<>();", "originalCommit": "884f3011ecd10bf7cb45e6cc925feefce588f25f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjY0NzY1Nw==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r512647657", "bodyText": "We are storing IDs of roles here and when we have UUID id [1], we should have Set<K> here.\n[1] https://github.com/keycloak/keycloak/pull/7444/files/884f3011ecd10bf7cb45e6cc925feefce588f25f#diff-c3c97dc82010fc4aaacdc6874dd2008cf74bed60d0a739c4d7ac4bd260e5b2cfR21", "author": "vramik", "createdAt": "2020-10-27T12:22:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxNDM0MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzAwODg4Ng==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r513008886", "bodyText": "You're right, from long term perspective it'd be good to have it as String. Thank you", "author": "vramik", "createdAt": "2020-10-27T20:28:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkxNDM0MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkyOTcxOA==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r511929718", "bodyText": "Does this make sense?\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                    this.updated = true;\n          \n          \n            \n                    this.updated |= !Objects.equals(this.attributes.put(name, values), values);", "author": "mhajas", "createdAt": "2020-10-26T12:41:47Z", "path": "model/map/src/main/java/org/keycloak/models/map/role/AbstractRoleEntity.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models.map.role;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import org.keycloak.models.map.common.AbstractEntity;\n+\n+public abstract class AbstractRoleEntity<K> implements AbstractEntity<K> {\n+\n+    private K id;\n+    private String realmId;\n+\n+    private String name;\n+    private String description;\n+    private boolean clientRole;\n+    private String clientId;\n+    private Set<K> compositeRoles = new HashSet<>();\n+    private Map<String, List<String>> attributes = new HashMap<>();\n+\n+    /**\n+     * Flag signalizing that any of the setters has been meaningfully used.\n+     */\n+    protected boolean updated;\n+\n+    protected AbstractRoleEntity() {\n+        this.id = null;\n+        this.realmId = null;\n+    }\n+\n+    public AbstractRoleEntity(K id, String realmId) {\n+        Objects.requireNonNull(id, \"id\");\n+        Objects.requireNonNull(realmId, \"realmId\");\n+\n+        this.id = id;\n+        this.realmId = realmId;\n+    }\n+\n+    @Override\n+    public K getId() {\n+        return this.id;\n+    }\n+\n+    @Override\n+    public boolean isUpdated() {\n+        return this.updated;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.updated |= ! Objects.equals(this.name, name);\n+        this.name = name;\n+    }\n+\n+    public String getDescription() {\n+        return description;\n+    }\n+\n+    public void setDescription(String description) {\n+        this.updated |= ! Objects.equals(this.description, description);\n+        this.description = description;\n+    }\n+\n+    public Map<String, List<String>> getAttributes() {\n+        return attributes;\n+    }\n+\n+    public void setAttributes(Map<String, List<String>> attributes) {\n+        this.updated |= ! Objects.equals(this.attributes, attributes);\n+        this.attributes = attributes;\n+    }\n+\n+    public void setAttribute(String name, List<String> values) {\n+        this.updated = true;", "originalCommit": "884f3011ecd10bf7cb45e6cc925feefce588f25f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkzNTk4Mw==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r511935983", "bodyText": "Missing exception message.", "author": "mhajas", "createdAt": "2020-10-26T12:52:52Z", "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {\n+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {\n+        if (getRealmRole(realm, name) != null) {\n+            throw new ModelDuplicateException();", "originalCommit": "884f3011ecd10bf7cb45e6cc925feefce588f25f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkzNjA0NQ==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r511936045", "bodyText": "Missing exception message.", "author": "mhajas", "createdAt": "2020-10-26T12:53:01Z", "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {\n+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {\n+        if (getRealmRole(realm, name) != null) {\n+            throw new ModelDuplicateException();\n+        }\n+\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addRealmRole(%s, %s, %s)%s\", realm.getName(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, realm.getId());\n+        entity.setName(name);\n+        entity.setRealmId(realm.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {\n+        Stream<RoleModel> s = getRealmRolesStream(realm);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(this::isRealmRole)\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(realm));\n+    }\n+\n+    private boolean isRealmRole(MapRoleEntity role) {\n+        return ! role.isClientRole();\n+    }\n+\n+    @Override\n+    public RoleModel addClientRole(ClientModel client, String id, String name) {\n+        if (getClientRole(client, name) != null) {\n+            throw new ModelDuplicateException();", "originalCommit": "884f3011ecd10bf7cb45e6cc925feefce588f25f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTkzODYxOQ==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r511938619", "bodyText": "Each call to this function is followed by filtering by realm. There could be an other function with realm filtering or it can be added to this one.", "author": "mhajas", "createdAt": "2020-10-26T12:57:17Z", "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {", "originalCommit": "884f3011ecd10bf7cb45e6cc925feefce588f25f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk0NTEwOQ==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r511945109", "bodyText": "Should we create RoleModel for each entity? We can work with entities and then turn to model only those that need to be updated (so that we add entities to transaction). Or we can maybe get rid of models here completely and work with entities only. Because if I see correctly, the MapRoleAdapter just call an operation on the entity. WDYT? @hmlnarik Maybe you could have also something to say to this.\nI am asking also because I am doing something similar for users, so if it is incorrect I need to make few changes.", "author": "mhajas", "createdAt": "2020-10-26T13:08:37Z", "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {\n+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {\n+        if (getRealmRole(realm, name) != null) {\n+            throw new ModelDuplicateException();\n+        }\n+\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addRealmRole(%s, %s, %s)%s\", realm.getName(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, realm.getId());\n+        entity.setName(name);\n+        entity.setRealmId(realm.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {\n+        Stream<RoleModel> s = getRealmRolesStream(realm);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(this::isRealmRole)\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(realm));\n+    }\n+\n+    private boolean isRealmRole(MapRoleEntity role) {\n+        return ! role.isClientRole();\n+    }\n+\n+    @Override\n+    public RoleModel addClientRole(ClientModel client, String id, String name) {\n+        if (getClientRole(client, name) != null) {\n+            throw new ModelDuplicateException();\n+        }\n+\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addClientRole(%s, %s, %s)%s\", client.getClientId(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, client.getRealm().getId());\n+        entity.setName(name);\n+        entity.setClientRole(true);\n+        entity.setClientId(client.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(client.getRealm()).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client, Integer first, Integer max) {\n+        Stream<RoleModel> s = getClientRolesStream(client);\n+        if (first != null && first > 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(client.getRealm()))\n+                .filter(entityClientFilter(client))\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(client.getRealm()));\n+    }\n+    @Override\n+    public boolean removeRole(RoleModel role) {\n+        LOG.tracef(\"removeRole(%s(%s))%s\", role.getName(), role.getId(), getShortStackTrace());\n+\n+        RealmModel realm = role.isClientRole() ? ((ClientModel)role.getContainer()).getRealm() : (RealmModel)role.getContainer();\n+\n+        session.users().preRemove(realm, role);\n+\n+        RoleContainerModel container = role.getContainer();\n+        if (container.getDefaultRolesStream().anyMatch(r -> Objects.equals(r, role.getName()))) {\n+            container.removeDefaultRoles(role.getName());\n+        }\n+\n+        //remove role from realm-roles composites\n+        try (Stream<RoleModel> baseStream = getRealmRolesStream(realm).filter(RoleModel::isComposite)) {", "originalCommit": "884f3011ecd10bf7cb45e6cc925feefce588f25f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzA1MzQyMQ==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r513053421", "bodyText": "I've changed it according to your suggestion. Thank you. The code is a little bit longer and maybe slightly less readable, but as you said by this approach we got rid of sorting and turning all entities to model. I'd like to also hear @hmlnarik's opinion on this.", "author": "vramik", "createdAt": "2020-10-27T21:49:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk0NTEwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDQwNTE4NA==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r514405184", "bodyText": "+1 to @mhajas's suggestion. Thanks for updating this!", "author": "hmlnarik", "createdAt": "2020-10-29T16:40:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk0NTEwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk0OTQ2NA==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r511949464", "bodyText": "The same here.", "author": "mhajas", "createdAt": "2020-10-26T13:15:27Z", "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {\n+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {\n+        if (getRealmRole(realm, name) != null) {\n+            throw new ModelDuplicateException();\n+        }\n+\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addRealmRole(%s, %s, %s)%s\", realm.getName(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, realm.getId());\n+        entity.setName(name);\n+        entity.setRealmId(realm.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {\n+        Stream<RoleModel> s = getRealmRolesStream(realm);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(this::isRealmRole)\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(realm));\n+    }\n+\n+    private boolean isRealmRole(MapRoleEntity role) {\n+        return ! role.isClientRole();\n+    }\n+\n+    @Override\n+    public RoleModel addClientRole(ClientModel client, String id, String name) {\n+        if (getClientRole(client, name) != null) {\n+            throw new ModelDuplicateException();\n+        }\n+\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addClientRole(%s, %s, %s)%s\", client.getClientId(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, client.getRealm().getId());\n+        entity.setName(name);\n+        entity.setClientRole(true);\n+        entity.setClientId(client.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(client.getRealm()).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client, Integer first, Integer max) {\n+        Stream<RoleModel> s = getClientRolesStream(client);\n+        if (first != null && first > 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(client.getRealm()))\n+                .filter(entityClientFilter(client))\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(client.getRealm()));\n+    }\n+    @Override\n+    public boolean removeRole(RoleModel role) {\n+        LOG.tracef(\"removeRole(%s(%s))%s\", role.getName(), role.getId(), getShortStackTrace());\n+\n+        RealmModel realm = role.isClientRole() ? ((ClientModel)role.getContainer()).getRealm() : (RealmModel)role.getContainer();\n+\n+        session.users().preRemove(realm, role);\n+\n+        RoleContainerModel container = role.getContainer();\n+        if (container.getDefaultRolesStream().anyMatch(r -> Objects.equals(r, role.getName()))) {\n+            container.removeDefaultRoles(role.getName());\n+        }\n+\n+        //remove role from realm-roles composites\n+        try (Stream<RoleModel> baseStream = getRealmRolesStream(realm).filter(RoleModel::isComposite)) {\n+            StreamUtils.leftInnerJoinStream(baseStream, RoleModel::getCompositesStream)\n+                .filter(pair -> role.equals(pair.getV()))\n+                .collect(Collectors.toSet())\n+                .forEach(pair -> pair.getK().removeCompositeRole(role));\n+        }\n+\n+        //remove role from client-roles composites\n+        session.clients().getClientsStream(realm).forEach(client -> {\n+            client.deleteScopeMapping(role);\n+            try (Stream<RoleModel> baseStream = getClientRolesStream(client).filter(RoleModel::isComposite)) {", "originalCommit": "884f3011ecd10bf7cb45e6cc925feefce588f25f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1MjgwNw==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r511952807", "bodyText": "Replace with method reference", "author": "mhajas", "createdAt": "2020-10-26T13:20:28Z", "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {\n+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {\n+        if (getRealmRole(realm, name) != null) {\n+            throw new ModelDuplicateException();\n+        }\n+\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addRealmRole(%s, %s, %s)%s\", realm.getName(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, realm.getId());\n+        entity.setName(name);\n+        entity.setRealmId(realm.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {\n+        Stream<RoleModel> s = getRealmRolesStream(realm);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(this::isRealmRole)\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(realm));\n+    }\n+\n+    private boolean isRealmRole(MapRoleEntity role) {\n+        return ! role.isClientRole();\n+    }\n+\n+    @Override\n+    public RoleModel addClientRole(ClientModel client, String id, String name) {\n+        if (getClientRole(client, name) != null) {\n+            throw new ModelDuplicateException();\n+        }\n+\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addClientRole(%s, %s, %s)%s\", client.getClientId(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, client.getRealm().getId());\n+        entity.setName(name);\n+        entity.setClientRole(true);\n+        entity.setClientId(client.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(client.getRealm()).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client, Integer first, Integer max) {\n+        Stream<RoleModel> s = getClientRolesStream(client);\n+        if (first != null && first > 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(client.getRealm()))\n+                .filter(entityClientFilter(client))\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(client.getRealm()));\n+    }\n+    @Override\n+    public boolean removeRole(RoleModel role) {\n+        LOG.tracef(\"removeRole(%s(%s))%s\", role.getName(), role.getId(), getShortStackTrace());\n+\n+        RealmModel realm = role.isClientRole() ? ((ClientModel)role.getContainer()).getRealm() : (RealmModel)role.getContainer();\n+\n+        session.users().preRemove(realm, role);\n+\n+        RoleContainerModel container = role.getContainer();\n+        if (container.getDefaultRolesStream().anyMatch(r -> Objects.equals(r, role.getName()))) {\n+            container.removeDefaultRoles(role.getName());\n+        }\n+\n+        //remove role from realm-roles composites\n+        try (Stream<RoleModel> baseStream = getRealmRolesStream(realm).filter(RoleModel::isComposite)) {\n+            StreamUtils.leftInnerJoinStream(baseStream, RoleModel::getCompositesStream)\n+                .filter(pair -> role.equals(pair.getV()))\n+                .collect(Collectors.toSet())\n+                .forEach(pair -> pair.getK().removeCompositeRole(role));\n+        }\n+\n+        //remove role from client-roles composites\n+        session.clients().getClientsStream(realm).forEach(client -> {\n+            client.deleteScopeMapping(role);\n+            try (Stream<RoleModel> baseStream = getClientRolesStream(client).filter(RoleModel::isComposite)) {\n+                StreamUtils.leftInnerJoinStream(baseStream, RoleModel::getCompositesStream)\n+                    .filter(pair -> role.equals(pair.getV()))\n+                    .collect(Collectors.toSet())\n+                    .forEach(pair -> pair.getK().removeCompositeRole(role));\n+            }\n+        });\n+        session.groups().preRemove(realm, role);\n+\n+        // TODO: Sending an event should be extracted to store layer\n+        session.getKeycloakSessionFactory().publish(new RoleContainerModel.RoleRemovedEvent() {\n+            @Override\n+            public RoleModel getRole() {\n+                return role;\n+            }\n+\n+            @Override\n+            public KeycloakSession getKeycloakSession() {\n+                return session;\n+            }\n+        });\n+        // TODO: ^^^^^^^ Up to here\n+\n+        tx.remove(UUID.fromString(role.getId()));\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public void removeRoles(RealmModel realm) {\n+        getRealmRolesStream(realm).forEach(this::removeRole);\n+    }\n+\n+    @Override\n+    public void removeRoles(ClientModel client) {\n+        getClientRolesStream(client).forEach(this::removeRole);\n+    }\n+\n+    @Override\n+    public RoleModel getRealmRole(RealmModel realm, String name) {\n+        if (name == null) {\n+            return null;\n+        }\n+        LOG.tracef(\"getRealmRole(%s, %s)%s\", realm.getName(), name, getShortStackTrace());\n+\n+        String roleNameLower = name.toLowerCase();\n+\n+        String roleId = getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(entity -> entity.getName()!= null && Objects.equals(entity.getName().toLowerCase(), roleNameLower))\n+                .map(entityToAdapterFunc(realm))\n+                .map(entity -> entity.getId())", "originalCommit": "884f3011ecd10bf7cb45e6cc925feefce588f25f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMTk1MzEyOA==", "url": "https://github.com/keycloak/keycloak/pull/7444#discussion_r511953128", "bodyText": "Replace with method reference.", "author": "mhajas", "createdAt": "2020-10-26T13:20:54Z", "path": "model/map/src/main/java/org/keycloak/models/map/role/MapRoleProvider.java", "diffHunk": "@@ -0,0 +1,361 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.models.map.role;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.ModelDuplicateException;\n+import org.keycloak.models.RealmModel;\n+\n+import org.keycloak.models.RoleModel;\n+import org.keycloak.models.map.storage.MapKeycloakTransaction;\n+import org.keycloak.models.map.common.Serialization;\n+import java.util.Comparator;\n+import java.util.Objects;\n+import java.util.UUID;\n+import java.util.function.Function;\n+import java.util.function.Predicate;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+import org.keycloak.models.map.storage.MapStorage;\n+import static org.keycloak.common.util.StackUtil.getShortStackTrace;\n+import org.keycloak.models.RoleContainerModel;\n+import org.keycloak.models.RoleProvider;\n+import org.keycloak.models.map.common.StreamUtils;\n+\n+public class MapRoleProvider implements RoleProvider {\n+\n+    private static final Logger LOG = Logger.getLogger(MapRoleProvider.class);\n+    private static final Predicate<MapRoleEntity> ALWAYS_FALSE = role -> { return false; };\n+    private final KeycloakSession session;\n+    final MapKeycloakTransaction<UUID, MapRoleEntity> tx;\n+    private final MapStorage<UUID, MapRoleEntity> roleStore;\n+\n+    private static final Comparator<MapRoleEntity> COMPARE_BY_NAME = new Comparator<MapRoleEntity>() {\n+        @Override\n+        public int compare(MapRoleEntity o1, MapRoleEntity o2) {\n+            String r1 = o1 == null ? null : o1.getName();\n+            String r2 = o2 == null ? null : o2.getName();\n+            return r1 == r2 ? 0\n+              : r1 == null ? -1\n+              : r2 == null ? 1\n+              : r1.compareTo(r2);\n+\n+        }\n+    };\n+\n+    public MapRoleProvider(KeycloakSession session, MapStorage<UUID, MapRoleEntity> roleStore) {\n+        this.session = session;\n+        this.roleStore = roleStore;\n+        this.tx = new MapKeycloakTransaction<>(roleStore);\n+        session.getTransactionManager().enlist(tx);\n+    }\n+\n+    private Function<MapRoleEntity, RoleModel> entityToAdapterFunc(RealmModel realm) {\n+        // Clone entity before returning back, to avoid giving away a reference to the live object to the caller\n+\n+        return origEntity -> new MapRoleAdapter(session, realm, registerEntityForChanges(origEntity));\n+    }\n+\n+    private MapRoleEntity registerEntityForChanges(MapRoleEntity origEntity) {\n+        final MapRoleEntity res = Serialization.from(origEntity);\n+        tx.putIfChanged(origEntity.getId(), res, MapRoleEntity::isUpdated);\n+        return res;\n+    }\n+\n+    private Predicate<MapRoleEntity> entityRealmFilter(RealmModel realm) {\n+        if (realm == null || realm.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String realmId = realm.getId();\n+        return entity -> Objects.equals(realmId, entity.getRealmId());\n+    }\n+\n+    private Predicate<MapRoleEntity> entityClientFilter(ClientModel client) {\n+        if (client == null || client.getId() == null) {\n+            return MapRoleProvider.ALWAYS_FALSE;\n+        }\n+        String clientId = client.getId();\n+        return entity -> entity.isClientRole() && \n+                Objects.equals(clientId, entity.getClientId());\n+    }\n+\n+    private Stream<MapRoleEntity> getNotRemovedUpdatedRolesStream() {\n+        Stream<MapRoleEntity> updatedAndNotRemovedRolesStream = roleStore.entrySet().stream()\n+          .map(tx::getUpdated)    // If the role has been removed, tx.get will return null, otherwise it will return me.getValue()\n+          .filter(Objects::nonNull);\n+        return Stream.concat(tx.createdValuesStream(roleStore.keySet()), updatedAndNotRemovedRolesStream);\n+    }\n+\n+    @Override\n+    public RoleModel addRealmRole(RealmModel realm, String id, String name) {\n+        if (getRealmRole(realm, name) != null) {\n+            throw new ModelDuplicateException();\n+        }\n+\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addRealmRole(%s, %s, %s)%s\", realm.getName(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, realm.getId());\n+        entity.setName(name);\n+        entity.setRealmId(realm.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(realm).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm, Integer first, Integer max) {\n+        Stream<RoleModel> s = getRealmRolesStream(realm);\n+        if (first != null && first >= 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getRealmRolesStream(RealmModel realm) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(this::isRealmRole)\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(realm));\n+    }\n+\n+    private boolean isRealmRole(MapRoleEntity role) {\n+        return ! role.isClientRole();\n+    }\n+\n+    @Override\n+    public RoleModel addClientRole(ClientModel client, String id, String name) {\n+        if (getClientRole(client, name) != null) {\n+            throw new ModelDuplicateException();\n+        }\n+\n+        final UUID entityId = id == null ? UUID.randomUUID() : UUID.fromString(id);\n+\n+        LOG.tracef(\"addClientRole(%s, %s, %s)%s\", client.getClientId(), id, name, getShortStackTrace());\n+\n+        MapRoleEntity entity = new MapRoleEntity(entityId, client.getRealm().getId());\n+        entity.setName(name);\n+        entity.setClientRole(true);\n+        entity.setClientId(client.getId());\n+        if (tx.get(entity.getId(), roleStore::get) != null) {\n+            throw new ModelDuplicateException(\"Role exists: \" + id);\n+        }\n+        tx.putIfAbsent(entity.getId(), entity);\n+        return entityToAdapterFunc(client.getRealm()).apply(entity);\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client, Integer first, Integer max) {\n+        Stream<RoleModel> s = getClientRolesStream(client);\n+        if (first != null && first > 0) {\n+            s = s.skip(first);\n+        }\n+        if (max != null && max >= 0) {\n+            s = s.limit(max);\n+        }\n+        return s;\n+    }\n+\n+    @Override\n+    public Stream<RoleModel> getClientRolesStream(ClientModel client) {\n+        return getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(client.getRealm()))\n+                .filter(entityClientFilter(client))\n+                .sorted(COMPARE_BY_NAME)\n+                .map(entityToAdapterFunc(client.getRealm()));\n+    }\n+    @Override\n+    public boolean removeRole(RoleModel role) {\n+        LOG.tracef(\"removeRole(%s(%s))%s\", role.getName(), role.getId(), getShortStackTrace());\n+\n+        RealmModel realm = role.isClientRole() ? ((ClientModel)role.getContainer()).getRealm() : (RealmModel)role.getContainer();\n+\n+        session.users().preRemove(realm, role);\n+\n+        RoleContainerModel container = role.getContainer();\n+        if (container.getDefaultRolesStream().anyMatch(r -> Objects.equals(r, role.getName()))) {\n+            container.removeDefaultRoles(role.getName());\n+        }\n+\n+        //remove role from realm-roles composites\n+        try (Stream<RoleModel> baseStream = getRealmRolesStream(realm).filter(RoleModel::isComposite)) {\n+            StreamUtils.leftInnerJoinStream(baseStream, RoleModel::getCompositesStream)\n+                .filter(pair -> role.equals(pair.getV()))\n+                .collect(Collectors.toSet())\n+                .forEach(pair -> pair.getK().removeCompositeRole(role));\n+        }\n+\n+        //remove role from client-roles composites\n+        session.clients().getClientsStream(realm).forEach(client -> {\n+            client.deleteScopeMapping(role);\n+            try (Stream<RoleModel> baseStream = getClientRolesStream(client).filter(RoleModel::isComposite)) {\n+                StreamUtils.leftInnerJoinStream(baseStream, RoleModel::getCompositesStream)\n+                    .filter(pair -> role.equals(pair.getV()))\n+                    .collect(Collectors.toSet())\n+                    .forEach(pair -> pair.getK().removeCompositeRole(role));\n+            }\n+        });\n+        session.groups().preRemove(realm, role);\n+\n+        // TODO: Sending an event should be extracted to store layer\n+        session.getKeycloakSessionFactory().publish(new RoleContainerModel.RoleRemovedEvent() {\n+            @Override\n+            public RoleModel getRole() {\n+                return role;\n+            }\n+\n+            @Override\n+            public KeycloakSession getKeycloakSession() {\n+                return session;\n+            }\n+        });\n+        // TODO: ^^^^^^^ Up to here\n+\n+        tx.remove(UUID.fromString(role.getId()));\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public void removeRoles(RealmModel realm) {\n+        getRealmRolesStream(realm).forEach(this::removeRole);\n+    }\n+\n+    @Override\n+    public void removeRoles(ClientModel client) {\n+        getClientRolesStream(client).forEach(this::removeRole);\n+    }\n+\n+    @Override\n+    public RoleModel getRealmRole(RealmModel realm, String name) {\n+        if (name == null) {\n+            return null;\n+        }\n+        LOG.tracef(\"getRealmRole(%s, %s)%s\", realm.getName(), name, getShortStackTrace());\n+\n+        String roleNameLower = name.toLowerCase();\n+\n+        String roleId = getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(realm))\n+                .filter(entity -> entity.getName()!= null && Objects.equals(entity.getName().toLowerCase(), roleNameLower))\n+                .map(entityToAdapterFunc(realm))\n+                .map(entity -> entity.getId())\n+                .findFirst()\n+                .orElse(null);\n+        //we need to go via session.roles() not to bypass cache\n+        return roleId == null ? null : session.roles().getRoleById(realm, roleId);\n+    }\n+\n+    @Override\n+    public RoleModel getClientRole(ClientModel client, String name) {\n+        if (name == null) {\n+            return null;\n+        }\n+        LOG.tracef(\"getClientRole(%s, %s)%s\", client.getClientId(), name, getShortStackTrace());\n+\n+        String roleNameLower = name.toLowerCase();\n+\n+        String roleId = getNotRemovedUpdatedRolesStream()\n+                .filter(entityRealmFilter(client.getRealm()))\n+                .filter(entityClientFilter(client))\n+                .filter(entity -> entity.getName()!= null && Objects.equals(entity.getName().toLowerCase(), roleNameLower))\n+                .map(entityToAdapterFunc(client.getRealm()))\n+                .map(entity -> entity.getId())", "originalCommit": "884f3011ecd10bf7cb45e6cc925feefce588f25f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e6be5a0340b6db0f0e87480185f9ef47663c27eb", "url": "https://github.com/keycloak/keycloak/commit/e6be5a0340b6db0f0e87480185f9ef47663c27eb", "message": "KEYCLOAK-14977 address comments - part3 - final", "committedDate": "2020-10-27T21:42:58Z", "type": "forcePushed"}, {"oid": "1198b340c7780ac7543be054cc9447f0d3146c08", "url": "https://github.com/keycloak/keycloak/commit/1198b340c7780ac7543be054cc9447f0d3146c08", "message": "KEYCLOAK-14977 address comments - part3 - final", "committedDate": "2020-10-27T21:45:02Z", "type": "forcePushed"}, {"oid": "5f7d8417118e87dd8318224267d05ac67c6c01b8", "url": "https://github.com/keycloak/keycloak/commit/5f7d8417118e87dd8318224267d05ac67c6c01b8", "message": "KEYCLOAK-14977 create MapRoleProvider", "committedDate": "2020-10-29T19:02:51Z", "type": "commit"}, {"oid": "5f7d8417118e87dd8318224267d05ac67c6c01b8", "url": "https://github.com/keycloak/keycloak/commit/5f7d8417118e87dd8318224267d05ac67c6c01b8", "message": "KEYCLOAK-14977 create MapRoleProvider", "committedDate": "2020-10-29T19:02:51Z", "type": "forcePushed"}]}