{"pr_number": 7104, "pr_title": "KEYCLOAK-14189 Client Policy : Basics", "pr_createdAt": "2020-05-25T05:18:19Z", "pr_url": "https://github.com/keycloak/keycloak/pull/7104", "timeline": [{"oid": "57524c993ce43c8958221f1c63f19a9360672bd2", "url": "https://github.com/keycloak/keycloak/commit/57524c993ce43c8958221f1c63f19a9360672bd2", "message": "KEYCLOAK-14189 Client Policy : Basics", "committedDate": "2020-05-25T06:27:47Z", "type": "forcePushed"}, {"oid": "5954e30e4438d9be8e34198b7df95a6ac1d4a65e", "url": "https://github.com/keycloak/keycloak/commit/5954e30e4438d9be8e34198b7df95a6ac1d4a65e", "message": "KEYCLOAK-14189 Client Policy : Basics", "committedDate": "2020-05-25T07:50:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4NTYwNA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r430885604", "bodyText": "One issue I see here is that it will be relatively expensive to loop through the component model and initialise all policies for all requests. A better option may be to follow something more along the lines of what is done with keys. See https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/keys/DefaultKeyManager.java. It caches the keys with the realm, which means it doesn't have to parse the config and load keys for every request.", "author": "stianst", "createdAt": "2020-05-27T06:31:14Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+public class ClientPolicyManager {", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY5Mjg2Ng==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431692866", "bodyText": "I see, it is performance matter and it can be resolved by cache conceptually. And I can find out the hint of how to implement it in https://github.com/keycloak/keycloak/blob/master/services/src/main/java/org/keycloak/keys/DefaultKeyManager.java. Let me give some time to study it.", "author": "tnorimat", "createdAt": "2020-05-28T09:10:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4NTYwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4NTc1MA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r430885750", "bodyText": "See comment on ClientPolicyManager, but this should be something like session.clientPolicy().trigger...", "author": "stianst", "createdAt": "2020-05-27T06:31:44Z", "path": "services/src/main/java/org/keycloak/protocol/oidc/endpoints/AuthorizationEndpoint.java", "diffHunk": "@@ -153,6 +155,12 @@ private Response process(MultivaluedMap<String, String> params) {\n             return errorResponse;\n         }\n \n+        try {\n+            ClientPolicyManager.triggerOnAuthorizationRequest(parsedResponseType, request, redirectUri, session);", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY5NDgzMw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431694833", "bodyText": "I see, Instead of calling ClientPolicyManager directly, calling KeycloakSession.clientPolicy() .", "author": "tnorimat", "createdAt": "2020-05-28T09:14:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4NTc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA2MzkwNQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r437063905", "bodyText": "I've tried to add clientPolicy() method on KeycloakSession and DefaultKecloakSession but have a problem. KeycloakSession belongs to keycloak-server-spi while ClientPolicyManager belongs to keycloak-services. The latter is not visible from the former. Considering signatures of methods in ClientPolicyManager, it seems to be difficult to implement ClientPolicyManager interface in keycloak-server-spi and DefaultClientPolicyManager implements ClientPolicyManager class in keycloak-services. Is it inevitably necessary to do so instead of the current ClientPolicyManager's method call directly?", "author": "tnorimat", "createdAt": "2020-06-08T23:58:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4NTc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTk2ODY0Ng==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r439968646", "bodyText": "I'm not quite sure I'm following. Why would it be problematic to have a ClientPolicyManager interface in keycloak-server-spi, with the DefaultClientPolicyManager in services?", "author": "stianst", "createdAt": "2020-06-15T07:05:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4NTc1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDQzMTgxNw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r440431817", "bodyText": "I've treated this matter as follows :\n\nCrate ClientPolicyContext in keycloak-server-spi interface only have a method for returning an event.\nClientPolicyManager interface in keycloak-server-spi receives this ClientPolicyContext as an argument.\nKeycloakSession interface in keycloak-server-spi has the method to get ClientPolicyManager.\nAn implementation class of ClientPolicyContext in keycloak-services implements actual methods depending on an event defined in ClientPolicyEvent.", "author": "tnorimat", "createdAt": "2020-06-15T20:36:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4NTc1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4NjUzNg==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r430886536", "bodyText": "Change to errorDetail", "author": "stianst", "createdAt": "2020-05-27T06:33:45Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyException.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+public class ClientPolicyException extends Exception {\n+    private String error;\n+    private String error_detail;", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTY5NTg5NA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431695894", "bodyText": "Yes, I'll change error_detail to errorDetail.", "author": "tnorimat", "createdAt": "2020-05-28T09:16:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4NjUzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4ODAxMw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r430888013", "bodyText": "Shouldn't we remove this, and always use error/errorDetails?", "author": "stianst", "createdAt": "2020-05-27T06:37:27Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyException.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+public class ClientPolicyException extends Exception {\n+    private String error;\n+    private String error_detail;\n+\n+    public ClientPolicyException(String message) {", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcwMjM2Mw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431702363", "bodyText": "I see, I'll remove this constructor.", "author": "tnorimat", "createdAt": "2020-05-28T09:27:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4ODAxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4ODE4NA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r430888184", "bodyText": "See above. Perhaps add \"public ClientPolicyException(String error, String error_detail, Throwable throwable)\" instead", "author": "stianst", "createdAt": "2020-05-27T06:37:53Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyException.java", "diffHunk": "@@ -0,0 +1,55 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+public class ClientPolicyException extends Exception {\n+    private String error;\n+    private String error_detail;\n+\n+    public ClientPolicyException(String message) {\n+        super(message);\n+    }\n+\n+    public ClientPolicyException(String message, Throwable throwable) {", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTcwMzM1Mw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431703353", "bodyText": "So, I'll remove this constructor and add ClientPolicyException(String error, String error_detail, Throwable throwable) constructor.", "author": "tnorimat", "createdAt": "2020-05-28T09:29:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg4ODE4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5MzA0NA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r430893044", "bodyText": "Rename to ClientPolicyExecutorProvider", "author": "stianst", "createdAt": "2020-05-27T06:50:27Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/ClientPolicyExecutorSpi.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor;\n+\n+import org.keycloak.provider.Provider;\n+import org.keycloak.provider.ProviderFactory;\n+import org.keycloak.provider.Spi;\n+\n+public class ClientPolicyExecutorSpi implements Spi {\n+\n+    @Override\n+    public boolean isInternal() {\n+        return true;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"client-policy-executor\";\n+    }\n+\n+    @Override\n+    public Class<? extends Provider> getProviderClass() {\n+        return ClientPolicyExecutor.class;", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIwOTkyMA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432209920", "bodyText": "I see, I'll rename to ClientPolicyExecutorProvider.", "author": "tnorimat", "createdAt": "2020-05-29T01:31:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5MzA0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5MzE3OQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r430893179", "bodyText": "Rename to ClientPolicyExecutorProviderFactory", "author": "stianst", "createdAt": "2020-05-27T06:50:43Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/ClientPolicyExecutorSpi.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor;\n+\n+import org.keycloak.provider.Provider;\n+import org.keycloak.provider.ProviderFactory;\n+import org.keycloak.provider.Spi;\n+\n+public class ClientPolicyExecutorSpi implements Spi {\n+\n+    @Override\n+    public boolean isInternal() {\n+        return true;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"client-policy-executor\";\n+    }\n+\n+    @Override\n+    public Class<? extends Provider> getProviderClass() {\n+        return ClientPolicyExecutor.class;\n+    }\n+\n+    @Override\n+    public Class<? extends ProviderFactory> getProviderFactoryClass() {\n+        return ClientPolicyExecutorFactory.class;", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIwOTk2Ng==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432209966", "bodyText": "I see, I'll rename to ClientPolicyExecutorProviderFactory.", "author": "tnorimat", "createdAt": "2020-05-29T01:31:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5MzE3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5MzM1Mw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r430893353", "bodyText": "Rename to ClientPolicyConditionProvider", "author": "stianst", "createdAt": "2020-05-27T06:51:07Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/condition/ClientPolicyConditionSpi.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.condition;\n+\n+import org.keycloak.provider.Provider;\n+import org.keycloak.provider.ProviderFactory;\n+import org.keycloak.provider.Spi;\n+\n+public class ClientPolicyConditionSpi implements Spi {\n+\n+    @Override\n+    public boolean isInternal() {\n+        return true;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"client-policy-condition\";\n+    }\n+\n+    @Override\n+    public Class<? extends Provider> getProviderClass() {\n+        return ClientPolicyCondition.class;", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIwOTA0Ng==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432209046", "bodyText": "I see, I'll rename to  ClientPolicyConditionProvider.", "author": "tnorimat", "createdAt": "2020-05-29T01:28:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5MzM1Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5MzQzNA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r430893434", "bodyText": "Rename to ClientPolicyConditionProviderFactory", "author": "stianst", "createdAt": "2020-05-27T06:51:17Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/condition/ClientPolicyConditionSpi.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.condition;\n+\n+import org.keycloak.provider.Provider;\n+import org.keycloak.provider.ProviderFactory;\n+import org.keycloak.provider.Spi;\n+\n+public class ClientPolicyConditionSpi implements Spi {\n+\n+    @Override\n+    public boolean isInternal() {\n+        return true;\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"client-policy-condition\";\n+    }\n+\n+    @Override\n+    public Class<? extends Provider> getProviderClass() {\n+        return ClientPolicyCondition.class;\n+    }\n+\n+    @Override\n+    public Class<? extends ProviderFactory> getProviderFactoryClass() {\n+        return ClientPolicyConditionFactory.class;", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIwOTEyOA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432209128", "bodyText": "I see, I'll rename ClientPolicyConditionProviderFactory.", "author": "tnorimat", "createdAt": "2020-05-29T01:28:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5MzQzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5NjQzOQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r430896439", "bodyText": "Very often a condition is going to have the same code for create/update as well as if it's admin or dynamic. So I would rather see something like:\ndefault boolean isSatisfiedOnClientUpdate(ClientUpdateContext context)\nWhere ClientUpdateContext contains information about who is updating it, and if it's a create or update.", "author": "stianst", "createdAt": "2020-05-27T06:58:09Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/condition/ClientPolicyCondition.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.condition;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.provider.Provider;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+/**\n+ * This condition determines to which client a {@link ClientPolicyProvider} is adopted.\n+ * The condition can be evaluated on the events defined in {@link ClientPolicyEvent}.\n+ * It is sufficient for the implementer of this condition to implement methods in which they are interested\n+ * and {@link isEvaluatedOnEvent} method.\n+ */\n+public interface ClientPolicyCondition extends Provider {\n+\n+    @Override\n+    default void close() {}\n+\n+    /**\n+     * returns true if this condition is evaluated to check\n+     * whether the client satisfies this condition on the event specified as a parameter.\n+     * A condition can be implemented to be evaluated on some events while not on others.\n+     * On the event specified as the parameter, this condition is skipped if this method returns false.\n+     *\n+     * @param event defined in {@link ClientPolicyEvent}\n+     * @return true if this condition is evaluated on the event.\n+     */\n+    default boolean isEvaluatedOnEvent(String event) {return true;}\n+\n+    /**\n+     * returns true if the client satisfies this condition\n+     * on Dynamic Registration Endpoint access for creating client.\n+     *\n+     * @param context\n+     * @param authType\n+     * @return true if the client satisfies this condition.\n+     */\n+    default boolean isSatisfiedOnDynamicClientRegister(", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM1ODAxNw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432358017", "bodyText": "Yes, it is really good way. I'll implement default boolean isSatisfiedOnClientUpdate(ClientUpdateContext context)\ninstead of current several method on each events.", "author": "tnorimat", "createdAt": "2020-05-29T09:13:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5NjQzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5NzM0Ng==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r430897346", "bodyText": "doPolicyOperation", "author": "stianst", "createdAt": "2020-05-27T07:00:13Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+public class ClientPolicyManager {\n+\n+    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);\n+\n+    // Dynamic Client Registration\n+    // delegate executions to the existing ClientRegistrationPolicyManager\n+\n+    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for creating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);\n+    }\n+\n+    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for updating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);\n+    }\n+\n+    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for creating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)\n+        );\n+    }\n+\n+    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for updating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)\n+        );\n+    }\n+\n+    public static void triggerOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Authorization Endpoint access for authorization request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRequest(\n+            MultivaluedMap<String, String> params,\n+            OAuth2CodeParser.ParseResult parseResult,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRefresh(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token refresh\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRevoke(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Revocation Endpoint access for token revoke\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenIntrospect(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Introspenction Endpoint access for token introspect\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)\n+        );\n+    }\n+\n+    public static void triggerOnUserInfoRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on UserInfo Endpoint access for userinfo request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)\n+        );\n+    }\n+\n+    public static void triggerOnLogoutRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Logout Endpoint access for logout request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)\n+        );\n+    }\n+\n+    private static void doPolicyOperaion(KeycloakSession session, ", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIwMTA5OQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432201099", "bodyText": "Yes, it's a typo. I'll rename as doPolicyOperation.", "author": "tnorimat", "createdAt": "2020-05-29T00:53:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDg5NzM0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwNjk1MQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431606951", "bodyText": "Would it not be better if this was an enum?", "author": "stianst", "createdAt": "2020-05-28T06:24:56Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyEvent.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+public interface ClientPolicyEvent {", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIwMDYwNA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432200604", "bodyText": "Yes, I'll implement ClientPolicyEvent as an enum.", "author": "tnorimat", "createdAt": "2020-05-29T00:51:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwNjk1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwODAxMA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431608010", "bodyText": "I wonder if it would be better if a ClientPolicyProvider returns lists of ClientPolicyCondition/ClientPolicyExecutor instead of ids. That would allow creating ClientPolicyProviders that don't use ComponentModel, but just hard-codes some conditions/executors instead.", "author": "stianst", "createdAt": "2020-05-28T06:27:45Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyProvider.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+\n+import org.keycloak.provider.Provider;\n+\n+/**\n+ * Provides Client Policy which accommodates several Conditions and Executors.\n+ */\n+public interface ClientPolicyProvider extends Provider {\n+\n+    /**\n+     * returns the list of condition's id which this provider accommodates.\n+     *\n+     * @return list of condition's id\n+     */\n+    List<String> getConditionIds();", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwMDMwNw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432300307", "bodyText": "I see, I'll revise this codes to return the lists of ClientPolicyCondition/ClientPolicyExecutor instead of its ids.", "author": "tnorimat", "createdAt": "2020-05-29T07:21:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwODAxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwODkzNA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431608934", "bodyText": "Why is this here? I can't see it being called anywhere.", "author": "stianst", "createdAt": "2020-05-28T06:30:03Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyProviderFactory.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+\n+import org.keycloak.component.ComponentFactory;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.provider.ProviderConfigProperty;\n+\n+public interface ClientPolicyProviderFactory extends ComponentFactory<ClientPolicyProvider, ClientPolicyProvider> {\n+\n+    List<ProviderConfigProperty> getConfigProperties(KeycloakSession session);", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNDcxNg==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432304716", "bodyText": "Yes, I'll remove this List<ProviderConfigProperty> getConfigProperties(KeycloakSession session) method.", "author": "tnorimat", "createdAt": "2020-05-29T07:30:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYwODkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMTE2Ng==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431611166", "bodyText": "Doesn't this mean that if a ClientPolicyCondition throws an exception it is ignored and only a trace level logging is shown? An exception in a ClientPolicyCondition/Executor should result in an error handling the request I'd say.", "author": "stianst", "createdAt": "2020-05-28T06:35:48Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+public class ClientPolicyManager {\n+\n+    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);\n+\n+    // Dynamic Client Registration\n+    // delegate executions to the existing ClientRegistrationPolicyManager\n+\n+    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for creating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);\n+    }\n+\n+    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for updating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);\n+    }\n+\n+    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for creating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)\n+        );\n+    }\n+\n+    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for updating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)\n+        );\n+    }\n+\n+    public static void triggerOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Authorization Endpoint access for authorization request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRequest(\n+            MultivaluedMap<String, String> params,\n+            OAuth2CodeParser.ParseResult parseResult,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRefresh(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token refresh\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRevoke(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Revocation Endpoint access for token revoke\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenIntrospect(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Introspenction Endpoint access for token introspect\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)\n+        );\n+    }\n+\n+    public static void triggerOnUserInfoRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on UserInfo Endpoint access for userinfo request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)\n+        );\n+    }\n+\n+    public static void triggerOnLogoutRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Logout Endpoint access for logout request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)\n+        );\n+    }\n+\n+    private static void doPolicyOperaion(KeycloakSession session, \n+            ClientConditionFilter conditionFilter, ClientConditionOperation condition,\n+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {\n+        RealmModel realm = session.getContext().getRealm();\n+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());\n+        for (ComponentModel policyModel : policyModels) {\n+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);\n+            ClientPolicyLogger.log(logger, \"Policy Name = \" + policyModel.getName());\n+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;\n+            execute(policy, session, executorFilter, executor);\n+        }\n+    }\n+\n+    private static boolean isSatisfied(\n+            ClientPolicyProvider policy,\n+            KeycloakSession session,\n+            ClientConditionFilter filter,\n+            ClientConditionOperation op) throws ClientPolicyException {\n+\n+        List<String> conditionIds = policy.getConditionIds();\n+\n+        if (conditionIds == null || conditionIds.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition registered.\");\n+            return false;\n+        }\n+\n+        List<ClientPolicyCondition> conditions = conditionIds.stream()\n+                .map(s -> {\n+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);\n+                        ClientPolicyLogger.log(logger, \"Condition ID = \" + s);\n+                        ClientPolicyLogger.log(logger, \"Condition Name = \" + conditionModel.getName());\n+                        ClientPolicyLogger.log(logger, \"Condition Provider ID = \" + conditionModel.getProviderId());\n+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);\n+                    })\n+                .filter(t -> {\n+                        try {return filter.run(t);} catch (ClientPolicyException e) {\n+                            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. \" + e);", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIyNjUyNQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432226525", "bodyText": "I've reviewed ClientConditionFilter interface and its implementation classes and found that these do not throw ClientPolicyException. Therefore, I'll modify ClientConditionFilter  and remove this try-catch sentences. WDYT?", "author": "tnorimat", "createdAt": "2020-05-29T02:43:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMTE2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM2Njk4OQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432366989", "bodyText": "Sounds good", "author": "stianst", "createdAt": "2020-05-29T09:30:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMTE2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMzE0NQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431613145", "bodyText": "If no conditions are evaluated it should return true right? Otherwise no matches would return in not accepting the request.", "author": "stianst", "createdAt": "2020-05-28T06:41:01Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+public class ClientPolicyManager {\n+\n+    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);\n+\n+    // Dynamic Client Registration\n+    // delegate executions to the existing ClientRegistrationPolicyManager\n+\n+    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for creating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);\n+    }\n+\n+    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for updating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);\n+    }\n+\n+    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for creating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)\n+        );\n+    }\n+\n+    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for updating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)\n+        );\n+    }\n+\n+    public static void triggerOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Authorization Endpoint access for authorization request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRequest(\n+            MultivaluedMap<String, String> params,\n+            OAuth2CodeParser.ParseResult parseResult,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRefresh(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token refresh\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRevoke(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Revocation Endpoint access for token revoke\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenIntrospect(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Introspenction Endpoint access for token introspect\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)\n+        );\n+    }\n+\n+    public static void triggerOnUserInfoRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on UserInfo Endpoint access for userinfo request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)\n+        );\n+    }\n+\n+    public static void triggerOnLogoutRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Logout Endpoint access for logout request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)\n+        );\n+    }\n+\n+    private static void doPolicyOperaion(KeycloakSession session, \n+            ClientConditionFilter conditionFilter, ClientConditionOperation condition,\n+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {\n+        RealmModel realm = session.getContext().getRealm();\n+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());\n+        for (ComponentModel policyModel : policyModels) {\n+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);\n+            ClientPolicyLogger.log(logger, \"Policy Name = \" + policyModel.getName());\n+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;\n+            execute(policy, session, executorFilter, executor);\n+        }\n+    }\n+\n+    private static boolean isSatisfied(\n+            ClientPolicyProvider policy,\n+            KeycloakSession session,\n+            ClientConditionFilter filter,\n+            ClientConditionOperation op) throws ClientPolicyException {\n+\n+        List<String> conditionIds = policy.getConditionIds();\n+\n+        if (conditionIds == null || conditionIds.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition registered.\");\n+            return false;\n+        }\n+\n+        List<ClientPolicyCondition> conditions = conditionIds.stream()\n+                .map(s -> {\n+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);\n+                        ClientPolicyLogger.log(logger, \"Condition ID = \" + s);\n+                        ClientPolicyLogger.log(logger, \"Condition Name = \" + conditionModel.getName());\n+                        ClientPolicyLogger.log(logger, \"Condition Provider ID = \" + conditionModel.getProviderId());\n+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);\n+                    })\n+                .filter(t -> {\n+                        try {return filter.run(t);} catch (ClientPolicyException e) {\n+                            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. \" + e);\n+                            return false;\n+                        }\n+                }).collect(Collectors.toList());\n+\n+        if (conditions == null || conditions.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition evalutated.\");", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIzNDk0OA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432234948", "bodyText": "I think it returns false. The reason is as follows :\n\n\nIMO, If it returns false, executors are not executed but the request itself from a client is accepted and processed the same as the current keycloak. Merely executors are not executed. Conditions only detetermines whether executors are executed.\n\n\nThere is the chance that no conditions are evaluated. (e.g. a policy including one condition about cilent role. It is evalutated in the event of Authz Request, Token Request, but not evaluated in the event of Dynamic Client Registration.)\n\n\nWDYT?", "author": "tnorimat", "createdAt": "2020-05-29T03:21:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMzE0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM2ODAwMg==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432368002", "bodyText": "Yup, you are right it should return false.", "author": "stianst", "createdAt": "2020-05-29T09:32:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMzE0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMzczOQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431613739", "bodyText": "Doesn't this mean an exception always results in false? That's okay, but there's no feedback to the user other than the request failed.", "author": "stianst", "createdAt": "2020-05-28T06:42:30Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+public class ClientPolicyManager {\n+\n+    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);\n+\n+    // Dynamic Client Registration\n+    // delegate executions to the existing ClientRegistrationPolicyManager\n+\n+    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for creating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);\n+    }\n+\n+    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for updating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);\n+    }\n+\n+    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for creating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)\n+        );\n+    }\n+\n+    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for updating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)\n+        );\n+    }\n+\n+    public static void triggerOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Authorization Endpoint access for authorization request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRequest(\n+            MultivaluedMap<String, String> params,\n+            OAuth2CodeParser.ParseResult parseResult,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRefresh(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token refresh\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRevoke(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Revocation Endpoint access for token revoke\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenIntrospect(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Introspenction Endpoint access for token introspect\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)\n+        );\n+    }\n+\n+    public static void triggerOnUserInfoRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on UserInfo Endpoint access for userinfo request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)\n+        );\n+    }\n+\n+    public static void triggerOnLogoutRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Logout Endpoint access for logout request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)\n+        );\n+    }\n+\n+    private static void doPolicyOperaion(KeycloakSession session, \n+            ClientConditionFilter conditionFilter, ClientConditionOperation condition,\n+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {\n+        RealmModel realm = session.getContext().getRealm();\n+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());\n+        for (ComponentModel policyModel : policyModels) {\n+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);\n+            ClientPolicyLogger.log(logger, \"Policy Name = \" + policyModel.getName());\n+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;\n+            execute(policy, session, executorFilter, executor);\n+        }\n+    }\n+\n+    private static boolean isSatisfied(\n+            ClientPolicyProvider policy,\n+            KeycloakSession session,\n+            ClientConditionFilter filter,\n+            ClientConditionOperation op) throws ClientPolicyException {\n+\n+        List<String> conditionIds = policy.getConditionIds();\n+\n+        if (conditionIds == null || conditionIds.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition registered.\");\n+            return false;\n+        }\n+\n+        List<ClientPolicyCondition> conditions = conditionIds.stream()\n+                .map(s -> {\n+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);\n+                        ClientPolicyLogger.log(logger, \"Condition ID = \" + s);\n+                        ClientPolicyLogger.log(logger, \"Condition Name = \" + conditionModel.getName());\n+                        ClientPolicyLogger.log(logger, \"Condition Provider ID = \" + conditionModel.getProviderId());\n+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);\n+                    })\n+                .filter(t -> {\n+                        try {return filter.run(t);} catch (ClientPolicyException e) {\n+                            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. \" + e);\n+                            return false;\n+                        }\n+                }).collect(Collectors.toList());\n+\n+        if (conditions == null || conditions.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition evalutated.\");\n+            return false;\n+        }\n+\n+        if (conditions.stream().anyMatch(t -> {\n+                    try {return !op.run(t);} catch (ClientPolicyException e) {\n+                        ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. \" + e);", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0MjM1NQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432242355", "bodyText": "Yes, always results in false. I think that this exception is catched by the source of event (e.g. AuthrozationEndpoint.process()) and the contents of this exeception can be propagated to the user as the error response.", "author": "tnorimat", "createdAt": "2020-05-29T03:56:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMzczOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM2OTIxMg==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432369212", "bodyText": "But, the exception is caught/swallowed here and false is returned, so how would AuthrozationEndpoint.process() catch the contents of the exception?", "author": "stianst", "createdAt": "2020-05-29T09:34:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMzczOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgwODAwMw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432808003", "bodyText": "Sorry, it's my misunderstanding. Indeed, it merely returns false.\nSo, in catch clause I'd like to throw this ClientPolicyException to the caller the method (e.g. AuthrozationEndpoint.process()). WDYT?", "author": "tnorimat", "createdAt": "2020-05-30T04:08:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxMzczOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNDEzOA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431614138", "bodyText": "There's no feedback to the user why this request has failed, and information is only available in trace level logging, which may not be enabled and would not always be available to application developers as often they wont have access to logs.", "author": "stianst", "createdAt": "2020-05-28T06:43:26Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+public class ClientPolicyManager {\n+\n+    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);\n+\n+    // Dynamic Client Registration\n+    // delegate executions to the existing ClientRegistrationPolicyManager\n+\n+    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for creating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);\n+    }\n+\n+    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for updating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);\n+    }\n+\n+    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for creating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)\n+        );\n+    }\n+\n+    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for updating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)\n+        );\n+    }\n+\n+    public static void triggerOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Authorization Endpoint access for authorization request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRequest(\n+            MultivaluedMap<String, String> params,\n+            OAuth2CodeParser.ParseResult parseResult,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRefresh(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token refresh\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRevoke(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Revocation Endpoint access for token revoke\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenIntrospect(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Introspenction Endpoint access for token introspect\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)\n+        );\n+    }\n+\n+    public static void triggerOnUserInfoRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on UserInfo Endpoint access for userinfo request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)\n+        );\n+    }\n+\n+    public static void triggerOnLogoutRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Logout Endpoint access for logout request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)\n+        );\n+    }\n+\n+    private static void doPolicyOperaion(KeycloakSession session, \n+            ClientConditionFilter conditionFilter, ClientConditionOperation condition,\n+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {\n+        RealmModel realm = session.getContext().getRealm();\n+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());\n+        for (ComponentModel policyModel : policyModels) {\n+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);\n+            ClientPolicyLogger.log(logger, \"Policy Name = \" + policyModel.getName());\n+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;\n+            execute(policy, session, executorFilter, executor);\n+        }\n+    }\n+\n+    private static boolean isSatisfied(\n+            ClientPolicyProvider policy,\n+            KeycloakSession session,\n+            ClientConditionFilter filter,\n+            ClientConditionOperation op) throws ClientPolicyException {\n+\n+        List<String> conditionIds = policy.getConditionIds();\n+\n+        if (conditionIds == null || conditionIds.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition registered.\");\n+            return false;\n+        }\n+\n+        List<ClientPolicyCondition> conditions = conditionIds.stream()\n+                .map(s -> {\n+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);\n+                        ClientPolicyLogger.log(logger, \"Condition ID = \" + s);\n+                        ClientPolicyLogger.log(logger, \"Condition Name = \" + conditionModel.getName());\n+                        ClientPolicyLogger.log(logger, \"Condition Provider ID = \" + conditionModel.getProviderId());\n+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);\n+                    })\n+                .filter(t -> {\n+                        try {return filter.run(t);} catch (ClientPolicyException e) {\n+                            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. \" + e);\n+                            return false;\n+                        }\n+                }).collect(Collectors.toList());\n+\n+        if (conditions == null || conditions.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition evalutated.\");\n+            return false;\n+        }\n+\n+        if (conditions.stream().anyMatch(t -> {\n+                    try {return !op.run(t);} catch (ClientPolicyException e) {\n+                        ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. \" + e);\n+                        return false;\n+                    }\n+            })) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. Not all conditones satisfied.\");\n+            return false;", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI0NzAyOQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432247029", "bodyText": "My intention is that the evaluation of conditions only detetermines whether executors are executed and the request itself is accepted and processed regardless of the result of the evaluation of conditions.", "author": "tnorimat", "createdAt": "2020-05-29T04:17:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNDEzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM2OTY5Nw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432369697", "bodyText": "Yes, of course you are correct here. This message does not need to be returned to the user.", "author": "stianst", "createdAt": "2020-05-29T09:35:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNDEzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNDY3NQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431614675", "bodyText": "This should be a single log statement, not 3", "author": "stianst", "createdAt": "2020-05-28T06:44:42Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+public class ClientPolicyManager {\n+\n+    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);\n+\n+    // Dynamic Client Registration\n+    // delegate executions to the existing ClientRegistrationPolicyManager\n+\n+    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for creating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);\n+    }\n+\n+    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for updating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);\n+    }\n+\n+    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for creating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)\n+        );\n+    }\n+\n+    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for updating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)\n+        );\n+    }\n+\n+    public static void triggerOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Authorization Endpoint access for authorization request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRequest(\n+            MultivaluedMap<String, String> params,\n+            OAuth2CodeParser.ParseResult parseResult,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRefresh(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token refresh\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRevoke(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Revocation Endpoint access for token revoke\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenIntrospect(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Introspenction Endpoint access for token introspect\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)\n+        );\n+    }\n+\n+    public static void triggerOnUserInfoRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on UserInfo Endpoint access for userinfo request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)\n+        );\n+    }\n+\n+    public static void triggerOnLogoutRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Logout Endpoint access for logout request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)\n+        );\n+    }\n+\n+    private static void doPolicyOperaion(KeycloakSession session, \n+            ClientConditionFilter conditionFilter, ClientConditionOperation condition,\n+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {\n+        RealmModel realm = session.getContext().getRealm();\n+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());\n+        for (ComponentModel policyModel : policyModels) {\n+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);\n+            ClientPolicyLogger.log(logger, \"Policy Name = \" + policyModel.getName());\n+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;\n+            execute(policy, session, executorFilter, executor);\n+        }\n+    }\n+\n+    private static boolean isSatisfied(\n+            ClientPolicyProvider policy,\n+            KeycloakSession session,\n+            ClientConditionFilter filter,\n+            ClientConditionOperation op) throws ClientPolicyException {\n+\n+        List<String> conditionIds = policy.getConditionIds();\n+\n+        if (conditionIds == null || conditionIds.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition registered.\");\n+            return false;\n+        }\n+\n+        List<ClientPolicyCondition> conditions = conditionIds.stream()\n+                .map(s -> {\n+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);\n+                        ClientPolicyLogger.log(logger, \"Condition ID = \" + s);\n+                        ClientPolicyLogger.log(logger, \"Condition Name = \" + conditionModel.getName());\n+                        ClientPolicyLogger.log(logger, \"Condition Provider ID = \" + conditionModel.getProviderId());", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIwMTMxMA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432201310", "bodyText": "I see, I'll implement a single log statement.", "author": "tnorimat", "createdAt": "2020-05-29T00:54:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNDY3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNDc1Mg==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431614752", "bodyText": "This should be a single log statement, not 3", "author": "stianst", "createdAt": "2020-05-28T06:44:52Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+public class ClientPolicyManager {\n+\n+    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);\n+\n+    // Dynamic Client Registration\n+    // delegate executions to the existing ClientRegistrationPolicyManager\n+\n+    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for creating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);\n+    }\n+\n+    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for updating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);\n+    }\n+\n+    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for creating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)\n+        );\n+    }\n+\n+    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for updating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)\n+        );\n+    }\n+\n+    public static void triggerOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Authorization Endpoint access for authorization request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRequest(\n+            MultivaluedMap<String, String> params,\n+            OAuth2CodeParser.ParseResult parseResult,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRefresh(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token refresh\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRevoke(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Revocation Endpoint access for token revoke\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenIntrospect(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Introspenction Endpoint access for token introspect\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)\n+        );\n+    }\n+\n+    public static void triggerOnUserInfoRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on UserInfo Endpoint access for userinfo request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)\n+        );\n+    }\n+\n+    public static void triggerOnLogoutRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Logout Endpoint access for logout request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)\n+        );\n+    }\n+\n+    private static void doPolicyOperaion(KeycloakSession session, \n+            ClientConditionFilter conditionFilter, ClientConditionOperation condition,\n+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {\n+        RealmModel realm = session.getContext().getRealm();\n+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());\n+        for (ComponentModel policyModel : policyModels) {\n+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);\n+            ClientPolicyLogger.log(logger, \"Policy Name = \" + policyModel.getName());\n+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;\n+            execute(policy, session, executorFilter, executor);\n+        }\n+    }\n+\n+    private static boolean isSatisfied(\n+            ClientPolicyProvider policy,\n+            KeycloakSession session,\n+            ClientConditionFilter filter,\n+            ClientConditionOperation op) throws ClientPolicyException {\n+\n+        List<String> conditionIds = policy.getConditionIds();\n+\n+        if (conditionIds == null || conditionIds.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition registered.\");\n+            return false;\n+        }\n+\n+        List<ClientPolicyCondition> conditions = conditionIds.stream()\n+                .map(s -> {\n+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);\n+                        ClientPolicyLogger.log(logger, \"Condition ID = \" + s);\n+                        ClientPolicyLogger.log(logger, \"Condition Name = \" + conditionModel.getName());\n+                        ClientPolicyLogger.log(logger, \"Condition Provider ID = \" + conditionModel.getProviderId());\n+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);\n+                    })\n+                .filter(t -> {\n+                        try {return filter.run(t);} catch (ClientPolicyException e) {\n+                            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. \" + e);\n+                            return false;\n+                        }\n+                }).collect(Collectors.toList());\n+\n+        if (conditions == null || conditions.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition evalutated.\");\n+            return false;\n+        }\n+\n+        if (conditions.stream().anyMatch(t -> {\n+                    try {return !op.run(t);} catch (ClientPolicyException e) {\n+                        ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. \" + e);\n+                        return false;\n+                    }\n+            })) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. Not all conditones satisfied.\");\n+            return false;\n+        }\n+\n+        ClientPolicyLogger.log(logger, \"POSITIVE :: This policy is applied.\");\n+        return true;\n+ \n+    }\n+\n+    private static void execute(\n+            ClientPolicyProvider policy,\n+            KeycloakSession session,\n+            ClientExecutorFilter filter,\n+            ClientExecutorOperation op) throws ClientPolicyException {\n+\n+        List<String> executorIds = policy.getExecutorIds();\n+\n+        if (executorIds == null || executorIds.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This executor is not executed. No executor registered.\");\n+            return;\n+        }\n+\n+        List<ClientPolicyExecutor> executors = executorIds.stream()\n+                .map(s -> {\n+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);\n+                        ClientPolicyLogger.log(logger, \"Executor ID = \" + s);\n+                        ClientPolicyLogger.log(logger, \"Executor Name = \" + conditionModel.getName());\n+                        ClientPolicyLogger.log(logger, \"Executor Provider ID = \" + conditionModel.getProviderId());", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjIwNzQ2Mg==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432207462", "bodyText": "I see, I'll implement a single log statement.", "author": "tnorimat", "createdAt": "2020-05-29T01:21:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNDc1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNTE1NQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431615155", "bodyText": "This swallows exceptions, with only information in trace level logging. An exception should probably result in an error to handle request (500).", "author": "stianst", "createdAt": "2020-05-28T06:45:49Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+public class ClientPolicyManager {\n+\n+    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);\n+\n+    // Dynamic Client Registration\n+    // delegate executions to the existing ClientRegistrationPolicyManager\n+\n+    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for creating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);\n+    }\n+\n+    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for updating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);\n+    }\n+\n+    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for creating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)\n+        );\n+    }\n+\n+    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for updating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)\n+        );\n+    }\n+\n+    public static void triggerOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Authorization Endpoint access for authorization request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRequest(\n+            MultivaluedMap<String, String> params,\n+            OAuth2CodeParser.ParseResult parseResult,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRefresh(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token refresh\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRevoke(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Revocation Endpoint access for token revoke\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenIntrospect(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Introspenction Endpoint access for token introspect\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)\n+        );\n+    }\n+\n+    public static void triggerOnUserInfoRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on UserInfo Endpoint access for userinfo request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)\n+        );\n+    }\n+\n+    public static void triggerOnLogoutRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Logout Endpoint access for logout request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)\n+        );\n+    }\n+\n+    private static void doPolicyOperaion(KeycloakSession session, \n+            ClientConditionFilter conditionFilter, ClientConditionOperation condition,\n+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {\n+        RealmModel realm = session.getContext().getRealm();\n+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());\n+        for (ComponentModel policyModel : policyModels) {\n+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);\n+            ClientPolicyLogger.log(logger, \"Policy Name = \" + policyModel.getName());\n+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;\n+            execute(policy, session, executorFilter, executor);\n+        }\n+    }\n+\n+    private static boolean isSatisfied(\n+            ClientPolicyProvider policy,\n+            KeycloakSession session,\n+            ClientConditionFilter filter,\n+            ClientConditionOperation op) throws ClientPolicyException {\n+\n+        List<String> conditionIds = policy.getConditionIds();\n+\n+        if (conditionIds == null || conditionIds.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition registered.\");\n+            return false;\n+        }\n+\n+        List<ClientPolicyCondition> conditions = conditionIds.stream()\n+                .map(s -> {\n+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);\n+                        ClientPolicyLogger.log(logger, \"Condition ID = \" + s);\n+                        ClientPolicyLogger.log(logger, \"Condition Name = \" + conditionModel.getName());\n+                        ClientPolicyLogger.log(logger, \"Condition Provider ID = \" + conditionModel.getProviderId());\n+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);\n+                    })\n+                .filter(t -> {\n+                        try {return filter.run(t);} catch (ClientPolicyException e) {\n+                            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. \" + e);\n+                            return false;\n+                        }\n+                }).collect(Collectors.toList());\n+\n+        if (conditions == null || conditions.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition evalutated.\");\n+            return false;\n+        }\n+\n+        if (conditions.stream().anyMatch(t -> {\n+                    try {return !op.run(t);} catch (ClientPolicyException e) {\n+                        ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. \" + e);\n+                        return false;\n+                    }\n+            })) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. Not all conditones satisfied.\");\n+            return false;\n+        }\n+\n+        ClientPolicyLogger.log(logger, \"POSITIVE :: This policy is applied.\");\n+        return true;\n+ \n+    }\n+\n+    private static void execute(\n+            ClientPolicyProvider policy,\n+            KeycloakSession session,\n+            ClientExecutorFilter filter,\n+            ClientExecutorOperation op) throws ClientPolicyException {\n+\n+        List<String> executorIds = policy.getExecutorIds();\n+\n+        if (executorIds == null || executorIds.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This executor is not executed. No executor registered.\");\n+            return;\n+        }\n+\n+        List<ClientPolicyExecutor> executors = executorIds.stream()\n+                .map(s -> {\n+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);\n+                        ClientPolicyLogger.log(logger, \"Executor ID = \" + s);\n+                        ClientPolicyLogger.log(logger, \"Executor Name = \" + conditionModel.getName());\n+                        ClientPolicyLogger.log(logger, \"Executor Provider ID = \" + conditionModel.getProviderId());\n+                        return session.getProvider(ClientPolicyExecutor.class, conditionModel);\n+                    })\n+                .filter(t -> {\n+                        try {return filter.run(t);} catch (ClientPolicyException e) {\n+                            ClientPolicyLogger.log(logger, \"NEGATIVE :: This executor is not executed. \" + e);", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI1MDAzMQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432250031", "bodyText": "I've reviewed ClientExecutorFilter interface and its implementation classes and found that these do not throw ClientPolicyException. Therefore, I'll modify ClientExecutorFilter and remove this try-catch sentences. WDYT?", "author": "tnorimat", "createdAt": "2020-05-29T04:31:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNTE1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM2OTg0Mw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432369843", "bodyText": "+1", "author": "stianst", "createdAt": "2020-05-29T09:35:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNTE1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNTg4Ng==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431615886", "bodyText": "Using exceptions when the executor is not happy is fine, but in that case it should be an exception that doesn't fill the stack trace, as otherwise you have stack traces being loaded during \"normal behaviour\", which doesn't come for free.", "author": "stianst", "createdAt": "2020-05-28T06:47:50Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyManager.java", "diffHunk": "@@ -0,0 +1,303 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyCondition;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyException;\n+import org.keycloak.services.clientregistration.policy.ClientRegistrationPolicyManager;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+public class ClientPolicyManager {\n+\n+    private static final Logger logger = Logger.getLogger(ClientPolicyManager.class);\n+\n+    // Dynamic Client Registration\n+    // delegate executions to the existing ClientRegistrationPolicyManager\n+\n+    public static void triggerBeforeRegister(ClientRegistrationContext context, RegistrationAuth authType) throws ClientRegistrationPolicyException, ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for creating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientRegister(context, authType),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientRegister(context, authType)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeRegister(context, authType);\n+    }\n+\n+    public static void triggerBeforeUpdate(ClientRegistrationContext context, RegistrationAuth authType, ClientModel client) throws ClientRegistrationPolicyException, ClientPolicyException  {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Dynamic Registration Endpoint access for updating client\");\n+        doPolicyOperaion(\n+                context.getSession(),\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnDynamicClientUpdate(context, authType, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.DYNAMIC_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnDynamicClientUpdate(context, authType, client)\n+        );\n+        ClientRegistrationPolicyManager.triggerBeforeUpdate(context, authType, client);\n+    }\n+\n+    public static void triggerBeforeRegisterByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for creating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientRegister(rep, admin),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_REGISTER),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientRegister(rep, admin)\n+        );\n+    }\n+\n+    public static void triggerBeforeUpdateByAdmin(KeycloakSession session, ClientRepresentation rep, AdminAuth admin, ClientModel client) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Admin REST API Registration access for updating client\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnClientUpdate(rep, admin, client),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.ADMIN_UPDATE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnClientUpdate(rep, admin, client)\n+        );\n+    }\n+\n+    public static void triggerOnAuthorizationRequest(\n+            OIDCResponseType parsedResponseType,\n+            AuthorizationEndpointRequest request,\n+            String redirectUri,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Authorization Endpoint access for authorization request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnAuthorizationRequest(parsedResponseType, request, redirectUri),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.AUTHORIZATION_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnAuthorizationRequest(parsedResponseType, request, redirectUri)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRequest(\n+            MultivaluedMap<String, String> params,\n+            OAuth2CodeParser.ParseResult parseResult,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRequest(params, parseResult),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRequest(params, parseResult)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRefresh(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Endpoint access for token refresh\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRefresh(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REFRESH),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRefresh(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenRevoke(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Revocation Endpoint access for token revoke\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenRevoke(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_REVOKE),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenRevoke(params)\n+        );\n+    }\n+\n+    public static void triggerOnTokenIntrospect(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Token Introspenction Endpoint access for token introspect\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnTokenIntrospect(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.TOKEN_INTROSPECT),\n+                (ClientPolicyExecutor executor) -> executor.executeOnTokenIntrospect(params)\n+        );\n+    }\n+\n+    public static void triggerOnUserInfoRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on UserInfo Endpoint access for userinfo request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnUserInfoRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.USERINFO_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnUserInfoRequest(params)\n+        );\n+    }\n+\n+    public static void triggerOnLogoutRequest(\n+            MultivaluedMap<String, String> params,\n+            KeycloakSession session) throws ClientPolicyException {\n+        ClientPolicyLogger.log(logger, \"Client Policy Operation : on Logout Endpoint access for logout request\");\n+        doPolicyOperaion(\n+                session,\n+                (ClientPolicyCondition condition) -> condition.isEvaluatedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyCondition condition) -> condition.isSatisfiedOnLogoutRequest(params),\n+                (ClientPolicyExecutor executor) -> executor.isExecutedOnEvent(ClientPolicyEvent.LOGOUT_REQUEST),\n+                (ClientPolicyExecutor executor) -> executor.executeOnLogoutRequest(params)\n+        );\n+    }\n+\n+    private static void doPolicyOperaion(KeycloakSession session, \n+            ClientConditionFilter conditionFilter, ClientConditionOperation condition,\n+            ClientExecutorFilter executorFilter, ClientExecutorOperation executor) throws ClientPolicyException {\n+        RealmModel realm = session.getContext().getRealm();\n+        List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());\n+        for (ComponentModel policyModel : policyModels) {\n+            ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);\n+            ClientPolicyLogger.log(logger, \"Policy Name = \" + policyModel.getName());\n+            if (!isSatisfied(policy, session, conditionFilter, condition)) continue;\n+            execute(policy, session, executorFilter, executor);\n+        }\n+    }\n+\n+    private static boolean isSatisfied(\n+            ClientPolicyProvider policy,\n+            KeycloakSession session,\n+            ClientConditionFilter filter,\n+            ClientConditionOperation op) throws ClientPolicyException {\n+\n+        List<String> conditionIds = policy.getConditionIds();\n+\n+        if (conditionIds == null || conditionIds.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition registered.\");\n+            return false;\n+        }\n+\n+        List<ClientPolicyCondition> conditions = conditionIds.stream()\n+                .map(s -> {\n+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);\n+                        ClientPolicyLogger.log(logger, \"Condition ID = \" + s);\n+                        ClientPolicyLogger.log(logger, \"Condition Name = \" + conditionModel.getName());\n+                        ClientPolicyLogger.log(logger, \"Condition Provider ID = \" + conditionModel.getProviderId());\n+                        return session.getProvider(ClientPolicyCondition.class, conditionModel);\n+                    })\n+                .filter(t -> {\n+                        try {return filter.run(t);} catch (ClientPolicyException e) {\n+                            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. \" + e);\n+                            return false;\n+                        }\n+                }).collect(Collectors.toList());\n+\n+        if (conditions == null || conditions.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition evalutated.\");\n+            return false;\n+        }\n+\n+        if (conditions.stream().anyMatch(t -> {\n+                    try {return !op.run(t);} catch (ClientPolicyException e) {\n+                        ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. \" + e);\n+                        return false;\n+                    }\n+            })) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. Not all conditones satisfied.\");\n+            return false;\n+        }\n+\n+        ClientPolicyLogger.log(logger, \"POSITIVE :: This policy is applied.\");\n+        return true;\n+ \n+    }\n+\n+    private static void execute(\n+            ClientPolicyProvider policy,\n+            KeycloakSession session,\n+            ClientExecutorFilter filter,\n+            ClientExecutorOperation op) throws ClientPolicyException {\n+\n+        List<String> executorIds = policy.getExecutorIds();\n+\n+        if (executorIds == null || executorIds.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This executor is not executed. No executor registered.\");\n+            return;\n+        }\n+\n+        List<ClientPolicyExecutor> executors = executorIds.stream()\n+                .map(s -> {\n+                        ComponentModel conditionModel = session.getContext().getRealm().getComponent(s);\n+                        ClientPolicyLogger.log(logger, \"Executor ID = \" + s);\n+                        ClientPolicyLogger.log(logger, \"Executor Name = \" + conditionModel.getName());\n+                        ClientPolicyLogger.log(logger, \"Executor Provider ID = \" + conditionModel.getProviderId());\n+                        return session.getProvider(ClientPolicyExecutor.class, conditionModel);\n+                    })\n+                .filter(t -> {\n+                        try {return filter.run(t);} catch (ClientPolicyException e) {\n+                            ClientPolicyLogger.log(logger, \"NEGATIVE :: This executor is not executed. \" + e);\n+                            return false;\n+                        }\n+                }).collect(Collectors.toList());\n+\n+        if (executors == null || executors.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This executor is not executed. No executor executable.\");\n+            return;\n+        }\n+\n+        for (ClientPolicyExecutor executor : executors) op.run(executor);", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjI5ODE0NQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432298145", "bodyText": "Yes, ClientPolicyException thrown from ClientPolicyExecutor is used to convey the event where an executor does not do what it intends to do. Therefore, as you said, its stacktrace for debugging is not needed. Therefore, I'll get rid of the stack trace of ClientPolicyException thrown from ClientPolicyExecutor . Is that right?", "author": "tnorimat", "createdAt": "2020-05-29T07:16:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNTg4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjM2OTk3MA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432369970", "bodyText": "+1", "author": "stianst", "createdAt": "2020-05-29T09:35:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNTg4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNzQwMg==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431617402", "bodyText": "Do we need the split between isEvaulated on and the isSatisfied? The default implementation should just return true that it is satisfied, which means you don't need a separate method to check if it should be called or not.", "author": "stianst", "createdAt": "2020-05-28T06:51:26Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/condition/ClientPolicyCondition.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.condition;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.provider.Provider;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+/**\n+ * This condition determines to which client a {@link ClientPolicyProvider} is adopted.\n+ * The condition can be evaluated on the events defined in {@link ClientPolicyEvent}.\n+ * It is sufficient for the implementer of this condition to implement methods in which they are interested\n+ * and {@link isEvaluatedOnEvent} method.\n+ */\n+public interface ClientPolicyCondition extends Provider {\n+\n+    @Override\n+    default void close() {}\n+\n+    /**\n+     * returns true if this condition is evaluated to check\n+     * whether the client satisfies this condition on the event specified as a parameter.\n+     * A condition can be implemented to be evaluated on some events while not on others.\n+     * On the event specified as the parameter, this condition is skipped if this method returns false.\n+     *\n+     * @param event defined in {@link ClientPolicyEvent}\n+     * @return true if this condition is evaluated on the event.\n+     */\n+    default boolean isEvaluatedOnEvent(String event) {return true;}", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQyNTM0OQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432425349", "bodyText": "I think you said that isEvaluatedOnEvent() and isSatisfiedOn...() are integrated into one method. The reason why I split into two method is as follows :\n\n\nThere are several events defined by ClientPolicyEvent and a condition is not needed to be evaluated on all events.  (e.g. a policy including one condition about client role. It is evaluated in the event of Authz Request, Token Request, but not evaluated in the event of Dynamic Client Registration.)\n\n\nConsidering the point just above, if we try to evaluate the condition, the following three results are possible\n\n\n\n\nThis condition is not needed to be evaluated.\n\n\nThis condition is needed to be evaluated. Therefore, keycloak tries to evaluate this condition to check whether the client who sent the request satisfies this condition and it indeed satisfies.\n\n\nThis condition is needed to be evaluated. Therefore, keycloak tries to evaluate this condition to check whether the client who sent the request satisfies this condition and it does NOT satisfies.\n\n\nwhich means three values are returned if we  integrate isEvaluatedOnEvent() and isSatisfiedOn...() onto one method.\nAt first, I had tried to achieve one method but found the point just above. Therefore I've separated two method. At first, checking whether the condition itself is needed to evaluated on its nature, after that, I've tried to actually evaluate this condition to check whether the client satisfies with the condition or not.", "author": "tnorimat", "createdAt": "2020-05-29T11:35:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNzQwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjQyOTUwOQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432429509", "bodyText": "And, I think that it is not appropriate to implement boolean isEvaluatedOnEvent(String event) with default sentence. IMO, the actual implementation of condition needs to implement this method explicitly on its nature. Therefore, I'd like to remove default keyword from this method.", "author": "tnorimat", "createdAt": "2020-05-29T11:44:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNzQwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzA4NTEzOA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r437085138", "bodyText": "The just idea for removing boolean isEvaluatedOnEvent(String event) is as follows :\n\n\nThis condition is not needed to be evaluated.\n\n\nboolean isSatisfiedOn...() throws ClientPolicyException without stacktrace.\n\n\nThis condition is needed to be evaluated. Therefore, keycloak tries to evaluate this condition to check whether the client who sent the request satisfies this condition and it indeed satisfies.\n\n\nboolean isSatisfiedOn...() returns true.\n\n\nThis condition is needed to be evaluated. Therefore, keycloak tries to evaluate this condition to check whether the client who sent the request satisfies this condition and it does NOT satisfies.\n\n\nboolean isSatisfiedOn...() returns false.\nI'm not sure whether it is appropriate to use Exception for such the use. WDYT?", "author": "tnorimat", "createdAt": "2020-06-09T01:20:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNzQwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNzg2MA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431617860", "bodyText": "Why is this here? Can't see it being invoked anywhere.", "author": "stianst", "createdAt": "2020-05-28T06:52:28Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/condition/ClientPolicyConditionFactory.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.condition;\n+\n+import java.util.List;\n+\n+import org.keycloak.component.ComponentFactory;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.provider.ProviderConfigProperty;\n+\n+public interface ClientPolicyConditionFactory extends ComponentFactory<ClientPolicyCondition, ClientPolicyCondition> {\n+\n+    List<ProviderConfigProperty> getConfigProperties(KeycloakSession session);", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNjg4NA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432306884", "bodyText": "Yes, I'll remove this List<ProviderConfigProperty> getConfigProperties(KeycloakSession session) method.", "author": "tnorimat", "createdAt": "2020-05-29T07:35:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxNzg2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxODQ4Ng==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431618486", "bodyText": "Same as with ClientPolicyCondition I don't think there's a need for a separate isExecutedOn as default methods should just be empty. That makes it easier to implement as you just implement those methods/events that you want", "author": "stianst", "createdAt": "2020-05-28T06:53:47Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/ClientPolicyExecutor.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.provider.Provider;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyEvent;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+/**\n+ * This executor specifies what action is executed on the client to which to which {@link ClientPolicyProvider} is adopted.\n+ * The executor can be executed on the events defined in {@link ClientPolicyEvent}.\n+ * It is sufficient for the implementer of this executor to implement methods in which they are interested\n+ * and {@link isEvaluatedOnEvent} method.\n+ */\n+public interface ClientPolicyExecutor extends Provider {\n+\n+    @Override\n+    default void close() {\n+    }\n+\n+    /**\n+     * returns true if this executor is executed against the client.\n+     * A executor can be implemented to be executed on some events while not on others.\n+     * On the event specified as the parameter, this executor is skipped if this method returns false.\n+     *\n+     * @param event defined in {@link ClientPolicyEvent}\n+     * @return true if this executor is executed on the event.\n+     */\n+    default boolean isExecutedOnEvent(String event) {return true;}", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc4NTI3Mg==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432785272", "bodyText": "Yes, I'll remove isExecutedOnEvent().", "author": "tnorimat", "createdAt": "2020-05-29T23:50:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxODQ4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxODk3Nw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431618977", "bodyText": "Default should just be an empty method, it should not throw an exception\nSame as with ClientPolicyCondition I think it would be better to have a single method for create/update clients for both dynamic and client. As in most cases the code will be the same, and a context object would allow different behaviour for specific cases.", "author": "stianst", "createdAt": "2020-05-28T06:54:49Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/ClientPolicyExecutor.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.provider.Provider;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyEvent;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+/**\n+ * This executor specifies what action is executed on the client to which to which {@link ClientPolicyProvider} is adopted.\n+ * The executor can be executed on the events defined in {@link ClientPolicyEvent}.\n+ * It is sufficient for the implementer of this executor to implement methods in which they are interested\n+ * and {@link isEvaluatedOnEvent} method.\n+ */\n+public interface ClientPolicyExecutor extends Provider {\n+\n+    @Override\n+    default void close() {\n+    }\n+\n+    /**\n+     * returns true if this executor is executed against the client.\n+     * A executor can be implemented to be executed on some events while not on others.\n+     * On the event specified as the parameter, this executor is skipped if this method returns false.\n+     *\n+     * @param event defined in {@link ClientPolicyEvent}\n+     * @return true if this executor is executed on the event.\n+     */\n+    default boolean isExecutedOnEvent(String event) {return true;}\n+\n+    /**\n+     * execute actions against the client\n+     * on Dynamic Registration Endpoint access for creating client.\n+     *\n+     * @param context\n+     * @param authType\n+     * @throws {@link ClientPolicyException} - if something wrong happens when execution actions\n+     */\n+    default void executeOnDynamicClientRegister(\n+            ClientRegistrationContext context,\n+            RegistrationAuth authType)  throws ClientPolicyException {}", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5MTM5NQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432791395", "bodyText": "My intention for throwing ClientPolicyException from executeOn...() methods is as follows :\n\n\nThere is a chance that an executor refuses a request from a client. For example, an executor for enforcing PKCE. When a client sends an authorization request without code_challenge on Authorization Endpoint, this executor refuses this request\n\n\nIf an executor refuses a request from a client, the executor needs to convey this situation to these methods' caller in order for them to send an appropriate error to the client. For the example above, AuthorizationEndpoint returns to the client 400 Bad Request with error=\"invalid_client\".\n\n\nTo convey such the situation, I've used an exception.", "author": "tnorimat", "createdAt": "2020-05-30T00:31:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxODk3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5MjE4NQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432792185", "bodyText": "As the same as condition, I'll implement default void executeOnClientUpdate(ClientUpdateContext context)\ninstead of current several method on each events (Dynamic Client Registration, Dynamic Client Update, Admin REST API Client Registration, Admin REST API Client Update).", "author": "tnorimat", "createdAt": "2020-05-30T00:37:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxODk3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzMjk4Nw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r435132987", "bodyText": "Ignore the comment on the default implementation - I completely miss-read the code, somehow I read \"throw new ClientPolicyException()\" as the default implementation, not that the method \"throws ClientPolicyException\"\nHaving the single method for an events (instead isExecuted on and executeOn) will be good and I think it will clean up the PR a lot, as well as require less \"boilerplate\" to implement executors and conditions.", "author": "stianst", "createdAt": "2020-06-04T09:54:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxODk3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNjIzNDc5NQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r436234795", "bodyText": "I see, as you pointed out, I'll integrate these two method (isExecuted() and executeOn...()) onto one method (executeOn...()).", "author": "tnorimat", "createdAt": "2020-06-06T03:54:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxODk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxOTE3Ng==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431619176", "bodyText": "Default should just be an empty method, it should not throw an exception. Applies to all default methods below.", "author": "stianst", "createdAt": "2020-05-28T06:55:13Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/ClientPolicyExecutor.java", "diffHunk": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.protocol.oidc.endpoints.request.AuthorizationEndpointRequest;\n+import org.keycloak.protocol.oidc.utils.OAuth2CodeParser;\n+import org.keycloak.protocol.oidc.utils.OIDCResponseType;\n+import org.keycloak.provider.Provider;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyEvent;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+/**\n+ * This executor specifies what action is executed on the client to which to which {@link ClientPolicyProvider} is adopted.\n+ * The executor can be executed on the events defined in {@link ClientPolicyEvent}.\n+ * It is sufficient for the implementer of this executor to implement methods in which they are interested\n+ * and {@link isEvaluatedOnEvent} method.\n+ */\n+public interface ClientPolicyExecutor extends Provider {\n+\n+    @Override\n+    default void close() {\n+    }\n+\n+    /**\n+     * returns true if this executor is executed against the client.\n+     * A executor can be implemented to be executed on some events while not on others.\n+     * On the event specified as the parameter, this executor is skipped if this method returns false.\n+     *\n+     * @param event defined in {@link ClientPolicyEvent}\n+     * @return true if this executor is executed on the event.\n+     */\n+    default boolean isExecutedOnEvent(String event) {return true;}\n+\n+    /**\n+     * execute actions against the client\n+     * on Dynamic Registration Endpoint access for creating client.\n+     *\n+     * @param context\n+     * @param authType\n+     * @throws {@link ClientPolicyException} - if something wrong happens when execution actions\n+     */\n+    default void executeOnDynamicClientRegister(\n+            ClientRegistrationContext context,\n+            RegistrationAuth authType)  throws ClientPolicyException {}\n+\n+    /**\n+     * execute actions against the client\n+     * on Dynamic Registration Endpoint access for updating client.\n+     *\n+     * @param context\n+     * @param authType\n+     * @param client - current client's model\n+     * @throws {@link ClientPolicyException} - if something wrong happens when execution actions\n+     */\n+    default void executeOnDynamicClientUpdate(\n+            ClientRegistrationContext context,\n+            RegistrationAuth authType,\n+            ClientModel client)  throws ClientPolicyException {}", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5MTY2Mw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432791663", "bodyText": "Please refer to the conversation just above.", "author": "tnorimat", "createdAt": "2020-05-30T00:33:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxOTE3Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzMzIwNA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r435133204", "bodyText": "Ignore this - I completely miss-read the code", "author": "stianst", "createdAt": "2020-06-04T09:54:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxOTE3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxOTM3OQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431619379", "bodyText": "I'm not too keen on the use of an AbstractClientPolicyExecutor here as this shows possibly a weakness in the interface.\nFor update events the augment for all executors needs to be done prior to the isSatisfied as it could be that one executor adds something that a different executor requires.\nI would probably rather have something like ClientPolicyExecutor#augumentClientConfig(ClientConfigContext context) and ClientPolicyExecutor#validateClientConfig(ClientConfigContext context), this would replace the AbstractClientPoicyExecutor and the executeOnClient methods.", "author": "stianst", "createdAt": "2020-05-28T06:55:40Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/impl/AbstractClientPoicyExecutor.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor.impl;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+/**\n+ * Executor can override the client settings to enforce some actions.\n+ * This feature can be activated or deactivated.\n+ */\n+public abstract class AbstractClientPoicyExecutor implements ClientPolicyExecutor {", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjgwMTk4Mg==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432801982", "bodyText": "For update events the augment for all executors needs to be done prior to the isSatisfied as it could be that one executor adds something that a different executor requires.\n\nOne point I'd like to confirm it is that an executor do augment and validation against clients that satisfies all conditions of a policy. Therefore, I intended that no method of an executor is called before isSatisfied...() of a condition are called. Is that correct?", "author": "tnorimat", "createdAt": "2020-05-30T02:27:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxOTM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTEzNTgwNA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r435135804", "bodyText": "Yes, it has to be that way", "author": "stianst", "createdAt": "2020-06-04T09:58:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYxOTM3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYyMTE2OQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431621169", "bodyText": "Same as in Condition/Executor there is no need for a separate isAugumentRequired method as the augment method should have a default empty method.", "author": "stianst", "createdAt": "2020-05-28T06:59:39Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/impl/AbstractClientPoicyExecutor.java", "diffHunk": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor.impl;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutor;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+/**\n+ * Executor can override the client settings to enforce some actions.\n+ * This feature can be activated or deactivated.\n+ */\n+public abstract class AbstractClientPoicyExecutor implements ClientPolicyExecutor {\n+\n+    protected static final Logger logger = Logger.getLogger(AbstractClientPoicyExecutor.class);\n+\n+    protected final KeycloakSession session;\n+    protected final ComponentModel componentModel;\n+\n+    public AbstractClientPoicyExecutor(KeycloakSession session, ComponentModel componentModel) {\n+        this.session = session;\n+        this.componentModel = componentModel;\n+    }\n+\n+    // on Dynamic Registration Endpoint access for creating client\n+    @Override\n+    public void executeOnDynamicClientRegister(\n+            ClientRegistrationContext context,\n+            RegistrationAuth authType) throws ClientPolicyException {\n+        if(isAugmentRequired()) augment(context.getClient());\n+        validate(context.getClient());\n+    }\n+\n+    // on Dynamic Registration Endpoint access for updating client\n+    @Override\n+    public void executeOnDynamicClientUpdate(\n+            ClientRegistrationContext context,\n+            RegistrationAuth authType,\n+            ClientModel client)  throws ClientPolicyException {\n+        if(isAugmentRequired()) augment(context.getClient());\n+        validate(context.getClient());\n+    }\n+ \n+    // on Admin REST API Registration access for creating client\n+    @Override\n+    public void executeOnClientRegister(\n+            ClientRepresentation rep,\n+            AdminAuth admin) throws ClientPolicyException {\n+        if(isAugmentRequired()) augment(rep);\n+        validate(rep);\n+    };\n+\n+    // on Admin REST API Registration access for updating client\n+    @Override\n+    public void executeOnClientUpdate(\n+            ClientRepresentation rep,\n+            AdminAuth admin,\n+            ClientModel client) throws ClientPolicyException {\n+        if(isAugmentRequired()) augment(rep);\n+        validate(rep);\n+    };\n+\n+    /**\n+     * returns true if this executor overrides the client settings. \n+     *\n+     * @return true if this executor overrides the client settings\n+     */\n+    protected abstract boolean isAugmentRequired();", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5OTA1MA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432799050", "bodyText": "I see, I'll remove isAugmentRequired().", "author": "tnorimat", "createdAt": "2020-05-30T01:46:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYyMTE2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYyMzMxNA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r431623314", "bodyText": "I couldn't find how the ClientPolicyManager has replaced the ClientRegistrationPolicyManager yet? Can you explain how the old client registration policies are executed now?", "author": "stianst", "createdAt": "2020-05-28T07:04:36Z", "path": "services/src/main/java/org/keycloak/services/clientregistration/ClientRegistrationAuth.java", "diffHunk": "@@ -149,8 +151,8 @@ public RegistrationAuth requireCreate(ClientRegistrationContext context) {\n         }\n \n         try {\n-            ClientRegistrationPolicyManager.triggerBeforeRegister(context, registrationAuth);\n-        } catch (ClientRegistrationPolicyException crpe) {\n+            ClientPolicyManager.triggerBeforeRegister(context, registrationAuth);", "originalCommit": "a8264b230f76bf1ecdaf55eff84c4567467c05b3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjc5Mzg2NA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r432793864", "bodyText": "ClientPolicyManager wraps the execution of the old client registration policy ClientRegistrationPolicyManager.\nIn the new client policy ClientPolicyManager.triggerBeforeRegister(), the old client registration policy ClientRegistrationPolicyManager.triggerBeforeRegister() is called.\nAlso, in the new client policy ClientPolicyManager.triggerBeforeUpdate(), the old client registration policy ClientRegistrationPolicyManager.triggerBeforeUpdate() is called.", "author": "tnorimat", "createdAt": "2020-05-30T00:50:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTYyMzMxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQzNDU2Mg==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r441434562", "bodyText": "This is not used right? So should be removed", "author": "stianst", "createdAt": "2020-06-17T10:07:36Z", "path": "server-spi-private/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyProviderFactory.java", "diffHunk": "@@ -0,0 +1,30 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+\n+import org.keycloak.component.ComponentFactory;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.provider.ProviderConfigProperty;\n+\n+public interface ClientPolicyProviderFactory extends ComponentFactory<ClientPolicyProvider, ClientPolicyProvider> {\n+\n+    List<ProviderConfigProperty> getConfigProperties(KeycloakSession session);", "originalCommit": "267c19c87e70cbd3f728c20aac3843d4a0ec823d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI2NjU1OA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r443266558", "bodyText": "Yes. I'll remove this method.", "author": "tnorimat", "createdAt": "2020-06-21T23:22:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQzNDU2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQzNTQ5OA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r441435498", "bodyText": "Nitpick to improve readability a bit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                default boolean isSatisfiedOnEvent(ClientPolicyContext context) throws ClientPolicyException {return true;}\n          \n          \n            \n                default boolean isSatisfiedOnEvent(ClientPolicyContext context) throws ClientPolicyException {\n          \n          \n            \n                    return true;\n          \n          \n            \n                }", "author": "stianst", "createdAt": "2020-06-17T10:09:16Z", "path": "server-spi-private/src/main/java/org/keycloak/services/clientpolicy/condition/ClientPolicyConditionProvider.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.condition;\n+\n+import org.keycloak.provider.Provider;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyEvent;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+\n+/**\n+ * This condition determines to which client a {@link ClientPolicyProvider} is adopted.\n+ * The condition can be evaluated on the events defined in {@link ClientPolicyEvent}.\n+ * It is sufficient for the implementer of this condition to implement methods in which they are interested\n+ * and {@link isEvaluatedOnEvent} method.\n+ */\n+public interface ClientPolicyConditionProvider extends Provider {\n+\n+    final String SKIP_EVALUATION = \"skip-evaluation\";\n+\n+    @Override\n+    default void close() {}\n+\n+    /**\n+     * returns true if the client satisfies this condition on the event defined in {@link ClientPolicyEvent}.\n+     *\n+     * @param context - the context of the event.\n+     * @return true if the client satisfies this condition.\n+     * @throws {@link ClientPolicyException} - thrown if the condition is not evaluated in its nature on the event specified by context.\n+     */\n+    default boolean isSatisfiedOnEvent(ClientPolicyContext context) throws ClientPolicyException {return true;}", "originalCommit": "267c19c87e70cbd3f728c20aac3843d4a0ec823d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI2NjcxOQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r443266719", "bodyText": "Yes, I'll change codes by following the style as you suggested.", "author": "tnorimat", "createdAt": "2020-06-21T23:24:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQzNTQ5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQzNjU5OA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r441436598", "bodyText": "What's the purpose of ClientPolicyException with skip-evaluation error? Shouldn't a condition just return true rather than throw an exception with skip-evaluation?", "author": "stianst", "createdAt": "2020-06-17T10:11:09Z", "path": "server-spi-private/src/main/java/org/keycloak/services/clientpolicy/condition/ClientPolicyConditionProvider.java", "diffHunk": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.condition;\n+\n+import org.keycloak.provider.Provider;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyEvent;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+\n+/**\n+ * This condition determines to which client a {@link ClientPolicyProvider} is adopted.\n+ * The condition can be evaluated on the events defined in {@link ClientPolicyEvent}.\n+ * It is sufficient for the implementer of this condition to implement methods in which they are interested\n+ * and {@link isEvaluatedOnEvent} method.\n+ */\n+public interface ClientPolicyConditionProvider extends Provider {\n+\n+    final String SKIP_EVALUATION = \"skip-evaluation\";", "originalCommit": "267c19c87e70cbd3f728c20aac3843d4a0ec823d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI2ODQyNA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r443268424", "bodyText": "Why this exception for notifying skipping the evaluation of the condition is as follows.\nAssume that\n\nClientPolicyConditionProvider.isSatisfiedOnEvent() returns true if this condition is not evaluated on the event.\nOn some event, all conditions of the policy are not evaluated. (e.g. On authorization request, the condition for checking Client App's IP is not possible to be evaluated because the browser is the HTTP Client, not Client App.)\nWhen this event happens, the executors of the policy are executed because all conditions of the policy return trues even these conditions are not evaluated.\n\nTo avoid this situation, I've explicitly distinguished situations between \"evaluated and satisfied (returns true)\", \"evaluated but not satisfied the condition (returns false)\" and \"not evaluated (throws exception) \".", "author": "tnorimat", "createdAt": "2020-06-21T23:43:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQzNjU5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTUxMjU5NQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r451512595", "bodyText": "I don't like the use of an exception in this way.\nWhat about something like:\ndefault Vote applyPolicy(ClientPolicyContext context)\nWhere Vote is an enum with values YES, NO, ABSTAIN", "author": "stianst", "createdAt": "2020-07-08T12:39:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQzNjU5OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTk2MTUwMw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r451961503", "bodyText": "I see, I'll revise codes to  add public enum ClientPolicyVote and replace default boolean isSatisfiedOnEvent(ClientPolicyContext context) with default ClientPolicyVoteapplyPolicy(ClientPolicyContext context) as you suggested.", "author": "tnorimat", "createdAt": "2020-07-09T04:47:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQzNjU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQzNzMxOQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r441437319", "bodyText": "Nitpick to improve readability a bit:\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                default void executeOnEvent(ClientPolicyContext context) throws ClientPolicyException {}\n          \n          \n            \n                default void executeOnEvent(ClientPolicyContext context) throws ClientPolicyException {\n          \n          \n            \n                }", "author": "stianst", "createdAt": "2020-06-17T10:12:22Z", "path": "server-spi-private/src/main/java/org/keycloak/services/clientpolicy/executor/ClientPolicyExecutorProvider.java", "diffHunk": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor;\n+\n+import org.keycloak.provider.Provider;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyEvent;\n+\n+/**\n+ * This executor specifies what action is executed on the client to which to which {@link ClientPolicyProvider} is adopted.\n+ * The executor can be executed on the events defined in {@link ClientPolicyEvent}.\n+ * It is sufficient for the implementer of this executor to implement methods in which they are interested\n+ * and {@link isEvaluatedOnEvent} method.\n+ */\n+public interface ClientPolicyExecutorProvider extends Provider {\n+\n+    @Override\n+    default void close() {}\n+\n+    /**\n+     * execute actions against the client on the event defined in {@link ClientPolicyEvent}.\n+     * \n+     * @param context - the context of the event.\n+     * @throws {@link ClientPolicyException} - if something wrong happens when execution actions.\n+     */\n+    default void executeOnEvent(ClientPolicyContext context) throws ClientPolicyException {}", "originalCommit": "267c19c87e70cbd3f728c20aac3843d4a0ec823d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI2ODQ5NA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r443268494", "bodyText": "Yes, I'll change codes by following the style as you suggested.", "author": "tnorimat", "createdAt": "2020-06-21T23:44:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQzNzMxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ0MjI3Mg==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r441442272", "bodyText": "I would rename this to something like AbstractAugumentingClientRegistrationPolicyExecutor. This is not really an abstract client policy executor, but rather a specific type of client policy exectuor.\nI'd also move the IS_AUGMENT field from ClientPolicyExecutorProviderFactory and move it to this class, then add the logic if (Boolean.valueOf(componentModel.getConfig().getFirst(ClientPolicyExecutorProviderFactory.IS_AUGMENT))) here instead of requiring the implementing classes to do that.\nFinally I would also add the augument config property options to this class, so sub-classes don't have to add it. If they just want to add something they can do something like:\ngetConfigProperties() {\n    List<ProviderConfigProperty l = super.getConfigProperties();\n    l.add(...)\n}", "author": "stianst", "createdAt": "2020-06-17T10:21:27Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/impl/AbstractClientPoicyExecutor.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor.impl;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientUpdateContext;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;\n+\n+public abstract class AbstractClientPoicyExecutor implements ClientPolicyExecutorProvider {", "originalCommit": "267c19c87e70cbd3f728c20aac3843d4a0ec823d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzI5MzI4Mg==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r443293282", "bodyText": "I see, I'll revise codes as you mentioned. IMO, getConfigProperties() has to be implemented on Factory class so that I'll add AbstractAugumentingClientRegistrationPolicyExecutorFactory. WDYT?", "author": "tnorimat", "createdAt": "2020-06-22T02:46:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ0MjI3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ0NzI0OQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r441447249", "bodyText": "What's the use-case for this one? It seems to enable a policy if the client has a specific role, but couldn't think why you would want that.", "author": "stianst", "createdAt": "2020-06-17T10:31:02Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/condition/impl/TestClientRolesCondition.java", "diffHunk": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.condition.impl;\n+\n+import java.util.List;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;\n+import org.keycloak.services.clientpolicy.impl.ClientPolicyLogger;\n+\n+public class TestClientRolesCondition implements ClientPolicyConditionProvider {", "originalCommit": "267c19c87e70cbd3f728c20aac3843d4a0ec823d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMwMTYwNA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r443301604", "bodyText": "It is test use only so that I'll move these Test... classes to testsuite-providers project.", "author": "tnorimat", "createdAt": "2020-06-22T03:32:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ0NzI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ0OTkxNA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r441449914", "bodyText": "Not sure these are quite correct. It shouldn't matter if you are using admin-apis or dynamic client registration apis. It's more down to who you are. So options should be something more like:\n\nauthenticated-user\nanonymous\ninitial-access-token\n\nFor initial-access-token it would actually be nice if we have a way in the future to generate different tokens for different groups of users or something, so an admin can issue tokens with different rights. That's certainly out of scope for this PR though.", "author": "stianst", "createdAt": "2020-06-17T10:36:03Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/condition/impl/TestAuthnMethodsConditionFactory.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.condition.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.keycloak.Config.Scope;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.KeycloakSessionFactory;\n+import org.keycloak.provider.ProviderConfigProperty;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProviderFactory;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+\n+public class TestAuthnMethodsConditionFactory implements ClientPolicyConditionProviderFactory {\n+\n+    public static final String PROVIDER_ID = \"test-authnmethods-condition\";\n+\n+    public static final String AUTH_METHOD = \"auth-method\";\n+    public static final String BY_ADMIN_REST_API = \"ByAdminRestAPI\";\n+    public static final String BY_DYNAMIC_ANONYMOUS = RegistrationAuth.ANONYMOUS.name();\n+    public static final String BY_DYNAMIC_AUTHENTICATED = RegistrationAuth.AUTHENTICATED.name();", "originalCommit": "267c19c87e70cbd3f728c20aac3843d4a0ec823d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0MDI4Mw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r445140283", "bodyText": "I see, I'll treat this matter as follows.\n\nmove this class to testsuite-providers project because it is test use only.\nthe following options about who tries to create/update a client are supported.\n\nauthenticated-user\nanonymous\ninitial-access-token\nregistration-access-token\n\n\nhold a token (initial-access-token, registration-access-token, access-token) in ClientUpdateContext in order for us to use it to do some policy operation based on it in the future.\n\nWDYT?", "author": "tnorimat", "createdAt": "2020-06-24T20:04:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ0OTkxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ1MDg1OQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r441450859", "bodyText": "pkce-enforce and drop Test from class name, see previous comment for details", "author": "stianst", "createdAt": "2020-06-17T10:37:52Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/impl/TestPKCEEnforceExecutorFactory.java", "diffHunk": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor.impl;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.keycloak.Config.Scope;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.KeycloakSessionFactory;\n+import org.keycloak.provider.ProviderConfigProperty;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProviderFactory;\n+\n+public class TestPKCEEnforceExecutorFactory implements ClientPolicyExecutorProviderFactory {\n+\n+    public static final String PROVIDER_ID = \"test-pkce-enforce-executor\";", "originalCommit": "267c19c87e70cbd3f728c20aac3843d4a0ec823d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMwMzI3OQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r443303279", "bodyText": "It is test use only so that I'll move these Test... classes to testsuite-providers project. I'll support this executor as the sub task defined in Client Policy - Executor : Enforce Proof Key for Code Exchange (PKCE) afterwards.", "author": "tnorimat", "createdAt": "2020-06-22T03:42:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ1MDg1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ1Mjg2Mw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r441452863", "bodyText": "Wonder if we actually care if it's dynamic or admin register/update. It's more down to who did the update, rather than what endpoint they used. So perhaps it would be better to just have REGISTER and UPDATE?", "author": "stianst", "createdAt": "2020-06-17T10:41:49Z", "path": "server-spi/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyEvent.java", "diffHunk": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+public enum ClientPolicyEvent {\n+\n+    DYNAMIC_REGISTER,\n+    DYNAMIC_UPDATE,\n+    ADMIN_REGISTER,\n+    ADMIN_UPDATE,", "originalCommit": "267c19c87e70cbd3f728c20aac3843d4a0ec823d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE0MTY4Mw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r445141683", "bodyText": "Yes, I'll replace DYNAMIC_REGISTER and ADMIN_REGISTER with REGISTER.\nAlso, I'll replace DYNAMIC_UPDATE and ADMIN_UPDATE with UPDATE.", "author": "tnorimat", "createdAt": "2020-06-24T20:07:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MTQ1Mjg2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxNDc5Mw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r442814793", "bodyText": "See comment on AbstractClientPoicyExecutor. I would remove this from here.", "author": "stianst", "createdAt": "2020-06-19T12:36:25Z", "path": "server-spi-private/src/main/java/org/keycloak/services/clientpolicy/executor/ClientPolicyExecutorProviderFactory.java", "diffHunk": "@@ -0,0 +1,25 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor;\n+\n+import org.keycloak.component.ComponentFactory;\n+\n+public interface ClientPolicyExecutorProviderFactory extends ComponentFactory<ClientPolicyExecutorProvider, ClientPolicyExecutorProvider> {\n+\n+    public static final String IS_AUGMENT = \"is-augment\";", "originalCommit": "267c19c87e70cbd3f728c20aac3843d4a0ec823d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzMwOTQ0Nw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r443309447", "bodyText": "I see, I'll remove IS_AUGMENT.", "author": "tnorimat", "createdAt": "2020-06-22T04:16:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxNDc5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxNTgxMw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r442815813", "bodyText": "I would prefer if there's a single way to get auth context rather than two separate depending on what API is used. That is enhancements/polish we can do later though.", "author": "stianst", "createdAt": "2020-06-19T12:38:38Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientUpdateContext.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.services.clientregistration.ClientRegistrationContext;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+import org.keycloak.services.resources.admin.AdminAuth;\n+\n+/**\n+ * Represents the context in the client registration/update by Dynamic Client Registration or Admin REST API.\n+ */\n+public interface ClientUpdateContext extends ClientPolicyContext {\n+\n+    /**\n+     * returns {@link ClientModel} of the current client that will be updated.\n+     *\n+     * @return {@link ClientModel}\n+     */\n+    default ClientModel getCurrentClientModel() {return null;}\n+\n+    /**\n+     * returns {@link ClientRepresentation} for updating the current client by Admin REST API.\n+     *\n+     * @return {@link ClientRepresentation}\n+     */\n+    default ClientRepresentation getProposedClientRepresentation() {return null;}\n+\n+    /**\n+     * returns {@link RegistrationAuth} by Dynamic Client Registration.\n+     *\n+     * @return {@link RegistrationAuth}\n+     */\n+    default RegistrationAuth getDynamicRegistrationAuth() {return null;}\n+\n+    /**\n+     * returns {@link AdminAuth} by Admin REST API.\n+     *\n+     * @return {@link AdminAuth}\n+     */\n+    default AdminAuth getAdminAuth() {return null;}", "originalCommit": "267c19c87e70cbd3f728c20aac3843d4a0ec823d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTE1MDQxNw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r445150417", "bodyText": "I see, I'll use the same methods for Dynamic Client Registration and Admin REST API.\nCreating/Updating Client\n\nClientRepresentation getProposedClientRepresentation()\nClientRepresentation for creating or updating the current client.\nClientModel getClientToBeUpdated()\nClientModel that will be updated.\n\nAuthentication Context\n\nUserModel getAuthenticatedUser()\nThe authenticated and authorized user for creating /updating a client. There is the case that no such user exist. (e.g. creating/updating a client with an access token issued by Client Credentials Grant)\nClientModel getAuthenticatedClient()\nThe authenticated and authorized client for creating /updating a client. There is the case that no such client exist. (e.g. creating/updating a client with an initial access token or a registration access token, or without any token)\nJsonWebToken getToken()\nThe token accompanied with a registration/update client request. It will be used to do some policy operation based on it in the future.\n\nWDYT?", "author": "tnorimat", "createdAt": "2020-06-24T20:24:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxNTgxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxNzE1MQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r442817151", "bodyText": "Having Test prefix on class name is confusing to me. At first I was thinking this had to do with testing.\nAnother thing is classes being in impl package, this is not a convention we use in Keycloak codebase elsewhere.\nPROVIDER_ID should just be \"authnmethods\". I find \"Test\" confusing and \"condition\" is already implied as it's \"authnmethods\" of \"client-policy-condition\" SPI.", "author": "stianst", "createdAt": "2020-06-19T12:41:26Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/condition/impl/TestAuthnMethodsConditionFactory.java", "diffHunk": "@@ -0,0 +1,85 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.condition.impl;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.keycloak.Config.Scope;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.KeycloakSessionFactory;\n+import org.keycloak.provider.ProviderConfigProperty;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProviderFactory;\n+import org.keycloak.services.clientregistration.policy.RegistrationAuth;\n+\n+public class TestAuthnMethodsConditionFactory implements ClientPolicyConditionProviderFactory {\n+\n+    public static final String PROVIDER_ID = \"test-authnmethods-condition\";", "originalCommit": "267c19c87e70cbd3f728c20aac3843d4a0ec823d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM0OTcyMg==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r443349722", "bodyText": "It is test use only so that I'll move these Test... classes to testsuite-providers project. I'll support this executor as the sub task defined in Client Policy - Executor : Enforce more secure client authentication method when client registration afterwards.", "author": "tnorimat", "createdAt": "2020-06-22T06:52:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxNzE1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxODA2NA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r442818064", "bodyText": "I'd just use clientroles and drop Test from class-name, see previous comment for more details", "author": "stianst", "createdAt": "2020-06-19T12:43:24Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/condition/impl/TestClientRolesConditionFactory.java", "diffHunk": "@@ -0,0 +1,77 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.condition.impl;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.keycloak.Config.Scope;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.KeycloakSessionFactory;\n+import org.keycloak.provider.ProviderConfigProperty;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProviderFactory;\n+\n+public class TestClientRolesConditionFactory implements ClientPolicyConditionProviderFactory {\n+\n+    public static final String PROVIDER_ID = \"test-clientroles-condition\";", "originalCommit": "267c19c87e70cbd3f728c20aac3843d4a0ec823d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM1MTgwOA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r443351808", "bodyText": "It is test use only so that I'll move these Test... classes to testsuite-providers project.", "author": "tnorimat", "createdAt": "2020-06-22T06:57:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxODA2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxODM4NQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r442818385", "bodyText": "client-authn and drop Test from class name. See previous comment for more details", "author": "stianst", "createdAt": "2020-06-19T12:44:05Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/executor/impl/TestClientAuthenticationExecutorFactory.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor.impl;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import org.keycloak.Config.Scope;\n+import org.keycloak.authentication.authenticators.client.JWTClientAuthenticator;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.KeycloakSessionFactory;\n+import org.keycloak.provider.ProviderConfigProperty;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProviderFactory;\n+\n+public class TestClientAuthenticationExecutorFactory implements ClientPolicyExecutorProviderFactory {\n+\n+    public static final String PROVIDER_ID = \"test-client-authn-executor\";", "originalCommit": "267c19c87e70cbd3f728c20aac3843d4a0ec823d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MzM1MjE1Ng==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r443352156", "bodyText": "It is test use only so that I'll move these Test... classes to testsuite-providers project.", "author": "tnorimat", "createdAt": "2020-06-22T06:58:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjgxODM4NQ=="}], "type": "inlineReview"}, {"oid": "ae04e159b2cfda874f63fa67a38b4450b0067e1e", "url": "https://github.com/keycloak/keycloak/commit/ae04e159b2cfda874f63fa67a38b4450b0067e1e", "message": "revise codes for 2nd iteration review comments feedback", "committedDate": "2020-06-25T03:36:50Z", "type": "forcePushed"}, {"oid": "f54ad3200705b542359bf59d5320ea2a364af621", "url": "https://github.com/keycloak/keycloak/commit/f54ad3200705b542359bf59d5320ea2a364af621", "message": "revise codes for 2nd iteration review comments feedback", "committedDate": "2020-06-25T05:54:51Z", "type": "forcePushed"}, {"oid": "1a21f1d0cc2a8014ac9beee62ab6cc08aebc4406", "url": "https://github.com/keycloak/keycloak/commit/1a21f1d0cc2a8014ac9beee62ab6cc08aebc4406", "message": "support GET method on UserInfo Endpoint", "committedDate": "2020-06-28T03:13:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTUxNTc4Mw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r451515783", "bodyText": "Thinking about this some more I wonder if skipping the policies on an exception is a good thing. It could result in some error in a condition resulting in accepting things that shouldn't be accepted. Wonder if we should fail the request in this case instead.", "author": "stianst", "createdAt": "2020-07-08T12:45:05Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/DefaultClientPolicyManager.java", "diffHunk": "@@ -0,0 +1,157 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.common.Profile;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyManager;\n+import org.keycloak.services.clientpolicy.ClientPolicyProvider;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;\n+\n+public class DefaultClientPolicyManager implements ClientPolicyManager {\n+\n+    private static final Logger logger = Logger.getLogger(DefaultClientPolicyManager.class);\n+\n+    private final KeycloakSession session;\n+    private final Map<String, List<ClientPolicyProvider>> providersMap = new HashMap<>();\n+\n+    public DefaultClientPolicyManager(KeycloakSession session) {\n+        this.session = session;\n+    }\n+\n+    @Override\n+    public void triggerOnEvent(ClientPolicyContext context) throws ClientPolicyException {\n+        if (!Profile.isFeatureEnabled(Profile.Feature.CLIENT_POLICIES)) return;\n+        ClientPolicyLogger.logv(logger, \"Client Policy Operation : event = {0}\", context.getEvent());\n+        doPolicyOperation(\n+                (ClientPolicyConditionProvider condition) -> condition.isSatisfiedOnEvent(context),\n+                (ClientPolicyExecutorProvider executor) -> executor.executeOnEvent(context)\n+            );\n+    }\n+\n+    private void doPolicyOperation(ClientConditionOperation condition, ClientExecutorOperation executor) throws ClientPolicyException {\n+        RealmModel realm = session.getContext().getRealm();\n+        for (ClientPolicyProvider policy : getProviders(realm)) {\n+            ClientPolicyLogger.logv(logger, \"Policy Operation : name = {0}, provider id = {1}\", policy.getName(), policy.getProviderId());\n+            if (!isSatisfied(policy, condition)) continue;\n+            execute(policy, executor);\n+        }\n+    }\n+\n+    private List<ClientPolicyProvider> getProviders(RealmModel realm) {\n+        List<ClientPolicyProvider> providers = providersMap.get(realm.getId());\n+        if (providers == null) {\n+            providers = new LinkedList<>();\n+            List<ComponentModel> policyModels = realm.getComponents(realm.getId(), ClientPolicyProvider.class.getName());\n+            for (ComponentModel policyModel : policyModels) {\n+                try {\n+                    ClientPolicyProvider policy = session.getProvider(ClientPolicyProvider.class, policyModel);\n+                    ClientPolicyLogger.logv(logger, \"Loaded Policy Name = {0}\", policyModel.getName());\n+                    session.enlistForClose(policy);\n+                    providers.add(policy);\n+                } catch (Throwable t) {\n+                    logger.errorv(t, \"Failed to load provider {0}\", policyModel.getId());\n+                }\n+            }\n+            providersMap.put(realm.getId(), providers);\n+        } else {\n+            ClientPolicyLogger.log(logger, \"Use cached policies.\");\n+        }\n+        return providers;\n+    }\n+\n+    private boolean isSatisfied(\n+            ClientPolicyProvider policy,\n+            ClientConditionOperation op) {\n+\n+        List<ClientPolicyConditionProvider> conditions = policy.getConditions();\n+\n+        if (conditions == null || conditions.isEmpty()) {\n+            ClientPolicyLogger.log(logger, \"NEGATIVE :: This policy is not applied. No condition exists.\");\n+            return false;\n+        }\n+\n+        boolean ret = false;\n+        for (ClientPolicyConditionProvider condition : conditions) {\n+            try {\n+                if (!op.run(condition)) {\n+                    ClientPolicyLogger.logv(logger, \"NEGATIVE :: This policy is not applied. condition not satisfied. name = {0}, provider id = {1}, \", condition.getName(), condition.getProviderId());\n+                    return false;\n+                } else {\n+                    ret = true;\n+                }\n+            } catch (ClientPolicyException cpe) {\n+                if (cpe.getError().equals(ClientPolicyConditionProvider.SKIP_EVALUATION)) {\n+                    ClientPolicyLogger.logv(logger, \"SKIP : This condition is not evaluated due to its nature. name = {0}, provider id = {1}\", condition.getName(), condition.getProviderId());\n+                    continue;\n+                }\n+                ClientPolicyLogger.logv(logger, \"CONDITION EXCEPTION : name = {0}, provider id = {1}, error = {2}, error_detail = {3}\", condition.getName(), condition.getProviderId(), cpe.getError(), cpe.getErrorDetail());\n+                return false;", "originalCommit": "1a21f1d0cc2a8014ac9beee62ab6cc08aebc4406", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTk1OTk0NA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r451959944", "bodyText": "Yes, I'll revise codes to make the request fail if ClientPolicyExceptionis thrown from ClientPolicyConditionProvider.", "author": "tnorimat", "createdAt": "2020-07-09T04:41:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTUxNTc4Mw=="}], "type": "inlineReview"}, {"oid": "9896dc6404d47fa3d0751e5b888a67e8e119b0e3", "url": "https://github.com/keycloak/keycloak/commit/9896dc6404d47fa3d0751e5b888a67e8e119b0e3", "message": "28. ClientPolicyConditionProvider : request fails if an exception happens", "committedDate": "2020-07-09T06:04:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY2ODUzMA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r455668530", "bodyText": "Very minor typo (two occurences of \"to which\")", "author": "mposolda", "createdAt": "2020-07-16T09:56:03Z", "path": "server-spi-private/src/main/java/org/keycloak/services/clientpolicy/executor/ClientPolicyExecutorProvider.java", "diffHunk": "@@ -0,0 +1,49 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy.executor;\n+\n+import org.keycloak.provider.Provider;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyEvent;\n+\n+/**\n+ * This executor specifies what action is executed on the client to which to which {@link ClientPolicyProvider} is adopted.", "originalCommit": "35a6a86b15d709bad843a57a3bf91191e43930d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA3ODQ3Mw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r456078473", "bodyText": "Thanks. I'll fix the point you've mentioned.", "author": "tnorimat", "createdAt": "2020-07-16T21:07:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY2ODUzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQyNDc4MQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r456424781", "bodyText": "Thanks!", "author": "mposolda", "createdAt": "2020-07-17T12:57:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTY2ODUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkzNzI1Ng==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r455937256", "bodyText": "Is this needed in the pull request? Some other tests, which rely on profile features, don't need to set this system property explicitly?", "author": "mposolda", "createdAt": "2020-07-16T17:03:48Z", "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPolicyBasicsTest.java", "diffHunk": "@@ -0,0 +1,938 @@\n+package org.keycloak.testsuite.client;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import static org.keycloak.testsuite.admin.AbstractAdminTest.loadJson;\n+import static org.keycloak.testsuite.admin.ApiUtil.findUserByUsername;\n+\n+import java.io.IOException;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import javax.ws.rs.BadRequestException;\n+import javax.ws.rs.core.Response;\n+\n+import org.hamcrest.Matchers;\n+import org.jboss.logging.Logger;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.admin.client.resource.ClientResource;\n+import org.keycloak.authentication.authenticators.client.ClientIdAndSecretAuthenticator;\n+import org.keycloak.authentication.authenticators.client.JWTClientAuthenticator;\n+import org.keycloak.authentication.authenticators.client.JWTClientSecretAuthenticator;\n+import org.keycloak.authentication.authenticators.client.X509ClientAuthenticator;\n+import org.keycloak.client.registration.Auth;\n+import org.keycloak.client.registration.ClientRegistration;\n+import org.keycloak.client.registration.ClientRegistrationException;\n+import org.keycloak.common.Profile;\n+import org.keycloak.common.util.Base64Url;\n+import org.keycloak.common.util.MultivaluedHashMap;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventType;\n+import org.keycloak.protocol.oidc.OIDCAdvancedConfigWrapper;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.representations.AccessToken;\n+import org.keycloak.representations.RefreshToken;\n+import org.keycloak.representations.idm.ClientInitialAccessCreatePresentation;\n+import org.keycloak.representations.idm.ClientInitialAccessPresentation;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.representations.idm.ComponentRepresentation;\n+import org.keycloak.representations.idm.EventRepresentation;\n+import org.keycloak.representations.idm.RealmRepresentation;\n+import org.keycloak.representations.oidc.OIDCClientRepresentation;\n+import org.keycloak.representations.oidc.TokenMetadataRepresentation;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyProvider;\n+import org.keycloak.services.clientpolicy.DefaultClientPolicyProviderFactory;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;\n+import org.keycloak.testsuite.AbstractKeycloakTest;\n+import org.keycloak.testsuite.AssertEvents;\n+import org.keycloak.testsuite.admin.ApiUtil;\n+import org.keycloak.testsuite.arquillian.annotation.EnableFeature;\n+import org.keycloak.testsuite.services.clientpolicy.condition.TestAuthnMethodsConditionFactory;\n+import org.keycloak.testsuite.services.clientpolicy.condition.TestClientRolesConditionFactory;\n+import org.keycloak.testsuite.services.clientpolicy.condition.TestRaiseExeptionConditionFactory;\n+import org.keycloak.testsuite.services.clientpolicy.executor.TestClientAuthenticationExecutorFactory;\n+import org.keycloak.testsuite.services.clientpolicy.executor.TestPKCEEnforceExecutorFactory;\n+import org.keycloak.testsuite.util.OAuthClient;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+@EnableFeature(value = Profile.Feature.CLIENT_POLICIES, skipRestart = true)\n+public class ClientPolicyBasicsTest extends AbstractKeycloakTest {\n+\n+    private static final Logger logger = Logger.getLogger(ClientPolicyBasicsTest.class);\n+\n+    static final String REALM_NAME = \"test\";\n+    static final String TEST_CLIENT = \"test-app\";\n+\n+    ClientRegistration reg;\n+\n+    @Rule\n+    public AssertEvents events = new AssertEvents(this);\n+\n+    @Before\n+    public void before() throws Exception {\n+        // get initial access token for Dynamic Client Registration with authentication\n+        reg = ClientRegistration.create().url(suiteContext.getAuthServerInfo().getContextRoot() + \"/auth\", REALM_NAME).build();\n+        ClientInitialAccessPresentation token = adminClient.realm(REALM_NAME).clientInitialAccess().create(new ClientInitialAccessCreatePresentation(0, 10));\n+        reg.auth(Auth.token(token));\n+\n+        System.setProperty(\"keycloak.profile\", \"preview\");", "originalCommit": "35a6a86b15d709bad843a57a3bf91191e43930d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA4MzIxNw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r456083217", "bodyText": "Yes, I'll remove testPurgePreviewProfile and its related codes as you've pointed out. This test was for checking activating/deactivating preview feature.", "author": "tnorimat", "createdAt": "2020-07-16T21:17:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkzNzI1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQyNjQzMw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r456426433", "bodyText": "Cool, Thanks. If tests still work for you with:\nmvn clean install -DskipTests=true -Pdistribution\n\nand then both Keycloak on undertow and wildfly\nmvn -f testsuite/integration-arquillian/pom.xml -Dtest=ClientPolicyBasicsTest clean install\nmvn -f testsuite/integration-arquillian/pom.xml -Pauth-server-wildfly -Dtest=ClientPolicyBasicsTest clean install\n\nthen we should be fine.", "author": "mposolda", "createdAt": "2020-07-17T13:00:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkzNzI1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkzNzM0Nw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r455937347", "bodyText": "Same comment as above", "author": "mposolda", "createdAt": "2020-07-16T17:03:59Z", "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/ClientPolicyBasicsTest.java", "diffHunk": "@@ -0,0 +1,938 @@\n+package org.keycloak.testsuite.client;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.fail;\n+import static org.keycloak.testsuite.admin.AbstractAdminTest.loadJson;\n+import static org.keycloak.testsuite.admin.ApiUtil.findUserByUsername;\n+\n+import java.io.IOException;\n+import java.security.MessageDigest;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.function.Consumer;\n+\n+import javax.ws.rs.BadRequestException;\n+import javax.ws.rs.core.Response;\n+\n+import org.hamcrest.Matchers;\n+import org.jboss.logging.Logger;\n+import org.junit.After;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.admin.client.resource.ClientResource;\n+import org.keycloak.authentication.authenticators.client.ClientIdAndSecretAuthenticator;\n+import org.keycloak.authentication.authenticators.client.JWTClientAuthenticator;\n+import org.keycloak.authentication.authenticators.client.JWTClientSecretAuthenticator;\n+import org.keycloak.authentication.authenticators.client.X509ClientAuthenticator;\n+import org.keycloak.client.registration.Auth;\n+import org.keycloak.client.registration.ClientRegistration;\n+import org.keycloak.client.registration.ClientRegistrationException;\n+import org.keycloak.common.Profile;\n+import org.keycloak.common.util.Base64Url;\n+import org.keycloak.common.util.MultivaluedHashMap;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventType;\n+import org.keycloak.protocol.oidc.OIDCAdvancedConfigWrapper;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.representations.AccessToken;\n+import org.keycloak.representations.RefreshToken;\n+import org.keycloak.representations.idm.ClientInitialAccessCreatePresentation;\n+import org.keycloak.representations.idm.ClientInitialAccessPresentation;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.representations.idm.ComponentRepresentation;\n+import org.keycloak.representations.idm.EventRepresentation;\n+import org.keycloak.representations.idm.RealmRepresentation;\n+import org.keycloak.representations.oidc.OIDCClientRepresentation;\n+import org.keycloak.representations.oidc.TokenMetadataRepresentation;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyProvider;\n+import org.keycloak.services.clientpolicy.DefaultClientPolicyProviderFactory;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;\n+import org.keycloak.testsuite.AbstractKeycloakTest;\n+import org.keycloak.testsuite.AssertEvents;\n+import org.keycloak.testsuite.admin.ApiUtil;\n+import org.keycloak.testsuite.arquillian.annotation.EnableFeature;\n+import org.keycloak.testsuite.services.clientpolicy.condition.TestAuthnMethodsConditionFactory;\n+import org.keycloak.testsuite.services.clientpolicy.condition.TestClientRolesConditionFactory;\n+import org.keycloak.testsuite.services.clientpolicy.condition.TestRaiseExeptionConditionFactory;\n+import org.keycloak.testsuite.services.clientpolicy.executor.TestClientAuthenticationExecutorFactory;\n+import org.keycloak.testsuite.services.clientpolicy.executor.TestPKCEEnforceExecutorFactory;\n+import org.keycloak.testsuite.util.OAuthClient;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+@EnableFeature(value = Profile.Feature.CLIENT_POLICIES, skipRestart = true)\n+public class ClientPolicyBasicsTest extends AbstractKeycloakTest {\n+\n+    private static final Logger logger = Logger.getLogger(ClientPolicyBasicsTest.class);\n+\n+    static final String REALM_NAME = \"test\";\n+    static final String TEST_CLIENT = \"test-app\";\n+\n+    ClientRegistration reg;\n+\n+    @Rule\n+    public AssertEvents events = new AssertEvents(this);\n+\n+    @Before\n+    public void before() throws Exception {\n+        // get initial access token for Dynamic Client Registration with authentication\n+        reg = ClientRegistration.create().url(suiteContext.getAuthServerInfo().getContextRoot() + \"/auth\", REALM_NAME).build();\n+        ClientInitialAccessPresentation token = adminClient.realm(REALM_NAME).clientInitialAccess().create(new ClientInitialAccessCreatePresentation(0, 10));\n+        reg.auth(Auth.token(token));\n+\n+        System.setProperty(\"keycloak.profile\", \"preview\");\n+        Profile.init();\n+\n+    }\n+\n+    @After\n+    public void after() throws Exception {\n+        reg.close();\n+\n+        System.getProperties().remove(\"keycloak.profile\");", "originalCommit": "35a6a86b15d709bad843a57a3bf91191e43930d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA4MzUxNg==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r456083516", "bodyText": "Yes, I'll do the same above.", "author": "tnorimat", "createdAt": "2020-07-16T21:18:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkzNzM0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQyNjYxNQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r456426615", "bodyText": "Thanks", "author": "mposolda", "createdAt": "2020-07-17T13:00:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTkzNzM0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk0MzE2NQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r455943165", "bodyText": "Does this interface need to have default methods? I see that most of the implementations need to override all the methods (with the exception of getClientToBeUpdated in case of \"Register\" classes). IMO it will be better if this interface don't have default methods - maybe with the exception of \"getClientToBeUpdated\" method.", "author": "mposolda", "createdAt": "2020-07-16T17:13:34Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/ClientUpdateContext.java", "diffHunk": "@@ -0,0 +1,75 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.representations.JsonWebToken;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+\n+/**\n+ * Represents the context in the client registration/update by Dynamic Client Registration or Admin REST API.\n+ */\n+public interface ClientUpdateContext extends ClientPolicyContext {", "originalCommit": "35a6a86b15d709bad843a57a3bf91191e43930d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjA5MTMyNg==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r456091326", "bodyText": "Yes, that's right. I'll only implement default method for getClientToBeUpdated() and remove default methods for others.", "author": "tnorimat", "createdAt": "2020-07-16T21:35:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk0MzE2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQyNDYyNw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r456424627", "bodyText": "+1, Thanks!", "author": "mposolda", "createdAt": "2020-07-17T12:56:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk0MzE2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk0ODkzMA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r455948930", "bodyText": "@tnorimat @stianst Maybe you discuss this already, but I am not 100% sure if ClientPolicyProvider need to be really Java provider? Isn't it rather just a ComponentModel?\nPer my understanding, the ClientPolicy provides binding between the set of conditions and executors. Hence usually I the typical administrator will create the policy instance in the admin console. And then he create some conditions and executors and bind them to this policy.\nI am probably missing some use-case why the ClientPolicyProvider is beneficial as a java provider rather than as a \"model\" ?", "author": "mposolda", "createdAt": "2020-07-16T17:22:56Z", "path": "server-spi-private/src/main/java/org/keycloak/services/clientpolicy/ClientPolicyProvider.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.List;\n+\n+import org.keycloak.provider.Provider;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;\n+\n+/**\n+ * Provides Client Policy which accommodates several Conditions and Executors.\n+ */\n+public interface ClientPolicyProvider extends Provider {", "originalCommit": "35a6a86b15d709bad843a57a3bf91191e43930d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM0MzU0Nw==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r456343547", "bodyText": "The idea behind this is that there can be multiple policies for a realm, where some are hard-coded/built-in. For example we could have a FAPIClientPolicyProvider that provides a built-in FAPI policy. Not quite sure if this will be the cleanest approach or not, but I would like to somehow avoid that we have to create \"built-in\" policies when new realms are being created.", "author": "stianst", "createdAt": "2020-07-17T09:55:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk0ODkzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM0NTA5OQ==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r456345099", "bodyText": "Perhaps we can keep it like this for now, then when we start adding the FAPI built-in profile, the editor for creating custom policies in the UI, and such, we can consider if it still should be a provider?", "author": "stianst", "createdAt": "2020-07-17T09:58:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk0ODkzMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQxODY1OA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r456418658", "bodyText": "@stianst +1, that works for me", "author": "mposolda", "createdAt": "2020-07-17T12:45:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk0ODkzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk1Mjg5MA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r455952890", "bodyText": "@tnorimat @stianst I have some concerns about the security of this.\nI am thinking of some scenario like:\n\nAdministrator start the server with the CLIENT_POLICIES feature enabled\nAdministrator configures some client policies\nAdministrator restart the server, but he forgets to enable the CLIENT_POLICIES feature for some reason (For example he is migrating from one environment to another and startup commands are slightly different etc).\nClient policies now won't be triggered at all, which can result in some potential unexpected issues (in theory even security issues).\n\nDo we want some better protection against this scenario? For example if CLIENT_POLICIES feature is not enabled, BUT there are some client policies in the DB, then throw the exception at startup - or at least big warning.\nI've just checked that for example WebAuthn works this way (If there is WebAuthn feature disabled BUT WebAuthn required action is registered in the realm, then the exception is thrown during attempt to authenticate user).", "author": "mposolda", "createdAt": "2020-07-16T17:29:19Z", "path": "services/src/main/java/org/keycloak/services/clientpolicy/DefaultClientPolicyManager.java", "diffHunk": "@@ -0,0 +1,156 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.keycloak.services.clientpolicy;\n+\n+import java.util.HashMap;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.common.Profile;\n+import org.keycloak.component.ComponentModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.services.clientpolicy.ClientPolicyContext;\n+import org.keycloak.services.clientpolicy.ClientPolicyException;\n+import org.keycloak.services.clientpolicy.ClientPolicyManager;\n+import org.keycloak.services.clientpolicy.ClientPolicyProvider;\n+import org.keycloak.services.clientpolicy.condition.ClientPolicyConditionProvider;\n+import org.keycloak.services.clientpolicy.executor.ClientPolicyExecutorProvider;\n+\n+public class DefaultClientPolicyManager implements ClientPolicyManager {\n+\n+    private static final Logger logger = Logger.getLogger(DefaultClientPolicyManager.class);\n+\n+    private final KeycloakSession session;\n+    private final Map<String, List<ClientPolicyProvider>> providersMap = new HashMap<>();\n+\n+    public DefaultClientPolicyManager(KeycloakSession session) {\n+        this.session = session;\n+    }\n+\n+    @Override\n+    public void triggerOnEvent(ClientPolicyContext context) throws ClientPolicyException {\n+        if (!Profile.isFeatureEnabled(Profile.Feature.CLIENT_POLICIES)) return;", "originalCommit": "35a6a86b15d709bad843a57a3bf91191e43930d7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjM0NDc2Ng==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r456344766", "bodyText": "@mposolda  Right now the client policies are preview, so the reason why there's a profile guard. I think when we mark it as supported we'd just remove it from the profile and have it always on. Since it's preview some great care should be considered before using it in production. With that in mind I don't think we need to introduce any extra guards, and can consider that in the future when we mark it as supported if we want to keep it as a feature that can be enabled/disabled. Does that work for you?", "author": "stianst", "createdAt": "2020-07-17T09:58:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk1Mjg5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjQyMzYwOA==", "url": "https://github.com/keycloak/keycloak/pull/7104#discussion_r456423608", "bodyText": "Yes, this is not the reason to block this PR in my opinion.\nThis is probably not specific to this PR, but rather a general thing. I am not sure if some better care should be taken for various features/profiles to be enabled, configured and then accidentally disabled after migration to another environment. I can see the potential for unexpected issues and some of them even security related. But maybe I am just overthinking this :) We can see if someone reports some similar issue in the future...", "author": "mposolda", "createdAt": "2020-07-17T12:54:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTk1Mjg5MA=="}], "type": "inlineReview"}, {"oid": "ec158b896517ad47df7d196319bb35b9cdf9d3c4", "url": "https://github.com/keycloak/keycloak/commit/ec158b896517ad47df7d196319bb35b9cdf9d3c4", "message": "KEYCLOAK-14189 Client Policy : Basics", "committedDate": "2020-07-20T07:55:58Z", "type": "commit"}, {"oid": "ec158b896517ad47df7d196319bb35b9cdf9d3c4", "url": "https://github.com/keycloak/keycloak/commit/ec158b896517ad47df7d196319bb35b9cdf9d3c4", "message": "KEYCLOAK-14189 Client Policy : Basics", "committedDate": "2020-07-20T07:55:58Z", "type": "forcePushed"}]}