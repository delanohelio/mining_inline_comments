{"pr_number": 7679, "pr_title": "KEYCLOAK-12137 OpenID Connect Client Initiated Backchannel Authentication (CIBA)", "pr_createdAt": "2020-12-14T22:27:55Z", "pr_url": "https://github.com/keycloak/keycloak/pull/7679", "timeline": [{"oid": "84fe84e083f0e2e488d26a729401dc2175a9f73a", "url": "https://github.com/keycloak/keycloak/commit/84fe84e083f0e2e488d26a729401dc2175a9f73a", "message": "KEYCLOAK-12137 OpenID Connect Client Initiated Backchannel Authentication (CIBA)\n\nCo-authored-by: Andrii Murashkin <amu@adorsys.com.ua>", "committedDate": "2020-12-20T11:44:37Z", "type": "forcePushed"}, {"oid": "47f206a06b177d0342baf15819e4c481b19c7ef3", "url": "https://github.com/keycloak/keycloak/commit/47f206a06b177d0342baf15819e4c481b19c7ef3", "message": "KEYCLOAK-12137 OpenID Connect Client Initiated Backchannel Authentication (CIBA)\n\nCo-authored-by: Andrii Murashkin <amu@adorsys.com.ua>", "committedDate": "2020-12-23T10:08:44Z", "type": "forcePushed"}, {"oid": "466333489cd8bd510d90b698b9ef7a332a666f03", "url": "https://github.com/keycloak/keycloak/commit/466333489cd8bd510d90b698b9ef7a332a666f03", "message": "KEYCLOAK-12137 OpenID Connect Client Initiated Backchannel Authentication (CIBA)\n\nCo-authored-by: Andrii Murashkin <amu@adorsys.com.ua>", "committedDate": "2020-12-27T12:24:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTM2NTA0OA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565365048", "bodyText": "Is migrate being used here?", "author": "pedroigor", "createdAt": "2021-01-27T14:45:35Z", "path": "server-spi-private/src/main/java/org/keycloak/models/utils/DefaultAuthenticationFlows.java", "diffHunk": "@@ -378,6 +381,33 @@ public static void browserFlow(RealmModel realm, boolean migrate) {\n         realm.addAuthenticatorExecution(execution);\n     }\n \n+    public static void cibaFlow(RealmModel realm, boolean migrate) {", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Njc4NTY0MA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r576785640", "bodyText": "@pedroigor This migrate is not used. I will remove it.", "author": "tnorimat", "createdAt": "2021-02-16T12:28:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTM2NTA0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTM2ODEzOQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565368139", "bodyText": "I'm wondering if CIBAPolicy could also be used as a top-level field on the representation so that we don't need to set its properties back and forth from rep <-> model.", "author": "pedroigor", "createdAt": "2021-01-27T14:49:09Z", "path": "server-spi-private/src/main/java/org/keycloak/models/utils/ModelToRepresentation.java", "diffHunk": "@@ -394,12 +401,19 @@ public static RealmRepresentation toRepresentation(RealmModel realm, boolean int\n         rep.setWebAuthnPolicyPasswordlessAvoidSameAuthenticatorRegister(webAuthnPolicy.isAvoidSameAuthenticatorRegister());\n         rep.setWebAuthnPolicyPasswordlessAcceptableAaguids(webAuthnPolicy.getAcceptableAaguids());\n \n+        CIBAPolicy cibaPolicy = realm.getCIBAPolicy();", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzc2OTk1Nw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r567769957", "bodyText": "@pedroigor Does it mean that we do not use CIBAPolicy but instead implement getter method for each items that consist of the current CIBAPolicy directly onto RealmModel ?\n        rep.setCibaBackchannelTokenDeliveryMode(realm.getBackchannelTokenDeliveryMode());\n        rep.setCibaExpiresIn(realm.getExpiresIn());\n        rep.setCibaInterval(realm.getInterval());\n        rep.setCibaAuthRequestedUserHint(realm.getAuthRequestedUserHint());\n\nIf so, I agree on this idea.", "author": "tnorimat", "createdAt": "2021-02-01T11:59:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTM2ODEzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzgxMjQzMQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r567812431", "bodyText": "What you said is basically how we do things today. I was thinking about the opposite, where CIBA related properties are grouped within a top-level type as you did for the RealmModel.\nIt sounds like a nitpick, but we have been discussing how to improve our extensibility so that you don't need to change core components such as the representation or model, when a new feature like CIBA needs to be introduced.\nFor this concrete case, I think having CIBAPolicy in the representation (similarly as you did to the model) helps to track (at least for now, considering we are not yet there in terms of our extensibility goals) CIBA related code more easily. And a possible smother refactoring in the future.", "author": "pedroigor", "createdAt": "2021-02-01T13:10:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTM2ODEzOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI4NTQwMg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r568285402", "bodyText": "@pedroigor Thank you for the clarification. I would like to follow your idea, namely managing CIBA related properties without changing core components like representations and models.", "author": "tnorimat", "createdAt": "2021-02-02T02:47:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTM2ODEzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTM2OTc2Nw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565369767", "bodyText": "Maybe the flow could also be part of the CIBAPolicy (or maybe change its name to something more generic around CIBA settings).\nThe point here is to have better isolation and centralize changes in a single place as much as possible.", "author": "pedroigor", "createdAt": "2021-01-27T14:51:14Z", "path": "server-spi-private/src/main/java/org/keycloak/models/utils/ModelToRepresentation.java", "diffHunk": "@@ -394,12 +401,19 @@ public static RealmRepresentation toRepresentation(RealmModel realm, boolean int\n         rep.setWebAuthnPolicyPasswordlessAvoidSameAuthenticatorRegister(webAuthnPolicy.isAvoidSameAuthenticatorRegister());\n         rep.setWebAuthnPolicyPasswordlessAcceptableAaguids(webAuthnPolicy.getAcceptableAaguids());\n \n+        CIBAPolicy cibaPolicy = realm.getCIBAPolicy();\n+        rep.setCibaBackchannelTokenDeliveryMode(cibaPolicy.getBackchannelTokenDeliveryMode());\n+        rep.setCibaExpiresIn(cibaPolicy.getExpiresIn());\n+        rep.setCibaInterval(cibaPolicy.getInterval());\n+        rep.setCibaAuthRequestedUserHint(cibaPolicy.getAuthRequestedUserHint());\n+\n         if (realm.getBrowserFlow() != null) rep.setBrowserFlow(realm.getBrowserFlow().getAlias());\n         if (realm.getRegistrationFlow() != null) rep.setRegistrationFlow(realm.getRegistrationFlow().getAlias());\n         if (realm.getDirectGrantFlow() != null) rep.setDirectGrantFlow(realm.getDirectGrantFlow().getAlias());\n         if (realm.getResetCredentialsFlow() != null) rep.setResetCredentialsFlow(realm.getResetCredentialsFlow().getAlias());\n         if (realm.getClientAuthenticationFlow() != null) rep.setClientAuthenticationFlow(realm.getClientAuthenticationFlow().getAlias());\n         if (realm.getDockerAuthenticationFlow() != null) rep.setDockerAuthenticationFlow(realm.getDockerAuthenticationFlow().getAlias());\n+        if (realm.getCIBAFlow() != null) rep.setCibaFlow(realm.getCIBAFlow().getAlias());", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzc3MDk1MQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r567770951", "bodyText": "@pedroigor I see, I would like to try to centralize CIBA related items onto one part.", "author": "tnorimat", "createdAt": "2021-02-01T12:01:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTM2OTc2Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTUwMzc3Mg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565503772", "bodyText": "Why do you need to validate/convert to UUID? Isn't expected that this string will always be a uuid?", "author": "pedroigor", "createdAt": "2021-01-27T17:38:27Z", "path": "services/src/main/java/org/keycloak/protocol/ciba/utils/EarlyAccessBlockerParser.java", "diffHunk": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.utils;\n+\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.protocol.ciba.EarlyAccessBlockerStore;\n+\n+public class EarlyAccessBlockerParser {\n+\n+    private static final Logger logger = Logger.getLogger(EarlyAccessBlockerParser.class);\n+\n+    public static void persistEarlyAccessBlocker(KeycloakSession session, String id, EarlyAccessBlocker earlyAccessBlockerData, int expires_in) {\n+        if (id == null) {\n+            throw new IllegalStateException(\"ID not present in the data\");\n+        }\n+        UUID key = UUID.fromString(id);", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzc4NjQxOQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r567786419", "bodyText": "@pedroigor I've reviewed EarlyAccessBlockerStore and found that we can simply use String instead of UUID. Anyway. I would like to use UUID or String without validating/converting them.", "author": "tnorimat", "createdAt": "2021-02-01T12:27:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTUwMzc3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTUxMjI2MA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565512260", "bodyText": "You probably want to validate if decoupledAuthnRequestUri was provided otherwise you will have errors when issuing the CIBAAuthReqId to do channel you choose to authenticate the user.", "author": "pedroigor", "createdAt": "2021-01-27T17:50:29Z", "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DelegateDecoupledAuthenticationProviderFactory.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import org.keycloak.Config.Scope;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.KeycloakSessionFactory;\n+\n+public class DelegateDecoupledAuthenticationProviderFactory implements DecoupledAuthenticationProviderFactory {\n+\n+    public static final String PROVIDER_ID = \"delegate-decoupled-authn\";\n+\n+    private String decoupledAuthenticationRequestUri;\n+\n+    @Override\n+    public DecoupledAuthenticationProvider create(KeycloakSession session) {\n+        return new DelegateDecoupledAuthenticationProvider(session, decoupledAuthenticationRequestUri);\n+    }\n+\n+    @Override\n+    public void init(Scope config) {\n+        decoupledAuthenticationRequestUri = config.get(\"decoupledAuthnRequestUri\");", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzc5MzE3MA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r567793170", "bodyText": "@pedroigor I see, I would like to send the appropriate error on DelegateDecoupledAuthenticationProvider.doBackchannelAuthentication() if valid decoupledAuthnRequestUri  is not provided.", "author": "tnorimat", "createdAt": "2021-02-01T12:38:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTUxMjI2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTUxMzkyNw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565513927", "bodyText": "Maybe we can change this class to HTTPAuthenticationProvider?\nOr maybe, introduce the concept of an authentication channel and have HttpAuthenticationChannel.", "author": "pedroigor", "createdAt": "2021-01-27T17:52:55Z", "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DelegateDecoupledAuthenticationProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.broker.provider.util.SimpleHttp;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.CIBAAuthReqId;\n+import org.keycloak.protocol.ciba.CIBAConstants;\n+import org.keycloak.protocol.ciba.endpoints.request.BackchannelAuthenticationRequest;\n+import org.keycloak.protocol.ciba.resolvers.CIBALoginUserResolver;\n+import org.keycloak.protocol.ciba.utils.CIBAAuthReqIdParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+\n+public class DelegateDecoupledAuthenticationProvider extends DecoupledAuthenticationProviderBase {", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzYxMDExMw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r567610113", "bodyText": "@pedroigor Yes, as mentioned below, I would like to introduce the concept Authentication Channel and provides HTTPAuthenticationChannel implementing AuthenticationChannelProvider for current DelegateDecoupledAuthenticationProvider .", "author": "tnorimat", "createdAt": "2021-02-01T07:30:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTUxMzkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTUxODU2Ng==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565518566", "bodyText": "I think it makes more sense to have the concept of authentication channel. Here we would rename the provider to AuthenticationChannelProvider, AuthenticationChannelProviderFactory, and AuthenticationChannelSPI.\nThe method could be just requestAuthentication. Or something more meaningful to indicate that we are actually requesting the choosed authentication channel to authenticate/authorize a user request.", "author": "pedroigor", "createdAt": "2021-01-27T17:59:14Z", "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProvider.java", "diffHunk": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.protocol.ciba.endpoints.request.BackchannelAuthenticationRequest;\n+import org.keycloak.provider.Provider;\n+\n+/**\n+ * Provides the interface for requesting the authentication(AuthN) and authorization(AuthZ) by an authentication device (AD) to the external entity called Decoupled Authentication Server.\n+ * This interface is for Client Initiated Backchannel Authentication(CIBA).\n+ *\n+ */\n+public interface DecoupledAuthenticationProvider extends Provider {", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzYwODM4Ng==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r567608386", "bodyText": "@pedroigor I see, I would like to introduce the concept \"Authentication Channel\" you suggested and create AuthenticationChannelProvider, AuthenticationChannelProviderFactory, and AuthenticationChannelSPI I would be happy if you review them afterwards.", "author": "tnorimat", "createdAt": "2021-02-01T07:26:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTUxODU2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTUyNjU3Mg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565526572", "bodyText": "In case you have a status other than 200, such as 404, 500, or any other that indicates that the chosen channel did not receive the authentication request, shouldn't we fail?\nAlso, the contract is not clear to me in regards to the expected response from the channel. Wouldn't be better to enforce a specific status code? Probably 201 (created) ?", "author": "pedroigor", "createdAt": "2021-01-27T18:11:17Z", "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DelegateDecoupledAuthenticationProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.broker.provider.util.SimpleHttp;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.CIBAAuthReqId;\n+import org.keycloak.protocol.ciba.CIBAConstants;\n+import org.keycloak.protocol.ciba.endpoints.request.BackchannelAuthenticationRequest;\n+import org.keycloak.protocol.ciba.resolvers.CIBALoginUserResolver;\n+import org.keycloak.protocol.ciba.utils.CIBAAuthReqIdParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+\n+public class DelegateDecoupledAuthenticationProvider extends DecoupledAuthenticationProviderBase {\n+\n+    private static final Logger logger = Logger.getLogger(DelegateDecoupledAuthenticationProvider.class);\n+\n+    private final String decoupledAuthenticationRequestUri;\n+\n+    public DelegateDecoupledAuthenticationProvider(KeycloakSession session, String decoupledAuthenticationRequestUri) {\n+        super(session);\n+        this.decoupledAuthenticationRequestUri = decoupledAuthenticationRequestUri;\n+    }\n+\n+    private String scope;\n+    private String userSessionIdWillBeCreated;\n+    private String userIdToBeAuthenticated;\n+    private String authResultId;\n+    private int expiration;\n+\n+    @Override\n+    protected String getScope() {\n+        return scope;\n+    }\n+\n+    @Override\n+    protected String getUserSessionIdWillBeCreated() {\n+        return userSessionIdWillBeCreated;\n+    }\n+\n+    @Override\n+    protected String getUserIdToBeAuthenticated() {\n+        return userIdToBeAuthenticated;\n+    }\n+\n+    @Override\n+    protected String getAuthResultId() {\n+        return authResultId;\n+    }\n+\n+    @Override\n+    protected int getExpiration() {\n+        return expiration;\n+    }\n+\n+    @Override\n+    protected Response verifyDecoupledAuthnResult() {\n+        String decoupledAuthId = formParams.getFirst(DelegateDecoupledAuthenticationProvider.DECOUPLED_AUTHN_ID);\n+        ParseResult parseResult = parseDecoupledAuthId(session, decoupledAuthId, event);\n+\n+        if (parseResult.isIllegalDecoupledAuthId()) {\n+            event.error(Errors.INVALID_INPUT);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.UNKNOWN);\n+            // decoupled auth id format is invalid or it has already been used\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"invalid decoupled authn id\", Response.Status.BAD_REQUEST);\n+        } else if (parseResult.isExpiredDecoupledAuthId()) {\n+            event.error(Errors.SESSION_EXPIRED);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.EXPIRED);\n+            return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+        }\n+\n+        CIBAAuthReqId decoupledAuthIdJwt = parseResult.decoupledAuthIdJwt();\n+        authResultId = decoupledAuthIdJwt.getAuthResultId();\n+        scope = decoupledAuthIdJwt.getScope();\n+        expiration = decoupledAuthIdJwt.getExp().intValue();\n+        userSessionIdWillBeCreated = decoupledAuthIdJwt.getSessionState();\n+        userIdToBeAuthenticated = decoupledAuthIdJwt.getSubject();\n+        // to bind Client Session of CD(Consumption Device) with User Session, set CD's Client Model to this class member \"client\".\n+        client = realm.getClientByClientId(decoupledAuthIdJwt.getIssuedFor());\n+\n+        CIBALoginUserResolver resolver = session.getProvider(CIBALoginUserResolver.class);\n+        if (resolver == null) {\n+            throw new RuntimeException(\"CIBA Login User Resolver not setup properly.\");\n+        }\n+        String userIdAuthenticated = resolver.getUserFromInfoUsedByAuthentication(formParams.getFirst(DelegateDecoupledAuthenticationProvider.DECOUPLED_AUTHN_USER_INFO)).getId();\n+        if (!userIdToBeAuthenticated.equals(userIdAuthenticated)) {\n+            event.error(Errors.DIFFERENT_USER_AUTHENTICATED);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.DIFFERENT);\n+            return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+        }\n+\n+        String authResult = formParams.getFirst(DelegateDecoupledAuthenticationProvider.DECOUPLED_AUTHN_RESULT);\n+        if (authResult == null) {\n+            event.error(Errors.INVALID_INPUT);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.UNKNOWN);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"authentication result not specified\", Response.Status.BAD_REQUEST);\n+        } else if (authResult.equals(DecoupledAuthStatus.FAILED)) {\n+            event.error(Errors.NOT_LOGGED_IN);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.FAILED);\n+        } else if (authResult.equals(DecoupledAuthStatus.CANCELLED)) {\n+            event.error(Errors.NOT_ALLOWED);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.CANCELLED);\n+        } else if (authResult.equals(DecoupledAuthStatus.UNAUTHORIZED)) {\n+            event.error(Errors.CONSENT_DENIED);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.UNAUTHORIZED);\n+        } else if (authResult.equals(DecoupledAuthStatus.SUCCEEDED)) {\n+            return null;\n+        } else {\n+            event.error(Errors.INVALID_INPUT);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.UNKNOWN);\n+        }\n+        return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+    }\n+\n+    @Override\n+    public void doBackchannelAuthentication(ClientModel client, BackchannelAuthenticationRequest request, int expiresIn, String authResultId, String userSessionIdWillBeCreated) {\n+        // create JWT formatted/JWS signed/JWE encrypted Decoupled Auth ID by the same manner in creating auth_req_id\n+        // Decoupled Auth ID binds Backchannel Authentication Request with Authentication by AD(Authentication Device).\n+        // By including userSessionIdWillBeCreated. keycloak can create UserSession whose ID is userSessionIdWillBeCreated on Decoupled Authentication Callback Endpoint,\n+        // which can bind userSessionIdWillBeCreated (namely, Backchannel Authentication Request) with authenticated UserSession.\n+        // By including authResultId, keycloak can create Decoupled Authentication Result of Authentication by AD on Decoupled Authentication Callback Endpoint,\n+        // which can bind authResultId with Decoupled Authentication Result of Authentication by AD.\n+        // By including client_id, Decoupled Authentication Callback Endpoint can recognize the CD(Consumption Device) who sent Backchannel Authentication Request.\n+\n+        // The following scopes should be displayed on AD(Authentication Device):\n+        // 1. scopes specified explicitly as query parameter in the authorization request\n+        // 2. scopes specified implicitly as default client scope in keycloak\n+        CIBALoginUserResolver resolver = session.getProvider(CIBALoginUserResolver.class);\n+        if (resolver == null) {\n+            throw new RuntimeException(\"CIBA Login User Resolver not setup properly.\");\n+        }\n+        String authRequestedUserHint = realm.getCIBAPolicy().getAuthRequestedUserHint();\n+        UserModel user = null;\n+        if (authRequestedUserHint.equals(CIBAConstants.LOGIN_HINT)) {\n+            user = resolver.getUserFromLoginHint(request.getLoginHint());\n+        } else if (authRequestedUserHint.equals(CIBAConstants.ID_TOKEN_HINT)) {\n+            user = resolver.getUserFromLoginHint(request.getIdTokenHint());\n+        } else if (authRequestedUserHint.equals(CIBAConstants.LOGIN_HINT_TOKEN)) {\n+            user = resolver.getUserFromLoginHint(request.getLoginHintToken());\n+        } else {\n+            throw new RuntimeException(\"CIBA invalid Authentication Requested User Hint.\");\n+        }\n+        String infoUsedByAuthentication = resolver.getInfoUsedByAuthentication(user);\n+\n+        StringBuilder scopeBuilder = new StringBuilder();\n+        Map<String, ClientScopeModel> defaultScopesMap = client.getClientScopes(true, true);\n+        defaultScopesMap.forEach((key, value)->{if (value.isDisplayOnConsentScreen()) scopeBuilder.append(value.getName()).append(\" \");});\n+        String defaultClientScope = scopeBuilder.toString();\n+\n+        CIBAAuthReqId decoupledAuthIdJwt = new CIBAAuthReqId();\n+        decoupledAuthIdJwt.id(KeycloakModelUtils.generateId());\n+        decoupledAuthIdJwt.setScope(request.getScope());\n+        decoupledAuthIdJwt.setSessionState(userSessionIdWillBeCreated);\n+        decoupledAuthIdJwt.setAuthResultId(authResultId);\n+        decoupledAuthIdJwt.issuedNow();\n+        decoupledAuthIdJwt.issuer(Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()));\n+        decoupledAuthIdJwt.audience(decoupledAuthIdJwt.getIssuer());\n+        decoupledAuthIdJwt.subject(user.getId());\n+        decoupledAuthIdJwt.exp(Long.valueOf(Time.currentTime() + expiresIn));\n+        //decoupledAuthIdJwt.issuedFor(Decoupled Auth Server's client_id); TODO\n+        decoupledAuthIdJwt.issuedFor(client.getClientId()); // TODO : set CD's client_id intentionally, not Decoupled Auth Server. It is not good idea so that client_id field should be added.\n+        String decoupledAuthId = CIBAAuthReqIdParser.persistAuthReqId(session, decoupledAuthIdJwt);\n+\n+        logger.info(\"  decoupledAuthnRequestUri = \" + decoupledAuthenticationRequestUri);\n+        try {\n+            int status = SimpleHttp.doPost(decoupledAuthenticationRequestUri, session)\n+                .param(DECOUPLED_AUTHN_ID, decoupledAuthId)\n+                .param(DECOUPLED_AUTHN_USER_INFO, infoUsedByAuthentication)\n+                .param(DECOUPLED_AUTHN_IS_CONSENT_REQUIRED, Boolean.toString(client.isConsentRequired()))\n+                .param(CIBAConstants.SCOPE, request.getScope())\n+                .param(DECOUPLED_DEFAULT_CLIENT_SCOPE, defaultClientScope)\n+                .param(CIBAConstants.BINDING_MESSAGE, request.getBindingMessage())\n+                .asStatus();\n+            logger.info(\"  Decoupled Authn Request URI Access = \" + status);\n+            if (status != 200) {", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzgwODg5Mg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r567808892", "bodyText": "@pedroigor As you said, we would want to fail the backchannel authentication request when we received some error response from the decoupled authentication server, namely received status code other than 200. However, at this time, we has already sent the backchannel authentication response to the client (consumption device) so that we could not tell the client this error response.\nAs for the status code for successful response from the decoupled authentication server, I agree with you. I would like to use 201 instead of 200.", "author": "tnorimat", "createdAt": "2021-02-01T13:05:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTUyNjU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTUyODQ4Mg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565528482", "bodyText": "I agree it is not a good idea.\nIMO, having the authentication channel as a client in Keycloak is probably the best way to go. We could potentially use different authentication methods when sending requests to the service too.\nWe could even send signed/encrypted requests.\nThe way it is right now is not much secure, from the service perspective.\nOne more reason, I think, to make have a HttpAuthenticationChannel so that we can use different forms of HTTP Authentication/Authorization, even if only BASIC.", "author": "pedroigor", "createdAt": "2021-01-27T18:14:16Z", "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DelegateDecoupledAuthenticationProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.broker.provider.util.SimpleHttp;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.CIBAAuthReqId;\n+import org.keycloak.protocol.ciba.CIBAConstants;\n+import org.keycloak.protocol.ciba.endpoints.request.BackchannelAuthenticationRequest;\n+import org.keycloak.protocol.ciba.resolvers.CIBALoginUserResolver;\n+import org.keycloak.protocol.ciba.utils.CIBAAuthReqIdParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+\n+public class DelegateDecoupledAuthenticationProvider extends DecoupledAuthenticationProviderBase {\n+\n+    private static final Logger logger = Logger.getLogger(DelegateDecoupledAuthenticationProvider.class);\n+\n+    private final String decoupledAuthenticationRequestUri;\n+\n+    public DelegateDecoupledAuthenticationProvider(KeycloakSession session, String decoupledAuthenticationRequestUri) {\n+        super(session);\n+        this.decoupledAuthenticationRequestUri = decoupledAuthenticationRequestUri;\n+    }\n+\n+    private String scope;\n+    private String userSessionIdWillBeCreated;\n+    private String userIdToBeAuthenticated;\n+    private String authResultId;\n+    private int expiration;\n+\n+    @Override\n+    protected String getScope() {\n+        return scope;\n+    }\n+\n+    @Override\n+    protected String getUserSessionIdWillBeCreated() {\n+        return userSessionIdWillBeCreated;\n+    }\n+\n+    @Override\n+    protected String getUserIdToBeAuthenticated() {\n+        return userIdToBeAuthenticated;\n+    }\n+\n+    @Override\n+    protected String getAuthResultId() {\n+        return authResultId;\n+    }\n+\n+    @Override\n+    protected int getExpiration() {\n+        return expiration;\n+    }\n+\n+    @Override\n+    protected Response verifyDecoupledAuthnResult() {\n+        String decoupledAuthId = formParams.getFirst(DelegateDecoupledAuthenticationProvider.DECOUPLED_AUTHN_ID);\n+        ParseResult parseResult = parseDecoupledAuthId(session, decoupledAuthId, event);\n+\n+        if (parseResult.isIllegalDecoupledAuthId()) {\n+            event.error(Errors.INVALID_INPUT);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.UNKNOWN);\n+            // decoupled auth id format is invalid or it has already been used\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"invalid decoupled authn id\", Response.Status.BAD_REQUEST);\n+        } else if (parseResult.isExpiredDecoupledAuthId()) {\n+            event.error(Errors.SESSION_EXPIRED);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.EXPIRED);\n+            return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+        }\n+\n+        CIBAAuthReqId decoupledAuthIdJwt = parseResult.decoupledAuthIdJwt();\n+        authResultId = decoupledAuthIdJwt.getAuthResultId();\n+        scope = decoupledAuthIdJwt.getScope();\n+        expiration = decoupledAuthIdJwt.getExp().intValue();\n+        userSessionIdWillBeCreated = decoupledAuthIdJwt.getSessionState();\n+        userIdToBeAuthenticated = decoupledAuthIdJwt.getSubject();\n+        // to bind Client Session of CD(Consumption Device) with User Session, set CD's Client Model to this class member \"client\".\n+        client = realm.getClientByClientId(decoupledAuthIdJwt.getIssuedFor());\n+\n+        CIBALoginUserResolver resolver = session.getProvider(CIBALoginUserResolver.class);\n+        if (resolver == null) {\n+            throw new RuntimeException(\"CIBA Login User Resolver not setup properly.\");\n+        }\n+        String userIdAuthenticated = resolver.getUserFromInfoUsedByAuthentication(formParams.getFirst(DelegateDecoupledAuthenticationProvider.DECOUPLED_AUTHN_USER_INFO)).getId();\n+        if (!userIdToBeAuthenticated.equals(userIdAuthenticated)) {\n+            event.error(Errors.DIFFERENT_USER_AUTHENTICATED);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.DIFFERENT);\n+            return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+        }\n+\n+        String authResult = formParams.getFirst(DelegateDecoupledAuthenticationProvider.DECOUPLED_AUTHN_RESULT);\n+        if (authResult == null) {\n+            event.error(Errors.INVALID_INPUT);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.UNKNOWN);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"authentication result not specified\", Response.Status.BAD_REQUEST);\n+        } else if (authResult.equals(DecoupledAuthStatus.FAILED)) {\n+            event.error(Errors.NOT_LOGGED_IN);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.FAILED);\n+        } else if (authResult.equals(DecoupledAuthStatus.CANCELLED)) {\n+            event.error(Errors.NOT_ALLOWED);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.CANCELLED);\n+        } else if (authResult.equals(DecoupledAuthStatus.UNAUTHORIZED)) {\n+            event.error(Errors.CONSENT_DENIED);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.UNAUTHORIZED);\n+        } else if (authResult.equals(DecoupledAuthStatus.SUCCEEDED)) {\n+            return null;\n+        } else {\n+            event.error(Errors.INVALID_INPUT);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.UNKNOWN);\n+        }\n+        return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+    }\n+\n+    @Override\n+    public void doBackchannelAuthentication(ClientModel client, BackchannelAuthenticationRequest request, int expiresIn, String authResultId, String userSessionIdWillBeCreated) {\n+        // create JWT formatted/JWS signed/JWE encrypted Decoupled Auth ID by the same manner in creating auth_req_id\n+        // Decoupled Auth ID binds Backchannel Authentication Request with Authentication by AD(Authentication Device).\n+        // By including userSessionIdWillBeCreated. keycloak can create UserSession whose ID is userSessionIdWillBeCreated on Decoupled Authentication Callback Endpoint,\n+        // which can bind userSessionIdWillBeCreated (namely, Backchannel Authentication Request) with authenticated UserSession.\n+        // By including authResultId, keycloak can create Decoupled Authentication Result of Authentication by AD on Decoupled Authentication Callback Endpoint,\n+        // which can bind authResultId with Decoupled Authentication Result of Authentication by AD.\n+        // By including client_id, Decoupled Authentication Callback Endpoint can recognize the CD(Consumption Device) who sent Backchannel Authentication Request.\n+\n+        // The following scopes should be displayed on AD(Authentication Device):\n+        // 1. scopes specified explicitly as query parameter in the authorization request\n+        // 2. scopes specified implicitly as default client scope in keycloak\n+        CIBALoginUserResolver resolver = session.getProvider(CIBALoginUserResolver.class);\n+        if (resolver == null) {\n+            throw new RuntimeException(\"CIBA Login User Resolver not setup properly.\");\n+        }\n+        String authRequestedUserHint = realm.getCIBAPolicy().getAuthRequestedUserHint();\n+        UserModel user = null;\n+        if (authRequestedUserHint.equals(CIBAConstants.LOGIN_HINT)) {\n+            user = resolver.getUserFromLoginHint(request.getLoginHint());\n+        } else if (authRequestedUserHint.equals(CIBAConstants.ID_TOKEN_HINT)) {\n+            user = resolver.getUserFromLoginHint(request.getIdTokenHint());\n+        } else if (authRequestedUserHint.equals(CIBAConstants.LOGIN_HINT_TOKEN)) {\n+            user = resolver.getUserFromLoginHint(request.getLoginHintToken());\n+        } else {\n+            throw new RuntimeException(\"CIBA invalid Authentication Requested User Hint.\");\n+        }\n+        String infoUsedByAuthentication = resolver.getInfoUsedByAuthentication(user);\n+\n+        StringBuilder scopeBuilder = new StringBuilder();\n+        Map<String, ClientScopeModel> defaultScopesMap = client.getClientScopes(true, true);\n+        defaultScopesMap.forEach((key, value)->{if (value.isDisplayOnConsentScreen()) scopeBuilder.append(value.getName()).append(\" \");});\n+        String defaultClientScope = scopeBuilder.toString();\n+\n+        CIBAAuthReqId decoupledAuthIdJwt = new CIBAAuthReqId();\n+        decoupledAuthIdJwt.id(KeycloakModelUtils.generateId());\n+        decoupledAuthIdJwt.setScope(request.getScope());\n+        decoupledAuthIdJwt.setSessionState(userSessionIdWillBeCreated);\n+        decoupledAuthIdJwt.setAuthResultId(authResultId);\n+        decoupledAuthIdJwt.issuedNow();\n+        decoupledAuthIdJwt.issuer(Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()));\n+        decoupledAuthIdJwt.audience(decoupledAuthIdJwt.getIssuer());\n+        decoupledAuthIdJwt.subject(user.getId());\n+        decoupledAuthIdJwt.exp(Long.valueOf(Time.currentTime() + expiresIn));\n+        //decoupledAuthIdJwt.issuedFor(Decoupled Auth Server's client_id); TODO\n+        decoupledAuthIdJwt.issuedFor(client.getClientId()); // TODO : set CD's client_id intentionally, not Decoupled Auth Server. It is not good idea so that client_id field should be added.", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODI4MTIxMw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r568281213", "bodyText": "@pedroigor I see, my understanding is that we had better to introduce the concept \"Authentication Channel\" just above whose role is to communicate between keycloak and the decouple authentication server (but not limited to) and provide several its implementation like HTTPAuthenticationChannel that can provide several security level (e.g. transport layer : HTTP only,  HTTPS  / client authentication : BASIC, X.509). Is that right?", "author": "tnorimat", "createdAt": "2021-02-02T02:34:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTUyODQ4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU1MjU2Ng==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r568552566", "bodyText": "Yeah. However, I won't push for introducing these authentication aspects right now if you think that it should be enough to document HTTPS between Keycloak and the authentication channel.\nLet's see what @mposolda thinks.", "author": "pedroigor", "createdAt": "2021-02-02T12:11:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTUyODQ4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTU3NjI4Ng==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565576286", "bodyText": "Shall we validate the inputs and avoid unexpected errors ? What happens if the form parameter is null ? I guess we want to return 400 ?", "author": "pedroigor", "createdAt": "2021-01-27T19:28:25Z", "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DelegateDecoupledAuthenticationProvider.java", "diffHunk": "@@ -0,0 +1,281 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.broker.provider.util.SimpleHttp;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.CIBAAuthReqId;\n+import org.keycloak.protocol.ciba.CIBAConstants;\n+import org.keycloak.protocol.ciba.endpoints.request.BackchannelAuthenticationRequest;\n+import org.keycloak.protocol.ciba.resolvers.CIBALoginUserResolver;\n+import org.keycloak.protocol.ciba.utils.CIBAAuthReqIdParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+\n+public class DelegateDecoupledAuthenticationProvider extends DecoupledAuthenticationProviderBase {\n+\n+    private static final Logger logger = Logger.getLogger(DelegateDecoupledAuthenticationProvider.class);\n+\n+    private final String decoupledAuthenticationRequestUri;\n+\n+    public DelegateDecoupledAuthenticationProvider(KeycloakSession session, String decoupledAuthenticationRequestUri) {\n+        super(session);\n+        this.decoupledAuthenticationRequestUri = decoupledAuthenticationRequestUri;\n+    }\n+\n+    private String scope;\n+    private String userSessionIdWillBeCreated;\n+    private String userIdToBeAuthenticated;\n+    private String authResultId;\n+    private int expiration;\n+\n+    @Override\n+    protected String getScope() {\n+        return scope;\n+    }\n+\n+    @Override\n+    protected String getUserSessionIdWillBeCreated() {\n+        return userSessionIdWillBeCreated;\n+    }\n+\n+    @Override\n+    protected String getUserIdToBeAuthenticated() {\n+        return userIdToBeAuthenticated;\n+    }\n+\n+    @Override\n+    protected String getAuthResultId() {\n+        return authResultId;\n+    }\n+\n+    @Override\n+    protected int getExpiration() {\n+        return expiration;\n+    }\n+\n+    @Override\n+    protected Response verifyDecoupledAuthnResult() {\n+        String decoupledAuthId = formParams.getFirst(DelegateDecoupledAuthenticationProvider.DECOUPLED_AUTHN_ID);\n+        ParseResult parseResult = parseDecoupledAuthId(session, decoupledAuthId, event);\n+\n+        if (parseResult.isIllegalDecoupledAuthId()) {\n+            event.error(Errors.INVALID_INPUT);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.UNKNOWN);\n+            // decoupled auth id format is invalid or it has already been used\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"invalid decoupled authn id\", Response.Status.BAD_REQUEST);\n+        } else if (parseResult.isExpiredDecoupledAuthId()) {\n+            event.error(Errors.SESSION_EXPIRED);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.EXPIRED);\n+            return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+        }\n+\n+        CIBAAuthReqId decoupledAuthIdJwt = parseResult.decoupledAuthIdJwt();\n+        authResultId = decoupledAuthIdJwt.getAuthResultId();\n+        scope = decoupledAuthIdJwt.getScope();\n+        expiration = decoupledAuthIdJwt.getExp().intValue();\n+        userSessionIdWillBeCreated = decoupledAuthIdJwt.getSessionState();\n+        userIdToBeAuthenticated = decoupledAuthIdJwt.getSubject();\n+        // to bind Client Session of CD(Consumption Device) with User Session, set CD's Client Model to this class member \"client\".\n+        client = realm.getClientByClientId(decoupledAuthIdJwt.getIssuedFor());\n+\n+        CIBALoginUserResolver resolver = session.getProvider(CIBALoginUserResolver.class);\n+        if (resolver == null) {\n+            throw new RuntimeException(\"CIBA Login User Resolver not setup properly.\");\n+        }\n+        String userIdAuthenticated = resolver.getUserFromInfoUsedByAuthentication(formParams.getFirst(DelegateDecoupledAuthenticationProvider.DECOUPLED_AUTHN_USER_INFO)).getId();", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzgyMjAyNA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r567822024", "bodyText": "@pedroigor Yes, this current codes assumed that \"user_info\" must be sent from the decoupled authentication server. I would like to add the check logic and returns the error response to the decoupled authentication server with 400.", "author": "tnorimat", "createdAt": "2021-02-01T13:25:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTU3NjI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTU4ODcyNA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565588724", "bodyText": "We should probably check whether username is null to avoid NPE.", "author": "pedroigor", "createdAt": "2021-01-27T19:48:37Z", "path": "services/src/main/java/org/keycloak/authentication/authenticators/ciba/CIBADecoupledAuthenticator.java", "diffHunk": "@@ -0,0 +1,78 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.authentication.authenticators.ciba;\n+\n+import org.jboss.logging.Logger;\n+\n+import org.keycloak.authentication.AuthenticationFlowContext;\n+import org.keycloak.authentication.AuthenticationFlowError;\n+import org.keycloak.authentication.Authenticator;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.CIBAConstants;\n+\n+public class CIBADecoupledAuthenticator implements Authenticator {\n+\n+    private static final Logger logger = Logger.getLogger(CIBADecoupledAuthenticator.class);\n+\n+    @Override\n+    public void authenticate(AuthenticationFlowContext context) {\n+        String userIdField = context.getAuthenticatorConfig().getConfig().get(CIBADecoupledAuthenticatorFactory.DEFAULT_USERID_FIELD);\n+        if (userIdField == null) userIdField = CIBAConstants.LOGIN_HINT;\n+        String username = context.getHttpRequest().getDecodedFormParameters().getFirst(userIdField);\n+\n+        logger.info(\"username = \" + username);\n+        UserModel user = KeycloakModelUtils.findUserByNameOrEmail(context.getSession(), context.getRealm(), username);", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzgwOTY2Mw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r567809663", "bodyText": "@pedroigor Yes, I would like to add check logic for username.", "author": "tnorimat", "createdAt": "2021-02-01T13:06:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTU4ODcyNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYwNzY4MA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565607680", "bodyText": "I think expires_in is in milliseconds and the provider is going to set expiration based on seconds. That would cause entries to take a lot of time to expire, and not really what you are expected.\nSee \n  \n    \n      keycloak/model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanCodeToTokenStoreProvider.java\n    \n    \n         Line 54\n      in\n      80f4bd3\n    \n    \n    \n    \n\n        \n          \n           cache.put(codeId, tokenValue, lifespanSeconds, TimeUnit.SECONDS); \n        \n    \n  \n\n.", "author": "pedroigor", "createdAt": "2021-01-27T20:21:30Z", "path": "services/src/main/java/org/keycloak/protocol/ciba/utils/DecoupledAuthnResultParser.java", "diffHunk": "@@ -0,0 +1,110 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.utils;\n+\n+import java.util.Map;\n+import java.util.UUID;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.models.CodeToTokenStoreProvider;\n+import org.keycloak.models.KeycloakSession;\n+\n+public class DecoupledAuthnResultParser {\n+\n+    private static final Logger logger = Logger.getLogger(DecoupledAuthnResultParser.class);\n+\n+    public static void persistDecoupledAuthnResult(KeycloakSession session, String id, DecoupledAuthnResult decoupledAuthnResultData, int expires_in) {\n+        CodeToTokenStoreProvider codeStore = session.getProvider(CodeToTokenStoreProvider.class);\n+\n+        if (id == null) {\n+            throw new IllegalStateException(\"ID not present in the data\");\n+        }\n+        UUID key = UUID.fromString(id);\n+\n+        Map<String, String> serialized = decoupledAuthnResultData.serializeCode();\n+        codeStore.put(key, expires_in, serialized);", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2Nzg0NDk2NQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r567844965", "bodyText": "@pedroigor I've supposed that this expires_in is in seconds. And I've written codes for treating it in seconds. I could not found out the point I've treated this expires_in in milliseconds.", "author": "tnorimat", "createdAt": "2021-02-01T13:59:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYwNzY4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2ODU1MzAwNg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r568553006", "bodyText": "Sorry, maybe I read the code too quickly then.", "author": "pedroigor", "createdAt": "2021-02-02T12:11:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYwNzY4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYxMzczNQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r565613735", "bodyText": "Maybe a LinkedHashMap makes sense here so we could bound the map to size and avoid memory leaks.\nIt should also be possible to remove the eldest entry more easily. Instead of iterating over entries (mainly if it is expected a potential growth in entries).", "author": "pedroigor", "createdAt": "2021-01-27T20:32:00Z", "path": "services/src/main/java/org/keycloak/protocol/ciba/EarlyAccessBlockerStore.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba;\n+\n+import java.util.Map;\n+import java.util.UUID;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+import org.keycloak.common.util.Time;\n+import org.keycloak.protocol.ciba.utils.EarlyAccessBlocker;\n+\n+public class EarlyAccessBlockerStore {\n+\n+    private final static ConcurrentMap<UUID, EarlyAccessBlockerValueEntity> blockerCache = new ConcurrentHashMap<>();", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NzgzMTg2Ng==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r567831866", "bodyText": "@pedroigor Thank you. I would like to try to use LinkedHashMap.", "author": "tnorimat", "createdAt": "2021-02-01T13:39:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU2NTYxMzczNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY4NzQxNg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575687416", "bodyText": "Here, NumberFormatException will happen if expiresIn is empty string \"\". Suggest to create some utility method\nstatic bool isNotBlank(String str) {\n    return str != null && !str.isEmpty();\n}\n\nand use it instead expiresIn != null", "author": "valb3r", "createdAt": "2021-02-13T16:51:19Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java", "diffHunk": "@@ -1061,6 +1061,46 @@ private void setWebAuthnPolicy(WebAuthnPolicy policy, String attributePrefix) {\n         }\n     }\n \n+    @Override\n+    public CIBAPolicy getCIBAPolicy() {\n+        CIBAPolicy policy = new CIBAPolicy();\n+\n+        String backchannelTokenDeliveryMode = getAttribute(RealmAttributes.CIBA_BACKCHANNEL_TOKENDELIVERY_MODE);\n+        if (backchannelTokenDeliveryMode == null || backchannelTokenDeliveryMode.isEmpty())\n+            backchannelTokenDeliveryMode = Constants.DEFAULT_CIBA_POLICY_TOKEN_DELIVERY_MODE;\n+        policy.setBackchannelTokenDeliveryMode(backchannelTokenDeliveryMode);\n+\n+        String expiresIn = getAttribute(RealmAttributes.CIBA_EXPIRES_IN);\n+        if (expiresIn != null) policy.setExpiresIn(Integer.parseInt(expiresIn));", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjYyMzA1OQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r576623059", "bodyText": "@valb3r Thanks. I'll create org.keycloak.utils.StringUtil in keycloak-server-spi project and provide isNotBlank and isBlank.", "author": "tnorimat", "createdAt": "2021-02-16T08:14:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY4NzQxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY4NzQ1NQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575687455", "bodyText": "Here, NumberFormatException will happen if interval is empty string \"\". Suggest to create some utility method\nstatic bool isNotBlank(String str) {\n    return str != null && !str.isEmpty();\n}\n\nand use it instead interval != null", "author": "valb3r", "createdAt": "2021-02-13T16:51:41Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java", "diffHunk": "@@ -1061,6 +1061,46 @@ private void setWebAuthnPolicy(WebAuthnPolicy policy, String attributePrefix) {\n         }\n     }\n \n+    @Override\n+    public CIBAPolicy getCIBAPolicy() {\n+        CIBAPolicy policy = new CIBAPolicy();\n+\n+        String backchannelTokenDeliveryMode = getAttribute(RealmAttributes.CIBA_BACKCHANNEL_TOKENDELIVERY_MODE);\n+        if (backchannelTokenDeliveryMode == null || backchannelTokenDeliveryMode.isEmpty())\n+            backchannelTokenDeliveryMode = Constants.DEFAULT_CIBA_POLICY_TOKEN_DELIVERY_MODE;\n+        policy.setBackchannelTokenDeliveryMode(backchannelTokenDeliveryMode);\n+\n+        String expiresIn = getAttribute(RealmAttributes.CIBA_EXPIRES_IN);\n+        if (expiresIn != null) policy.setExpiresIn(Integer.parseInt(expiresIn));\n+        else policy.setExpiresIn(Constants.DEFAULT_CIBA_POLICY_EXPIRES_IN);\n+\n+        String interval = getAttribute(RealmAttributes.CIBA_INTERVAL);\n+        if (interval != null) policy.setInterval(Integer.parseInt(interval));", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjYyMjUyMQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r576622521", "bodyText": "@valb3r Thank you. the same above.", "author": "tnorimat", "createdAt": "2021-02-16T08:13:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY4NzQ1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY4NzU2NQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575687565", "bodyText": "Suggest to use create and use isBlank utility method instead of authRequestedUserHint == null || authRequestedUserHint.isEmpty() as the same check is done at\nhttps://github.com/keycloak/keycloak/pull/7679/files#diff-170c22cf3ea1d9f1e8150ebd8220d3dfdc27d411c26e005bd4b45d3e7e716e03R1069", "author": "valb3r", "createdAt": "2021-02-13T16:53:09Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java", "diffHunk": "@@ -1061,6 +1061,46 @@ private void setWebAuthnPolicy(WebAuthnPolicy policy, String attributePrefix) {\n         }\n     }\n \n+    @Override\n+    public CIBAPolicy getCIBAPolicy() {\n+        CIBAPolicy policy = new CIBAPolicy();\n+\n+        String backchannelTokenDeliveryMode = getAttribute(RealmAttributes.CIBA_BACKCHANNEL_TOKENDELIVERY_MODE);\n+        if (backchannelTokenDeliveryMode == null || backchannelTokenDeliveryMode.isEmpty())\n+            backchannelTokenDeliveryMode = Constants.DEFAULT_CIBA_POLICY_TOKEN_DELIVERY_MODE;\n+        policy.setBackchannelTokenDeliveryMode(backchannelTokenDeliveryMode);\n+\n+        String expiresIn = getAttribute(RealmAttributes.CIBA_EXPIRES_IN);\n+        if (expiresIn != null) policy.setExpiresIn(Integer.parseInt(expiresIn));\n+        else policy.setExpiresIn(Constants.DEFAULT_CIBA_POLICY_EXPIRES_IN);\n+\n+        String interval = getAttribute(RealmAttributes.CIBA_INTERVAL);\n+        if (interval != null) policy.setInterval(Integer.parseInt(interval));\n+        else policy.setInterval(Constants.DEFAULT_CIBA_POLICY_INTERVAL);\n+\n+        String authRequestedUserHint = getAttribute(RealmAttributes.CIBA_AUTH_REQUESTED_USER_HINT);\n+        if (authRequestedUserHint == null || authRequestedUserHint.isEmpty())", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjYyMzQzNQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r576623435", "bodyText": "@valb3r Thank you. the same above.", "author": "tnorimat", "createdAt": "2021-02-16T08:15:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY4NzU2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY4NzY4NA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575687684", "bodyText": "Suggest to create isBlank utility method for this check", "author": "valb3r", "createdAt": "2021-02-13T16:54:15Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java", "diffHunk": "@@ -1061,6 +1061,46 @@ private void setWebAuthnPolicy(WebAuthnPolicy policy, String attributePrefix) {\n         }\n     }\n \n+    @Override\n+    public CIBAPolicy getCIBAPolicy() {\n+        CIBAPolicy policy = new CIBAPolicy();\n+\n+        String backchannelTokenDeliveryMode = getAttribute(RealmAttributes.CIBA_BACKCHANNEL_TOKENDELIVERY_MODE);\n+        if (backchannelTokenDeliveryMode == null || backchannelTokenDeliveryMode.isEmpty())", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjYyNDM3MQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r576624371", "bodyText": "@valb3r Thank you. the same above.", "author": "tnorimat", "createdAt": "2021-02-16T08:17:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY4NzY4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5MDE0Mg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575690142", "bodyText": "Suggest to create isBlank utility method and use it here to check if String is empty", "author": "valb3r", "createdAt": "2021-02-13T17:16:38Z", "path": "server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java", "diffHunk": "@@ -285,6 +286,28 @@ public static void importRealm(KeycloakSession session, RealmRepresentation rep,\n         webAuthnPolicy = getWebAuthnPolicyPasswordless(rep);\n         newRealm.setWebAuthnPolicyPasswordless(webAuthnPolicy);\n \n+        CIBAPolicy cibaPolicy = new CIBAPolicy();\n+\n+        String cibaBackchannelTokenDeliveryMode = rep.getCibaBackchannelTokenDeliveryMode();\n+        if (cibaBackchannelTokenDeliveryMode == null || cibaBackchannelTokenDeliveryMode.isEmpty())", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjcwMTIyNQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r576701225", "bodyText": "@valb3r Thank you. the same above.", "author": "tnorimat", "createdAt": "2021-02-16T10:09:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5MDE0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5MDE0Nw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575690147", "bodyText": "Suggest to create isBlank utility method and use it here to check if String is empty", "author": "valb3r", "createdAt": "2021-02-13T17:16:48Z", "path": "server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java", "diffHunk": "@@ -285,6 +286,28 @@ public static void importRealm(KeycloakSession session, RealmRepresentation rep,\n         webAuthnPolicy = getWebAuthnPolicyPasswordless(rep);\n         newRealm.setWebAuthnPolicyPasswordless(webAuthnPolicy);\n \n+        CIBAPolicy cibaPolicy = new CIBAPolicy();\n+\n+        String cibaBackchannelTokenDeliveryMode = rep.getCibaBackchannelTokenDeliveryMode();\n+        if (cibaBackchannelTokenDeliveryMode == null || cibaBackchannelTokenDeliveryMode.isEmpty())\n+            cibaBackchannelTokenDeliveryMode = Constants.DEFAULT_CIBA_POLICY_TOKEN_DELIVERY_MODE;\n+        cibaPolicy.setBackchannelTokenDeliveryMode(cibaBackchannelTokenDeliveryMode);\n+\n+        Integer cibaExpiresIn = rep.getCibaExpiresIn();\n+        if (cibaExpiresIn != null) cibaPolicy.setExpiresIn(cibaExpiresIn);\n+        else cibaPolicy.setExpiresIn(Constants.DEFAULT_CIBA_POLICY_EXPIRES_IN);\n+\n+        Integer cibaInterval = rep.getCibaInterval();\n+        if (cibaInterval != null) cibaPolicy.setInterval(cibaInterval);\n+        else cibaPolicy.setInterval(Constants.DEFAULT_CIBA_POLICY_INTERVAL);\n+\n+        String cibaAuthRequestedUserHint = rep.getCibaAuthRequestedUserHint();\n+        if (cibaAuthRequestedUserHint == null || cibaAuthRequestedUserHint.isEmpty())", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjcxMDY3Mg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r576710672", "bodyText": "@valb3r Thank you. the same above.", "author": "tnorimat", "createdAt": "2021-02-16T10:23:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5MDE0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5MTAwNg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575691006", "bodyText": "The body of the current method is already huge. Can we simply create private static method\n    private static void handleCibaFlowIfApplicable(RealmModel newRealm, RealmRepresentation rep) {\n        if (rep.getCibaFlow() == null) {\n            AuthenticationFlowModel cibaFlowModel = newRealm.getFlowByAlias(DefaultAuthenticationFlows.CIBA_FLOW);\n            if (cibaFlowModel != null) {\n                newRealm.setCIBAFlow(cibaFlowModel);\n            } else {\n                DefaultAuthenticationFlows.cibaFlow(newRealm, true);\n            }\n        } else {\n            newRealm.setCIBAFlow(newRealm.getFlowByAlias(rep.getCibaFlow()));\n        }\n    }\n\nand do simply handleCibaFlowIfApplicable(newRealm, rep); instead of this  if", "author": "valb3r", "createdAt": "2021-02-13T17:24:24Z", "path": "server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java", "diffHunk": "@@ -766,6 +789,16 @@ public static void importGroup(RealmModel realm, GroupModel parent, GroupReprese\n         } else {\n             newRealm.setDirectGrantFlow(newRealm.getFlowByAlias(rep.getDirectGrantFlow()));\n         }\n+        if (rep.getCibaFlow() == null) {", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjcyMDM1NQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r576720355", "bodyText": "@valb3r I see, I will fix codes as you suggested.", "author": "tnorimat", "createdAt": "2021-02-16T10:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5MTAwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5MTA5MA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575691090", "bodyText": "Suggest to create isBlank utility method and use it here to check if String is empty", "author": "valb3r", "createdAt": "2021-02-13T17:25:21Z", "path": "server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java", "diffHunk": "@@ -1140,6 +1173,28 @@ public static void updateRealm(RealmRepresentation rep, RealmModel realm, Keyclo\n         webAuthnPolicy = getWebAuthnPolicyPasswordless(rep);\n         realm.setWebAuthnPolicyPasswordless(webAuthnPolicy);\n \n+        CIBAPolicy cibaPolicy = new CIBAPolicy();\n+\n+        String cibaBackchannelTokenDeliveryMode = rep.getCibaBackchannelTokenDeliveryMode();\n+        if (cibaBackchannelTokenDeliveryMode == null || cibaBackchannelTokenDeliveryMode.isEmpty())", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjcyMjI1NQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r576722255", "bodyText": "@valb3r Thank you. the same above.", "author": "tnorimat", "createdAt": "2021-02-16T10:40:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5MTA5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5MTExNg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575691116", "bodyText": "Suggest to create isBlank utility method and use it here to check if String is empty", "author": "valb3r", "createdAt": "2021-02-13T17:25:36Z", "path": "server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java", "diffHunk": "@@ -1140,6 +1173,28 @@ public static void updateRealm(RealmRepresentation rep, RealmModel realm, Keyclo\n         webAuthnPolicy = getWebAuthnPolicyPasswordless(rep);\n         realm.setWebAuthnPolicyPasswordless(webAuthnPolicy);\n \n+        CIBAPolicy cibaPolicy = new CIBAPolicy();\n+\n+        String cibaBackchannelTokenDeliveryMode = rep.getCibaBackchannelTokenDeliveryMode();\n+        if (cibaBackchannelTokenDeliveryMode == null || cibaBackchannelTokenDeliveryMode.isEmpty())\n+            cibaBackchannelTokenDeliveryMode = Constants.DEFAULT_CIBA_POLICY_TOKEN_DELIVERY_MODE;\n+        cibaPolicy.setBackchannelTokenDeliveryMode(cibaBackchannelTokenDeliveryMode);\n+\n+        Integer cibaExpiresIn = rep.getCibaExpiresIn();\n+        if (cibaExpiresIn != null) cibaPolicy.setExpiresIn(cibaExpiresIn);\n+        else cibaPolicy.setExpiresIn(Constants.DEFAULT_CIBA_POLICY_EXPIRES_IN);\n+\n+        Integer cibaInterval = rep.getCibaInterval();\n+        if (cibaInterval != null) cibaPolicy.setInterval(cibaInterval);\n+        else cibaPolicy.setInterval(Constants.DEFAULT_CIBA_POLICY_INTERVAL);\n+\n+        String cibaAuthRequestedUserHint = rep.getCibaAuthRequestedUserHint();\n+        if (cibaAuthRequestedUserHint == null || cibaAuthRequestedUserHint.isEmpty())", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjcyMjc2Ng==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r576722766", "bodyText": "@valb3r Thank you. the same above.", "author": "tnorimat", "createdAt": "2021-02-16T10:41:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5MTExNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5MTgxMw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575691813", "bodyText": "The lines\nCIBAPolicy cibaPolicy = new CIBAPolicy();\n\n        String cibaBackchannelTokenDeliveryMode = rep.getCibaBackchannelTokenDeliveryMode();\n        if (cibaBackchannelTokenDeliveryMode == null || cibaBackchannelTokenDeliveryMode.isEmpty())\n            cibaBackchannelTokenDeliveryMode = Constants.DEFAULT_CIBA_POLICY_TOKEN_DELIVERY_MODE;\n        cibaPolicy.setBackchannelTokenDeliveryMode(cibaBackchannelTokenDeliveryMode);\n\n        Integer cibaExpiresIn = rep.getCibaExpiresIn();\n        if (cibaExpiresIn != null) cibaPolicy.setExpiresIn(cibaExpiresIn);\n        else cibaPolicy.setExpiresIn(Constants.DEFAULT_CIBA_POLICY_EXPIRES_IN);\n\n        Integer cibaInterval = rep.getCibaInterval();\n        if (cibaInterval != null) cibaPolicy.setInterval(cibaInterval);\n        else cibaPolicy.setInterval(Constants.DEFAULT_CIBA_POLICY_INTERVAL);\n\n        String cibaAuthRequestedUserHint = rep.getCibaAuthRequestedUserHint();\n        if (cibaAuthRequestedUserHint == null || cibaAuthRequestedUserHint.isEmpty())\n            cibaAuthRequestedUserHint = Constants.DEFAULT_CIBA_POLICY_AUTH_REQUESTED_USER_HINT;\n        cibaPolicy.setAuthRequestedUserHint(cibaAuthRequestedUserHint);\n\n        newRealm.setCIBAPolicy(cibaPolicy);\n\nseem to be duplicated at\nhttps://github.com/keycloak/keycloak/pull/7679/files#diff-bf084091e13d0b998262192910037c7cd2e5640fcd846da15299f1bdef7230c9R1176\nCan't we extract the following static private method:\n    private static void applyCibaPolicyToRealm(RealmRepresentation rep, RealmModel realm) {\n        CIBAPolicy cibaPolicy = new CIBAPolicy();\n\n        String cibaBackchannelTokenDeliveryMode = rep.getCibaBackchannelTokenDeliveryMode();\n        if (cibaBackchannelTokenDeliveryMode == null || cibaBackchannelTokenDeliveryMode.isEmpty())\n            cibaBackchannelTokenDeliveryMode = Constants.DEFAULT_CIBA_POLICY_TOKEN_DELIVERY_MODE;\n        cibaPolicy.setBackchannelTokenDeliveryMode(cibaBackchannelTokenDeliveryMode);\n\n        Integer cibaExpiresIn = rep.getCibaExpiresIn();\n        if (cibaExpiresIn != null) cibaPolicy.setExpiresIn(cibaExpiresIn);\n        else cibaPolicy.setExpiresIn(Constants.DEFAULT_CIBA_POLICY_EXPIRES_IN);\n\n        Integer cibaInterval = rep.getCibaInterval();\n        if (cibaInterval != null) cibaPolicy.setInterval(cibaInterval);\n        else cibaPolicy.setInterval(Constants.DEFAULT_CIBA_POLICY_INTERVAL);\n\n        String cibaAuthRequestedUserHint = rep.getCibaAuthRequestedUserHint();\n        if (cibaAuthRequestedUserHint == null || cibaAuthRequestedUserHint.isEmpty())\n            cibaAuthRequestedUserHint = Constants.DEFAULT_CIBA_POLICY_AUTH_REQUESTED_USER_HINT;\n        cibaPolicy.setAuthRequestedUserHint(cibaAuthRequestedUserHint);\n\n        realm.setCIBAPolicy(cibaPolicy);\n    }\n\nand use it in both places?", "author": "valb3r", "createdAt": "2021-02-13T17:31:17Z", "path": "server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java", "diffHunk": "@@ -285,6 +286,28 @@ public static void importRealm(KeycloakSession session, RealmRepresentation rep,\n         webAuthnPolicy = getWebAuthnPolicyPasswordless(rep);\n         newRealm.setWebAuthnPolicyPasswordless(webAuthnPolicy);\n \n+        CIBAPolicy cibaPolicy = new CIBAPolicy();", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5MjExNA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575692114", "bodyText": "There is no need to define empty public contructor, java already provides the default one", "author": "valb3r", "createdAt": "2021-02-13T17:35:06Z", "path": "server-spi/src/main/java/org/keycloak/models/CIBAPolicy.java", "diffHunk": "@@ -0,0 +1,66 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models;\n+\n+import java.io.Serializable;\n+\n+import org.jboss.logging.Logger;\n+\n+public class CIBAPolicy implements Serializable {\n+\n+    protected static final Logger logger = Logger.getLogger(CIBAPolicy.class);\n+\n+    protected String backchannelTokenDeliveryMode = \"poll\";\n+    protected int expiresIn = 120;\n+    protected int interval = 0;\n+    protected String authRequestedUserHint = \"login_hint\";\n+\n+    public CIBAPolicy() {", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NjcyMzU5OA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r576723598", "bodyText": "@valb3r That is right. I will fix codes as you pointed out.", "author": "tnorimat", "createdAt": "2021-02-16T10:42:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5MjExNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5NDYxNA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575694614", "bodyText": "What is the purpose of this log statement? if userSession is null doesn't it makes sense to throw an exception immediately? as updateUserSessionFromClientAuthwill throw NPE ifuserSession` is null", "author": "valb3r", "createdAt": "2021-02-13T17:56:57Z", "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProviderBase.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.util.Map;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.spi.HttpResponse;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.authentication.AuthenticationProcessor;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.AuthenticationFlowModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.models.utils.AuthenticationFlowResolver;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.managers.AuthenticationManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.sessions.AuthenticationSessionModel;\n+import org.keycloak.sessions.RootAuthenticationSessionModel;\n+\n+public abstract class DecoupledAuthenticationProviderBase implements DecoupledAuthenticationProvider, OIDCExtProvider {\n+\n+    private static final Logger logger = Logger.getLogger(DecoupledAuthenticationProviderBase.class);\n+\n+    protected KeycloakSession session;\n+    protected EventBuilder event;\n+\n+    protected MultivaluedMap<String, String> formParams;\n+\n+    protected RealmModel realm;\n+\n+    protected ClientModel client;\n+    protected Map<String, String> clientAuthAttributes;\n+\n+    @Context\n+    protected HttpHeaders headers;\n+    @Context\n+    protected HttpRequest httpRequest;\n+    @Context\n+    protected HttpResponse httpResponse;\n+    @Context\n+    protected ClientConnection clientConnection;\n+\n+    protected Cors cors;\n+\n+    public DecoupledAuthenticationProviderBase(KeycloakSession session) {\n+        this.session = session;\n+        realm = session.getContext().getRealm();\n+    }\n+\n+    @Override\n+    public void setEvent(EventBuilder event) {\n+        this.event = event;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processDecoupledAuthnResult() {\n+        event.event(EventType.LOGIN);\n+        headers = session.getContext().getContextObject(HttpHeaders.class);\n+        httpRequest = session.getContext().getContextObject(HttpRequest.class);\n+        httpResponse = session.getContext().getContextObject(HttpResponse.class);\n+        clientConnection = session.getContext().getContextObject(ClientConnection.class);\n+\n+        cors = Cors.add(httpRequest).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+        formParams = httpRequest.getDecodedFormParameters();\n+\n+        checkSsl();\n+        checkRealm();\n+        // here Client Model of Decoupled Authentication Server is set to this class member \"client\".\n+        // this will be overridden by Client Model of CD(Consumption Device) in verifyDecoupledAuthnResult().\n+        checkClient();\n+        logger.info(\" client_id = \" + client.getClientId());\n+\n+        MultivaluedMap<String, Object> outputHeaders = httpResponse.getOutputHeaders();\n+        outputHeaders.putSingle(\"Cache-Control\", \"no-store\");\n+        outputHeaders.putSingle(\"Pragma\", \"no-cache\");\n+\n+        Response response = verifyDecoupledAuthnResult();\n+        if (response != null) return response;\n+\n+        setupSessions();\n+\n+        persistDecoupledAuthenticationResult(DecoupledAuthStatus.SUCCEEDED);\n+\n+        return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+    }\n+\n+    private void setupSessions() {\n+        RootAuthenticationSessionModel rootAuthSession = session.authenticationSessions().createRootAuthenticationSession(realm, getUserSessionIdWillBeCreated());\n+        // here Client Model of CD(Consumption Device) needs to be used to bind its Client Session with User Session.\n+        AuthenticationSessionModel authSession = rootAuthSession.createAuthenticationSession(client);\n+\n+        authSession.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);\n+        authSession.setAction(AuthenticatedClientSessionModel.Action.AUTHENTICATE.name());\n+        authSession.setClientNote(OIDCLoginProtocol.ISSUER, Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()));\n+        authSession.setClientNote(OIDCLoginProtocol.SCOPE_PARAM, getScope());\n+        logger.info(\" specified scopes in backchannel authentication endpoint = \" + getScope());\n+\n+        // authentication\n+        AuthenticationFlowModel flow = AuthenticationFlowResolver.resolveCIBAFlow(authSession);\n+        String flowId = flow.getId();\n+        AuthenticationProcessor processor = new AuthenticationProcessor();\n+        processor.setAuthenticationSession(authSession)\n+                .setFlowId(flowId)\n+                .setConnection(clientConnection)\n+                .setEventBuilder(event)\n+                .setRealm(realm)\n+                .setSession(session)\n+                .setUriInfo(session.getContext().getUri())\n+                .setRequest(httpRequest);\n+\n+        processor.authenticateOnly();\n+        processor.evaluateRequiredActionTriggers();\n+        UserModel user = authSession.getAuthenticatedUser();\n+        if (user.getRequiredActionsStream().count() > 0) {\n+            event.error(Errors.RESOLVE_REQUIRED_ACTIONS);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"Account is not fully set up\", Response.Status.BAD_REQUEST);\n+        }\n+\n+        AuthenticationManager.setClientScopesInSession(authSession);\n+\n+        processor.attachSession();\n+        UserSessionModel userSession = processor.getUserSession();\n+        if (userSession == null) {\n+            logger.info(\" userSession is null.\");", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Njc2Njg1Ng==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r576766856", "bodyText": "@valb3r Yes, it causes NPE if userSession == null. I will fix these codes as follows.\n            event.error(Errors.USER_SESSION_NOT_FOUND);\n            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"User session is not found\", Response.Status.BAD_REQUEST);", "author": "tnorimat", "createdAt": "2021-02-16T11:54:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5NDYxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5NDk0Ng==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575694946", "bodyText": "Instead of doing string-concatenation, it might be better to use logger.infof", "author": "valb3r", "createdAt": "2021-02-13T17:59:23Z", "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProviderBase.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.util.Map;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.spi.HttpResponse;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.authentication.AuthenticationProcessor;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.AuthenticationFlowModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.models.utils.AuthenticationFlowResolver;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.managers.AuthenticationManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.sessions.AuthenticationSessionModel;\n+import org.keycloak.sessions.RootAuthenticationSessionModel;\n+\n+public abstract class DecoupledAuthenticationProviderBase implements DecoupledAuthenticationProvider, OIDCExtProvider {\n+\n+    private static final Logger logger = Logger.getLogger(DecoupledAuthenticationProviderBase.class);\n+\n+    protected KeycloakSession session;\n+    protected EventBuilder event;\n+\n+    protected MultivaluedMap<String, String> formParams;\n+\n+    protected RealmModel realm;\n+\n+    protected ClientModel client;\n+    protected Map<String, String> clientAuthAttributes;\n+\n+    @Context\n+    protected HttpHeaders headers;\n+    @Context\n+    protected HttpRequest httpRequest;\n+    @Context\n+    protected HttpResponse httpResponse;\n+    @Context\n+    protected ClientConnection clientConnection;\n+\n+    protected Cors cors;\n+\n+    public DecoupledAuthenticationProviderBase(KeycloakSession session) {\n+        this.session = session;\n+        realm = session.getContext().getRealm();\n+    }\n+\n+    @Override\n+    public void setEvent(EventBuilder event) {\n+        this.event = event;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processDecoupledAuthnResult() {\n+        event.event(EventType.LOGIN);\n+        headers = session.getContext().getContextObject(HttpHeaders.class);\n+        httpRequest = session.getContext().getContextObject(HttpRequest.class);\n+        httpResponse = session.getContext().getContextObject(HttpResponse.class);\n+        clientConnection = session.getContext().getContextObject(ClientConnection.class);\n+\n+        cors = Cors.add(httpRequest).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+        formParams = httpRequest.getDecodedFormParameters();\n+\n+        checkSsl();\n+        checkRealm();\n+        // here Client Model of Decoupled Authentication Server is set to this class member \"client\".\n+        // this will be overridden by Client Model of CD(Consumption Device) in verifyDecoupledAuthnResult().\n+        checkClient();\n+        logger.info(\" client_id = \" + client.getClientId());\n+\n+        MultivaluedMap<String, Object> outputHeaders = httpResponse.getOutputHeaders();\n+        outputHeaders.putSingle(\"Cache-Control\", \"no-store\");\n+        outputHeaders.putSingle(\"Pragma\", \"no-cache\");\n+\n+        Response response = verifyDecoupledAuthnResult();\n+        if (response != null) return response;\n+\n+        setupSessions();\n+\n+        persistDecoupledAuthenticationResult(DecoupledAuthStatus.SUCCEEDED);\n+\n+        return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+    }\n+\n+    private void setupSessions() {\n+        RootAuthenticationSessionModel rootAuthSession = session.authenticationSessions().createRootAuthenticationSession(realm, getUserSessionIdWillBeCreated());\n+        // here Client Model of CD(Consumption Device) needs to be used to bind its Client Session with User Session.\n+        AuthenticationSessionModel authSession = rootAuthSession.createAuthenticationSession(client);\n+\n+        authSession.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);\n+        authSession.setAction(AuthenticatedClientSessionModel.Action.AUTHENTICATE.name());\n+        authSession.setClientNote(OIDCLoginProtocol.ISSUER, Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()));\n+        authSession.setClientNote(OIDCLoginProtocol.SCOPE_PARAM, getScope());\n+        logger.info(\" specified scopes in backchannel authentication endpoint = \" + getScope());\n+\n+        // authentication\n+        AuthenticationFlowModel flow = AuthenticationFlowResolver.resolveCIBAFlow(authSession);\n+        String flowId = flow.getId();\n+        AuthenticationProcessor processor = new AuthenticationProcessor();\n+        processor.setAuthenticationSession(authSession)\n+                .setFlowId(flowId)\n+                .setConnection(clientConnection)\n+                .setEventBuilder(event)\n+                .setRealm(realm)\n+                .setSession(session)\n+                .setUriInfo(session.getContext().getUri())\n+                .setRequest(httpRequest);\n+\n+        processor.authenticateOnly();\n+        processor.evaluateRequiredActionTriggers();\n+        UserModel user = authSession.getAuthenticatedUser();\n+        if (user.getRequiredActionsStream().count() > 0) {\n+            event.error(Errors.RESOLVE_REQUIRED_ACTIONS);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"Account is not fully set up\", Response.Status.BAD_REQUEST);\n+        }\n+\n+        AuthenticationManager.setClientScopesInSession(authSession);\n+\n+        processor.attachSession();\n+        UserSessionModel userSession = processor.getUserSession();\n+        if (userSession == null) {\n+            logger.info(\" userSession is null.\");\n+        } else {\n+            logger.info(\" user session id = \" + userSession.getId() + \", username = \" + userSession.getUser().getUsername());", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Njc3MDgwNQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r576770805", "bodyText": "@valb3r I see, I will fix codes as follows.\n            logger.infof(\" user session id =  %s, username = %s\", userSession.getId(), userSession.getUser().getUsername());", "author": "tnorimat", "createdAt": "2021-02-16T12:01:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5NDk0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5NTE5MA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575695190", "bodyText": "can be simplified to grantedConsent.getGrantedClientScopes().forEach(i->logger.info(i.getName()));", "author": "valb3r", "createdAt": "2021-02-13T18:02:02Z", "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProviderBase.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.util.Map;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.spi.HttpResponse;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.authentication.AuthenticationProcessor;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.AuthenticationFlowModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.models.utils.AuthenticationFlowResolver;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.managers.AuthenticationManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.sessions.AuthenticationSessionModel;\n+import org.keycloak.sessions.RootAuthenticationSessionModel;\n+\n+public abstract class DecoupledAuthenticationProviderBase implements DecoupledAuthenticationProvider, OIDCExtProvider {\n+\n+    private static final Logger logger = Logger.getLogger(DecoupledAuthenticationProviderBase.class);\n+\n+    protected KeycloakSession session;\n+    protected EventBuilder event;\n+\n+    protected MultivaluedMap<String, String> formParams;\n+\n+    protected RealmModel realm;\n+\n+    protected ClientModel client;\n+    protected Map<String, String> clientAuthAttributes;\n+\n+    @Context\n+    protected HttpHeaders headers;\n+    @Context\n+    protected HttpRequest httpRequest;\n+    @Context\n+    protected HttpResponse httpResponse;\n+    @Context\n+    protected ClientConnection clientConnection;\n+\n+    protected Cors cors;\n+\n+    public DecoupledAuthenticationProviderBase(KeycloakSession session) {\n+        this.session = session;\n+        realm = session.getContext().getRealm();\n+    }\n+\n+    @Override\n+    public void setEvent(EventBuilder event) {\n+        this.event = event;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processDecoupledAuthnResult() {\n+        event.event(EventType.LOGIN);\n+        headers = session.getContext().getContextObject(HttpHeaders.class);\n+        httpRequest = session.getContext().getContextObject(HttpRequest.class);\n+        httpResponse = session.getContext().getContextObject(HttpResponse.class);\n+        clientConnection = session.getContext().getContextObject(ClientConnection.class);\n+\n+        cors = Cors.add(httpRequest).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+        formParams = httpRequest.getDecodedFormParameters();\n+\n+        checkSsl();\n+        checkRealm();\n+        // here Client Model of Decoupled Authentication Server is set to this class member \"client\".\n+        // this will be overridden by Client Model of CD(Consumption Device) in verifyDecoupledAuthnResult().\n+        checkClient();\n+        logger.info(\" client_id = \" + client.getClientId());\n+\n+        MultivaluedMap<String, Object> outputHeaders = httpResponse.getOutputHeaders();\n+        outputHeaders.putSingle(\"Cache-Control\", \"no-store\");\n+        outputHeaders.putSingle(\"Pragma\", \"no-cache\");\n+\n+        Response response = verifyDecoupledAuthnResult();\n+        if (response != null) return response;\n+\n+        setupSessions();\n+\n+        persistDecoupledAuthenticationResult(DecoupledAuthStatus.SUCCEEDED);\n+\n+        return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+    }\n+\n+    private void setupSessions() {\n+        RootAuthenticationSessionModel rootAuthSession = session.authenticationSessions().createRootAuthenticationSession(realm, getUserSessionIdWillBeCreated());\n+        // here Client Model of CD(Consumption Device) needs to be used to bind its Client Session with User Session.\n+        AuthenticationSessionModel authSession = rootAuthSession.createAuthenticationSession(client);\n+\n+        authSession.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);\n+        authSession.setAction(AuthenticatedClientSessionModel.Action.AUTHENTICATE.name());\n+        authSession.setClientNote(OIDCLoginProtocol.ISSUER, Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()));\n+        authSession.setClientNote(OIDCLoginProtocol.SCOPE_PARAM, getScope());\n+        logger.info(\" specified scopes in backchannel authentication endpoint = \" + getScope());\n+\n+        // authentication\n+        AuthenticationFlowModel flow = AuthenticationFlowResolver.resolveCIBAFlow(authSession);\n+        String flowId = flow.getId();\n+        AuthenticationProcessor processor = new AuthenticationProcessor();\n+        processor.setAuthenticationSession(authSession)\n+                .setFlowId(flowId)\n+                .setConnection(clientConnection)\n+                .setEventBuilder(event)\n+                .setRealm(realm)\n+                .setSession(session)\n+                .setUriInfo(session.getContext().getUri())\n+                .setRequest(httpRequest);\n+\n+        processor.authenticateOnly();\n+        processor.evaluateRequiredActionTriggers();\n+        UserModel user = authSession.getAuthenticatedUser();\n+        if (user.getRequiredActionsStream().count() > 0) {\n+            event.error(Errors.RESOLVE_REQUIRED_ACTIONS);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"Account is not fully set up\", Response.Status.BAD_REQUEST);\n+        }\n+\n+        AuthenticationManager.setClientScopesInSession(authSession);\n+\n+        processor.attachSession();\n+        UserSessionModel userSession = processor.getUserSession();\n+        if (userSession == null) {\n+            logger.info(\" userSession is null.\");\n+        } else {\n+            logger.info(\" user session id = \" + userSession.getId() + \", username = \" + userSession.getUser().getUsername());\n+        }\n+        updateUserSessionFromClientAuth(userSession);\n+\n+        logger.info(\"  Created User Session's id                            = \" + userSession.getId());\n+        logger.info(\"  Submitted in advance User Session ID Will Be Created = \" + getUserSessionIdWillBeCreated());\n+\n+        // authorization (consent)\n+        UserConsentModel grantedConsent = session.users().getConsentByClient(realm, user.getId(), client.getId());\n+        if (grantedConsent == null) {\n+            grantedConsent = new UserConsentModel(client);\n+            session.users().addConsent(realm, user.getId(), grantedConsent);\n+            logger.info(\"  Consent updated : \");\n+            grantedConsent.getGrantedClientScopes().stream().forEach(i->logger.info(i.getName()));", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Njc3MTg5Mw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r576771893", "bodyText": "@valb3r Yes, I will fix codes as you suggested.", "author": "tnorimat", "createdAt": "2021-02-16T12:03:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5NTE5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5NTI5MQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r575695291", "bodyText": "can be simplified to grantedConsent.getGrantedClientScopes().forEach(i->logger.info(i.getName()));", "author": "valb3r", "createdAt": "2021-02-13T18:03:18Z", "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProviderBase.java", "diffHunk": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.util.Map;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.spi.HttpResponse;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.authentication.AuthenticationProcessor;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.AuthenticationFlowModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.models.utils.AuthenticationFlowResolver;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.managers.AuthenticationManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.sessions.AuthenticationSessionModel;\n+import org.keycloak.sessions.RootAuthenticationSessionModel;\n+\n+public abstract class DecoupledAuthenticationProviderBase implements DecoupledAuthenticationProvider, OIDCExtProvider {\n+\n+    private static final Logger logger = Logger.getLogger(DecoupledAuthenticationProviderBase.class);\n+\n+    protected KeycloakSession session;\n+    protected EventBuilder event;\n+\n+    protected MultivaluedMap<String, String> formParams;\n+\n+    protected RealmModel realm;\n+\n+    protected ClientModel client;\n+    protected Map<String, String> clientAuthAttributes;\n+\n+    @Context\n+    protected HttpHeaders headers;\n+    @Context\n+    protected HttpRequest httpRequest;\n+    @Context\n+    protected HttpResponse httpResponse;\n+    @Context\n+    protected ClientConnection clientConnection;\n+\n+    protected Cors cors;\n+\n+    public DecoupledAuthenticationProviderBase(KeycloakSession session) {\n+        this.session = session;\n+        realm = session.getContext().getRealm();\n+    }\n+\n+    @Override\n+    public void setEvent(EventBuilder event) {\n+        this.event = event;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processDecoupledAuthnResult() {\n+        event.event(EventType.LOGIN);\n+        headers = session.getContext().getContextObject(HttpHeaders.class);\n+        httpRequest = session.getContext().getContextObject(HttpRequest.class);\n+        httpResponse = session.getContext().getContextObject(HttpResponse.class);\n+        clientConnection = session.getContext().getContextObject(ClientConnection.class);\n+\n+        cors = Cors.add(httpRequest).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+        formParams = httpRequest.getDecodedFormParameters();\n+\n+        checkSsl();\n+        checkRealm();\n+        // here Client Model of Decoupled Authentication Server is set to this class member \"client\".\n+        // this will be overridden by Client Model of CD(Consumption Device) in verifyDecoupledAuthnResult().\n+        checkClient();\n+        logger.info(\" client_id = \" + client.getClientId());\n+\n+        MultivaluedMap<String, Object> outputHeaders = httpResponse.getOutputHeaders();\n+        outputHeaders.putSingle(\"Cache-Control\", \"no-store\");\n+        outputHeaders.putSingle(\"Pragma\", \"no-cache\");\n+\n+        Response response = verifyDecoupledAuthnResult();\n+        if (response != null) return response;\n+\n+        setupSessions();\n+\n+        persistDecoupledAuthenticationResult(DecoupledAuthStatus.SUCCEEDED);\n+\n+        return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+    }\n+\n+    private void setupSessions() {\n+        RootAuthenticationSessionModel rootAuthSession = session.authenticationSessions().createRootAuthenticationSession(realm, getUserSessionIdWillBeCreated());\n+        // here Client Model of CD(Consumption Device) needs to be used to bind its Client Session with User Session.\n+        AuthenticationSessionModel authSession = rootAuthSession.createAuthenticationSession(client);\n+\n+        authSession.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);\n+        authSession.setAction(AuthenticatedClientSessionModel.Action.AUTHENTICATE.name());\n+        authSession.setClientNote(OIDCLoginProtocol.ISSUER, Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()));\n+        authSession.setClientNote(OIDCLoginProtocol.SCOPE_PARAM, getScope());\n+        logger.info(\" specified scopes in backchannel authentication endpoint = \" + getScope());\n+\n+        // authentication\n+        AuthenticationFlowModel flow = AuthenticationFlowResolver.resolveCIBAFlow(authSession);\n+        String flowId = flow.getId();\n+        AuthenticationProcessor processor = new AuthenticationProcessor();\n+        processor.setAuthenticationSession(authSession)\n+                .setFlowId(flowId)\n+                .setConnection(clientConnection)\n+                .setEventBuilder(event)\n+                .setRealm(realm)\n+                .setSession(session)\n+                .setUriInfo(session.getContext().getUri())\n+                .setRequest(httpRequest);\n+\n+        processor.authenticateOnly();\n+        processor.evaluateRequiredActionTriggers();\n+        UserModel user = authSession.getAuthenticatedUser();\n+        if (user.getRequiredActionsStream().count() > 0) {\n+            event.error(Errors.RESOLVE_REQUIRED_ACTIONS);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"Account is not fully set up\", Response.Status.BAD_REQUEST);\n+        }\n+\n+        AuthenticationManager.setClientScopesInSession(authSession);\n+\n+        processor.attachSession();\n+        UserSessionModel userSession = processor.getUserSession();\n+        if (userSession == null) {\n+            logger.info(\" userSession is null.\");\n+        } else {\n+            logger.info(\" user session id = \" + userSession.getId() + \", username = \" + userSession.getUser().getUsername());\n+        }\n+        updateUserSessionFromClientAuth(userSession);\n+\n+        logger.info(\"  Created User Session's id                            = \" + userSession.getId());\n+        logger.info(\"  Submitted in advance User Session ID Will Be Created = \" + getUserSessionIdWillBeCreated());\n+\n+        // authorization (consent)\n+        UserConsentModel grantedConsent = session.users().getConsentByClient(realm, user.getId(), client.getId());\n+        if (grantedConsent == null) {\n+            grantedConsent = new UserConsentModel(client);\n+            session.users().addConsent(realm, user.getId(), grantedConsent);\n+            logger.info(\"  Consent updated : \");\n+            grantedConsent.getGrantedClientScopes().stream().forEach(i->logger.info(i.getName()));\n+        }\n+\n+        boolean updateConsentRequired = false;\n+\n+        for (String clientScopeId : authSession.getClientScopes()) {\n+            ClientScopeModel clientScope = KeycloakModelUtils.findClientScopeById(realm, client, clientScopeId);\n+            if (clientScope != null) {\n+                if (!grantedConsent.isClientScopeGranted(clientScope) && clientScope.isDisplayOnConsentScreen()) {\n+                    grantedConsent.addGrantedClientScope(clientScope);\n+                    updateConsentRequired = true;\n+                }\n+            } else {\n+                logger.warnf(\"Client scope or client with ID '%s' not found\", clientScopeId);\n+            }\n+        }\n+\n+        if (updateConsentRequired) {\n+            session.users().updateConsent(realm, user.getId(), grantedConsent);\n+            logger.info(\"  Consent granted : \");\n+            grantedConsent.getGrantedClientScopes().stream().forEach(i->logger.info(i.getName()));", "originalCommit": "466333489cd8bd510d90b698b9ef7a332a666f03", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3Njc3MjAwNg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r576772006", "bodyText": "@valb3r Yes, I will fix codes as you suggested.", "author": "tnorimat", "createdAt": "2021-02-16T12:03:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NTY5NTI5MQ=="}], "type": "inlineReview"}, {"oid": "9fdf0bb45e53185115f1035c059be90569f31cea", "url": "https://github.com/keycloak/keycloak/commit/9fdf0bb45e53185115f1035c059be90569f31cea", "message": "KEYCLOAK-12137 OpenID Connect Client Initiated Backchannel Authentication (CIBA)\n\nCo-authored-by: Andrii Murashkin <amu@adorsys.com.ua>", "committedDate": "2021-02-16T09:00:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU0ODIwNA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577548204", "bodyText": "I would also move this to the CIBA representation. All CIBA related data from a single place. Same for the model.", "author": "pedroigor", "createdAt": "2021-02-17T11:50:28Z", "path": "core/src/main/java/org/keycloak/representations/idm/RealmRepresentation.java", "diffHunk": "@@ -180,6 +183,7 @@\n     protected String resetCredentialsFlow;\n     protected String clientAuthenticationFlow;\n     protected String dockerAuthenticationFlow;\n+    protected String cibaFlow;", "originalCommit": "098220ef66b8ff7bad8371639a102f03cf9e66d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODAxNDUzNw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r578014537", "bodyText": "@pedroigor Thank you for the clarification. I will put cibaFlow onto CIBAPolicy.", "author": "tnorimat", "createdAt": "2021-02-17T23:22:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU0ODIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU1MDE3NQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577550175", "bodyText": "To avoid boilerplate code we could probable add a public String getAttribute(String name, String defaultValue) as we have for other types like int, boolean, etc.", "author": "pedroigor", "createdAt": "2021-02-17T11:54:02Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java", "diffHunk": "@@ -1048,6 +1049,46 @@ private void setWebAuthnPolicy(WebAuthnPolicy policy, String attributePrefix) {\n         }\n     }\n \n+    @Override\n+    public CIBAPolicy getCIBAPolicy() {\n+        CIBAPolicy policy = new CIBAPolicy();\n+\n+        String backchannelTokenDeliveryMode = getAttribute(RealmAttributes.CIBA_BACKCHANNEL_TOKENDELIVERY_MODE);", "originalCommit": "098220ef66b8ff7bad8371639a102f03cf9e66d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODgxMjk2OA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r578812968", "bodyText": "@pedroigor I see, how about implementing code as follows in RealmModel interface?\n    default String getAttribute(String name, String defaultValue) {\n        return Optional.ofNullable(getAttribute(name)).filter(StringUtil::isNotBlank).orElse(defaultValue);\n    }\n\nand in RealmAdapter,\npolicy.setBackchannelTokenDeliveryMode(getAttribute(RealmAttributes.CIBA_BACKCHANNEL_TOKENDELIVERY_MODE, \n        Constants.DEFAULT_CIBA_POLICY_TOKEN_DELIVERY_MODE));\n\npolicy.setAuthRequestedUserHint(getAttribute(RealmAttributes.CIBA_AUTH_REQUESTED_USER_HINT,\n        Constants.DEFAULT_CIBA_POLICY_AUTH_REQUESTED_USER_HINT));", "author": "tnorimat", "createdAt": "2021-02-18T23:13:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU1MDE3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU1NjA1OA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577556058", "bodyText": "As mentioned before. We can move the cibaFlow to CIBAPolicy. No need for this method.", "author": "pedroigor", "createdAt": "2021-02-17T12:04:01Z", "path": "model/jpa/src/main/java/org/keycloak/models/jpa/RealmAdapter.java", "diffHunk": "@@ -1554,6 +1595,18 @@ public void setDockerAuthenticationFlow(AuthenticationFlowModel flow) {\n         realm.setDockerAuthenticationFlow(flow.getId());\n     }\n \n+    @Override\n+    public AuthenticationFlowModel getCIBAFlow() {\n+        String flowId = getAttribute(RealmAttributes.CIBA_AUTHENTICATION_FLOW);\n+        if (flowId == null) return null;\n+        return getAuthenticationFlowById(flowId);\n+    }\n+\n+    @Override\n+    public void setCIBAFlow(AuthenticationFlowModel flow) {", "originalCommit": "098220ef66b8ff7bad8371639a102f03cf9e66d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODAxNDIwNw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r578014207", "bodyText": "@pedroigor Thank you for the clarification. I will put cibaFlow onto CIBAPolicy as mentioned before.", "author": "tnorimat", "createdAt": "2021-02-17T23:21:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU1NjA1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU1ODk5MA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577558990", "bodyText": "This should remove some boilerplate code:\ncibaPolicy.setBackchannelTokenDeliveryMode(Optional.ofNullable(cibaRep.getCibaBackchannelTokenDeliveryMode())\n                    .filter(StringUtil::isNotBlank)\n                    .orElse(Constants.DEFAULT_CIBA_POLICY_TOKEN_DELIVERY_MODE));", "author": "pedroigor", "createdAt": "2021-02-17T12:08:58Z", "path": "server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java", "diffHunk": "@@ -544,6 +550,35 @@ private static WebAuthnPolicy getWebAuthnPolicyPasswordless(RealmRepresentation\n         return webAuthnPolicy;\n     }\n \n+    private static CIBAPolicy convertCIBARepresentationToPolicy(CIBARepresentation cibaRep) {\n+        CIBAPolicy cibaPolicy = new CIBAPolicy();\n+        if (cibaRep != null) {\n+            String cibaBackchannelTokenDeliveryMode = cibaRep.getCibaBackchannelTokenDeliveryMode();", "originalCommit": "098220ef66b8ff7bad8371639a102f03cf9e66d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODIwMTg4OQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r578201889", "bodyText": "@pedroigor I see, I will fix codes as you proposed instead of current boilerplate style codes.", "author": "tnorimat", "createdAt": "2021-02-18T07:58:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU1ODk5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2MDE4Nw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577560187", "bodyText": "What should happen if the flow from representation does not exist?", "author": "pedroigor", "createdAt": "2021-02-17T12:10:58Z", "path": "server-spi-private/src/main/java/org/keycloak/models/utils/RepresentationToModel.java", "diffHunk": "@@ -808,6 +844,19 @@ public static void importGroup(RealmModel realm, GroupModel parent, GroupReprese\n         return mappedFlows;\n     }\n \n+    private static void handleCibaFlowIfApplicable(RealmModel newRealm, RealmRepresentation rep) {\n+        if (rep.getCibaFlow() == null) {\n+            AuthenticationFlowModel cibaFlowModel = newRealm.getFlowByAlias(DefaultAuthenticationFlows.CIBA_FLOW);\n+            if (cibaFlowModel != null) {\n+                newRealm.setCIBAFlow(cibaFlowModel);\n+            } else {\n+                DefaultAuthenticationFlows.cibaFlow(newRealm);\n+            }\n+        } else {\n+            newRealm.setCIBAFlow(newRealm.getFlowByAlias(rep.getCibaFlow()));", "originalCommit": "098220ef66b8ff7bad8371639a102f03cf9e66d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3OTcxODA4NQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r579718085", "bodyText": "@pedroigor Basically, CIBA flow should always exist so that it is created if not exist on the representation by DefaultAuthenticationFlows.cibaFlow.", "author": "tnorimat", "createdAt": "2021-02-20T22:34:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2MDE4Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2MDU1MA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577560550", "bodyText": "Using logger?", "author": "pedroigor", "createdAt": "2021-02-17T12:11:41Z", "path": "server-spi/src/main/java/org/keycloak/models/CIBAPolicy.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models;\n+\n+import java.io.Serializable;\n+\n+import org.jboss.logging.Logger;\n+\n+public class CIBAPolicy implements Serializable {\n+\n+    protected static final Logger logger = Logger.getLogger(CIBAPolicy.class);", "originalCommit": "098220ef66b8ff7bad8371639a102f03cf9e66d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODAyMTEzNA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r578021134", "bodyText": "@pedroigor No. I will remove this logger.", "author": "tnorimat", "createdAt": "2021-02-17T23:39:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2MDU1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2MTE4OQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577561189", "bodyText": "Do you expect sub-types or types within the same package to extend this class? Could them be private instead?", "author": "pedroigor", "createdAt": "2021-02-17T12:12:47Z", "path": "server-spi/src/main/java/org/keycloak/models/CIBAPolicy.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.models;\n+\n+import java.io.Serializable;\n+\n+import org.jboss.logging.Logger;\n+\n+public class CIBAPolicy implements Serializable {\n+\n+    protected static final Logger logger = Logger.getLogger(CIBAPolicy.class);\n+\n+    protected String backchannelTokenDeliveryMode = \"poll\";", "originalCommit": "098220ef66b8ff7bad8371639a102f03cf9e66d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODA1NTk1NA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r578055954", "bodyText": "@pedroigor No, I do not expect it.  As you suggested, private is appropriate. I will change these fields' visibility as private.", "author": "tnorimat", "createdAt": "2021-02-18T01:13:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2MTE4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2MjIwMA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577562200", "bodyText": "Trim the string before checking if it is empty?", "author": "pedroigor", "createdAt": "2021-02-17T12:14:20Z", "path": "server-spi/src/main/java/org/keycloak/utils/StringUtil.java", "diffHunk": "@@ -0,0 +1,29 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.utils;\n+\n+public class StringUtil {\n+\n+    public static boolean isBlank(String str) {\n+        return !(isNotBlank(str));\n+    }\n+\n+    public static boolean  isNotBlank(String str) {\n+        return str != null && !str.isEmpty();", "originalCommit": "098220ef66b8ff7bad8371639a102f03cf9e66d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODAyNTIyMA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r578025220", "bodyText": "@pedroigor Yes, I will fix codes as https://github.com/keycloak/keycloak/blob/master/saml-core/src/main/java/org/keycloak/saml/common/util/StringUtil.java .", "author": "tnorimat", "createdAt": "2021-02-17T23:50:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2MjIwMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2Mjg4NQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577562885", "bodyText": "Aren't those fields automatically injected as they are annotated with @Context ?", "author": "pedroigor", "createdAt": "2021-02-17T12:15:31Z", "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProviderBase.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.util.Map;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.spi.HttpResponse;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.authentication.AuthenticationProcessor;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.AuthenticationFlowModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.models.utils.AuthenticationFlowResolver;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.managers.AuthenticationManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.sessions.AuthenticationSessionModel;\n+import org.keycloak.sessions.RootAuthenticationSessionModel;\n+\n+public abstract class DecoupledAuthenticationProviderBase implements DecoupledAuthenticationProvider, OIDCExtProvider {\n+\n+    private static final Logger logger = Logger.getLogger(DecoupledAuthenticationProviderBase.class);\n+\n+    protected KeycloakSession session;\n+    protected EventBuilder event;\n+\n+    protected MultivaluedMap<String, String> formParams;\n+\n+    protected RealmModel realm;\n+\n+    protected ClientModel client;\n+    protected Map<String, String> clientAuthAttributes;\n+\n+    @Context\n+    protected HttpHeaders headers;\n+    @Context\n+    protected HttpRequest httpRequest;\n+    @Context\n+    protected HttpResponse httpResponse;\n+    @Context\n+    protected ClientConnection clientConnection;\n+\n+    protected Cors cors;\n+\n+    public DecoupledAuthenticationProviderBase(KeycloakSession session) {\n+        this.session = session;\n+        realm = session.getContext().getRealm();\n+    }\n+\n+    @Override\n+    public void setEvent(EventBuilder event) {\n+        this.event = event;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processDecoupledAuthnResult() {\n+        event.event(EventType.LOGIN);\n+        headers = session.getContext().getContextObject(HttpHeaders.class);\n+        httpRequest = session.getContext().getContextObject(HttpRequest.class);", "originalCommit": "098220ef66b8ff7bad8371639a102f03cf9e66d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODgzNjUwNw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r578836507", "bodyText": "@pedroigor I've missed that this @Context does not work so that these should be removed.\nThis class uses the endpoint extension and it does not inject context.\n\n  \n    \n      keycloak/services/src/main/java/org/keycloak/protocol/oidc/OIDCLoginProtocolService.java\n    \n    \n        Lines 302 to 310\n      in\n      750f5fd\n    \n    \n    \n    \n\n        \n          \n           @Path(\"ext/{extension}\") \n        \n\n        \n          \n           public Object resolveExtension(@PathParam(\"extension\") String extension) { \n        \n\n        \n          \n               OIDCExtProvider provider = session.getProvider(OIDCExtProvider.class, extension); \n        \n\n        \n          \n               if (provider != null) { \n        \n\n        \n          \n                   provider.setEvent(event); \n        \n\n        \n          \n                   return provider; \n        \n\n        \n          \n               } \n        \n\n        \n          \n               throw new NotFoundException(); \n        \n\n        \n          \n           }", "author": "tnorimat", "createdAt": "2021-02-19T00:14:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2Mjg4NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2Mzg4NA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577563884", "bodyText": "Prefer using constants from org.jboss.resteasy.util.HttpHeaderNames.\nAlso, the Response type from JAX-RS should give you methods to set the cache-control as well as any other header, without having to deal with the HttpResponse directly.", "author": "pedroigor", "createdAt": "2021-02-17T12:17:11Z", "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProviderBase.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.util.Map;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.spi.HttpResponse;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.authentication.AuthenticationProcessor;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.AuthenticationFlowModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.models.utils.AuthenticationFlowResolver;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.managers.AuthenticationManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.sessions.AuthenticationSessionModel;\n+import org.keycloak.sessions.RootAuthenticationSessionModel;\n+\n+public abstract class DecoupledAuthenticationProviderBase implements DecoupledAuthenticationProvider, OIDCExtProvider {\n+\n+    private static final Logger logger = Logger.getLogger(DecoupledAuthenticationProviderBase.class);\n+\n+    protected KeycloakSession session;\n+    protected EventBuilder event;\n+\n+    protected MultivaluedMap<String, String> formParams;\n+\n+    protected RealmModel realm;\n+\n+    protected ClientModel client;\n+    protected Map<String, String> clientAuthAttributes;\n+\n+    @Context\n+    protected HttpHeaders headers;\n+    @Context\n+    protected HttpRequest httpRequest;\n+    @Context\n+    protected HttpResponse httpResponse;\n+    @Context\n+    protected ClientConnection clientConnection;\n+\n+    protected Cors cors;\n+\n+    public DecoupledAuthenticationProviderBase(KeycloakSession session) {\n+        this.session = session;\n+        realm = session.getContext().getRealm();\n+    }\n+\n+    @Override\n+    public void setEvent(EventBuilder event) {\n+        this.event = event;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processDecoupledAuthnResult() {\n+        event.event(EventType.LOGIN);\n+        headers = session.getContext().getContextObject(HttpHeaders.class);\n+        httpRequest = session.getContext().getContextObject(HttpRequest.class);\n+        httpResponse = session.getContext().getContextObject(HttpResponse.class);\n+        clientConnection = session.getContext().getContextObject(ClientConnection.class);\n+\n+        cors = Cors.add(httpRequest).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+        formParams = httpRequest.getDecodedFormParameters();\n+\n+        checkSsl();\n+        checkRealm();\n+        // here Client Model of Decoupled Authentication Server is set to this class member \"client\".\n+        // this will be overridden by Client Model of CD(Consumption Device) in verifyDecoupledAuthnResult().\n+        checkClient();\n+        logger.info(\" client_id = \" + client.getClientId());\n+\n+        MultivaluedMap<String, Object> outputHeaders = httpResponse.getOutputHeaders();\n+        outputHeaders.putSingle(\"Cache-Control\", \"no-store\");", "originalCommit": "098220ef66b8ff7bad8371639a102f03cf9e66d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODg0NTAwNg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r578845006", "bodyText": "@pedroigor Yes. I will fix codes as follows as you suggested.\n        return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)\n                .header(HttpHeaderNames.CACHE_CONTROL, \"no-store\")\n                .header(HttpHeaderNames.PRAGMA, \"no-cache\"))\n                .build();", "author": "tnorimat", "createdAt": "2021-02-19T00:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2Mzg4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2NjQwOA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577566408", "bodyText": "Too verbose?", "author": "pedroigor", "createdAt": "2021-02-17T12:21:13Z", "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProviderBase.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.util.Map;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.spi.HttpResponse;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.authentication.AuthenticationProcessor;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.AuthenticationFlowModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.models.utils.AuthenticationFlowResolver;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.managers.AuthenticationManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.sessions.AuthenticationSessionModel;\n+import org.keycloak.sessions.RootAuthenticationSessionModel;\n+\n+public abstract class DecoupledAuthenticationProviderBase implements DecoupledAuthenticationProvider, OIDCExtProvider {\n+\n+    private static final Logger logger = Logger.getLogger(DecoupledAuthenticationProviderBase.class);\n+\n+    protected KeycloakSession session;\n+    protected EventBuilder event;\n+\n+    protected MultivaluedMap<String, String> formParams;\n+\n+    protected RealmModel realm;\n+\n+    protected ClientModel client;\n+    protected Map<String, String> clientAuthAttributes;\n+\n+    @Context\n+    protected HttpHeaders headers;\n+    @Context\n+    protected HttpRequest httpRequest;\n+    @Context\n+    protected HttpResponse httpResponse;\n+    @Context\n+    protected ClientConnection clientConnection;\n+\n+    protected Cors cors;\n+\n+    public DecoupledAuthenticationProviderBase(KeycloakSession session) {\n+        this.session = session;\n+        realm = session.getContext().getRealm();\n+    }\n+\n+    @Override\n+    public void setEvent(EventBuilder event) {\n+        this.event = event;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processDecoupledAuthnResult() {\n+        event.event(EventType.LOGIN);\n+        headers = session.getContext().getContextObject(HttpHeaders.class);\n+        httpRequest = session.getContext().getContextObject(HttpRequest.class);\n+        httpResponse = session.getContext().getContextObject(HttpResponse.class);\n+        clientConnection = session.getContext().getContextObject(ClientConnection.class);\n+\n+        cors = Cors.add(httpRequest).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+        formParams = httpRequest.getDecodedFormParameters();\n+\n+        checkSsl();\n+        checkRealm();\n+        // here Client Model of Decoupled Authentication Server is set to this class member \"client\".\n+        // this will be overridden by Client Model of CD(Consumption Device) in verifyDecoupledAuthnResult().\n+        checkClient();\n+        logger.info(\" client_id = \" + client.getClientId());", "originalCommit": "098220ef66b8ff7bad8371639a102f03cf9e66d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODAyNzMyNg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r578027326", "bodyText": "@pedroigor Yes, I will remove it.", "author": "tnorimat", "createdAt": "2021-02-17T23:55:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2NjQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2Njc0Ng==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577566746", "bodyText": "Too verbose?", "author": "pedroigor", "createdAt": "2021-02-17T12:21:46Z", "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProviderBase.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.util.Map;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.spi.HttpResponse;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.authentication.AuthenticationProcessor;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.AuthenticationFlowModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.models.utils.AuthenticationFlowResolver;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.managers.AuthenticationManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.sessions.AuthenticationSessionModel;\n+import org.keycloak.sessions.RootAuthenticationSessionModel;\n+\n+public abstract class DecoupledAuthenticationProviderBase implements DecoupledAuthenticationProvider, OIDCExtProvider {\n+\n+    private static final Logger logger = Logger.getLogger(DecoupledAuthenticationProviderBase.class);\n+\n+    protected KeycloakSession session;\n+    protected EventBuilder event;\n+\n+    protected MultivaluedMap<String, String> formParams;\n+\n+    protected RealmModel realm;\n+\n+    protected ClientModel client;\n+    protected Map<String, String> clientAuthAttributes;\n+\n+    @Context\n+    protected HttpHeaders headers;\n+    @Context\n+    protected HttpRequest httpRequest;\n+    @Context\n+    protected HttpResponse httpResponse;\n+    @Context\n+    protected ClientConnection clientConnection;\n+\n+    protected Cors cors;\n+\n+    public DecoupledAuthenticationProviderBase(KeycloakSession session) {\n+        this.session = session;\n+        realm = session.getContext().getRealm();\n+    }\n+\n+    @Override\n+    public void setEvent(EventBuilder event) {\n+        this.event = event;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processDecoupledAuthnResult() {\n+        event.event(EventType.LOGIN);\n+        headers = session.getContext().getContextObject(HttpHeaders.class);\n+        httpRequest = session.getContext().getContextObject(HttpRequest.class);\n+        httpResponse = session.getContext().getContextObject(HttpResponse.class);\n+        clientConnection = session.getContext().getContextObject(ClientConnection.class);\n+\n+        cors = Cors.add(httpRequest).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+        formParams = httpRequest.getDecodedFormParameters();\n+\n+        checkSsl();\n+        checkRealm();\n+        // here Client Model of Decoupled Authentication Server is set to this class member \"client\".\n+        // this will be overridden by Client Model of CD(Consumption Device) in verifyDecoupledAuthnResult().\n+        checkClient();\n+        logger.info(\" client_id = \" + client.getClientId());\n+\n+        MultivaluedMap<String, Object> outputHeaders = httpResponse.getOutputHeaders();\n+        outputHeaders.putSingle(\"Cache-Control\", \"no-store\");\n+        outputHeaders.putSingle(\"Pragma\", \"no-cache\");\n+\n+        Response response = verifyDecoupledAuthnResult();\n+        if (response != null) return response;\n+\n+        setupSessions();\n+\n+        persistDecoupledAuthenticationResult(DecoupledAuthStatus.SUCCEEDED);\n+\n+        return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+    }\n+\n+    private void setupSessions() {\n+        RootAuthenticationSessionModel rootAuthSession = session.authenticationSessions().createRootAuthenticationSession(realm, getUserSessionIdWillBeCreated());\n+        // here Client Model of CD(Consumption Device) needs to be used to bind its Client Session with User Session.\n+        AuthenticationSessionModel authSession = rootAuthSession.createAuthenticationSession(client);\n+\n+        authSession.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);\n+        authSession.setAction(AuthenticatedClientSessionModel.Action.AUTHENTICATE.name());\n+        authSession.setClientNote(OIDCLoginProtocol.ISSUER, Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()));\n+        authSession.setClientNote(OIDCLoginProtocol.SCOPE_PARAM, getScope());\n+        logger.info(\" specified scopes in backchannel authentication endpoint = \" + getScope());\n+\n+        // authentication\n+        AuthenticationFlowModel flow = AuthenticationFlowResolver.resolveCIBAFlow(authSession);\n+        String flowId = flow.getId();\n+        AuthenticationProcessor processor = new AuthenticationProcessor();\n+        processor.setAuthenticationSession(authSession)\n+                .setFlowId(flowId)\n+                .setConnection(clientConnection)\n+                .setEventBuilder(event)\n+                .setRealm(realm)\n+                .setSession(session)\n+                .setUriInfo(session.getContext().getUri())\n+                .setRequest(httpRequest);\n+\n+        processor.authenticateOnly();\n+        processor.evaluateRequiredActionTriggers();\n+        UserModel user = authSession.getAuthenticatedUser();\n+        if (user.getRequiredActionsStream().count() > 0) {\n+            event.error(Errors.RESOLVE_REQUIRED_ACTIONS);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"Account is not fully set up\", Response.Status.BAD_REQUEST);\n+        }\n+\n+        AuthenticationManager.setClientScopesInSession(authSession);\n+\n+        processor.attachSession();\n+        UserSessionModel userSession = processor.getUserSession();\n+        if (userSession == null) {\n+            event.error(Errors.USER_SESSION_NOT_FOUND);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"User session is not found\", Response.Status.BAD_REQUEST);\n+        } else {\n+            logger.infof(\" user session id =  %s, username = %s\", userSession.getId(), userSession.getUser().getUsername());", "originalCommit": "098220ef66b8ff7bad8371639a102f03cf9e66d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODAyNzU0Ng==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r578027546", "bodyText": "@pedroigor Yes, I will also remove it.", "author": "tnorimat", "createdAt": "2021-02-17T23:56:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2Njc0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2NzMyMg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577567322", "bodyText": "Too verbose?\nCould you please check other logging messages in other places that fit into the same problem?", "author": "pedroigor", "createdAt": "2021-02-17T12:22:31Z", "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProviderBase.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.util.Map;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.spi.HttpResponse;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.authentication.AuthenticationProcessor;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.AuthenticationFlowModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.models.utils.AuthenticationFlowResolver;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.managers.AuthenticationManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.sessions.AuthenticationSessionModel;\n+import org.keycloak.sessions.RootAuthenticationSessionModel;\n+\n+public abstract class DecoupledAuthenticationProviderBase implements DecoupledAuthenticationProvider, OIDCExtProvider {\n+\n+    private static final Logger logger = Logger.getLogger(DecoupledAuthenticationProviderBase.class);\n+\n+    protected KeycloakSession session;\n+    protected EventBuilder event;\n+\n+    protected MultivaluedMap<String, String> formParams;\n+\n+    protected RealmModel realm;\n+\n+    protected ClientModel client;\n+    protected Map<String, String> clientAuthAttributes;\n+\n+    @Context\n+    protected HttpHeaders headers;\n+    @Context\n+    protected HttpRequest httpRequest;\n+    @Context\n+    protected HttpResponse httpResponse;\n+    @Context\n+    protected ClientConnection clientConnection;\n+\n+    protected Cors cors;\n+\n+    public DecoupledAuthenticationProviderBase(KeycloakSession session) {\n+        this.session = session;\n+        realm = session.getContext().getRealm();\n+    }\n+\n+    @Override\n+    public void setEvent(EventBuilder event) {\n+        this.event = event;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processDecoupledAuthnResult() {\n+        event.event(EventType.LOGIN);\n+        headers = session.getContext().getContextObject(HttpHeaders.class);\n+        httpRequest = session.getContext().getContextObject(HttpRequest.class);\n+        httpResponse = session.getContext().getContextObject(HttpResponse.class);\n+        clientConnection = session.getContext().getContextObject(ClientConnection.class);\n+\n+        cors = Cors.add(httpRequest).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+        formParams = httpRequest.getDecodedFormParameters();\n+\n+        checkSsl();\n+        checkRealm();\n+        // here Client Model of Decoupled Authentication Server is set to this class member \"client\".\n+        // this will be overridden by Client Model of CD(Consumption Device) in verifyDecoupledAuthnResult().\n+        checkClient();\n+        logger.info(\" client_id = \" + client.getClientId());\n+\n+        MultivaluedMap<String, Object> outputHeaders = httpResponse.getOutputHeaders();\n+        outputHeaders.putSingle(\"Cache-Control\", \"no-store\");\n+        outputHeaders.putSingle(\"Pragma\", \"no-cache\");\n+\n+        Response response = verifyDecoupledAuthnResult();\n+        if (response != null) return response;\n+\n+        setupSessions();\n+\n+        persistDecoupledAuthenticationResult(DecoupledAuthStatus.SUCCEEDED);\n+\n+        return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+    }\n+\n+    private void setupSessions() {\n+        RootAuthenticationSessionModel rootAuthSession = session.authenticationSessions().createRootAuthenticationSession(realm, getUserSessionIdWillBeCreated());\n+        // here Client Model of CD(Consumption Device) needs to be used to bind its Client Session with User Session.\n+        AuthenticationSessionModel authSession = rootAuthSession.createAuthenticationSession(client);\n+\n+        authSession.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);\n+        authSession.setAction(AuthenticatedClientSessionModel.Action.AUTHENTICATE.name());\n+        authSession.setClientNote(OIDCLoginProtocol.ISSUER, Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()));\n+        authSession.setClientNote(OIDCLoginProtocol.SCOPE_PARAM, getScope());\n+        logger.info(\" specified scopes in backchannel authentication endpoint = \" + getScope());\n+\n+        // authentication\n+        AuthenticationFlowModel flow = AuthenticationFlowResolver.resolveCIBAFlow(authSession);\n+        String flowId = flow.getId();\n+        AuthenticationProcessor processor = new AuthenticationProcessor();\n+        processor.setAuthenticationSession(authSession)\n+                .setFlowId(flowId)\n+                .setConnection(clientConnection)\n+                .setEventBuilder(event)\n+                .setRealm(realm)\n+                .setSession(session)\n+                .setUriInfo(session.getContext().getUri())\n+                .setRequest(httpRequest);\n+\n+        processor.authenticateOnly();\n+        processor.evaluateRequiredActionTriggers();\n+        UserModel user = authSession.getAuthenticatedUser();\n+        if (user.getRequiredActionsStream().count() > 0) {\n+            event.error(Errors.RESOLVE_REQUIRED_ACTIONS);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"Account is not fully set up\", Response.Status.BAD_REQUEST);\n+        }\n+\n+        AuthenticationManager.setClientScopesInSession(authSession);\n+\n+        processor.attachSession();\n+        UserSessionModel userSession = processor.getUserSession();\n+        if (userSession == null) {\n+            event.error(Errors.USER_SESSION_NOT_FOUND);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"User session is not found\", Response.Status.BAD_REQUEST);\n+        } else {\n+            logger.infof(\" user session id =  %s, username = %s\", userSession.getId(), userSession.getUser().getUsername());\n+        }\n+        updateUserSessionFromClientAuth(userSession);\n+\n+        logger.infof(\"  Created User Session's id                            = %s\", userSession.getId());", "originalCommit": "098220ef66b8ff7bad8371639a102f03cf9e66d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODAyODAyNg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r578028026", "bodyText": "@pedroigor I will review logging messages and remove them.", "author": "tnorimat", "createdAt": "2021-02-17T23:57:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2NzMyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODAzMTIwNA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r578031204", "bodyText": "@pedroigor I think these verbose logging message might be beneficial for debugging (check whether CIBA works well). So, how about outputting these messages as trace log facility like ClientPolicyLogger of Client Policies?\nIf so, ClientPolicyLogger itself might be used for CIBA.", "author": "tnorimat", "createdAt": "2021-02-18T00:06:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2NzMyMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODU1ODY5Mg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r578558692", "bodyText": "I think log using trace lavel makes sense.", "author": "pedroigor", "createdAt": "2021-02-18T16:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2NzMyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2OTQ1MQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r577569451", "bodyText": "Woudn't be easier to just userSession.getNotes().putAll(clientAuthAttributes)? And probably remove this method.", "author": "pedroigor", "createdAt": "2021-02-17T12:26:09Z", "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProviderBase.java", "diffHunk": "@@ -0,0 +1,263 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.util.Map;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.HttpHeaders;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.spi.HttpResponse;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.authentication.AuthenticationProcessor;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.AuthenticationFlowModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.models.utils.AuthenticationFlowResolver;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.managers.AuthenticationManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.sessions.AuthenticationSessionModel;\n+import org.keycloak.sessions.RootAuthenticationSessionModel;\n+\n+public abstract class DecoupledAuthenticationProviderBase implements DecoupledAuthenticationProvider, OIDCExtProvider {\n+\n+    private static final Logger logger = Logger.getLogger(DecoupledAuthenticationProviderBase.class);\n+\n+    protected KeycloakSession session;\n+    protected EventBuilder event;\n+\n+    protected MultivaluedMap<String, String> formParams;\n+\n+    protected RealmModel realm;\n+\n+    protected ClientModel client;\n+    protected Map<String, String> clientAuthAttributes;\n+\n+    @Context\n+    protected HttpHeaders headers;\n+    @Context\n+    protected HttpRequest httpRequest;\n+    @Context\n+    protected HttpResponse httpResponse;\n+    @Context\n+    protected ClientConnection clientConnection;\n+\n+    protected Cors cors;\n+\n+    public DecoupledAuthenticationProviderBase(KeycloakSession session) {\n+        this.session = session;\n+        realm = session.getContext().getRealm();\n+    }\n+\n+    @Override\n+    public void setEvent(EventBuilder event) {\n+        this.event = event;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processDecoupledAuthnResult() {\n+        event.event(EventType.LOGIN);\n+        headers = session.getContext().getContextObject(HttpHeaders.class);\n+        httpRequest = session.getContext().getContextObject(HttpRequest.class);\n+        httpResponse = session.getContext().getContextObject(HttpResponse.class);\n+        clientConnection = session.getContext().getContextObject(ClientConnection.class);\n+\n+        cors = Cors.add(httpRequest).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+        formParams = httpRequest.getDecodedFormParameters();\n+\n+        checkSsl();\n+        checkRealm();\n+        // here Client Model of Decoupled Authentication Server is set to this class member \"client\".\n+        // this will be overridden by Client Model of CD(Consumption Device) in verifyDecoupledAuthnResult().\n+        checkClient();\n+        logger.info(\" client_id = \" + client.getClientId());\n+\n+        MultivaluedMap<String, Object> outputHeaders = httpResponse.getOutputHeaders();\n+        outputHeaders.putSingle(\"Cache-Control\", \"no-store\");\n+        outputHeaders.putSingle(\"Pragma\", \"no-cache\");\n+\n+        Response response = verifyDecoupledAuthnResult();\n+        if (response != null) return response;\n+\n+        setupSessions();\n+\n+        persistDecoupledAuthenticationResult(DecoupledAuthStatus.SUCCEEDED);\n+\n+        return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+    }\n+\n+    private void setupSessions() {\n+        RootAuthenticationSessionModel rootAuthSession = session.authenticationSessions().createRootAuthenticationSession(realm, getUserSessionIdWillBeCreated());\n+        // here Client Model of CD(Consumption Device) needs to be used to bind its Client Session with User Session.\n+        AuthenticationSessionModel authSession = rootAuthSession.createAuthenticationSession(client);\n+\n+        authSession.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);\n+        authSession.setAction(AuthenticatedClientSessionModel.Action.AUTHENTICATE.name());\n+        authSession.setClientNote(OIDCLoginProtocol.ISSUER, Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()));\n+        authSession.setClientNote(OIDCLoginProtocol.SCOPE_PARAM, getScope());\n+        logger.info(\" specified scopes in backchannel authentication endpoint = \" + getScope());\n+\n+        // authentication\n+        AuthenticationFlowModel flow = AuthenticationFlowResolver.resolveCIBAFlow(authSession);\n+        String flowId = flow.getId();\n+        AuthenticationProcessor processor = new AuthenticationProcessor();\n+        processor.setAuthenticationSession(authSession)\n+                .setFlowId(flowId)\n+                .setConnection(clientConnection)\n+                .setEventBuilder(event)\n+                .setRealm(realm)\n+                .setSession(session)\n+                .setUriInfo(session.getContext().getUri())\n+                .setRequest(httpRequest);\n+\n+        processor.authenticateOnly();\n+        processor.evaluateRequiredActionTriggers();\n+        UserModel user = authSession.getAuthenticatedUser();\n+        if (user.getRequiredActionsStream().count() > 0) {\n+            event.error(Errors.RESOLVE_REQUIRED_ACTIONS);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"Account is not fully set up\", Response.Status.BAD_REQUEST);\n+        }\n+\n+        AuthenticationManager.setClientScopesInSession(authSession);\n+\n+        processor.attachSession();\n+        UserSessionModel userSession = processor.getUserSession();\n+        if (userSession == null) {\n+            event.error(Errors.USER_SESSION_NOT_FOUND);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"User session is not found\", Response.Status.BAD_REQUEST);\n+        } else {\n+            logger.infof(\" user session id =  %s, username = %s\", userSession.getId(), userSession.getUser().getUsername());\n+        }\n+        updateUserSessionFromClientAuth(userSession);\n+\n+        logger.infof(\"  Created User Session's id                            = %s\", userSession.getId());\n+        logger.infof(\"  Submitted in advance User Session ID Will Be Created = %s\", getUserSessionIdWillBeCreated());\n+\n+        // authorization (consent)\n+        UserConsentModel grantedConsent = session.users().getConsentByClient(realm, user.getId(), client.getId());\n+        if (grantedConsent == null) {\n+            grantedConsent = new UserConsentModel(client);\n+            session.users().addConsent(realm, user.getId(), grantedConsent);\n+            logger.info(\"  Consent updated : \");\n+            grantedConsent.getGrantedClientScopes().forEach(i->logger.info(i.getName()));\n+        }\n+\n+        boolean updateConsentRequired = false;\n+\n+        for (String clientScopeId : authSession.getClientScopes()) {\n+            ClientScopeModel clientScope = KeycloakModelUtils.findClientScopeById(realm, client, clientScopeId);\n+            if (clientScope != null) {\n+                if (!grantedConsent.isClientScopeGranted(clientScope) && clientScope.isDisplayOnConsentScreen()) {\n+                    grantedConsent.addGrantedClientScope(clientScope);\n+                    updateConsentRequired = true;\n+                }\n+            } else {\n+                logger.warnf(\"Client scope or client with ID '%s' not found\", clientScopeId);\n+            }\n+        }\n+\n+        if (updateConsentRequired) {\n+            session.users().updateConsent(realm, user.getId(), grantedConsent);\n+            logger.info(\"  Consent granted : \");\n+            grantedConsent.getGrantedClientScopes().forEach(i->logger.info(i.getName()));\n+        }\n+\n+        event.detail(Details.CONSENT, Details.CONSENT_VALUE_CONSENT_GRANTED);\n+\n+        event.success();\n+    }\n+\n+\n+    protected void persistDecoupledAuthenticationResult(String status) {\n+        DecoupledAuthnResult decoupledAuthnResult = new DecoupledAuthnResult(getExpiration(), status);\n+        DecoupledAuthnResultParser.persistDecoupledAuthnResult(session, getAuthResultId(), decoupledAuthnResult, getExpiration());\n+    }\n+\n+    abstract protected String getScope();\n+    abstract protected String getUserSessionIdWillBeCreated();\n+    abstract protected String getUserIdToBeAuthenticated();\n+    abstract protected String getAuthResultId();\n+    abstract protected int getExpiration();\n+\n+    abstract protected Response verifyDecoupledAuthnResult();\n+\n+    private void updateUserSessionFromClientAuth(UserSessionModel userSession) {\n+        for (Map.Entry<String, String> attr : clientAuthAttributes.entrySet()) {", "originalCommit": "098220ef66b8ff7bad8371639a102f03cf9e66d3", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3ODA0OTkzMQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r578049931", "bodyText": "@pedroigor Yes, that is right. I will write userSession.getNotes().putAll(clientAuthAttributes) directly on the caller of this method and remove it.", "author": "tnorimat", "createdAt": "2021-02-18T00:59:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU3NzU2OTQ1MQ=="}], "type": "inlineReview"}, {"oid": "6f0c208a4affc51479ffeffa99a5c59c5e43c10d", "url": "https://github.com/keycloak/keycloak/commit/6f0c208a4affc51479ffeffa99a5c59c5e43c10d", "message": "rebase master to resolve conflicts", "committedDate": "2021-02-21T20:29:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDU2MTM5MQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r580561391", "bodyText": "I would add an if statement prior to running this line to check if trace level is enabled.", "author": "pedroigor", "createdAt": "2021-02-22T20:18:05Z", "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/DecoupledAuthenticationProviderBase.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.util.Map;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.util.HttpHeaderNames;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.authentication.AuthenticationProcessor;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.AuthenticatedClientSessionModel;\n+import org.keycloak.models.AuthenticationFlowModel;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserConsentModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.UserSessionModel;\n+import org.keycloak.models.utils.AuthenticationFlowResolver;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.oidc.OIDCLoginProtocol;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;\n+import org.keycloak.protocol.oidc.utils.AuthorizeClientUtil;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+import org.keycloak.services.managers.AuthenticationManager;\n+import org.keycloak.services.resources.Cors;\n+import org.keycloak.sessions.AuthenticationSessionModel;\n+import org.keycloak.sessions.RootAuthenticationSessionModel;\n+\n+public abstract class DecoupledAuthenticationProviderBase implements DecoupledAuthenticationProvider, OIDCExtProvider {\n+\n+    private static final Logger logger = Logger.getLogger(DecoupledAuthenticationProviderBase.class);\n+\n+    protected KeycloakSession session;\n+    protected EventBuilder event;\n+\n+    protected MultivaluedMap<String, String> formParams;\n+\n+    protected RealmModel realm;\n+\n+    protected ClientModel client;\n+    protected Map<String, String> clientAuthAttributes;\n+\n+    protected Cors cors;\n+\n+    public DecoupledAuthenticationProviderBase(KeycloakSession session) {\n+        this.session = session;\n+        realm = session.getContext().getRealm();\n+    }\n+\n+    @Override\n+    public void setEvent(EventBuilder event) {\n+        this.event = event;\n+    }\n+\n+    @Override\n+    public void close() {\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processDecoupledAuthnResult() {\n+        event.event(EventType.LOGIN);\n+\n+        HttpRequest httpRequest = session.getContext().getContextObject(HttpRequest.class);\n+        ClientConnection clientConnection = session.getContext().getContextObject(ClientConnection.class);\n+\n+        cors = Cors.add(httpRequest).auth().allowedMethods(\"POST\").auth().exposedHeaders(Cors.ACCESS_CONTROL_ALLOW_METHODS);\n+        formParams = httpRequest.getDecodedFormParameters();\n+\n+        checkSsl(clientConnection);\n+        checkRealm();\n+        checkClient();\n+\n+        Response response = verifyDecoupledAuthnResult();\n+        if (response != null) return response;\n+\n+        setupSessions(httpRequest, clientConnection);\n+\n+        persistDecoupledAuthenticationResult(DecoupledAuthStatus.SUCCEEDED);\n+\n+        return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)\n+                .header(HttpHeaderNames.CACHE_CONTROL, \"no-store\")\n+                .header(HttpHeaderNames.PRAGMA, \"no-cache\"))\n+                .build();\n+    }\n+\n+    private void setupSessions(HttpRequest httpRequest, ClientConnection clientConnection) {\n+        RootAuthenticationSessionModel rootAuthSession = session.authenticationSessions().createRootAuthenticationSession(realm, getUserSessionIdWillBeCreated());\n+        // here Client Model of CD(Consumption Device) needs to be used to bind its Client Session with User Session.\n+        AuthenticationSessionModel authSession = rootAuthSession.createAuthenticationSession(client);\n+\n+        authSession.setProtocol(OIDCLoginProtocol.LOGIN_PROTOCOL);\n+        authSession.setAction(AuthenticatedClientSessionModel.Action.AUTHENTICATE.name());\n+        authSession.setClientNote(OIDCLoginProtocol.ISSUER, Urls.realmIssuer(session.getContext().getUri().getBaseUri(), realm.getName()));\n+        authSession.setClientNote(OIDCLoginProtocol.SCOPE_PARAM, getScope());\n+\n+        // authentication\n+        AuthenticationFlowModel flow = AuthenticationFlowResolver.resolveCIBAFlow(authSession);\n+        String flowId = flow.getId();\n+        AuthenticationProcessor processor = new AuthenticationProcessor();\n+        processor.setAuthenticationSession(authSession)\n+                .setFlowId(flowId)\n+                .setConnection(clientConnection)\n+                .setEventBuilder(event)\n+                .setRealm(realm)\n+                .setSession(session)\n+                .setUriInfo(session.getContext().getUri())\n+                .setRequest(httpRequest);\n+\n+        processor.authenticateOnly();\n+        processor.evaluateRequiredActionTriggers();\n+        UserModel user = authSession.getAuthenticatedUser();\n+        if (user.getRequiredActionsStream().count() > 0) {\n+            event.error(Errors.RESOLVE_REQUIRED_ACTIONS);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"Account is not fully set up\", Response.Status.BAD_REQUEST);\n+        }\n+\n+        AuthenticationManager.setClientScopesInSession(authSession);\n+\n+        processor.attachSession();\n+        UserSessionModel userSession = processor.getUserSession();\n+        if (userSession == null) {\n+            event.error(Errors.USER_SESSION_NOT_FOUND);\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"User session is not found\", Response.Status.BAD_REQUEST);\n+        }\n+        userSession.getNotes().putAll(clientAuthAttributes);\n+        logger.tracef(\"CIBA Grant :: specified scopes in backchannel authentication endpoint = %s, Created User Session's id = %s, Submitted in advance User Session ID Will Be Created = %s, username = %s\", getScope(), userSession.getId(), getUserSessionIdWillBeCreated(), userSession.getUser().getUsername());\n+\n+        // authorization (consent)\n+        UserConsentModel grantedConsent = session.users().getConsentByClient(realm, user.getId(), client.getId());\n+        if (grantedConsent == null) {\n+            grantedConsent = new UserConsentModel(client);\n+            session.users().addConsent(realm, user.getId(), grantedConsent);\n+            grantedConsent.getGrantedClientScopes().forEach(i->logger.tracef(\"CIBA Grant :: Consent granted. %s\", i.getName()));", "originalCommit": "6f0c208a4affc51479ffeffa99a5c59c5e43c10d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDc2MjIyMw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r580762223", "bodyText": "@pedroigor Yes, it is rational. I will add trace log level checks before logging.", "author": "tnorimat", "createdAt": "2021-02-23T04:30:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4MDU2MTM5MQ=="}], "type": "inlineReview"}, {"oid": "132f6b350528cbf6f8a212bfac88b1badc3a378e", "url": "https://github.com/keycloak/keycloak/commit/132f6b350528cbf6f8a212bfac88b1badc3a378e", "message": "remove CIBARepresentation add trace log facility check in advance", "committedDate": "2021-02-23T07:38:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDc1NDMyOA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r584754328", "bodyText": "This is going to cause an NPE if the param is not available from the request.", "author": "pedroigor", "createdAt": "2021-03-01T14:28:52Z", "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/HttpAuthenticationChannelProvider.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.broker.provider.util.SimpleHttp;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.CIBAAuthReqId;\n+import org.keycloak.protocol.ciba.CIBAConstants;\n+import org.keycloak.protocol.ciba.endpoints.request.BackchannelAuthenticationRequest;\n+import org.keycloak.protocol.ciba.resolvers.CIBALoginUserResolver;\n+import org.keycloak.protocol.ciba.utils.CIBAAuthReqIdParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+\n+public class HttpAuthenticationChannelProvider extends HttpAuthenticationChannelProviderBase {\n+\n+    private static final Logger logger = Logger.getLogger(HttpAuthenticationChannelProvider.class);\n+\n+    protected final String httpAuthenticationRequestUri;\n+\n+    public HttpAuthenticationChannelProvider(KeycloakSession session, String httpAuthenticationRequestUri) {\n+        super(session);\n+        this.httpAuthenticationRequestUri = httpAuthenticationRequestUri;\n+    }\n+\n+    protected String scope;\n+    protected String userSessionIdWillBeCreated;\n+    protected String userIdToBeAuthenticated;\n+    protected String authResultId;\n+    protected int expiration;\n+\n+    @Override\n+    protected String getScope() {\n+        return scope;\n+    }\n+\n+    @Override\n+    protected String getUserSessionIdWillBeCreated() {\n+        return userSessionIdWillBeCreated;\n+    }\n+\n+    @Override\n+    protected String getUserIdToBeAuthenticated() {\n+        return userIdToBeAuthenticated;\n+    }\n+\n+    @Override\n+    protected String getAuthResultId() {\n+        return authResultId;\n+    }\n+\n+    @Override\n+    protected int getExpiration() {\n+        return expiration;\n+    }\n+\n+    @Override\n+    protected Response verifyDecoupledAuthnResult() {\n+        String decoupledAuthId = formParams.getFirst(HttpAuthenticationChannelProvider.DECOUPLED_AUTHN_ID);\n+        ParseResult parseResult = parseDecoupledAuthId(session, decoupledAuthId, event);\n+\n+        if (parseResult.isIllegalDecoupledAuthId()) {\n+            event.error(Errors.INVALID_INPUT);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.UNKNOWN);\n+            // decoupled auth id format is invalid or it has already been used\n+            throw new CorsErrorResponseException(cors, OAuthErrorException.INVALID_GRANT, \"invalid decoupled authn id\", Response.Status.BAD_REQUEST);\n+        } else if (parseResult.isExpiredDecoupledAuthId()) {\n+            event.error(Errors.SESSION_EXPIRED);\n+            persistDecoupledAuthenticationResult(DecoupledAuthStatus.EXPIRED);\n+            return cors.builder(Response.ok(\"\", MediaType.APPLICATION_JSON_TYPE)).build();\n+        }\n+\n+        CIBAAuthReqId decoupledAuthIdJwt = parseResult.decoupledAuthIdJwt();\n+        authResultId = decoupledAuthIdJwt.getAuthResultId();\n+        scope = decoupledAuthIdJwt.getScope();\n+        expiration = decoupledAuthIdJwt.getExp().intValue();\n+        userSessionIdWillBeCreated = decoupledAuthIdJwt.getSessionState();\n+        userIdToBeAuthenticated = decoupledAuthIdJwt.getSubject();\n+        // to bind Client Session of CD(Consumption Device) with User Session, set CD's Client Model to this class member \"client\".\n+        client = realm.getClientByClientId(decoupledAuthIdJwt.getIssuedFor());\n+\n+        CIBALoginUserResolver resolver = session.getProvider(CIBALoginUserResolver.class);\n+        if (resolver == null) {\n+            throw new RuntimeException(\"CIBA Login User Resolver not setup properly.\");\n+        }\n+        String userIdAuthenticated = resolver.getUserFromInfoUsedByAuthentication(formParams.getFirst(HttpAuthenticationChannelProvider.DECOUPLED_AUTHN_USER_INFO)).getId();", "originalCommit": "fcbea7a2f9ce743bd5503edc43464c8bb01c1721", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDc1NTQ3MA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r584755470", "bodyText": "Does it make more sense to move all this method to the CIBADecoupledAuthenticator ?\nPlease, see my last comment about whether we need a CIBA flow.", "author": "pedroigor", "createdAt": "2021-03-01T14:30:19Z", "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/HttpAuthenticationChannelProvider.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.broker.provider.util.SimpleHttp;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.ClientScopeModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.ciba.CIBAAuthReqId;\n+import org.keycloak.protocol.ciba.CIBAConstants;\n+import org.keycloak.protocol.ciba.endpoints.request.BackchannelAuthenticationRequest;\n+import org.keycloak.protocol.ciba.resolvers.CIBALoginUserResolver;\n+import org.keycloak.protocol.ciba.utils.CIBAAuthReqIdParser;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthStatus;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResult;\n+import org.keycloak.protocol.ciba.utils.DecoupledAuthnResultParser;\n+import org.keycloak.services.CorsErrorResponseException;\n+import org.keycloak.services.Urls;\n+\n+public class HttpAuthenticationChannelProvider extends HttpAuthenticationChannelProviderBase {\n+\n+    private static final Logger logger = Logger.getLogger(HttpAuthenticationChannelProvider.class);\n+\n+    protected final String httpAuthenticationRequestUri;\n+\n+    public HttpAuthenticationChannelProvider(KeycloakSession session, String httpAuthenticationRequestUri) {\n+        super(session);\n+        this.httpAuthenticationRequestUri = httpAuthenticationRequestUri;\n+    }\n+\n+    protected String scope;\n+    protected String userSessionIdWillBeCreated;\n+    protected String userIdToBeAuthenticated;\n+    protected String authResultId;\n+    protected int expiration;\n+\n+    @Override\n+    protected String getScope() {\n+        return scope;\n+    }\n+\n+    @Override\n+    protected String getUserSessionIdWillBeCreated() {\n+        return userSessionIdWillBeCreated;\n+    }\n+\n+    @Override\n+    protected String getUserIdToBeAuthenticated() {\n+        return userIdToBeAuthenticated;\n+    }\n+\n+    @Override\n+    protected String getAuthResultId() {\n+        return authResultId;\n+    }\n+\n+    @Override\n+    protected int getExpiration() {\n+        return expiration;\n+    }\n+\n+    @Override\n+    protected Response verifyDecoupledAuthnResult() {", "originalCommit": "fcbea7a2f9ce743bd5503edc43464c8bb01c1721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4OTE4Mjg3NA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r589182874", "bodyText": "@pedroigor I see, I've renamed this method.", "author": "tnorimat", "createdAt": "2021-03-08T05:46:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDc1NTQ3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDc1NjkzOA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r584756938", "bodyText": "Like in other places, I think we should remove all references to \"decoupled\" to reference \"authentication channel\" instead?", "author": "pedroigor", "createdAt": "2021-03-01T14:32:15Z", "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/HttpAuthenticationChannelProvider.java", "diffHunk": "@@ -0,0 +1,296 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;", "originalCommit": "fcbea7a2f9ce743bd5503edc43464c8bb01c1721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4OTE4MzAzNQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r589183035", "bodyText": "@pedroigor I've rename \"decoupled\" with \"authentication channel\".", "author": "tnorimat", "createdAt": "2021-03-08T05:47:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDc1NjkzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDc1OTA5Ng==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r584759096", "bodyText": "Wouldn't be easier to just have a single HttpAuthenticationChannepProvider for both http and https schemes?", "author": "pedroigor", "createdAt": "2021-03-01T14:35:07Z", "path": "services/src/main/java/org/keycloak/protocol/ciba/decoupledauthn/HttpsAuthenticationChannelProvider.java", "diffHunk": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2021 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.ciba.decoupledauthn;\n+\n+import org.jboss.logging.Logger;\n+import org.keycloak.models.KeycloakSession;\n+\n+public class HttpsAuthenticationChannelProvider extends HttpAuthenticationChannelProvider {", "originalCommit": "fcbea7a2f9ce743bd5503edc43464c8bb01c1721", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4OTE4NDU1MA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r589184550", "bodyText": "@pedroigor  I see, I will modify HttpAuthenticationChannepProvider to allow only both http and https scheme.", "author": "tnorimat", "createdAt": "2021-03-08T05:52:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU4NDc1OTA5Ng=="}], "type": "inlineReview"}, {"oid": "557ec24025cc86e630da1ef29c13d5cc38435ad1", "url": "https://github.com/keycloak/keycloak/commit/557ec24025cc86e630da1ef29c13d5cc38435ad1", "message": "KEYCLOAK-12137 OpenID Connect Client Initiated Backchannel Authentication (CIBA)\n\nCo-authored-by: Andrii Murashkin <amu@adorsys.com.ua>\nCo-authored-by: Christophe Lannoy <c4r1570p4e@gmail.com>", "committedDate": "2021-03-07T23:20:38Z", "type": "forcePushed"}, {"oid": "b7187a29bf4b6a6c1b2119291b10aefa31b4d295", "url": "https://github.com/keycloak/keycloak/commit/b7187a29bf4b6a6c1b2119291b10aefa31b4d295", "message": "KEYCLOAK-12137 OpenID Connect Client Initiated Backchannel Authentication (CIBA)\n\nCo-authored-by: Andrii Murashkin <amu@adorsys.com.ua>\nCo-authored-by: Christophe Lannoy <c4r1570p4e@gmail.com>", "committedDate": "2021-03-08T07:23:23Z", "type": "forcePushed"}, {"oid": "4ba2e1eedcfd3fa6714789f0c99ecc0bb62b2d71", "url": "https://github.com/keycloak/keycloak/commit/4ba2e1eedcfd3fa6714789f0c99ecc0bb62b2d71", "message": "fix CIBATest", "committedDate": "2021-03-22T01:30:26Z", "type": "forcePushed"}, {"oid": "a0c3846cf6d86e45f501a6de1e28f0efbaa25991", "url": "https://github.com/keycloak/keycloak/commit/a0c3846cf6d86e45f501a6de1e28f0efbaa25991", "message": "fix CIBATest", "committedDate": "2021-03-22T04:04:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQwODcxMA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599408710", "bodyText": "Shouldn't we throw an exception in case that unsupported token delivery mode is used? Accepting for example \"ping\" may indicate that Keycloak supports that, even if not.", "author": "mposolda", "createdAt": "2021-03-23T09:38:13Z", "path": "services/src/main/java/org/keycloak/services/clientregistration/oidc/DescriptionConverter.java", "diffHunk": "@@ -165,6 +165,10 @@ public static ClientRepresentation toInternal(KeycloakSession session, OIDCClien\n             configWrapper.setBackchannelLogoutRevokeOfflineTokens(clientOIDC.getBackchannelLogoutRevokeOfflineTokens());\n         }\n \n+        if (clientOIDC.getBackchannelTokenDeliveryMode() != null) {\n+            configWrapper.setBackchannelTokenDeliveryMode(clientOIDC.getBackchannelTokenDeliveryMode());", "originalCommit": "077f83af85195f4db9fffc0f1e245efc12d46f80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQ5NjgwMg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599496802", "bodyText": "Makes sense. I did not go through client registration, my fault. Good, you are looking at it now.", "author": "pedroigor", "createdAt": "2021-03-23T11:48:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQwODcxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDI0Mjc1NA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r600242754", "bodyText": "@mposolda @pedroigor I see. I will revise codes to throw ClientRegistrationException if the unsupported token delivery mode be used.", "author": "tnorimat", "createdAt": "2021-03-24T07:51:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQwODcxMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzQ0NzMyOQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r617447329", "bodyText": "@mposolda I've resolved it (ebe569c).", "author": "tnorimat", "createdAt": "2021-04-21T11:25:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQwODcxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxMjY1Ng==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599412656", "bodyText": "@tnorimat @pedroigor Comment to DescriptionConverter.getOIDCGrantTypes: According to the specification https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#registration, there is this: When using the ping or poll mode, the Client MUST include the CIBA grant type in the \"grant_types\" field. . However we don't include it here. For example for Device Grant, we correctly include the device grant type based on whether the device grant is enabled for client or not.\nRelated question: For CIBA, we don't have switch for the client to specify if CIBA grant type is enabled for the client or not. Shouldn't we have this switch similarly like we have it for the Device Grant? It seems to me that yes. For example see the example from the end of the section https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#registration . This registration request specifies that CIBA is required (and only supported) grant type for this client. IMO we should allow to convert such registration request to the Keycloak client, which will have only CIBA grant allowed and not any other grant types. Hence I suggest, we should also change the DescriptionConverter.toInternal to propagate the OIDC \"grant_types\" field to enable CIBA for the client in case that CIBA grant type is enabled.\nRelated note for device grant: I've just noticed that in DescriptionConverter.toInternal, for some reason we missed to convert OIDC device grant type to the switch for enabling device grant for the client. I suggest we fix this as well when we're at this (or maybe we can create separate JIRA for it?)", "author": "mposolda", "createdAt": "2021-03-23T09:43:47Z", "path": "services/src/main/java/org/keycloak/services/clientregistration/oidc/DescriptionConverter.java", "diffHunk": "@@ -270,6 +274,10 @@ public static OIDCClientRepresentation toExternalResponse(KeycloakSession sessio\n         response.setBackchannelLogoutSessionRequired(config.isBackchannelLogoutSessionRequired());\n         response.setBackchannelLogoutSessionRequired(config.getBackchannelLogoutRevokeOfflineTokens());\n \n+        if (config.getBackchannelTokenDeliveryMode() != null) {\n+            response.setBackchannelTokenDeliveryMode(config.getBackchannelTokenDeliveryMode());\n+        }\n+\n         List<ProtocolMapperRepresentation> foundPairwiseMappers = PairwiseSubMapperUtils.getPairwiseSubMappers(client);\n         SubjectType subjectType = foundPairwiseMappers.isEmpty() ? SubjectType.PUBLIC : SubjectType.PAIRWISE;\n         response.setSubjectType(subjectType.toString().toLowerCase());", "originalCommit": "077f83af85195f4db9fffc0f1e245efc12d46f80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQ5NjI4Nw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599496287", "bodyText": "Makes sense for me.", "author": "pedroigor", "createdAt": "2021-03-23T11:47:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxMjY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTA3MzI3NA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r601073274", "bodyText": "@mposolda @pedroigor I agree with you. How about the followings?\n\nadd CIBA Grant switch the same as Device Grant.\nin DescriptionConverter.getOIDCGrantTypes, convert CIBA Grant switch setting to the value of grant_type\nin DescriptionConverter.toInternal, convert the value of grant_type to CIBA Grant switch setting.\n\nThe current DescriptionConverter.toInternal, Resource Owner Password Credentials Grant and Client Credentials Grant are converted their value of grant_type to their switch settings (Direct Access, Service Account) while others are determined based on response_type. IMO we might reconsider the logic so that it could be treated as the other JIRA ticket.", "author": "tnorimat", "createdAt": "2021-03-25T05:56:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxMjY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjA2OTU1MA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r602069550", "bodyText": "+1. The OIDC client registration specification ( https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata ) mentions this: The following table lists the correspondence between response_type values that the Client will use and grant_type values that MUST be included in the registered grant_types list .\nSo in theory, we may throw the exception during client registration in case that grant_types and response_types are incompatible? For example if response_types is just authorization_code, but the grant_types has also grants for implicit/hybrid flow like code id_token etc.\nBut that is maybe something for the future? For CIBA, there is no corresponding response type AFAIK (Similarly like for example for Resource Owner Password Credentials or Client Credentials Grant). Hence in this PR, I would just convert grant type for CIBA to the corresponding switch of client as you suggested.", "author": "mposolda", "createdAt": "2021-03-26T07:37:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxMjY1Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgwOTk3Mw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r602809973", "bodyText": "@mposolda\n\nSo in theory, we may throw the exception during client registration in case that grant_types and response_types are incompatible? For example if response_types is just authorization_code, but the grant_types has also grants for implicit/hybrid flow like code id_token etc.\n\nYes, in theory, we thrown an exception in this case.\nFor CIBA, it is not relevant to response_type as you mentioned. Therefore, I would like to convert grant_type and the switch setting.", "author": "tnorimat", "createdAt": "2021-03-28T00:32:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxMjY1Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxNDI5MA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599414290", "bodyText": "@pedroigor Should this switch be moved to the CibaConfig? Not a big deal, but I've noticed that you added client-specific switches to the OAuth2DeviceConfig class. Hence I wonder if CIBA client-specific switches should be also moved there to align with device grant?\nSame might apply to the client switch for \"CIBA Enabled\" if we add it (See my comment in the DescriptionConverter class)", "author": "mposolda", "createdAt": "2021-03-23T09:45:58Z", "path": "services/src/main/java/org/keycloak/protocol/oidc/OIDCAdvancedConfigWrapper.java", "diffHunk": "@@ -220,6 +220,14 @@ public void setBackchannelLogoutRevokeOfflineTokens(boolean backchannelLogoutRev\n         setAttribute(OIDCConfigAttributes.BACKCHANNEL_LOGOUT_REVOKE_OFFLINE_TOKENS, val);\n     }\n \n+    public String getBackchannelTokenDeliveryMode() {", "originalCommit": "077f83af85195f4db9fffc0f1e245efc12d46f80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQ5NTc4Nw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599495787", "bodyText": "I agree. As much we can have in a central place better.", "author": "pedroigor", "createdAt": "2021-03-23T11:46:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxNDI5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxNDg1NA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599414854", "bodyText": "My vote is to rename this class to something like \"CibaRootEndpoint\" or \"CibaExtEndpoint\" . CibaEndpoint implies to me that it inherits from \"AbstractCibaEndpoint\", which is not the case. But maybe it is just me.. I don't have strong opinion in regards to this one...:)", "author": "mposolda", "createdAt": "2021-03-23T09:46:47Z", "path": "services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/CibaEndpoint.java", "diffHunk": "@@ -0,0 +1,96 @@\n+/*\n+ *\n+ *  * Copyright 2021  Red Hat, Inc. and/or its affiliates\n+ *  * and other contributors as indicated by the @author tags.\n+ *  *\n+ *  * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  * you may not use this file except in compliance with the License.\n+ *  * You may obtain a copy of the License at\n+ *  *\n+ *  * http://www.apache.org/licenses/LICENSE-2.0\n+ *  *\n+ *  * Unless required by applicable law or agreed to in writing, software\n+ *  * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  * See the License for the specific language governing permissions and\n+ *  * limitations under the License.\n+ *\n+ */\n+\n+package org.keycloak.protocol.oidc.grants.ciba.endpoints;\n+\n+import javax.ws.rs.Path;\n+\n+import org.jboss.resteasy.spi.ResteasyProviderFactory;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProvider;\n+import org.keycloak.protocol.oidc.ext.OIDCExtProviderFactory;\n+\n+/**\n+ * @author <a href=\"mailto:psilva@redhat.com\">Pedro Igor</a>\n+ */\n+public class CibaEndpoint implements OIDCExtProvider, OIDCExtProviderFactory {", "originalCommit": "077f83af85195f4db9fffc0f1e245efc12d46f80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQ5NTQ3MQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599495471", "bodyText": "I see your point, but I would leave it as is. No hard opinion about names.", "author": "pedroigor", "createdAt": "2021-03-23T11:45:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxNDg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUzNTgxNA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599535814", "bodyText": "We can leave to @tnorimat whatever he prefers. I am also fine with either way to keep or rename.", "author": "mposolda", "createdAt": "2021-03-23T12:48:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxNDg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDI2MzIwNA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r600263204", "bodyText": "@mposolda @pedroigor My vote is to rename as @mposolda proposed.", "author": "tnorimat", "createdAt": "2021-03-24T08:25:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxNDg1NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzQ2MTI2OQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r617461269", "bodyText": "@mposolda I've renamed to CibaRootEndpoint (ca47e4d).", "author": "tnorimat", "createdAt": "2021-04-21T11:47:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxNDg1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxNTQzNQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599415435", "bodyText": "This comment is outdated. For example it mentions userSessionIdWillBeCreated, which doesn't exists anymore in this PR. I suggest to either remove this comment or make it up-to-date to avoid confusions and outdated info in the source code comments.", "author": "mposolda", "createdAt": "2021-03-23T09:47:27Z", "path": "services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/channel/HttpAuthenticationChannelProvider.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.oidc.grants.ciba.channel;\n+\n+import static org.keycloak.OAuth2Constants.SCOPE;\n+import static org.keycloak.protocol.oidc.grants.ciba.CibaGrantType.BINDING_MESSAGE;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.keycloak.broker.provider.util.SimpleHttp;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;\n+import org.keycloak.services.resources.Cors;\n+\n+public class HttpAuthenticationChannelProvider implements AuthenticationChannelProvider{\n+\n+    public static final String AUTHENTICATION_CHANNEL_ID = \"authentication_channel_id\";\n+    public static final String AUTHENTICATION_CHANNEL_USER_INFO = \"user_info\";\n+    public static final String AUTHENTICATION_STATUS = \"auth_result\";\n+    public static final String AUTHENTICATION_CHANNEL_IS_CONSENT_REQUIRED = \"is_consent_required\";\n+\n+    protected KeycloakSession session;\n+    protected MultivaluedMap<String, String> formParams;\n+    protected RealmModel realm;\n+    protected Map<String, String> clientAuthAttributes;\n+    protected Cors cors;\n+    protected final String httpAuthenticationChannelUri;\n+\n+    public HttpAuthenticationChannelProvider(KeycloakSession session, String httpAuthenticationRequestUri) {\n+        this.session = session;\n+        this.realm = session.getContext().getRealm();\n+        this.httpAuthenticationChannelUri = httpAuthenticationRequestUri;\n+    }\n+\n+    @Override\n+    public boolean requestAuthentication(AuthenticationRequest request, String infoUsedByAuthenticator) {\n+        // create JWT formatted/JWS signed/JWE encrypted Authentication Channel ID by the same manner in creating auth_req_id", "originalCommit": "077f83af85195f4db9fffc0f1e245efc12d46f80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDI2NzI0MQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r600267241", "bodyText": "@mposolda Yes, I will update or remove comments on this PR.", "author": "tnorimat", "createdAt": "2021-03-24T08:32:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxNTQzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxNjY4MQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599416681", "bodyText": "@pedroigor I see that for CIBA, we don't use OAuth2DeviceUserCodeModel for anything. The callback and grant endpoints need just the deviceCode. Currently after finish the CIBA flow, the \"userCode\" entry still remains in the cache as a thombstone until it is expired (which is usually in a short period of time, but still). So should be better to just send \"null\" as a \"userCode\" argument to the OAuth2DeviceTokenStoreProvider?", "author": "mposolda", "createdAt": "2021-03-23T09:49:05Z", "path": "services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationEndpoint.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.oidc.grants.ciba.endpoints;\n+\n+import static org.keycloak.protocol.oidc.OIDCLoginProtocol.ID_TOKEN_HINT;\n+import static org.keycloak.protocol.oidc.OIDCLoginProtocol.LOGIN_HINT_PARAM;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import org.jboss.resteasy.annotations.cache.NoCache;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.common.Profile;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.CibaConfig;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.OAuth2DeviceCodeModel;\n+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;\n+import org.keycloak.models.OAuth2DeviceUserCodeModel;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationChannelProvider;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationRequest;\n+import org.keycloak.protocol.oidc.grants.ciba.resolvers.CIBALoginUserResolver;\n+import org.keycloak.services.ErrorResponseException;\n+import org.keycloak.util.JsonSerialization;\n+import org.keycloak.utils.ProfileHelper;\n+\n+public class BackchannelAuthenticationEndpoint extends AbstractCibaEndpoint {\n+\n+    private final RealmModel realm;\n+\n+    public BackchannelAuthenticationEndpoint(KeycloakSession session, EventBuilder event) {\n+        super(session, event);\n+        this.realm = session.getContext().getRealm();\n+        event.event(EventType.LOGIN);\n+    }\n+\n+    @POST\n+    @NoCache\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processGrantRequest(@Context HttpRequest httpRequest) {\n+        ProfileHelper.requireFeature(Profile.Feature.CIBA);\n+        AuthenticationRequest request = authorizeClient(httpRequest.getDecodedFormParameters());\n+\n+        try {\n+            String authReqId = request.serialize(session);\n+            AuthenticationChannelProvider provider = session.getProvider(AuthenticationChannelProvider.class);\n+\n+            if (provider == null) {\n+                throw new RuntimeException(\"Authentication Channel Provider not found.\");\n+            }\n+\n+            CIBALoginUserResolver resolver = session.getProvider(CIBALoginUserResolver.class);\n+\n+            if (resolver == null) {\n+                throw new RuntimeException(\"CIBA Login User Resolver not setup properly.\");\n+            }\n+\n+            UserModel user = request.getUser();\n+\n+            String infoUsedByAuthentication = resolver.getInfoUsedByAuthentication(user);\n+\n+            if (provider.requestAuthentication(request, infoUsedByAuthentication)) {\n+                CibaConfig cibaPolicy = realm.getCibaPolicy();\n+                int poolingInterval = cibaPolicy.getPoolingInterval();\n+\n+                storeAuthenticationRequest(request, cibaPolicy);\n+\n+                ObjectNode response = JsonSerialization.createObjectNode();\n+\n+                response.put(CibaGrantType.AUTH_REQ_ID, authReqId)\n+                        .put(OAuth2Constants.EXPIRES_IN, cibaPolicy.getExpiresIn());\n+\n+                if (poolingInterval > 0) {\n+                    response.put(OAuth2Constants.INTERVAL, poolingInterval);\n+                }\n+\n+                return Response.ok(JsonSerialization.writeValueAsBytes(response))\n+                        .build();\n+            }\n+        } catch (Exception e) {\n+            throw new ErrorResponseException(OAuthErrorException.SERVER_ERROR, \"Failed to send authentication request\", Response.Status.SERVICE_UNAVAILABLE);\n+        }\n+\n+        throw new ErrorResponseException(OAuthErrorException.SERVER_ERROR, \"Unexpected response from authentication device\", Response.Status.SERVICE_UNAVAILABLE);\n+    }\n+\n+    /**\n+     * TODO: Leverage the device code storage for tracking authentication requests. Not sure if we need a specific storage,\n+     * but probably make the {@link OAuth2DeviceTokenStoreProvider} more generic for ciba, device, or any other use case\n+     * that relies on cross-references for unsolicited user authentication requests from devices.\n+     */\n+    private void storeAuthenticationRequest(AuthenticationRequest request, CibaConfig cibaConfig) {\n+        ClientModel client = request.getClient();\n+        int expiresIn = cibaConfig.getExpiresIn();\n+        int poolingInterval = cibaConfig.getPoolingInterval();\n+\n+        OAuth2DeviceCodeModel deviceCode = OAuth2DeviceCodeModel.create(realm, client,\n+                request.getId(), request.getScope(), null, expiresIn, poolingInterval,\n+                Collections.emptyMap());\n+        String authResultId = request.getAuthResultId();\n+        OAuth2DeviceUserCodeModel userCode = new OAuth2DeviceUserCodeModel(realm, deviceCode.getDeviceCode(),\n+                authResultId);\n+\n+        // To inform \"expired_token\" to the client, the lifespan of the cache provider is longer than device code\n+        int lifespanSeconds = expiresIn + poolingInterval + 10;\n+\n+        OAuth2DeviceTokenStoreProvider store = session.getProvider(OAuth2DeviceTokenStoreProvider.class);\n+\n+        store.put(deviceCode, userCode, lifespanSeconds);", "originalCommit": "077f83af85195f4db9fffc0f1e245efc12d46f80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTQzMDk5MQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r619430991", "bodyText": "We use it at the callback endpoint. The usage is similar to device code, where the user code is the so-called auth_result_id.", "author": "pedroigor", "createdAt": "2021-04-23T18:48:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxNjY4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxOTc3NjM2OQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r619776369", "bodyText": "@mposolda As @pedroigor stated, I also think that OAuth2DeviceUserCodeModel is needed. In this context, auth_result_id included in this model takes the same role of user_code, namely being used as the key to retrieve the context data from the cache on BackchannelAuthenticationCallbackEndpoint.", "author": "tnorimat", "createdAt": "2021-04-25T08:39:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxNjY4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYyMDA2MDM3OA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r620060378", "bodyText": "I am not 100% sure, but this is not big issue regardless as entry from the cache should be removed after very short time anyway. We can eventually doublecheck in the future... I am resolving this comment for now.", "author": "mposolda", "createdAt": "2021-04-26T08:01:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxNjY4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxOTAxNg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599419016", "bodyText": "@tnorimat @pedroigor I have one minor concern regarding \"acr_values\" . Keycloak currently doesn't properly support this parameter inside Keycloak authentication flows. However in the case of CIBA, Keycloak delegates authentication to the authentication channel to happen outside of Keycloak. Hence I wonder if we should allow this \"acr_parameter\" and include it via the HttpAuthenticationChannelProvider.requestAuthentication for the case that authentication channel supports it?\nAlternatively to sending acr_values to the channel provider, I think we can also support to have more AuthenticationChannelProvider implementations and Keycloak can decide which AuthenticationChannelProvider to use based on the \"acr_values\" parameter. At least, that is my understanding how it could work based on the specification https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#auth_server_obtains_consent . See especially this comment in the specs After the OP has validated the Authentication Request, the OP identifies the user and chooses a channel to best authenticate the user and authorize the request, in line with the Client's requests regarding acr_values. .\nThis support for acr_values is not a blocker for this PR IMO, just something to consider...", "author": "mposolda", "createdAt": "2021-03-23T09:52:13Z", "path": "services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationEndpoint.java", "diffHunk": "@@ -0,0 +1,243 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.oidc.grants.ciba.endpoints;\n+\n+import static org.keycloak.protocol.oidc.OIDCLoginProtocol.ID_TOKEN_HINT;\n+import static org.keycloak.protocol.oidc.OIDCLoginProtocol.LOGIN_HINT_PARAM;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import org.jboss.resteasy.annotations.cache.NoCache;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.common.Profile;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.CibaConfig;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.OAuth2DeviceCodeModel;\n+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;\n+import org.keycloak.models.OAuth2DeviceUserCodeModel;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationChannelProvider;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationRequest;\n+import org.keycloak.protocol.oidc.grants.ciba.resolvers.CIBALoginUserResolver;\n+import org.keycloak.services.ErrorResponseException;\n+import org.keycloak.util.JsonSerialization;\n+import org.keycloak.utils.ProfileHelper;\n+\n+public class BackchannelAuthenticationEndpoint extends AbstractCibaEndpoint {\n+\n+    private final RealmModel realm;\n+\n+    public BackchannelAuthenticationEndpoint(KeycloakSession session, EventBuilder event) {\n+        super(session, event);\n+        this.realm = session.getContext().getRealm();\n+        event.event(EventType.LOGIN);\n+    }\n+\n+    @POST\n+    @NoCache\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processGrantRequest(@Context HttpRequest httpRequest) {\n+        ProfileHelper.requireFeature(Profile.Feature.CIBA);\n+        AuthenticationRequest request = authorizeClient(httpRequest.getDecodedFormParameters());\n+\n+        try {\n+            String authReqId = request.serialize(session);\n+            AuthenticationChannelProvider provider = session.getProvider(AuthenticationChannelProvider.class);\n+\n+            if (provider == null) {\n+                throw new RuntimeException(\"Authentication Channel Provider not found.\");\n+            }\n+\n+            CIBALoginUserResolver resolver = session.getProvider(CIBALoginUserResolver.class);\n+\n+            if (resolver == null) {\n+                throw new RuntimeException(\"CIBA Login User Resolver not setup properly.\");\n+            }\n+\n+            UserModel user = request.getUser();\n+\n+            String infoUsedByAuthentication = resolver.getInfoUsedByAuthentication(user);\n+\n+            if (provider.requestAuthentication(request, infoUsedByAuthentication)) {\n+                CibaConfig cibaPolicy = realm.getCibaPolicy();\n+                int poolingInterval = cibaPolicy.getPoolingInterval();\n+\n+                storeAuthenticationRequest(request, cibaPolicy);\n+\n+                ObjectNode response = JsonSerialization.createObjectNode();\n+\n+                response.put(CibaGrantType.AUTH_REQ_ID, authReqId)\n+                        .put(OAuth2Constants.EXPIRES_IN, cibaPolicy.getExpiresIn());\n+\n+                if (poolingInterval > 0) {\n+                    response.put(OAuth2Constants.INTERVAL, poolingInterval);\n+                }\n+\n+                return Response.ok(JsonSerialization.writeValueAsBytes(response))\n+                        .build();\n+            }\n+        } catch (Exception e) {\n+            throw new ErrorResponseException(OAuthErrorException.SERVER_ERROR, \"Failed to send authentication request\", Response.Status.SERVICE_UNAVAILABLE);\n+        }\n+\n+        throw new ErrorResponseException(OAuthErrorException.SERVER_ERROR, \"Unexpected response from authentication device\", Response.Status.SERVICE_UNAVAILABLE);\n+    }\n+\n+    /**\n+     * TODO: Leverage the device code storage for tracking authentication requests. Not sure if we need a specific storage,\n+     * but probably make the {@link OAuth2DeviceTokenStoreProvider} more generic for ciba, device, or any other use case\n+     * that relies on cross-references for unsolicited user authentication requests from devices.\n+     */\n+    private void storeAuthenticationRequest(AuthenticationRequest request, CibaConfig cibaConfig) {\n+        ClientModel client = request.getClient();\n+        int expiresIn = cibaConfig.getExpiresIn();\n+        int poolingInterval = cibaConfig.getPoolingInterval();\n+\n+        OAuth2DeviceCodeModel deviceCode = OAuth2DeviceCodeModel.create(realm, client,\n+                request.getId(), request.getScope(), null, expiresIn, poolingInterval,\n+                Collections.emptyMap());\n+        String authResultId = request.getAuthResultId();\n+        OAuth2DeviceUserCodeModel userCode = new OAuth2DeviceUserCodeModel(realm, deviceCode.getDeviceCode(),\n+                authResultId);\n+\n+        // To inform \"expired_token\" to the client, the lifespan of the cache provider is longer than device code\n+        int lifespanSeconds = expiresIn + poolingInterval + 10;\n+\n+        OAuth2DeviceTokenStoreProvider store = session.getProvider(OAuth2DeviceTokenStoreProvider.class);\n+\n+        store.put(deviceCode, userCode, lifespanSeconds);\n+    }\n+\n+    private AuthenticationRequest authorizeClient(MultivaluedMap<String, String> params) {\n+        ClientModel client = authenticateClient();\n+        UserModel user = resolveUser(params, realm.getCibaPolicy().getAuthRequestedUserHint());\n+\n+        AuthenticationRequest request = new AuthenticationRequest(session, user, client);\n+\n+        request.setClient(client);\n+\n+        String scope = params.getFirst(OAuth2Constants.SCOPE);\n+\n+        if (scope == null)\n+            throw new ErrorResponseException(OAuthErrorException.INVALID_REQUEST, \"missing parameter : scope\",\n+                    Response.Status.BAD_REQUEST);\n+\n+        request.setScope(scope);\n+\n+        request.setBindingMessage(params.getFirst(CibaGrantType.BINDING_MESSAGE));\n+\n+        CibaConfig policy = realm.getCibaPolicy();\n+\n+        // create JWE encoded auth_req_id from Auth Req ID.\n+        Integer expiresIn = policy.getExpiresIn();\n+        String requestedExpiry = params.getFirst(CibaGrantType.REQUESTED_EXPIRY);\n+\n+        if (requestedExpiry != null) {\n+            expiresIn = Integer.valueOf(requestedExpiry);\n+        }\n+\n+        request.exp(Time.currentTime() + expiresIn.longValue());\n+\n+        StringBuilder scopes = new StringBuilder(Optional.ofNullable(request.getScope()).orElse(\"\"));\n+        client.getClientScopes(true, true)\n+                .forEach((key, value) -> {\n+                    if (value.isDisplayOnConsentScreen())\n+                        scopes.append(\" \").append(value.getName());\n+                });\n+        request.setScope(scopes.toString());\n+\n+        String clientNotificationToken = params.getFirst(CibaGrantType.CLIENT_NOTIFICATION_TOKEN);\n+\n+        if (clientNotificationToken != null) {\n+            throw new ErrorResponseException(OAuthErrorException.INVALID_REQUEST,\n+                    \"Ping and push modes not supported. Use poll mode instead.\", Response.Status.BAD_REQUEST);\n+        }\n+\n+        String userCode = params.getFirst(OAuth2Constants.USER_CODE);\n+\n+        if (userCode != null) {\n+            throw new ErrorResponseException(OAuthErrorException.INVALID_REQUEST, \"User code not supported\",\n+                    Response.Status.BAD_REQUEST);\n+        }\n+\n+        String acrValues = params.getFirst(OAuth2Constants.ACR_VALUES);\n+\n+        if (acrValues != null) {", "originalCommit": "077f83af85195f4db9fffc0f1e245efc12d46f80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTg3NTQzNw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r601875437", "bodyText": "@mposolda @pedroigor IMO, this point might be treated afterwards as some follow-up PR by considering the following points.\n\nacr has not yet been supported completely (mentioned in KEYCLOAK-3314) .\nthis PR's design document does not treat acr_values of CIBA's parameter.\n\nAt first, we may have to support acr completely. IMO, we need to make keycloak assign acr value onto each an authentication flow. Also, considering the point that keycloak's user may choose their preferable LoA profile (e.g. NIST's SP 800-63-3, InCommon, eIDAS), keycloak's administrator can assign acr value onto each the authentication flow by themselves.", "author": "tnorimat", "createdAt": "2021-03-25T22:18:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxOTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjA3MzA3OA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r602073078", "bodyText": "Yes, I agree that it is not a blocker for this PR.\nHowever my point is that supporting acr_values for CIBA is probably much easier than supporting them for core Keycloak authentication flows? The reason is, that in CIBA, it is not Keycloak, who is authenticating user, but the thirdparty Autentication channel. So in theory, Keycloak just needs to re-send the acr_values received in BackchannelAuthenticationEndpoint to the authentication channel? But sure, not a blocker for this PR.", "author": "mposolda", "createdAt": "2021-03-26T07:44:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxOTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgxMjU2OQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r602812569", "bodyText": "@mposolda I see, on this PR, I would like to add the following feature to prepare the complete support for acr_values in the future.\n\nIf acr_values parameter is sent to BackchannelAuthenticationEndpoint, it is re-sent to AuthenticationChannel\nThe treatment of this acr_values is up to the actual implementation of AuthenticationChannel. The current default implementation HttpAuthenticationChannel just ignore it.\nIt is RECOMMENDED in CIBA that the resulting acr value that corresponding to the actually conducted authentication method is included into ID Token's acr, but this PR does not support it.\n\nWDYT?", "author": "tnorimat", "createdAt": "2021-03-28T01:06:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxOTAxNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzA4MDExMQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r603080111", "bodyText": "Yes, that will be nice. Thanks", "author": "mposolda", "createdAt": "2021-03-29T07:51:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQxOTAxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyMTAyNg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599421026", "bodyText": "@tnorimat @pedroigor AFAIK this endpoint contains lots of proprietary non-standard CIBA parameters specific to the particular authentication channel. For example parameters like authentication_channel_id or auth_result . In this regards, I am not sure if it rather makes sense to move some parts regarding to parsing this request to the HttpAuthenticationChannelProvider?\nMy understanding is, that it might be ideal if implemetation of the AuthenticationChannelProvider contains all the stuff related to the \"proprietary\" part of the CIBA protocol for the communication between Keycloak server and Authentication Channel. In this regards, I vote for add the \"callback\" method to AuthenticationChannelProvider interface and implement the processing of the callback request inside AuthenticationChannelPRovider. So that if someone wants to introduce the custom protocol for the communication between Keycloak and Authentication Channel, he just needs to implement his own AuthenticationChannelProvider. Not also the callback endpoint, which is currently implemented in the BackchannelAuthenticationCallbackEndpoint. WDYT?", "author": "mposolda", "createdAt": "2021-03-23T09:55:03Z", "path": "services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationCallbackEndpoint.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.oidc.grants.ciba.endpoints;\n+\n+import static org.keycloak.events.Errors.DIFFERENT_USER_AUTHENTICATED;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.util.HttpHeaderNames;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationRequest;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.HttpAuthenticationChannelProvider;\n+import org.keycloak.protocol.oidc.grants.ciba.resolvers.CIBALoginUserResolver;\n+import org.keycloak.services.ErrorResponseException;\n+\n+public class BackchannelAuthenticationCallbackEndpoint extends AbstractCibaEndpoint {\n+\n+    public static final String SUCCEEDED = \"succeeded\";\n+    public static final String UNAUTHORIZED = \"unauthorized\";\n+    public static final String CANCELLED = \"cancelled\";\n+\n+    @Context\n+    private HttpRequest httpRequest;\n+\n+    public BackchannelAuthenticationCallbackEndpoint(KeycloakSession session, EventBuilder event) {\n+        super(session, event);\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processAuthenticationChannelResult() {", "originalCommit": "077f83af85195f4db9fffc0f1e245efc12d46f80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTg4MzM1OQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r601883359", "bodyText": "@mposolda @pedroigor +1 . It might be preferable if we could separate \"proprietary\" part and realize it as an individual class. AuthenticationChannelProvider and its implementation classes are ideal for it.", "author": "tnorimat", "createdAt": "2021-03-25T22:37:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyMTAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjA3NjMyNA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r602076324", "bodyText": "Yeah. I suppose that this may not be so big change as we will just need to:\n\nintroduce new method on AuthenticationChannelProvider. Maybe like handleCallback or something like that?\nmove most of the logic from BackchannelAuthenticationCallbackEndpoint to that new method on AuthenticationChannelProvider . BackchannelAuthenticationCallbackEndpoint might just need to call this AuthenticationChannelPRovider.handleCallback and that's it mostly?", "author": "mposolda", "createdAt": "2021-03-26T07:51:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyMTAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgxMzE4NQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r602813185", "bodyText": "@mposolda I agree with your proposal. I would like to change codes as you proposed.", "author": "tnorimat", "createdAt": "2021-03-28T01:14:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyMTAyNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzA3NzI5Mg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r603077292", "bodyText": "@tnorimat Thanks", "author": "mposolda", "createdAt": "2021-03-29T07:47:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyMTAyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyNDMyMw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599424323", "bodyText": "@tnorimat @pedroigor Sorry for the dummy question (as maybe it is my lack of understanding protocol), but does BackchannelAuthenticationCallbackEndpoint really needs client authentication? My understanding is, that this endpoint is usually invoked by the \"Authentication Channel\" once it completes the authentication of the user with the authentication device. And the \"Authentication Channel\" won't have access to client credentials?\nIf it is the client, which is supposed to send the request to callback endpoint, then there won't be a need for the polling mechanism described in the CIBA specification. IMO the whole point of polling mechanism is, that client doesn't know when exactly is authentication between user and authentication channel finished.\nMy understanding is, that this Keycloak endpoint is able to parse the JWE sent in the authentication_channel_id parameter and IMO this is the verification that HTTP request to this endpoint was sent from the real authentication channel (the one implemented by the HttpAuthenticationChannelProvider). Hence no point for client authentication in this endpoint. WDYT?", "author": "mposolda", "createdAt": "2021-03-23T09:59:26Z", "path": "services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationCallbackEndpoint.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.oidc.grants.ciba.endpoints;\n+\n+import static org.keycloak.events.Errors.DIFFERENT_USER_AUTHENTICATED;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+\n+import org.jboss.logging.Logger;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.jboss.resteasy.util.HttpHeaderNames;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.common.ClientConnection;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationRequest;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.HttpAuthenticationChannelProvider;\n+import org.keycloak.protocol.oidc.grants.ciba.resolvers.CIBALoginUserResolver;\n+import org.keycloak.services.ErrorResponseException;\n+\n+public class BackchannelAuthenticationCallbackEndpoint extends AbstractCibaEndpoint {\n+\n+    public static final String SUCCEEDED = \"succeeded\";\n+    public static final String UNAUTHORIZED = \"unauthorized\";\n+    public static final String CANCELLED = \"cancelled\";\n+\n+    @Context\n+    private HttpRequest httpRequest;\n+\n+    public BackchannelAuthenticationCallbackEndpoint(KeycloakSession session, EventBuilder event) {\n+        super(session, event);\n+    }\n+\n+    @Path(\"/\")\n+    @POST\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processAuthenticationChannelResult() {\n+        event.event(EventType.LOGIN);\n+\n+        authenticateClient();", "originalCommit": "077f83af85195f4db9fffc0f1e245efc12d46f80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTkwODg1MA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r601908850", "bodyText": "@mposolda As you said, it is not necessary to do this client authentication but we need to do access control to this endpoint.\nOriginally I've wanted to confirm that the following two entities are the same.\n\nThe entity sending the result of the authentication by AD to this callback endpoint.\nThe entity to which keycloak has sent the request of the authentication by AD.\n\nTo do so, I've considered as follows.\n\nWhen sending the request of the authentication by AD,  keycloak put onto JWE the identity of this entity.\nWhen receiving the response of the authentication by AD, keycloak decrypts the accompanied JWE, reads the identity of the entity on this JWE, compare this identity with the one found by doing client authentication on this callback endpoint.\n\nI'm not adhere to this mechanism. The simpler mechanism is preferable.\nIf we assume that the entity of doing authentication by AD is under control of the keycloak' administrator, we need not do the client authentication. My vote is that\n\nnot do client authentication on this callback endpoint\nwrite this assumption on keycloak's document\nWDYT?", "author": "tnorimat", "createdAt": "2021-03-25T23:46:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyNDMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjA5MzI0Mg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r602093242", "bodyText": "@tnorimat I've replied to this in the other comment #7679 (comment) , so we not discuss same/similar thing on two places.", "author": "mposolda", "createdAt": "2021-03-26T08:24:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyNDMyMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgxMzM2MA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r602813360", "bodyText": "@mposolda I see, I would like to refer to #7679 (comment) to discuss this point.", "author": "tnorimat", "createdAt": "2021-03-28T01:16:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyNDMyMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyNjA4MQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599426081", "bodyText": "Minor: I vote to rename this class to CIBAAuthenticationRequest. We already have class \"AuthenticationRequest\" used by brokering, so it may help to avoid some confusions. In theory package name differentiation should be sufficient, but still sometimes the confusion can easily happen for the duplicated class names. But maybe it is just me... :-)", "author": "mposolda", "createdAt": "2021-03-23T10:01:55Z", "path": "services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/channel/AuthenticationRequest.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ *\n+ *  * Copyright 2021  Red Hat, Inc. and/or its affiliates\n+ *  * and other contributors as indicated by the @author tags.\n+ *  *\n+ *  * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  * you may not use this file except in compliance with the License.\n+ *  * You may obtain a copy of the License at\n+ *  *\n+ *  * http://www.apache.org/licenses/LICENSE-2.0\n+ *  *\n+ *  * Unless required by applicable law or agreed to in writing, software\n+ *  * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  * See the License for the specific language governing permissions and\n+ *  * limitations under the License.\n+ *\n+ */\n+package org.keycloak.protocol.oidc.grants.ciba.channel;\n+\n+import javax.crypto.SecretKey;\n+import java.io.UnsupportedEncodingException;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.crypto.Algorithm;\n+import org.keycloak.crypto.KeyUse;\n+import org.keycloak.crypto.SignatureProvider;\n+import org.keycloak.crypto.SignatureSignerContext;\n+import org.keycloak.jose.jwe.JWEException;\n+import org.keycloak.jose.jws.JWSBuilder;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;\n+import org.keycloak.representations.IDToken;\n+import org.keycloak.representations.JsonWebToken;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import org.keycloak.services.Urls;\n+import org.keycloak.util.TokenUtil;\n+\n+/**\n+ * <p>Represents an authentication request sent by a consumption device.\n+ *\n+ * <p>A authentication request can be serialized to a JWE so that they can be exchanged with authentication devices to communicate\n+ * and authorize the authentication request made by consumption devices.\n+ */\n+public class AuthenticationRequest extends JsonWebToken {", "originalCommit": "077f83af85195f4db9fffc0f1e245efc12d46f80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQ5NDUyNw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599494527", "bodyText": "I don't mind. But I would prefer the way it is.", "author": "pedroigor", "createdAt": "2021-03-23T11:44:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyNjA4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUzNTQ0OQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599535449", "bodyText": "We can leave to @tnorimat whatever he prefers. I am also fine with either way to keep or rename.", "author": "mposolda", "createdAt": "2021-03-23T12:47:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyNjA4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTkxMDI2Mg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r601910262", "bodyText": "@mposolda @pedroigor My vote is to rename it to CIBAAuthenticationRequest.", "author": "tnorimat", "createdAt": "2021-03-25T23:51:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyNjA4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzQ2MTg4Nw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r617461887", "bodyText": "@mposolda I've renamed CIBAAuthenticationRequest to (4d1e347).", "author": "tnorimat", "createdAt": "2021-04-21T11:48:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyNjA4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyNjMxMg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599426312", "bodyText": "The \"sessionState\" is not used at all in the AuthenticationRequest. It is always null. Should we remove this parameter?", "author": "mposolda", "createdAt": "2021-03-23T10:02:12Z", "path": "services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/channel/AuthenticationRequest.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ *\n+ *  * Copyright 2021  Red Hat, Inc. and/or its affiliates\n+ *  * and other contributors as indicated by the @author tags.\n+ *  *\n+ *  * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  * you may not use this file except in compliance with the License.\n+ *  * You may obtain a copy of the License at\n+ *  *\n+ *  * http://www.apache.org/licenses/LICENSE-2.0\n+ *  *\n+ *  * Unless required by applicable law or agreed to in writing, software\n+ *  * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  * See the License for the specific language governing permissions and\n+ *  * limitations under the License.\n+ *\n+ */\n+package org.keycloak.protocol.oidc.grants.ciba.channel;\n+\n+import javax.crypto.SecretKey;\n+import java.io.UnsupportedEncodingException;\n+\n+import com.fasterxml.jackson.annotation.JsonIgnore;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.crypto.Algorithm;\n+import org.keycloak.crypto.KeyUse;\n+import org.keycloak.crypto.SignatureProvider;\n+import org.keycloak.crypto.SignatureSignerContext;\n+import org.keycloak.jose.jwe.JWEException;\n+import org.keycloak.jose.jws.JWSBuilder;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.models.utils.KeycloakModelUtils;\n+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;\n+import org.keycloak.representations.IDToken;\n+import org.keycloak.representations.JsonWebToken;\n+\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+import org.keycloak.services.Urls;\n+import org.keycloak.util.TokenUtil;\n+\n+/**\n+ * <p>Represents an authentication request sent by a consumption device.\n+ *\n+ * <p>A authentication request can be serialized to a JWE so that they can be exchanged with authentication devices to communicate\n+ * and authorize the authentication request made by consumption devices.\n+ */\n+public class AuthenticationRequest extends JsonWebToken {\n+\n+    /**\n+     * Deserialize the given {@code jwe} to a {@link AuthenticationRequest} instance.\n+     *\n+     * @param session the session\n+     * @param jwe the authentication request in JWE format.\n+     * @return the authentication request instance\n+     * @throws Exception\n+     */\n+    public static AuthenticationRequest deserialize(KeycloakSession session, String jwe) {\n+        SecretKey aesKey = session.keys().getActiveKey(session.getContext().getRealm(), KeyUse.ENC, Algorithm.AES).getSecretKey();\n+        SecretKey hmacKey = session.keys().getActiveKey(session.getContext().getRealm(), KeyUse.SIG, Algorithm.HS256).getSecretKey();\n+\n+        try {\n+            byte[] contentBytes = TokenUtil.jweDirectVerifyAndDecode(aesKey, hmacKey, jwe);\n+            jwe = new String(contentBytes, \"UTF-8\");\n+        } catch (JWEException | UnsupportedEncodingException e) {\n+            throw new RuntimeException(\"Error decoding auth_req_id.\", e);\n+        }\n+\n+        return session.tokens().decode(jwe, AuthenticationRequest.class);\n+    }\n+\n+    public static final String SESSION_STATE = IDToken.SESSION_STATE;\n+    public static final String AUTH_RESULT_ID = \"auth_result_id\";\n+\n+    @JsonProperty(OAuth2Constants.SCOPE)\n+    protected String scope;\n+\n+    @JsonProperty(SESSION_STATE)\n+    protected String sessionState;", "originalCommit": "077f83af85195f4db9fffc0f1e245efc12d46f80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTkxMDczNQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r601910735", "bodyText": "@mposolda I agree with you.", "author": "tnorimat", "createdAt": "2021-03-25T23:52:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyNjMxMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyNzU5Nw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599427597", "bodyText": "It can be good to remove \"codeId\", \"sessionId\" and \"isOfflineAccess\" entirely from this method signature? It seems they are either always null or not used at all.\nSame for the other \"doBackchannelAuthenticationTokenRequest\" method below.", "author": "mposolda", "createdAt": "2021-03-23T10:04:03Z", "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/CIBATest.java", "diffHunk": "@@ -0,0 +1,1196 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.testsuite.client;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.containsString;\n+\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+\n+import static org.junit.Assert.assertThat;\n+import static org.keycloak.OAuthErrorException.INVALID_REQUEST;\n+import static org.keycloak.protocol.oidc.grants.ciba.endpoints.BackchannelAuthenticationCallbackEndpoint.CANCELLED;\n+import static org.keycloak.protocol.oidc.grants.ciba.endpoints.BackchannelAuthenticationCallbackEndpoint.SUCCEEDED;\n+import static org.keycloak.protocol.oidc.grants.ciba.endpoints.BackchannelAuthenticationCallbackEndpoint.UNAUTHORIZED;\n+import static org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude.AuthServer.QUARKUS;\n+import static org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude.AuthServer.REMOTE;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.hamcrest.CoreMatchers;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.admin.client.resource.ClientResource;\n+import org.keycloak.common.Profile;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.CibaConfig;\n+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;\n+import org.keycloak.protocol.oidc.OIDCAdvancedConfigWrapper;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.HttpAuthenticationChannelProviderFactory;\n+import org.keycloak.representations.AccessToken;\n+import org.keycloak.representations.IDToken;\n+import org.keycloak.representations.RefreshToken;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.representations.idm.EventRepresentation;\n+import org.keycloak.representations.idm.RealmRepresentation;\n+import org.keycloak.representations.idm.UserRepresentation;\n+import org.keycloak.representations.oidc.TokenMetadataRepresentation;\n+import org.keycloak.testsuite.AbstractTestRealmKeycloakTest;\n+import org.keycloak.testsuite.AssertEvents;\n+import org.keycloak.testsuite.admin.ApiUtil;\n+import org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude;\n+import org.keycloak.testsuite.arquillian.annotation.EnableCiba;\n+import org.keycloak.testsuite.arquillian.annotation.EnableFeature;\n+import org.keycloak.testsuite.ciba.AuthenticationChannelRequest;\n+import org.keycloak.testsuite.client.resources.TestApplicationResourceUrls;\n+import org.keycloak.testsuite.client.resources.TestOIDCEndpointsApplicationResource;\n+import org.keycloak.testsuite.util.KeycloakModelUtils;\n+import org.keycloak.testsuite.util.Matchers;\n+import org.keycloak.testsuite.util.OAuthClient;\n+import org.keycloak.testsuite.util.UserBuilder;\n+import org.keycloak.testsuite.util.OAuthClient.AuthenticationRequestAcknowledgement;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.keycloak.testsuite.util.WaitUtils;\n+\n+@EnableCiba\n+@EnableFeature(value = Profile.Feature.CIBA, skipRestart = true)\n+@AuthServerContainerExclude({REMOTE, QUARKUS})\n+public class CIBATest extends AbstractTestRealmKeycloakTest {\n+\n+    private final String AUTHENTICATION_CHANNEL_SERVER_NAME = \"authentication-channel-server\";\n+    private final String AUTHENTICATION_CHANNEL_SERVER_PASSWORD = \"passwort-authentication-channel-server\";\n+\n+    @Rule\n+    public AssertEvents events = new AssertEvents(this);\n+\n+    @Override\n+    public void configureTestRealm(RealmRepresentation testRealm) {\n+\n+        UserRepresentation user = UserBuilder.create()\n+                .username(\"nutzername-schwarz\")\n+                .email(\"schwarz@test.example.com\")\n+                .enabled(true)\n+                .password(\"passwort-schwarz\")\n+                .addRoles(\"user\", \"offline_access\")\n+                .build();\n+        testRealm.getUsers().add(user);\n+\n+        user = UserBuilder.create()\n+                .username(\"nutzername-rot\")\n+                .email(\"rot@test.example.com\")\n+                .enabled(true)\n+                .password(\"passwort-rot\")\n+                .addRoles(\"user\", \"offline_access\")\n+                .build();\n+        testRealm.getUsers().add(user);\n+\n+        user = UserBuilder.create()\n+                .username(\"nutzername-gelb\")\n+                .email(\"gelb@test.example.com\")\n+                .enabled(true)\n+                .password(\"passwort-gelb\")\n+                .addRoles(\"user\", \"offline_access\")\n+                .build();\n+        testRealm.getUsers().add(user);\n+\n+        user = UserBuilder.create()\n+                .username(\"nutzername-deaktiviert\")\n+                .email(\"deaktiviert@test.example.com\")\n+                .enabled(false)\n+                .password(\"passwort-deaktiviert\")\n+                .addRoles(\"user\", \"offline_access\")\n+                .build();\n+        testRealm.getUsers().add(user);\n+\n+        ClientRepresentation confApp = KeycloakModelUtils.createClient(testRealm, AUTHENTICATION_CHANNEL_SERVER_NAME);\n+        confApp.setSecret(AUTHENTICATION_CHANNEL_SERVER_PASSWORD);\n+        confApp.setServiceAccountsEnabled(Boolean.TRUE);\n+\n+    }\n+\n+    @BeforeClass\n+    public static void setAuthenticationChannelRequestUri() {\n+        System.setProperty(\"keycloak.ciba.auth.channel.provider\", HttpAuthenticationChannelProviderFactory.PROVIDER_ID);\n+        System.setProperty(\"keycloak.ciba.http.auth.channel.uri\", TestApplicationResourceUrls.clientAuthenticationChannelRequestUri());\n+    }\n+\n+    private String cibaBackchannelTokenDeliveryMode;\n+    private Integer cibaExpiresIn;\n+    private Integer cibaInterval;\n+    private String cibaAuthRequestedUserHint;\n+\n+    private final String TEST_REALM_NAME = \"test\";\n+    private final String TEST_CLIENT_NAME = \"test-app\";\n+    private final String TEST_CLIENT_PASSWORD = \"password\";\n+\n+    private AuthenticationRequestAcknowledgement doBackchannelAuthenticationRequest(String username) throws Exception {\n+        return doBackchannelAuthenticationRequest(TEST_CLIENT_NAME, TEST_CLIENT_PASSWORD, username, null);\n+    }\n+\n+    private AuthenticationRequestAcknowledgement doBackchannelAuthenticationRequest(String clientId, String clientSecret, String username, String bindingMessage) throws Exception {\n+        AuthenticationRequestAcknowledgement response = oauth.doBackchannelAuthenticationRequest(clientId, clientSecret, username, bindingMessage);\n+        Assert.assertThat(response.getStatusCode(), is(equalTo(200)));\n+        Assert.assertNotNull(response.getAuthReqId());\n+        return response;\n+    }\n+\n+    private AuthenticationChannelRequest doAuthenticationChannelRequest() {\n+        // get Authentication Channel Request keycloak has done on Backchannel Authentication Endpoint from the FIFO queue of testing Authentication Channel Request API\n+        TestOIDCEndpointsApplicationResource oidcClientEndpointsResource = testingClient.testApp().oidcClientEndpoints();\n+        AuthenticationChannelRequest authenticationChannelReq = oidcClientEndpointsResource.getAuthenticationChannel();\n+        return authenticationChannelReq;\n+    }\n+\n+    private EventRepresentation doAuthenticationChannelCallback(AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username) throws Exception {\n+        return doAuthenticationChannelCallback(TEST_CLIENT_NAME, authenticationChannelReq, authenticationChannelStatus, username);\n+    }\n+\n+    private EventRepresentation doAuthenticationChannelCallback(String clientIdAsConsumerDevice, AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username) throws Exception {\n+        int statusCode = oauth.doAuthenticationChannelCallback(AUTHENTICATION_CHANNEL_SERVER_NAME, AUTHENTICATION_CHANNEL_SERVER_PASSWORD, authenticationChannelReq.getUserInfo(), authenticationChannelReq.getAuthenticationChannelId(), authenticationChannelStatus);\n+        Assert.assertThat(statusCode, is(equalTo(200)));\n+        // check login event : ignore user id and other details except for username\n+        EventRepresentation representation = new EventRepresentation();\n+\n+        representation.setDetails(Collections.emptyMap());\n+\n+        return representation;\n+    }\n+\n+    private EventRepresentation doAuthenticationChannelCallback(String clientId, AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username, String error) throws Exception {\n+        int statusCode = oauth.doAuthenticationChannelCallback(AUTHENTICATION_CHANNEL_SERVER_NAME, AUTHENTICATION_CHANNEL_SERVER_PASSWORD, authenticationChannelReq.getUserInfo(), authenticationChannelReq.getAuthenticationChannelId(), authenticationChannelStatus);\n+        Assert.assertThat(statusCode, is(equalTo(200)));\n+        return events.expect(EventType.LOGIN_ERROR).clearDetails().client(clientId).error(error).user((String)null).session(CoreMatchers.nullValue(String.class)).assertEvent();\n+    }\n+\n+    private EventRepresentation doAuthenticationChannelCallbackError(Status status, String clientId, AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username, String error) throws Exception {\n+        int statusCode = oauth.doAuthenticationChannelCallback(AUTHENTICATION_CHANNEL_SERVER_NAME, AUTHENTICATION_CHANNEL_SERVER_PASSWORD, authenticationChannelReq.getUserInfo(), authenticationChannelReq.getAuthenticationChannelId(), authenticationChannelStatus);\n+        Assert.assertThat(statusCode, is(equalTo(status.getStatusCode())));\n+        return events.expect(EventType.LOGIN_ERROR).clearDetails().client(clientId).error(error).user((String)null).session(CoreMatchers.nullValue(String.class)).assertEvent();\n+    }\n+\n+    private OAuthClient.AccessTokenResponse doBackchannelAuthenticationTokenRequest(String codeId, String sessionId, String username, String authReqId, boolean isOfflineAccess) throws Exception {", "originalCommit": "077f83af85195f4db9fffc0f1e245efc12d46f80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTkxMjA2NA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r601912064", "bodyText": "@mposolda I see, I will remove them.", "author": "tnorimat", "createdAt": "2021-03-25T23:56:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyNzU5Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzQ2MjQ2MA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r617462460", "bodyText": "@mposolda I've removed them (89ddf70).", "author": "tnorimat", "createdAt": "2021-04-21T11:49:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyNzU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyODYwNg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599428606", "bodyText": "It seems this method is not used and can be removed", "author": "mposolda", "createdAt": "2021-03-23T10:05:22Z", "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/CIBATest.java", "diffHunk": "@@ -0,0 +1,1196 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.testsuite.client;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.containsString;\n+\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+\n+import static org.junit.Assert.assertThat;\n+import static org.keycloak.OAuthErrorException.INVALID_REQUEST;\n+import static org.keycloak.protocol.oidc.grants.ciba.endpoints.BackchannelAuthenticationCallbackEndpoint.CANCELLED;\n+import static org.keycloak.protocol.oidc.grants.ciba.endpoints.BackchannelAuthenticationCallbackEndpoint.SUCCEEDED;\n+import static org.keycloak.protocol.oidc.grants.ciba.endpoints.BackchannelAuthenticationCallbackEndpoint.UNAUTHORIZED;\n+import static org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude.AuthServer.QUARKUS;\n+import static org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude.AuthServer.REMOTE;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.hamcrest.CoreMatchers;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.admin.client.resource.ClientResource;\n+import org.keycloak.common.Profile;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.CibaConfig;\n+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;\n+import org.keycloak.protocol.oidc.OIDCAdvancedConfigWrapper;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.HttpAuthenticationChannelProviderFactory;\n+import org.keycloak.representations.AccessToken;\n+import org.keycloak.representations.IDToken;\n+import org.keycloak.representations.RefreshToken;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.representations.idm.EventRepresentation;\n+import org.keycloak.representations.idm.RealmRepresentation;\n+import org.keycloak.representations.idm.UserRepresentation;\n+import org.keycloak.representations.oidc.TokenMetadataRepresentation;\n+import org.keycloak.testsuite.AbstractTestRealmKeycloakTest;\n+import org.keycloak.testsuite.AssertEvents;\n+import org.keycloak.testsuite.admin.ApiUtil;\n+import org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude;\n+import org.keycloak.testsuite.arquillian.annotation.EnableCiba;\n+import org.keycloak.testsuite.arquillian.annotation.EnableFeature;\n+import org.keycloak.testsuite.ciba.AuthenticationChannelRequest;\n+import org.keycloak.testsuite.client.resources.TestApplicationResourceUrls;\n+import org.keycloak.testsuite.client.resources.TestOIDCEndpointsApplicationResource;\n+import org.keycloak.testsuite.util.KeycloakModelUtils;\n+import org.keycloak.testsuite.util.Matchers;\n+import org.keycloak.testsuite.util.OAuthClient;\n+import org.keycloak.testsuite.util.UserBuilder;\n+import org.keycloak.testsuite.util.OAuthClient.AuthenticationRequestAcknowledgement;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.keycloak.testsuite.util.WaitUtils;\n+\n+@EnableCiba\n+@EnableFeature(value = Profile.Feature.CIBA, skipRestart = true)\n+@AuthServerContainerExclude({REMOTE, QUARKUS})\n+public class CIBATest extends AbstractTestRealmKeycloakTest {\n+\n+    private final String AUTHENTICATION_CHANNEL_SERVER_NAME = \"authentication-channel-server\";\n+    private final String AUTHENTICATION_CHANNEL_SERVER_PASSWORD = \"passwort-authentication-channel-server\";\n+\n+    @Rule\n+    public AssertEvents events = new AssertEvents(this);\n+\n+    @Override\n+    public void configureTestRealm(RealmRepresentation testRealm) {\n+\n+        UserRepresentation user = UserBuilder.create()\n+                .username(\"nutzername-schwarz\")\n+                .email(\"schwarz@test.example.com\")\n+                .enabled(true)\n+                .password(\"passwort-schwarz\")\n+                .addRoles(\"user\", \"offline_access\")\n+                .build();\n+        testRealm.getUsers().add(user);\n+\n+        user = UserBuilder.create()\n+                .username(\"nutzername-rot\")\n+                .email(\"rot@test.example.com\")\n+                .enabled(true)\n+                .password(\"passwort-rot\")\n+                .addRoles(\"user\", \"offline_access\")\n+                .build();\n+        testRealm.getUsers().add(user);\n+\n+        user = UserBuilder.create()\n+                .username(\"nutzername-gelb\")\n+                .email(\"gelb@test.example.com\")\n+                .enabled(true)\n+                .password(\"passwort-gelb\")\n+                .addRoles(\"user\", \"offline_access\")\n+                .build();\n+        testRealm.getUsers().add(user);\n+\n+        user = UserBuilder.create()\n+                .username(\"nutzername-deaktiviert\")\n+                .email(\"deaktiviert@test.example.com\")\n+                .enabled(false)\n+                .password(\"passwort-deaktiviert\")\n+                .addRoles(\"user\", \"offline_access\")\n+                .build();\n+        testRealm.getUsers().add(user);\n+\n+        ClientRepresentation confApp = KeycloakModelUtils.createClient(testRealm, AUTHENTICATION_CHANNEL_SERVER_NAME);\n+        confApp.setSecret(AUTHENTICATION_CHANNEL_SERVER_PASSWORD);\n+        confApp.setServiceAccountsEnabled(Boolean.TRUE);\n+\n+    }\n+\n+    @BeforeClass\n+    public static void setAuthenticationChannelRequestUri() {\n+        System.setProperty(\"keycloak.ciba.auth.channel.provider\", HttpAuthenticationChannelProviderFactory.PROVIDER_ID);\n+        System.setProperty(\"keycloak.ciba.http.auth.channel.uri\", TestApplicationResourceUrls.clientAuthenticationChannelRequestUri());\n+    }\n+\n+    private String cibaBackchannelTokenDeliveryMode;\n+    private Integer cibaExpiresIn;\n+    private Integer cibaInterval;\n+    private String cibaAuthRequestedUserHint;\n+\n+    private final String TEST_REALM_NAME = \"test\";\n+    private final String TEST_CLIENT_NAME = \"test-app\";\n+    private final String TEST_CLIENT_PASSWORD = \"password\";\n+\n+    private AuthenticationRequestAcknowledgement doBackchannelAuthenticationRequest(String username) throws Exception {\n+        return doBackchannelAuthenticationRequest(TEST_CLIENT_NAME, TEST_CLIENT_PASSWORD, username, null);\n+    }\n+\n+    private AuthenticationRequestAcknowledgement doBackchannelAuthenticationRequest(String clientId, String clientSecret, String username, String bindingMessage) throws Exception {\n+        AuthenticationRequestAcknowledgement response = oauth.doBackchannelAuthenticationRequest(clientId, clientSecret, username, bindingMessage);\n+        Assert.assertThat(response.getStatusCode(), is(equalTo(200)));\n+        Assert.assertNotNull(response.getAuthReqId());\n+        return response;\n+    }\n+\n+    private AuthenticationChannelRequest doAuthenticationChannelRequest() {\n+        // get Authentication Channel Request keycloak has done on Backchannel Authentication Endpoint from the FIFO queue of testing Authentication Channel Request API\n+        TestOIDCEndpointsApplicationResource oidcClientEndpointsResource = testingClient.testApp().oidcClientEndpoints();\n+        AuthenticationChannelRequest authenticationChannelReq = oidcClientEndpointsResource.getAuthenticationChannel();\n+        return authenticationChannelReq;\n+    }\n+\n+    private EventRepresentation doAuthenticationChannelCallback(AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username) throws Exception {\n+        return doAuthenticationChannelCallback(TEST_CLIENT_NAME, authenticationChannelReq, authenticationChannelStatus, username);\n+    }\n+\n+    private EventRepresentation doAuthenticationChannelCallback(String clientIdAsConsumerDevice, AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username) throws Exception {\n+        int statusCode = oauth.doAuthenticationChannelCallback(AUTHENTICATION_CHANNEL_SERVER_NAME, AUTHENTICATION_CHANNEL_SERVER_PASSWORD, authenticationChannelReq.getUserInfo(), authenticationChannelReq.getAuthenticationChannelId(), authenticationChannelStatus);\n+        Assert.assertThat(statusCode, is(equalTo(200)));\n+        // check login event : ignore user id and other details except for username\n+        EventRepresentation representation = new EventRepresentation();\n+\n+        representation.setDetails(Collections.emptyMap());\n+\n+        return representation;\n+    }\n+\n+    private EventRepresentation doAuthenticationChannelCallback(String clientId, AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username, String error) throws Exception {", "originalCommit": "077f83af85195f4db9fffc0f1e245efc12d46f80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTkxMjcxNg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r601912716", "bodyText": "@mposolda Yes, I will remove it.", "author": "tnorimat", "createdAt": "2021-03-25T23:58:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyODYwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNzQ0NjIyOQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r617446229", "bodyText": "@mposolda I've already removed this method.", "author": "tnorimat", "createdAt": "2021-04-21T11:23:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQyODYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQzMDg2OA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599430868", "bodyText": "@tnorimat  @pedroigor This is only testsuite related concern, but my vote is that method \"doAuthenticationChannelRequest()\" accepts the bindingMessage as an argument and that the bindingMessage is sent to the testing endpoint. And also that the testing endpoint checks the \"bindingMessage\" equals to the previously saved request. This is minor testsuite related concern, but IMO it may help the \"newbie\" to understand CIBA protocols a bit better.\nIn general, the CIBA protocol is quite hard to understand for the newbies IMO as there is big amount of various HTTP requests sent among various parties. And hence it helps a bit if the testsuite related requests are also a bit \"logical\" and represents the reality, which will be used by the CIBA protocol in production. And IMO in reality, the request from the user to AuthenticationChannel will need to contain the \"bindingMessage\" as in reality AuthenticationChannel can contain many different requests from different users and bindingMessage would be used to bind the request with the actual user. For same reason, I vote to change the BlockingQueue in the TestingOIDCEndpointsApplicationResource to be the Map where the key is the \"bindingMessage\" and the value the actual request. WDYT?", "author": "mposolda", "createdAt": "2021-03-23T10:08:09Z", "path": "testsuite/integration-arquillian/tests/base/src/test/java/org/keycloak/testsuite/client/CIBATest.java", "diffHunk": "@@ -0,0 +1,1196 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.testsuite.client;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.containsString;\n+\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.apache.http.client.methods.CloseableHttpResponse;\n+\n+import static org.junit.Assert.assertThat;\n+import static org.keycloak.OAuthErrorException.INVALID_REQUEST;\n+import static org.keycloak.protocol.oidc.grants.ciba.endpoints.BackchannelAuthenticationCallbackEndpoint.CANCELLED;\n+import static org.keycloak.protocol.oidc.grants.ciba.endpoints.BackchannelAuthenticationCallbackEndpoint.SUCCEEDED;\n+import static org.keycloak.protocol.oidc.grants.ciba.endpoints.BackchannelAuthenticationCallbackEndpoint.UNAUTHORIZED;\n+import static org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude.AuthServer.QUARKUS;\n+import static org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude.AuthServer.REMOTE;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import org.hamcrest.CoreMatchers;\n+import org.junit.Assert;\n+import org.junit.BeforeClass;\n+import org.junit.Ignore;\n+import org.junit.Rule;\n+import org.junit.Test;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.admin.client.resource.ClientResource;\n+import org.keycloak.common.Profile;\n+import org.keycloak.events.Details;\n+import org.keycloak.events.Errors;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.CibaConfig;\n+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;\n+import org.keycloak.protocol.oidc.OIDCAdvancedConfigWrapper;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.HttpAuthenticationChannelProviderFactory;\n+import org.keycloak.representations.AccessToken;\n+import org.keycloak.representations.IDToken;\n+import org.keycloak.representations.RefreshToken;\n+import org.keycloak.representations.idm.ClientRepresentation;\n+import org.keycloak.representations.idm.EventRepresentation;\n+import org.keycloak.representations.idm.RealmRepresentation;\n+import org.keycloak.representations.idm.UserRepresentation;\n+import org.keycloak.representations.oidc.TokenMetadataRepresentation;\n+import org.keycloak.testsuite.AbstractTestRealmKeycloakTest;\n+import org.keycloak.testsuite.AssertEvents;\n+import org.keycloak.testsuite.admin.ApiUtil;\n+import org.keycloak.testsuite.arquillian.annotation.AuthServerContainerExclude;\n+import org.keycloak.testsuite.arquillian.annotation.EnableCiba;\n+import org.keycloak.testsuite.arquillian.annotation.EnableFeature;\n+import org.keycloak.testsuite.ciba.AuthenticationChannelRequest;\n+import org.keycloak.testsuite.client.resources.TestApplicationResourceUrls;\n+import org.keycloak.testsuite.client.resources.TestOIDCEndpointsApplicationResource;\n+import org.keycloak.testsuite.util.KeycloakModelUtils;\n+import org.keycloak.testsuite.util.Matchers;\n+import org.keycloak.testsuite.util.OAuthClient;\n+import org.keycloak.testsuite.util.UserBuilder;\n+import org.keycloak.testsuite.util.OAuthClient.AuthenticationRequestAcknowledgement;\n+\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import org.keycloak.testsuite.util.WaitUtils;\n+\n+@EnableCiba\n+@EnableFeature(value = Profile.Feature.CIBA, skipRestart = true)\n+@AuthServerContainerExclude({REMOTE, QUARKUS})\n+public class CIBATest extends AbstractTestRealmKeycloakTest {\n+\n+    private final String AUTHENTICATION_CHANNEL_SERVER_NAME = \"authentication-channel-server\";\n+    private final String AUTHENTICATION_CHANNEL_SERVER_PASSWORD = \"passwort-authentication-channel-server\";\n+\n+    @Rule\n+    public AssertEvents events = new AssertEvents(this);\n+\n+    @Override\n+    public void configureTestRealm(RealmRepresentation testRealm) {\n+\n+        UserRepresentation user = UserBuilder.create()\n+                .username(\"nutzername-schwarz\")\n+                .email(\"schwarz@test.example.com\")\n+                .enabled(true)\n+                .password(\"passwort-schwarz\")\n+                .addRoles(\"user\", \"offline_access\")\n+                .build();\n+        testRealm.getUsers().add(user);\n+\n+        user = UserBuilder.create()\n+                .username(\"nutzername-rot\")\n+                .email(\"rot@test.example.com\")\n+                .enabled(true)\n+                .password(\"passwort-rot\")\n+                .addRoles(\"user\", \"offline_access\")\n+                .build();\n+        testRealm.getUsers().add(user);\n+\n+        user = UserBuilder.create()\n+                .username(\"nutzername-gelb\")\n+                .email(\"gelb@test.example.com\")\n+                .enabled(true)\n+                .password(\"passwort-gelb\")\n+                .addRoles(\"user\", \"offline_access\")\n+                .build();\n+        testRealm.getUsers().add(user);\n+\n+        user = UserBuilder.create()\n+                .username(\"nutzername-deaktiviert\")\n+                .email(\"deaktiviert@test.example.com\")\n+                .enabled(false)\n+                .password(\"passwort-deaktiviert\")\n+                .addRoles(\"user\", \"offline_access\")\n+                .build();\n+        testRealm.getUsers().add(user);\n+\n+        ClientRepresentation confApp = KeycloakModelUtils.createClient(testRealm, AUTHENTICATION_CHANNEL_SERVER_NAME);\n+        confApp.setSecret(AUTHENTICATION_CHANNEL_SERVER_PASSWORD);\n+        confApp.setServiceAccountsEnabled(Boolean.TRUE);\n+\n+    }\n+\n+    @BeforeClass\n+    public static void setAuthenticationChannelRequestUri() {\n+        System.setProperty(\"keycloak.ciba.auth.channel.provider\", HttpAuthenticationChannelProviderFactory.PROVIDER_ID);\n+        System.setProperty(\"keycloak.ciba.http.auth.channel.uri\", TestApplicationResourceUrls.clientAuthenticationChannelRequestUri());\n+    }\n+\n+    private String cibaBackchannelTokenDeliveryMode;\n+    private Integer cibaExpiresIn;\n+    private Integer cibaInterval;\n+    private String cibaAuthRequestedUserHint;\n+\n+    private final String TEST_REALM_NAME = \"test\";\n+    private final String TEST_CLIENT_NAME = \"test-app\";\n+    private final String TEST_CLIENT_PASSWORD = \"password\";\n+\n+    private AuthenticationRequestAcknowledgement doBackchannelAuthenticationRequest(String username) throws Exception {\n+        return doBackchannelAuthenticationRequest(TEST_CLIENT_NAME, TEST_CLIENT_PASSWORD, username, null);\n+    }\n+\n+    private AuthenticationRequestAcknowledgement doBackchannelAuthenticationRequest(String clientId, String clientSecret, String username, String bindingMessage) throws Exception {\n+        AuthenticationRequestAcknowledgement response = oauth.doBackchannelAuthenticationRequest(clientId, clientSecret, username, bindingMessage);\n+        Assert.assertThat(response.getStatusCode(), is(equalTo(200)));\n+        Assert.assertNotNull(response.getAuthReqId());\n+        return response;\n+    }\n+\n+    private AuthenticationChannelRequest doAuthenticationChannelRequest() {\n+        // get Authentication Channel Request keycloak has done on Backchannel Authentication Endpoint from the FIFO queue of testing Authentication Channel Request API\n+        TestOIDCEndpointsApplicationResource oidcClientEndpointsResource = testingClient.testApp().oidcClientEndpoints();\n+        AuthenticationChannelRequest authenticationChannelReq = oidcClientEndpointsResource.getAuthenticationChannel();\n+        return authenticationChannelReq;\n+    }\n+\n+    private EventRepresentation doAuthenticationChannelCallback(AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username) throws Exception {\n+        return doAuthenticationChannelCallback(TEST_CLIENT_NAME, authenticationChannelReq, authenticationChannelStatus, username);\n+    }\n+\n+    private EventRepresentation doAuthenticationChannelCallback(String clientIdAsConsumerDevice, AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username) throws Exception {\n+        int statusCode = oauth.doAuthenticationChannelCallback(AUTHENTICATION_CHANNEL_SERVER_NAME, AUTHENTICATION_CHANNEL_SERVER_PASSWORD, authenticationChannelReq.getUserInfo(), authenticationChannelReq.getAuthenticationChannelId(), authenticationChannelStatus);\n+        Assert.assertThat(statusCode, is(equalTo(200)));\n+        // check login event : ignore user id and other details except for username\n+        EventRepresentation representation = new EventRepresentation();\n+\n+        representation.setDetails(Collections.emptyMap());\n+\n+        return representation;\n+    }\n+\n+    private EventRepresentation doAuthenticationChannelCallback(String clientId, AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username, String error) throws Exception {\n+        int statusCode = oauth.doAuthenticationChannelCallback(AUTHENTICATION_CHANNEL_SERVER_NAME, AUTHENTICATION_CHANNEL_SERVER_PASSWORD, authenticationChannelReq.getUserInfo(), authenticationChannelReq.getAuthenticationChannelId(), authenticationChannelStatus);\n+        Assert.assertThat(statusCode, is(equalTo(200)));\n+        return events.expect(EventType.LOGIN_ERROR).clearDetails().client(clientId).error(error).user((String)null).session(CoreMatchers.nullValue(String.class)).assertEvent();\n+    }\n+\n+    private EventRepresentation doAuthenticationChannelCallbackError(Status status, String clientId, AuthenticationChannelRequest authenticationChannelReq, String authenticationChannelStatus, String username, String error) throws Exception {\n+        int statusCode = oauth.doAuthenticationChannelCallback(AUTHENTICATION_CHANNEL_SERVER_NAME, AUTHENTICATION_CHANNEL_SERVER_PASSWORD, authenticationChannelReq.getUserInfo(), authenticationChannelReq.getAuthenticationChannelId(), authenticationChannelStatus);\n+        Assert.assertThat(statusCode, is(equalTo(status.getStatusCode())));\n+        return events.expect(EventType.LOGIN_ERROR).clearDetails().client(clientId).error(error).user((String)null).session(CoreMatchers.nullValue(String.class)).assertEvent();\n+    }\n+\n+    private OAuthClient.AccessTokenResponse doBackchannelAuthenticationTokenRequest(String codeId, String sessionId, String username, String authReqId, boolean isOfflineAccess) throws Exception {\n+        return doBackchannelAuthenticationTokenRequest(TEST_CLIENT_NAME, TEST_CLIENT_PASSWORD, codeId, sessionId, username, authReqId, isOfflineAccess);\n+    }\n+\n+    private OAuthClient.AccessTokenResponse doBackchannelAuthenticationTokenRequest(String clientId, String clientSecret, String codeId, String sessionId, String username, String authReqId, boolean isOfflineAccess) throws Exception {\n+        OAuthClient.AccessTokenResponse tokenRes = oauth.doBackchannelAuthenticationTokenRequest(clientId, clientSecret, authReqId);\n+        Assert.assertThat(tokenRes.getStatusCode(), is(equalTo(200)));\n+        EventRepresentation event = events.expectAuthReqIdToToken(codeId, sessionId).clearDetails().user(AssertEvents.isUUID()).client(clientId).assertEvent();\n+\n+        AccessToken accessToken = oauth.verifyToken(tokenRes.getAccessToken());\n+        Assert.assertThat(accessToken.getIssuedFor(), is(equalTo(clientId)));\n+\n+        RefreshToken refreshToken = oauth.parseRefreshToken(tokenRes.getRefreshToken());\n+        Assert.assertThat(refreshToken.getIssuedFor(), is(equalTo(clientId)));\n+        Assert.assertThat(refreshToken.getAudience()[0], is(equalTo(refreshToken.getIssuer())));\n+\n+        IDToken idToken = oauth.verifyIDToken(tokenRes.getIdToken());\n+        Assert.assertThat(idToken.getPreferredUsername(), is(equalTo(username)));\n+        Assert.assertThat(idToken.getIssuedFor(), is(equalTo(clientId)));\n+        Assert.assertThat(idToken.getAudience()[0], is(equalTo(idToken.getIssuedFor())));\n+\n+        return tokenRes;\n+    }\n+\n+    private String doIntrospectAccessTokenWithClientCredential(OAuthClient.AccessTokenResponse tokenRes, String username) throws IOException {\n+        String tokenResponse = oauth.introspectAccessTokenWithClientCredential(TEST_CLIENT_NAME, TEST_CLIENT_PASSWORD, tokenRes.getAccessToken());\n+        ObjectMapper objectMapper = new ObjectMapper();\n+        JsonNode jsonNode = objectMapper.readTree(tokenResponse);\n+        Assert.assertThat(jsonNode.get(\"active\").asBoolean(), is(equalTo(true)));\n+        Assert.assertThat(jsonNode.get(\"username\").asText(), is(equalTo(username)));\n+        Assert.assertThat(jsonNode.get(\"client_id\").asText(), is(equalTo(TEST_CLIENT_NAME)));\n+        TokenMetadataRepresentation rep = objectMapper.readValue(tokenResponse, TokenMetadataRepresentation.class);\n+        Assert.assertThat(rep.isActive(), is(equalTo(true)));\n+        Assert.assertThat(rep.getClientId(), is(equalTo(TEST_CLIENT_NAME)));\n+        Assert.assertThat(rep.getIssuedFor(), is(equalTo(TEST_CLIENT_NAME)));\n+        events.expect(EventType.INTROSPECT_TOKEN).user((String)null).clearDetails().assertEvent();\n+\n+        tokenResponse = oauth.introspectAccessTokenWithClientCredential(TEST_CLIENT_NAME, TEST_CLIENT_PASSWORD, tokenRes.getRefreshToken());\n+        jsonNode = objectMapper.readTree(tokenResponse);\n+        Assert.assertThat(jsonNode.get(\"active\").asBoolean(), is(equalTo(true)));\n+        Assert.assertThat(jsonNode.get(\"client_id\").asText(), is(equalTo(TEST_CLIENT_NAME)));\n+        rep = objectMapper.readValue(tokenResponse, TokenMetadataRepresentation.class);\n+        Assert.assertThat(rep.isActive(), is(equalTo(true)));\n+        Assert.assertThat(rep.getClientId(), is(equalTo(TEST_CLIENT_NAME)));\n+        Assert.assertThat(rep.getIssuedFor(), is(equalTo(TEST_CLIENT_NAME)));\n+        Assert.assertThat(rep.getAudience()[0], is(equalTo(rep.getIssuer())));\n+        events.expect(EventType.INTROSPECT_TOKEN).user((String)null).clearDetails().assertEvent();\n+\n+        tokenResponse = oauth.introspectAccessTokenWithClientCredential(TEST_CLIENT_NAME, TEST_CLIENT_PASSWORD, tokenRes.getIdToken());\n+        jsonNode = objectMapper.readTree(tokenResponse);\n+        Assert.assertThat(jsonNode.get(\"active\").asBoolean(), is(equalTo(true)));\n+        Assert.assertThat(jsonNode.get(\"client_id\").asText(), is(equalTo(TEST_CLIENT_NAME)));\n+        rep = objectMapper.readValue(tokenResponse, TokenMetadataRepresentation.class);\n+        Assert.assertThat(rep.isActive(), is(equalTo(true)));\n+        Assert.assertThat(rep.getUserName(), is(equalTo(username)));\n+        Assert.assertThat(rep.getClientId(), is(equalTo(TEST_CLIENT_NAME)));\n+        Assert.assertThat(rep.getIssuedFor(), is(equalTo(TEST_CLIENT_NAME)));\n+        Assert.assertThat(rep.getPreferredUsername(), is(equalTo(username)));\n+        Assert.assertThat(rep.getAudience()[0], is(equalTo(rep.getIssuedFor())));\n+        events.expect(EventType.INTROSPECT_TOKEN).user((String)null).clearDetails().assertEvent();\n+\n+        return tokenResponse;\n+    }\n+\n+    private OAuthClient.AccessTokenResponse doRefreshTokenRequest(String oldRefreshToken, String username, String sessionId, boolean isOfflineAccess) {\n+        OAuthClient.AccessTokenResponse tokenRes = oauth.doRefreshTokenRequest(oldRefreshToken, TEST_CLIENT_PASSWORD);\n+        Assert.assertThat(tokenRes.getStatusCode(), is(equalTo(200)));\n+\n+        AccessToken accessToken = oauth.verifyToken(tokenRes.getAccessToken());\n+        Assert.assertThat(accessToken.getIssuedFor(), is(equalTo(TEST_CLIENT_NAME)));\n+        Assert.assertThat(accessToken.getExp().longValue(), is(equalTo(accessToken.getIat().longValue() + tokenRes.getExpiresIn())));\n+\n+        RefreshToken refreshToken = oauth.parseRefreshToken(tokenRes.getRefreshToken());\n+        Assert.assertThat(refreshToken.getIssuedFor(), is(equalTo(TEST_CLIENT_NAME)));\n+        Assert.assertThat(refreshToken.getAudience()[0], is(equalTo(refreshToken.getIssuer())));\n+        if(!isOfflineAccess) Assert.assertThat(refreshToken.getExp().longValue(), is(equalTo(refreshToken.getIat().longValue() + tokenRes.getRefreshExpiresIn())));\n+\n+        IDToken idToken = oauth.verifyIDToken(tokenRes.getIdToken());\n+        Assert.assertThat(idToken.getPreferredUsername(), is(equalTo(username)));\n+        Assert.assertThat(idToken.getIssuedFor(), is(equalTo(TEST_CLIENT_NAME)));\n+        Assert.assertThat(idToken.getAudience()[0], is(equalTo(idToken.getIssuedFor())));\n+        Assert.assertThat(idToken.getExp().longValue(), is(equalTo(idToken.getIat().longValue() + tokenRes.getExpiresIn())));\n+\n+        events.expectRefresh(tokenRes.getRefreshToken(), sessionId).session(CoreMatchers.notNullValue(String.class)).user(AssertEvents.isUUID()).clearDetails().assertEvent();\n+\n+        return tokenRes;\n+    }\n+\n+    private EventRepresentation doLogoutByRefreshToken(String refreshToken, String sessionId, String userId, boolean isOfflineAccess) throws IOException{\n+        try (CloseableHttpResponse res = oauth.doLogout(refreshToken, TEST_CLIENT_PASSWORD)) {\n+            assertThat(res, Matchers.statusCodeIsHC(Status.NO_CONTENT));\n+        }\n+\n+        // confirm logged out\n+        OAuthClient.AccessTokenResponse tokenRes = oauth.doRefreshTokenRequest(refreshToken, TEST_CLIENT_PASSWORD);\n+        Assert.assertThat(tokenRes.getStatusCode(), is(equalTo(400)));\n+        Assert.assertThat(tokenRes.getError(), is(equalTo(OAuthErrorException.INVALID_GRANT)));\n+        if (isOfflineAccess) Assert.assertThat(tokenRes.getErrorDescription(), is(equalTo(\"Offline user session not found\")));\n+        else Assert.assertThat(tokenRes.getErrorDescription(), is(equalTo(\"Session not active\")));\n+\n+        return events.expectLogout(sessionId).client(TEST_CLIENT_NAME).user(AssertEvents.isUUID()).session(AssertEvents.isUUID()).clearDetails().assertEvent();\n+    }\n+\n+    private EventRepresentation doTokenRevokeByRefreshToken(String refreshToken, String sessionId, String userId, boolean isOfflineAccess) throws IOException{\n+        try (CloseableHttpResponse res = oauth.doTokenRevoke(refreshToken, \"refresh_token\", TEST_CLIENT_PASSWORD)) {\n+            assertThat(res, Matchers.statusCodeIsHC(Status.OK));\n+        }\n+\n+        // confirm revocation\n+        OAuthClient.AccessTokenResponse tokenRes = oauth.doRefreshTokenRequest(refreshToken, TEST_CLIENT_PASSWORD);\n+        Assert.assertThat(tokenRes.getStatusCode(), is(equalTo(400)));\n+        Assert.assertThat(tokenRes.getError(), is(equalTo(OAuthErrorException.INVALID_GRANT)));\n+        if (isOfflineAccess) Assert.assertThat(tokenRes.getErrorDescription(), is(equalTo(\"Offline user session not found\")));\n+        else Assert.assertThat(tokenRes.getErrorDescription(), is(equalTo(\"Session not active\")));\n+\n+        return events.expect(EventType.REVOKE_GRANT).clearDetails().client(TEST_CLIENT_NAME).user(AssertEvents.isUUID()).assertEvent();\n+    }\n+\n+    private void testBackchannelAuthenticationFlow(boolean isOfflineAccess) throws Exception {\n+        ClientResource clientResource = null;\n+        ClientRepresentation clientRep = null;\n+        try {\n+            final String username = \"nutzername-rot\";\n+            final String bindingMessage = \"BASTION\";\n+\n+            // prepare CIBA settings\n+            clientResource = ApiUtil.findClientByClientId(adminClient.realm(TEST_REALM_NAME), TEST_CLIENT_NAME);\n+            clientRep = clientResource.toRepresentation();\n+            prepareCIBASettings(clientResource, clientRep);\n+            if(isOfflineAccess) oauth.scope(OAuth2Constants.OFFLINE_ACCESS);\n+\n+            // user Backchannel Authentication Request\n+            AuthenticationRequestAcknowledgement response = doBackchannelAuthenticationRequest(TEST_CLIENT_NAME, TEST_CLIENT_PASSWORD, username, bindingMessage);\n+\n+            // user Authentication Channel Request\n+            AuthenticationChannelRequest authenticationChannelReq = doAuthenticationChannelRequest();", "originalCommit": "077f83af85195f4db9fffc0f1e245efc12d46f80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTkxNTgxNg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r601915816", "bodyText": "@mposolda I agree with you. It is quite reasonable. I will revise CIBATest as you suggested.", "author": "tnorimat", "createdAt": "2021-03-26T00:06:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQzMDg2OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjA3NjkzNA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r602076934", "bodyText": "Thanks!", "author": "mposolda", "createdAt": "2021-03-26T07:52:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTQzMDg2OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599501914", "bodyText": "I've been thinking about this one.\nPerhaps, but I'm not pushing for it now, we could make the payload simpler by:\n\nUse a JWS holding all these parameters. Including the serialized auth_req_id. The JWS would be sent in the body where the AD should support application/json media type. By using a JWS, we would avoid the payload from being tampered and allow ADs to perform a more secure validation by checking signatures, consider expiration of the request, audience, etc.\n\nOne possible exploit I can think about here is in case an attacker intercepts the request and is able to change the scope parameter, potentially causing the device to ask users for scopes that are not really those originally asked by the CD.", "author": "pedroigor", "createdAt": "2021-03-23T11:56:44Z", "path": "services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/channel/HttpAuthenticationChannelProvider.java", "diffHunk": "@@ -0,0 +1,105 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.oidc.grants.ciba.channel;\n+\n+import static org.keycloak.OAuth2Constants.SCOPE;\n+import static org.keycloak.protocol.oidc.grants.ciba.CibaGrantType.BINDING_MESSAGE;\n+\n+import java.io.IOException;\n+import java.util.Map;\n+\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response.Status;\n+\n+import org.keycloak.broker.provider.util.SimpleHttp;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;\n+import org.keycloak.services.resources.Cors;\n+\n+public class HttpAuthenticationChannelProvider implements AuthenticationChannelProvider{\n+\n+    public static final String AUTHENTICATION_CHANNEL_ID = \"authentication_channel_id\";\n+    public static final String AUTHENTICATION_CHANNEL_USER_INFO = \"user_info\";\n+    public static final String AUTHENTICATION_STATUS = \"auth_result\";\n+    public static final String AUTHENTICATION_CHANNEL_IS_CONSENT_REQUIRED = \"is_consent_required\";\n+\n+    protected KeycloakSession session;\n+    protected MultivaluedMap<String, String> formParams;\n+    protected RealmModel realm;\n+    protected Map<String, String> clientAuthAttributes;\n+    protected Cors cors;\n+    protected final String httpAuthenticationChannelUri;\n+\n+    public HttpAuthenticationChannelProvider(KeycloakSession session, String httpAuthenticationRequestUri) {\n+        this.session = session;\n+        this.realm = session.getContext().getRealm();\n+        this.httpAuthenticationChannelUri = httpAuthenticationRequestUri;\n+    }\n+\n+    @Override\n+    public boolean requestAuthentication(AuthenticationRequest request, String infoUsedByAuthenticator) {\n+        // create JWT formatted/JWS signed/JWE encrypted Authentication Channel ID by the same manner in creating auth_req_id\n+        // Authentication Channel ID binds Backchannel Authentication Request with Authentication by AD(Authentication Device).\n+        // By including userSessionIdWillBeCreated. keycloak can create UserSession whose ID is userSessionIdWillBeCreated on Authentication Channel Callback Endpoint,\n+        // which can bind userSessionIdWillBeCreated (namely, Backchannel Authentication Request) with authenticated UserSession.\n+        // By including authId, keycloak can create Authentication Channel Result of Authentication by AD on Authentication Channel Callback Endpoint,\n+        // which can bind authId with Authentication Channel Result of Authentication by AD.\n+        // By including client_id, Authentication Channel Callback Endpoint can recognize the CD(Consumption Device) who sent Backchannel Authentication Request.\n+\n+        // The following scopes should be displayed on AD(Authentication Device):\n+        // 1. scopes specified explicitly as query parameter in the authorization request\n+        // 2. scopes specified implicitly as default client scope in keycloak\n+\n+        checkAuthenticationChannel();\n+\n+        ClientModel client = request.getClient();\n+\n+        try {\n+            // TODO: we should probably just pass the serialized authentication request\n+            int status = SimpleHttp.doPost(httpAuthenticationChannelUri, session)", "originalCommit": "077f83af85195f4db9fffc0f1e245efc12d46f80", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTU1NDY0OQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599554649", "bodyText": "+1 that the request sent from HttpAuthenticationChannelProvider can be JWS instead of JWE. This will allow to simplify the protocol for the communication between Keycloak and \"Authentication channel\" as the \"Authentication Channel\" will be able to look all the stuff directly from the JWS.\nFor the auth_req_id sent in the initial response to client request from BackchannelAuthenticationEndpoint, I vote that it is kept as JWE as there is no reason to reveal any more informations with the client. And in case of JWS, some stuff is revealed to the client as he can simply look into the JWS. The client just need to sent periodic requests to the TokenEndpoint and he should be completely fine with treating auth_req_id to be opaque string to him and hence no reason to reveal any more info with him.", "author": "mposolda", "createdAt": "2021-03-23T13:13:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTU2MDUxMA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599560510", "bodyText": "@tnorimat @pedroigor I actually think if we don't have security hole in the current implementation? I will try to chime more and test, but I have some suspicion that client is currently able to do whole CIBA flow by himself without any interaction from the user. Client can probably does it by sending request to the BackchannelAuthenticationCallbackEndpoint with sending the authentication_channel_id where he just use the value sent to him as auth_req_id in the initial AuthenticationRequestAcknowledgement. I think that to prevent this, we may need to be sure that format of auth_req_id and authentication_channel_id is somehow different and there is any differentiator in them.\nEither by ensure that:\n\nauth_req_id sent to client is JWE when the authentication_channel_id sent to the AuthenticationChannel is JWS\nHave both as JWE (or as JWS), but then make sure that there is some other claim inside the request, which is able to differentiate between those two. And make sure that both callback endpoint and TokenEndpoint verifies this claim.\n\nThe point is, that client should not be allowed to finish whole CIBA flow by himself just by sending the request to the BackchannelAuthenticationCallbackEndpoint. The request sent to BackchannelAuthenticationCallbackEndpoint needs to be sent by the Authentication Channel itself if I understand correctly.", "author": "mposolda", "createdAt": "2021-03-23T13:20:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTU4Njk1MA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r599586950", "bodyText": "@tnorimat @pedroigor I've just did the automated test in this branch https://github.com/mposolda/keycloak/tree/KEYCLOAK-12137 for the above. See the latest commit from this branch. As pointed in the test, currently there is security hole as client is able to do whole CIBA flow by himself by just send the callback request with the authentication_channel_id where he use the auth_req_id sent to him before.\nI suggest that you cherry-pick the test to this PR and make something from the options I proposed above for fix the security hole. Related point is, that client authentication should be likely removed from the Backchannel callback endpoint as I pointed in the other inline comment as it is not the client, who should send this callback request.", "author": "mposolda", "createdAt": "2021-03-23T13:52:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDA2NTIwOA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r600065208", "bodyText": "@mposolda This should also be solved by changing the contract with the AD. So that we won't use the auth_req_id anymore, but a specific JWS which is bound with the auth_req_id. The client won't know about this token.", "author": "pedroigor", "createdAt": "2021-03-24T00:40:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDM3MjIzNg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r600372236", "bodyText": "@pedroigor Not 100% sure what you mean? Do you mean that auth_req_id parameter returned to the client from initial Backchannel endpoint will be simple ID and not anything like JWE/JWS? That can probably work though as long as Ciba Grant endpoint is able to use this ID for lookup OAuth2DeviceCodeModel from the cache - which it is AFAIK.\nSo are we going with:\n\nauth_req_id to be just simple UUID\nauthentication_channel_id to be JWS signed by the Keycloak server private key. Authentication channel 3rd party can download key from JWKS_URL (if it wants) and verify signature and retrieve all the data from it.\n\nWDYT?", "author": "mposolda", "createdAt": "2021-03-24T10:57:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMDM5MDEzOQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r600390139", "bodyText": "In fact, @tnorimat originally used a specific ID to send to AD. The auth_result_ id. I the one who introduced the behavior we are discussing.\nSo, I would just send the JWS and get it back, where its ID will be used to map to the model.\nBackchannel would just use bearer token authorization based on the JWS.", "author": "pedroigor", "createdAt": "2021-03-24T11:24:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMTkzMjYyOA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r601932628", "bodyText": "@mposolda @pedroigor  I've mentioned before, I've wanted to confirm that the following two entities are the same.\n\nThe entity sending the result of the authentication by AD to this callback endpoint.\nThe entity to which keycloak has sent the request of the authentication by AD via AuthenticationChannelProvider\n\nTo do so, I've considered as follows.\n\nWhen sending the request of the authentication by AD, keycloak put onto JWE the identity of this entity.\nWhen receiving the response of the authentication by AD, keycloak decrypts the accompanied JWE, reads the identity of the entity on this JWE, compare this identity with the one found by doing client authentication on this callback endpoint.\n\nHowever, the current AuthenticationRequest that is encrypted as authentication_channel_id in JWE does not include this identity. If do so, we could fix this issue, but it is only my idea so that other way like proposed by @mposolda is OK.\nauth_result_id is the information identifying the specific CIBA flow. It is kept in keycloak's infinispan distribution cache. Both JWE encrypted auth_req_id sent to the Client and JWE encrypted authentication_channel_id sent to the entity doing authentication includes this auth_result_id in order to bind several HTTP request/response among them  with one logical CIBA flow.", "author": "tnorimat", "createdAt": "2021-03-26T00:47:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjA5MjcxNA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r602092714", "bodyText": "@tnorimat +1 to include the identity in the authentication_channel_id as you proposed.\nAnother related thing is, if we want to change authentication_channel_id request to be JWS instead of JWE as @pedroigor proposed? This will have the advantage that all the info can be wrapped into the JWS token and the AD can read the data directly from it instead of including many other parameters in the request sent from HttpAuthenticationChannelProvider.sendRequest (In case of JWE, the authentication_channel_id is opaque string to the AD).\nFor the last point for auth_req_id, to me whatever works, which will make sure that auth_req_id and authentication_channel_id are not inter-changeable with each other. As the fact they are inter-changeable means the security whole when client is able to do whole CIBA flow without any interaction needed from the user. In other words, we need to somehow make sure that the test testAttackerClientUseAuthReqIdInCallbackEndpoint  I sent in the commit https://github.com/mposolda/keycloak/tree/KEYCLOAK-12137 will pass.", "author": "mposolda", "createdAt": "2021-03-26T08:23:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMjgzODkyMg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r602838922", "bodyText": "@mposolda @pedroigor Yes, we can change opaque JWE authentication_channel_id to semantic tamper-resistant JWS. Only relatively sensitive data included in the current JWE authentication_channel_id and will be revealed in JWS is\n    @JsonProperty(AUTH_RESULT_ID)\n    protected String authResultId;\n\nBut it is needed to bind the HTTP request/response conducted between CD and keycloak as one logical CIBA flow. Therefore it cannot be removed.\nAs mentioned earlier, to prevent the attacker from impersonating the entity via AuthenticationChannel the followings are needed.\n\ninclude this entity's identity in JWS or JWE authentication_channel_id (the current authentication_channel_id does not incude it.)\nwhen receiving the result of authentication by AD, keycloak needs to do client authentication and confirm that the identity determined by this client authentication is the client identified in authentication_channel_id.\n\nTo do so, keycloak needs to treat this entity as OAuth2's client. One idea just hit on me is as follows:\n\nAdd the CIBA setting specifying this entity.\nthe keycloak admin registers this entity as OAuth2's client (confidential) in advance\nthe keycloak admin set this client as the entity via AuthenticationChannel on CIBA settings\n\nIt might be better if there is the other way that can authenticate and identify such the entity in not introducing OAuth2's client concept.\nBTW, this authentication_channel_id is similar to Refresh Token because the issuer is also the audience.", "author": "tnorimat", "createdAt": "2021-03-28T06:29:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwMzEwOTk0NQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r603109945", "bodyText": "@tnorimat Let me check if I understand correctly your proposal:\n\nThere will be special client registered in Keycloak, which will represent the \"Authentication Channel (AD)\" .\nThe request sent to the BackchannelAuthenticationCallbackEndpoint will be secured by this special client. Hence Keycloak will need to verify authentication of this client (Currently in BackchannelAuthenticationCallbackEndpoint.authenticateClient(), Keycloak authenticates the \"target\" authentication client, which doesn't makes sense to me as I mentioned above)\nThe authentication_channel_id will contain JWS instead of JWE. And this JWS will contain the authResultId as one of the claims inside this JWS.\n\nIs it correct?\nFor me, it works. My original assumption was, that request to BackchannelAuthenticationCallbackEndpoint doesn't need to authenticate client at all . Just the fact that sender was able to send the authentication_channel_id is considered to be an \"authentication\" as there is an assumption that authentication_channel_id token is available just to the Authentication Channel (AD) and it is never shared with anyone. But I agree that add authentication of this \"Authentication Channel\" client to the BackchannelAuthenticationCallbackEndpoint will be safer to ensure that potential attacker, who stole the authentication_channel_id is not able to send the request to finish authentication.", "author": "mposolda", "createdAt": "2021-03-29T08:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNTMyOTYzNQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r605329635", "bodyText": "@mposolda\n\n\nThere will be special client registered in Keycloak, which will represent the \"Authentication Channel (AD)\" .\nThe request sent to the BackchannelAuthenticationCallbackEndpoint will be secured by this special client. Hence Keycloak will need to verify authentication of this client (Currently in BackchannelAuthenticationCallbackEndpoint.authenticateClient(), Keycloak authenticates the \"target\" authentication client, which doesn't makes sense to me as I mentioned above)\nThe authentication_channel_id will contain JWS instead of JWE. And this JWS will contain the authResultId as one of the claims inside this JWS.\n\n\nTo say more precisely, we need to put the identity of AD onto JWS or JWE authentication_channel_id. By doing so, we can confirm that the sender that has already authenticated as AD is actually the receiver to which keycloak sent authentication_channel_id.\nConsidering this point, we can detect the following attacks by the attacker who registered itself to keycloak as the legitimate client.\n\n[Impersonation] The attacker intercepts authentication_channel_id that keycloak sent to the legitimate AD and send authentication_channel_id on behalf of AD to keycloak.\n[Hijacking] The attacker triggers CIBA flow and get authentication_channel_id. After that, when the legitimate AD also triggers CIBA flow and get its own authentication_channel_id. When the AD sends authentication_channel_id to keycloak, the attacker replaces its own authentication_channel_id with AD's authentication_channel_id.\n\nAnd , as you proposed, under the assumption that only AD holds authentication_channel_id, it might be OK that the request to BackchannelAuthenticationCallbackEndpoint doesn't need to authenticate client.\nIMHO, I'm not sure whether this assumption is plausible or not. My vote is that\n\nIn this PR, the request to BackchannelAuthenticationCallbackEndpoint doesn't authenticate client. The design document and the keycloak manual mention the assumption that only AD holds authentication_channel_id.\nAs follow-up PR, we might consider the option that the request to BackchannelAuthenticationCallbackEndpoint authenticates client.\n\nWe might discuss whether  the request to BackchannelAuthenticationCallbackEndpoint need to authenticates client or not after this initial PR being released.\nWDYT?", "author": "tnorimat", "createdAt": "2021-04-01T02:05:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNzMxNDI4NA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r607314284", "bodyText": "@mposolda @tnorimat Could you guys check https://github.com/pedroigor/keycloak/tree/KEYCLOAK-12137 ?\nBasically, I've decoupled the authentication bits from the payload sent to AD. Keycloak sends now a JWS with only the necessary bits to authenticate requests from the AD at the callback endpoint. A payload is also sent with only the information needed by the AD.\nWe don't expose the auth_req_id to the AD. In fact, I think we can remove the subject  too.\nBy using JSON as a payload, I think the contract is much more simple and well structured than using form parameters.\nThere is no client authentication, but bearer authorization at both sides: the AD and the callback endpoint.\nThere is one thing though that I think we might consider:\n\n\nThe bearer token sent to AD uses the client associated with the CD. IMO, we should have the AD as a client as well. Ideally, we should build the JWS where azp is the AD client. That should also enable to pass the CD client id to the AD so that additional validations and logic can be applied by the AD when authorizing a user for a particular CD. One drawback of this is that it would make CIBA config a bit more complicated.\n\n\nBy having a specific client for AD, we can in the future perform other forms of authentication.\n\n\nI've also changed tests but I did only three of them. Please, let me know if the changes make sense so we can continue.", "author": "pedroigor", "createdAt": "2021-04-05T20:28:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNzc2Nzc5OQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r607767799", "bodyText": "@mposolda @tnorimat I was thinking more about how we authenticate the AD when at the callback endpoint. I think we should keep client authentication and have the AD as a client registered to the server.\nWhen at the callback endpoint, we are going to allow only the AD client.\nI'm not sure if we should blindly trust requests from AD based on bearer authorization only. This is a critical part of the CIBA flow and if the token is somehow leaked/stolen, bad things can happen.\nBearer authorization helps to authorize Keycloak when pushing authentication requests to AD. But not the other way around.\nSo, I propose we either:\n\nChange CIBA policy to define a client as an AD\nDefine a built-in role for CIBA that should be granted to clients actings as a AD\n\nWDYT?", "author": "pedroigor", "createdAt": "2021-04-06T11:31:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwNzk5NTg2MA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r607995860", "bodyText": "@pedroigor +1 to your last comment. I believe that this is also aligned with what we discussed earlier with @tnorimat in the comment #7679 (comment) and earlier.\nAlso if I understand correctly, it means that AuthenticationChannelRequest will need to contain the client_id of CD client, so that callback endpoint will verify this client_id and compare it with the ID from the cache (similarly like is currently done in your branch here https://github.com/pedroigor/keycloak/blob/KEYCLOAK-12137/services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationCallbackEndpoint.java#L127 ). This will be good to avoid scenarios mentioned by @tnorimat in this comment #7679 (comment) .\nFrom the proposed alternatives, I am not 100% sure if it is better to have client as an AD defined on the CIBA policy, or the built-in role for CIBA granted to clients? Any of those are fine for me for this PR.\n@pedroigor @tnorimat For the future, I guess we may need something even more powerful though. It is possible that various CD clients will want to authenticate against specified AD. The AD can be possibly either configured for the client OR the target AD can be chosen from multiple ADs inside BackchannelAuthenticationEndpoint based on the acr_values claim. At least, it is my understanding of the specification when it mentions this here https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#auth_server_obtains_consent:\nAfter the OP has validated the Authentication Request, the OP identifies the user and chooses a channel to best \nauthenticate the user and authorize the request, in line with the Client's requests regarding acr_values. \n\nWhich means that single CD client might want to use:\n\nAD client \"ad1\" in case that acr_values contains claims level1\nAD client \"ad2\" in case that acr_values contains claims level2\nBut this is just some brainstorming for the future. Not something for this PR IMO...", "author": "mposolda", "createdAt": "2021-04-06T16:20:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODA4NTA2OQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r608085069", "bodyText": "Also if I understand correctly, it means that AuthenticationChannelRequest will need to contain the client_id of CD client, so that callback endpoint will verify this client_id and compare it with the ID from the cache (similarly like is currently done in your branch here https://github.com/pedroigor/keycloak/blob/KEYCLOAK-12137/services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationCallbackEndpoint.java#L127 ). This will be good to avoid scenarios mentioned by @tnorimat in this comment #7679 (comment) .\n\nWhat I have in mind is:\n\n\nWe still need to pass some reference token so that we don't complicate the life of AD when invoking the callback endpoint. Without this token, we are in the same situation as before, where the AD should be aware of multiple fields to return back. One important aspect of this token is the azp, marking this token as primarily issued for the AD.\n(not the CD as it stands now)\n\n\nThe reference token is pretty much what I have in that branch. It should be enough to authenticate a request from Keycloak (signature mainly) and hold what is needed to validate requests from AD to the callback endpoint. The AD does not need to introspect this token but only use it to authenticate requests and replay it when calling the callback endpoint.\n\n\nThe payload, the AuthenticationChannelRequest is only used for passing data that might be useful for the AD when authenticating a user. One example is passing the client id of the CD so that the AD could do some sort of customization depending on the CD asking for authentication. Perhaps, also acr_values, etc.\n\n\nWhen making requests to the callback endpoint, the AD is going to authenticate using its client credentials (and any authentication method) and we are going to compare if the azp in the reference token is the same as the client authenticating (the AD) to the callback endpoint. If not, that means another client is trying to act as the AD.\n\n\n\nFrom the proposed alternatives, I am not 100% sure if it is better to have client as an AD defined on the CIBA policy, or the built-in role for CIBA granted to clients? Any of those are fine for me for this PR.\n\nSame here. I would also highlight that introducing either of these options is going to complicate CIBA config. And I'm also OK to leave that for now and only rely on the bearer-token authorization. Just like it is implemented in my branch. It is not the ideal, but it works as long as:\n\nAD must make sure the bearer token is secure in transit (TLS) and at rest (if they need to store it).\nAD should have a high level of trust\n\nIf these requirements can be fulfilled then I think it is OK to rely on bearer token authorization between callback endpoint and AD.\nWDYT?\n\n@pedroigor @tnorimat For the future, I guess we may need something even more powerful though. It is possible that various CD clients will want to authenticate against specified AD. The AD can be possibly either configured for the client OR the target AD can be chosen from multiple ADs inside BackchannelAuthenticationEndpoint based on the acr_values claim. At least, it is my understanding of the specification when it mentions this here https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html#auth_server_obtains_consent:\nAfter the OP has validated the Authentication Request, the OP identifies the user and chooses a channel to best \nauthenticate the user and authorize the request, in line with the Client's requests regarding acr_values. \n\nWhich means that single CD client might want to use:\n\nAD client \"ad1\" in case that acr_values contains claims level1\nAD client \"ad2\" in case that acr_values contains claims level2\nBut this is just some brainstorming for the future. Not something for this PR IMO...\n\n\nDefinitely. But easily solved as you can implement an authentication channel provider.", "author": "pedroigor", "createdAt": "2021-04-06T18:26:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODE0NDExMA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r608144110", "bodyText": "Btw, w.r.t to the callback endpoint contract. So far we are relying on request data (either as form params or as a JSON, as per in my branch) to check whether the user was authenticated by the AD, or if the authentication request was denied or canceled.\nAnother thing we could improve here is:\n\nRely on HTTP verbs for approval and deny. For instance, a POST to the callback endpoint is a OK from AD. A DELETE a deny/cancel. Not sure if we need to cancel.\nBy relying on HTTP verbs, we could still allow AD to pass \"details\" about the operation and potentially return that either to the CD or just for audit purposes.", "author": "pedroigor", "createdAt": "2021-04-06T20:04:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODI2OTYxMQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r608269611", "bodyText": "@pedroigor @mposolda I agree with the discussion here and the @pedroigor 's branch https://github.com/pedroigor/keycloak/tree/KEYCLOAK-12137.\nOnly I would like to mention is that we need to describe the assumption just below explicitly on keycloak's document.\n\n\nAD must make sure the bearer token is secure in transit (TLS) and at rest (if they need to store it).\nAD should have a high level of trust\n\n\n@pedroigor If you do not have any plan to change your branch further drastically, I would like to pick up it and continue my work based on it. WDYT?", "author": "tnorimat", "createdAt": "2021-04-07T00:55:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODM3MjAzNg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r608372036", "bodyText": "@pedroigor I am also fine with the fact that callback endpoint won't be authenticated by the AD for now. I originally though that you wanted to enforce the client authentication of AD client based on your comment #7679 (comment) . But agree that it would be another complexity, so +1 for adding it later and just go with bearer authentication for now.\nWhen you pointed acr_values inside AuthenticationChannelRequest, this is exactly something, which we discussed with @tnorimat on the other place #7679 (comment) . My vote would be to allow acr_values parameter inside the initial BackchannelAuthenticationEndpoint and forward it to the AD as it is, so that AD can eventually choose from various authentication possibilities for the case it supports acr_values. But not a blocker for this PR IMO.", "author": "mposolda", "createdAt": "2021-04-07T06:26:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODY5NDIxNw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r608694217", "bodyText": "@pedroigor If you do not have any plan to change your branch further drastically, I would like to pick up it and continue my work based on it. WDYT?\n\nI don't :) Sounds good to me, please continue your work on it.\nI've also updated tests.\nOne thing though that I think we should do is to make sure CIBA is marked as a tech preview feature. For that, I've updated that branch to avoid registering CIBA-related providers.\n@mposolda I found an issue when providers are being deployed where the list of default providers is not updated. Please, see the DefaultKeycloakSessionFactory changes.", "author": "pedroigor", "createdAt": "2021-04-07T14:14:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwODY5NTI4Mw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r608695283", "bodyText": "@pedroigor I am also fine with the fact that callback endpoint won't be authenticated by the AD for now. I originally though that you wanted to enforce the client authentication of AD client based on your comment #7679 (comment) . But agree that it would be another complexity, so +1 for adding it later and just go with bearer authentication for now.\n\nI still think it is important. But right now it would complicate the CIBA config a bit and we can always add client authentication, as you guys mentioned.", "author": "pedroigor", "createdAt": "2021-04-07T14:15:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTMxODQ0Mw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r609318443", "bodyText": "@pedroigor Thank you. I'll pick up your branch, consider the following points and push additional commits.\n\nmake CIBA preview feature.\nsend acr_values to AD if it exists as @mposolda has suggested.", "author": "tnorimat", "createdAt": "2021-04-08T05:38:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTM3ODMzOQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r609378339", "bodyText": "@pedroigor Changes to DefaultKeycloakSessionFactory looks good to me. Thanks for the update.", "author": "mposolda", "createdAt": "2021-04-08T07:09:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTU1ODAwMg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r609558002", "bodyText": "@tnorimat The changes to have it as a preview feature should be there already.", "author": "pedroigor", "createdAt": "2021-04-08T10:39:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYwOTU2NTY0Nw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r609565647", "bodyText": "@tnorimat If you think it makes sense, please also consider changing the callback endpoint to use the HTTP POST and DELETE verbs for approving and denying authentication requests, respectively. As I mentioned in one of my last comments, that should make it more RESTful-styled and make life a bit easier for AD.\nNot a must-have, but a suggestion.", "author": "pedroigor", "createdAt": "2021-04-08T10:49:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTAyNTEyMw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r611025123", "bodyText": "@pedroigor @mposolda I'm trying to restore commented out tests of CIBATest and found that AD became not to send the authenticated user (e.g. username as user hint) to keycloak's callback endpoint BackchannelAuthenticationCallbackEndpoint which makes CIBATest.testDifferentUserAuthenticated not work.\nIMO, this authenticated user has to be propagated to keycloak so that keycloak can confirm that the user it want to be authenticated is actually the authenticated one by AD. WDYT?", "author": "tnorimat", "createdAt": "2021-04-10T10:04:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTUzMTI4OQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r611531289", "bodyText": "@tnorimat Now we are binding the token to the authentication request, I would say this check is no longer relevant?", "author": "pedroigor", "createdAt": "2021-04-12T11:02:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTUzNjY1OA==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r611536658", "bodyText": "@pedroigor  I'm afraid that honest AD may mistakenly authenticate the different user. However, I've reconsider this matter and found that we need not to send back the authenticated user by AD to keycloak because we've already assumed the following conditions when the keycloak user uses CIBA.\n\nAD must make sure the bearer token is secure in transit (TLS) and at rest (if they need to store it).\nAD should have a high level of trust\n\nTherefore, I would like to remove the corresponding test method in CIBATest. WDYT?", "author": "tnorimat", "createdAt": "2021-04-12T11:10:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMTU2ODE3Mg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r611568172", "bodyText": "I agree.", "author": "pedroigor", "createdAt": "2021-04-12T12:03:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU5OTUwMTkxNA=="}], "type": "inlineReview"}, {"oid": "ed778bbc0ae730a75eb17b8c06761180a8f370f7", "url": "https://github.com/keycloak/keycloak/commit/ed778bbc0ae730a75eb17b8c06761180a8f370f7", "message": "ignore RealmRepresentation.getAttributesOrEmpty for PermissionsTest", "committedDate": "2021-03-24T05:05:56Z", "type": "forcePushed"}, {"oid": "831c27e719868d70fade0dba77ae932d64a52c1a", "url": "https://github.com/keycloak/keycloak/commit/831c27e719868d70fade0dba77ae932d64a52c1a", "message": "add c4r1570p4e's commit", "committedDate": "2021-04-12T05:21:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjMzNDIwMw==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r612334203", "bodyText": "Can you please revert this change?", "author": "pedroigor", "createdAt": "2021-04-13T10:44:08Z", "path": "model/map/src/main/java/org/keycloak/models/map/realm/AbstractRealmEntity.java", "diffHunk": "@@ -97,9 +97,10 @@\n     private String resetCredentialsFlow;\n     private String clientAuthenticationFlow;\n     private String dockerAuthenticationFlow;\n-    private MapOTPPolicyEntity otpPolicy = MapOTPPolicyEntity.fromModel(OTPPolicy.DEFAULT_POLICY);;\n-    private MapWebAuthnPolicyEntity webAuthnPolicy = MapWebAuthnPolicyEntity.defaultWebAuthnPolicy();;\n-    private MapWebAuthnPolicyEntity webAuthnPolicyPasswordless = MapWebAuthnPolicyEntity.defaultWebAuthnPolicy();;\n+    private MapOTPPolicyEntity otpPolicy = MapOTPPolicyEntity.fromModel(OTPPolicy.DEFAULT_POLICY);\n+    private MapWebAuthnPolicyEntity webAuthnPolicy = MapWebAuthnPolicyEntity.defaultWebAuthnPolicy();\n+    private MapWebAuthnPolicyEntity webAuthnPolicyPasswordless = MapWebAuthnPolicyEntity.defaultWebAuthnPolicy();\n+", "originalCommit": "da5a0fab4ef08d7088fd67c69d3604eea65f700e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNDQ4NjIyMg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r614486222", "bodyText": "@pedroigor I've checked the diff and found that the codes\n-    private MapOTPPolicyEntity otpPolicy = MapOTPPolicyEntity.fromModel(OTPPolicy.DEFAULT_POLICY);;\n-    private MapWebAuthnPolicyEntity webAuthnPolicy = MapWebAuthnPolicyEntity.defaultWebAuthnPolicy();;\n-    private MapWebAuthnPolicyEntity webAuthnPolicyPasswordless = MapWebAuthnPolicyEntity.defaultWebAuthnPolicy();;\n+    private MapOTPPolicyEntity otpPolicy = MapOTPPolicyEntity.fromModel(OTPPolicy.DEFAULT_POLICY);\n+    private MapWebAuthnPolicyEntity webAuthnPolicy = MapWebAuthnPolicyEntity.defaultWebAuthnPolicy();\n+    private MapWebAuthnPolicyEntity webAuthnPolicyPasswordless = MapWebAuthnPolicyEntity.defaultWebAuthnPolicy();\n\nTherefore, should I revert to the following?\n    private MapOTPPolicyEntity otpPolicy = MapOTPPolicyEntity.fromModel(OTPPolicy.DEFAULT_POLICY);;\n    private MapWebAuthnPolicyEntity webAuthnPolicy = MapWebAuthnPolicyEntity.defaultWebAuthnPolicy();;\n    private MapWebAuthnPolicyEntity webAuthnPolicyPasswordless = MapWebAuthnPolicyEntity.defaultWebAuthnPolicy();;", "author": "tnorimat", "createdAt": "2021-04-16T00:54:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjMzNDIwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjM0ODk0NQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r612348945", "bodyText": "Please, look at my changes here pedroigor@36d4dad#diff-02e6e5ccb2fbf550ae191261cd4daa7e0618fc5e52f3810ea7e69550d0ac3d3fL72.\nWe should avoid using this kind of check and avoid loading any CIBA-related provider by pedroigor@36d4dad#diff-b3048d7253e9d6afa4a39616a9e090326ef3474fc31322f2a797991eeba73a5dR35.\nHere we are using EnvironmentDependentProviderFactory to decide whether or not CIBA providers should be loaded.", "author": "pedroigor", "createdAt": "2021-04-13T11:08:52Z", "path": "services/src/main/java/org/keycloak/protocol/oidc/grants/ciba/endpoints/BackchannelAuthenticationEndpoint.java", "diffHunk": "@@ -0,0 +1,238 @@\n+/*\n+ * Copyright 2020 Red Hat, Inc. and/or its affiliates\n+ * and other contributors as indicated by the @author tags.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.keycloak.protocol.oidc.grants.ciba.endpoints;\n+\n+import static org.keycloak.protocol.oidc.OIDCLoginProtocol.ID_TOKEN_HINT;\n+import static org.keycloak.protocol.oidc.OIDCLoginProtocol.LOGIN_HINT_PARAM;\n+\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.Context;\n+import javax.ws.rs.core.MediaType;\n+import javax.ws.rs.core.MultivaluedMap;\n+import javax.ws.rs.core.Response;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+import com.fasterxml.jackson.databind.node.ObjectNode;\n+import org.jboss.resteasy.annotations.cache.NoCache;\n+import org.jboss.resteasy.spi.HttpRequest;\n+import org.keycloak.OAuth2Constants;\n+import org.keycloak.OAuthErrorException;\n+import org.keycloak.common.Profile;\n+import org.keycloak.common.util.Time;\n+import org.keycloak.events.EventBuilder;\n+import org.keycloak.events.EventType;\n+import org.keycloak.models.CibaConfig;\n+import org.keycloak.models.ClientModel;\n+import org.keycloak.models.KeycloakSession;\n+import org.keycloak.models.OAuth2DeviceCodeModel;\n+import org.keycloak.models.OAuth2DeviceTokenStoreProvider;\n+import org.keycloak.models.OAuth2DeviceUserCodeModel;\n+import org.keycloak.models.RealmModel;\n+import org.keycloak.models.UserModel;\n+import org.keycloak.protocol.oidc.grants.ciba.CibaGrantType;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationChannelProvider;\n+import org.keycloak.protocol.oidc.grants.ciba.channel.AuthenticationRequest;\n+import org.keycloak.protocol.oidc.grants.ciba.resolvers.CIBALoginUserResolver;\n+import org.keycloak.services.ErrorResponseException;\n+import org.keycloak.util.JsonSerialization;\n+import org.keycloak.utils.ProfileHelper;\n+\n+public class BackchannelAuthenticationEndpoint extends AbstractCibaEndpoint {\n+\n+    private final RealmModel realm;\n+\n+    public BackchannelAuthenticationEndpoint(KeycloakSession session, EventBuilder event) {\n+        super(session, event);\n+        this.realm = session.getContext().getRealm();\n+        event.event(EventType.LOGIN);\n+    }\n+\n+    @POST\n+    @NoCache\n+    @Consumes(MediaType.APPLICATION_FORM_URLENCODED)\n+    @Produces(MediaType.APPLICATION_JSON)\n+    public Response processGrantRequest(@Context HttpRequest httpRequest) {\n+        ProfileHelper.requireFeature(Profile.Feature.CIBA);", "originalCommit": "da5a0fab4ef08d7088fd67c69d3604eea65f700e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTEyNjMxMg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r615126312", "bodyText": "@pedroigor I see, I would like to add them. By the way, your commit(pedroigor@36d4dad) have other different parts against my latest commit(3ab5bae). Should I cherry pick your this commit to my latest commit?", "author": "tnorimat", "createdAt": "2021-04-16T21:16:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjM0ODk0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNTc1MDQxNQ==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r615750415", "bodyText": "Yes, I would say so. There is an important fix to KeycloakSessionFactory here too. See pedroigor@36d4dad#diff-84a206194f2fcaa58d8b4cc343e9092f5c7e7d22576ec362d87fa85cbfc823c9.", "author": "pedroigor", "createdAt": "2021-04-19T11:02:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjM0ODk0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxNjI2OTMwMg==", "url": "https://github.com/keycloak/keycloak/pull/7679#discussion_r616269302", "bodyText": "@pedroigor I've cherry-picked your commit (pedroigor@36d4dad). Thank you. However, mentioned below, CIBATest fails in -Pauth-server-wildfly.", "author": "tnorimat", "createdAt": "2021-04-20T00:53:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDYxMjM0ODk0NQ=="}], "type": "inlineReview"}, {"oid": "f60f13a7ee575ee00bc8324d5bb72d2f8f5ceec9", "url": "https://github.com/keycloak/keycloak/commit/f60f13a7ee575ee00bc8324d5bb72d2f8f5ceec9", "message": "remove not used arguments", "committedDate": "2021-04-22T01:47:05Z", "type": "forcePushed"}, {"oid": "f648a35eaed5cf7df337ac14dd026ee73ef96837", "url": "https://github.com/keycloak/keycloak/commit/f648a35eaed5cf7df337ac14dd026ee73ef96837", "message": "KEYCLOAK-12137 OpenID Connect Client Initiated Backchannel Authentication (CIBA)\n\nCo-authored-by: Andrii Murashkin <amu@adorsys.com.ua>\nCo-authored-by: Christophe Lannoy <c4r1570p4e@gmail.com>", "committedDate": "2021-04-28T21:47:19Z", "type": "commit"}, {"oid": "2d0a282f1d5b3e3fab17e6e66693602cbd8ed9c2", "url": "https://github.com/keycloak/keycloak/commit/2d0a282f1d5b3e3fab17e6e66693602cbd8ed9c2", "message": "removing ciba flow", "committedDate": "2021-04-28T21:47:19Z", "type": "commit"}, {"oid": "ebaadaf1d7f7d6af1a5d5d6f9b726ff34e60e4cc", "url": "https://github.com/keycloak/keycloak/commit/ebaadaf1d7f7d6af1a5d5d6f9b726ff34e60e4cc", "message": "revert ciba flow related tests", "committedDate": "2021-04-28T21:47:19Z", "type": "commit"}, {"oid": "80f24bbd8731e8ef988485a09b7336e943047d6d", "url": "https://github.com/keycloak/keycloak/commit/80f24bbd8731e8ef988485a09b7336e943047d6d", "message": "revert removed SAML SCP default auth flow setting", "committedDate": "2021-04-28T21:47:19Z", "type": "commit"}, {"oid": "7915f9b49e3b8cea2466cebf7ca6a000219f8e1e", "url": "https://github.com/keycloak/keycloak/commit/7915f9b49e3b8cea2466cebf7ca6a000219f8e1e", "message": "refactoring", "committedDate": "2021-04-28T21:47:20Z", "type": "commit"}, {"oid": "9a63da421623a392e18b89160eb5b10900620eee", "url": "https://github.com/keycloak/keycloak/commit/9a63da421623a392e18b89160eb5b10900620eee", "message": "fix CIBATest", "committedDate": "2021-04-28T21:47:20Z", "type": "commit"}, {"oid": "3673a17873f26d225c3ec34d64905afc8af70ebf", "url": "https://github.com/keycloak/keycloak/commit/3673a17873f26d225c3ec34d64905afc8af70ebf", "message": "fixing backchannel endpoint url", "committedDate": "2021-04-28T21:47:20Z", "type": "commit"}, {"oid": "2d80f93a96fc2e56267cd76eeae0dc2df928394f", "url": "https://github.com/keycloak/keycloak/commit/2d80f93a96fc2e56267cd76eeae0dc2df928394f", "message": "ignore RealmRepresentation.getAttributesOrEmpty for PermissionsTest", "committedDate": "2021-04-28T21:47:20Z", "type": "commit"}, {"oid": "acee96924e9385d0167ba7c08ef3b51a82e088ab", "url": "https://github.com/keycloak/keycloak/commit/acee96924e9385d0167ba7c08ef3b51a82e088ab", "message": "add author tag", "committedDate": "2021-04-28T21:47:20Z", "type": "commit"}, {"oid": "77419f98cdfc7eab29e37f7fa8e00c7e6b8af314", "url": "https://github.com/keycloak/keycloak/commit/77419f98cdfc7eab29e37f7fa8e00c7e6b8af314", "message": "ad authentication", "committedDate": "2021-04-28T22:01:26Z", "type": "commit"}, {"oid": "2b95bb6a5592b5db26165bc4268f657690ada06e", "url": "https://github.com/keycloak/keycloak/commit/2b95bb6a5592b5db26165bc4268f657690ada06e", "message": "restore tests", "committedDate": "2021-04-28T22:01:33Z", "type": "commit"}, {"oid": "824404af9c286924f0f8493498315ea938e74258", "url": "https://github.com/keycloak/keycloak/commit/824404af9c286924f0f8493498315ea938e74258", "message": "remove unnecessary factory registration", "committedDate": "2021-04-28T22:01:33Z", "type": "commit"}, {"oid": "15f2bc2398bdb7c4def12092e3967f9c685ad936", "url": "https://github.com/keycloak/keycloak/commit/15f2bc2398bdb7c4def12092e3967f9c685ad936", "message": "partially support optional acr_values parameter", "committedDate": "2021-04-28T22:01:33Z", "type": "commit"}, {"oid": "9a7cb02f3a27ddeb24c6a750d484edb17868b5b6", "url": "https://github.com/keycloak/keycloak/commit/9a7cb02f3a27ddeb24c6a750d484edb17868b5b6", "message": "add c4r1570p4e's commit", "committedDate": "2021-04-28T22:01:33Z", "type": "commit"}, {"oid": "965f09c486d4de1b881587be26980914c8e417a2", "url": "https://github.com/keycloak/keycloak/commit/965f09c486d4de1b881587be26980914c8e417a2", "message": "fix code comments and remove unused codes", "committedDate": "2021-04-28T22:01:33Z", "type": "commit"}, {"oid": "70cc31ff06c667d962ede75ceebe7cc2a34f4c8a", "url": "https://github.com/keycloak/keycloak/commit/70cc31ff06c667d962ede75ceebe7cc2a34f4c8a", "message": "Added testAttackerClientUseAuthReqIdInCallbackEndpoint", "committedDate": "2021-04-28T22:01:33Z", "type": "commit"}, {"oid": "4882555bd77f98297d9dbf8f2e2c3700332d8c6c", "url": "https://github.com/keycloak/keycloak/commit/4882555bd77f98297d9dbf8f2e2c3700332d8c6c", "message": "Use Infinispan time service and remove WaitUtils pauses", "committedDate": "2021-04-28T22:01:33Z", "type": "commit"}, {"oid": "d5573890e4da627d72e8fa94d2a874a84aff0c3d", "url": "https://github.com/keycloak/keycloak/commit/d5573890e4da627d72e8fa94d2a874a84aff0c3d", "message": "changes to callback endpoint and ciba feature", "committedDate": "2021-04-28T22:01:33Z", "type": "commit"}, {"oid": "1e87ebb8cab0258cf537f8eba45726b5128af280", "url": "https://github.com/keycloak/keycloak/commit/1e87ebb8cab0258cf537f8eba45726b5128af280", "message": "only accept supported backchannel token delivery mode client metadata", "committedDate": "2021-04-28T22:01:34Z", "type": "commit"}, {"oid": "6dd1d4b42aeb99ffb407b6df75de7da292146fc6", "url": "https://github.com/keycloak/keycloak/commit/6dd1d4b42aeb99ffb407b6df75de7da292146fc6", "message": "fixing auth-server-wildfly tests", "committedDate": "2021-04-28T22:01:34Z", "type": "commit"}, {"oid": "9879a644f7cf32a7d8d5feec8549b97fe3023ee2", "url": "https://github.com/keycloak/keycloak/commit/9879a644f7cf32a7d8d5feec8549b97fe3023ee2", "message": "rename CIBAEndpoint", "committedDate": "2021-04-28T22:01:34Z", "type": "commit"}, {"oid": "2d1ff848e3b8e6bba980c4e7d9681fb5adcd2a77", "url": "https://github.com/keycloak/keycloak/commit/2d1ff848e3b8e6bba980c4e7d9681fb5adcd2a77", "message": "rename AuthenticationRequest", "committedDate": "2021-04-28T22:01:34Z", "type": "commit"}, {"oid": "28fc9341a362123737cc5f41800de3ad8e98f27d", "url": "https://github.com/keycloak/keycloak/commit/28fc9341a362123737cc5f41800de3ad8e98f27d", "message": "remove not used arguments", "committedDate": "2021-04-28T22:01:34Z", "type": "commit"}, {"oid": "2f0b222eedb532c7aa137e4739f9ba1f5c76e982", "url": "https://github.com/keycloak/keycloak/commit/2f0b222eedb532c7aa137e4739f9ba1f5c76e982", "message": "remove unnecessary server config in json", "committedDate": "2021-04-28T22:01:34Z", "type": "commit"}, {"oid": "af4f8a181a92057aa7c6b201c2b1a9c6a5c4df4d", "url": "https://github.com/keycloak/keycloak/commit/af4f8a181a92057aa7c6b201c2b1a9c6a5c4df4d", "message": "fix OIDCClientRegistrationTest.testCIBASettings", "committedDate": "2021-04-28T22:01:34Z", "type": "commit"}, {"oid": "3e6cdc682f44cc902cd879a404a3a32a5435e3d2", "url": "https://github.com/keycloak/keycloak/commit/3e6cdc682f44cc902cd879a404a3a32a5435e3d2", "message": "add ciba grant enable switch per client", "committedDate": "2021-04-28T22:01:34Z", "type": "commit"}, {"oid": "3a449a9a8cad58fb9323796c7576e4f105006c0b", "url": "https://github.com/keycloak/keycloak/commit/3a449a9a8cad58fb9323796c7576e4f105006c0b", "message": "convert internal and external rep for ciba grant", "committedDate": "2021-04-28T22:01:34Z", "type": "commit"}, {"oid": "fc0c8b6eb3fc17e419d80e8bf3c2a6590330b238", "url": "https://github.com/keycloak/keycloak/commit/fc0c8b6eb3fc17e419d80e8bf3c2a6590330b238", "message": "fix messages", "committedDate": "2021-04-28T22:01:35Z", "type": "commit"}, {"oid": "42af20907a9fb1c63f670e3f8d1c36e40bd74516", "url": "https://github.com/keycloak/keycloak/commit/42af20907a9fb1c63f670e3f8d1c36e40bd74516", "message": "move delivery mode setting to CibaConfig", "committedDate": "2021-04-28T22:01:35Z", "type": "commit"}, {"oid": "722f1ff03a18def0931592afbec05e09474617a4", "url": "https://github.com/keycloak/keycloak/commit/722f1ff03a18def0931592afbec05e09474617a4", "message": "typos", "committedDate": "2021-04-28T22:01:35Z", "type": "commit"}, {"oid": "8845be86d8baa428236df89eda4058589087ad46", "url": "https://github.com/keycloak/keycloak/commit/8845be86d8baa428236df89eda4058589087ad46", "message": "Avoid writing to DB during constructor of CibaConfig", "committedDate": "2021-04-28T22:01:35Z", "type": "commit"}, {"oid": "8845be86d8baa428236df89eda4058589087ad46", "url": "https://github.com/keycloak/keycloak/commit/8845be86d8baa428236df89eda4058589087ad46", "message": "Avoid writing to DB during constructor of CibaConfig", "committedDate": "2021-04-28T22:01:35Z", "type": "forcePushed"}]}