{"pr_number": 7569, "pr_title": "Keycloak 9551 refresh token client cred", "pr_createdAt": "2020-11-03T12:33:51Z", "pr_url": "https://github.com/keycloak/keycloak/pull/7569", "timeline": [{"oid": "5af485a11a3eeb66046f46b6cc065b07a71da256", "url": "https://github.com/keycloak/keycloak/commit/5af485a11a3eeb66046f46b6cc065b07a71da256", "message": "More fixes", "committedDate": "2020-11-04T08:41:20Z", "type": "forcePushed"}, {"oid": "8bcba2142d634daf9ac3a662376fab993ddeb901", "url": "https://github.com/keycloak/keycloak/commit/8bcba2142d634daf9ac3a662376fab993ddeb901", "message": "More fixes", "committedDate": "2020-11-04T14:50:37Z", "type": "forcePushed"}, {"oid": "f6461b305e968e03dba7b614b7c0f4fcf84e9fba", "url": "https://github.com/keycloak/keycloak/commit/f6461b305e968e03dba7b614b7c0f4fcf84e9fba", "message": "Fx KcReg", "committedDate": "2020-11-05T10:49:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk4NDA0Ng==", "url": "https://github.com/keycloak/keycloak/pull/7569#discussion_r517984046", "bodyText": "Nice one the removal of duplicates for this piece.", "author": "pedroigor", "createdAt": "2020-11-05T11:34:41Z", "path": "model/infinispan/src/main/java/org/keycloak/models/sessions/infinispan/InfinispanSingleUseTokenStoreProviderFactory.java", "diffHunk": "@@ -52,28 +52,32 @@ private void lazyInit(KeycloakSession session) {\n         if (tokenCache == null) {\n             synchronized (this) {\n                 if (tokenCache == null) {\n-                    InfinispanConnectionProvider connections = session.getProvider(InfinispanConnectionProvider.class);\n-                    Cache cache = connections.getCache(InfinispanConnectionProvider.ACTION_TOKEN_CACHE);\n-\n-                    RemoteCache remoteCache = InfinispanUtil.getRemoteCache(cache);\n-\n-                    if (remoteCache != null) {\n-                        LOG.debugf(\"Having remote stores. Using remote cache '%s' for single-use cache of token\", remoteCache.getName());\n-                        this.tokenCache = () -> {\n-                            // Doing this way as flag is per invocation\n-                            return remoteCache.withFlags(Flag.FORCE_RETURN_VALUE);\n-                        };\n-                    } else {\n-                        LOG.debugf(\"Not having remote stores. Using normal cache '%s' for single-use cache of token\", cache.getName());\n-                        this.tokenCache = () -> {\n-                            return cache;\n-                        };\n-                    }\n+                    this.tokenCache = getActionTokenCache(session);\n                 }\n             }\n         }\n     }\n \n+    static Supplier getActionTokenCache(KeycloakSession session) {", "originalCommit": "f6461b305e968e03dba7b614b7c0f4fcf84e9fba", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk5NjIzOA==", "url": "https://github.com/keycloak/keycloak/pull/7569#discussion_r517996238", "bodyText": "Just to confirm my understanding.\nNow that token revocation supports access tokens, we have this check to revoke them although in case the token is stateful the session will still be alive. So clients would be forced to refresh the token.\nMakes sense ?", "author": "pedroigor", "createdAt": "2020-11-05T11:56:29Z", "path": "services/src/main/java/org/keycloak/protocol/oidc/TokenManager.java", "diffHunk": "@@ -233,28 +235,43 @@ public boolean checkTokenValidForIntrospection(KeycloakSession session, RealmMod\n             return false;\n         }\n \n-        boolean valid = false;\n+        TokenRevocationStoreProvider revocationStore = session.getProvider(TokenRevocationStoreProvider.class);\n+        if (revocationStore.isRevoked(token.getId())) {", "originalCommit": "f6461b305e968e03dba7b614b7c0f4fcf84e9fba", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA0NjE3Mg==", "url": "https://github.com/keycloak/keycloak/pull/7569#discussion_r518046172", "bodyText": "Yes, the session will be still alive once access tokens are revoked. Few points to this:\n\n\nSpecification https://tools.ietf.org/html/rfc7009 does not prescribe the behaviour in this case. It explicitly mentions: \"If the token passed to the request is an access token, the server MAY revoke the respective refresh token as well.\" .\n\n\nRegarding session revoke for access tokens, I was thinking about the following scenario:\n-- Public client \"foo\" obtains tokens through the Browser UI\n-- Client \"foo\" sends the token to the resource-server \"bar\"\n-- Resource server \"bar\" is bad citizen and he decides to revoke the access token sent to it. Nothing prevents him to do so, as the \"foo\" is public client and hence Keycloak will just need to accept the access token sent to it for the revocation\n-- Now if the session will be logged-out as well, it would give the resource server \"bar\" the power to revoke sessions of client \"foo\" . Which IMO is not great behaviour. That's why I've not invalidated the session for the access token.\n\n\nWDYT?", "author": "mposolda", "createdAt": "2020-11-05T13:23:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk5NjIzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA1NzkwNA==", "url": "https://github.com/keycloak/keycloak/pull/7569#discussion_r518057904", "bodyText": "The main reason behind my question is that accordingly to the specs the AS \"verifies whether the token\nwas issued to the client making the revocation request\". That said, you can't revoke the token using a different client. In your case, the RS won't be able to revoke tokens issued to the client application.\nI did not consider this point as critical because I consider this as an improvement so that admins can choose the behavior.", "author": "pedroigor", "createdAt": "2020-11-05T13:41:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk5NjIzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA2NTk4MQ==", "url": "https://github.com/keycloak/keycloak/pull/7569#discussion_r518065981", "bodyText": "Hmm... The thing is that when \"foo\" is public client as in my example, then the resource server can just do revocation request? Reason is that there is no client authentication. So the resource server will just need to know:\n\nthe \"client_id=foo\", which he can use in the revocation request\nthe access token, which was sent to it\nAnd he has all of this, so Keycloak server will just need to accept revocation request and revoke the token?", "author": "mposolda", "createdAt": "2020-11-05T13:52:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk5NjIzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODA4MjgzNg==", "url": "https://github.com/keycloak/keycloak/pull/7569#discussion_r518082836", "bodyText": "I'm not sure if that would be possible because token revocation requires client authentication.", "author": "pedroigor", "createdAt": "2020-11-05T14:16:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk5NjIzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODExOTI5OA==", "url": "https://github.com/keycloak/keycloak/pull/7569#discussion_r518119298", "bodyText": "Yeah, however in case of the public clients, the client authentication is just verification that there is parameter like \"client_id=foo\" . It seems our TokenRevocationEndpoint calls the \"AuthorizeClientUtil.authorizeClient\", which does just this for public clients. So it is not real authentication. The specs does not enforce client authentication, it allows public clients as well, so we are fine with regards to the specs IMO...", "author": "mposolda", "createdAt": "2020-11-05T15:03:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk5NjIzOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODE0MDA3OA==", "url": "https://github.com/keycloak/keycloak/pull/7569#discussion_r518140078", "bodyText": "I see. Missed the client-id based authentication for public clients.\nWe should be fine, yes, but your concern is still relevant. Something we can keep an eye on and improve later.", "author": "pedroigor", "createdAt": "2020-11-05T15:31:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzk5NjIzOA=="}], "type": "inlineReview"}, {"oid": "6ef25c5c5a02ed251945278eca64390510ffcb40", "url": "https://github.com/keycloak/keycloak/commit/6ef25c5c5a02ed251945278eca64390510ffcb40", "message": "KEYCLOAK-9551 KEYCLOAK-16159 Make refresh_token generation for client_credentials optional. Support for revocation of access tokens.\n\nCo-authored-by: mposolda <mposolda@gmail.com>", "committedDate": "2020-11-05T13:56:08Z", "type": "commit"}, {"oid": "6ef25c5c5a02ed251945278eca64390510ffcb40", "url": "https://github.com/keycloak/keycloak/commit/6ef25c5c5a02ed251945278eca64390510ffcb40", "message": "KEYCLOAK-9551 KEYCLOAK-16159 Make refresh_token generation for client_credentials optional. Support for revocation of access tokens.\n\nCo-authored-by: mposolda <mposolda@gmail.com>", "committedDate": "2020-11-05T13:56:08Z", "type": "forcePushed"}]}