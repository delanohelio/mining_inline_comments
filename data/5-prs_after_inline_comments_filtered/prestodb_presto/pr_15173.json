{"pr_number": 15173, "pr_title": "Implement Spilling Strategies", "pr_createdAt": "2020-09-15T15:47:27Z", "pr_url": "https://github.com/prestodb/presto/pull/15173", "timeline": [{"oid": "5347917c2dfe02e6f4cf3595a85f2a021fc4479f", "url": "https://github.com/prestodb/presto/commit/5347917c2dfe02e6f4cf3595a85f2a021fc4479f", "message": "Prototype spilling strategies for testing", "committedDate": "2020-09-15T15:53:01Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4MDczNg==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r489080736", "bodyText": "break line before this", "author": "highker", "createdAt": "2020-09-15T23:51:22Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/MemoryRevokingScheduler.java", "diffHunk": "@@ -48,11 +51,14 @@\n     private static final Logger log = Logger.get(MemoryRevokingScheduler.class);\n \n     private static final Ordering<SqlTask> ORDER_BY_CREATE_TIME = Ordering.natural().onResultOf(task -> task.getTaskInfo().getStats().getCreateTime());\n+    private static final Ordering<SqlTask> ORDER_BY_REVOCABLE_MEMORY = Ordering.natural().onResultOf(task -> task.getTaskInfo().getStats().getRevocableMemoryReservationInBytes());\n     private final List<MemoryPool> memoryPools;", "originalCommit": "5347917c2dfe02e6f4cf3595a85f2a021fc4479f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4MDk3OA==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r489080978", "bodyText": "OptionalLong as this might not be used if we choose other strategies.", "author": "highker", "createdAt": "2020-09-15T23:52:14Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/MemoryRevokingScheduler.java", "diffHunk": "@@ -48,11 +51,14 @@\n     private static final Logger log = Logger.get(MemoryRevokingScheduler.class);\n \n     private static final Ordering<SqlTask> ORDER_BY_CREATE_TIME = Ordering.natural().onResultOf(task -> task.getTaskInfo().getStats().getCreateTime());\n+    private static final Ordering<SqlTask> ORDER_BY_REVOCABLE_MEMORY = Ordering.natural().onResultOf(task -> task.getTaskInfo().getStats().getRevocableMemoryReservationInBytes());\n     private final List<MemoryPool> memoryPools;\n     private final Supplier<? extends Collection<SqlTask>> currentTasksSupplier;\n     private final ScheduledExecutorService taskManagementExecutor;\n     private final double memoryRevokingThreshold;\n     private final double memoryRevokingTarget;\n+    private final long maxRevocableMemoryPerTask;", "originalCommit": "5347917c2dfe02e6f4cf3595a85f2a021fc4479f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4MTAxOQ==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r489081019", "bodyText": "Both requireNonNull", "author": "highker", "createdAt": "2020-09-15T23:52:23Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/MemoryRevokingScheduler.java", "diffHunk": "@@ -82,13 +90,17 @@ public MemoryRevokingScheduler(\n             Supplier<? extends Collection<SqlTask>> currentTasksSupplier,\n             ScheduledExecutorService taskManagementExecutor,\n             double memoryRevokingThreshold,\n-            double memoryRevokingTarget)\n+            double memoryRevokingTarget,\n+            long maxRevocableMemoryPerTask,\n+            TaskSpillingStrategy taskSpillingStrategy)\n     {\n         this.memoryPools = ImmutableList.copyOf(requireNonNull(memoryPools, \"memoryPools is null\"));\n         this.currentTasksSupplier = requireNonNull(currentTasksSupplier, \"currentTasksSupplier is null\");\n         this.taskManagementExecutor = requireNonNull(taskManagementExecutor, \"taskManagementExecutor is null\");\n         this.memoryRevokingThreshold = checkFraction(memoryRevokingThreshold, \"memoryRevokingThreshold\");\n         this.memoryRevokingTarget = checkFraction(memoryRevokingTarget, \"memoryRevokingTarget\");\n+        this.maxRevocableMemoryPerTask = maxRevocableMemoryPerTask;\n+        this.spillingStrategy = taskSpillingStrategy;", "originalCommit": "5347917c2dfe02e6f4cf3595a85f2a021fc4479f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4MTkwNA==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r489081904", "bodyText": "ORDER_BY_CREATE_TIME, ORDER_BY_REVOCABLE_BYTES , PER_TASK_MEMORY_THRESHOLD\nAlso add javadoc or comments to each option.", "author": "highker", "createdAt": "2020-09-15T23:55:20Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/FeaturesConfig.java", "diffHunk": "@@ -222,6 +225,13 @@ public boolean isAdoptingMergedPreference()\n         }\n     }\n \n+    public enum TaskSpillingStrategy\n+    {\n+        SPILL_BY_CREATE_TIME,\n+        SPILL_BY_REVOCABLE_BYTES,\n+        SPILL_BY_TASK_MEMORY_THRESHOLD", "originalCommit": "5347917c2dfe02e6f4cf3595a85f2a021fc4479f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4NTQwNA==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r489085404", "bodyText": "We might need some unit/integration tests on this path", "author": "highker", "createdAt": "2020-09-16T00:07:03Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/MemoryRevokingScheduler.java", "diffHunk": "@@ -184,6 +218,45 @@ private void scheduleRevoking()\n         });\n     }\n \n+    private synchronized void revokeHighMemoryTasks()", "originalCommit": "5347917c2dfe02e6f4cf3595a85f2a021fc4479f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4NTY3NA==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r489085674", "bodyText": "We might need to think about renaming this or merging this with above to not confuse people with different spilling strategies.", "author": "highker", "createdAt": "2020-09-16T00:07:58Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/MemoryRevokingScheduler.java", "diffHunk": "@@ -184,6 +218,45 @@ private void scheduleRevoking()\n         });\n     }\n \n+    private synchronized void revokeHighMemoryTasks()\n+    {\n+        if (checkPending.getAndSet(false)) {\n+            Collection<SqlTask> sqlTasks = requireNonNull(currentTasksSupplier.get());\n+            for (SqlTask task : sqlTasks) {\n+                long currentTaskAllocation = task.getTaskInfo().getStats().getRevocableMemoryReservationInBytes();\n+\n+                if (currentTaskAllocation > maxRevocableMemoryPerTask) {\n+                    AtomicLong remainingBytesToRevokeAtomic = new AtomicLong(currentTaskAllocation - maxRevocableMemoryPerTask);\n+                    task.getQueryContext().accept(new VoidTraversingQueryContextVisitor<AtomicLong>()\n+                    {\n+                        @Override\n+                        public Void visitQueryContext(QueryContext queryContext, AtomicLong remainingBytesToRevoke)\n+                        {\n+                            if (remainingBytesToRevoke.get() < 0) {\n+                                // exit immediately if no work needs to be done\n+                                return null;\n+                            }\n+                            return super.visitQueryContext(queryContext, remainingBytesToRevoke);\n+                        }\n+\n+                        @Override\n+                        public Void visitOperatorContext(OperatorContext operatorContext, AtomicLong remainingBytesToRevoke)\n+                        {\n+                            if (remainingBytesToRevoke.get() > 0) {\n+                                long revokedBytes = operatorContext.requestMemoryRevoking();\n+                                if (revokedBytes > 0) {\n+                                    remainingBytesToRevoke.addAndGet(-revokedBytes);\n+                                    log.debug(\"taskId=%s: requested revoking %s; remaining %s\", task.getTaskInfo().getTaskId(), revokedBytes, remainingBytesToRevoke.get());\n+                                }\n+                            }\n+                            return null;\n+                        }\n+                    }, remainingBytesToRevokeAtomic);\n+                }\n+            }\n+        }\n+    }\n+\n     private synchronized void runMemoryRevoking()", "originalCommit": "5347917c2dfe02e6f4cf3595a85f2a021fc4479f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NDAyMTk4Mg==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r494021982", "bodyText": "Just moved this to another file to remove confusion about strategies entirely.", "author": "sachdevs", "createdAt": "2020-09-24T03:51:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4OTA4NTY3NA=="}], "type": "inlineReview"}, {"oid": "3d0be0088915633f1b3989227d961e58a1521224", "url": "https://github.com/prestodb/presto/commit/3d0be0088915633f1b3989227d961e58a1521224", "message": "Implement spilling strategies", "committedDate": "2020-09-24T03:51:33Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI3MzgxNw==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r495273817", "bodyText": "Sorry if it's a dumb question. I just realized memory revoking scheduler (and MemoryRevokingScheduler) doesn't implement any interface. Curious how are they get called? I assume it's related to the @PostConstruct and @PreDestroy annotation?", "author": "wenleix", "createdAt": "2020-09-25T22:12:36Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/TaskThresholdMemoryRevokingScheduler.java", "diffHunk": "@@ -0,0 +1,128 @@\n+package com.facebook.presto.execution;\n+\n+import com.facebook.airlift.log.Logger;\n+import com.facebook.presto.memory.QueryContext;\n+import com.facebook.presto.memory.VoidTraversingQueryContextVisitor;\n+import com.facebook.presto.operator.OperatorContext;\n+import com.facebook.presto.sql.analyzer.FeaturesConfig;\n+import com.google.common.annotations.VisibleForTesting;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+\n+import java.util.Collection;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public class TaskThresholdMemoryRevokingScheduler", "originalCommit": "3d0be0088915633f1b3989227d961e58a1521224", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjA3MjAwNQ==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r496072005", "bodyText": "Yup you got it. They run as a separate thread and are created at injection time. On creation (@PostConstruct), we register a periodically executing method to check if revoking is necessary (based on whichever spilling strategy we are using). As for which scheduler is created, that is determined in ServerMainModule, using installModuleIf. I was wondering too if it's worth having an interface but figured there wasn't enough reason to abstract it yet.", "author": "sachdevs", "createdAt": "2020-09-28T16:14:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI3MzgxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxNTg1Mg==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r496315852", "bodyText": "@sachdevs : I see. Is this a mechanism from Guice? (e.g. automatically call methods annotated with @PostConstruct)", "author": "wenleix", "createdAt": "2020-09-29T01:02:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI3MzgxNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg3ODM0Mw==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r496878343", "bodyText": "Javax annotation: https://docs.oracle.com/javaee/7/api/javax/annotation/PostConstruct.html.", "author": "sachdevs", "createdAt": "2020-09-29T16:30:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI3MzgxNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI3OTQ0Nw==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r495279447", "bodyText": "nit: consider use a switch? So you can throw UnsupportedOperationException for enum values not applicable.", "author": "wenleix", "createdAt": "2020-09-25T22:21:39Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/MemoryRevokingScheduler.java", "diffHunk": "@@ -244,10 +251,12 @@ public Long mergeResults(List<Long> childrenResults)\n     private void requestRevoking(MemoryPool memoryPool, Collection<SqlTask> sqlTasks, long remainingBytesToRevoke)\n     {\n         AtomicLong remainingBytesToRevokeAtomic = new AtomicLong(remainingBytesToRevoke);\n+        Ordering<SqlTask> sqlTaskOrdering = spillingStrategy == TaskSpillingStrategy.ORDER_BY_CREATE_TIME ? ORDER_BY_CREATE_TIME : ORDER_BY_REVOCABLE_MEMORY;", "originalCommit": "3d0be0088915633f1b3989227d961e58a1521224", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE2NzA0Mg==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r496167042", "bodyText": "I also added checkArgument in constructor to make sure this wont happen.", "author": "sachdevs", "createdAt": "2020-09-28T18:58:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTI3OTQ0Nw=="}], "type": "inlineReview"}, {"oid": "0b338429442481f5748b9561d6b41374d189b746", "url": "https://github.com/prestodb/presto/commit/0b338429442481f5748b9561d6b41374d189b746", "message": "Implement spilling strategies", "committedDate": "2020-09-28T18:12:28Z", "type": "forcePushed"}, {"oid": "46ed059c03bd9442fbafd57dd9edf5bb82cde515", "url": "https://github.com/prestodb/presto/commit/46ed059c03bd9442fbafd57dd9edf5bb82cde515", "message": "Implement spilling strategies", "committedDate": "2020-09-28T18:48:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3MjY5NQ==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r496172695", "bodyText": "Should we treat join and aggregation spill the same way? The cost of spilling them is not uniform.\nWith join if you spill it then the entire probe side has to be spilled incurring a 3x IO cost.\nWith aggregation if you spill it will have to merge in one more run, but it can continue to use memory to avoid creating more sorted runs.\nIn practice whether this distinction matters often???", "author": "aweisberg", "createdAt": "2020-09-28T19:09:25Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/FeaturesConfig.java", "diffHunk": "@@ -222,6 +225,13 @@ public boolean isAdoptingMergedPreference()\n         }\n     }\n \n+    public enum TaskSpillingStrategy\n+    {\n+        ORDER_BY_CREATE_TIME, // When spilling is triggered, revoke tasks in order of oldest to newest\n+        ORDER_BY_REVOCABLE_BYTES, // When spilling is triggered, revoke tasks by most allocated revocable memory to least allocated revocable memory", "originalCommit": "46ed059c03bd9442fbafd57dd9edf5bb82cde515", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE5MTI2Nw==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r496191267", "bodyText": "There are two levels of spilling strategy:\n\n\nPrioritizing which operator to spill within a given task.\nThis would be easy to add on top of the existing implementation. Modifying the VoidTraversingQueryContextVisitor to make a list of operators and then rank them by priority would accomplish this. This refers to how we choose to spill operators within a task. So far, these implementations do not try to distinguish between operators when choosing to spill which isn't ideal. I can look into adding this in as we see fit depending on how spilling works in production for our workload as we start rolling out soon.\n\n\nPrioritizing which task to spill in a list of currently running tasks.\nAs for distinguishing between revocable bytes allocated by join operator vs agg operator and using that to prioritize which tasks to spill, that would be a bit more work. Let's circle back on this if we see issues with this in during shadow.", "author": "sachdevs", "createdAt": "2020-09-28T19:45:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjE3MjY5NQ=="}], "type": "inlineReview"}, {"oid": "400f1fbd85811e04bfcad29e9372c7b77fbb68b0", "url": "https://github.com/prestodb/presto/commit/400f1fbd85811e04bfcad29e9372c7b77fbb68b0", "message": "Introduce TaskSpillingStrategy and multiple spilling strategies\nThis adds ordering tasks by revocable bytes and per task memory\nthreshold alongside ordering by create time.", "committedDate": "2020-09-28T19:15:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM2ODE5OA==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r496368198", "bodyText": "s/Mocked/Testing", "author": "highker", "createdAt": "2020-09-29T04:11:59Z", "path": "presto-main/src/test/java/com/facebook/presto/execution/TestMemoryRevokingScheduler.java", "diffHunk": "@@ -262,13 +398,76 @@ private OperatorContext createContexts(SqlTask sqlTask)\n         return operatorContext;\n     }\n \n+    private MockedOperatorContext createMockedContexts(SqlTask sqlTask, String operatorName)\n+    {\n+        // update task to update underlying taskHolderReference with taskExecution + create a new taskContext\n+        sqlTask.updateTask(TEST_SESSION,\n+                Optional.of(PLAN_FRAGMENT),\n+                ImmutableList.of(new TaskSource(TABLE_SCAN_NODE_ID, ImmutableSet.of(SPLIT), false)),\n+                createInitialEmptyOutputBuffers(PARTITIONED).withBuffer(OUT, 0).withNoMoreBufferIds(),\n+                Optional.of(new TableWriteInfo(Optional.empty(), Optional.empty(), Optional.empty())));\n+\n+        // use implicitly created task context from updateTask. It should be the only task in this QueryContext's tasks\n+        TaskContext taskContext = sqlTask.getQueryContext().getTaskContextByTaskId(sqlTask.getTaskId());\n+        PipelineContext pipelineContext = taskContext.addPipelineContext(0, false, false, false);\n+        DriverContext driverContext = pipelineContext.addDriverContext();\n+        MockedOperatorContext mockedOperatorContext = new MockedOperatorContext(\n+                1,\n+                new PlanNodeId(\"na\"),\n+                \"na\",\n+                driverContext,\n+                executor,\n+                driverContext.getDriverMemoryContext().newMemoryTrackingContext(),\n+                operatorName);\n+        driverContext.addOperatorContext(mockedOperatorContext);\n+        return mockedOperatorContext;\n+    }\n+\n+    private static class MockedOperatorContext", "originalCommit": "400f1fbd85811e04bfcad29e9372c7b77fbb68b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM2ODQwMQ==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r496368401", "bodyText": "createTestingOperatorContexts", "author": "highker", "createdAt": "2020-09-29T04:12:15Z", "path": "presto-main/src/test/java/com/facebook/presto/execution/TestMemoryRevokingScheduler.java", "diffHunk": "@@ -262,13 +398,76 @@ private OperatorContext createContexts(SqlTask sqlTask)\n         return operatorContext;\n     }\n \n+    private MockedOperatorContext createMockedContexts(SqlTask sqlTask, String operatorName)", "originalCommit": "400f1fbd85811e04bfcad29e9372c7b77fbb68b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM2OTMyOQ==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r496369329", "bodyText": "We probably need to fix TestFeaturesConfig", "author": "highker", "createdAt": "2020-09-29T04:13:39Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/FeaturesConfig.java", "diffHunk": "@@ -78,6 +79,8 @@\n     private int concurrentLifespansPerTask;\n     private boolean spatialJoinsEnabled = true;\n     private boolean fastInequalityJoins = true;\n+    private TaskSpillingStrategy taskSpillingStrategy = ORDER_BY_CREATE_TIME;\n+    private long maxRevocableMemoryPerTask = 500000L;", "originalCommit": "400f1fbd85811e04bfcad29e9372c7b77fbb68b0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM2OTc2NQ==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r496369765", "bodyText": "break a line after this.", "author": "highker", "createdAt": "2020-09-29T04:14:17Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/TaskThresholdMemoryRevokingScheduler.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution;\n+\n+import com.facebook.airlift.log.Logger;\n+import com.facebook.presto.memory.QueryContext;\n+import com.facebook.presto.memory.VoidTraversingQueryContextVisitor;\n+import com.facebook.presto.operator.OperatorContext;\n+import com.facebook.presto.sql.analyzer.FeaturesConfig;\n+import com.google.common.annotations.VisibleForTesting;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+\n+import java.util.Collection;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public class TaskThresholdMemoryRevokingScheduler\n+{\n+    private static final Logger log = Logger.get(MemoryRevokingScheduler.class);", "originalCommit": "400f1fbd85811e04bfcad29e9372c7b77fbb68b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4NzA0MQ==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r496887041", "bodyText": "We should probably add linter rules for things like this so reviewers don't have to notice this.", "author": "sachdevs", "createdAt": "2020-09-29T16:43:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM2OTc2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM3MjU5Mg==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r496372592", "bodyText": "I guess this variable is not thread-safe? Maybe have synchronized methods/blocks + \"GuardedBy(\"this\")\"", "author": "highker", "createdAt": "2020-09-29T04:18:15Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/TaskThresholdMemoryRevokingScheduler.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution;\n+\n+import com.facebook.airlift.log.Logger;\n+import com.facebook.presto.memory.QueryContext;\n+import com.facebook.presto.memory.VoidTraversingQueryContextVisitor;\n+import com.facebook.presto.operator.OperatorContext;\n+import com.facebook.presto.sql.analyzer.FeaturesConfig;\n+import com.google.common.annotations.VisibleForTesting;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+\n+import java.util.Collection;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public class TaskThresholdMemoryRevokingScheduler\n+{\n+    private static final Logger log = Logger.get(MemoryRevokingScheduler.class);\n+    private final Supplier<? extends Collection<SqlTask>> currentTasksSupplier;\n+    private final ScheduledExecutorService taskManagementExecutor;\n+    private final long maxRevocableMemoryPerTask;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture;", "originalCommit": "400f1fbd85811e04bfcad29e9372c7b77fbb68b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg0NjIwNw==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r496846207", "bodyText": "Looks like it's just copied from existing MemoryRevokingScheduler \ud83d\ude02", "author": "wenleix", "createdAt": "2020-09-29T15:57:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM3MjU5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkwMDkxNQ==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r496900915", "bodyText": "See comment on lines 95-98", "author": "sachdevs", "createdAt": "2020-09-29T17:05:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM3MjU5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM3NTMyMA==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r496375320", "bodyText": "This is not thread-safe", "author": "highker", "createdAt": "2020-09-29T04:21:57Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/TaskThresholdMemoryRevokingScheduler.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution;\n+\n+import com.facebook.airlift.log.Logger;\n+import com.facebook.presto.memory.QueryContext;\n+import com.facebook.presto.memory.VoidTraversingQueryContextVisitor;\n+import com.facebook.presto.operator.OperatorContext;\n+import com.facebook.presto.sql.analyzer.FeaturesConfig;\n+import com.google.common.annotations.VisibleForTesting;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+\n+import java.util.Collection;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public class TaskThresholdMemoryRevokingScheduler\n+{\n+    private static final Logger log = Logger.get(MemoryRevokingScheduler.class);\n+    private final Supplier<? extends Collection<SqlTask>> currentTasksSupplier;\n+    private final ScheduledExecutorService taskManagementExecutor;\n+    private final long maxRevocableMemoryPerTask;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture;\n+\n+    private final AtomicBoolean checkPending = new AtomicBoolean();\n+\n+    @Inject\n+    public TaskThresholdMemoryRevokingScheduler(\n+            SqlTaskManager sqlTaskManager,\n+            TaskManagementExecutor taskManagementExecutor,\n+            FeaturesConfig config)\n+    {\n+        this(\n+                requireNonNull(sqlTaskManager, \"sqlTaskManager cannot be null\")::getAllTasks,\n+                requireNonNull(taskManagementExecutor, \"taskManagementExecutor cannot be null\").getExecutor(),\n+                config.getMaxRevocableMemoryPerTask());\n+        log.debug(\"Using TaskThresholdMemoryRevokingScheduler spilling strategy\");\n+    }\n+\n+    @VisibleForTesting\n+    TaskThresholdMemoryRevokingScheduler(\n+            Supplier<? extends Collection<SqlTask>> currentTasksSupplier,\n+            ScheduledExecutorService taskManagementExecutor,\n+            long maxRevocableMemoryPerTask)\n+    {\n+        this.currentTasksSupplier = requireNonNull(currentTasksSupplier, \"currentTasksSupplier is null\");\n+        this.taskManagementExecutor = requireNonNull(taskManagementExecutor, \"taskManagementExecutor is null\");\n+        this.maxRevocableMemoryPerTask = maxRevocableMemoryPerTask;\n+    }\n+\n+    @PostConstruct\n+    public void start()\n+    {\n+        registerTaskMemoryPeriodicCheck();\n+    }\n+\n+    private void registerTaskMemoryPeriodicCheck()\n+    {\n+        this.scheduledFuture = taskManagementExecutor.scheduleWithFixedDelay(() -> {\n+            try {\n+                revokeHighMemoryTasksIfNeeded();\n+            }\n+            catch (Throwable e) {\n+                log.error(e, \"Error requesting task memory revoking\");\n+            }\n+        }, 1, 1, SECONDS);\n+    }\n+\n+    @PreDestroy\n+    public void stop()\n+    {\n+        if (scheduledFuture != null) {\n+            scheduledFuture.cancel(true);\n+            scheduledFuture = null;\n+        }", "originalCommit": "400f1fbd85811e04bfcad29e9372c7b77fbb68b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5ODM4NQ==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r496898385", "bodyText": "Since this class is injected as a SINGLETON + this part is only called on @PreDestroy, this method won't be called until this class is destroyed (We never call stop() manually). This won't happen until Presto shuts down? I can't imagine any other case in which we will destroy these schedulers. This method only exists to stop leaking this future for tests I'm guessing (since a similar method is also present in MemoryRevokingScheduler). Let me know if we still need thread safety for this variable because of this context.", "author": "sachdevs", "createdAt": "2020-09-29T17:01:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM3NTMyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM3NjM5OQ==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r496376399", "bodyText": "Why not just use Supplier<List<SqlTask>>?", "author": "highker", "createdAt": "2020-09-29T04:23:31Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/TaskThresholdMemoryRevokingScheduler.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution;\n+\n+import com.facebook.airlift.log.Logger;\n+import com.facebook.presto.memory.QueryContext;\n+import com.facebook.presto.memory.VoidTraversingQueryContextVisitor;\n+import com.facebook.presto.operator.OperatorContext;\n+import com.facebook.presto.sql.analyzer.FeaturesConfig;\n+import com.google.common.annotations.VisibleForTesting;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+\n+import java.util.Collection;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public class TaskThresholdMemoryRevokingScheduler\n+{\n+    private static final Logger log = Logger.get(MemoryRevokingScheduler.class);\n+    private final Supplier<? extends Collection<SqlTask>> currentTasksSupplier;", "originalCommit": "400f1fbd85811e04bfcad29e9372c7b77fbb68b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg0NjYwNg==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r496846606", "bodyText": "Because existing MemoryRevokingScheduler is using Supplier<? extends Collection<SqlTask>>? \ud83d\ude02", "author": "wenleix", "createdAt": "2020-09-29T15:58:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM3NjM5OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg5MDE0MQ==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r496890141", "bodyText": "I had done it in case tests would have non-list inputs like they do in MemoryRevokingScheduler but yeah, should just be a list, even in MemoryRevokingScheduler", "author": "sachdevs", "createdAt": "2020-09-29T16:48:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM3NjM5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM3NjgzMw==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r496376833", "bodyText": "if (currentTaskAllocation < maxRevocableMemoryPerTask) {\n    continue;\n}\n\n....", "author": "highker", "createdAt": "2020-09-29T04:24:09Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/TaskThresholdMemoryRevokingScheduler.java", "diffHunk": "@@ -0,0 +1,147 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution;\n+\n+import com.facebook.airlift.log.Logger;\n+import com.facebook.presto.memory.QueryContext;\n+import com.facebook.presto.memory.VoidTraversingQueryContextVisitor;\n+import com.facebook.presto.operator.OperatorContext;\n+import com.facebook.presto.sql.analyzer.FeaturesConfig;\n+import com.google.common.annotations.VisibleForTesting;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+\n+import java.util.Collection;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public class TaskThresholdMemoryRevokingScheduler\n+{\n+    private static final Logger log = Logger.get(MemoryRevokingScheduler.class);\n+    private final Supplier<? extends Collection<SqlTask>> currentTasksSupplier;\n+    private final ScheduledExecutorService taskManagementExecutor;\n+    private final long maxRevocableMemoryPerTask;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture;\n+\n+    private final AtomicBoolean checkPending = new AtomicBoolean();\n+\n+    @Inject\n+    public TaskThresholdMemoryRevokingScheduler(\n+            SqlTaskManager sqlTaskManager,\n+            TaskManagementExecutor taskManagementExecutor,\n+            FeaturesConfig config)\n+    {\n+        this(\n+                requireNonNull(sqlTaskManager, \"sqlTaskManager cannot be null\")::getAllTasks,\n+                requireNonNull(taskManagementExecutor, \"taskManagementExecutor cannot be null\").getExecutor(),\n+                config.getMaxRevocableMemoryPerTask());\n+        log.debug(\"Using TaskThresholdMemoryRevokingScheduler spilling strategy\");\n+    }\n+\n+    @VisibleForTesting\n+    TaskThresholdMemoryRevokingScheduler(\n+            Supplier<? extends Collection<SqlTask>> currentTasksSupplier,\n+            ScheduledExecutorService taskManagementExecutor,\n+            long maxRevocableMemoryPerTask)\n+    {\n+        this.currentTasksSupplier = requireNonNull(currentTasksSupplier, \"currentTasksSupplier is null\");\n+        this.taskManagementExecutor = requireNonNull(taskManagementExecutor, \"taskManagementExecutor is null\");\n+        this.maxRevocableMemoryPerTask = maxRevocableMemoryPerTask;\n+    }\n+\n+    @PostConstruct\n+    public void start()\n+    {\n+        registerTaskMemoryPeriodicCheck();\n+    }\n+\n+    private void registerTaskMemoryPeriodicCheck()\n+    {\n+        this.scheduledFuture = taskManagementExecutor.scheduleWithFixedDelay(() -> {\n+            try {\n+                revokeHighMemoryTasksIfNeeded();\n+            }\n+            catch (Throwable e) {\n+                log.error(e, \"Error requesting task memory revoking\");\n+            }\n+        }, 1, 1, SECONDS);\n+    }\n+\n+    @PreDestroy\n+    public void stop()\n+    {\n+        if (scheduledFuture != null) {\n+            scheduledFuture.cancel(true);\n+            scheduledFuture = null;\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    public void revokeHighMemoryTasksIfNeeded()\n+    {\n+        if (checkPending.compareAndSet(false, true)) {\n+            revokeHighMemoryTasks();\n+        }\n+    }\n+\n+    private synchronized void revokeHighMemoryTasks()\n+    {\n+        if (checkPending.getAndSet(false)) {\n+            Collection<SqlTask> sqlTasks = requireNonNull(currentTasksSupplier.get());\n+            for (SqlTask task : sqlTasks) {\n+                long currentTaskAllocation = task.getTaskInfo().getStats().getRevocableMemoryReservationInBytes();\n+\n+                if (currentTaskAllocation > maxRevocableMemoryPerTask) {", "originalCommit": "400f1fbd85811e04bfcad29e9372c7b77fbb68b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Njg4NTkyNg==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r496885926", "bodyText": "Oops :)", "author": "sachdevs", "createdAt": "2020-09-29T16:41:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM3NjgzMw=="}], "type": "inlineReview"}, {"oid": "c56cc077543868cc09331d9ebb8fac38d43b3065", "url": "https://github.com/prestodb/presto/commit/c56cc077543868cc09331d9ebb8fac38d43b3065", "message": "Introduce TaskSpillingStrategy and multiple spilling strategies\nThis adds ordering tasks by revocable bytes and per task memory\nthreshold alongside ordering by create time.", "committedDate": "2020-09-29T17:03:00Z", "type": "forcePushed"}, {"oid": "43a9b80f218c2f33e71a466303ad196a9cf1c28c", "url": "https://github.com/prestodb/presto/commit/43a9b80f218c2f33e71a466303ad196a9cf1c28c", "message": "Introduce TaskSpillingStrategy and multiple spilling strategies\nThis adds ordering tasks by revocable bytes and per task memory\nthreshold alongside ordering by create time.", "committedDate": "2020-09-29T17:09:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM4MTI3MQ==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r496381271", "bodyText": "nit: why not just use sqlTaskOrdering here?", "author": "wenleix", "createdAt": "2020-09-29T04:30:28Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/MemoryRevokingScheduler.java", "diffHunk": "@@ -244,10 +253,25 @@ public Long mergeResults(List<Long> childrenResults)\n     private void requestRevoking(MemoryPool memoryPool, Collection<SqlTask> sqlTasks, long remainingBytesToRevoke)\n     {\n         AtomicLong remainingBytesToRevokeAtomic = new AtomicLong(remainingBytesToRevoke);\n+\n+        Ordering<SqlTask> sqlTaskOrdering;\n+        switch (spillingStrategy) {\n+            case ORDER_BY_CREATE_TIME:\n+                sqlTaskOrdering = ORDER_BY_CREATE_TIME;\n+                break;\n+            case ORDER_BY_REVOCABLE_BYTES:\n+                sqlTaskOrdering = ORDER_BY_REVOCABLE_MEMORY;\n+                break;\n+            case PER_TASK_MEMORY_THRESHOLD:\n+            default:\n+                throw new UnsupportedOperationException(\"Unexpected spilling strategy in MemoryRevokingScheduler\");\n+        }\n+        log.debug(\"Ordering by %s\", spillingStrategy == TaskSpillingStrategy.ORDER_BY_CREATE_TIME ? ORDER_BY_CREATE_TIME : ORDER_BY_REVOCABLE_MEMORY);", "originalCommit": "400f1fbd85811e04bfcad29e9372c7b77fbb68b0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkyOTc2OQ==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r496929769", "bodyText": "Should be spillingStrategy alone oops \ud83e\udd26", "author": "sachdevs", "createdAt": "2020-09-29T17:52:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjM4MTI3MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjkxMzI5NQ==", "url": "https://github.com/prestodb/presto/pull/15173#discussion_r496913295", "bodyText": "nti: currentRevocableMemory?", "author": "wenleix", "createdAt": "2020-09-29T17:26:05Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/TaskThresholdMemoryRevokingScheduler.java", "diffHunk": "@@ -0,0 +1,150 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution;\n+\n+import com.facebook.airlift.log.Logger;\n+import com.facebook.presto.memory.QueryContext;\n+import com.facebook.presto.memory.VoidTraversingQueryContextVisitor;\n+import com.facebook.presto.operator.OperatorContext;\n+import com.facebook.presto.sql.analyzer.FeaturesConfig;\n+import com.google.common.annotations.VisibleForTesting;\n+\n+import javax.annotation.Nullable;\n+import javax.annotation.PostConstruct;\n+import javax.annotation.PreDestroy;\n+import javax.inject.Inject;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.ScheduledFuture;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicLong;\n+import java.util.function.Supplier;\n+\n+import static java.util.Objects.requireNonNull;\n+import static java.util.concurrent.TimeUnit.SECONDS;\n+\n+public class TaskThresholdMemoryRevokingScheduler\n+{\n+    private static final Logger log = Logger.get(TaskThresholdMemoryRevokingScheduler.class);\n+\n+    private final Supplier<List<SqlTask>> currentTasksSupplier;\n+    private final ScheduledExecutorService taskManagementExecutor;\n+    private final long maxRevocableMemoryPerTask;\n+\n+    @Nullable\n+    private ScheduledFuture<?> scheduledFuture;\n+\n+    private final AtomicBoolean checkPending = new AtomicBoolean();\n+\n+    @Inject\n+    public TaskThresholdMemoryRevokingScheduler(\n+            SqlTaskManager sqlTaskManager,\n+            TaskManagementExecutor taskManagementExecutor,\n+            FeaturesConfig config)\n+    {\n+        this(\n+                requireNonNull(sqlTaskManager, \"sqlTaskManager cannot be null\")::getAllTasks,\n+                requireNonNull(taskManagementExecutor, \"taskManagementExecutor cannot be null\").getExecutor(),\n+                config.getMaxRevocableMemoryPerTask());\n+        log.debug(\"Using TaskThresholdMemoryRevokingScheduler spilling strategy\");\n+    }\n+\n+    @VisibleForTesting\n+    TaskThresholdMemoryRevokingScheduler(\n+            Supplier<List<SqlTask>> currentTasksSupplier,\n+            ScheduledExecutorService taskManagementExecutor,\n+            long maxRevocableMemoryPerTask)\n+    {\n+        this.currentTasksSupplier = requireNonNull(currentTasksSupplier, \"currentTasksSupplier is null\");\n+        this.taskManagementExecutor = requireNonNull(taskManagementExecutor, \"taskManagementExecutor is null\");\n+        this.maxRevocableMemoryPerTask = maxRevocableMemoryPerTask;\n+    }\n+\n+    @PostConstruct\n+    public void start()\n+    {\n+        registerTaskMemoryPeriodicCheck();\n+    }\n+\n+    private void registerTaskMemoryPeriodicCheck()\n+    {\n+        this.scheduledFuture = taskManagementExecutor.scheduleWithFixedDelay(() -> {\n+            try {\n+                revokeHighMemoryTasksIfNeeded();\n+            }\n+            catch (Throwable e) {\n+                log.error(e, \"Error requesting task memory revoking\");\n+            }\n+        }, 1, 1, SECONDS);\n+    }\n+\n+    @PreDestroy\n+    public void stop()\n+    {\n+        if (scheduledFuture != null) {\n+            scheduledFuture.cancel(true);\n+            scheduledFuture = null;\n+        }\n+    }\n+\n+    @VisibleForTesting\n+    void revokeHighMemoryTasksIfNeeded()\n+    {\n+        if (checkPending.compareAndSet(false, true)) {\n+            revokeHighMemoryTasks();\n+        }\n+    }\n+\n+    private synchronized void revokeHighMemoryTasks()\n+    {\n+        if (checkPending.getAndSet(false)) {\n+            Collection<SqlTask> sqlTasks = requireNonNull(currentTasksSupplier.get());\n+            for (SqlTask task : sqlTasks) {\n+                long currentTaskAllocation = task.getTaskInfo().getStats().getRevocableMemoryReservationInBytes();", "originalCommit": "43a9b80f218c2f33e71a466303ad196a9cf1c28c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d6e2c5be9ba3bb0eac66e3a153574e1adfb47e1d", "url": "https://github.com/prestodb/presto/commit/d6e2c5be9ba3bb0eac66e3a153574e1adfb47e1d", "message": "Introduce TaskSpillingStrategy and multiple spilling strategies\nThis adds ordering tasks by revocable bytes and per task memory\nthreshold alongside ordering by create time.", "committedDate": "2020-09-29T17:54:39Z", "type": "forcePushed"}, {"oid": "4be43f5793275a763a5e6f4775609f175e9c1d78", "url": "https://github.com/prestodb/presto/commit/4be43f5793275a763a5e6f4775609f175e9c1d78", "message": "Introduce TaskSpillingStrategy and multiple spilling strategies\nThis adds ordering tasks by revocable bytes and per task memory\nthreshold alongside ordering by create time.", "committedDate": "2020-09-29T19:07:08Z", "type": "forcePushed"}, {"oid": "5bf9207af6b6890599dfe115ab9fccd2921dd633", "url": "https://github.com/prestodb/presto/commit/5bf9207af6b6890599dfe115ab9fccd2921dd633", "message": "Introduce TaskSpillingStrategy and multiple spilling strategies\nThis adds ordering tasks by revocable bytes and per task memory\nthreshold alongside ordering by create time.", "committedDate": "2020-09-29T21:39:30Z", "type": "commit"}, {"oid": "5bf9207af6b6890599dfe115ab9fccd2921dd633", "url": "https://github.com/prestodb/presto/commit/5bf9207af6b6890599dfe115ab9fccd2921dd633", "message": "Introduce TaskSpillingStrategy and multiple spilling strategies\nThis adds ordering tasks by revocable bytes and per task memory\nthreshold alongside ordering by create time.", "committedDate": "2020-09-29T21:39:30Z", "type": "forcePushed"}]}