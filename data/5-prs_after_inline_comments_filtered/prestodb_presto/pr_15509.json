{"pr_number": 15509, "pr_title": "More lock contention reductions", "pr_createdAt": "2020-12-08T17:53:02Z", "pr_url": "https://github.com/prestodb/presto/pull/15509", "timeline": [{"oid": "f8c71709b2a9ed6237b971e948c29abfaf12f3a0", "url": "https://github.com/prestodb/presto/commit/f8c71709b2a9ed6237b971e948c29abfaf12f3a0", "message": "Reduce synchronization in LocalExchangeMemoryManager", "committedDate": "2020-12-08T23:32:58Z", "type": "forcePushed"}, {"oid": "d4182bb3a21227a064a2cff596cc796d778c8ec4", "url": "https://github.com/prestodb/presto/commit/d4182bb3a21227a064a2cff596cc796d778c8ec4", "message": "Reduce synchronization in LocalExchangeMemoryManager", "committedDate": "2020-12-09T13:39:18Z", "type": "forcePushed"}, {"oid": "3dca8fd7d5bbf0941cf151113038d849ec505e80", "url": "https://github.com/prestodb/presto/commit/3dca8fd7d5bbf0941cf151113038d849ec505e80", "message": "Reduce synchronization in LocalExchangeMemoryManager", "committedDate": "2020-12-09T15:26:42Z", "type": "forcePushed"}, {"oid": "58a339c3365f9e430590235ffa11496e548981e4", "url": "https://github.com/prestodb/presto/commit/58a339c3365f9e430590235ffa11496e548981e4", "message": "Reduce synchronization in LocalExchangeMemoryManager", "committedDate": "2020-12-09T17:19:49Z", "type": "forcePushed"}, {"oid": "fb474a90ff6eb63c16f54e8050a87ead2fe56dd6", "url": "https://github.com/prestodb/presto/commit/fb474a90ff6eb63c16f54e8050a87ead2fe56dd6", "message": "Improve LocalExchangeSource locking behaviors\n\nAdds an unsynchronized fast path to LocalExchangeSource#waitForReading()\nand removes usages of LinkedBlockingQueue#isEmpty() which is implemented\nas LinkedBlockingQueue#size() == 0 under the hood. Also removes an\nunnecessary \"lock\" object which was obscuring this particular contention\npoint in profiling originally.", "committedDate": "2020-12-09T20:14:10Z", "type": "forcePushed"}, {"oid": "eccc257857050f3710a243db102fb48305fad889", "url": "https://github.com/prestodb/presto/commit/eccc257857050f3710a243db102fb48305fad889", "message": "Improve LocalExchangeSource locking behaviors\n\nAdds an unsynchronized fast path to LocalExchangeSource#waitForReading()\nand removes usages of LinkedBlockingQueue#isEmpty() which is implemented\nas LinkedBlockingQueue#size() == 0 under the hood. Also removes an\nunnecessary \"lock\" object which was obscuring this particular contention\npoint in profiling originally.", "committedDate": "2020-12-11T15:06:19Z", "type": "forcePushed"}, {"oid": "6b490fb9c9840b235d4ccb177ca7d91898eaae63", "url": "https://github.com/prestodb/presto/commit/6b490fb9c9840b235d4ccb177ca7d91898eaae63", "message": "Improve LocalExchangeSource locking behaviors\n\nAdds an unsynchronized fast path to LocalExchangeSource#waitForReading()\nand removes usages of LinkedBlockingQueue#isEmpty() which is implemented\nas LinkedBlockingQueue#size() == 0 under the hood. Also removes an\nunnecessary \"lock\" object which was obscuring this particular contention\npoint in profiling originally.", "committedDate": "2020-12-11T15:19:58Z", "type": "forcePushed"}, {"oid": "ada05e5a6ca7113a8907ad17013c990fdcaa3801", "url": "https://github.com/prestodb/presto/commit/ada05e5a6ca7113a8907ad17013c990fdcaa3801", "message": "Remove synchronized for final field read in MemoryPool#getMaxBytes()", "committedDate": "2020-12-14T18:37:28Z", "type": "forcePushed"}, {"oid": "5dc1615a2c8b1cfd7fe9780faa4f51d66d42d36e", "url": "https://github.com/prestodb/presto/commit/5dc1615a2c8b1cfd7fe9780faa4f51d66d42d36e", "message": "Remove synchronized for final field read in MemoryPool#getMaxBytes()", "committedDate": "2020-12-16T17:47:49Z", "type": "forcePushed"}, {"oid": "90a4bd9134ccf06420b00eeff224481546da37fc", "url": "https://github.com/prestodb/presto/commit/90a4bd9134ccf06420b00eeff224481546da37fc", "message": "Remove synchronized for final field read in MemoryPool#getMaxBytes()", "committedDate": "2020-12-16T18:00:52Z", "type": "forcePushed"}, {"oid": "1b1b79a7b9e8774f84b6115ab3ad045769b459f1", "url": "https://github.com/prestodb/presto/commit/1b1b79a7b9e8774f84b6115ab3ad045769b459f1", "message": "Remove synchronized for final field read in MemoryPool#getMaxBytes()", "committedDate": "2020-12-16T18:05:18Z", "type": "forcePushed"}, {"oid": "d1b44fea810e0feadce1ac6aad9e53d85cf52b02", "url": "https://github.com/prestodb/presto/commit/d1b44fea810e0feadce1ac6aad9e53d85cf52b02", "message": "Remove synchronized for final field read in MemoryPool#getMaxBytes()", "committedDate": "2020-12-16T19:23:51Z", "type": "forcePushed"}, {"oid": "37dcb74aaa7e8b3467fcccea79df2542072a6316", "url": "https://github.com/prestodb/presto/commit/37dcb74aaa7e8b3467fcccea79df2542072a6316", "message": "Remove synchronized for final field read in MemoryPool#getMaxBytes()", "committedDate": "2020-12-21T16:05:46Z", "type": "forcePushed"}, {"oid": "32a80b3448cf5e729dbb4846301c85041639d88f", "url": "https://github.com/prestodb/presto/commit/32a80b3448cf5e729dbb4846301c85041639d88f", "message": "Remove synchronized for final field read in MemoryPool#getMaxBytes()", "committedDate": "2020-12-22T16:32:02Z", "type": "forcePushed"}, {"oid": "f13bd48f9860d4f7d22af4effe044345c8961759", "url": "https://github.com/prestodb/presto/commit/f13bd48f9860d4f7d22af4effe044345c8961759", "message": "Remove synchronized for final field read in MemoryPool#getMaxBytes()", "committedDate": "2021-01-05T19:11:59Z", "type": "forcePushed"}, {"oid": "8f752c536ca85634df2eec5f6b2ad8dedac67601", "url": "https://github.com/prestodb/presto/commit/8f752c536ca85634df2eec5f6b2ad8dedac67601", "message": "Remove synchronized for final field read in MemoryPool#getMaxBytes()", "committedDate": "2021-01-06T16:02:29Z", "type": "forcePushed"}, {"oid": "48b0a366d11de4c7ea08a68e152ad44ff6f6dd00", "url": "https://github.com/prestodb/presto/commit/48b0a366d11de4c7ea08a68e152ad44ff6f6dd00", "message": "Remove synchronized for final field read in MemoryPool#getMaxBytes()", "committedDate": "2021-01-06T16:21:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2Mzk5NQ==", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r551463995", "bodyText": "Wondering why this isn't volatile? Are multi-field objects a case where unsafe publishing is a good idea?\nWith primitives, yeah I get it's just about physically impossible for the value to not eventually propagate and propagate atomically because it's word sized, but that isn't the case for references to objects as the stores for their contents can be out of order with publishing the reference.", "author": "aweisberg", "createdAt": "2021-01-04T17:38:17Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/ExchangeOperator.java", "diffHunk": "@@ -92,6 +92,7 @@ public void noMoreOperators()\n     private final PlanNodeId sourceId;\n     private final ExchangeClient exchangeClient;\n     private final PagesSerde serde;\n+    private ListenableFuture<?> isBlocked = NOT_BLOCKED;", "originalCommit": "9fe7d4e3ecba9b779721c24b75e57322a9996adc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk0NzMyNw==", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r552947327", "bodyText": "All accesses of this field (and operators in general) is done while holding the driver lock in a single threaded manner, so unsafe publication shouldn't be a concern. Even if that weren't true, the only risk would be somehow seeing null in this field because all of the ListenableFuture<?> instances returned here are amenable to being called multiple times- just at the cost of synchronizing into a critical section.", "author": "pettyjamesm", "createdAt": "2021-01-06T20:31:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2Mzk5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2MTc0OQ==", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r552961749", "bodyText": "I don't think there is a guarantee that the ListenableFuture implementation is constructed in such a way that after the constructor completes the fields are visible? I did look at all the callers and yeah it looks like it is all from the driver loop I just didn't have as high a confidence as you that I wasn't missing something.\nLGTM", "author": "aweisberg", "createdAt": "2021-01-06T21:07:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2Mzk5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2NTI0NQ==", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r551465245", "bodyText": "Do you need to check this at all before calculating the size? Since it is checked in the synchronized block anyways?\nClosed and failed are rare events.", "author": "aweisberg", "createdAt": "2021-01-04T17:40:48Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/ExchangeClient.java", "diffHunk": "@@ -404,50 +404,66 @@ public synchronized void scheduleRequestIfNecessary()\n         }\n     }\n \n-    public synchronized ListenableFuture<?> isBlocked()\n+    public ListenableFuture<?> isBlocked()\n     {\n+        //  Fast path return without synchronizing\n         if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n             return Futures.immediateFuture(true);\n         }\n-        SettableFuture<?> future = SettableFuture.create();\n-        blockedCallers.add(future);\n-        return future;\n+        synchronized (this) {\n+            //  Re-check after synchronizing\n+            if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n+                return Futures.immediateFuture(true);\n+            }\n+            SettableFuture<?> future = SettableFuture.create();\n+            blockedCallers.add(future);\n+            return future;\n+        }\n     }\n \n-    private synchronized boolean addPages(List<SerializedPage> pages)\n+    private boolean addPages(List<SerializedPage> pages)\n     {\n+        //  Fast path return\n         if (isClosed() || isFailed()) {", "originalCommit": "bbfe576cb6cd0229361aa59a4855ecfff18e3eef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk1MjAwNQ==", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r552952005", "bodyText": "Fair point, I'll remove the pre-checks.", "author": "pettyjamesm", "createdAt": "2021-01-06T20:43:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2NTI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2NjkyOA==", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r551466928", "bodyText": "Notify blocked callers also synchronizes on this so now it has to re-acquire the lock?", "author": "aweisberg", "createdAt": "2021-01-04T17:44:15Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/ExchangeClient.java", "diffHunk": "@@ -404,50 +404,66 @@ public synchronized void scheduleRequestIfNecessary()\n         }\n     }\n \n-    public synchronized ListenableFuture<?> isBlocked()\n+    public ListenableFuture<?> isBlocked()\n     {\n+        //  Fast path return without synchronizing\n         if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n             return Futures.immediateFuture(true);\n         }\n-        SettableFuture<?> future = SettableFuture.create();\n-        blockedCallers.add(future);\n-        return future;\n+        synchronized (this) {\n+            //  Re-check after synchronizing\n+            if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n+                return Futures.immediateFuture(true);\n+            }\n+            SettableFuture<?> future = SettableFuture.create();\n+            blockedCallers.add(future);\n+            return future;\n+        }\n     }\n \n-    private synchronized boolean addPages(List<SerializedPage> pages)\n+    private boolean addPages(List<SerializedPage> pages)\n     {\n+        //  Fast path return\n         if (isClosed() || isFailed()) {\n             return false;\n         }\n \n-        pageBuffer.addAll(pages);\n+        //  Compute stats before acquiring the lock\n+        long pagesRetainedSizeInBytes = 0;\n+        long responseSize = 0;\n+        for (SerializedPage page : pages) {\n+            pagesRetainedSizeInBytes += page.getRetainedSizeInBytes();\n+            responseSize += page.getSizeInBytes();\n+        }\n+\n+        synchronized (this) {\n+            //  Re-check after lock is acquired\n+            if (isClosed() || isFailed()) {\n+                return false;\n+            }\n+\n+            pageBuffer.addAll(pages);\n \n+            bufferRetainedSizeInBytes += pagesRetainedSizeInBytes;\n+            maxBufferRetainedSizeInBytes = max(maxBufferRetainedSizeInBytes, bufferRetainedSizeInBytes);\n+            successfulRequests++;\n+            responseSizeExponentialMovingAverage.update(responseSize);\n+            systemMemoryContext.setBytes(bufferRetainedSizeInBytes);\n+        }\n         if (!pages.isEmpty()) {\n             // notify all blocked callers\n             notifyBlockedCallers();", "originalCommit": "bbfe576cb6cd0229361aa59a4855ecfff18e3eef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk1MTkxMw==", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r552951913", "bodyText": "Indeed it does, I think the best route here is going to be to clear the blocked callers list while holding the lock and notifying them after releasing it.", "author": "pettyjamesm", "createdAt": "2021-01-06T20:43:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2NjkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2MzEwNg==", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r552963106", "bodyText": "In the common case pages will not be empty since one was just added so there is no reason to release the lock before acquiring the list of callers?\nHow common will it be that the list of blocked callers is non-empty? I imagine it depends a lot on the query and whether the producer or the consumer is faster.", "author": "aweisberg", "createdAt": "2021-01-06T21:11:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2NjkyOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2NjY2MA==", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r552966660", "bodyText": "In the common case pages will not be empty since one was just added so there is no reason to release the lock before acquiring the list of callers?\n\nYou're correct. Originally I restructured it this way to avoid holding the lock for the duration of the notifications being enqueued to the background executor (ScheduledThreadPoolExecutorService have a priority queue as their run queue even for non-scheduled runnables, so enqueues are more expensive than you might expect). I've updated the commit to just duplicate a little snippet of the notifyBlockedCallers() method with the synchronization in the right place.\n\nHow common will it be that the list of blocked callers is non-empty? I imagine it depends a lot on the query and whether the producer or the consumer is faster.\n\nIt should depend on the relative pace of consumers + producers, but I think it's probably very common for the exchange network throughput is slower than whatever consumes from the other side of the exchange. As an aside, before the operator ListenableFuture<?> isBlocked caching change each driver would enqueue at least 3 separate listeners because of the way that the Driver loop discards the future on the first pass.", "author": "pettyjamesm", "createdAt": "2021-01-06T21:20:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2NjkyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2OTc3Ng==", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r551469776", "bodyText": "This is a bit different now in that there can be several threads attempting to notify blocked callers in different orders with different sets of blocked callers. Is that OK? Really hard to reason about without knowing how tolerant blocked callers are of being woken up in different orders.\nSeems like they want to pull data so it is fine for them to come up empty?", "author": "aweisberg", "createdAt": "2021-01-04T17:49:36Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/ExchangeClient.java", "diffHunk": "@@ -404,50 +404,66 @@ public synchronized void scheduleRequestIfNecessary()\n         }\n     }\n \n-    public synchronized ListenableFuture<?> isBlocked()\n+    public ListenableFuture<?> isBlocked()\n     {\n+        //  Fast path return without synchronizing\n         if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n             return Futures.immediateFuture(true);\n         }\n-        SettableFuture<?> future = SettableFuture.create();\n-        blockedCallers.add(future);\n-        return future;\n+        synchronized (this) {\n+            //  Re-check after synchronizing\n+            if (isClosed() || isFailed() || pageBuffer.peek() != null) {\n+                return Futures.immediateFuture(true);\n+            }\n+            SettableFuture<?> future = SettableFuture.create();\n+            blockedCallers.add(future);\n+            return future;\n+        }\n     }\n \n-    private synchronized boolean addPages(List<SerializedPage> pages)\n+    private boolean addPages(List<SerializedPage> pages)\n     {\n+        //  Fast path return\n         if (isClosed() || isFailed()) {\n             return false;\n         }\n \n-        pageBuffer.addAll(pages);\n+        //  Compute stats before acquiring the lock\n+        long pagesRetainedSizeInBytes = 0;\n+        long responseSize = 0;\n+        for (SerializedPage page : pages) {\n+            pagesRetainedSizeInBytes += page.getRetainedSizeInBytes();\n+            responseSize += page.getSizeInBytes();\n+        }\n+\n+        synchronized (this) {\n+            //  Re-check after lock is acquired\n+            if (isClosed() || isFailed()) {\n+                return false;\n+            }\n+\n+            pageBuffer.addAll(pages);\n \n+            bufferRetainedSizeInBytes += pagesRetainedSizeInBytes;\n+            maxBufferRetainedSizeInBytes = max(maxBufferRetainedSizeInBytes, bufferRetainedSizeInBytes);\n+            successfulRequests++;\n+            responseSizeExponentialMovingAverage.update(responseSize);\n+            systemMemoryContext.setBytes(bufferRetainedSizeInBytes);\n+        }\n         if (!pages.isEmpty()) {\n             // notify all blocked callers\n             notifyBlockedCallers();\n         }\n-\n-        long pagesRetainedSizeInBytes = pages.stream()\n-                .mapToLong(SerializedPage::getRetainedSizeInBytes)\n-                .sum();\n-\n-        bufferRetainedSizeInBytes += pagesRetainedSizeInBytes;\n-        maxBufferRetainedSizeInBytes = max(maxBufferRetainedSizeInBytes, bufferRetainedSizeInBytes);\n-        systemMemoryContext.setBytes(bufferRetainedSizeInBytes);\n-        successfulRequests++;\n-\n-        long responseSize = pages.stream()\n-                .mapToLong(SerializedPage::getSizeInBytes)\n-                .sum();\n-        responseSizeExponentialMovingAverage.update(responseSize);\n-\n         return true;\n     }\n \n-    private synchronized void notifyBlockedCallers()\n+    private void notifyBlockedCallers()\n     {\n-        List<SettableFuture<?>> callers = ImmutableList.copyOf(blockedCallers);\n-        blockedCallers.clear();\n+        List<SettableFuture<?>> callers;", "originalCommit": "bbfe576cb6cd0229361aa59a4855ecfff18e3eef", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk1Njg2MQ==", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r552956861", "bodyText": "Yep, even adding a single page to the buffer immediately wakes up any and all waiters so they have to be tolerant to that possibility- still, not a desirable thing to do but addressing that is non-trivial complexity wise.", "author": "pettyjamesm", "createdAt": "2021-01-06T20:55:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ2OTc3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3NDY2Mw==", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r551474663", "bodyText": "This change doesn't look very controversial, LGTM.", "author": "aweisberg", "createdAt": "2021-01-04T17:58:46Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/exchange/BroadcastExchanger.java", "diffHunk": "@@ -19,6 +19,7 @@\n ", "originalCommit": "1bd7bd4a5d6a1485b6d312701bf025fe5cd9bd69", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU1OTk4NQ==", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r551559985", "bodyText": "This change seems not very controversial to me.", "author": "aweisberg", "createdAt": "2021-01-04T20:47:49Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/exchange/LocalExchangeMemoryManager.java", "diffHunk": "@@ -16,28 +16,26 @@\n import com.google.common.util.concurrent.ListenableFuture;", "originalCommit": "22f80c425c2192cf76fbb6cfdf892e69d2870b3c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU2MzMzOQ==", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r551563339", "bodyText": "In some ways this feels a bit copy-pasta heavy. Not sure if it is better/worse to try and shoe-horn things into the base class.", "author": "aweisberg", "createdAt": "2021-01-04T20:55:02Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/ExchangeOperator.java", "diffHunk": "@@ -92,6 +92,7 @@ public void noMoreOperators()\n     private final PlanNodeId sourceId;", "originalCommit": "9fe7d4e3ecba9b779721c24b75e57322a9996adc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk2MTU4NQ==", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r552961585", "bodyText": "I think probably worse. I'm not sure how one would accomodate the slight variations in the behaviors of where the isBlocked trigger comes from without cluttering the Operator interface.", "author": "pettyjamesm", "createdAt": "2021-01-06T21:07:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTU2MzMzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg4MTkzMQ==", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r552881931", "bodyText": "Not controversial either. But do the changes around managing the future have an impact? You are removing some volatile reads yes, but you are also adding conditional logic under the lock.", "author": "aweisberg", "createdAt": "2021-01-06T18:18:13Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/exchange/LocalExchangeSource.java", "diffHunk": "@@ -19,6 +19,7 @@\n import com.google.common.util.concurrent.ListenableFuture;", "originalCommit": "2ea85926d19184c3cc023bb75ceccc886a3a8e36", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjk1ODk5Mg==", "url": "https://github.com/prestodb/presto/pull/15509#discussion_r552958992", "bodyText": "True, but this will be a \"shallow check\" in that we're just comparing the reference value and not accessing the target of the reference. As such, one would expect this to amount to a very-local CPU cache entry because we've already taken ownership of the object monitor.\nUltimately it's not obvious whether to unconditionally save and clear the listener without branching is better here. It could well be that the CPU wouldn't issue a store operation if the value was null and null was being set.", "author": "pettyjamesm", "createdAt": "2021-01-06T21:00:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1Mjg4MTkzMQ=="}], "type": "inlineReview"}, {"oid": "7b537aea72485f9fef74319f252259417fe7656f", "url": "https://github.com/prestodb/presto/commit/7b537aea72485f9fef74319f252259417fe7656f", "message": "Remove synchronized for final field read in MemoryPool#getMaxBytes()", "committedDate": "2021-01-06T20:53:00Z", "type": "forcePushed"}, {"oid": "5027cdb12ca0d3f6e9603dd029e6faf871925744", "url": "https://github.com/prestodb/presto/commit/5027cdb12ca0d3f6e9603dd029e6faf871925744", "message": "Remove synchronized for final field read in MemoryPool#getMaxBytes()", "committedDate": "2021-01-06T21:03:10Z", "type": "forcePushed"}, {"oid": "ebbda4670de2b7d9a2e83abaac13f68329ee086a", "url": "https://github.com/prestodb/presto/commit/ebbda4670de2b7d9a2e83abaac13f68329ee086a", "message": "Cache isBlocked future in various operator implementations\n\nAvoids re-checking the same isBlocked condition when the operator\nblocks which reduces contention for locks and registering duplicate\nisBlocked callback events.", "committedDate": "2021-01-11T15:50:23Z", "type": "commit"}, {"oid": "d28a0b16cd4377c9196155f95a1009000c5043d9", "url": "https://github.com/prestodb/presto/commit/d28a0b16cd4377c9196155f95a1009000c5043d9", "message": "Add unsynchronized fast paths to reduce contention in ExchangeClient", "committedDate": "2021-01-11T15:56:04Z", "type": "commit"}, {"oid": "71af1e9ea09da8f5f93e8217341bc14d8500de6f", "url": "https://github.com/prestodb/presto/commit/71af1e9ea09da8f5f93e8217341bc14d8500de6f", "message": "Remove synchronized for final field read in MemoryPool#getMaxBytes()", "committedDate": "2021-01-11T15:56:05Z", "type": "forcePushed"}, {"oid": "5ca13df409e24e13753aae8209625858afdf00a5", "url": "https://github.com/prestodb/presto/commit/5ca13df409e24e13753aae8209625858afdf00a5", "message": "Refactor ExchangeClient#pollPage\n\nMerges ExchangeClient#postProcessPage into ExchangeClient#pollPage\n(its only usage) to avoid a redundant lock holder check, removes\na redundant peek into the pagesBuffer for NO_MORE_PAGES, and coalesces\nthe synchronized section of scheduleRequestIfNecessary into the\nsynchronized block that immediately preceeded it anyway", "committedDate": "2021-01-11T18:50:09Z", "type": "commit"}, {"oid": "222bd3f72f2458fc3d14ee96f51162861c47a6b7", "url": "https://github.com/prestodb/presto/commit/222bd3f72f2458fc3d14ee96f51162861c47a6b7", "message": "Use AtomicIntegerFieldUpdater for LocalExchange PageReference", "committedDate": "2021-01-11T18:50:09Z", "type": "commit"}, {"oid": "046bf4b51d565781a0a45d0706443d3994b7f72b", "url": "https://github.com/prestodb/presto/commit/046bf4b51d565781a0a45d0706443d3994b7f72b", "message": "Reduce synchronization in LocalExchangeMemoryManager", "committedDate": "2021-01-11T18:50:09Z", "type": "commit"}, {"oid": "151b6758599765d537584f897e077fb7fcfba293", "url": "https://github.com/prestodb/presto/commit/151b6758599765d537584f897e077fb7fcfba293", "message": "Improve LocalExchangeSource locking behaviors\n\nAdds an unsynchronized fast path to LocalExchangeSource#waitForReading()\nand LocalExchangeSource#isFinished(). Also removes an unnecessary \"lock\"\nObject which was obscuring this particular contention point in profiling\noriginally.", "committedDate": "2021-01-11T18:50:09Z", "type": "commit"}, {"oid": "6b1478ac641002ecdb6011a5a79c4e3cdf77ca38", "url": "https://github.com/prestodb/presto/commit/6b1478ac641002ecdb6011a5a79c4e3cdf77ca38", "message": "Remove synchronized for final field read in MemoryPool#getMaxBytes()", "committedDate": "2021-01-11T18:50:09Z", "type": "commit"}, {"oid": "6b1478ac641002ecdb6011a5a79c4e3cdf77ca38", "url": "https://github.com/prestodb/presto/commit/6b1478ac641002ecdb6011a5a79c4e3cdf77ca38", "message": "Remove synchronized for final field read in MemoryPool#getMaxBytes()", "committedDate": "2021-01-11T18:50:09Z", "type": "forcePushed"}]}