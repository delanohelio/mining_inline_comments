{"pr_number": 14515, "pr_title": "Run AbstractTestQueries suite with Presto on Spark", "pr_createdAt": "2020-05-12T15:33:02Z", "pr_url": "https://github.com/prestodb/presto/pull/14515", "timeline": [{"oid": "6a06981469a8a3b97894269dcc3b7d764b28281f", "url": "https://github.com/prestodb/presto/commit/6a06981469a8a3b97894269dcc3b7d764b28281f", "message": "Collect input rdds in parallel", "committedDate": "2020-05-12T15:45:20Z", "type": "forcePushed"}, {"oid": "d856452d6c2caa1c65a6df21dd732ae36d40b297", "url": "https://github.com/prestodb/presto/commit/d856452d6c2caa1c65a6df21dd732ae36d40b297", "message": "Do not close testing SparkContext that is still in use", "committedDate": "2020-05-13T22:29:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg3NDgwNw==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r424874807", "bodyText": "When the fragment doesn't have any child, it cannot have broadcast input as well right?", "author": "wenleix", "createdAt": "2020-05-14T05:13:41Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/planner/PrestoSparkRddFactory.java", "diffHunk": "@@ -225,7 +227,15 @@ private static Partitioner createPartitioner(PartitioningHandle partitioning, in\n         PrestoSparkTaskDescriptor taskDescriptor = createIntermediateTaskDescriptor(session, tableWriteInfo, fragment);\n         SerializedPrestoSparkTaskDescriptor serializedTaskDescriptor = new SerializedPrestoSparkTaskDescriptor(taskDescriptorJsonCodec.toJsonBytes(taskDescriptor));\n \n-        if (rddInputs.size() == 1) {\n+        if (rddInputs.size() == 0) {\n+            checkArgument(fragment.getPartitioning().equals(SINGLE_DISTRIBUTION), \"SINGLE_DISTRIBUTION partitioning is expected: %s\", fragment.getPartitioning());\n+            return sparkContext.parallelize(ImmutableList.of(serializedTaskDescriptor), 1)\n+                    .mapPartitionsToPair(createTaskProcessor(\n+                            executorFactoryProvider,\n+                            taskStatsCollector,\n+                            toTaskProcessorBroadcastInputs(broadcastInputs)));", "originalCommit": "e6295347080e36a5ce956be7009876a30c08636b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI3NDgyNw==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r425274827", "bodyText": "Theoretically it is possible to get such plans. Think of a broadcast join with VALUES. e.g.: (VALUES JOIN table)", "author": "arhimondr", "createdAt": "2020-05-14T16:33:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg3NDgwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg3OTE3Mg==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r424879172", "bodyText": "My understanding Spark Java API avoids directly using scala.reflect.ClassTag$.MODULE$,  and that's why JavaRDDLike is introduced with automatic wrap of class tags, e.g. https://github.com/apache/spark/blob/fd2d55c9919ece5463377bc6f45f2cdb8bf90515/core/src/main/scala/org/apache/spark/api/java/JavaRDDLike.scala#L93\nIn fact, in JavaRDDLike, it use \"fakeClassTag\"  to \"keep ClassTags out of the external Java API\", as explained here: https://github.com/apache/spark/blob/fd2d55c9919ece5463377bc6f45f2cdb8bf90515/core/src/main/scala/org/apache/spark/api/java/JavaSparkContext.scala#L754-L764\n   * Produces a ClassTag[T], which is actually just a casted ClassTag[AnyRef].\n   *\n   * This method is used to keep ClassTags out of the external Java API, as the Java compiler\n   * cannot produce them automatically. While this ClassTag-faking does please the compiler,\n   * it can cause problems at runtime if the Scala API relies on ClassTags for correctness.\n   *\n   * Often, though, a ClassTag[AnyRef] will not lead to incorrect behavior, just worse performance\n   * or security issues. For instance, an Array[AnyRef] can hold any type T, but may lose primitive\n   * specialization.\n\ncc @sameeragarwal", "author": "wenleix", "createdAt": "2020-05-14T05:29:35Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/planner/PrestoSparkRddFactory.java", "diffHunk": "@@ -235,38 +237,25 @@ private static Partitioner createPartitioner(PartitioningHandle partitioning, in\n                             taskStatsCollector,\n                             toTaskProcessorBroadcastInputs(broadcastInputs)));\n         }\n-        else if (rddInputs.size() == 1) {\n-            Entry<PlanFragmentId, JavaPairRDD<Integer, PrestoSparkRow>> input = getOnlyElement(rddInputs.entrySet());\n-            PairFlatMapFunction<Iterator<Tuple2<Integer, PrestoSparkRow>>, Integer, PrestoSparkRow> taskProcessor =\n-                    createTaskProcessor(\n-                            executorFactoryProvider,\n-                            serializedTaskDescriptor,\n-                            input.getKey().toString(),\n-                            taskStatsCollector,\n-                            toTaskProcessorBroadcastInputs(broadcastInputs));\n-            return input.getValue()\n-                    .mapPartitionsToPair(taskProcessor);\n-        }\n-        if (rddInputs.size() == 2) {\n-            List<PlanFragmentId> fragmentIds = ImmutableList.copyOf(rddInputs.keySet());\n-            List<JavaPairRDD<Integer, PrestoSparkRow>> rdds = fragmentIds.stream()\n-                    .map(rddInputs::get)\n-                    .collect(toImmutableList());\n-            FlatMapFunction2<Iterator<Tuple2<Integer, PrestoSparkRow>>, Iterator<Tuple2<Integer, PrestoSparkRow>>, Tuple2<Integer, PrestoSparkRow>> taskProcessor =\n-                    createTaskProcessor(\n-                            executorFactoryProvider,\n-                            serializedTaskDescriptor,\n-                            fragmentIds.get(0).toString(),\n-                            fragmentIds.get(1).toString(),\n-                            taskStatsCollector,\n-                            toTaskProcessorBroadcastInputs(broadcastInputs));\n-            return JavaPairRDD.fromJavaRDD(\n-                    rdds.get(0).zipPartitions(\n-                            rdds.get(1),\n-                            taskProcessor));\n+\n+        ImmutableList.Builder<String> fragmentIds = ImmutableList.builder();\n+        ImmutableList.Builder<RDD<Tuple2<Integer, PrestoSparkRow>>> rdds = ImmutableList.builder();\n+        for (Entry<PlanFragmentId, JavaPairRDD<Integer, PrestoSparkRow>> input : rddInputs.entrySet()) {\n+            fragmentIds.add(input.getKey().toString());\n+            rdds.add(input.getValue().rdd());\n         }\n \n-        throw new IllegalArgumentException(format(\"unsupported number of inputs: %s\", rddInputs.size()));\n+        Function<List<Iterator<Tuple2<Integer, PrestoSparkRow>>>, Iterator<Tuple2<Integer, PrestoSparkRow>>> taskProcessor = createTaskProcessor(\n+                executorFactoryProvider,\n+                serializedTaskDescriptor,\n+                fragmentIds.build(),\n+                taskStatsCollector,\n+                toTaskProcessorBroadcastInputs(broadcastInputs));\n+\n+        return JavaPairRDD.fromRDD(\n+                new PrestoSparkZipRdd(sparkContext.sc(), rdds.build(), taskProcessor),\n+                classTag(Integer.class),", "originalCommit": "32653f1a4c24cd87557e23c7a515a5fa8c2c6b37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI3MjEzNA==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r425272134", "bodyText": "$.MODULE$ Is the way Scala implements lazy singleton objects. Although this is not very \"public\" API, given the legacy I don't expect it to change.", "author": "arhimondr", "createdAt": "2020-05-14T16:29:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg3OTE3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjEwMDQxNQ==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r426100415", "bodyText": "@arhimondr : The fundamental question is how to interact between Java/Scala API in such case. I assume Databricks has done in-depth investigation into this when they design the Spark Java API. Thus there might be reason why they use fakeClassTag instead of scala.reflect.\nI will check this offline with @sameeragarwal . In the meanwhile, we can continue with what is implemented in your PR. Just keep in mind we might need revisit in the future about Java-Scala interaction (which I heard can be tricky in some cases due to Scala has many fancy features done by Scala Compiler \ud83d\ude03 ) and pay back tech-debt, if there is \ud83d\ude03", "author": "wenleix", "createdAt": "2020-05-16T00:53:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg3OTE3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MTQ0Nw==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r424881447", "bodyText": "ZippedPartitionsBaseRDD seems to be a private[static] class : https://github.com/apache/spark/blob/fd2d55c9919ece5463377bc6f45f2cdb8bf90515/core/src/main/scala/org/apache/spark/rdd/ZippedPartitionsRDD.scala#L45  Shall we extend it?\ncc @sameeragarwal", "author": "wenleix", "createdAt": "2020-05-14T05:37:50Z", "path": "presto-spark-classloader-interface/src/main/java/com/facebook/presto/spark/classloader_interface/PrestoSparkZipRdd.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.spark.classloader_interface;\n+\n+import org.apache.spark.Partition;\n+import org.apache.spark.SparkContext;\n+import org.apache.spark.TaskContext;\n+import org.apache.spark.rdd.RDD;\n+import org.apache.spark.rdd.ZippedPartitionsBaseRDD;\n+import org.apache.spark.rdd.ZippedPartitionsPartition;\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.IntStream;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.toList;\n+import static scala.collection.JavaConversions.asScalaBuffer;\n+import static scala.collection.JavaConversions.asScalaIterator;\n+import static scala.collection.JavaConversions.seqAsJavaList;\n+\n+public class PrestoSparkZipRdd\n+        extends ZippedPartitionsBaseRDD<Tuple2<Integer, PrestoSparkRow>>", "originalCommit": "32653f1a4c24cd87557e23c7a515a5fa8c2c6b37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNTI3NDMzOQ==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r425274339", "bodyText": "Ideally - no. This is a private API. However public API does not allow zipping of more than 4 RDD's. That's why we are making this tradeoff.\nI acknowledge that we might looks forward compatibility at some point due to using this private API. However unfortunately I don't see how can we zip more than 4 partition in a way other than that.\nThis is tested with Spark 2.0 and Spark 2.4.3 and it works. If at some point we discover that compatibility is broken for some version of Spark we will try to figure out how to fix it.\nMeanwhile we can also try to contribute N-way ZIP partition to open source Spark.", "author": "arhimondr", "createdAt": "2020-05-14T16:32:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MTQ0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjA5OTg0Mg==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r426099842", "bodyText": "@arhimondr :\n\nMeanwhile we can also try to contribute N-way ZIP partition to open source Spark.\n\nThat could be the long-term solution. Another worthwhile investigation next half could be to understand how does SparkSQL implement it without N-way ZIP partition. I also see SparkSQL implements some specialized SparkSQL RDD (unfortunately, in Scala). Thus they don't have this Java-Scala interaction design problem :)", "author": "wenleix", "createdAt": "2020-05-16T00:48:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MTQ0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5MzE5OA==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r426693198", "bodyText": "I suspect that they implemented it by calling zip partitions (or join / etc:) multiple times, as they don't really need to have 1 task per stage, since the exchange is row based anyway.", "author": "arhimondr", "createdAt": "2020-05-18T15:03:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MTQ0Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAyOTY3Mw==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r427029673", "bodyText": "@arhimondr : Even SparkSQL is already row-based, calling zipPartition might also cause unnecessary materialization (depends on implementation). I also suspect it could limit the efficiency of whole stage codegen without having all the zipped partitions all in once...", "author": "wenleix", "createdAt": "2020-05-19T04:55:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDg4MTQ0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyOTA3MA==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r426229070", "bodyText": "nit: I think we usually use Map.Entry<...> ?", "author": "wenleix", "createdAt": "2020-05-17T07:40:18Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/planner/PrestoSparkRddFactory.java", "diffHunk": "@@ -235,38 +237,25 @@ private static Partitioner createPartitioner(PartitioningHandle partitioning, in\n                             taskStatsCollector,\n                             toTaskProcessorBroadcastInputs(broadcastInputs)));\n         }\n-        else if (rddInputs.size() == 1) {\n-            Entry<PlanFragmentId, JavaPairRDD<Integer, PrestoSparkRow>> input = getOnlyElement(rddInputs.entrySet());\n-            PairFlatMapFunction<Iterator<Tuple2<Integer, PrestoSparkRow>>, Integer, PrestoSparkRow> taskProcessor =\n-                    createTaskProcessor(\n-                            executorFactoryProvider,\n-                            serializedTaskDescriptor,\n-                            input.getKey().toString(),\n-                            taskStatsCollector,\n-                            toTaskProcessorBroadcastInputs(broadcastInputs));\n-            return input.getValue()\n-                    .mapPartitionsToPair(taskProcessor);\n-        }\n-        if (rddInputs.size() == 2) {\n-            List<PlanFragmentId> fragmentIds = ImmutableList.copyOf(rddInputs.keySet());\n-            List<JavaPairRDD<Integer, PrestoSparkRow>> rdds = fragmentIds.stream()\n-                    .map(rddInputs::get)\n-                    .collect(toImmutableList());\n-            FlatMapFunction2<Iterator<Tuple2<Integer, PrestoSparkRow>>, Iterator<Tuple2<Integer, PrestoSparkRow>>, Tuple2<Integer, PrestoSparkRow>> taskProcessor =\n-                    createTaskProcessor(\n-                            executorFactoryProvider,\n-                            serializedTaskDescriptor,\n-                            fragmentIds.get(0).toString(),\n-                            fragmentIds.get(1).toString(),\n-                            taskStatsCollector,\n-                            toTaskProcessorBroadcastInputs(broadcastInputs));\n-            return JavaPairRDD.fromJavaRDD(\n-                    rdds.get(0).zipPartitions(\n-                            rdds.get(1),\n-                            taskProcessor));\n+\n+        ImmutableList.Builder<String> fragmentIds = ImmutableList.builder();\n+        ImmutableList.Builder<RDD<Tuple2<Integer, PrestoSparkRow>>> rdds = ImmutableList.builder();\n+        for (Entry<PlanFragmentId, JavaPairRDD<Integer, PrestoSparkRow>> input : rddInputs.entrySet()) {", "originalCommit": "32653f1a4c24cd87557e23c7a515a5fa8c2c6b37", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyOTI1OA==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r426229258", "bodyText": "nit: for line 401 to 409, we could also consider use an imperative way (instead of using stream API) -- especially collectAndDestroyDependencies has side effect . No strong opinion here.", "author": "wenleix", "createdAt": "2020-05-17T07:42:29Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -400,14 +398,20 @@ private PrestoSparkQueryExecution(\n                         tableWriteInfo);\n                 SerializedPrestoSparkTaskDescriptor serializedTaskDescriptor = new SerializedPrestoSparkTaskDescriptor(sparkTaskDescriptorJsonCodec.toJsonBytes(taskDescriptor));\n \n-                SubPlan child = getOnlyElement(root.getChildren());\n-                RddAndMore rdd = createRdd(child);\n-                List<Tuple2<Integer, PrestoSparkRow>> sparkDriverInput = rdd.collectAndDestroyDependencies();\n+                Map<PlanFragmentId, RddAndMore> inputRdds = root.getChildren().stream()", "originalCommit": "32653f1a4c24cd87557e23c7a515a5fa8c2c6b37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk1NjYyNA==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r426956624", "bodyText": "I tried converting it to loops, but it becomes more wordy, as you have to initialize the builders first for rdd's, then for the futures, then for the results. I would like to keep it as is if you don't mind.", "author": "arhimondr", "createdAt": "2020-05-19T00:04:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyOTI1OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyOTY5Mg==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r426229692", "bodyText": "int: Maybe just using for-loop + ArrayList here? My feeling is using Stream API here doesn't help make the code easy to read or reasoning (you still need to use i which is almost for-loop). But it's just a personal preference.", "author": "wenleix", "createdAt": "2020-05-17T07:47:56Z", "path": "presto-spark-classloader-interface/src/main/java/com/facebook/presto/spark/classloader_interface/PrestoSparkZipRdd.java", "diffHunk": "@@ -0,0 +1,83 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.spark.classloader_interface;\n+\n+import org.apache.spark.Partition;\n+import org.apache.spark.SparkContext;\n+import org.apache.spark.TaskContext;\n+import org.apache.spark.rdd.RDD;\n+import org.apache.spark.rdd.ZippedPartitionsBaseRDD;\n+import org.apache.spark.rdd.ZippedPartitionsPartition;\n+import scala.Tuple2;\n+import scala.collection.JavaConversions;\n+import scala.collection.Seq;\n+\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.function.Function;\n+import java.util.stream.IntStream;\n+\n+import static java.util.Collections.unmodifiableList;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.toList;\n+import static scala.collection.JavaConversions.asScalaBuffer;\n+import static scala.collection.JavaConversions.asScalaIterator;\n+import static scala.collection.JavaConversions.seqAsJavaList;\n+\n+public class PrestoSparkZipRdd\n+        extends ZippedPartitionsBaseRDD<Tuple2<Integer, PrestoSparkRow>>\n+{\n+    private List<RDD<Tuple2<Integer, PrestoSparkRow>>> rdds;\n+    private Function<List<Iterator<Tuple2<Integer, PrestoSparkRow>>>, Iterator<Tuple2<Integer, PrestoSparkRow>>> function;\n+\n+    public PrestoSparkZipRdd(\n+            SparkContext context,\n+            List<RDD<Tuple2<Integer, PrestoSparkRow>>> rdds,\n+            Function<List<Iterator<Tuple2<Integer, PrestoSparkRow>>>, Iterator<Tuple2<Integer, PrestoSparkRow>>> function)\n+    {\n+        super(\n+                context,\n+                getRDDSequence(requireNonNull(rdds, \"rdds is null\")),\n+                false,\n+                scala.reflect.ClassTag$.MODULE$.apply(Tuple2.class));\n+        this.rdds = rdds;\n+        this.function = context.clean(requireNonNull(function, \"function is null\"), true);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static Seq<RDD<?>> getRDDSequence(List<RDD<Tuple2<Integer, PrestoSparkRow>>> rdds)\n+    {\n+        return asScalaBuffer((List<RDD<?>>) (List<?>) new ArrayList<>(rdds)).toSeq();\n+    }\n+\n+    @Override\n+    public scala.collection.Iterator<Tuple2<Integer, PrestoSparkRow>> compute(Partition split, TaskContext context)\n+    {\n+        List<Partition> partitions = seqAsJavaList(((ZippedPartitionsPartition) split).partitions());\n+        List<Iterator<Tuple2<Integer, PrestoSparkRow>>> iterators = unmodifiableList(IntStream.range(0, rdds.size())", "originalCommit": "32653f1a4c24cd87557e23c7a515a5fa8c2c6b37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk1NzA5Mw==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r426957093", "bodyText": "Makes sense. Converted to a loop.", "author": "arhimondr", "createdAt": "2020-05-19T00:06:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyOTY5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIzMDU3MA==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r426230570", "bodyText": "Note you are also using PrestoSparkZipRdd even there is only one RDD input. I am wondering if we should only use PrestoSparkZipRdd when there are more than two inputs?  Since it seems reasonable to specialize when there is only one RDD input.", "author": "wenleix", "createdAt": "2020-05-17T07:58:39Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/planner/PrestoSparkRddFactory.java", "diffHunk": "@@ -235,38 +237,25 @@ private static Partitioner createPartitioner(PartitioningHandle partitioning, in\n                             taskStatsCollector,\n                             toTaskProcessorBroadcastInputs(broadcastInputs)));\n         }\n-        else if (rddInputs.size() == 1) {\n-            Entry<PlanFragmentId, JavaPairRDD<Integer, PrestoSparkRow>> input = getOnlyElement(rddInputs.entrySet());\n-            PairFlatMapFunction<Iterator<Tuple2<Integer, PrestoSparkRow>>, Integer, PrestoSparkRow> taskProcessor =\n-                    createTaskProcessor(\n-                            executorFactoryProvider,\n-                            serializedTaskDescriptor,\n-                            input.getKey().toString(),\n-                            taskStatsCollector,\n-                            toTaskProcessorBroadcastInputs(broadcastInputs));\n-            return input.getValue()\n-                    .mapPartitionsToPair(taskProcessor);", "originalCommit": "32653f1a4c24cd87557e23c7a515a5fa8c2c6b37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5NTU3OQ==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r426695579", "bodyText": "Then we need to have 2 different task processors implemented, one for partitionBy and one for zipRdd. This results in code duplication.", "author": "arhimondr", "createdAt": "2020-05-18T15:07:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIzMDU3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk1OTgyOA==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r426959828", "bodyText": "Also I was thinking about extending PrestoSparkZipRdd to also accept an RDD of partitioned splits for bucketed tables. Thus I would prefer to have all exchanges implemented with PrestoSparkZipRdd.", "author": "arhimondr", "createdAt": "2020-05-19T00:16:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIzMDU3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0MjcxNw==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r427042717", "bodyText": "@arhimondr :\n\nThen we need to have 2 different task processors implemented, one for partitionBy and one for zipRdd. This results in code duplication.\n\nMy intuition is there might be some way to refactor the task processor to avoid code duplication. I raise this as originally, the code is clear about when to use the mapPartitions primitive and when to use zipPartitions primitive. Now zipPartitions becomes a bit omnipotent.\nBut I agree let's revisit these primitives after bucketed table is implemented (even after initial production use cases \ud83d\ude03 )", "author": "wenleix", "createdAt": "2020-05-19T05:43:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIzMDU3MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA3MjYzMg==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r428072632", "bodyText": "I have a prototype for bucketed tables.\nI consolidated all RDD creation into the PrestoSparkTaskRdd, that accepts both, PrestoSparkRow RDD's and RDD containing splits: c018b12#diff-c96d6601d2e7713a8432fbd9702bdcb6R41\nThe PrestoSparkTaskRdd takes PrestoSparkTaskProcessor, that is also now consolidated into one:\nc018b12#diff-25f8e21cfd79d29a34d89b1f2758822bR32", "author": "arhimondr", "createdAt": "2020-05-20T14:46:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIzMDU3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIzMTE4Mg==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r426231182", "bodyText": "Instead of using a general function type. I am wondering if we can have FlatMapFunctionNSameInputType<Iterator<Tuple2<Integer, PrestoSparkRow>>, Tuple2<Integer, PrestoSparkRow>>? Essentially thinking about generalizing FlatMapFunction2 to N inputs with same type :)", "author": "wenleix", "createdAt": "2020-05-17T08:05:45Z", "path": "presto-spark-classloader-interface/src/main/java/com/facebook/presto/spark/classloader_interface/TaskProcessors.java", "diffHunk": "@@ -62,59 +62,37 @@ private TaskProcessors() {}\n         };\n     }\n \n-    public static PairFlatMapFunction<Iterator<Tuple2<Integer, PrestoSparkRow>>, Integer, PrestoSparkRow> createTaskProcessor(\n+    public static Function<List<Iterator<Tuple2<Integer, PrestoSparkRow>>>, Iterator<Tuple2<Integer, PrestoSparkRow>>> createTaskProcessor(", "originalCommit": "32653f1a4c24cd87557e23c7a515a5fa8c2c6b37", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5NjQxNA==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r426696414", "bodyText": "Could you please elaborate a little more on this?", "author": "arhimondr", "createdAt": "2020-05-18T15:08:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIzMTE4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjcwMDE2NQ==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r426700165", "bodyText": "Actually never-mind. I think I got it. Let me have a look", "author": "arhimondr", "createdAt": "2020-05-18T15:13:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIzMTE4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjk1OTM5NA==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r426959394", "bodyText": "Currently the functions argument is List<Iterator<Tuple2<Integer, PrestoSparkRow>>>. It's because the inputs are always Tuple2<Integer, PrestoSparkRow>.\nWhen I was thinking about bucketed tables implementation, I envisioned the second type of inputs, Tuple2<Integer, Split> -> (partition,split). Thus I would love to leave the flexibility to freely define signature, since it will not necessarily be accepting the inputs of the same type.", "author": "arhimondr", "createdAt": "2020-05-19T00:15:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIzMTE4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzAzMTI1OQ==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r427031259", "bodyText": "@arhimondr : Makes sense. We can revisit potential refactors once bucketed table join unbucketed table is implemented.", "author": "wenleix", "createdAt": "2020-05-19T05:01:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIzMTE4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3ODkxNQ==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r426378915", "bodyText": "Before, when will this branch being triggered? -- one case I can think is to gather all the table write information ?", "author": "wenleix", "createdAt": "2020-05-18T05:37:44Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/AddExchanges.java", "diffHunk": "@@ -1202,9 +1205,30 @@ public PlanWithProperties visitUnion(UnionNode node, PreferredProperties parentP\n                 // children partitioning and don't GATHER partitioned inputs\n                 // TODO: add FIXED_ARBITRARY_DISTRIBUTION support on non empty singleNodeChildren\n                 if (!parentPartitioningPreference.isPresent() || parentPartitioningPreference.get().isDistributed()) {\n-                    return arbitraryDistributeUnion(node, distributedChildren, distributedOutputLayouts);\n+                    // TODO: can we insert LOCAL exchange for one child SOURCE distributed and another HASH distributed?\n+                    if (getNumberOfTableScans(distributedChildren) == 0 && isSameOrSystemCompatiblePartitions(extractRemoteExchangePartitioningHandles(distributedChildren))) {\n+                        // No source distributed child, we can use insert LOCAL exchange\n+                        // TODO: if all children have the same partitioning, pass this partitioning to the parent\n+                        // instead of \"arbitraryPartition\".\n+                        return new PlanWithProperties(node.replaceChildren(distributedChildren));\n+                    }\n+                    else if (preferDistributedUnion) {\n+                        // Presto currently can not execute stage that has multiple table scans, so in that case\n+                        // we have to insert REMOTE exchange with FIXED_ARBITRARY_DISTRIBUTION instead of local exchange\n+                        return new PlanWithProperties(\n+                                new ExchangeNode(\n+                                        idAllocator.getNextId(),\n+                                        REPARTITION,\n+                                        REMOTE_STREAMING,\n+                                        new PartitioningScheme(Partitioning.create(FIXED_ARBITRARY_DISTRIBUTION, ImmutableList.of()), node.getOutputVariables()),\n+                                        distributedChildren,\n+                                        distributedOutputLayouts,\n+                                        false,\n+                                        Optional.empty()));\n+                    }\n                 }\n-\n+                // TODO: We should support multiple table scans in a single fragment for efficient union implementation\n+                // TODO: Multiple table scans are already partially supported (for partitioned (bucketed) tables)", "originalCommit": "9352a0d6db268ce76afd8bf68d5786e475df15eb", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5NzgwOA==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r426697808", "bodyText": "Yeah, table write information is one of them. Another good example is sort.", "author": "arhimondr", "createdAt": "2020-05-18T15:10:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM3ODkxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM4MjQ4Mw==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r426382483", "bodyText": "There is no Airlift MoreFutures utility methods to do this? :)", "author": "wenleix", "createdAt": "2020-05-18T05:50:24Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -506,6 +517,34 @@ private QueryInfo createQueryInfo(Optional<Throwable> failure)\n             // TODO: create query info\n             return null;\n         }\n+\n+        private static <T> void waitFor(Collection<Future<T>> futures)", "originalCommit": "50535a959c402218966f62b4c6f7165f41c03ee2", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjY5ODQxMA==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r426698410", "bodyText": "They all operate on ListeableFuture. The Spark API returns just a regular Future =\\", "author": "arhimondr", "createdAt": "2020-05-18T15:10:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjM4MjQ4Mw=="}], "type": "inlineReview"}, {"oid": "2d9fa7aa5a3acc512d6d3b0490b96c38d85a9db9", "url": "https://github.com/prestodb/presto/commit/2d9fa7aa5a3acc512d6d3b0490b96c38d85a9db9", "message": "Do not close testing SparkContext that is still in use", "committedDate": "2020-05-19T00:19:21Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NDYyNA==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r427044624", "bodyText": "Maybe explain now there are two situations UNION will be executed by gathering into the same worker\n\nParent node doesn't prefer distributed partitioning (e.g. TableFinish)\nParent node prefers distributed partitioning  but prefer_distributed_union is disabled\n\nFor the second situation, we should support multiple table scans in a single fragment.", "author": "wenleix", "createdAt": "2020-05-19T05:50:04Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/AddExchanges.java", "diffHunk": "@@ -1202,9 +1205,30 @@ public PlanWithProperties visitUnion(UnionNode node, PreferredProperties parentP\n                 // children partitioning and don't GATHER partitioned inputs\n                 // TODO: add FIXED_ARBITRARY_DISTRIBUTION support on non empty singleNodeChildren\n                 if (!parentPartitioningPreference.isPresent() || parentPartitioningPreference.get().isDistributed()) {\n-                    return arbitraryDistributeUnion(node, distributedChildren, distributedOutputLayouts);\n+                    // TODO: can we insert LOCAL exchange for one child SOURCE distributed and another HASH distributed?\n+                    if (getNumberOfTableScans(distributedChildren) == 0 && isSameOrSystemCompatiblePartitions(extractRemoteExchangePartitioningHandles(distributedChildren))) {\n+                        // No source distributed child, we can use insert LOCAL exchange\n+                        // TODO: if all children have the same partitioning, pass this partitioning to the parent\n+                        // instead of \"arbitraryPartition\".\n+                        return new PlanWithProperties(node.replaceChildren(distributedChildren));\n+                    }\n+                    else if (preferDistributedUnion) {\n+                        // Presto currently can not execute stage that has multiple table scans, so in that case\n+                        // we have to insert REMOTE exchange with FIXED_ARBITRARY_DISTRIBUTION instead of local exchange\n+                        return new PlanWithProperties(\n+                                new ExchangeNode(\n+                                        idAllocator.getNextId(),\n+                                        REPARTITION,\n+                                        REMOTE_STREAMING,\n+                                        new PartitioningScheme(Partitioning.create(FIXED_ARBITRARY_DISTRIBUTION, ImmutableList.of()), node.getOutputVariables()),\n+                                        distributedChildren,\n+                                        distributedOutputLayouts,\n+                                        false,\n+                                        Optional.empty()));\n+                    }\n                 }\n-\n+                // TODO: We should support multiple table scans in a single fragment for efficient union implementation", "originalCommit": "afb0fe58126e30ac93dd867d5a837d82ced6db9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NTAyNQ==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r427045025", "bodyText": "we can set this property to be hidden :)", "author": "wenleix", "createdAt": "2020-05-19T05:51:12Z", "path": "presto-main/src/main/java/com/facebook/presto/SystemSessionProperties.java", "diffHunk": "@@ -762,6 +763,11 @@ public SystemSessionProperties(\n                         OPTIMIZE_COMMON_SUB_EXPRESSIONS,\n                         \"Extract and compute common sub-expressions in projection\",\n                         featuresConfig.isOptimizeCommonSubExpressions(),\n+                        false),\n+                booleanProperty(\n+                        PREFER_DISTRIBUTED_UNION,\n+                        \"Prefer distributed union\",\n+                        featuresConfig.isPreferDistributedUnion(),", "originalCommit": "afb0fe58126e30ac93dd867d5a837d82ced6db9f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NTcxNA==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r427045714", "bodyText": "I am actually thinking to set PREFER_DISTRIBUTED_UNION  to be false in production -- this would fail user query loudly instead of make it run but somehow very slow...\nPREFER_DISTRIBUTED_UNION should only be used to entertain test.", "author": "wenleix", "createdAt": "2020-05-19T05:53:22Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkSettingsRequirements.java", "diffHunk": "@@ -49,6 +50,7 @@ public void verify(SparkContext sparkContext, Session session)\n                 \"grouped execution is not supported\");\n         verify(!isRedistributeWrites(session), \"redistribute writes is not supported\");\n         verify(!isScaleWriters(session), \"scale writes is not supported\");\n+        verify(!isPreferDistributedUnion(session), \"prefer distributed union is expected to be disabled\");", "originalCommit": "afb0fe58126e30ac93dd867d5a837d82ced6db9f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODExNzM1Ng==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r428117356", "bodyText": "That makes sense. Let me change that.", "author": "arhimondr", "createdAt": "2020-05-20T15:45:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA0NTcxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczNDc5Nw==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r427734797", "bodyText": "So wrap the encoded execution info with \"|\" is to allow being parsed out in PrestoSparkExecutionExceptionFactory ?", "author": "wenleix", "createdAt": "2020-05-20T04:29:55Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/execution/PrestoSparkExecutionException.java", "diffHunk": "@@ -0,0 +1,28 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.spark.execution;\n+\n+public abstract class PrestoSparkExecutionException\n+        extends RuntimeException\n+{\n+    protected PrestoSparkExecutionException(String message, String encodedExecutionFailureInfo, Throwable cause)\n+    {\n+        super(formatExceptionMessage(message, encodedExecutionFailureInfo), cause);\n+    }\n+\n+    private static String formatExceptionMessage(String message, String encodedExecutionFailureInfo)\n+    {\n+        return message + \" | ExecutionFailureInfo[\" + encodedExecutionFailureInfo + \"] |\";", "originalCommit": "d70f28a22701873490635eaaf814edd808da22c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyMTIzNw==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r428121237", "bodyText": "Also it helps to visually divide it when reading the error message from the executor", "author": "arhimondr", "createdAt": "2020-05-20T15:50:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczNDc5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczNjI1Mw==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r427736253", "bodyText": "nit: What about toPrestoSparkExecutionException?", "author": "wenleix", "createdAt": "2020-05-20T04:36:19Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/execution/PrestoSparkExecutionExceptionFactory.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.spark.execution;\n+\n+import com.facebook.airlift.json.JsonCodec;\n+import com.facebook.presto.execution.ExecutionFailureInfo;\n+import com.facebook.presto.spi.ErrorCode;\n+import com.facebook.presto.spi.ErrorType;\n+import org.apache.spark.SparkException;\n+\n+import javax.inject.Inject;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Base64;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.zip.DeflaterInputStream;\n+import java.util.zip.InflaterOutputStream;\n+\n+import static com.facebook.presto.spi.ErrorType.EXTERNAL;\n+import static com.facebook.presto.spi.ErrorType.INTERNAL_ERROR;\n+import static com.facebook.presto.util.Failures.toFailure;\n+import static com.google.common.io.ByteStreams.toByteArray;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.regex.Pattern.DOTALL;\n+import static java.util.regex.Pattern.MULTILINE;\n+\n+public class PrestoSparkExecutionExceptionFactory\n+{\n+    private static final Pattern PATTERN = Pattern.compile(\".*\\\\| ExecutionFailureInfo\\\\[([^\\\\[\\\\]]+)\\\\] \\\\|.*\", MULTILINE | DOTALL);\n+\n+    private final JsonCodec<ExecutionFailureInfo> codec;\n+\n+    @Inject\n+    public PrestoSparkExecutionExceptionFactory(JsonCodec<ExecutionFailureInfo> codec)\n+    {\n+        this.codec = requireNonNull(codec, \"codec is null\");\n+    }\n+\n+    public PrestoSparkExecutionException translate(Throwable throwable)", "originalCommit": "d70f28a22701873490635eaaf814edd808da22c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczNjM1NQ==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r427736355", "bodyText": "is compression necessary?", "author": "wenleix", "createdAt": "2020-05-20T04:36:48Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/execution/PrestoSparkExecutionExceptionFactory.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.spark.execution;\n+\n+import com.facebook.airlift.json.JsonCodec;\n+import com.facebook.presto.execution.ExecutionFailureInfo;\n+import com.facebook.presto.spi.ErrorCode;\n+import com.facebook.presto.spi.ErrorType;\n+import org.apache.spark.SparkException;\n+\n+import javax.inject.Inject;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Base64;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.zip.DeflaterInputStream;\n+import java.util.zip.InflaterOutputStream;\n+\n+import static com.facebook.presto.spi.ErrorType.EXTERNAL;\n+import static com.facebook.presto.spi.ErrorType.INTERNAL_ERROR;\n+import static com.facebook.presto.util.Failures.toFailure;\n+import static com.google.common.io.ByteStreams.toByteArray;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.regex.Pattern.DOTALL;\n+import static java.util.regex.Pattern.MULTILINE;\n+\n+public class PrestoSparkExecutionExceptionFactory\n+{\n+    private static final Pattern PATTERN = Pattern.compile(\".*\\\\| ExecutionFailureInfo\\\\[([^\\\\[\\\\]]+)\\\\] \\\\|.*\", MULTILINE | DOTALL);\n+\n+    private final JsonCodec<ExecutionFailureInfo> codec;\n+\n+    @Inject\n+    public PrestoSparkExecutionExceptionFactory(JsonCodec<ExecutionFailureInfo> codec)\n+    {\n+        this.codec = requireNonNull(codec, \"codec is null\");\n+    }\n+\n+    public PrestoSparkExecutionException translate(Throwable throwable)\n+    {\n+        ExecutionFailureInfo failureInfo = toFailure(throwable);\n+        byte[] serialized = codec.toJsonBytes(failureInfo);\n+        byte[] compressed = compress(serialized);", "originalCommit": "d70f28a22701873490635eaaf814edd808da22c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyMjM0NA==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r428122344", "bodyText": "Not necessary, but generally desired since we serialize to Json that is very verbose.", "author": "arhimondr", "createdAt": "2020-05-20T15:52:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczNjM1NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyOTA3ODQ1Ng==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r429078456", "bodyText": "@arhimondr : Ideally thrift encoding should be used then .But ExecutionFailureInfo contains recursive structure so it's not an option \ud83d\ude15", "author": "wenleix", "createdAt": "2020-05-22T07:07:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczNjM1NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczNjcwNA==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r427736704", "bodyText": "nit: what about extractExecutionFailureInfo?  -- ditto for other 2 tryDecode method.", "author": "wenleix", "createdAt": "2020-05-20T04:38:30Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/execution/PrestoSparkExecutionExceptionFactory.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.spark.execution;\n+\n+import com.facebook.airlift.json.JsonCodec;\n+import com.facebook.presto.execution.ExecutionFailureInfo;\n+import com.facebook.presto.spi.ErrorCode;\n+import com.facebook.presto.spi.ErrorType;\n+import org.apache.spark.SparkException;\n+\n+import javax.inject.Inject;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Base64;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.zip.DeflaterInputStream;\n+import java.util.zip.InflaterOutputStream;\n+\n+import static com.facebook.presto.spi.ErrorType.EXTERNAL;\n+import static com.facebook.presto.spi.ErrorType.INTERNAL_ERROR;\n+import static com.facebook.presto.util.Failures.toFailure;\n+import static com.google.common.io.ByteStreams.toByteArray;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.regex.Pattern.DOTALL;\n+import static java.util.regex.Pattern.MULTILINE;\n+\n+public class PrestoSparkExecutionExceptionFactory\n+{\n+    private static final Pattern PATTERN = Pattern.compile(\".*\\\\| ExecutionFailureInfo\\\\[([^\\\\[\\\\]]+)\\\\] \\\\|.*\", MULTILINE | DOTALL);\n+\n+    private final JsonCodec<ExecutionFailureInfo> codec;\n+\n+    @Inject\n+    public PrestoSparkExecutionExceptionFactory(JsonCodec<ExecutionFailureInfo> codec)\n+    {\n+        this.codec = requireNonNull(codec, \"codec is null\");\n+    }\n+\n+    public PrestoSparkExecutionException translate(Throwable throwable)\n+    {\n+        ExecutionFailureInfo failureInfo = toFailure(throwable);\n+        byte[] serialized = codec.toJsonBytes(failureInfo);\n+        byte[] compressed = compress(serialized);\n+        String encoded = Base64.getEncoder().encodeToString(compressed);\n+        if (isRetryable(failureInfo)) {\n+            return new PrestoSparkRetryableExecutionException(throwable.getMessage(), encoded, throwable);\n+        }\n+        else {\n+            return new PrestoSparkNonRetryableExecutionException(throwable.getMessage(), encoded, throwable);\n+        }\n+    }\n+\n+    public Optional<ExecutionFailureInfo> tryDecode(SparkException sparkException)\n+    {\n+        return tryDecode(sparkException.getMessage());\n+    }\n+\n+    public Optional<ExecutionFailureInfo> tryDecode(PrestoSparkExecutionException executionException)\n+    {\n+        return tryDecode(executionException.getMessage());\n+    }\n+\n+    private Optional<ExecutionFailureInfo> tryDecode(String message)", "originalCommit": "d70f28a22701873490635eaaf814edd808da22c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyMjY5MA==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r428122690", "bodyText": "Sounds great", "author": "arhimondr", "createdAt": "2020-05-20T15:52:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczNjcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczNzM3NQ==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r427737375", "bodyText": "nit: encodedExecutionFailureInfo", "author": "wenleix", "createdAt": "2020-05-20T04:41:29Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/execution/PrestoSparkExecutionExceptionFactory.java", "diffHunk": "@@ -0,0 +1,123 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.spark.execution;\n+\n+import com.facebook.airlift.json.JsonCodec;\n+import com.facebook.presto.execution.ExecutionFailureInfo;\n+import com.facebook.presto.spi.ErrorCode;\n+import com.facebook.presto.spi.ErrorType;\n+import org.apache.spark.SparkException;\n+\n+import javax.inject.Inject;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.util.Base64;\n+import java.util.Optional;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.zip.DeflaterInputStream;\n+import java.util.zip.InflaterOutputStream;\n+\n+import static com.facebook.presto.spi.ErrorType.EXTERNAL;\n+import static com.facebook.presto.spi.ErrorType.INTERNAL_ERROR;\n+import static com.facebook.presto.util.Failures.toFailure;\n+import static com.google.common.io.ByteStreams.toByteArray;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.regex.Pattern.DOTALL;\n+import static java.util.regex.Pattern.MULTILINE;\n+\n+public class PrestoSparkExecutionExceptionFactory\n+{\n+    private static final Pattern PATTERN = Pattern.compile(\".*\\\\| ExecutionFailureInfo\\\\[([^\\\\[\\\\]]+)\\\\] \\\\|.*\", MULTILINE | DOTALL);\n+\n+    private final JsonCodec<ExecutionFailureInfo> codec;\n+\n+    @Inject\n+    public PrestoSparkExecutionExceptionFactory(JsonCodec<ExecutionFailureInfo> codec)\n+    {\n+        this.codec = requireNonNull(codec, \"codec is null\");\n+    }\n+\n+    public PrestoSparkExecutionException translate(Throwable throwable)\n+    {\n+        ExecutionFailureInfo failureInfo = toFailure(throwable);\n+        byte[] serialized = codec.toJsonBytes(failureInfo);\n+        byte[] compressed = compress(serialized);\n+        String encoded = Base64.getEncoder().encodeToString(compressed);", "originalCommit": "d70f28a22701873490635eaaf814edd808da22c1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczODg4Mw==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r427738883", "bodyText": "Instead of doing instanceof here, shouldn't we try to catch SparkException and PrestoSparkExecutionException in line 357? -- is that the more \"Java\" way to handle exceptions?\nIn order to do that, you probably need to refactor line 358 to 370 into something like tryRollbackAndLog", "author": "wenleix", "createdAt": "2020-05-20T04:47:51Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -341,24 +354,36 @@ private PrestoSparkQueryExecution(\n                 rddResults = doExecute(plan);\n                 commit(session, transactionManager);\n             }\n-            catch (RuntimeException executionFailure) {\n+            catch (Exception executionFailure) {\n                 try {\n                     rollback(session, transactionManager);\n                 }\n                 catch (RuntimeException rollbackFailure) {\n-                    if (executionFailure != rollbackFailure) {\n-                        executionFailure.addSuppressed(rollbackFailure);\n-                    }\n+                    log.error(rollbackFailure, \"Encountered error when performing rollback\");\n                 }\n+\n                 try {\n                     queryCompletedEvent(Optional.of(executionFailure));\n                 }\n                 catch (RuntimeException eventFailure) {\n-                    if (executionFailure != eventFailure) {\n-                        executionFailure.addSuppressed(eventFailure);\n+                    log.error(eventFailure, \"Error publishing query completed event\");\n+                }\n+\n+                if (executionFailure instanceof SparkException) {", "originalCommit": "d70f28a22701873490635eaaf814edd808da22c1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODEyNDkzMg==", "url": "https://github.com/prestodb/presto/pull/14515#discussion_r428124932", "bodyText": "Instead of doing instanceof here, shouldn't we try to catch SparkException and PrestoSparkExecutionException in line 357?\n\nIt feels like more just a matter of taste. We can try to catch these two exceptions separately, but then we need to make sure we replicate the rollback and query event logic correctly. We can refactor that logic into a separate method, as you suggested, but still I would prefer to have only a single block of exception handling, as it feels like it is easier to follow.", "author": "arhimondr", "createdAt": "2020-05-20T15:55:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzczODg4Mw=="}], "type": "inlineReview"}, {"oid": "d5e65d0f143d601748ad250a8d98a81f01f3a502", "url": "https://github.com/prestodb/presto/commit/d5e65d0f143d601748ad250a8d98a81f01f3a502", "message": "Implement values in Presto on Spark", "committedDate": "2020-05-20T14:48:41Z", "type": "commit"}, {"oid": "40173ef09eca37f3b28d015c282281a3fe64746d", "url": "https://github.com/prestodb/presto/commit/40173ef09eca37f3b28d015c282281a3fe64746d", "message": "Implement N-Way join and UNION ALL", "committedDate": "2020-05-20T14:48:41Z", "type": "commit"}, {"oid": "878f76ee066a8f25d3e9f57461184b44ac0827e9", "url": "https://github.com/prestodb/presto/commit/878f76ee066a8f25d3e9f57461184b44ac0827e9", "message": "Add PrestoSparkSettingsRequirements", "committedDate": "2020-05-20T15:48:16Z", "type": "commit"}, {"oid": "e9d94ea94aa73bf577bf7be76d5acfcfb8ce2242", "url": "https://github.com/prestodb/presto/commit/e9d94ea94aa73bf577bf7be76d5acfcfb8ce2242", "message": "Support broadcast union\n\nPresto on Spark does not support round robin partitioning.\nRound robin partitioning is very expensive in Spark and should be avoided.\nFor now unions are collected into a single node. Given there's not that many\nquery shapes that would result in such plan it should be fine as a temporary\nsolution. However long term we should support multiple table scans in the\nfragment to avoid such suboptimal union planning.", "committedDate": "2020-05-20T15:48:56Z", "type": "commit"}, {"oid": "4740a10cb3fab3d3536564c504402d79db5fdfea", "url": "https://github.com/prestodb/presto/commit/4740a10cb3fab3d3536564c504402d79db5fdfea", "message": "Support nulls in results for Presto on Spark", "committedDate": "2020-05-20T15:48:58Z", "type": "commit"}, {"oid": "5161a011737217a3e1482babd45c0c4f93d1ddb3", "url": "https://github.com/prestodb/presto/commit/5161a011737217a3e1482babd45c0c4f93d1ddb3", "message": "Propagate exceptions from executor to driver\n\nSpark embeds the exception thrown on executor into SparkException as a message.\nSo we have to manually encode and decode the actual Presto exception.", "committedDate": "2020-05-20T15:57:01Z", "type": "commit"}, {"oid": "8d9cdfdb8a6af2037112b3315aefc9868de88fe7", "url": "https://github.com/prestodb/presto/commit/8d9cdfdb8a6af2037112b3315aefc9868de88fe7", "message": "Run AbstractTestQueries suite with Presto on Spark", "committedDate": "2020-05-20T15:57:04Z", "type": "commit"}, {"oid": "570c9d3f9d178de1e1def2ce44fcb6a716918daa", "url": "https://github.com/prestodb/presto/commit/570c9d3f9d178de1e1def2ce44fcb6a716918daa", "message": "Collect input rdds in parallel", "committedDate": "2020-05-20T15:57:04Z", "type": "commit"}, {"oid": "90a2798df8d7a1f8e3901e6ee124492050e63e4d", "url": "https://github.com/prestodb/presto/commit/90a2798df8d7a1f8e3901e6ee124492050e63e4d", "message": "Do not close testing SparkContext that is still in use\n\nMultiple SparkContext per JVM is not supported, thus we have to\nmaintain a single SparkContext. This commit prevents the context\nfrom being closed while it is still in use by a SparkQueryRunner\ninstance.", "committedDate": "2020-05-20T15:57:04Z", "type": "commit"}, {"oid": "90a2798df8d7a1f8e3901e6ee124492050e63e4d", "url": "https://github.com/prestodb/presto/commit/90a2798df8d7a1f8e3901e6ee124492050e63e4d", "message": "Do not close testing SparkContext that is still in use\n\nMultiple SparkContext per JVM is not supported, thus we have to\nmaintain a single SparkContext. This commit prevents the context\nfrom being closed while it is still in use by a SparkQueryRunner\ninstance.", "committedDate": "2020-05-20T15:57:04Z", "type": "forcePushed"}]}