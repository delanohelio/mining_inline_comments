{"pr_number": 14845, "pr_title": "Support evaluating min/max only metadata query", "pr_createdAt": "2020-07-16T01:27:23Z", "pr_url": "https://github.com/prestodb/presto/pull/14845", "timeline": [{"oid": "2493b37a92cd40f3b696c1d9827785562235f958", "url": "https://github.com/prestodb/presto/commit/2493b37a92cd40f3b696c1d9827785562235f958", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan.", "committedDate": "2020-07-16T05:32:46Z", "type": "forcePushed"}, {"oid": "0656169ffe79a4441e0dba3112745d0d2b7a1f1a", "url": "https://github.com/prestodb/presto/commit/0656169ffe79a4441e0dba3112745d0d2b7a1f1a", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan.", "committedDate": "2020-07-16T18:07:26Z", "type": "forcePushed"}, {"oid": "abeffefc0147352aeba3d00881d6ea5734c739a9", "url": "https://github.com/prestodb/presto/commit/abeffefc0147352aeba3d00881d6ea5734c739a9", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan.", "committedDate": "2020-07-18T17:15:52Z", "type": "forcePushed"}, {"oid": "d5a5fe94b49dd6324a3ab6fb2951cef4ab5f4f80", "url": "https://github.com/prestodb/presto/commit/d5a5fe94b49dd6324a3ab6fb2951cef4ab5f4f80", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan.", "committedDate": "2020-07-22T17:12:59Z", "type": "forcePushed"}, {"oid": "3756a124d7458297be7ea623c0bb057efaa99e5b", "url": "https://github.com/prestodb/presto/commit/3756a124d7458297be7ea623c0bb057efaa99e5b", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan.", "committedDate": "2020-07-23T00:19:37Z", "type": "forcePushed"}, {"oid": "6d81914bc64fd689380223cf788cdb27e0aae19e", "url": "https://github.com/prestodb/presto/commit/6d81914bc64fd689380223cf788cdb27e0aae19e", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan.", "committedDate": "2020-07-23T00:30:42Z", "type": "forcePushed"}, {"oid": "bfca28aa15a51d2441bd2140834481c354c58ea5", "url": "https://github.com/prestodb/presto/commit/bfca28aa15a51d2441bd2140834481c354c58ea5", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan.", "committedDate": "2020-07-23T01:12:03Z", "type": "forcePushed"}, {"oid": "a7030b174b59c2f5afd40fc5b9f91492b4573cd4", "url": "https://github.com/prestodb/presto/commit/a7030b174b59c2f5afd40fc5b9f91492b4573cd4", "message": "Push expression translation above MetadataQueryOptimizer", "committedDate": "2020-07-23T17:40:29Z", "type": "commit"}, {"oid": "04fcf53e29f2bac8fac5bf39285fbf204156d48c", "url": "https://github.com/prestodb/presto/commit/04fcf53e29f2bac8fac5bf39285fbf204156d48c", "message": "Allow EnforceSingleRowNode for predicate extractor\n\nAssuming we have a daily ingested table that is partitioned on ds,\na filter like `ds = (SELECT '2020-07-01')` is converted into an\nINNER JOIN, but this value is not passed to the other side of Join,\nwhich leads to full table scan.\n\nThis commit will enable this value being treated as predicate, and\nthus we only need to read this one partition.", "committedDate": "2020-07-23T17:40:29Z", "type": "commit"}, {"oid": "be7331a304d6abc02e2b83b91684e359562cbd4f", "url": "https://github.com/prestodb/presto/commit/be7331a304d6abc02e2b83b91684e359562cbd4f", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan.", "committedDate": "2020-07-23T18:21:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA0MzE5NA==", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461043194", "bodyText": "Breakdown the params into multiple lines\n        queryRunner.execute(\n                shufflePartitionColumns,\n                \"CREATE TABLE test_metadata_aggregation_folding WITH (partitioned_by = ARRAY['ds']) AS \" +\n                        \"SELECT orderkey, CAST(to_iso8601(date_add('DAY', orderkey % 7, date('2020-07-01'))) AS VARCHAR) AS ds FROM orders WHERE orderkey < 1000\");", "author": "highker", "createdAt": "2020-07-27T17:13:40Z", "path": "presto-hive/src/test/java/com/facebook/presto/hive/TestHiveLogicalPlanner.java", "diffHunk": "@@ -277,6 +280,83 @@ public void testPartitionPruning()\n         }\n     }\n \n+    @Test\n+    public void testMetadataAggregationFolding()\n+    {\n+        QueryRunner queryRunner = getQueryRunner();\n+        Session optimizeMetadataQueries = Session.builder(this.getQueryRunner().getDefaultSession())\n+                .setSystemProperty(OPTIMIZE_METADATA_QUERIES, Boolean.toString(true))\n+                .build();\n+        Session shufflePartitionColumns = Session.builder(this.getQueryRunner().getDefaultSession())\n+                .setCatalogSessionProperty(HIVE_CATALOG, SHUFFLE_PARTITIONED_COLUMNS_FOR_TABLE_WRITE, Boolean.toString(true))\n+                .build();\n+\n+        queryRunner.execute(shufflePartitionColumns, \"CREATE TABLE test_metadata_aggregation_folding WITH (partitioned_by = ARRAY['ds']) AS \" +\n+                \"SELECT orderkey, CAST(to_iso8601(date_add('DAY', orderkey % 7, date('2020-07-01'))) AS VARCHAR) AS ds FROM orders WHERE orderkey < 1000\");\n+        queryRunner.execute(shufflePartitionColumns, \"CREATE TABLE test_metadata_aggregation_folding_more_partitions WITH (partitioned_by = ARRAY['ds']) AS \" +\n+                \"SELECT orderkey, CAST(to_iso8601(date_add('DAY', orderkey % 200, date('2020-07-01'))) AS VARCHAR) AS ds FROM orders WHERE orderkey < 1000\");\n+        queryRunner.execute(shufflePartitionColumns, \"CREATE TABLE test_metadata_aggregation_folding_null_partitions WITH (partitioned_by = ARRAY['ds']) AS \" +\n+                \"SELECT orderkey, CAST(to_iso8601(date_add('DAY', orderkey % 7, date('2020-07-01'))) AS VARCHAR) AS ds FROM orders WHERE orderkey < 1000\");\n+        queryRunner.execute(shufflePartitionColumns, \"INSERT INTO test_metadata_aggregation_folding_null_partitions SELECT 0 as orderkey, null AS ds\");", "originalCommit": "be7331a304d6abc02e2b83b91684e359562cbd4f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA0ODU5Nw==", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461048597", "bodyText": "Maybe add a helper function when isReducible(node) is true and put the new logic there? This function is already pretty big.", "author": "highker", "createdAt": "2020-07-27T17:22:42Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "diffHunk": "@@ -151,31 +166,111 @@ public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> cont\n                 return context.defaultRewrite(node);\n             }\n \n-            ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n-            for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n-                if (!domain.isNone()) {\n-                    Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+            if (!isReducible(node)) {", "originalCommit": "be7331a304d6abc02e2b83b91684e359562cbd4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE1MDcwNA==", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461150704", "bodyText": "I extracted the newly added code into reduce (after changing reduce to evaluateMinMax). Also flipped the if statement so it looks like early return pattern.", "author": "shixuan-fan", "createdAt": "2020-07-27T20:29:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA0ODU5Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA0OTgxNA==", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461049814", "bodyText": "if (domain.isNone()) {\n    continue;\n}", "author": "highker", "createdAt": "2020-07-27T17:24:44Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "diffHunk": "@@ -151,31 +166,111 @@ public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> cont\n                 return context.defaultRewrite(node);\n             }\n \n-            ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n-            for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n-                if (!domain.isNone()) {\n-                    Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+            if (!isReducible(node)) {\n+                ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+\n+                        ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n+                        // for each input column, add a literal expression using the entry value\n+                        for (VariableReferenceExpression input : inputs) {\n+                            ColumnHandle column = columns.get(input);\n+                            NullableValue value = entries.get(column);\n+                            if (value == null) {\n+                                // partition key does not have a single value, so bail out to be safe\n+                                return context.defaultRewrite(node);\n+                            }\n+                            else {\n+                                rowBuilder.add(constant(value.getValue(), input.getType()));\n+                            }\n+                        }\n+                        rowsBuilder.add(rowBuilder.build());\n+                    }\n+                }\n \n-                    ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n-                    // for each input column, add a literal expression using the entry value\n-                    for (VariableReferenceExpression input : inputs) {\n-                        ColumnHandle column = columns.get(input);\n+                // replace the tablescan node with a values node\n+                return SimplePlanRewriter.rewriteWith(new Replacer(new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build())), node);\n+            }\n+\n+            // Fold min/max aggregations to a constant value\n+            ImmutableList.Builder<RowExpression> scalarsBuilder = ImmutableList.builder();\n+            for (int i = 0; i < inputs.size(); i++) {\n+                ImmutableList.Builder<RowExpression> arguments = ImmutableList.builder();\n+                ColumnHandle column = columns.get(inputs.get(i));\n+                // for each input column, add a literal expression using the entry value\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {", "originalCommit": "be7331a304d6abc02e2b83b91684e359562cbd4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE1MTc4MQ==", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461151781", "bodyText": "This is following the existing code, but I agree with the proposed change. Also changed the original code as well.", "author": "shixuan-fan", "createdAt": "2020-07-27T20:31:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA0OTgxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA1MzY3Ng==", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461053676", "bodyText": "evaluateMinMax", "author": "highker", "createdAt": "2020-07-27T17:30:59Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "diffHunk": "@@ -151,31 +166,111 @@ public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> cont\n                 return context.defaultRewrite(node);\n             }\n \n-            ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n-            for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n-                if (!domain.isNone()) {\n-                    Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+            if (!isReducible(node)) {\n+                ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+\n+                        ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n+                        // for each input column, add a literal expression using the entry value\n+                        for (VariableReferenceExpression input : inputs) {\n+                            ColumnHandle column = columns.get(input);\n+                            NullableValue value = entries.get(column);\n+                            if (value == null) {\n+                                // partition key does not have a single value, so bail out to be safe\n+                                return context.defaultRewrite(node);\n+                            }\n+                            else {\n+                                rowBuilder.add(constant(value.getValue(), input.getType()));\n+                            }\n+                        }\n+                        rowsBuilder.add(rowBuilder.build());\n+                    }\n+                }\n \n-                    ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n-                    // for each input column, add a literal expression using the entry value\n-                    for (VariableReferenceExpression input : inputs) {\n-                        ColumnHandle column = columns.get(input);\n+                // replace the tablescan node with a values node\n+                return SimplePlanRewriter.rewriteWith(new Replacer(new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build())), node);\n+            }\n+\n+            // Fold min/max aggregations to a constant value\n+            ImmutableList.Builder<RowExpression> scalarsBuilder = ImmutableList.builder();\n+            for (int i = 0; i < inputs.size(); i++) {\n+                ImmutableList.Builder<RowExpression> arguments = ImmutableList.builder();\n+                ColumnHandle column = columns.get(inputs.get(i));\n+                // for each input column, add a literal expression using the entry value\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n                         NullableValue value = entries.get(column);\n                         if (value == null) {\n                             // partition key does not have a single value, so bail out to be safe\n                             return context.defaultRewrite(node);\n                         }\n-                        else {\n-                            rowBuilder.add(constant(value.getValue(), input.getType()));\n+                        // min/max ignores null value\n+                        else if (value.getValue() != null) {\n+                            Type type = inputs.get(i).getType();\n+                            arguments.add(constant(value.getValue(), type));\n                         }\n                     }\n-                    rowsBuilder.add(rowBuilder.build());\n                 }\n+                scalarsBuilder.add(reduce(\n+                        metadata.getFunctionManager().getFunctionMetadata(node.getAggregations().get(node.getOutputVariables().get(i)).getFunctionHandle()),\n+                        arguments.build()));\n             }\n+            List<RowExpression> scalars = scalarsBuilder.build();\n \n-            // replace the tablescan node with a values node\n-            ValuesNode valuesNode = new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build());\n-            return SimplePlanRewriter.rewriteWith(new Replacer(valuesNode), node);\n+            Assignments.Builder assignments = Assignments.builder();\n+            for (int i = 0; i < node.getOutputVariables().size(); i++) {\n+                assignments.put(node.getOutputVariables().get(i), scalars.get(i));\n+            }\n+            ValuesNode valuesNode = new ValuesNode(idAllocator.getNextId(), inputs, ImmutableList.of(scalars));\n+            return new ProjectNode(idAllocator.getNextId(), valuesNode, assignments.build());\n+        }\n+\n+        private boolean isReducible(AggregationNode node)\n+        {\n+            if (node.getAggregations().isEmpty() || !(node.getSource() instanceof TableScanNode)) {\n+                return false;\n+            }\n+            for (Aggregation aggregation : node.getAggregations().values()) {\n+                FunctionMetadata functionMetadata = metadata.getFunctionManager().getFunctionMetadata(aggregation.getFunctionHandle());\n+                if (!AGGREGATION_SCALAR_MAPPING.containsKey(functionMetadata.getName()) || functionMetadata.getArgumentTypes().size() > 1) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        private RowExpression reduce(FunctionMetadata aggregationFunctionMetadata, List<RowExpression> arguments)", "originalCommit": "be7331a304d6abc02e2b83b91684e359562cbd4f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA1NzAzNw==", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461057037", "bodyText": "Use the util in Expressions to build CallExpression", "author": "highker", "createdAt": "2020-07-27T17:36:53Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "diffHunk": "@@ -151,31 +166,111 @@ public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> cont\n                 return context.defaultRewrite(node);\n             }\n \n-            ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n-            for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n-                if (!domain.isNone()) {\n-                    Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+            if (!isReducible(node)) {\n+                ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+\n+                        ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n+                        // for each input column, add a literal expression using the entry value\n+                        for (VariableReferenceExpression input : inputs) {\n+                            ColumnHandle column = columns.get(input);\n+                            NullableValue value = entries.get(column);\n+                            if (value == null) {\n+                                // partition key does not have a single value, so bail out to be safe\n+                                return context.defaultRewrite(node);\n+                            }\n+                            else {\n+                                rowBuilder.add(constant(value.getValue(), input.getType()));\n+                            }\n+                        }\n+                        rowsBuilder.add(rowBuilder.build());\n+                    }\n+                }\n \n-                    ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n-                    // for each input column, add a literal expression using the entry value\n-                    for (VariableReferenceExpression input : inputs) {\n-                        ColumnHandle column = columns.get(input);\n+                // replace the tablescan node with a values node\n+                return SimplePlanRewriter.rewriteWith(new Replacer(new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build())), node);\n+            }\n+\n+            // Fold min/max aggregations to a constant value\n+            ImmutableList.Builder<RowExpression> scalarsBuilder = ImmutableList.builder();\n+            for (int i = 0; i < inputs.size(); i++) {\n+                ImmutableList.Builder<RowExpression> arguments = ImmutableList.builder();\n+                ColumnHandle column = columns.get(inputs.get(i));\n+                // for each input column, add a literal expression using the entry value\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n                         NullableValue value = entries.get(column);\n                         if (value == null) {\n                             // partition key does not have a single value, so bail out to be safe\n                             return context.defaultRewrite(node);\n                         }\n-                        else {\n-                            rowBuilder.add(constant(value.getValue(), input.getType()));\n+                        // min/max ignores null value\n+                        else if (value.getValue() != null) {\n+                            Type type = inputs.get(i).getType();\n+                            arguments.add(constant(value.getValue(), type));\n                         }\n                     }\n-                    rowsBuilder.add(rowBuilder.build());\n                 }\n+                scalarsBuilder.add(reduce(\n+                        metadata.getFunctionManager().getFunctionMetadata(node.getAggregations().get(node.getOutputVariables().get(i)).getFunctionHandle()),\n+                        arguments.build()));\n             }\n+            List<RowExpression> scalars = scalarsBuilder.build();\n \n-            // replace the tablescan node with a values node\n-            ValuesNode valuesNode = new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build());\n-            return SimplePlanRewriter.rewriteWith(new Replacer(valuesNode), node);\n+            Assignments.Builder assignments = Assignments.builder();\n+            for (int i = 0; i < node.getOutputVariables().size(); i++) {\n+                assignments.put(node.getOutputVariables().get(i), scalars.get(i));\n+            }\n+            ValuesNode valuesNode = new ValuesNode(idAllocator.getNextId(), inputs, ImmutableList.of(scalars));\n+            return new ProjectNode(idAllocator.getNextId(), valuesNode, assignments.build());\n+        }\n+\n+        private boolean isReducible(AggregationNode node)\n+        {\n+            if (node.getAggregations().isEmpty() || !(node.getSource() instanceof TableScanNode)) {\n+                return false;\n+            }\n+            for (Aggregation aggregation : node.getAggregations().values()) {\n+                FunctionMetadata functionMetadata = metadata.getFunctionManager().getFunctionMetadata(aggregation.getFunctionHandle());\n+                if (!AGGREGATION_SCALAR_MAPPING.containsKey(functionMetadata.getName()) || functionMetadata.getArgumentTypes().size() > 1) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        private RowExpression reduce(FunctionMetadata aggregationFunctionMetadata, List<RowExpression> arguments)\n+        {\n+            QualifiedFunctionName scalarFunctionName = AGGREGATION_SCALAR_MAPPING.get(aggregationFunctionMetadata.getName());\n+            Type returnType = metadata.getTypeManager().getType(aggregationFunctionMetadata.getReturnType());\n+            while (arguments.size() > 1) {\n+                List<RowExpression> reducedArguments = new ArrayList<>();\n+                // We fold for every 100 values because GREATEST/LEAST has argument count limit\n+                for (List<RowExpression> partitionedArguments : Lists.partition(arguments, 100)) {\n+                    List<TypeSignatureProvider> typeSignatureProviders = partitionedArguments.stream()\n+                            .map(RowExpression::getType)\n+                            .map(Type::getTypeSignature)\n+                            .map(TypeSignatureProvider::new)\n+                            .collect(toImmutableList());\n+                    Object reducedValue = evaluateConstantRowExpression(\n+                            new CallExpression(\n+                                    scalarFunctionName.getFunctionName(),\n+                                    metadata.getFunctionManager().resolveFunction(Optional.empty(), scalarFunctionName, typeSignatureProviders),\n+                                    returnType,\n+                                    partitionedArguments),\n+                            metadata,\n+                            session.toConnectorSession());", "originalCommit": "be7331a304d6abc02e2b83b91684e359562cbd4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE1NTI1Mg==", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461155252", "bodyText": "Not aware of this. Looks so much better.", "author": "shixuan-fan", "createdAt": "2020-07-27T20:38:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA1NzAzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA1ODM5Mg==", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461058392", "bodyText": "When will the result be null?", "author": "highker", "createdAt": "2020-07-27T17:39:26Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/optimizations/MetadataQueryOptimizer.java", "diffHunk": "@@ -151,31 +166,111 @@ public PlanNode visitAggregation(AggregationNode node, RewriteContext<Void> cont\n                 return context.defaultRewrite(node);\n             }\n \n-            ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n-            for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n-                if (!domain.isNone()) {\n-                    Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+            if (!isReducible(node)) {\n+                ImmutableList.Builder<List<RowExpression>> rowsBuilder = ImmutableList.builder();\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n+\n+                        ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n+                        // for each input column, add a literal expression using the entry value\n+                        for (VariableReferenceExpression input : inputs) {\n+                            ColumnHandle column = columns.get(input);\n+                            NullableValue value = entries.get(column);\n+                            if (value == null) {\n+                                // partition key does not have a single value, so bail out to be safe\n+                                return context.defaultRewrite(node);\n+                            }\n+                            else {\n+                                rowBuilder.add(constant(value.getValue(), input.getType()));\n+                            }\n+                        }\n+                        rowsBuilder.add(rowBuilder.build());\n+                    }\n+                }\n \n-                    ImmutableList.Builder<RowExpression> rowBuilder = ImmutableList.builder();\n-                    // for each input column, add a literal expression using the entry value\n-                    for (VariableReferenceExpression input : inputs) {\n-                        ColumnHandle column = columns.get(input);\n+                // replace the tablescan node with a values node\n+                return SimplePlanRewriter.rewriteWith(new Replacer(new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build())), node);\n+            }\n+\n+            // Fold min/max aggregations to a constant value\n+            ImmutableList.Builder<RowExpression> scalarsBuilder = ImmutableList.builder();\n+            for (int i = 0; i < inputs.size(); i++) {\n+                ImmutableList.Builder<RowExpression> arguments = ImmutableList.builder();\n+                ColumnHandle column = columns.get(inputs.get(i));\n+                // for each input column, add a literal expression using the entry value\n+                for (TupleDomain<ColumnHandle> domain : predicates.getPredicates()) {\n+                    if (!domain.isNone()) {\n+                        Map<ColumnHandle, NullableValue> entries = TupleDomain.extractFixedValues(domain).get();\n                         NullableValue value = entries.get(column);\n                         if (value == null) {\n                             // partition key does not have a single value, so bail out to be safe\n                             return context.defaultRewrite(node);\n                         }\n-                        else {\n-                            rowBuilder.add(constant(value.getValue(), input.getType()));\n+                        // min/max ignores null value\n+                        else if (value.getValue() != null) {\n+                            Type type = inputs.get(i).getType();\n+                            arguments.add(constant(value.getValue(), type));\n                         }\n                     }\n-                    rowsBuilder.add(rowBuilder.build());\n                 }\n+                scalarsBuilder.add(reduce(\n+                        metadata.getFunctionManager().getFunctionMetadata(node.getAggregations().get(node.getOutputVariables().get(i)).getFunctionHandle()),\n+                        arguments.build()));\n             }\n+            List<RowExpression> scalars = scalarsBuilder.build();\n \n-            // replace the tablescan node with a values node\n-            ValuesNode valuesNode = new ValuesNode(idAllocator.getNextId(), inputs, rowsBuilder.build());\n-            return SimplePlanRewriter.rewriteWith(new Replacer(valuesNode), node);\n+            Assignments.Builder assignments = Assignments.builder();\n+            for (int i = 0; i < node.getOutputVariables().size(); i++) {\n+                assignments.put(node.getOutputVariables().get(i), scalars.get(i));\n+            }\n+            ValuesNode valuesNode = new ValuesNode(idAllocator.getNextId(), inputs, ImmutableList.of(scalars));\n+            return new ProjectNode(idAllocator.getNextId(), valuesNode, assignments.build());\n+        }\n+\n+        private boolean isReducible(AggregationNode node)\n+        {\n+            if (node.getAggregations().isEmpty() || !(node.getSource() instanceof TableScanNode)) {\n+                return false;\n+            }\n+            for (Aggregation aggregation : node.getAggregations().values()) {\n+                FunctionMetadata functionMetadata = metadata.getFunctionManager().getFunctionMetadata(aggregation.getFunctionHandle());\n+                if (!AGGREGATION_SCALAR_MAPPING.containsKey(functionMetadata.getName()) || functionMetadata.getArgumentTypes().size() > 1) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+\n+        private RowExpression reduce(FunctionMetadata aggregationFunctionMetadata, List<RowExpression> arguments)\n+        {\n+            QualifiedFunctionName scalarFunctionName = AGGREGATION_SCALAR_MAPPING.get(aggregationFunctionMetadata.getName());\n+            Type returnType = metadata.getTypeManager().getType(aggregationFunctionMetadata.getReturnType());\n+            while (arguments.size() > 1) {\n+                List<RowExpression> reducedArguments = new ArrayList<>();\n+                // We fold for every 100 values because GREATEST/LEAST has argument count limit\n+                for (List<RowExpression> partitionedArguments : Lists.partition(arguments, 100)) {\n+                    List<TypeSignatureProvider> typeSignatureProviders = partitionedArguments.stream()\n+                            .map(RowExpression::getType)\n+                            .map(Type::getTypeSignature)\n+                            .map(TypeSignatureProvider::new)\n+                            .collect(toImmutableList());\n+                    Object reducedValue = evaluateConstantRowExpression(\n+                            new CallExpression(\n+                                    scalarFunctionName.getFunctionName(),\n+                                    metadata.getFunctionManager().resolveFunction(Optional.empty(), scalarFunctionName, typeSignatureProviders),\n+                                    returnType,\n+                                    partitionedArguments),\n+                            metadata,\n+                            session.toConnectorSession());\n+                    reducedArguments.add(constant(reducedValue, returnType));\n+                }\n+                arguments = reducedArguments;\n+            }\n+            if (arguments.isEmpty()) {\n+                return constant(null, returnType);\n+            }", "originalCommit": "be7331a304d6abc02e2b83b91684e359562cbd4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE1Njk1Ng==", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461156956", "bodyText": "The result would be null if all values are null.", "author": "shixuan-fan", "createdAt": "2020-07-27T20:41:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA1ODM5Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE2MDU0Nw==", "url": "https://github.com/prestodb/presto/pull/14845#discussion_r461160547", "bodyText": "That being said, I should probably move this to be the first step of this function.", "author": "shixuan-fan", "createdAt": "2020-07-27T20:48:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA1ODM5Mg=="}], "type": "inlineReview"}, {"oid": "3435c2bfdaebd0e3870be4bd40fe79ad0a591707", "url": "https://github.com/prestodb/presto/commit/3435c2bfdaebd0e3870be4bd40fe79ad0a591707", "message": "Remove unused field in MetadataQueryOptimizer", "committedDate": "2020-07-27T20:13:01Z", "type": "commit"}, {"oid": "fe7b487c62014ab9cd4424eb44aeaee6853c8a86", "url": "https://github.com/prestodb/presto/commit/fe7b487c62014ab9cd4424eb44aeaee6853c8a86", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan.", "committedDate": "2020-07-27T20:44:52Z", "type": "forcePushed"}, {"oid": "d6df5fdb6b3ccd0edbd21e2de6952085c3b0af07", "url": "https://github.com/prestodb/presto/commit/d6df5fdb6b3ccd0edbd21e2de6952085c3b0af07", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan.", "committedDate": "2020-07-27T20:49:00Z", "type": "commit"}, {"oid": "d6df5fdb6b3ccd0edbd21e2de6952085c3b0af07", "url": "https://github.com/prestodb/presto/commit/d6df5fdb6b3ccd0edbd21e2de6952085c3b0af07", "message": "Support evaluating min/max only metadata query\n\nAssuming we have a daily ingested table that is partitioned on ds, one\ncommon use case is to fetch data from latest ds partition. One way to\ncompose such a query is using a filter like\n`ds = (SELECT max(ds) FROM table)`. However, this filter is converted\ninto an INNER JOIN, and will lead to a full table scan on the other\nside of join.\n\nInstead, this commit enables a query like `SELECT max(ds) FROM table`\nbeing evaluated at optimization time when OPTIMIZE_METADATA_QUERIES\nis set to true, and convert it into a ValuesNode, which could then\nbe pushed to the other side of Join to avoid expensive full table\nscan.", "committedDate": "2020-07-27T20:49:00Z", "type": "forcePushed"}]}