{"pr_number": 15522, "pr_title": "Initialize memory limits once", "pr_createdAt": "2020-12-15T15:48:57Z", "pr_url": "https://github.com/prestodb/presto/pull/15522", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUzNjQwMA==", "url": "https://github.com/prestodb/presto/pull/15522#discussion_r543536400", "bodyText": "It's unclear to me if it's intentional (or desirable) that a task update would previously cause these values to change once a query was promoted to the reserved pool. If so, it's easy enough to modify this PR to handle that as well- just need to know the intended behavior in that situation.", "author": "pettyjamesm", "createdAt": "2020-12-15T17:21:24Z", "path": "presto-main/src/main/java/com/facebook/presto/memory/QueryContext.java", "diffHunk": "@@ -129,13 +131,20 @@ public QueryContext(\n                 newRootAggregatedMemoryContext(new QueryMemoryReservationHandler(this::updateSystemMemory, this::tryReserveMemoryNotSupported, this::updateBroadcastMemory, this::tryUpdateBroadcastMemory), 0L));\n     }\n \n+    public boolean needsMemoryLimitsInitialized()\n+    {\n+        return needsMemoryLimitsInitialized;\n+    }\n+\n     // TODO: This method should be removed, and the correct limit set in the constructor. However, due to the way QueryContext is constructed the memory limit is not known in advance\n     public synchronized void setResourceOvercommit()\n     {\n         // Allow the query to use the entire pool. This way the worker will kill the query, if it uses the entire local general pool.\n         // The coordinator will kill the query if the cluster runs out of memory.\n         maxUserMemory = memoryPool.getMaxBytes();", "originalCommit": "54b228185dc305e51bf21f77633ce22c0e7e4408", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzU2MjYwNw==", "url": "https://github.com/prestodb/presto/pull/15522#discussion_r543562607", "bodyText": "Since it's unclear what the intended or correct interaction between resource over-commit and the reserved pool should be in this scenario, I've opted to preserve the current effective behavior by modifying the memory limits for resource over-commit queries as part of their memory pool change.", "author": "pettyjamesm", "createdAt": "2020-12-15T17:56:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUzNjQwMA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYyMzk3NQ==", "url": "https://github.com/prestodb/presto/pull/15522#discussion_r543623975", "bodyText": "This change makes sense to me. The limit on resource over commit should be all available memory in the pool. We don't want to fail without using the entire pool. If the reserve pool happens to be larger then we want to use it.\nI don't see that as being common but whatever :-)", "author": "aweisberg", "createdAt": "2020-12-15T19:24:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzUzNjQwMA=="}], "type": "inlineReview"}, {"oid": "2aa92bfd6bdd8fe46624d9519102b4158e8c14ad", "url": "https://github.com/prestodb/presto/commit/2aa92bfd6bdd8fe46624d9519102b4158e8c14ad", "message": "Fix typo in ConcurrentHashMap creation", "committedDate": "2020-12-15T17:52:49Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYxNTU4Mg==", "url": "https://github.com/prestodb/presto/pull/15522#discussion_r543615582", "bodyText": "Would this need to be volatile for needsMemoryLimitsInitialized to return an up to date value without synchronization with other threads?", "author": "aweisberg", "createdAt": "2020-12-15T19:11:50Z", "path": "presto-main/src/main/java/com/facebook/presto/memory/QueryContext.java", "diffHunk": "@@ -72,7 +72,11 @@\n     private final ScheduledExecutorService yieldExecutor;\n     private final long maxSpill;\n     private final SpillSpaceTracker spillSpaceTracker;\n-    private final Map<TaskId, TaskContext> taskContexts = new ConcurrentHashMap();\n+    private final Map<TaskId, TaskContext> taskContexts = new ConcurrentHashMap<>();\n+\n+    @GuardedBy(\"this\")\n+    private boolean isResourceOverCommit;\n+    private boolean needsMemoryLimitsInitialized = true;", "originalCommit": "2aa92bfd6bdd8fe46624d9519102b4158e8c14ad", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYyNDU0NA==", "url": "https://github.com/prestodb/presto/pull/15522#discussion_r543624544", "bodyText": "Ah, so you spotted it! I figured someone might. If it was more critical to avoid redundant initializations, you might indeed want to make it volatile (and I'm happy to do so if you feel strongly about it). The goal here is simply to avoid repeatedly contending for the QueryContext since all memory updates for the query also contend for that lock (very heavily, I might add). This is more of a \"best effort\" and it's not critical to definitely observe latest state since the failure mode is a redundant update (just like what happens today). Happy to change it that's what you'd prefer.", "author": "pettyjamesm", "createdAt": "2020-12-15T19:25:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYxNTU4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzY1MTE4OA==", "url": "https://github.com/prestodb/presto/pull/15522#discussion_r543651188", "bodyText": "OK, QueryContext is almost definitely safely published so we can rely on the default value.", "author": "aweisberg", "createdAt": "2020-12-15T20:06:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYxNTU4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM1ODA0OA==", "url": "https://github.com/prestodb/presto/pull/15522#discussion_r544358048", "bodyText": "Decided to make it volatile anyway since clearly this was going to be a recurring feedback item.", "author": "pettyjamesm", "createdAt": "2020-12-16T14:48:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MzYxNTU4Mg=="}], "type": "inlineReview"}, {"oid": "acde0bb5c2c154538e3ec23f16909098fc234889", "url": "https://github.com/prestodb/presto/commit/acde0bb5c2c154538e3ec23f16909098fc234889", "message": "Fix typo in ConcurrentHashMap creation", "committedDate": "2020-12-15T21:53:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc5MDA1MA==", "url": "https://github.com/prestodb/presto/pull/15522#discussion_r543790050", "bodyText": "isMemoryLimitsInitialized()", "author": "viczhang861", "createdAt": "2020-12-16T00:36:58Z", "path": "presto-main/src/main/java/com/facebook/presto/memory/QueryContext.java", "diffHunk": "@@ -129,13 +133,21 @@ public QueryContext(\n                 newRootAggregatedMemoryContext(new QueryMemoryReservationHandler(this::updateSystemMemory, this::tryReserveMemoryNotSupported, this::updateBroadcastMemory, this::tryUpdateBroadcastMemory), 0L));\n     }\n \n+    public boolean needsMemoryLimitsInitialized()", "originalCommit": "ae92bdd1d0fd69983e2aadc0022e6b5094431914", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc5MTg1MA==", "url": "https://github.com/prestodb/presto/pull/15522#discussion_r543791850", "bodyText": "if (!queryContext.isMemoryLimitsInitialized())", "author": "viczhang861", "createdAt": "2020-12-16T00:41:46Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/SqlTaskManager.java", "diffHunk": "@@ -389,19 +389,21 @@ public TaskInfo updateTask(\n         requireNonNull(sources, \"sources is null\");\n         requireNonNull(outputBuffers, \"outputBuffers is null\");\n \n-        if (resourceOvercommit(session)) {\n-            // TODO: This should have been done when the QueryContext was created. However, the session isn't available at that point.\n-            queryContexts.getUnchecked(taskId.getQueryId()).setResourceOvercommit();\n-        }\n-        else {\n-            queryContexts.getUnchecked(\n-                    taskId.getQueryId()).setMemoryLimits(\n-                    getQueryMaxMemoryPerNode(session),\n-                    getQueryMaxTotalMemoryPerNode(session),\n-                    getQueryMaxBroadcastMemory(session));\n+        SqlTask sqlTask = tasks.getUnchecked(taskId);\n+        QueryContext queryContext = sqlTask.getQueryContext();\n+        if (queryContext.needsMemoryLimitsInitialized()) {", "originalCommit": "ae92bdd1d0fd69983e2aadc0022e6b5094431914", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0NDM0NTI1OA==", "url": "https://github.com/prestodb/presto/pull/15522#discussion_r544345258", "bodyText": "Done", "author": "pettyjamesm", "createdAt": "2020-12-16T14:33:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0Mzc5MTg1MA=="}], "type": "inlineReview"}, {"oid": "a8312b1792f6e583fb6054e0d7929cdc050f7605", "url": "https://github.com/prestodb/presto/commit/a8312b1792f6e583fb6054e0d7929cdc050f7605", "message": "Fix javadoc method reference", "committedDate": "2020-12-16T14:31:42Z", "type": "forcePushed"}, {"oid": "3c0aba81cbd558158706696c02f993f7c272e4af", "url": "https://github.com/prestodb/presto/commit/3c0aba81cbd558158706696c02f993f7c272e4af", "message": "Avoid repeatedly setting memory limits in QueryContext\n\nSynchronizing on the QueryContext as part of every task update adds\ncontention to the already heavily contended QueryContext instance\n(since each memory tracking update must synchronize as well). This\nchange checks whether the memory limit initialization is necessary\nbefore synchronizing to avoid adding the extra contention after they\nhave been set at least once successfully.", "committedDate": "2020-12-16T14:40:04Z", "type": "commit"}, {"oid": "d1e15200c802a1da3db7c406203b994a3e281358", "url": "https://github.com/prestodb/presto/commit/d1e15200c802a1da3db7c406203b994a3e281358", "message": "Fix typo in ConcurrentHashMap creation", "committedDate": "2020-12-16T14:40:04Z", "type": "commit"}, {"oid": "924740ad3d15588b777ca33e48838b703bfc1054", "url": "https://github.com/prestodb/presto/commit/924740ad3d15588b777ca33e48838b703bfc1054", "message": "Fix javadoc method reference", "committedDate": "2020-12-16T14:40:26Z", "type": "commit"}, {"oid": "924740ad3d15588b777ca33e48838b703bfc1054", "url": "https://github.com/prestodb/presto/commit/924740ad3d15588b777ca33e48838b703bfc1054", "message": "Fix javadoc method reference", "committedDate": "2020-12-16T14:40:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODE4OTYzNA==", "url": "https://github.com/prestodb/presto/pull/15522#discussion_r548189634", "bodyText": "This statement looks quite weird.  if resource resourceOverCommit is true, then `setResourceOvercommit? -- looks unnecessary?\nMy understanding is we call setResourceOvercommit() to reset memory limits based on the pool assignment. If that's the case maybe elaborate a bit in the comment? e.g.\nWhile resourceOverCommit is already set to true, we still call setResourceOvercommit() to \nreset the memory limits based on the new pool assignment\n\n-- Just want to double check on this. I can edit the comment when merging it, since it's a very small change.", "author": "wenleix", "createdAt": "2020-12-23T20:00:47Z", "path": "presto-main/src/main/java/com/facebook/presto/memory/QueryContext.java", "diffHunk": "@@ -278,6 +290,10 @@ public synchronized void setMemoryPool(MemoryPool newMemoryPool)\n         }\n         ListenableFuture<?> future = memoryPool.moveQuery(queryId, newMemoryPool);\n         memoryPool = newMemoryPool;\n+        if (resourceOverCommit) {\n+            // Reset the memory limits based on the new pool assignment\n+            setResourceOvercommit();", "originalCommit": "924740ad3d15588b777ca33e48838b703bfc1054", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODE5MjE0MA==", "url": "https://github.com/prestodb/presto/pull/15522#discussion_r548192140", "bodyText": "Alternatively, you can just do what is done in the PrestoSQL repo right? https://github.com/prestosql/presto/pull/6349/files#diff-f218331177a9762b996c0276315db720a7b987ff7a0455aca45993db22a06b15R272 :)", "author": "wenleix", "createdAt": "2020-12-23T20:04:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODE4OTYzNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODE5MzI2Ng==", "url": "https://github.com/prestodb/presto/pull/15522#discussion_r548193266", "bodyText": "Actually, since it's confirmed by PrestoSQL side PR. I will just merge this :) . Leave minor comment tweak/ refactor as future work :)", "author": "wenleix", "createdAt": "2020-12-23T20:05:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODE4OTYzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0ODE5MDkzNg==", "url": "https://github.com/prestodb/presto/pull/15522#discussion_r548190936", "bodyText": "curious: is this also Guarded this? -- or we are based on benign data race?", "author": "wenleix", "createdAt": "2020-12-23T20:02:29Z", "path": "presto-main/src/main/java/com/facebook/presto/memory/QueryContext.java", "diffHunk": "@@ -72,7 +72,11 @@\n     private final ScheduledExecutorService yieldExecutor;\n     private final long maxSpill;\n     private final SpillSpaceTracker spillSpaceTracker;\n-    private final Map<TaskId, TaskContext> taskContexts = new ConcurrentHashMap();\n+    private final Map<TaskId, TaskContext> taskContexts = new ConcurrentHashMap<>();\n+\n+    @GuardedBy(\"this\")\n+    private boolean resourceOverCommit;\n+    private volatile boolean memoryLimitsInitialized;", "originalCommit": "924740ad3d15588b777ca33e48838b703bfc1054", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}