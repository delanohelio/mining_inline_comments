{"pr_number": 14155, "pr_title": "Predicate Pushdown for Druid connector", "pr_createdAt": "2020-02-25T03:42:06Z", "pr_url": "https://github.com/prestodb/presto/pull/14155", "timeline": [{"oid": "83ff8adbe9623e455bfeeb2756146b93cd43d73d", "url": "https://github.com/prestodb/presto/commit/83ff8adbe9623e455bfeeb2756146b93cd43d73d", "message": "Druid Connector PlanOptimizer", "committedDate": "2020-02-25T03:45:28Z", "type": "commit"}, {"oid": "50ef836520bce0d8cb55907d722ef69a2a9833b6", "url": "https://github.com/prestodb/presto/commit/50ef836520bce0d8cb55907d722ef69a2a9833b6", "message": "Predicate Pushdown for Druid connector", "committedDate": "2020-02-25T03:52:26Z", "type": "commit"}, {"oid": "2a2513b4d7a23179c5cc6ef36474ea99081aa400", "url": "https://github.com/prestodb/presto/commit/2a2513b4d7a23179c5cc6ef36474ea99081aa400", "message": "Add Testcase for Druid connector", "committedDate": "2020-02-25T03:52:36Z", "type": "commit"}, {"oid": "2a2513b4d7a23179c5cc6ef36474ea99081aa400", "url": "https://github.com/prestodb/presto/commit/2a2513b4d7a23179c5cc6ef36474ea99081aa400", "message": "Add Testcase for Druid connector", "committedDate": "2020-02-25T03:52:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY4ODAxMQ==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r383688011", "bodyText": "If it is only filter pushdown, getPhysicalPlanOptimizers is the better place to put the optimizer.", "author": "highker", "createdAt": "2020-02-25T06:53:33Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidConnector.java", "diffHunk": "@@ -74,6 +82,25 @@ public ConnectorPageSourceProvider getPageSourceProvider()\n         return pageSourceProvider;\n     }\n \n+    @Override\n+    public ConnectorPlanOptimizerProvider getConnectorPlanOptimizerProvider()\n+    {\n+        return new ConnectorPlanOptimizerProvider()\n+        {\n+            @Override\n+            public Set<ConnectorPlanOptimizer> getLogicalPlanOptimizers()\n+            {\n+                return ImmutableSet.of(planOptimizer);", "originalCommit": "2a2513b4d7a23179c5cc6ef36474ea99081aa400", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzczOTM4NA==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r383739384", "bodyText": "limit, aggregation pushdowns will be added in following step :)", "author": "zhenxiao", "createdAt": "2020-02-25T09:02:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY4ODAxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY5MDI2OQ==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r383690269", "bodyText": "This patch has many pinot-related concept. Is broker something for druid as well?", "author": "highker", "createdAt": "2020-02-25T07:00:50Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidBrokerPageSource.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.json.ObjectMapperProvider;\n+import com.facebook.presto.druid.DruidQueryGenerator.GeneratedDql;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPageSource;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.Page;\n+import com.facebook.presto.spi.PageBuilder;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.block.BlockBuilder;\n+import com.facebook.presto.spi.type.BigintType;\n+import com.facebook.presto.spi.type.DoubleType;\n+import com.facebook.presto.spi.type.RealType;\n+import com.facebook.presto.spi.type.TimestampType;\n+import com.facebook.presto.spi.type.Type;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import org.joda.time.DateTime;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_BROKER_RESULT_ERROR;\n+import static com.facebook.presto.util.DateTimeZoneIndex.getChronology;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidBrokerPageSource\n+        implements ConnectorPageSource\n+{\n+    private final ObjectMapper objecMapper = new ObjectMapperProvider().get();\n+    private final ConnectorSession session;\n+    private final GeneratedDql brokerDql;\n+    private final List<ColumnHandle> columnHandles;\n+    private final DruidClient druidClient;\n+\n+    private boolean finished;\n+    private long readTimeNanos;\n+    private long completedBytes;\n+    private long completedPositions;\n+\n+    public DruidBrokerPageSource(", "originalCommit": "2a2513b4d7a23179c5cc6ef36474ea99081aa400", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzczNjM0MA==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r383736340", "bodyText": "oh, yes, Druid has broker, too: https://druid.apache.org/docs/latest/design/broker.html", "author": "zhenxiao", "createdAt": "2020-02-25T08:56:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzY5MDI2OQ=="}], "type": "inlineReview"}, {"oid": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73", "url": "https://github.com/prestodb/presto/commit/bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73", "message": "Get rid of presto util dependency in Druid connector", "committedDate": "2020-02-25T09:10:16Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk4NzgwNg==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r383987806", "bodyText": "I wonder why this code looks so familiar :-)", "author": "agrawaldevesh", "createdAt": "2020-02-25T16:21:30Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidConnectorPlanOptimizer.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.expressions.LogicalRowExpressions;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPlanOptimizer;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.ConnectorTableHandle;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.VariableAllocator;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.inject.Inject;\n+\n+import java.util.ArrayList;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_QUERY_GENERATOR_FAILURE;\n+import static com.facebook.presto.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidConnectorPlanOptimizer\n+        implements ConnectorPlanOptimizer\n+{\n+    private final DruidQueryGenerator druidQueryGenerator;\n+    private final TypeManager typeManager;\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final LogicalRowExpressions logicalRowExpressions;\n+    private final StandardFunctionResolution standardFunctionResolution;\n+\n+    @Inject\n+    public DruidConnectorPlanOptimizer(\n+            DruidQueryGenerator druidQueryGenerator,\n+            TypeManager typeManager,\n+            FunctionMetadataManager functionMetadataManager,\n+            LogicalRowExpressions logicalRowExpressions,\n+            StandardFunctionResolution standardFunctionResolution)\n+    {\n+        this.druidQueryGenerator = requireNonNull(druidQueryGenerator, \"pinot query generator is null\");\n+        this.typeManager = requireNonNull(typeManager, \"type manager is null\");\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"function manager is null\");\n+        this.logicalRowExpressions = requireNonNull(logicalRowExpressions, \"logical row expressions is null\");\n+        this.standardFunctionResolution = requireNonNull(standardFunctionResolution, \"standard function resolution is null\");\n+    }\n+\n+    @Override\n+    public PlanNode optimize(PlanNode maxSubplan,\n+            ConnectorSession session,\n+            VariableAllocator variableAllocator,\n+            PlanNodeIdAllocator idAllocator)\n+    {\n+        Map<TableScanNode, Void> scanNodes = maxSubplan.accept(new TableFindingVisitor(), null);\n+        TableScanNode druidTableScanNode = getOnlyDruidTable(scanNodes)\n+                .orElseThrow(() -> new PrestoException(GENERIC_INTERNAL_ERROR,\n+                        \"Expected to find druid table handle for the scan node\"));\n+        return maxSubplan.accept(new Visitor(druidTableScanNode, session, idAllocator), null);\n+    }\n+\n+    private static Optional<DruidTableHandle> getDruidTableHandle(TableScanNode tableScanNode)\n+    {\n+        TableHandle table = tableScanNode.getTable();\n+        if (table != null) {\n+            ConnectorTableHandle connectorHandle = table.getConnectorHandle();\n+            if (connectorHandle instanceof DruidTableHandle) {\n+                return Optional.of((DruidTableHandle) connectorHandle);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private static Optional<TableScanNode> getOnlyDruidTable(Map<TableScanNode, Void> scanNodes)\n+    {\n+        if (scanNodes.size() == 1) {\n+            TableScanNode tableScanNode = scanNodes.keySet().iterator().next();\n+            if (getDruidTableHandle(tableScanNode).isPresent()) {\n+                return Optional.of(tableScanNode);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private static PlanNode replaceChildren(PlanNode node, List<PlanNode> children)\n+    {\n+        for (int i = 0; i < node.getSources().size(); i++) {\n+            if (children.get(i) != node.getSources().get(i)) {\n+                return node.replaceChildren(children);\n+            }\n+        }\n+        return node;\n+    }\n+\n+    private static class TableFindingVisitor\n+            extends PlanVisitor<Map<TableScanNode, Void>, Void>\n+    {\n+        @Override\n+        public Map<TableScanNode, Void> visitPlan(PlanNode node, Void context)\n+        {\n+            Map<TableScanNode, Void> ret = new IdentityHashMap<>();\n+            node.getSources().forEach(source -> ret.putAll(source.accept(this, context)));\n+            return ret;\n+        }\n+\n+        @Override\n+        public Map<TableScanNode, Void> visitTableScan(TableScanNode node, Void context)\n+        {\n+            Map<TableScanNode, Void> ret = new IdentityHashMap<>();\n+            ret.put(node, null);\n+            return ret;\n+        }\n+    }\n+\n+    private class Visitor\n+            extends PlanVisitor<PlanNode, Void>\n+    {\n+        private final PlanNodeIdAllocator idAllocator;\n+        private final ConnectorSession session;\n+        private final TableScanNode tableScanNode;\n+        private final IdentityHashMap<FilterNode, Void> filtersSplitUp = new IdentityHashMap<>();\n+\n+        public Visitor(TableScanNode tableScanNode, ConnectorSession session, PlanNodeIdAllocator idAllocator)\n+        {\n+            this.session = session;\n+            this.idAllocator = idAllocator;\n+            this.tableScanNode = tableScanNode;\n+            // Just making sure that the table exists\n+            getDruidTableHandle(this.tableScanNode).get().getTableName();\n+        }\n+\n+        private Optional<PlanNode> tryCreatingNewScanNode(PlanNode plan)", "originalCommit": "2a2513b4d7a23179c5cc6ef36474ea99081aa400", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDAyMzE3Mg==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384023172", "bodyText": "haha, yes, I copied a bunch of code from ur Pinot connector :)", "author": "zhenxiao", "createdAt": "2020-02-25T17:34:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk4NzgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDEwNjQ5MA==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384106490", "bodyText": "Hi @zhenxiao , It would help the reader if you could refer to the PR or commit of the Pinot connector optimizer PR/commit in your commit message. This code is basically identical to the Pinot connector and it would not only help with proper attribution but also if we subsequently need to fix some bugs in both the pinot/druid connectors.\nAlso, it would be great if you could think a bit about how we may refactor to share more common code b/w the pinot and the druid connector. What did you think about what we could refactor into a separate module ?\nThanks", "author": "agrawaldevesh", "createdAt": "2020-02-25T20:24:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk4NzgwNg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDExMzU0OA==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384113548", "bodyText": "Good idea. Yep, Pinot and Druid are similar. We could think about refactoring common code. I will add \"Reference Pinot Connector\" in the commit message. The optimizer code is similar. The code are not identical, Druid has its own segment scan log and broker page source. Logic for FilterExpressionConverter are different, too.", "author": "zhenxiao", "createdAt": "2020-02-25T20:40:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Mzk4NzgwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA1Njg4Ng==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384056886", "bodyText": "typo and make it static", "author": "highker", "createdAt": "2020-02-25T18:50:56Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidBrokerPageSource.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.json.ObjectMapperProvider;\n+import com.facebook.presto.druid.DruidQueryGenerator.GeneratedDql;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPageSource;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.Page;\n+import com.facebook.presto.spi.PageBuilder;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.block.BlockBuilder;\n+import com.facebook.presto.spi.type.BigintType;\n+import com.facebook.presto.spi.type.DoubleType;\n+import com.facebook.presto.spi.type.RealType;\n+import com.facebook.presto.spi.type.TimestampType;\n+import com.facebook.presto.spi.type.Type;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import org.joda.time.DateTime;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_BROKER_RESULT_ERROR;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidBrokerPageSource\n+        implements ConnectorPageSource\n+{\n+    private final ObjectMapper objecMapper = new ObjectMapperProvider().get();", "originalCommit": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA1Njk3Mw==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384056973", "bodyText": "convert to local var", "author": "highker", "createdAt": "2020-02-25T18:51:05Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidBrokerPageSource.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.json.ObjectMapperProvider;\n+import com.facebook.presto.druid.DruidQueryGenerator.GeneratedDql;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPageSource;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.Page;\n+import com.facebook.presto.spi.PageBuilder;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.block.BlockBuilder;\n+import com.facebook.presto.spi.type.BigintType;\n+import com.facebook.presto.spi.type.DoubleType;\n+import com.facebook.presto.spi.type.RealType;\n+import com.facebook.presto.spi.type.TimestampType;\n+import com.facebook.presto.spi.type.Type;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import org.joda.time.DateTime;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_BROKER_RESULT_ERROR;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidBrokerPageSource\n+        implements ConnectorPageSource\n+{\n+    private final ObjectMapper objecMapper = new ObjectMapperProvider().get();\n+    private final ConnectorSession session;", "originalCommit": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA1NzE4NA==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384057184", "bodyText": "requireNonNull on columnHandles", "author": "highker", "createdAt": "2020-02-25T18:51:29Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidBrokerPageSource.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.json.ObjectMapperProvider;\n+import com.facebook.presto.druid.DruidQueryGenerator.GeneratedDql;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPageSource;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.Page;\n+import com.facebook.presto.spi.PageBuilder;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.block.BlockBuilder;\n+import com.facebook.presto.spi.type.BigintType;\n+import com.facebook.presto.spi.type.DoubleType;\n+import com.facebook.presto.spi.type.RealType;\n+import com.facebook.presto.spi.type.TimestampType;\n+import com.facebook.presto.spi.type.Type;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import org.joda.time.DateTime;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_BROKER_RESULT_ERROR;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidBrokerPageSource\n+        implements ConnectorPageSource\n+{\n+    private final ObjectMapper objecMapper = new ObjectMapperProvider().get();\n+    private final ConnectorSession session;\n+    private final GeneratedDql brokerDql;\n+    private final List<ColumnHandle> columnHandles;\n+    private final DruidClient druidClient;\n+\n+    private boolean finished;\n+    private long readTimeNanos;\n+    private long completedBytes;\n+    private long completedPositions;\n+\n+    public DruidBrokerPageSource(\n+            ConnectorSession session,\n+            GeneratedDql brokerDql,\n+            List<ColumnHandle> columnHandles,\n+            DruidClient druidClient)\n+    {\n+        this.session = requireNonNull(session, \"session is null\");\n+        this.brokerDql = requireNonNull(brokerDql, \"broker is null\");\n+        this.columnHandles = ImmutableList.copyOf(columnHandles);", "originalCommit": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2MDAzMw==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384060033", "bodyText": "Let's get the instance size of this class", "author": "highker", "createdAt": "2020-02-25T18:56:31Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidBrokerPageSource.java", "diffHunk": "@@ -0,0 +1,181 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.json.ObjectMapperProvider;\n+import com.facebook.presto.druid.DruidQueryGenerator.GeneratedDql;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPageSource;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.Page;\n+import com.facebook.presto.spi.PageBuilder;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.block.BlockBuilder;\n+import com.facebook.presto.spi.type.BigintType;\n+import com.facebook.presto.spi.type.DoubleType;\n+import com.facebook.presto.spi.type.RealType;\n+import com.facebook.presto.spi.type.TimestampType;\n+import com.facebook.presto.spi.type.Type;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import org.joda.time.DateTime;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_BROKER_RESULT_ERROR;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidBrokerPageSource\n+        implements ConnectorPageSource\n+{\n+    private final ObjectMapper objecMapper = new ObjectMapperProvider().get();\n+    private final ConnectorSession session;\n+    private final GeneratedDql brokerDql;\n+    private final List<ColumnHandle> columnHandles;\n+    private final DruidClient druidClient;\n+\n+    private boolean finished;\n+    private long readTimeNanos;\n+    private long completedBytes;\n+    private long completedPositions;\n+\n+    public DruidBrokerPageSource(\n+            ConnectorSession session,\n+            GeneratedDql brokerDql,\n+            List<ColumnHandle> columnHandles,\n+            DruidClient druidClient)\n+    {\n+        this.session = requireNonNull(session, \"session is null\");\n+        this.brokerDql = requireNonNull(brokerDql, \"broker is null\");\n+        this.columnHandles = ImmutableList.copyOf(columnHandles);\n+        this.druidClient = requireNonNull(druidClient, \"druid client is null\");\n+    }\n+\n+    @Override\n+    public long getCompletedBytes()\n+    {\n+        return completedBytes;\n+    }\n+\n+    @Override\n+    public long getCompletedPositions()\n+    {\n+        return completedPositions;\n+    }\n+\n+    @Override\n+    public long getReadTimeNanos()\n+    {\n+        return readTimeNanos;\n+    }\n+\n+    @Override\n+    public boolean isFinished()\n+    {\n+        return finished;\n+    }\n+\n+    @Override\n+    public Page getNextPage()\n+    {\n+        if (finished) {\n+            return null;\n+        }\n+\n+        long start = System.nanoTime();\n+        try {\n+            List<DruidColumnHandle> handles = columnHandles.stream()\n+                    .map(column -> (DruidColumnHandle) column)\n+                    .collect(Collectors.toList());\n+\n+            List<Type> columnTypes = handles.stream()\n+                    .map(DruidColumnHandle::getColumnType)\n+                    .collect(Collectors.toList());\n+\n+            PageBuilder pageBuilder = new PageBuilder(columnTypes);\n+\n+            String data = druidClient.getData(brokerDql.getDql());\n+            JsonNode rootNode;\n+            try {\n+                rootNode = objecMapper.readTree(data);\n+                checkArgument(rootNode.isArray(), \"broker Druid query should return Json Array\");\n+                ArrayNode arrayNode = (ArrayNode) rootNode;\n+                Iterator<JsonNode> iterator = arrayNode.elements();\n+                while (iterator.hasNext()) {\n+                    JsonNode node = iterator.next();\n+                    for (int i = 0; i < columnHandles.size(); i++) {\n+                        Type type = columnTypes.get(i);\n+                        BlockBuilder blockBuilder = pageBuilder.getBlockBuilder(i);\n+                        JsonNode value = node.get(handles.get(i).getColumnName());\n+                        if (type instanceof BigintType) {\n+                            type.writeLong(blockBuilder, value.longValue());\n+                        }\n+                        if (type instanceof DoubleType) {\n+                            type.writeDouble(blockBuilder, value.doubleValue());\n+                        }\n+                        if (type instanceof RealType) {\n+                            type.writeDouble(blockBuilder, value.doubleValue());\n+                        }\n+                        else if (type instanceof TimestampType) {\n+                            DateTimeFormatter formatter = ISODateTimeFormat.dateTimeParser()\n+                                    .withChronology(ISOChronology.getInstanceUTC())\n+                                    .withOffsetParsed();\n+                            DateTime dateTime = formatter.parseDateTime(value.textValue());\n+                            type.writeLong(blockBuilder, dateTime.getMillis());\n+                        }\n+                        else {\n+                            Slice slice = Slices.utf8Slice(value.textValue());\n+                            blockBuilder.writeBytes(slice, 0, slice.length()).closeEntry();\n+                            completedBytes += slice.length();\n+                        }\n+                    }\n+                }\n+            }\n+            catch (IOException e) {\n+                throw new PrestoException(DRUID_BROKER_RESULT_ERROR, e);\n+            }\n+            pageBuilder.declarePositions(rootNode.size());\n+            Page page = pageBuilder.build();\n+            completedPositions += page.getPositionCount();\n+            finished = true;\n+            return page;\n+        }\n+        finally {\n+            readTimeNanos += System.nanoTime() - start;\n+        }\n+    }\n+\n+    @Override\n+    public long getSystemMemoryUsage()\n+    {\n+        return 0;", "originalCommit": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NDQ2Nw==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384064467", "bodyText": "add it to equals as well maybe", "author": "highker", "createdAt": "2020-02-25T19:04:24Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidColumnHandle.java", "diffHunk": "@@ -76,6 +100,13 @@ public String toString()\n         return toStringHelper(this)\n                 .add(\"columnName\", columnName)\n                 .add(\"columnType\", columnType)\n+                .add(\"type\", type)", "originalCommit": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NDk1OQ==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384064959", "bodyText": "maybe create a new class", "author": "highker", "createdAt": "2020-02-25T19:05:25Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidConnector.java", "diffHunk": "@@ -74,6 +82,25 @@ public ConnectorPageSourceProvider getPageSourceProvider()\n         return pageSourceProvider;\n     }\n \n+    @Override\n+    public ConnectorPlanOptimizerProvider getConnectorPlanOptimizerProvider()\n+    {\n+        return new ConnectorPlanOptimizerProvider()", "originalCommit": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI4ODYxNQ==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384288615", "bodyText": "Comment not addressed?", "author": "highker", "createdAt": "2020-02-26T06:00:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NDk1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NTM3OA==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384065378", "bodyText": "Kinda weird. LogicalRowExpressions can be created anytime than an injected singleton", "author": "highker", "createdAt": "2020-02-25T19:06:12Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidConnectorFactory.java", "diffHunk": "@@ -48,7 +53,13 @@ public Connector create(String catalogName, Map<String, String> config, Connecto\n         try {\n             Bootstrap app = new Bootstrap(\n                     new JsonModule(),\n-                    new DruidModule(context.getTypeManager()));\n+                    new DruidModule(), binder -> {\n+                binder.bind(TypeManager.class).toInstance(context.getTypeManager());\n+                binder.bind(FunctionMetadataManager.class).toInstance(context.getFunctionMetadataManager());\n+                binder.bind(RowExpressionService.class).toInstance(context.getRowExpressionService());\n+                binder.bind(LogicalRowExpressions.class).toInstance(new LogicalRowExpressions(context.getRowExpressionService().getDeterminismEvaluator(), context.getStandardFunctionResolution(), context.getFunctionMetadataManager()));", "originalCommit": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI4ODYzOQ==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384288639", "bodyText": "Comment not addressed?", "author": "highker", "createdAt": "2020-02-26T06:00:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NTM3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NTc3OQ==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384065779", "bodyText": "nit: put GENERIC_INTERNAL_ERROR to its own line", "author": "highker", "createdAt": "2020-02-25T19:06:59Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidConnectorPlanOptimizer.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.expressions.LogicalRowExpressions;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPlanOptimizer;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.ConnectorTableHandle;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.VariableAllocator;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.inject.Inject;\n+\n+import java.util.ArrayList;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_QUERY_GENERATOR_FAILURE;\n+import static com.facebook.presto.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidConnectorPlanOptimizer\n+        implements ConnectorPlanOptimizer\n+{\n+    private final DruidQueryGenerator druidQueryGenerator;\n+    private final TypeManager typeManager;\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final LogicalRowExpressions logicalRowExpressions;\n+    private final StandardFunctionResolution standardFunctionResolution;\n+\n+    @Inject\n+    public DruidConnectorPlanOptimizer(\n+            DruidQueryGenerator druidQueryGenerator,\n+            TypeManager typeManager,\n+            FunctionMetadataManager functionMetadataManager,\n+            LogicalRowExpressions logicalRowExpressions,\n+            StandardFunctionResolution standardFunctionResolution)\n+    {\n+        this.druidQueryGenerator = requireNonNull(druidQueryGenerator, \"pinot query generator is null\");\n+        this.typeManager = requireNonNull(typeManager, \"type manager is null\");\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"function manager is null\");\n+        this.logicalRowExpressions = requireNonNull(logicalRowExpressions, \"logical row expressions is null\");\n+        this.standardFunctionResolution = requireNonNull(standardFunctionResolution, \"standard function resolution is null\");\n+    }\n+\n+    @Override\n+    public PlanNode optimize(PlanNode maxSubplan,\n+            ConnectorSession session,\n+            VariableAllocator variableAllocator,\n+            PlanNodeIdAllocator idAllocator)\n+    {\n+        Map<TableScanNode, Void> scanNodes = maxSubplan.accept(new TableFindingVisitor(), null);\n+        TableScanNode druidTableScanNode = getOnlyDruidTable(scanNodes)\n+                .orElseThrow(() -> new PrestoException(GENERIC_INTERNAL_ERROR,", "originalCommit": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NjAxMw==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384066013", "bodyText": "spell out ret", "author": "highker", "createdAt": "2020-02-25T19:07:23Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidConnectorPlanOptimizer.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.expressions.LogicalRowExpressions;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPlanOptimizer;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.ConnectorTableHandle;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.VariableAllocator;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.inject.Inject;\n+\n+import java.util.ArrayList;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_QUERY_GENERATOR_FAILURE;\n+import static com.facebook.presto.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidConnectorPlanOptimizer\n+        implements ConnectorPlanOptimizer\n+{\n+    private final DruidQueryGenerator druidQueryGenerator;\n+    private final TypeManager typeManager;\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final LogicalRowExpressions logicalRowExpressions;\n+    private final StandardFunctionResolution standardFunctionResolution;\n+\n+    @Inject\n+    public DruidConnectorPlanOptimizer(\n+            DruidQueryGenerator druidQueryGenerator,\n+            TypeManager typeManager,\n+            FunctionMetadataManager functionMetadataManager,\n+            LogicalRowExpressions logicalRowExpressions,\n+            StandardFunctionResolution standardFunctionResolution)\n+    {\n+        this.druidQueryGenerator = requireNonNull(druidQueryGenerator, \"pinot query generator is null\");\n+        this.typeManager = requireNonNull(typeManager, \"type manager is null\");\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"function manager is null\");\n+        this.logicalRowExpressions = requireNonNull(logicalRowExpressions, \"logical row expressions is null\");\n+        this.standardFunctionResolution = requireNonNull(standardFunctionResolution, \"standard function resolution is null\");\n+    }\n+\n+    @Override\n+    public PlanNode optimize(PlanNode maxSubplan,\n+            ConnectorSession session,\n+            VariableAllocator variableAllocator,\n+            PlanNodeIdAllocator idAllocator)\n+    {\n+        Map<TableScanNode, Void> scanNodes = maxSubplan.accept(new TableFindingVisitor(), null);\n+        TableScanNode druidTableScanNode = getOnlyDruidTable(scanNodes)\n+                .orElseThrow(() -> new PrestoException(GENERIC_INTERNAL_ERROR,\n+                        \"Expected to find druid table handle for the scan node\"));\n+        return maxSubplan.accept(new Visitor(druidTableScanNode, session, idAllocator), null);\n+    }\n+\n+    private static Optional<DruidTableHandle> getDruidTableHandle(TableScanNode tableScanNode)\n+    {\n+        TableHandle table = tableScanNode.getTable();\n+        if (table != null) {\n+            ConnectorTableHandle connectorHandle = table.getConnectorHandle();\n+            if (connectorHandle instanceof DruidTableHandle) {\n+                return Optional.of((DruidTableHandle) connectorHandle);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private static Optional<TableScanNode> getOnlyDruidTable(Map<TableScanNode, Void> scanNodes)\n+    {\n+        if (scanNodes.size() == 1) {\n+            TableScanNode tableScanNode = scanNodes.keySet().iterator().next();\n+            if (getDruidTableHandle(tableScanNode).isPresent()) {\n+                return Optional.of(tableScanNode);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private static PlanNode replaceChildren(PlanNode node, List<PlanNode> children)\n+    {\n+        for (int i = 0; i < node.getSources().size(); i++) {\n+            if (children.get(i) != node.getSources().get(i)) {\n+                return node.replaceChildren(children);\n+            }\n+        }\n+        return node;\n+    }\n+\n+    private static class TableFindingVisitor\n+            extends PlanVisitor<Map<TableScanNode, Void>, Void>\n+    {\n+        @Override\n+        public Map<TableScanNode, Void> visitPlan(PlanNode node, Void context)\n+        {\n+            Map<TableScanNode, Void> ret = new IdentityHashMap<>();\n+            node.getSources().forEach(source -> ret.putAll(source.accept(this, context)));\n+            return ret;\n+        }\n+\n+        @Override\n+        public Map<TableScanNode, Void> visitTableScan(TableScanNode node, Void context)\n+        {\n+            Map<TableScanNode, Void> ret = new IdentityHashMap<>();", "originalCommit": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NjE1MQ==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384066151", "bodyText": "same", "author": "highker", "createdAt": "2020-02-25T19:07:41Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidConnectorPlanOptimizer.java", "diffHunk": "@@ -0,0 +1,229 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.expressions.LogicalRowExpressions;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPlanOptimizer;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.ConnectorTableHandle;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.VariableAllocator;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.inject.Inject;\n+\n+import java.util.ArrayList;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_QUERY_GENERATOR_FAILURE;\n+import static com.facebook.presto.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidConnectorPlanOptimizer\n+        implements ConnectorPlanOptimizer\n+{\n+    private final DruidQueryGenerator druidQueryGenerator;\n+    private final TypeManager typeManager;\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final LogicalRowExpressions logicalRowExpressions;\n+    private final StandardFunctionResolution standardFunctionResolution;\n+\n+    @Inject\n+    public DruidConnectorPlanOptimizer(\n+            DruidQueryGenerator druidQueryGenerator,\n+            TypeManager typeManager,\n+            FunctionMetadataManager functionMetadataManager,\n+            LogicalRowExpressions logicalRowExpressions,\n+            StandardFunctionResolution standardFunctionResolution)\n+    {\n+        this.druidQueryGenerator = requireNonNull(druidQueryGenerator, \"pinot query generator is null\");\n+        this.typeManager = requireNonNull(typeManager, \"type manager is null\");\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"function manager is null\");\n+        this.logicalRowExpressions = requireNonNull(logicalRowExpressions, \"logical row expressions is null\");\n+        this.standardFunctionResolution = requireNonNull(standardFunctionResolution, \"standard function resolution is null\");\n+    }\n+\n+    @Override\n+    public PlanNode optimize(PlanNode maxSubplan,\n+            ConnectorSession session,\n+            VariableAllocator variableAllocator,\n+            PlanNodeIdAllocator idAllocator)\n+    {\n+        Map<TableScanNode, Void> scanNodes = maxSubplan.accept(new TableFindingVisitor(), null);\n+        TableScanNode druidTableScanNode = getOnlyDruidTable(scanNodes)\n+                .orElseThrow(() -> new PrestoException(GENERIC_INTERNAL_ERROR,\n+                        \"Expected to find druid table handle for the scan node\"));\n+        return maxSubplan.accept(new Visitor(druidTableScanNode, session, idAllocator), null);\n+    }\n+\n+    private static Optional<DruidTableHandle> getDruidTableHandle(TableScanNode tableScanNode)\n+    {\n+        TableHandle table = tableScanNode.getTable();\n+        if (table != null) {\n+            ConnectorTableHandle connectorHandle = table.getConnectorHandle();\n+            if (connectorHandle instanceof DruidTableHandle) {\n+                return Optional.of((DruidTableHandle) connectorHandle);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private static Optional<TableScanNode> getOnlyDruidTable(Map<TableScanNode, Void> scanNodes)\n+    {\n+        if (scanNodes.size() == 1) {\n+            TableScanNode tableScanNode = scanNodes.keySet().iterator().next();\n+            if (getDruidTableHandle(tableScanNode).isPresent()) {\n+                return Optional.of(tableScanNode);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private static PlanNode replaceChildren(PlanNode node, List<PlanNode> children)\n+    {\n+        for (int i = 0; i < node.getSources().size(); i++) {\n+            if (children.get(i) != node.getSources().get(i)) {\n+                return node.replaceChildren(children);\n+            }\n+        }\n+        return node;\n+    }\n+\n+    private static class TableFindingVisitor\n+            extends PlanVisitor<Map<TableScanNode, Void>, Void>\n+    {\n+        @Override\n+        public Map<TableScanNode, Void> visitPlan(PlanNode node, Void context)\n+        {\n+            Map<TableScanNode, Void> ret = new IdentityHashMap<>();", "originalCommit": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NjUzMA==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384066530", "bodyText": "not used", "author": "highker", "createdAt": "2020-02-25T19:08:25Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -0,0 +1,210 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.log.Logger;\n+import com.facebook.presto.druid.DruidQueryGeneratorContext.Selection;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import javax.inject.Inject;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidQueryGeneratorContext.Origin.TABLE_COLUMN;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidQueryGenerator\n+{\n+    private static final Logger log = Logger.get(DruidQueryGenerator.class);\n+\n+    private final DruidConfig druidConfig;", "originalCommit": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NjY4Ng==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384066686", "bodyText": "remove stream()", "author": "highker", "createdAt": "2020-02-25T19:08:41Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGeneratorContext.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_QUERY_GENERATOR_FAILURE;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidQueryGeneratorContext\n+{\n+    private final LinkedHashMap<VariableReferenceExpression, Selection> selections;\n+    private final Optional<String> from;\n+    private final Optional<String> filter;\n+\n+    @Override\n+    public String toString()\n+    {\n+        return toStringHelper(this)\n+                .add(\"selections\", selections)\n+                .add(\"from\", from)\n+                .add(\"filter\", filter)\n+                .toString();\n+    }\n+\n+    DruidQueryGeneratorContext()\n+    {\n+        this(new LinkedHashMap<>(), null);\n+    }\n+\n+    DruidQueryGeneratorContext(\n+            LinkedHashMap<VariableReferenceExpression, Selection> selections,\n+            String from)\n+    {\n+        this(\n+                selections,\n+                Optional.ofNullable(from),\n+                Optional.empty());\n+    }\n+\n+    private DruidQueryGeneratorContext(\n+            LinkedHashMap<VariableReferenceExpression, Selection> selections,\n+            Optional<String> from,\n+            Optional<String> filter)\n+    {\n+        this.selections = new LinkedHashMap<>(requireNonNull(selections, \"selections can't be null\"));\n+        this.from = requireNonNull(from, \"source can't be null\");\n+        this.filter = requireNonNull(filter, \"filter is null\");\n+    }\n+\n+    public DruidQueryGeneratorContext withFilter(String filter)\n+    {\n+        checkArgument(!hasFilter(), \"Druid doesn't support filters at multiple levels\");\n+        return new DruidQueryGeneratorContext(\n+                selections,\n+                from,\n+                Optional.of(filter));\n+    }\n+\n+    public DruidQueryGeneratorContext withProject(LinkedHashMap<VariableReferenceExpression, Selection> newSelections)\n+    {\n+        return new DruidQueryGeneratorContext(\n+                newSelections,\n+                from,\n+                filter);\n+    }\n+\n+    private boolean hasFilter()\n+    {\n+        return filter.isPresent();\n+    }\n+\n+    public LinkedHashMap<VariableReferenceExpression, Selection> getSelections()\n+    {\n+        return selections;\n+    }\n+\n+    public DruidQueryGenerator.GeneratedDql toQuery()\n+    {\n+        String expressions = selections.entrySet().stream()\n+                .map(s -> s.getValue().getDefinition())\n+                .collect(Collectors.joining(\", \"));\n+        if (expressions.isEmpty()) {\n+            throw new PrestoException(DRUID_QUERY_GENERATOR_FAILURE, \"Empty Druid query\");\n+        }\n+\n+        String tableName = from.orElseThrow(() -> new PrestoException(DRUID_QUERY_GENERATOR_FAILURE, \"Table name missing in Druid query\"));\n+        String query = \"SELECT \" + expressions + \" FROM \" + tableName;\n+        if (filter.isPresent()) {\n+            String filterString = filter.get();\n+            // this is hack!!!. Ideally we want to clone the scan pipeline and create/update the filter in the scan pipeline to contain this filter and\n+            // at the same time add the time column to scan so that the query generator doesn't fail when it looks up the time column in scan output columns\n+            query += \" WHERE \" + filterString;\n+        }\n+        return new DruidQueryGenerator.GeneratedDql(tableName, query);\n+    }\n+\n+    public LinkedHashMap<VariableReferenceExpression, DruidColumnHandle> getAssignments()\n+    {\n+        LinkedHashMap<VariableReferenceExpression, DruidColumnHandle> result = new LinkedHashMap<>();\n+        selections.entrySet().stream().forEach(entry -> {", "originalCommit": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NzM4Mw==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384067383", "bodyText": "return address.map(ImmutableList::of).orElse(ImmutableList.of());", "author": "highker", "createdAt": "2020-02-25T19:10:04Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidSplit.java", "diffHunk": "@@ -62,12 +108,32 @@ public NodeSelectionStrategy getNodeSelectionStrategy()\n     @Override\n     public List<HostAddress> getPreferredNodes(List<HostAddress> sortedCandidates)\n     {\n-        return ImmutableList.of(address);\n+        if (address.isPresent()) {", "originalCommit": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NzQxOQ==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384067419", "bodyText": "remove", "author": "highker", "createdAt": "2020-02-25T19:10:08Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidSplit.java", "diffHunk": "@@ -22,33 +22,79 @@\n import com.google.common.collect.ImmutableList;\n \n import java.util.List;\n+import java.util.Optional;\n \n import static com.facebook.presto.spi.schedule.NodeSelectionStrategy.NO_PREFERENCE;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Preconditions.checkArgument;\n import static java.util.Objects.requireNonNull;\n \n public class DruidSplit\n         implements ConnectorSplit\n {\n-    private final DruidSegmentInfo segmentInfo;\n-    private final HostAddress address;\n+    private final SplitType splitType;\n+    private final Optional<DruidQueryGenerator.GeneratedDql> brokerDql;\n+    private final Optional<DruidSegmentInfo> segmentInfo;\n+    private final Optional<HostAddress> address;\n \n     @JsonCreator\n     public DruidSplit(\n-            @JsonProperty(\"segmentInfo\") DruidSegmentInfo segmentInfo,\n-            @JsonProperty(\"address\") HostAddress address)\n+            @JsonProperty(\"splitType\") SplitType splitType,\n+            @JsonProperty(\"brokerDql\") Optional<DruidQueryGenerator.GeneratedDql> brokerDql,\n+            @JsonProperty(\"segmentInfo\") Optional<DruidSegmentInfo> segmentInfo,\n+            @JsonProperty(\"address\") Optional<HostAddress> address)\n     {\n+        this.splitType = requireNonNull(splitType, \"splitType id is null\");\n+        this.brokerDql = requireNonNull(brokerDql, \"brokerDql is null\");\n         this.segmentInfo = requireNonNull(segmentInfo, \"segment info is null\");\n         this.address = requireNonNull(address, \"address info is null\");\n+        if (splitType == SplitType.SEGMENT) {\n+            checkArgument(segmentInfo.isPresent(), \"SegmentInfo is missing from split\");\n+            checkArgument(address.isPresent(), \"Address is missing from split\");\n+        }\n+        else {\n+            checkArgument(brokerDql.isPresent(), \"brokerDql is missing from the split\");\n+        }\n+    }\n+\n+    public static DruidSplit createBrokerSplit(DruidQueryGenerator.GeneratedDql brokerDql)\n+    {\n+        return new DruidSplit(\n+                SplitType.BROKER,\n+                Optional.of(requireNonNull(brokerDql, \"brokerDql is null\")),\n+                Optional.empty(),\n+                Optional.empty());\n+    }\n+\n+    public static DruidSplit createSegmentSplit(DruidSegmentInfo segmentInfo, HostAddress address)\n+    {\n+        return new DruidSplit(\n+                SplitType.SEGMENT,\n+                Optional.empty(),\n+                Optional.of(requireNonNull(segmentInfo, \"segmentInfo are null\")),\n+                Optional.of(requireNonNull(address, \"address is null\")));\n     }\n \n     @JsonProperty\n-    public DruidSegmentInfo getSegmentInfo()\n+    public SplitType getSplitType()\n+    {\n+        return splitType;\n+    }\n+\n+    @JsonProperty\n+    public Optional<DruidQueryGenerator.GeneratedDql> getBrokerDql()\n+    {\n+        return brokerDql;\n+    }\n+\n+    @JsonProperty\n+    public Optional<DruidSegmentInfo> getSegmentInfo()\n     {\n         return segmentInfo;\n     }\n \n     @JsonProperty\n-    public HostAddress getAddress()\n+    public Optional<HostAddress> getAddress()", "originalCommit": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDA2NzY4NQ==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384067685", "bodyText": "TestingMetadataUtil", "author": "highker", "createdAt": "2020-02-25T19:10:42Z", "path": "presto-druid/src/test/java/com/facebook/presto/druid/MetadataUtil.java", "diffHunk": "@@ -0,0 +1,73 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.json.JsonCodec;\n+import com.facebook.airlift.json.JsonCodecFactory;\n+import com.facebook.airlift.json.ObjectMapperProvider;\n+import com.facebook.presto.spi.type.StandardTypes;\n+import com.facebook.presto.spi.type.Type;\n+import com.fasterxml.jackson.databind.DeserializationContext;\n+import com.fasterxml.jackson.databind.JsonDeserializer;\n+import com.fasterxml.jackson.databind.deser.std.FromStringDeserializer;\n+import com.google.common.collect.ImmutableMap;\n+\n+import java.util.Map;\n+\n+import static com.facebook.presto.spi.type.BigintType.BIGINT;\n+import static com.facebook.presto.spi.type.BooleanType.BOOLEAN;\n+import static com.facebook.presto.spi.type.DoubleType.DOUBLE;\n+import static com.facebook.presto.spi.type.IntegerType.INTEGER;\n+import static com.facebook.presto.spi.type.VarcharType.VARCHAR;\n+import static java.util.Locale.ENGLISH;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class MetadataUtil", "originalCommit": "bf24d4d7bfc9a03747dcbc9c4f5f80dc49195d73", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE1OTI4NQ==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384159285", "bodyText": "All uppercase with underscores. Break a line after this.", "author": "highker", "createdAt": "2020-02-25T22:14:50Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidBrokerPageSource.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.json.ObjectMapperProvider;\n+import com.facebook.presto.druid.DruidQueryGenerator.GeneratedDql;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPageSource;\n+import com.facebook.presto.spi.Page;\n+import com.facebook.presto.spi.PageBuilder;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.block.BlockBuilder;\n+import com.facebook.presto.spi.type.BigintType;\n+import com.facebook.presto.spi.type.DoubleType;\n+import com.facebook.presto.spi.type.RealType;\n+import com.facebook.presto.spi.type.TimestampType;\n+import com.facebook.presto.spi.type.Type;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import org.joda.time.DateTime;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_BROKER_RESULT_ERROR;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidBrokerPageSource\n+        implements ConnectorPageSource\n+{\n+    private static final ObjectMapper objectMapper = new ObjectMapperProvider().get();", "originalCommit": "2571a68788cfe5176ade1e9a8cfd4122853f58ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3MDg4OA==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384170888", "bodyText": "toImmutableList", "author": "highker", "createdAt": "2020-02-25T22:41:16Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidBrokerPageSource.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.json.ObjectMapperProvider;\n+import com.facebook.presto.druid.DruidQueryGenerator.GeneratedDql;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPageSource;\n+import com.facebook.presto.spi.Page;\n+import com.facebook.presto.spi.PageBuilder;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.block.BlockBuilder;\n+import com.facebook.presto.spi.type.BigintType;\n+import com.facebook.presto.spi.type.DoubleType;\n+import com.facebook.presto.spi.type.RealType;\n+import com.facebook.presto.spi.type.TimestampType;\n+import com.facebook.presto.spi.type.Type;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import org.joda.time.DateTime;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_BROKER_RESULT_ERROR;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidBrokerPageSource\n+        implements ConnectorPageSource\n+{\n+    private static final ObjectMapper objectMapper = new ObjectMapperProvider().get();\n+    private final GeneratedDql brokerDql;\n+    private final List<ColumnHandle> columnHandles;\n+    private final DruidClient druidClient;\n+\n+    private boolean finished;\n+    private long readTimeNanos;\n+    private long completedBytes;\n+    private long completedPositions;\n+\n+    public DruidBrokerPageSource(\n+            GeneratedDql brokerDql,\n+            List<ColumnHandle> columnHandles,\n+            DruidClient druidClient)\n+    {\n+        this.brokerDql = requireNonNull(brokerDql, \"broker is null\");\n+        this.columnHandles = ImmutableList.copyOf(requireNonNull(columnHandles, \"columnHandles is null\"));\n+        this.druidClient = requireNonNull(druidClient, \"druid client is null\");\n+    }\n+\n+    @Override\n+    public long getCompletedBytes()\n+    {\n+        return completedBytes;\n+    }\n+\n+    @Override\n+    public long getCompletedPositions()\n+    {\n+        return completedPositions;\n+    }\n+\n+    @Override\n+    public long getReadTimeNanos()\n+    {\n+        return readTimeNanos;\n+    }\n+\n+    @Override\n+    public boolean isFinished()\n+    {\n+        return finished;\n+    }\n+\n+    @Override\n+    public Page getNextPage()\n+    {\n+        if (finished) {\n+            return null;\n+        }\n+\n+        long start = System.nanoTime();\n+        try {\n+            List<DruidColumnHandle> handles = columnHandles.stream()\n+                    .map(column -> (DruidColumnHandle) column)\n+                    .collect(Collectors.toList());", "originalCommit": "2571a68788cfe5176ade1e9a8cfd4122853f58ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3MDkyMA==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384170920", "bodyText": "toImmutableList", "author": "highker", "createdAt": "2020-02-25T22:41:19Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidBrokerPageSource.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.json.ObjectMapperProvider;\n+import com.facebook.presto.druid.DruidQueryGenerator.GeneratedDql;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPageSource;\n+import com.facebook.presto.spi.Page;\n+import com.facebook.presto.spi.PageBuilder;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.block.BlockBuilder;\n+import com.facebook.presto.spi.type.BigintType;\n+import com.facebook.presto.spi.type.DoubleType;\n+import com.facebook.presto.spi.type.RealType;\n+import com.facebook.presto.spi.type.TimestampType;\n+import com.facebook.presto.spi.type.Type;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import org.joda.time.DateTime;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_BROKER_RESULT_ERROR;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidBrokerPageSource\n+        implements ConnectorPageSource\n+{\n+    private static final ObjectMapper objectMapper = new ObjectMapperProvider().get();\n+    private final GeneratedDql brokerDql;\n+    private final List<ColumnHandle> columnHandles;\n+    private final DruidClient druidClient;\n+\n+    private boolean finished;\n+    private long readTimeNanos;\n+    private long completedBytes;\n+    private long completedPositions;\n+\n+    public DruidBrokerPageSource(\n+            GeneratedDql brokerDql,\n+            List<ColumnHandle> columnHandles,\n+            DruidClient druidClient)\n+    {\n+        this.brokerDql = requireNonNull(brokerDql, \"broker is null\");\n+        this.columnHandles = ImmutableList.copyOf(requireNonNull(columnHandles, \"columnHandles is null\"));\n+        this.druidClient = requireNonNull(druidClient, \"druid client is null\");\n+    }\n+\n+    @Override\n+    public long getCompletedBytes()\n+    {\n+        return completedBytes;\n+    }\n+\n+    @Override\n+    public long getCompletedPositions()\n+    {\n+        return completedPositions;\n+    }\n+\n+    @Override\n+    public long getReadTimeNanos()\n+    {\n+        return readTimeNanos;\n+    }\n+\n+    @Override\n+    public boolean isFinished()\n+    {\n+        return finished;\n+    }\n+\n+    @Override\n+    public Page getNextPage()\n+    {\n+        if (finished) {\n+            return null;\n+        }\n+\n+        long start = System.nanoTime();\n+        try {\n+            List<DruidColumnHandle> handles = columnHandles.stream()\n+                    .map(column -> (DruidColumnHandle) column)\n+                    .collect(Collectors.toList());\n+\n+            List<Type> columnTypes = handles.stream()\n+                    .map(DruidColumnHandle::getColumnType)\n+                    .collect(Collectors.toList());", "originalCommit": "2571a68788cfe5176ade1e9a8cfd4122853f58ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3MTI0OA==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384171248", "bodyText": "else if", "author": "highker", "createdAt": "2020-02-25T22:41:58Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidBrokerPageSource.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.json.ObjectMapperProvider;\n+import com.facebook.presto.druid.DruidQueryGenerator.GeneratedDql;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPageSource;\n+import com.facebook.presto.spi.Page;\n+import com.facebook.presto.spi.PageBuilder;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.block.BlockBuilder;\n+import com.facebook.presto.spi.type.BigintType;\n+import com.facebook.presto.spi.type.DoubleType;\n+import com.facebook.presto.spi.type.RealType;\n+import com.facebook.presto.spi.type.TimestampType;\n+import com.facebook.presto.spi.type.Type;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import org.joda.time.DateTime;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_BROKER_RESULT_ERROR;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidBrokerPageSource\n+        implements ConnectorPageSource\n+{\n+    private static final ObjectMapper objectMapper = new ObjectMapperProvider().get();\n+    private final GeneratedDql brokerDql;\n+    private final List<ColumnHandle> columnHandles;\n+    private final DruidClient druidClient;\n+\n+    private boolean finished;\n+    private long readTimeNanos;\n+    private long completedBytes;\n+    private long completedPositions;\n+\n+    public DruidBrokerPageSource(\n+            GeneratedDql brokerDql,\n+            List<ColumnHandle> columnHandles,\n+            DruidClient druidClient)\n+    {\n+        this.brokerDql = requireNonNull(brokerDql, \"broker is null\");\n+        this.columnHandles = ImmutableList.copyOf(requireNonNull(columnHandles, \"columnHandles is null\"));\n+        this.druidClient = requireNonNull(druidClient, \"druid client is null\");\n+    }\n+\n+    @Override\n+    public long getCompletedBytes()\n+    {\n+        return completedBytes;\n+    }\n+\n+    @Override\n+    public long getCompletedPositions()\n+    {\n+        return completedPositions;\n+    }\n+\n+    @Override\n+    public long getReadTimeNanos()\n+    {\n+        return readTimeNanos;\n+    }\n+\n+    @Override\n+    public boolean isFinished()\n+    {\n+        return finished;\n+    }\n+\n+    @Override\n+    public Page getNextPage()\n+    {\n+        if (finished) {\n+            return null;\n+        }\n+\n+        long start = System.nanoTime();\n+        try {\n+            List<DruidColumnHandle> handles = columnHandles.stream()\n+                    .map(column -> (DruidColumnHandle) column)\n+                    .collect(Collectors.toList());\n+\n+            List<Type> columnTypes = handles.stream()\n+                    .map(DruidColumnHandle::getColumnType)\n+                    .collect(Collectors.toList());\n+\n+            PageBuilder pageBuilder = new PageBuilder(columnTypes);\n+\n+            String data = druidClient.getData(brokerDql.getDql());\n+            JsonNode rootNode;\n+            try {\n+                rootNode = objectMapper.readTree(data);\n+                checkArgument(rootNode.isArray(), \"broker Druid query should return Json Array\");\n+                ArrayNode arrayNode = (ArrayNode) rootNode;\n+                Iterator<JsonNode> iterator = arrayNode.elements();\n+                while (iterator.hasNext()) {\n+                    JsonNode node = iterator.next();\n+                    for (int i = 0; i < columnHandles.size(); i++) {\n+                        Type type = columnTypes.get(i);\n+                        BlockBuilder blockBuilder = pageBuilder.getBlockBuilder(i);\n+                        JsonNode value = node.get(handles.get(i).getColumnName());\n+                        if (type instanceof BigintType) {\n+                            type.writeLong(blockBuilder, value.longValue());\n+                        }\n+                        if (type instanceof DoubleType) {", "originalCommit": "2571a68788cfe5176ade1e9a8cfd4122853f58ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE3MTI3Nw==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384171277", "bodyText": "else if", "author": "highker", "createdAt": "2020-02-25T22:42:02Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidBrokerPageSource.java", "diffHunk": "@@ -0,0 +1,177 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.json.ObjectMapperProvider;\n+import com.facebook.presto.druid.DruidQueryGenerator.GeneratedDql;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPageSource;\n+import com.facebook.presto.spi.Page;\n+import com.facebook.presto.spi.PageBuilder;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.block.BlockBuilder;\n+import com.facebook.presto.spi.type.BigintType;\n+import com.facebook.presto.spi.type.DoubleType;\n+import com.facebook.presto.spi.type.RealType;\n+import com.facebook.presto.spi.type.TimestampType;\n+import com.facebook.presto.spi.type.Type;\n+import com.fasterxml.jackson.databind.JsonNode;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import com.fasterxml.jackson.databind.node.ArrayNode;\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import org.joda.time.DateTime;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.format.DateTimeFormatter;\n+import org.joda.time.format.ISODateTimeFormat;\n+\n+import java.io.IOException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_BROKER_RESULT_ERROR;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidBrokerPageSource\n+        implements ConnectorPageSource\n+{\n+    private static final ObjectMapper objectMapper = new ObjectMapperProvider().get();\n+    private final GeneratedDql brokerDql;\n+    private final List<ColumnHandle> columnHandles;\n+    private final DruidClient druidClient;\n+\n+    private boolean finished;\n+    private long readTimeNanos;\n+    private long completedBytes;\n+    private long completedPositions;\n+\n+    public DruidBrokerPageSource(\n+            GeneratedDql brokerDql,\n+            List<ColumnHandle> columnHandles,\n+            DruidClient druidClient)\n+    {\n+        this.brokerDql = requireNonNull(brokerDql, \"broker is null\");\n+        this.columnHandles = ImmutableList.copyOf(requireNonNull(columnHandles, \"columnHandles is null\"));\n+        this.druidClient = requireNonNull(druidClient, \"druid client is null\");\n+    }\n+\n+    @Override\n+    public long getCompletedBytes()\n+    {\n+        return completedBytes;\n+    }\n+\n+    @Override\n+    public long getCompletedPositions()\n+    {\n+        return completedPositions;\n+    }\n+\n+    @Override\n+    public long getReadTimeNanos()\n+    {\n+        return readTimeNanos;\n+    }\n+\n+    @Override\n+    public boolean isFinished()\n+    {\n+        return finished;\n+    }\n+\n+    @Override\n+    public Page getNextPage()\n+    {\n+        if (finished) {\n+            return null;\n+        }\n+\n+        long start = System.nanoTime();\n+        try {\n+            List<DruidColumnHandle> handles = columnHandles.stream()\n+                    .map(column -> (DruidColumnHandle) column)\n+                    .collect(Collectors.toList());\n+\n+            List<Type> columnTypes = handles.stream()\n+                    .map(DruidColumnHandle::getColumnType)\n+                    .collect(Collectors.toList());\n+\n+            PageBuilder pageBuilder = new PageBuilder(columnTypes);\n+\n+            String data = druidClient.getData(brokerDql.getDql());\n+            JsonNode rootNode;\n+            try {\n+                rootNode = objectMapper.readTree(data);\n+                checkArgument(rootNode.isArray(), \"broker Druid query should return Json Array\");\n+                ArrayNode arrayNode = (ArrayNode) rootNode;\n+                Iterator<JsonNode> iterator = arrayNode.elements();\n+                while (iterator.hasNext()) {\n+                    JsonNode node = iterator.next();\n+                    for (int i = 0; i < columnHandles.size(); i++) {\n+                        Type type = columnTypes.get(i);\n+                        BlockBuilder blockBuilder = pageBuilder.getBlockBuilder(i);\n+                        JsonNode value = node.get(handles.get(i).getColumnName());\n+                        if (type instanceof BigintType) {\n+                            type.writeLong(blockBuilder, value.longValue());\n+                        }\n+                        if (type instanceof DoubleType) {\n+                            type.writeDouble(blockBuilder, value.doubleValue());\n+                        }\n+                        if (type instanceof RealType) {", "originalCommit": "2571a68788cfe5176ade1e9a8cfd4122853f58ac", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "fd87a7008690d955e28be03aac725936c3d30fe5", "url": "https://github.com/prestodb/presto/commit/fd87a7008690d955e28be03aac725936c3d30fe5", "message": "Code cleanup for Druid predicate pushdown", "committedDate": "2020-02-26T03:55:41Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI4ODU4Mw==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384288583", "bodyText": "move binder -> { to its own line", "author": "highker", "createdAt": "2020-02-26T06:00:13Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidConnectorFactory.java", "diffHunk": "@@ -48,7 +53,13 @@ public Connector create(String catalogName, Map<String, String> config, Connecto\n         try {\n             Bootstrap app = new Bootstrap(\n                     new JsonModule(),\n-                    new DruidModule(context.getTypeManager()));\n+                    new DruidModule(), binder -> {", "originalCommit": "fd87a7008690d955e28be03aac725936c3d30fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI4ODcwMQ==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384288701", "bodyText": "create it instead of inject it", "author": "highker", "createdAt": "2020-02-26T06:00:45Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidConnectorPlanOptimizer.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.expressions.LogicalRowExpressions;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPlanOptimizer;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.ConnectorTableHandle;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.VariableAllocator;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.inject.Inject;\n+\n+import java.util.ArrayList;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_QUERY_GENERATOR_FAILURE;\n+import static com.facebook.presto.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidConnectorPlanOptimizer\n+        implements ConnectorPlanOptimizer\n+{\n+    private final DruidQueryGenerator druidQueryGenerator;\n+    private final TypeManager typeManager;\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final LogicalRowExpressions logicalRowExpressions;\n+    private final StandardFunctionResolution standardFunctionResolution;\n+\n+    @Inject\n+    public DruidConnectorPlanOptimizer(\n+            DruidQueryGenerator druidQueryGenerator,\n+            TypeManager typeManager,\n+            FunctionMetadataManager functionMetadataManager,\n+            LogicalRowExpressions logicalRowExpressions,", "originalCommit": "fd87a7008690d955e28be03aac725936c3d30fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI4ODgxNg==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384288816", "bodyText": "combine this line with the previous line", "author": "highker", "createdAt": "2020-02-26T06:01:17Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidConnectorPlanOptimizer.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.expressions.LogicalRowExpressions;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPlanOptimizer;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.ConnectorTableHandle;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.VariableAllocator;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.inject.Inject;\n+\n+import java.util.ArrayList;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_QUERY_GENERATOR_FAILURE;\n+import static com.facebook.presto.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidConnectorPlanOptimizer\n+        implements ConnectorPlanOptimizer\n+{\n+    private final DruidQueryGenerator druidQueryGenerator;\n+    private final TypeManager typeManager;\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final LogicalRowExpressions logicalRowExpressions;\n+    private final StandardFunctionResolution standardFunctionResolution;\n+\n+    @Inject\n+    public DruidConnectorPlanOptimizer(\n+            DruidQueryGenerator druidQueryGenerator,\n+            TypeManager typeManager,\n+            FunctionMetadataManager functionMetadataManager,\n+            LogicalRowExpressions logicalRowExpressions,\n+            StandardFunctionResolution standardFunctionResolution)\n+    {\n+        this.druidQueryGenerator = requireNonNull(druidQueryGenerator, \"pinot query generator is null\");\n+        this.typeManager = requireNonNull(typeManager, \"type manager is null\");\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"function manager is null\");\n+        this.logicalRowExpressions = requireNonNull(logicalRowExpressions, \"logical row expressions is null\");\n+        this.standardFunctionResolution = requireNonNull(standardFunctionResolution, \"standard function resolution is null\");\n+    }\n+\n+    @Override\n+    public PlanNode optimize(PlanNode maxSubplan,\n+            ConnectorSession session,\n+            VariableAllocator variableAllocator,\n+            PlanNodeIdAllocator idAllocator)\n+    {\n+        Map<TableScanNode, Void> scanNodes = maxSubplan.accept(new TableFindingVisitor(), null);\n+        TableScanNode druidTableScanNode = getOnlyDruidTable(scanNodes)\n+                .orElseThrow(() -> new PrestoException(", "originalCommit": "fd87a7008690d955e28be03aac725936c3d30fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5MDg0MA==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384290840", "bodyText": "Map", "author": "highker", "createdAt": "2020-02-26T06:09:16Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidConnectorPlanOptimizer.java", "diffHunk": "@@ -0,0 +1,230 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.expressions.LogicalRowExpressions;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorPlanOptimizer;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.ConnectorTableHandle;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.VariableAllocator;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.inject.Inject;\n+\n+import java.util.ArrayList;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_QUERY_GENERATOR_FAILURE;\n+import static com.facebook.presto.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidConnectorPlanOptimizer\n+        implements ConnectorPlanOptimizer\n+{\n+    private final DruidQueryGenerator druidQueryGenerator;\n+    private final TypeManager typeManager;\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final LogicalRowExpressions logicalRowExpressions;\n+    private final StandardFunctionResolution standardFunctionResolution;\n+\n+    @Inject\n+    public DruidConnectorPlanOptimizer(\n+            DruidQueryGenerator druidQueryGenerator,\n+            TypeManager typeManager,\n+            FunctionMetadataManager functionMetadataManager,\n+            LogicalRowExpressions logicalRowExpressions,\n+            StandardFunctionResolution standardFunctionResolution)\n+    {\n+        this.druidQueryGenerator = requireNonNull(druidQueryGenerator, \"pinot query generator is null\");\n+        this.typeManager = requireNonNull(typeManager, \"type manager is null\");\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"function manager is null\");\n+        this.logicalRowExpressions = requireNonNull(logicalRowExpressions, \"logical row expressions is null\");\n+        this.standardFunctionResolution = requireNonNull(standardFunctionResolution, \"standard function resolution is null\");\n+    }\n+\n+    @Override\n+    public PlanNode optimize(PlanNode maxSubplan,\n+            ConnectorSession session,\n+            VariableAllocator variableAllocator,\n+            PlanNodeIdAllocator idAllocator)\n+    {\n+        Map<TableScanNode, Void> scanNodes = maxSubplan.accept(new TableFindingVisitor(), null);\n+        TableScanNode druidTableScanNode = getOnlyDruidTable(scanNodes)\n+                .orElseThrow(() -> new PrestoException(\n+                        GENERIC_INTERNAL_ERROR,\n+                        \"Expected to find druid table handle for the scan node\"));\n+        return maxSubplan.accept(new Visitor(druidTableScanNode, session, idAllocator), null);\n+    }\n+\n+    private static Optional<DruidTableHandle> getDruidTableHandle(TableScanNode tableScanNode)\n+    {\n+        TableHandle table = tableScanNode.getTable();\n+        if (table != null) {\n+            ConnectorTableHandle connectorHandle = table.getConnectorHandle();\n+            if (connectorHandle instanceof DruidTableHandle) {\n+                return Optional.of((DruidTableHandle) connectorHandle);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private static Optional<TableScanNode> getOnlyDruidTable(Map<TableScanNode, Void> scanNodes)\n+    {\n+        if (scanNodes.size() == 1) {\n+            TableScanNode tableScanNode = scanNodes.keySet().iterator().next();\n+            if (getDruidTableHandle(tableScanNode).isPresent()) {\n+                return Optional.of(tableScanNode);\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private static PlanNode replaceChildren(PlanNode node, List<PlanNode> children)\n+    {\n+        for (int i = 0; i < node.getSources().size(); i++) {\n+            if (children.get(i) != node.getSources().get(i)) {\n+                return node.replaceChildren(children);\n+            }\n+        }\n+        return node;\n+    }\n+\n+    private static class TableFindingVisitor\n+            extends PlanVisitor<Map<TableScanNode, Void>, Void>\n+    {\n+        @Override\n+        public Map<TableScanNode, Void> visitPlan(PlanNode node, Void context)\n+        {\n+            Map<TableScanNode, Void> result = new IdentityHashMap<>();\n+            node.getSources().forEach(source -> result.putAll(source.accept(this, context)));\n+            return result;\n+        }\n+\n+        @Override\n+        public Map<TableScanNode, Void> visitTableScan(TableScanNode node, Void context)\n+        {\n+            Map<TableScanNode, Void> result = new IdentityHashMap<>();\n+            result.put(node, null);\n+            return result;\n+        }\n+    }\n+\n+    private class Visitor\n+            extends PlanVisitor<PlanNode, Void>\n+    {\n+        private final PlanNodeIdAllocator idAllocator;\n+        private final ConnectorSession session;\n+        private final TableScanNode tableScanNode;\n+        private final IdentityHashMap<FilterNode, Void> filtersSplitUp = new IdentityHashMap<>();\n+\n+        public Visitor(TableScanNode tableScanNode, ConnectorSession session, PlanNodeIdAllocator idAllocator)\n+        {\n+            this.session = session;\n+            this.idAllocator = idAllocator;\n+            this.tableScanNode = tableScanNode;\n+            // Just making sure that the table exists\n+            getDruidTableHandle(this.tableScanNode).get().getTableName();\n+        }\n+\n+        private Optional<PlanNode> tryCreatingNewScanNode(PlanNode plan)\n+        {\n+            Optional<DruidQueryGenerator.DruidQueryGeneratorResult> dql = druidQueryGenerator.generate(plan, session);\n+            if (!dql.isPresent()) {\n+                return Optional.empty();\n+            }\n+            DruidTableHandle druidTableHandle = getDruidTableHandle(tableScanNode).orElseThrow(() -> new PrestoException(DRUID_QUERY_GENERATOR_FAILURE, \"Expected to find a druid table handle\"));\n+            DruidQueryGeneratorContext context = dql.get().getContext();\n+            TableHandle oldTableHandle = tableScanNode.getTable();\n+            LinkedHashMap<VariableReferenceExpression, DruidColumnHandle> assignments = context.getAssignments();", "originalCommit": "fd87a7008690d955e28be03aac725936c3d30fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5NDA2OQ==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384294069", "bodyText": "private", "author": "highker", "createdAt": "2020-02-26T06:22:21Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.log.Logger;\n+import com.facebook.presto.druid.DruidQueryGeneratorContext.Selection;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import javax.inject.Inject;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidQueryGeneratorContext.Origin.TABLE_COLUMN;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidQueryGenerator\n+{\n+    private static final Logger log = Logger.get(DruidQueryGenerator.class);\n+\n+    private final TypeManager typeManager;\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final StandardFunctionResolution standardFunctionResolution;\n+    private final DruidProjectExpressionConverter druidProjectExpressionConverter;\n+\n+    @Inject\n+    public DruidQueryGenerator(\n+            TypeManager typeManager,\n+            FunctionMetadataManager functionMetadataManager,\n+            StandardFunctionResolution standardFunctionResolution)\n+    {\n+        this.typeManager = requireNonNull(typeManager, \"type manager is null\");\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"function metadata manager is null\");\n+        this.standardFunctionResolution = requireNonNull(standardFunctionResolution, \"standardFunctionResolution is null\");\n+        this.druidProjectExpressionConverter = new DruidProjectExpressionConverter(typeManager, standardFunctionResolution);\n+    }\n+\n+    public static class DruidQueryGeneratorResult\n+    {\n+        private final GeneratedDql generateddql;\n+        private final DruidQueryGeneratorContext context;\n+\n+        public DruidQueryGeneratorResult(\n+                GeneratedDql generateddql,\n+                DruidQueryGeneratorContext context)\n+        {\n+            this.generateddql = requireNonNull(generateddql, \"generateddql is null\");\n+            this.context = requireNonNull(context, \"context is null\");\n+        }\n+\n+        public GeneratedDql getGeneratedDql()\n+        {\n+            return generateddql;\n+        }\n+\n+        public DruidQueryGeneratorContext getContext()\n+        {\n+            return context;\n+        }\n+    }\n+\n+    public Optional<DruidQueryGeneratorResult> generate(PlanNode plan, ConnectorSession session)\n+    {\n+        try {\n+            DruidQueryGeneratorContext context = requireNonNull(plan.accept(\n+                    new DruidQueryPlanVisitor(session),\n+                    new DruidQueryGeneratorContext()),\n+                    \"Resulting context is null\");\n+            return Optional.of(new DruidQueryGeneratorResult(context.toQuery(), context));\n+        }\n+        catch (PrestoException e) {\n+            log.debug(e, \"Possibly benign error when pushing plan into scan node %s\", plan);\n+            return Optional.empty();\n+        }\n+    }\n+\n+    public static class GeneratedDql\n+    {\n+        final String table;\n+        final String dql;\n+\n+        @JsonCreator\n+        public GeneratedDql(\n+                @JsonProperty(\"table\") String table,\n+                @JsonProperty(\"dql\") String dql)\n+        {\n+            this.table = table;\n+            this.dql = dql;\n+        }\n+\n+        @JsonProperty(\"dql\")\n+        public String getDql()\n+        {\n+            return dql;\n+        }\n+\n+        @JsonProperty(\"table\")\n+        public String getTable()\n+        {\n+            return table;\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+            return toStringHelper(this)\n+                    .add(\"dql\", dql)\n+                    .add(\"table\", table)\n+                    .toString();\n+        }\n+    }\n+\n+    class DruidQueryPlanVisitor", "originalCommit": "fd87a7008690d955e28be03aac725936c3d30fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5NDExNA==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384294114", "bodyText": "Map", "author": "highker", "createdAt": "2020-02-26T06:22:35Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.log.Logger;\n+import com.facebook.presto.druid.DruidQueryGeneratorContext.Selection;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import javax.inject.Inject;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidQueryGeneratorContext.Origin.TABLE_COLUMN;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidQueryGenerator\n+{\n+    private static final Logger log = Logger.get(DruidQueryGenerator.class);\n+\n+    private final TypeManager typeManager;\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final StandardFunctionResolution standardFunctionResolution;\n+    private final DruidProjectExpressionConverter druidProjectExpressionConverter;\n+\n+    @Inject\n+    public DruidQueryGenerator(\n+            TypeManager typeManager,\n+            FunctionMetadataManager functionMetadataManager,\n+            StandardFunctionResolution standardFunctionResolution)\n+    {\n+        this.typeManager = requireNonNull(typeManager, \"type manager is null\");\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"function metadata manager is null\");\n+        this.standardFunctionResolution = requireNonNull(standardFunctionResolution, \"standardFunctionResolution is null\");\n+        this.druidProjectExpressionConverter = new DruidProjectExpressionConverter(typeManager, standardFunctionResolution);\n+    }\n+\n+    public static class DruidQueryGeneratorResult\n+    {\n+        private final GeneratedDql generateddql;\n+        private final DruidQueryGeneratorContext context;\n+\n+        public DruidQueryGeneratorResult(\n+                GeneratedDql generateddql,\n+                DruidQueryGeneratorContext context)\n+        {\n+            this.generateddql = requireNonNull(generateddql, \"generateddql is null\");\n+            this.context = requireNonNull(context, \"context is null\");\n+        }\n+\n+        public GeneratedDql getGeneratedDql()\n+        {\n+            return generateddql;\n+        }\n+\n+        public DruidQueryGeneratorContext getContext()\n+        {\n+            return context;\n+        }\n+    }\n+\n+    public Optional<DruidQueryGeneratorResult> generate(PlanNode plan, ConnectorSession session)\n+    {\n+        try {\n+            DruidQueryGeneratorContext context = requireNonNull(plan.accept(\n+                    new DruidQueryPlanVisitor(session),\n+                    new DruidQueryGeneratorContext()),\n+                    \"Resulting context is null\");\n+            return Optional.of(new DruidQueryGeneratorResult(context.toQuery(), context));\n+        }\n+        catch (PrestoException e) {\n+            log.debug(e, \"Possibly benign error when pushing plan into scan node %s\", plan);\n+            return Optional.empty();\n+        }\n+    }\n+\n+    public static class GeneratedDql\n+    {\n+        final String table;\n+        final String dql;\n+\n+        @JsonCreator\n+        public GeneratedDql(\n+                @JsonProperty(\"table\") String table,\n+                @JsonProperty(\"dql\") String dql)\n+        {\n+            this.table = table;\n+            this.dql = dql;\n+        }\n+\n+        @JsonProperty(\"dql\")\n+        public String getDql()\n+        {\n+            return dql;\n+        }\n+\n+        @JsonProperty(\"table\")\n+        public String getTable()\n+        {\n+            return table;\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+            return toStringHelper(this)\n+                    .add(\"dql\", dql)\n+                    .add(\"table\", table)\n+                    .toString();\n+        }\n+    }\n+\n+    class DruidQueryPlanVisitor\n+            extends PlanVisitor<DruidQueryGeneratorContext, DruidQueryGeneratorContext>\n+    {\n+        private final ConnectorSession session;\n+\n+        protected DruidQueryPlanVisitor(ConnectorSession session)\n+        {\n+            this.session = session;\n+        }\n+\n+        @Override\n+        public DruidQueryGeneratorContext visitPlan(PlanNode node, DruidQueryGeneratorContext context)\n+        {\n+            throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector with plan node of type \" + node);\n+        }\n+\n+        protected VariableReferenceExpression getVariableReference(RowExpression expression)\n+        {\n+            if (expression instanceof VariableReferenceExpression) {\n+                return ((VariableReferenceExpression) expression);\n+            }\n+            throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector. Expect variable reference, but get: \" + expression);\n+        }\n+\n+        @Override\n+        public DruidQueryGeneratorContext visitFilter(FilterNode node, DruidQueryGeneratorContext context)\n+        {\n+            context = node.getSource().accept(this, context);\n+            requireNonNull(context, \"context is null\");\n+            LinkedHashMap<VariableReferenceExpression, Selection> selections = context.getSelections();\n+            DruidFilterExpressionConverter druidFilterExpressionConverter = new DruidFilterExpressionConverter(typeManager, functionMetadataManager, standardFunctionResolution, session);\n+            String filter = node.getPredicate().accept(druidFilterExpressionConverter, selections::get).getDefinition();\n+            return context.withFilter(filter).withOutputColumns(node.getOutputVariables());\n+        }\n+\n+        @Override\n+        public DruidQueryGeneratorContext visitProject(ProjectNode node, DruidQueryGeneratorContext contextIn)\n+        {\n+            DruidQueryGeneratorContext context = node.getSource().accept(this, contextIn);\n+            requireNonNull(context, \"context is null\");\n+            LinkedHashMap<VariableReferenceExpression, Selection> newSelections = new LinkedHashMap<>();\n+\n+            node.getOutputVariables().forEach(variable -> {\n+                RowExpression expression = node.getAssignments().get(variable);\n+                DruidExpression druidExpression = expression.accept(\n+                        druidProjectExpressionConverter,\n+                        context.getSelections());\n+                newSelections.put(\n+                        variable,\n+                        new Selection(druidExpression.getDefinition(), druidExpression.getOrigin()));\n+            });\n+            return context.withProject(newSelections);\n+        }\n+\n+        @Override\n+        public DruidQueryGeneratorContext visitTableScan(TableScanNode node, DruidQueryGeneratorContext contextIn)\n+        {\n+            DruidTableHandle tableHandle = (DruidTableHandle) node.getTable().getConnectorHandle();\n+            checkArgument(!tableHandle.getDql().isPresent(), \"Druid tableHandle should not have dql before pushdown\");\n+            LinkedHashMap<VariableReferenceExpression, Selection> selections = new LinkedHashMap<>();", "originalCommit": "fd87a7008690d955e28be03aac725936c3d30fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5NDIxOA==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384294218", "bodyText": "Map", "author": "highker", "createdAt": "2020-02-26T06:22:51Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -0,0 +1,207 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.airlift.log.Logger;\n+import com.facebook.presto.druid.DruidQueryGeneratorContext.Selection;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanVisitor;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import javax.inject.Inject;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidQueryGeneratorContext.Origin.TABLE_COLUMN;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidQueryGenerator\n+{\n+    private static final Logger log = Logger.get(DruidQueryGenerator.class);\n+\n+    private final TypeManager typeManager;\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final StandardFunctionResolution standardFunctionResolution;\n+    private final DruidProjectExpressionConverter druidProjectExpressionConverter;\n+\n+    @Inject\n+    public DruidQueryGenerator(\n+            TypeManager typeManager,\n+            FunctionMetadataManager functionMetadataManager,\n+            StandardFunctionResolution standardFunctionResolution)\n+    {\n+        this.typeManager = requireNonNull(typeManager, \"type manager is null\");\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"function metadata manager is null\");\n+        this.standardFunctionResolution = requireNonNull(standardFunctionResolution, \"standardFunctionResolution is null\");\n+        this.druidProjectExpressionConverter = new DruidProjectExpressionConverter(typeManager, standardFunctionResolution);\n+    }\n+\n+    public static class DruidQueryGeneratorResult\n+    {\n+        private final GeneratedDql generateddql;\n+        private final DruidQueryGeneratorContext context;\n+\n+        public DruidQueryGeneratorResult(\n+                GeneratedDql generateddql,\n+                DruidQueryGeneratorContext context)\n+        {\n+            this.generateddql = requireNonNull(generateddql, \"generateddql is null\");\n+            this.context = requireNonNull(context, \"context is null\");\n+        }\n+\n+        public GeneratedDql getGeneratedDql()\n+        {\n+            return generateddql;\n+        }\n+\n+        public DruidQueryGeneratorContext getContext()\n+        {\n+            return context;\n+        }\n+    }\n+\n+    public Optional<DruidQueryGeneratorResult> generate(PlanNode plan, ConnectorSession session)\n+    {\n+        try {\n+            DruidQueryGeneratorContext context = requireNonNull(plan.accept(\n+                    new DruidQueryPlanVisitor(session),\n+                    new DruidQueryGeneratorContext()),\n+                    \"Resulting context is null\");\n+            return Optional.of(new DruidQueryGeneratorResult(context.toQuery(), context));\n+        }\n+        catch (PrestoException e) {\n+            log.debug(e, \"Possibly benign error when pushing plan into scan node %s\", plan);\n+            return Optional.empty();\n+        }\n+    }\n+\n+    public static class GeneratedDql\n+    {\n+        final String table;\n+        final String dql;\n+\n+        @JsonCreator\n+        public GeneratedDql(\n+                @JsonProperty(\"table\") String table,\n+                @JsonProperty(\"dql\") String dql)\n+        {\n+            this.table = table;\n+            this.dql = dql;\n+        }\n+\n+        @JsonProperty(\"dql\")\n+        public String getDql()\n+        {\n+            return dql;\n+        }\n+\n+        @JsonProperty(\"table\")\n+        public String getTable()\n+        {\n+            return table;\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+            return toStringHelper(this)\n+                    .add(\"dql\", dql)\n+                    .add(\"table\", table)\n+                    .toString();\n+        }\n+    }\n+\n+    class DruidQueryPlanVisitor\n+            extends PlanVisitor<DruidQueryGeneratorContext, DruidQueryGeneratorContext>\n+    {\n+        private final ConnectorSession session;\n+\n+        protected DruidQueryPlanVisitor(ConnectorSession session)\n+        {\n+            this.session = session;\n+        }\n+\n+        @Override\n+        public DruidQueryGeneratorContext visitPlan(PlanNode node, DruidQueryGeneratorContext context)\n+        {\n+            throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector with plan node of type \" + node);\n+        }\n+\n+        protected VariableReferenceExpression getVariableReference(RowExpression expression)\n+        {\n+            if (expression instanceof VariableReferenceExpression) {\n+                return ((VariableReferenceExpression) expression);\n+            }\n+            throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector. Expect variable reference, but get: \" + expression);\n+        }\n+\n+        @Override\n+        public DruidQueryGeneratorContext visitFilter(FilterNode node, DruidQueryGeneratorContext context)\n+        {\n+            context = node.getSource().accept(this, context);\n+            requireNonNull(context, \"context is null\");\n+            LinkedHashMap<VariableReferenceExpression, Selection> selections = context.getSelections();", "originalCommit": "fd87a7008690d955e28be03aac725936c3d30fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5NDI3NQ==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384294275", "bodyText": "Map", "author": "highker", "createdAt": "2020-02-26T06:23:03Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGeneratorContext.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_QUERY_GENERATOR_FAILURE;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidQueryGeneratorContext\n+{\n+    private final LinkedHashMap<VariableReferenceExpression, Selection> selections;", "originalCommit": "fd87a7008690d955e28be03aac725936c3d30fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5NDQyMw==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384294423", "bodyText": "Can we replace all these to map?", "author": "highker", "createdAt": "2020-02-26T06:23:32Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGeneratorContext.java", "diffHunk": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_QUERY_GENERATOR_FAILURE;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidQueryGeneratorContext\n+{\n+    private final LinkedHashMap<VariableReferenceExpression, Selection> selections;\n+    private final Optional<String> from;\n+    private final Optional<String> filter;\n+\n+    @Override\n+    public String toString()\n+    {\n+        return toStringHelper(this)\n+                .add(\"selections\", selections)\n+                .add(\"from\", from)\n+                .add(\"filter\", filter)\n+                .toString();\n+    }\n+\n+    DruidQueryGeneratorContext()\n+    {\n+        this(new LinkedHashMap<>(), null);\n+    }\n+\n+    DruidQueryGeneratorContext(\n+            LinkedHashMap<VariableReferenceExpression, Selection> selections,\n+            String from)\n+    {\n+        this(\n+                selections,\n+                Optional.ofNullable(from),\n+                Optional.empty());\n+    }\n+\n+    private DruidQueryGeneratorContext(\n+            LinkedHashMap<VariableReferenceExpression, Selection> selections,\n+            Optional<String> from,\n+            Optional<String> filter)\n+    {\n+        this.selections = new LinkedHashMap<>(requireNonNull(selections, \"selections can't be null\"));\n+        this.from = requireNonNull(from, \"source can't be null\");\n+        this.filter = requireNonNull(filter, \"filter is null\");\n+    }\n+\n+    public DruidQueryGeneratorContext withFilter(String filter)\n+    {\n+        checkArgument(!hasFilter(), \"Druid doesn't support filters at multiple levels\");\n+        return new DruidQueryGeneratorContext(\n+                selections,\n+                from,\n+                Optional.of(filter));\n+    }\n+\n+    public DruidQueryGeneratorContext withProject(LinkedHashMap<VariableReferenceExpression, Selection> newSelections)\n+    {\n+        return new DruidQueryGeneratorContext(\n+                newSelections,\n+                from,\n+                filter);\n+    }\n+\n+    private boolean hasFilter()\n+    {\n+        return filter.isPresent();\n+    }\n+\n+    public LinkedHashMap<VariableReferenceExpression, Selection> getSelections()\n+    {\n+        return selections;\n+    }\n+\n+    public DruidQueryGenerator.GeneratedDql toQuery()\n+    {\n+        String expressions = selections.entrySet().stream()\n+                .map(s -> s.getValue().getDefinition())\n+                .collect(Collectors.joining(\", \"));\n+        if (expressions.isEmpty()) {\n+            throw new PrestoException(DRUID_QUERY_GENERATOR_FAILURE, \"Empty Druid query\");\n+        }\n+\n+        String tableName = from.orElseThrow(() -> new PrestoException(DRUID_QUERY_GENERATOR_FAILURE, \"Table name missing in Druid query\"));\n+        String query = \"SELECT \" + expressions + \" FROM \" + tableName;\n+        if (filter.isPresent()) {\n+            String filterString = filter.get();\n+            // this is hack!!!. Ideally we want to clone the scan pipeline and create/update the filter in the scan pipeline to contain this filter and\n+            // at the same time add the time column to scan so that the query generator doesn't fail when it looks up the time column in scan output columns\n+            query += \" WHERE \" + filterString;\n+        }\n+        return new DruidQueryGenerator.GeneratedDql(tableName, query);\n+    }\n+\n+    public LinkedHashMap<VariableReferenceExpression, DruidColumnHandle> getAssignments()\n+    {\n+        LinkedHashMap<VariableReferenceExpression, DruidColumnHandle> result = new LinkedHashMap<>();\n+        selections.entrySet().forEach(entry -> {\n+            VariableReferenceExpression variable = entry.getKey();\n+            Selection selection = entry.getValue();\n+            DruidColumnHandle handle = selection.getOrigin() == Origin.TABLE_COLUMN ? new DruidColumnHandle(selection.getDefinition(), variable.getType(), DruidColumnHandle.DruidColumnType.REGULAR) : new DruidColumnHandle(variable, DruidColumnHandle.DruidColumnType.DERIVED);\n+            result.put(variable, handle);\n+        });\n+        return result;\n+    }\n+\n+    public DruidQueryGeneratorContext withOutputColumns(List<VariableReferenceExpression> outputColumns)\n+    {\n+        LinkedHashMap<VariableReferenceExpression, Selection> newSelections = new LinkedHashMap<>();", "originalCommit": "fd87a7008690d955e28be03aac725936c3d30fe5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5NDc5MQ==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384294791", "bodyText": "Do we really need both sessions?", "author": "highker", "createdAt": "2020-02-26T06:25:01Z", "path": "presto-druid/src/test/java/com/facebook/presto/druid/TestDruidQueryBase.java", "diffHunk": "@@ -0,0 +1,219 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.Session;\n+import com.facebook.presto.SystemSessionProperties;\n+import com.facebook.presto.block.BlockEncodingManager;\n+import com.facebook.presto.execution.warnings.WarningCollector;\n+import com.facebook.presto.metadata.FunctionManager;\n+import com.facebook.presto.metadata.Metadata;\n+import com.facebook.presto.metadata.MetadataManager;\n+import com.facebook.presto.metadata.SessionPropertyManager;\n+import com.facebook.presto.spi.ColumnHandle;\n+import com.facebook.presto.spi.ConnectorId;\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.TableHandle;\n+import com.facebook.presto.spi.block.SortOrder;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.Assignments;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.LimitNode;\n+import com.facebook.presto.spi.plan.Ordering;\n+import com.facebook.presto.spi.plan.OrderingScheme;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.plan.TopNNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.Type;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.facebook.presto.sql.ExpressionUtils;\n+import com.facebook.presto.sql.analyzer.FeaturesConfig;\n+import com.facebook.presto.sql.parser.ParsingOptions;\n+import com.facebook.presto.sql.parser.SqlParser;\n+import com.facebook.presto.sql.planner.TypeProvider;\n+import com.facebook.presto.sql.planner.iterative.rule.test.PlanBuilder;\n+import com.facebook.presto.sql.relational.FunctionResolution;\n+import com.facebook.presto.sql.relational.SqlToRowExpressionTranslator;\n+import com.facebook.presto.sql.tree.Expression;\n+import com.facebook.presto.sql.tree.NodeRef;\n+import com.facebook.presto.testing.TestingSession;\n+import com.facebook.presto.testing.TestingTransactionHandle;\n+import com.facebook.presto.type.TypeRegistry;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+\n+import java.util.Arrays;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.IntStream;\n+\n+import static com.facebook.presto.druid.DruidColumnHandle.DruidColumnType.REGULAR;\n+import static com.facebook.presto.druid.DruidQueryGeneratorContext.Origin.DERIVED;\n+import static com.facebook.presto.druid.DruidQueryGeneratorContext.Origin.TABLE_COLUMN;\n+import static com.facebook.presto.spi.plan.LimitNode.Step.FINAL;\n+import static com.facebook.presto.spi.type.BigintType.BIGINT;\n+import static com.facebook.presto.spi.type.DoubleType.DOUBLE;\n+import static com.facebook.presto.spi.type.VarcharType.VARCHAR;\n+import static com.facebook.presto.sql.analyzer.ExpressionAnalyzer.getExpressionTypes;\n+import static com.facebook.presto.testing.TestingConnectorSession.SESSION;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Locale.ENGLISH;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.function.Function.identity;\n+import static java.util.stream.Collectors.toMap;\n+\n+public class TestDruidQueryBase\n+{\n+    protected static final TypeManager typeManager = new TypeRegistry();\n+    protected static final FunctionManager functionMetadataManager = new FunctionManager(typeManager, new BlockEncodingManager(typeManager), new FeaturesConfig());\n+    protected static final StandardFunctionResolution standardFunctionResolution = new FunctionResolution(functionMetadataManager);\n+\n+    protected static ConnectorId druidConnectorId = new ConnectorId(\"id\");\n+    protected static DruidTableHandle realtimeOnlyTable = new DruidTableHandle(\"schema\", \"realtimeOnly\", Optional.empty());\n+    protected static DruidTableHandle hybridTable = new DruidTableHandle(\"schema\", \"hybrid\", Optional.empty());\n+    protected static DruidColumnHandle regionId = new DruidColumnHandle(\"regionId\", BIGINT, REGULAR);\n+    protected static DruidColumnHandle city = new DruidColumnHandle(\"city\", VARCHAR, REGULAR);\n+    protected static final DruidColumnHandle fare = new DruidColumnHandle(\"fare\", DOUBLE, REGULAR);\n+    protected static final DruidColumnHandle secondsSinceEpoch = new DruidColumnHandle(\"secondsSinceEpoch\", BIGINT, REGULAR);\n+\n+    protected static final Metadata metadata = MetadataManager.createTestMetadataManager();\n+\n+    protected final DruidConfig druidConfig = new DruidConfig();\n+\n+    protected static final Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> testInput = ImmutableMap.of(\n+            new VariableReferenceExpression(\"regionid\", BIGINT), new DruidQueryGeneratorContext.Selection(\"regionId\", TABLE_COLUMN),\n+            new VariableReferenceExpression(\"city\", VARCHAR), new DruidQueryGeneratorContext.Selection(\"city\", TABLE_COLUMN),\n+            new VariableReferenceExpression(\"fare\", DOUBLE), new DruidQueryGeneratorContext.Selection(\"fare\", TABLE_COLUMN),\n+            new VariableReferenceExpression(\"totalfare\", DOUBLE), new DruidQueryGeneratorContext.Selection(\"(fare + trip)\", DERIVED),\n+            new VariableReferenceExpression(\"secondssinceepoch\", BIGINT), new DruidQueryGeneratorContext.Selection(\"secondsSinceEpoch\", TABLE_COLUMN));\n+\n+    protected final TypeProvider typeProvider = TypeProvider.fromVariables(testInput.keySet());\n+\n+    protected static class SessionHolder\n+    {\n+        private final ConnectorSession connectorSession;\n+        private final Session session;", "originalCommit": "fd87a7008690d955e28be03aac725936c3d30fe5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDMxMTcyNw==", "url": "https://github.com/prestodb/presto/pull/14155#discussion_r384311727", "bodyText": "yep, need connectorSession for timeZoneKey, and Session for ExpressionAnalyzer", "author": "zhenxiao", "createdAt": "2020-02-26T07:25:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDI5NDc5MQ=="}], "type": "inlineReview"}, {"oid": "b180aa4350c052143bcbfce6a841229658f11904", "url": "https://github.com/prestodb/presto/commit/b180aa4350c052143bcbfce6a841229658f11904", "message": "Code cleanup for Druid predicate pushdown", "committedDate": "2020-02-26T07:25:40Z", "type": "forcePushed"}, {"oid": "1fe8ad3269fb85f615bb21ac3a998dd19fd6efe5", "url": "https://github.com/prestodb/presto/commit/1fe8ad3269fb85f615bb21ac3a998dd19fd6efe5", "message": "Code cleanup for Druid predicate pushdown", "committedDate": "2020-02-26T20:44:16Z", "type": "commit"}, {"oid": "1fe8ad3269fb85f615bb21ac3a998dd19fd6efe5", "url": "https://github.com/prestodb/presto/commit/1fe8ad3269fb85f615bb21ac3a998dd19fd6efe5", "message": "Code cleanup for Druid predicate pushdown", "committedDate": "2020-02-26T20:44:16Z", "type": "forcePushed"}]}