{"pr_number": 15362, "pr_title": "Optimize TypedSet and map_concat, array_union", "pr_createdAt": "2020-10-27T08:43:43Z", "pr_url": "https://github.com/prestodb/presto/pull/15362", "timeline": [{"oid": "65bd19a9fb26148c399ac64ac80d65dbca4fb87e", "url": "https://github.com/prestodb/presto/commit/65bd19a9fb26148c399ac64ac80d65dbca4fb87e", "message": "Use OptimizedTypedSet in map_concat\n\nJMH benchmark shows 22% improvement for non_empty case:\n\nBaseline\nBenchmark                     Mode  Cnt    Score    Error  Units\nBenchmarkMapConcat.mapConcat  avgt   10  999.316 \u00b1 74.728  ns/op\n\nAfter\nBenchmark                     Mode  Cnt    Score    Error  Units\nBenchmarkMapConcat.mapConcat  avgt   10  783.887 \u00b1 108.378  ns/op", "committedDate": "2020-10-27T09:00:40Z", "type": "forcePushed"}, {"oid": "980ce35a653a72d0cf9368147bdc0e6d10104bfa", "url": "https://github.com/prestodb/presto/commit/980ce35a653a72d0cf9368147bdc0e6d10104bfa", "message": "Use OptimizedTypedSet in map_concat\n\nJMH benchmark shows 22% improvement for non_empty case:\n\nBaseline\nBenchmark                     Mode  Cnt    Score    Error  Units\nBenchmarkMapConcat.mapConcat  avgt   10  999.316 \u00b1 74.728  ns/op\n\nAfter\nBenchmark                     Mode  Cnt    Score    Error  Units\nBenchmarkMapConcat.mapConcat  avgt   10  783.887 \u00b1 108.378  ns/op", "committedDate": "2020-10-27T19:14:39Z", "type": "forcePushed"}, {"oid": "7fdfe62520dc93e37d41ec0f4164c90bc27cf577", "url": "https://github.com/prestodb/presto/commit/7fdfe62520dc93e37d41ec0f4164c90bc27cf577", "message": "Use OptimizedTypedSet in map_concat\n\nJMH benchmark shows 22% improvement for non_empty case:\n\nBaseline\nBenchmark                     Mode  Cnt    Score    Error  Units\nBenchmarkMapConcat.mapConcat  avgt   10  999.316 \u00b1 74.728  ns/op\n\nAfter\nBenchmark                     Mode  Cnt    Score    Error  Units\nBenchmarkMapConcat.mapConcat  avgt   10  783.887 \u00b1 108.378  ns/op", "committedDate": "2020-10-27T19:16:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY2MDIxMA==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r515660210", "bodyText": "nit: this on a new line or everything on same line", "author": "sujay-jain", "createdAt": "2020-11-01T19:16:14Z", "path": "presto-common/src/main/java/com/facebook/presto/common/block/AbstractMapBlock.java", "diffHunk": "@@ -284,9 +284,9 @@ public Block getBlock(int position)\n         int startEntryOffset = getOffset(position);\n         int endEntryOffset = getOffset(position + 1);\n         return new SingleMapBlock(\n+                position,\n                 startEntryOffset * 2,\n-                (endEntryOffset - startEntryOffset) * 2,\n-                this);\n+                (endEntryOffset - startEntryOffset) * 2, this);\n     }", "originalCommit": "7fdfe62520dc93e37d41ec0f4164c90bc27cf577", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY2NDA1Nw==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r515664057", "bodyText": "maybe blocks[++currentBlockIndex] = block?", "author": "sujay-jain", "createdAt": "2020-11-01T19:51:46Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,198 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+\n+    private final Type elementType;\n+    private final String functionName;\n+\n+    // size is the number of elements added to the TypedSet (including null).\n+    private int size;\n+    private int hashCapacity;\n+    private int hashMask;\n+\n+    private Block[] blocks;\n+    private int maxBlockCount;\n+    private List<SelectedPositions> positionsForBlocks = new ArrayList<>();\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;\n+\n+    public OptimizedTypedSet(Type elementType, int maxBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        this.maxBlockCount = maxBlockCount;\n+        blocks = new Block[maxBlockCount];\n+        blockPositionByHash = new long[hashCapacity];\n+        Arrays.fill(blockPositionByHash, EMPTY_SLOT);\n+    }\n+\n+    /**\n+     * Add the block into the hash table blockPositionByHash using \"union\" semantics\n+     */\n+    public void addUnion(Block block)\n+    {\n+        if (positionsForBlocks.size() == maxBlockCount) {\n+            throw new IllegalArgumentException(\"Cannot add block to OptimizedTypedSet: maxBlockCount is reached\");\n+        }\n+\n+        int positionCount = block.getPositionCount();\n+\n+        currentBlockIndex++;\n+        blocks[currentBlockIndex] = block;", "originalCommit": "7fdfe62520dc93e37d41ec0f4164c90bc27cf577", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjMwNjExMw==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r516306113", "bodyText": "I believe using ++ on the same line is not preferred by Presto. But it does save one line.", "author": "yingsu00", "createdAt": "2020-11-02T22:50:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTY2NDA1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2NzcxNg==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r516067716", "bodyText": "let's declare the 2 as a constant at the top", "author": "sujay-jain", "createdAt": "2020-11-02T15:51:06Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/ArrayUnionFunction.java", "diffHunk": "@@ -43,52 +36,13 @@ public static Block union(\n     {\n         int leftArrayCount = leftArray.getPositionCount();\n         int rightArrayCount = rightArray.getPositionCount();\n-        TypedSet typedSet = new TypedSet(type, leftArrayCount + rightArrayCount, \"array_union\");\n-        BlockBuilder distinctElementBlockBuilder = type.createBlockBuilder(null, leftArrayCount + rightArrayCount);\n-        appendTypedArray(leftArray, type, typedSet, distinctElementBlockBuilder);\n-        appendTypedArray(rightArray, type, typedSet, distinctElementBlockBuilder);\n-\n-        return distinctElementBlockBuilder.build();\n-    }\n-\n-    private static void appendTypedArray(Block array, Type type, TypedSet typedSet, BlockBuilder blockBuilder)\n-    {\n-        for (int i = 0; i < array.getPositionCount(); i++) {\n-            if (!typedSet.contains(array, i)) {\n-                typedSet.add(array, i);\n-                type.appendTo(array, i, blockBuilder);\n-            }\n-        }\n-    }\n+        OptimizedTypedSet typedSet = new OptimizedTypedSet(type, 2, leftArrayCount + rightArrayCount, \"array_union\");\n ", "originalCommit": "7fdfe62520dc93e37d41ec0f4164c90bc27cf577", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk4NjUwMw==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r516986503", "bodyText": "I actually think making caller to set the maxBlockCount was not very good. In the new iteration, I removed maxBlockCount and made the number of blocks growable. So this constant 2 is now removed.", "author": "yingsu00", "createdAt": "2020-11-03T22:13:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA2NzcxNg=="}], "type": "inlineReview"}, {"oid": "0863764c17ddf513e33a6dc2b1c66dc4e713bcc9", "url": "https://github.com/prestodb/presto/commit/0863764c17ddf513e33a6dc2b1c66dc4e713bcc9", "message": "Optimize array_intersect by using OptimizedTypedSet\n\nJMH benchmark shows 35% improvement:\n\nBefore\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  540349.423 \u00b1 66298.751  ns/op\n\nAfter\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  350934.564 \u00b1 34092.598  ns/op", "committedDate": "2020-11-03T09:13:21Z", "type": "forcePushed"}, {"oid": "f35720d3b36d534d53effa147f77c2ee5a7a65f4", "url": "https://github.com/prestodb/presto/commit/f35720d3b36d534d53effa147f77c2ee5a7a65f4", "message": "Replace BenchmarkArrayIntersectFunctions with BenchmarkArraySetFunctions\n\nThis adds benchmarks for array_except and array_union as well.", "committedDate": "2020-11-05T10:11:16Z", "type": "forcePushed"}, {"oid": "13ed5a5885a04a3e41564464ae198640a72e5db1", "url": "https://github.com/prestodb/presto/commit/13ed5a5885a04a3e41564464ae198640a72e5db1", "message": "Optimize array_intersect by using OptimizedTypedSet\n\nJMH benchmark shows 35% improvement:\n\nBefore\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  540349.423 \u00b1 66298.751  ns/op\n\nAfter\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  350934.564 \u00b1 34092.598  ns/op", "committedDate": "2020-11-06T02:10:11Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYxOTc3OA==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r521619778", "bodyText": "let's move this assignment to L90 where it is being used", "author": "sujay-jain", "createdAt": "2020-11-11T20:29:13Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final String functionName;\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount, String functionName)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount, functionName);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        blocks = new Block[expectedBlockCount];\n+        positionsForBlocks = new ArrayList<>(expectedBlockCount);\n+        blockPositionByHash = initializeHashTable();\n+    }\n+\n+    /**\n+     * Union the set by adding the elements of the block, eliminating duplicates.\n+     */\n+    public void union(Block block)\n+    {\n+        int positionCount = block.getPositionCount();", "originalCommit": "13ed5a5885a04a3e41564464ae198640a72e5db1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyMjkzMg==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r521622932", "bodyText": "let's move this inside the else to keep the scope small", "author": "sujay-jain", "createdAt": "2020-11-11T20:35:25Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final String functionName;\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount, String functionName)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount, functionName);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        blocks = new Block[expectedBlockCount];\n+        positionsForBlocks = new ArrayList<>(expectedBlockCount);\n+        blockPositionByHash = initializeHashTable();\n+    }\n+\n+    /**\n+     * Union the set by adding the elements of the block, eliminating duplicates.\n+     */\n+    public void union(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        int[] positions = new int[positionCount];\n+\n+        // Add the elements to the hash table. Since union can only increase the set size, there is no need to create a separate hashtable.\n+        int positionsIndex = 0;\n+        for (int i = 0; i < positionCount; i++) {\n+            int hashPosition = getInsertPosition(blockPositionByHash, getMaskedHash(hashPosition(elementType, block, i)), block, i);\n+            if (hashPosition != INVALID_POSITION) {\n+                // There is no need to test if adding element is successful since it's on the same hash table\n+                addElement(blockPositionByHash, hashPosition, block, i);\n+                positions[positionsIndex++] = i;\n+            }\n+        }\n+\n+        getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+        size += positionsIndex;\n+    }\n+\n+    /**\n+     * Intersect the set with the elements of the block, eliminating duplicates.\n+     */\n+    public void intersect(Block block)\n+    {\n+        int positionCount = block.getPositionCount();", "originalCommit": "13ed5a5885a04a3e41564464ae198640a72e5db1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyMzkyNg==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r521623926", "bodyText": "perhaps we don't even need this variable. Can inline it into the loop directly", "author": "sujay-jain", "createdAt": "2020-11-11T20:37:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyMjkzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgzNjAzMA==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r521836030", "bodyText": "perhaps we don't even need this variable. Can inline it into the loop directly\n\npositionCount is used in the performance critical for loop. I'm sure the function call will be inlined here, but it may still be an indirect memory access through the block pointer. Besides, it's used in two different places and having a variable doesn't reduce readability. I'd prefer keeping the variable. I did move the declaration to inside of the else block.", "author": "yingsu00", "createdAt": "2020-11-12T04:44:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyMjkzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyNTEyNQ==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r521625125", "bodyText": "perhaps it is cleaner to do the +1 inside the ensureCapacity instead of here", "author": "sujay-jain", "createdAt": "2020-11-11T20:39:48Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final String functionName;\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount, String functionName)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount, functionName);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        blocks = new Block[expectedBlockCount];\n+        positionsForBlocks = new ArrayList<>(expectedBlockCount);\n+        blockPositionByHash = initializeHashTable();\n+    }\n+\n+    /**\n+     * Union the set by adding the elements of the block, eliminating duplicates.\n+     */\n+    public void union(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);", "originalCommit": "13ed5a5885a04a3e41564464ae198640a72e5db1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTgzODQ3OQ==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r521838479", "bodyText": "@sujay-jain The ensureCapacity function, by reading its name, and by numerous use cases of similar function, implies that it ensures the object size to be the value of the input capacity parameter. Here the capacity to be ensured was currentBlockIndex + 1 because the size of an array is the largest index plus 1. If we move the +1 logic inside of the function, then the function becomes  ensure the capacity of the object array to be capacity + 1 which is weird. So I think it's better to keep it this way.", "author": "yingsu00", "createdAt": "2020-11-12T04:54:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyNTEyNQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0OTIxMg==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r522349212", "bodyText": "makes sense. I missed the part that we were passing in the index", "author": "sujay-jain", "createdAt": "2020-11-12T19:09:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyNTEyNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyODkwMg==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r521628902", "bodyText": "the else part can be extracted into a function since getInsertPosition is also doing the same thing more or less.", "author": "sujay-jain", "createdAt": "2020-11-11T20:47:14Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final String functionName;\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount, String functionName)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount, functionName);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        blocks = new Block[expectedBlockCount];\n+        positionsForBlocks = new ArrayList<>(expectedBlockCount);\n+        blockPositionByHash = initializeHashTable();\n+    }\n+\n+    /**\n+     * Union the set by adding the elements of the block, eliminating duplicates.\n+     */\n+    public void union(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        int[] positions = new int[positionCount];\n+\n+        // Add the elements to the hash table. Since union can only increase the set size, there is no need to create a separate hashtable.\n+        int positionsIndex = 0;\n+        for (int i = 0; i < positionCount; i++) {\n+            int hashPosition = getInsertPosition(blockPositionByHash, getMaskedHash(hashPosition(elementType, block, i)), block, i);\n+            if (hashPosition != INVALID_POSITION) {\n+                // There is no need to test if adding element is successful since it's on the same hash table\n+                addElement(blockPositionByHash, hashPosition, block, i);\n+                positions[positionsIndex++] = i;\n+            }\n+        }\n+\n+        getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+        size += positionsIndex;\n+    }\n+\n+    /**\n+     * Intersect the set with the elements of the block, eliminating duplicates.\n+     */\n+    public void intersect(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        if (currentBlockIndex == 0) {\n+            // This set was an empty set, so the result set should also be an empty set.\n+            positionsForBlocks.add(EMPTY_SELECTED_POSITIONS);\n+            return;\n+        }\n+        else {\n+            int[] positions = ensureCapacity(positionsForBlocks.get(currentBlockIndex - 1).getPositions(), positionCount);\n+\n+            // We need to create a new hash table because the elements in the set may be removed\n+            long[] newBlockPositionByHash = initializeHashTable();\n+\n+            int positionsIndex = 0;\n+            for (int i = 0; i < positionCount; i++) {\n+                int hash = getMaskedHash(hashPosition(elementType, block, i));\n+                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+                if (positionInBlockPositionByHash == INVALID_POSITION) {\n+                    // add to the hash table if it exists in blockPositionByHash\n+                    if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                        positions[positionsIndex++] = i;\n+                    }\n+                }\n+            }\n+\n+            blockPositionByHash = newBlockPositionByHash;\n+            getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+            size = positionsIndex;\n+\n+            clearPreviousBlocks();\n+        }\n+    }\n+\n+    private long[] initializeHashTable()\n+    {\n+        long[] newBlockPositionByHash = new long[hashCapacity]; // Create a new hashtable\n+        Arrays.fill(newBlockPositionByHash, EMPTY_SLOT);\n+        return newBlockPositionByHash;\n+    }\n+\n+    /**\n+     * Add the elements of the block that do not exist in the set, eliminating duplicates, and remove all previously existing elements.\n+     */\n+    public void except(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        if (currentBlockIndex == -1) {\n+            // This set was an empty set. Call union() to remove duplicates.\n+            union(block);\n+            return;\n+        }\n+        else {\n+            currentBlockIndex++;\n+            ensureBlocksCapacity(currentBlockIndex + 1);\n+            blocks[currentBlockIndex] = block;\n+\n+            int[] positions = new int[positionCount];\n+\n+            // We need to create a new hash table because the elements in the set need be removed\n+            long[] newBlockPositionByHash = initializeHashTable();\n+\n+            int positionsIndex = 0;\n+            for (int i = 0; i < positionCount; i++) {\n+                int hash = getMaskedHash(hashPosition(elementType, block, i));\n+                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+\n+                // add to the hash table if it does not exist in blockPositionByHash\n+                if (positionInBlockPositionByHash != INVALID_POSITION) {\n+                    if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                        positions[positionsIndex++] = i;\n+                    }\n+                }\n+            }\n+\n+            blockPositionByHash = newBlockPositionByHash;\n+            getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+            size = positionsIndex;\n+\n+            clearPreviousBlocks();\n+        }\n+    }\n+\n+    /**\n+     * Build and return the block representing this set\n+     */\n+    public Block getBlock()\n+    {\n+        if (size == 0) {\n+            return elementType.createBlockBuilder(null, 0).build();\n+        }\n+\n+        if (currentBlockIndex == 0) {\n+            // Just one block. Return a DictionaryBlock\n+            Block block = blocks[currentBlockIndex];\n+            SelectedPositions selectedPositions = getPositionsForBlocks().get(currentBlockIndex);\n+\n+            if (!selectedPositions.isList()) {\n+                if (selectedPositions.size() == block.getPositionCount()) {\n+                    return block;\n+                }\n+                else {\n+                    return block.getRegion(selectedPositions.getOffset(), selectedPositions.size());\n+                }\n+            }\n+            return new DictionaryBlock(\n+                    selectedPositions.getOffset(),\n+                    selectedPositions.size(),\n+                    block,\n+                    selectedPositions.getPositions(),\n+                    false,\n+                    DictionaryId.randomDictionaryId());\n+        }\n+\n+        Block firstBlock = blocks[0];\n+        BlockBuilder blockBuilder = elementType.createBlockBuilder(\n+                null,\n+                size,\n+                toIntExact(firstBlock.getApproximateRegionLogicalSizeInBytes(0, firstBlock.getPositionCount()) / max(1, toIntExact(firstBlock.getPositionCount()))));\n+        for (int i = 0; i <= currentBlockIndex; i++) {\n+            Block block = blocks[i];\n+            SelectedPositions selectedPositions = getPositionsForBlocks().get(i);\n+            int positionCount = selectedPositions.size();\n+\n+            if (!selectedPositions.isList()) {\n+                if (positionCount == block.getPositionCount()) {\n+                    return block;\n+                }\n+                else {\n+                    return block.getRegion(selectedPositions.getOffset(), positionCount);\n+                }\n+            }\n+            int[] positions = selectedPositions.getPositions();\n+            for (int j = 0; j < positionCount; j++) {\n+                // offset is always 0\n+                int position = positions[j];\n+                if (block.isNull(position)) {\n+                    blockBuilder.appendNull();\n+                }\n+                else {\n+                    elementType.appendTo(block, position, blockBuilder);\n+                }\n+            }\n+        }\n+\n+        return blockBuilder.build();\n+    }\n+\n+    public List<SelectedPositions> getPositionsForBlocks()\n+    {\n+        return positionsForBlocks;\n+    }\n+\n+    public long getRetainedSizeInBytes()\n+    {\n+        long sizeInBytes = INSTANCE_SIZE + ARRAY_LIST_INSTANCE_SIZE + sizeOf(blockPositionByHash);\n+        for (int i = 0; i <= currentBlockIndex; i++) {\n+            sizeInBytes += sizeOf(positionsForBlocks.get(i).getPositions());\n+        }\n+        return sizeInBytes;\n+    }\n+\n+    public void ensureBlocksCapacity(int capacity)\n+    {\n+        if (blocks == null || blocks.length < capacity) {\n+            blocks = Arrays.copyOf(blocks, capacity);\n+        }\n+    }\n+\n+    private int getMaskedHash(long rawHash)\n+    {\n+        return (int) (rawHash & hashMask);\n+    }\n+\n+    /**\n+     * Return the position in the hashtable the element at Block position should be inserted.\n+     *\n+     * @return The position of the hashtable to be inserted if the element does not exist, INVALID_POSITION otherwise.\n+     * @hashPosition The position into the hashtable the linear probing starts\n+     */\n+    private int getInsertPosition(long[] hashtable, int hashPosition, Block block, int position)\n+    {\n+        while (true) {\n+            long blockPosition = hashtable[hashPosition];\n+            // Doesn't have this element\n+            if (blockPosition == EMPTY_SLOT) {\n+                // does not exist\n+                return hashPosition;\n+            }\n+            else {\n+                // Already has this element\n+                int blockIndex = (int) ((blockPosition & 0xffff_ffff_0000_0000L) >> 32);\n+                int positionWithinBlock = (int) (blockPosition & 0xffff_ffff);\n+                if (positionEqualsPosition(elementType, blocks[blockIndex], positionWithinBlock, block, position)) {\n+                    return INVALID_POSITION;\n+                }\n+            }\n+\n+            hashPosition = getMaskedHash(hashPosition + 1);\n+        }\n+    }\n+\n+    /**\n+     * Add an element to the hash table if it's not already existed.\n+     *\n+     * @param hashtable The target hash table the element to be inserted into\n+     * @param hashPosition The position into the hashtable the linear probing starts\n+     * @return true of the element is inserted, false otherwise\n+     */\n+    private boolean addElement(long[] hashtable, int hashPosition, Block block, int position)\n+    {\n+        while (true) {\n+            long blockPosition = hashtable[hashPosition];\n+\n+            // Doesn't have this element\n+            if (blockPosition == EMPTY_SLOT) {\n+                hashtable[hashPosition] = ((long) currentBlockIndex << 32) | position;\n+                return true;\n+            }\n+            else {\n+                // Already has this element\n+                int blockIndex = (int) ((blockPosition & 0xffff_ffff_0000_0000L) >> 32);\n+                int positionWithinBlock = (int) (blockPosition & 0xffff_ffff);\n+                if (positionEqualsPosition(elementType, blocks[blockIndex], positionWithinBlock, block, position)) {\n+                    return false;\n+                }", "originalCommit": "13ed5a5885a04a3e41564464ae198640a72e5db1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg0MzAwNw==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r521843007", "bodyText": "@sujay-jain I understand they share lots of similarities but there are some subtle differences. addElement returns boolean while getInsertPosition returns int. addElement does insert the element into the hashtable but getInsertPosition doesn't. The reason having both was to avoid expensive hash value calculation when there're multiple hash tables, so that calculating of the hash value on the first hash table can be reused by the second. I can change the addElement to return an int, but then the callsite would become something like this:\nif (addElement(newBlockPositionByHash, hash, block, i) == INVALID_POSITION) {\n        positions[positionsIndex++] = i;\n }\n\nThis again looks not as easy to understand than returning a boolean. It is common in multiple standard libraries that a function to add a new element into a set to return boolean than an int. What do you think?", "author": "yingsu00", "createdAt": "2020-11-12T05:10:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTYyODkwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY0ODI5MQ==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r521648291", "bodyText": "There's common functionality between except and intersect eg: the for loop. Can we try to extract the common things to functions - makes it more readable and reduces changes of bugs :)", "author": "sujay-jain", "createdAt": "2020-11-11T21:26:48Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,355 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final String functionName;\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount, String functionName)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount, functionName);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        blocks = new Block[expectedBlockCount];\n+        positionsForBlocks = new ArrayList<>(expectedBlockCount);\n+        blockPositionByHash = initializeHashTable();\n+    }\n+\n+    /**\n+     * Union the set by adding the elements of the block, eliminating duplicates.\n+     */\n+    public void union(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        int[] positions = new int[positionCount];\n+\n+        // Add the elements to the hash table. Since union can only increase the set size, there is no need to create a separate hashtable.\n+        int positionsIndex = 0;\n+        for (int i = 0; i < positionCount; i++) {\n+            int hashPosition = getInsertPosition(blockPositionByHash, getMaskedHash(hashPosition(elementType, block, i)), block, i);\n+            if (hashPosition != INVALID_POSITION) {\n+                // There is no need to test if adding element is successful since it's on the same hash table\n+                addElement(blockPositionByHash, hashPosition, block, i);\n+                positions[positionsIndex++] = i;\n+            }\n+        }\n+\n+        getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+        size += positionsIndex;\n+    }\n+\n+    /**\n+     * Intersect the set with the elements of the block, eliminating duplicates.\n+     */\n+    public void intersect(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        if (currentBlockIndex == 0) {\n+            // This set was an empty set, so the result set should also be an empty set.\n+            positionsForBlocks.add(EMPTY_SELECTED_POSITIONS);\n+            return;\n+        }\n+        else {\n+            int[] positions = ensureCapacity(positionsForBlocks.get(currentBlockIndex - 1).getPositions(), positionCount);\n+\n+            // We need to create a new hash table because the elements in the set may be removed\n+            long[] newBlockPositionByHash = initializeHashTable();\n+\n+            int positionsIndex = 0;\n+            for (int i = 0; i < positionCount; i++) {\n+                int hash = getMaskedHash(hashPosition(elementType, block, i));\n+                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+                if (positionInBlockPositionByHash == INVALID_POSITION) {\n+                    // add to the hash table if it exists in blockPositionByHash\n+                    if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                        positions[positionsIndex++] = i;\n+                    }\n+                }\n+            }\n+\n+            blockPositionByHash = newBlockPositionByHash;\n+            getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+            size = positionsIndex;\n+\n+            clearPreviousBlocks();\n+        }\n+    }\n+\n+    private long[] initializeHashTable()\n+    {\n+        long[] newBlockPositionByHash = new long[hashCapacity]; // Create a new hashtable\n+        Arrays.fill(newBlockPositionByHash, EMPTY_SLOT);\n+        return newBlockPositionByHash;\n+    }\n+\n+    /**\n+     * Add the elements of the block that do not exist in the set, eliminating duplicates, and remove all previously existing elements.\n+     */\n+    public void except(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        if (currentBlockIndex == -1) {\n+            // This set was an empty set. Call union() to remove duplicates.\n+            union(block);\n+            return;\n+        }\n+        else {", "originalCommit": "13ed5a5885a04a3e41564464ae198640a72e5db1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTg1MjkzNg==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r521852936", "bodyText": "@sujay-jain I understand they look similar, but the logic is different. intersect has\nif (positionInBlockPositionByHash == INVALID_POSITION) {\n   // Add the new element\n}\n\nBut the except has\nif (positionInBlockPositionByHash != INVALID_POSITION) {\n   // Add the new element\n}\n\nThis makes it hard to extract common method. The only part can be extracted was\nif (addElement(hashtable, hash, block, position)) {\n        positions[positionsIndex++] = position;\n}\n\nI tried to extract it to a private method:\nprivate int addElementIfNotExists(Block block, int position, int[] positions, long[] hashtable, int hash, int positionsIndex)\n    {\n        if (addElement(hashtable, hash, block, position)) {\n            positions[positionsIndex++] = position;\n        }\n        return positionsIndex;\n    }\n\nAnd now the callsites become\nintersect:\nfor (int i = 0; i < positionCount; i++) {\n                int hash = getMaskedHash(hashPosition(elementType, block, i));\n                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n                if (positionInBlockPositionByHash == INVALID_POSITION) {\n                    // add to the hash table if it exists in blockPositionByHash\n                    positionsIndex = addElementIfNotExists(block, i, positions, newBlockPositionByHash, hash, positionsIndex);\n                }\n            }\n\nexept:\nfor (int i = 0; i < positionCount; i++) {\n                int hash = getMaskedHash(hashPosition(elementType, block, i));\n                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n\n                // add to the hash table if it does not exist in blockPositionByHash\n                if (positionInBlockPositionByHash != INVALID_POSITION) {\n                    positionsIndex = addElementIfNotExists(block, i, positions, newBlockPositionByHash, hash, positionsIndex);\n                }\n            }\n\nNow you have to jump and scroll down to check what addElementIfNotExists does. Its 6 parameters makes it hard to know what's done inside. Also, it mixes operations on the hash table with the operation on positions array which are two different objects in the class that serves different purposes. It doesn't save lines either: the two lines that got extracted into a function just adds inconvenience for the readers.\nCombining these considerations I think keeping it as original may be better. If you see other ways doing this, please let me know!", "author": "yingsu00", "createdAt": "2020-11-12T05:43:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY0ODI5MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM0ODczNg==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r522348736", "bodyText": "ok, I think we can leave it as is if you feel that's cleaner. Thanks for trying it.", "author": "sujay-jain", "createdAt": "2020-11-12T19:08:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY0ODI5MQ=="}], "type": "inlineReview"}, {"oid": "4578da73101d41fbcb54eedb0cecf8e6a80f3c38", "url": "https://github.com/prestodb/presto/commit/4578da73101d41fbcb54eedb0cecf8e6a80f3c38", "message": "Optimize array_intersect by using OptimizedTypedSet\n\nJMH benchmark shows 35% improvement:\n\nBefore\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  540349.423 \u00b1 66298.751  ns/op\n\nAfter\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  350934.564 \u00b1 34092.598  ns/op", "committedDate": "2020-11-12T05:48:25Z", "type": "forcePushed"}, {"oid": "683a703e8e6078874de51d6dd618d590a5ae3f78", "url": "https://github.com/prestodb/presto/commit/683a703e8e6078874de51d6dd618d590a5ae3f78", "message": "Optimize array_intersect by using OptimizedTypedSet\n\nJMH benchmark shows 35% improvement:\n\nBefore\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  540349.423 \u00b1 66298.751  ns/op\n\nAfter\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  350934.564 \u00b1 34092.598  ns/op", "committedDate": "2020-11-12T05:53:30Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjU5Njg5Mg==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r522596892", "bodyText": "two lines.", "author": "rongrong", "createdAt": "2020-11-13T03:53:04Z", "path": "presto-common/src/main/java/com/facebook/presto/common/block/SingleMapBlock.java", "diffHunk": "@@ -120,9 +122,29 @@ public Block getLoadedBlock()\n             return this;\n         }\n         return new SingleMapBlock(\n+                positionInMap,\n                 offset,\n-                positionCount,\n-                mapBlock);\n+                positionCount, mapBlock);", "originalCommit": "e39114eec3edee89d908f54c5e44358c242e4da8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYwMDM4MA==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r522600380", "bodyText": "else is unnecessary.", "author": "rongrong", "createdAt": "2020-11-13T04:08:19Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final String functionName;\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount, String functionName)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount, functionName);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        blocks = new Block[expectedBlockCount];\n+        positionsForBlocks = new ArrayList<>(expectedBlockCount);\n+        blockPositionByHash = initializeHashTable();\n+    }\n+\n+    /**\n+     * Union the set by adding the elements of the block, eliminating duplicates.\n+     */\n+    public void union(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        int positionCount = block.getPositionCount();\n+        int[] positions = new int[positionCount];\n+\n+        // Add the elements to the hash table. Since union can only increase the set size, there is no need to create a separate hashtable.\n+        int positionsIndex = 0;\n+        for (int i = 0; i < positionCount; i++) {\n+            int hashPosition = getInsertPosition(blockPositionByHash, getMaskedHash(hashPosition(elementType, block, i)), block, i);\n+            if (hashPosition != INVALID_POSITION) {\n+                // There is no need to test if adding element is successful since it's on the same hash table\n+                addElement(blockPositionByHash, hashPosition, block, i);\n+                positions[positionsIndex++] = i;\n+            }\n+        }\n+\n+        getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+        size += positionsIndex;\n+    }\n+\n+    /**\n+     * Intersect the set with the elements of the block, eliminating duplicates.\n+     */\n+    public void intersect(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        if (currentBlockIndex == 0) {\n+            // This set was an empty set, so the result set should also be an empty set.\n+            positionsForBlocks.add(EMPTY_SELECTED_POSITIONS);\n+            return;\n+        }\n+        else {", "originalCommit": "2a2e43ee6bda9f59b2e6a404b9a00183740b5a49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYwMDQyOQ==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r522600429", "bodyText": "else is unnecessary.", "author": "rongrong", "createdAt": "2020-11-13T04:08:33Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final String functionName;\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount, String functionName)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount, functionName);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        blocks = new Block[expectedBlockCount];\n+        positionsForBlocks = new ArrayList<>(expectedBlockCount);\n+        blockPositionByHash = initializeHashTable();\n+    }\n+\n+    /**\n+     * Union the set by adding the elements of the block, eliminating duplicates.\n+     */\n+    public void union(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        int positionCount = block.getPositionCount();\n+        int[] positions = new int[positionCount];\n+\n+        // Add the elements to the hash table. Since union can only increase the set size, there is no need to create a separate hashtable.\n+        int positionsIndex = 0;\n+        for (int i = 0; i < positionCount; i++) {\n+            int hashPosition = getInsertPosition(blockPositionByHash, getMaskedHash(hashPosition(elementType, block, i)), block, i);\n+            if (hashPosition != INVALID_POSITION) {\n+                // There is no need to test if adding element is successful since it's on the same hash table\n+                addElement(blockPositionByHash, hashPosition, block, i);\n+                positions[positionsIndex++] = i;\n+            }\n+        }\n+\n+        getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+        size += positionsIndex;\n+    }\n+\n+    /**\n+     * Intersect the set with the elements of the block, eliminating duplicates.\n+     */\n+    public void intersect(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        if (currentBlockIndex == 0) {\n+            // This set was an empty set, so the result set should also be an empty set.\n+            positionsForBlocks.add(EMPTY_SELECTED_POSITIONS);\n+            return;\n+        }\n+        else {\n+            int positionCount = block.getPositionCount();\n+            int[] positions = ensureCapacity(positionsForBlocks.get(currentBlockIndex - 1).getPositions(), positionCount);\n+\n+            // We need to create a new hash table because the elements in the set may be removed\n+            long[] newBlockPositionByHash = initializeHashTable();\n+\n+            int positionsIndex = 0;\n+            for (int i = 0; i < positionCount; i++) {\n+                int hash = getMaskedHash(hashPosition(elementType, block, i));\n+                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+                if (positionInBlockPositionByHash == INVALID_POSITION) {\n+                    // add to the hash table if it exists in blockPositionByHash\n+                    if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                        positions[positionsIndex++] = i;\n+                    }\n+                }\n+            }\n+\n+            blockPositionByHash = newBlockPositionByHash;\n+            getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+            size = positionsIndex;\n+\n+            clearPreviousBlocks();\n+        }\n+    }\n+\n+    /**\n+     * Add the elements of the block that do not exist in the set, eliminating duplicates, and remove all previously existing elements.\n+     */\n+    public void except(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        if (currentBlockIndex == -1) {\n+            // This set was an empty set. Call union() to remove duplicates.\n+            union(block);\n+            return;\n+        }\n+        else {", "originalCommit": "2a2e43ee6bda9f59b2e6a404b9a00183740b5a49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYwMDYwNQ==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r522600605", "bodyText": "else is not necessary.", "author": "rongrong", "createdAt": "2020-11-13T04:09:14Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final String functionName;\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount, String functionName)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount, functionName);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        blocks = new Block[expectedBlockCount];\n+        positionsForBlocks = new ArrayList<>(expectedBlockCount);\n+        blockPositionByHash = initializeHashTable();\n+    }\n+\n+    /**\n+     * Union the set by adding the elements of the block, eliminating duplicates.\n+     */\n+    public void union(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        int positionCount = block.getPositionCount();\n+        int[] positions = new int[positionCount];\n+\n+        // Add the elements to the hash table. Since union can only increase the set size, there is no need to create a separate hashtable.\n+        int positionsIndex = 0;\n+        for (int i = 0; i < positionCount; i++) {\n+            int hashPosition = getInsertPosition(blockPositionByHash, getMaskedHash(hashPosition(elementType, block, i)), block, i);\n+            if (hashPosition != INVALID_POSITION) {\n+                // There is no need to test if adding element is successful since it's on the same hash table\n+                addElement(blockPositionByHash, hashPosition, block, i);\n+                positions[positionsIndex++] = i;\n+            }\n+        }\n+\n+        getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+        size += positionsIndex;\n+    }\n+\n+    /**\n+     * Intersect the set with the elements of the block, eliminating duplicates.\n+     */\n+    public void intersect(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        if (currentBlockIndex == 0) {\n+            // This set was an empty set, so the result set should also be an empty set.\n+            positionsForBlocks.add(EMPTY_SELECTED_POSITIONS);\n+            return;\n+        }\n+        else {\n+            int positionCount = block.getPositionCount();\n+            int[] positions = ensureCapacity(positionsForBlocks.get(currentBlockIndex - 1).getPositions(), positionCount);\n+\n+            // We need to create a new hash table because the elements in the set may be removed\n+            long[] newBlockPositionByHash = initializeHashTable();\n+\n+            int positionsIndex = 0;\n+            for (int i = 0; i < positionCount; i++) {\n+                int hash = getMaskedHash(hashPosition(elementType, block, i));\n+                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+                if (positionInBlockPositionByHash == INVALID_POSITION) {\n+                    // add to the hash table if it exists in blockPositionByHash\n+                    if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                        positions[positionsIndex++] = i;\n+                    }\n+                }\n+            }\n+\n+            blockPositionByHash = newBlockPositionByHash;\n+            getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+            size = positionsIndex;\n+\n+            clearPreviousBlocks();\n+        }\n+    }\n+\n+    /**\n+     * Add the elements of the block that do not exist in the set, eliminating duplicates, and remove all previously existing elements.\n+     */\n+    public void except(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        if (currentBlockIndex == -1) {\n+            // This set was an empty set. Call union() to remove duplicates.\n+            union(block);\n+            return;\n+        }\n+        else {\n+            currentBlockIndex++;\n+            ensureBlocksCapacity(currentBlockIndex + 1);\n+            blocks[currentBlockIndex] = block;\n+\n+            int[] positions = new int[positionCount];\n+\n+            // We need to create a new hash table because the elements in the set need be removed\n+            long[] newBlockPositionByHash = initializeHashTable();\n+\n+            int positionsIndex = 0;\n+            for (int i = 0; i < positionCount; i++) {\n+                int hash = getMaskedHash(hashPosition(elementType, block, i));\n+                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+\n+                // add to the hash table if it does not exist in blockPositionByHash\n+                if (positionInBlockPositionByHash != INVALID_POSITION) {\n+                    if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                        positions[positionsIndex++] = i;\n+                    }\n+                }\n+            }\n+\n+            blockPositionByHash = newBlockPositionByHash;\n+            getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+            size = positionsIndex;\n+\n+            clearPreviousBlocks();\n+        }\n+    }\n+\n+    /**\n+     * Build and return the block representing this set\n+     */\n+    public Block getBlock()\n+    {\n+        if (size == 0) {\n+            return elementType.createBlockBuilder(null, 0).build();\n+        }\n+\n+        if (currentBlockIndex == 0) {\n+            // Just one block. Return a DictionaryBlock\n+            Block block = blocks[currentBlockIndex];\n+            SelectedPositions selectedPositions = getPositionsForBlocks().get(currentBlockIndex);\n+\n+            if (!selectedPositions.isList()) {\n+                if (selectedPositions.size() == block.getPositionCount()) {\n+                    return block;\n+                }\n+                else {\n+                    return block.getRegion(selectedPositions.getOffset(), selectedPositions.size());\n+                }\n+            }\n+            return new DictionaryBlock(\n+                    selectedPositions.getOffset(),\n+                    selectedPositions.size(),\n+                    block,\n+                    selectedPositions.getPositions(),\n+                    false,\n+                    DictionaryId.randomDictionaryId());\n+        }\n+\n+        Block firstBlock = blocks[0];\n+        BlockBuilder blockBuilder = elementType.createBlockBuilder(\n+                null,\n+                size,\n+                toIntExact(firstBlock.getApproximateRegionLogicalSizeInBytes(0, firstBlock.getPositionCount()) / max(1, toIntExact(firstBlock.getPositionCount()))));\n+        for (int i = 0; i <= currentBlockIndex; i++) {\n+            Block block = blocks[i];\n+            SelectedPositions selectedPositions = getPositionsForBlocks().get(i);\n+            int positionCount = selectedPositions.size();\n+\n+            if (!selectedPositions.isList()) {\n+                if (positionCount == block.getPositionCount()) {\n+                    return block;\n+                }\n+                else {\n+                    return block.getRegion(selectedPositions.getOffset(), positionCount);\n+                }\n+            }\n+            int[] positions = selectedPositions.getPositions();\n+            for (int j = 0; j < positionCount; j++) {\n+                // offset is always 0\n+                int position = positions[j];\n+                if (block.isNull(position)) {\n+                    blockBuilder.appendNull();\n+                }\n+                else {\n+                    elementType.appendTo(block, position, blockBuilder);\n+                }\n+            }\n+        }\n+\n+        return blockBuilder.build();\n+    }\n+\n+    public List<SelectedPositions> getPositionsForBlocks()\n+    {\n+        return positionsForBlocks;\n+    }\n+\n+    public long getRetainedSizeInBytes()\n+    {\n+        long sizeInBytes = INSTANCE_SIZE + ARRAY_LIST_INSTANCE_SIZE + sizeOf(blockPositionByHash);\n+        for (int i = 0; i <= currentBlockIndex; i++) {\n+            sizeInBytes += sizeOf(positionsForBlocks.get(i).getPositions());\n+        }\n+        return sizeInBytes;\n+    }\n+\n+    private long[] initializeHashTable()\n+    {\n+        long[] newBlockPositionByHash = new long[hashCapacity]; // Create a new hashtable\n+        Arrays.fill(newBlockPositionByHash, EMPTY_SLOT);\n+        return newBlockPositionByHash;\n+    }\n+\n+    private void ensureBlocksCapacity(int capacity)\n+    {\n+        if (blocks == null || blocks.length < capacity) {\n+            blocks = Arrays.copyOf(blocks, capacity);\n+        }\n+    }\n+\n+    private int getMaskedHash(long rawHash)\n+    {\n+        return (int) (rawHash & hashMask);\n+    }\n+\n+    /**\n+     * Return the position in the hashtable the element at Block position should be inserted.\n+     *\n+     * @return The position of the hashtable to be inserted if the element does not exist, INVALID_POSITION otherwise.\n+     * @hashPosition The position into the hashtable the linear probing starts\n+     */\n+    private int getInsertPosition(long[] hashtable, int hashPosition, Block block, int position)\n+    {\n+        while (true) {\n+            long blockPosition = hashtable[hashPosition];\n+            // Doesn't have this element\n+            if (blockPosition == EMPTY_SLOT) {\n+                // does not exist\n+                return hashPosition;\n+            }\n+            else {", "originalCommit": "2a2e43ee6bda9f59b2e6a404b9a00183740b5a49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYwMDY3OA==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r522600678", "bodyText": "else is not neccessary.", "author": "rongrong", "createdAt": "2020-11-13T04:09:30Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final String functionName;\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount, String functionName)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount, functionName);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        blocks = new Block[expectedBlockCount];\n+        positionsForBlocks = new ArrayList<>(expectedBlockCount);\n+        blockPositionByHash = initializeHashTable();\n+    }\n+\n+    /**\n+     * Union the set by adding the elements of the block, eliminating duplicates.\n+     */\n+    public void union(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        int positionCount = block.getPositionCount();\n+        int[] positions = new int[positionCount];\n+\n+        // Add the elements to the hash table. Since union can only increase the set size, there is no need to create a separate hashtable.\n+        int positionsIndex = 0;\n+        for (int i = 0; i < positionCount; i++) {\n+            int hashPosition = getInsertPosition(blockPositionByHash, getMaskedHash(hashPosition(elementType, block, i)), block, i);\n+            if (hashPosition != INVALID_POSITION) {\n+                // There is no need to test if adding element is successful since it's on the same hash table\n+                addElement(blockPositionByHash, hashPosition, block, i);\n+                positions[positionsIndex++] = i;\n+            }\n+        }\n+\n+        getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+        size += positionsIndex;\n+    }\n+\n+    /**\n+     * Intersect the set with the elements of the block, eliminating duplicates.\n+     */\n+    public void intersect(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        if (currentBlockIndex == 0) {\n+            // This set was an empty set, so the result set should also be an empty set.\n+            positionsForBlocks.add(EMPTY_SELECTED_POSITIONS);\n+            return;\n+        }\n+        else {\n+            int positionCount = block.getPositionCount();\n+            int[] positions = ensureCapacity(positionsForBlocks.get(currentBlockIndex - 1).getPositions(), positionCount);\n+\n+            // We need to create a new hash table because the elements in the set may be removed\n+            long[] newBlockPositionByHash = initializeHashTable();\n+\n+            int positionsIndex = 0;\n+            for (int i = 0; i < positionCount; i++) {\n+                int hash = getMaskedHash(hashPosition(elementType, block, i));\n+                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+                if (positionInBlockPositionByHash == INVALID_POSITION) {\n+                    // add to the hash table if it exists in blockPositionByHash\n+                    if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                        positions[positionsIndex++] = i;\n+                    }\n+                }\n+            }\n+\n+            blockPositionByHash = newBlockPositionByHash;\n+            getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+            size = positionsIndex;\n+\n+            clearPreviousBlocks();\n+        }\n+    }\n+\n+    /**\n+     * Add the elements of the block that do not exist in the set, eliminating duplicates, and remove all previously existing elements.\n+     */\n+    public void except(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        if (currentBlockIndex == -1) {\n+            // This set was an empty set. Call union() to remove duplicates.\n+            union(block);\n+            return;\n+        }\n+        else {\n+            currentBlockIndex++;\n+            ensureBlocksCapacity(currentBlockIndex + 1);\n+            blocks[currentBlockIndex] = block;\n+\n+            int[] positions = new int[positionCount];\n+\n+            // We need to create a new hash table because the elements in the set need be removed\n+            long[] newBlockPositionByHash = initializeHashTable();\n+\n+            int positionsIndex = 0;\n+            for (int i = 0; i < positionCount; i++) {\n+                int hash = getMaskedHash(hashPosition(elementType, block, i));\n+                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+\n+                // add to the hash table if it does not exist in blockPositionByHash\n+                if (positionInBlockPositionByHash != INVALID_POSITION) {\n+                    if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                        positions[positionsIndex++] = i;\n+                    }\n+                }\n+            }\n+\n+            blockPositionByHash = newBlockPositionByHash;\n+            getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+            size = positionsIndex;\n+\n+            clearPreviousBlocks();\n+        }\n+    }\n+\n+    /**\n+     * Build and return the block representing this set\n+     */\n+    public Block getBlock()\n+    {\n+        if (size == 0) {\n+            return elementType.createBlockBuilder(null, 0).build();\n+        }\n+\n+        if (currentBlockIndex == 0) {\n+            // Just one block. Return a DictionaryBlock\n+            Block block = blocks[currentBlockIndex];\n+            SelectedPositions selectedPositions = getPositionsForBlocks().get(currentBlockIndex);\n+\n+            if (!selectedPositions.isList()) {\n+                if (selectedPositions.size() == block.getPositionCount()) {\n+                    return block;\n+                }\n+                else {\n+                    return block.getRegion(selectedPositions.getOffset(), selectedPositions.size());\n+                }\n+            }\n+            return new DictionaryBlock(\n+                    selectedPositions.getOffset(),\n+                    selectedPositions.size(),\n+                    block,\n+                    selectedPositions.getPositions(),\n+                    false,\n+                    DictionaryId.randomDictionaryId());\n+        }\n+\n+        Block firstBlock = blocks[0];\n+        BlockBuilder blockBuilder = elementType.createBlockBuilder(\n+                null,\n+                size,\n+                toIntExact(firstBlock.getApproximateRegionLogicalSizeInBytes(0, firstBlock.getPositionCount()) / max(1, toIntExact(firstBlock.getPositionCount()))));\n+        for (int i = 0; i <= currentBlockIndex; i++) {\n+            Block block = blocks[i];\n+            SelectedPositions selectedPositions = getPositionsForBlocks().get(i);\n+            int positionCount = selectedPositions.size();\n+\n+            if (!selectedPositions.isList()) {\n+                if (positionCount == block.getPositionCount()) {\n+                    return block;\n+                }\n+                else {\n+                    return block.getRegion(selectedPositions.getOffset(), positionCount);\n+                }\n+            }\n+            int[] positions = selectedPositions.getPositions();\n+            for (int j = 0; j < positionCount; j++) {\n+                // offset is always 0\n+                int position = positions[j];\n+                if (block.isNull(position)) {\n+                    blockBuilder.appendNull();\n+                }\n+                else {\n+                    elementType.appendTo(block, position, blockBuilder);\n+                }\n+            }\n+        }\n+\n+        return blockBuilder.build();\n+    }\n+\n+    public List<SelectedPositions> getPositionsForBlocks()\n+    {\n+        return positionsForBlocks;\n+    }\n+\n+    public long getRetainedSizeInBytes()\n+    {\n+        long sizeInBytes = INSTANCE_SIZE + ARRAY_LIST_INSTANCE_SIZE + sizeOf(blockPositionByHash);\n+        for (int i = 0; i <= currentBlockIndex; i++) {\n+            sizeInBytes += sizeOf(positionsForBlocks.get(i).getPositions());\n+        }\n+        return sizeInBytes;\n+    }\n+\n+    private long[] initializeHashTable()\n+    {\n+        long[] newBlockPositionByHash = new long[hashCapacity]; // Create a new hashtable\n+        Arrays.fill(newBlockPositionByHash, EMPTY_SLOT);\n+        return newBlockPositionByHash;\n+    }\n+\n+    private void ensureBlocksCapacity(int capacity)\n+    {\n+        if (blocks == null || blocks.length < capacity) {\n+            blocks = Arrays.copyOf(blocks, capacity);\n+        }\n+    }\n+\n+    private int getMaskedHash(long rawHash)\n+    {\n+        return (int) (rawHash & hashMask);\n+    }\n+\n+    /**\n+     * Return the position in the hashtable the element at Block position should be inserted.\n+     *\n+     * @return The position of the hashtable to be inserted if the element does not exist, INVALID_POSITION otherwise.\n+     * @hashPosition The position into the hashtable the linear probing starts\n+     */\n+    private int getInsertPosition(long[] hashtable, int hashPosition, Block block, int position)\n+    {\n+        while (true) {\n+            long blockPosition = hashtable[hashPosition];\n+            // Doesn't have this element\n+            if (blockPosition == EMPTY_SLOT) {\n+                // does not exist\n+                return hashPosition;\n+            }\n+            else {\n+                // Already has this element\n+                int blockIndex = (int) ((blockPosition & 0xffff_ffff_0000_0000L) >> 32);\n+                int positionWithinBlock = (int) (blockPosition & 0xffff_ffff);\n+                if (positionEqualsPosition(elementType, blocks[blockIndex], positionWithinBlock, block, position)) {\n+                    return INVALID_POSITION;\n+                }\n+            }\n+\n+            hashPosition = getMaskedHash(hashPosition + 1);\n+        }\n+    }\n+\n+    /**\n+     * Add an element to the hash table if it's not already existed.\n+     *\n+     * @param hashtable The target hash table the element to be inserted into\n+     * @param hashPosition The position into the hashtable the linear probing starts\n+     * @return true of the element is inserted, false otherwise\n+     */\n+    private boolean addElement(long[] hashtable, int hashPosition, Block block, int position)\n+    {\n+        while (true) {\n+            long blockPosition = hashtable[hashPosition];\n+\n+            // Doesn't have this element\n+            if (blockPosition == EMPTY_SLOT) {\n+                hashtable[hashPosition] = ((long) currentBlockIndex << 32) | position;\n+                return true;\n+            }\n+            else {", "originalCommit": "2a2e43ee6bda9f59b2e6a404b9a00183740b5a49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYwMDc4NQ==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r522600785", "bodyText": "else is not necessary.", "author": "rongrong", "createdAt": "2020-11-13T04:09:54Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final String functionName;\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount, String functionName)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount, functionName);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        blocks = new Block[expectedBlockCount];\n+        positionsForBlocks = new ArrayList<>(expectedBlockCount);\n+        blockPositionByHash = initializeHashTable();\n+    }\n+\n+    /**\n+     * Union the set by adding the elements of the block, eliminating duplicates.\n+     */\n+    public void union(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        int positionCount = block.getPositionCount();\n+        int[] positions = new int[positionCount];\n+\n+        // Add the elements to the hash table. Since union can only increase the set size, there is no need to create a separate hashtable.\n+        int positionsIndex = 0;\n+        for (int i = 0; i < positionCount; i++) {\n+            int hashPosition = getInsertPosition(blockPositionByHash, getMaskedHash(hashPosition(elementType, block, i)), block, i);\n+            if (hashPosition != INVALID_POSITION) {\n+                // There is no need to test if adding element is successful since it's on the same hash table\n+                addElement(blockPositionByHash, hashPosition, block, i);\n+                positions[positionsIndex++] = i;\n+            }\n+        }\n+\n+        getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+        size += positionsIndex;\n+    }\n+\n+    /**\n+     * Intersect the set with the elements of the block, eliminating duplicates.\n+     */\n+    public void intersect(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        if (currentBlockIndex == 0) {\n+            // This set was an empty set, so the result set should also be an empty set.\n+            positionsForBlocks.add(EMPTY_SELECTED_POSITIONS);\n+            return;\n+        }\n+        else {\n+            int positionCount = block.getPositionCount();\n+            int[] positions = ensureCapacity(positionsForBlocks.get(currentBlockIndex - 1).getPositions(), positionCount);\n+\n+            // We need to create a new hash table because the elements in the set may be removed\n+            long[] newBlockPositionByHash = initializeHashTable();\n+\n+            int positionsIndex = 0;\n+            for (int i = 0; i < positionCount; i++) {\n+                int hash = getMaskedHash(hashPosition(elementType, block, i));\n+                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+                if (positionInBlockPositionByHash == INVALID_POSITION) {\n+                    // add to the hash table if it exists in blockPositionByHash\n+                    if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                        positions[positionsIndex++] = i;\n+                    }\n+                }\n+            }\n+\n+            blockPositionByHash = newBlockPositionByHash;\n+            getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+            size = positionsIndex;\n+\n+            clearPreviousBlocks();\n+        }\n+    }\n+\n+    /**\n+     * Add the elements of the block that do not exist in the set, eliminating duplicates, and remove all previously existing elements.\n+     */\n+    public void except(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        if (currentBlockIndex == -1) {\n+            // This set was an empty set. Call union() to remove duplicates.\n+            union(block);\n+            return;\n+        }\n+        else {\n+            currentBlockIndex++;\n+            ensureBlocksCapacity(currentBlockIndex + 1);\n+            blocks[currentBlockIndex] = block;\n+\n+            int[] positions = new int[positionCount];\n+\n+            // We need to create a new hash table because the elements in the set need be removed\n+            long[] newBlockPositionByHash = initializeHashTable();\n+\n+            int positionsIndex = 0;\n+            for (int i = 0; i < positionCount; i++) {\n+                int hash = getMaskedHash(hashPosition(elementType, block, i));\n+                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+\n+                // add to the hash table if it does not exist in blockPositionByHash\n+                if (positionInBlockPositionByHash != INVALID_POSITION) {\n+                    if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                        positions[positionsIndex++] = i;\n+                    }\n+                }\n+            }\n+\n+            blockPositionByHash = newBlockPositionByHash;\n+            getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+            size = positionsIndex;\n+\n+            clearPreviousBlocks();\n+        }\n+    }\n+\n+    /**\n+     * Build and return the block representing this set\n+     */\n+    public Block getBlock()\n+    {\n+        if (size == 0) {\n+            return elementType.createBlockBuilder(null, 0).build();\n+        }\n+\n+        if (currentBlockIndex == 0) {\n+            // Just one block. Return a DictionaryBlock\n+            Block block = blocks[currentBlockIndex];\n+            SelectedPositions selectedPositions = getPositionsForBlocks().get(currentBlockIndex);\n+\n+            if (!selectedPositions.isList()) {\n+                if (selectedPositions.size() == block.getPositionCount()) {\n+                    return block;\n+                }\n+                else {\n+                    return block.getRegion(selectedPositions.getOffset(), selectedPositions.size());\n+                }\n+            }\n+            return new DictionaryBlock(\n+                    selectedPositions.getOffset(),\n+                    selectedPositions.size(),\n+                    block,\n+                    selectedPositions.getPositions(),\n+                    false,\n+                    DictionaryId.randomDictionaryId());\n+        }\n+\n+        Block firstBlock = blocks[0];\n+        BlockBuilder blockBuilder = elementType.createBlockBuilder(\n+                null,\n+                size,\n+                toIntExact(firstBlock.getApproximateRegionLogicalSizeInBytes(0, firstBlock.getPositionCount()) / max(1, toIntExact(firstBlock.getPositionCount()))));\n+        for (int i = 0; i <= currentBlockIndex; i++) {\n+            Block block = blocks[i];\n+            SelectedPositions selectedPositions = getPositionsForBlocks().get(i);\n+            int positionCount = selectedPositions.size();\n+\n+            if (!selectedPositions.isList()) {\n+                if (positionCount == block.getPositionCount()) {\n+                    return block;\n+                }\n+                else {", "originalCommit": "2a2e43ee6bda9f59b2e6a404b9a00183740b5a49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYwMDgzMQ==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r522600831", "bodyText": "else is not neccessary.", "author": "rongrong", "createdAt": "2020-11-13T04:10:06Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final String functionName;\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount, String functionName)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount, functionName);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        blocks = new Block[expectedBlockCount];\n+        positionsForBlocks = new ArrayList<>(expectedBlockCount);\n+        blockPositionByHash = initializeHashTable();\n+    }\n+\n+    /**\n+     * Union the set by adding the elements of the block, eliminating duplicates.\n+     */\n+    public void union(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        int positionCount = block.getPositionCount();\n+        int[] positions = new int[positionCount];\n+\n+        // Add the elements to the hash table. Since union can only increase the set size, there is no need to create a separate hashtable.\n+        int positionsIndex = 0;\n+        for (int i = 0; i < positionCount; i++) {\n+            int hashPosition = getInsertPosition(blockPositionByHash, getMaskedHash(hashPosition(elementType, block, i)), block, i);\n+            if (hashPosition != INVALID_POSITION) {\n+                // There is no need to test if adding element is successful since it's on the same hash table\n+                addElement(blockPositionByHash, hashPosition, block, i);\n+                positions[positionsIndex++] = i;\n+            }\n+        }\n+\n+        getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+        size += positionsIndex;\n+    }\n+\n+    /**\n+     * Intersect the set with the elements of the block, eliminating duplicates.\n+     */\n+    public void intersect(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        if (currentBlockIndex == 0) {\n+            // This set was an empty set, so the result set should also be an empty set.\n+            positionsForBlocks.add(EMPTY_SELECTED_POSITIONS);\n+            return;\n+        }\n+        else {\n+            int positionCount = block.getPositionCount();\n+            int[] positions = ensureCapacity(positionsForBlocks.get(currentBlockIndex - 1).getPositions(), positionCount);\n+\n+            // We need to create a new hash table because the elements in the set may be removed\n+            long[] newBlockPositionByHash = initializeHashTable();\n+\n+            int positionsIndex = 0;\n+            for (int i = 0; i < positionCount; i++) {\n+                int hash = getMaskedHash(hashPosition(elementType, block, i));\n+                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+                if (positionInBlockPositionByHash == INVALID_POSITION) {\n+                    // add to the hash table if it exists in blockPositionByHash\n+                    if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                        positions[positionsIndex++] = i;\n+                    }\n+                }\n+            }\n+\n+            blockPositionByHash = newBlockPositionByHash;\n+            getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+            size = positionsIndex;\n+\n+            clearPreviousBlocks();\n+        }\n+    }\n+\n+    /**\n+     * Add the elements of the block that do not exist in the set, eliminating duplicates, and remove all previously existing elements.\n+     */\n+    public void except(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        if (currentBlockIndex == -1) {\n+            // This set was an empty set. Call union() to remove duplicates.\n+            union(block);\n+            return;\n+        }\n+        else {\n+            currentBlockIndex++;\n+            ensureBlocksCapacity(currentBlockIndex + 1);\n+            blocks[currentBlockIndex] = block;\n+\n+            int[] positions = new int[positionCount];\n+\n+            // We need to create a new hash table because the elements in the set need be removed\n+            long[] newBlockPositionByHash = initializeHashTable();\n+\n+            int positionsIndex = 0;\n+            for (int i = 0; i < positionCount; i++) {\n+                int hash = getMaskedHash(hashPosition(elementType, block, i));\n+                int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+\n+                // add to the hash table if it does not exist in blockPositionByHash\n+                if (positionInBlockPositionByHash != INVALID_POSITION) {\n+                    if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                        positions[positionsIndex++] = i;\n+                    }\n+                }\n+            }\n+\n+            blockPositionByHash = newBlockPositionByHash;\n+            getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+            size = positionsIndex;\n+\n+            clearPreviousBlocks();\n+        }\n+    }\n+\n+    /**\n+     * Build and return the block representing this set\n+     */\n+    public Block getBlock()\n+    {\n+        if (size == 0) {\n+            return elementType.createBlockBuilder(null, 0).build();\n+        }\n+\n+        if (currentBlockIndex == 0) {\n+            // Just one block. Return a DictionaryBlock\n+            Block block = blocks[currentBlockIndex];\n+            SelectedPositions selectedPositions = getPositionsForBlocks().get(currentBlockIndex);\n+\n+            if (!selectedPositions.isList()) {\n+                if (selectedPositions.size() == block.getPositionCount()) {\n+                    return block;\n+                }\n+                else {", "originalCommit": "2a2e43ee6bda9f59b2e6a404b9a00183740b5a49", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYwNjA2Ng==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r522606066", "bodyText": "entries / 2 is very confusing to me. Maybe when compute entries in line 135, just /2 there?", "author": "rongrong", "createdAt": "2020-11-13T04:17:32Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/MapConcatFunction.java", "diffHunk": "@@ -139,42 +142,36 @@ public static Block mapConcat(MapType mapType, Object state, Block[] maps)\n             return maps[lastMapIndex];\n         }\n \n+        Type keyType = mapType.getKeyType();\n+        Type valueType = mapType.getValueType();\n+        OptimizedTypedSet typedSet = new OptimizedTypedSet(keyType, maps.length, entries / 2, FUNCTION_NAME);", "originalCommit": "5146dc9f40c905ba80eaaa691178ad352c1afa1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM0NDc2NA==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r523344764", "bodyText": "Agree it's confusing. This is because SingleMapBlock counts the positionCount for both key and value block. But line 135 is in the loop and I tend to not add more computation there. I added the following comments\n// We need to divide the entries by 2 because the maps array is SingleMapBlocks and it had the positionCount twice as large as a normal Block\nOptimizedTypedSet typedSet = new OptimizedTypedSet(keyType, maps.length, entries / 2, FUNCTION_NAME);", "author": "yingsu00", "createdAt": "2020-11-14T02:13:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYwNjA2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYwNjczMg==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r522606732", "bodyText": "What is this for?", "author": "rongrong", "createdAt": "2020-11-13T04:18:30Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,353 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final String functionName;\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount, String functionName)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount, functionName);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount, String functionName)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.functionName = functionName;", "originalCommit": "2a2e43ee6bda9f59b2e6a404b9a00183740b5a49", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMzM1NzIxMg==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r523357212", "bodyText": "@rongrong It used to be in TypedSet and used in the error message for EXCEEDED_FUNCTION_MEMORY_LIMIT. But the new implementation removed this limit so we don't need this functionName anymore. I have removed it. Thank you for the catch!", "author": "yingsu00", "createdAt": "2020-11-14T02:30:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYwNjczMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYwNzUwOQ==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r522607509", "bodyText": "Is this change intended?", "author": "rongrong", "createdAt": "2020-11-13T04:19:35Z", "path": "presto-main/src/test/java/com/facebook/presto/operator/scalar/BenchmarkMapConcat.java", "diffHunk": "@@ -92,7 +92,7 @@\n         private String name = \"map_concat\";\n \n         @Param({\"left_empty\", \"right_empty\", \"both_empty\", \"non_empty\"})\n-        private String mapConfig = \"left_empty\";\n+        private String mapConfig = \"non_empty\";", "originalCommit": "5146dc9f40c905ba80eaaa691178ad352c1afa1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjY2NTA4Ng==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r522665086", "bodyText": "Yes it is inteded. left_empty means the left input array is empty and is not the case we cared most.", "author": "yingsu00", "createdAt": "2020-11-13T05:32:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjYwNzUwOQ=="}], "type": "inlineReview"}, {"oid": "f9bd8b9e8dbce84f256dd7443990f20888d9e090", "url": "https://github.com/prestodb/presto/commit/f9bd8b9e8dbce84f256dd7443990f20888d9e090", "message": "Optimize array_intersect by using OptimizedTypedSet\n\nJMH benchmark shows 35% improvement:\n\nBefore\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  540349.423 \u00b1 66298.751  ns/op\n\nAfter\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  350934.564 \u00b1 34092.598  ns/op", "committedDate": "2020-11-14T02:44:13Z", "type": "forcePushed"}, {"oid": "6526b0aa75b6e0d246fd448dc46eef26b12e8e6a", "url": "https://github.com/prestodb/presto/commit/6526b0aa75b6e0d246fd448dc46eef26b12e8e6a", "message": "Optimize array_intersect by using OptimizedTypedSet\n\nJMH benchmark shows 35% improvement:\n\nBefore\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  540349.423 \u00b1 66298.751  ns/op\n\nAfter\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  350934.564 \u00b1 34092.598  ns/op", "committedDate": "2020-11-14T02:47:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkwNjEyNw==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r524906127", "bodyText": "curious: when would this happen? (in that case we will return the current block positions)", "author": "wenleix", "createdAt": "2020-11-17T06:13:32Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/OptimizedTypedSet.java", "diffHunk": "@@ -0,0 +1,347 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator.aggregation;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.block.DictionaryBlock;\n+import com.facebook.presto.common.block.DictionaryId;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.operator.project.SelectedPositions;\n+import org.openjdk.jol.info.ClassLayout;\n+\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+\n+import static com.facebook.presto.array.Arrays.ensureCapacity;\n+import static com.facebook.presto.operator.project.SelectedPositions.positionsList;\n+import static com.facebook.presto.type.TypeUtils.hashPosition;\n+import static com.facebook.presto.type.TypeUtils.positionEqualsPosition;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static io.airlift.slice.SizeOf.sizeOf;\n+import static it.unimi.dsi.fastutil.HashCommon.arraySize;\n+import static java.lang.Math.max;\n+import static java.lang.Math.toIntExact;\n+import static java.util.Objects.requireNonNull;\n+\n+public class OptimizedTypedSet\n+{\n+    private static final int INSTANCE_SIZE = ClassLayout.parseClass(TypedSet.class).instanceSize();\n+    private static final int ARRAY_LIST_INSTANCE_SIZE = ClassLayout.parseClass(ArrayList.class).instanceSize();\n+    private static final float FILL_RATIO = 0.75f;\n+    private static final int EMPTY_SLOT = -1;\n+    private static final int INVALID_POSITION = -1;\n+    private static final int INITIAL_BLOCK_COUNT = 2;\n+    private static final SelectedPositions EMPTY_SELECTED_POSITIONS = positionsList(new int[0], 0, 0);\n+\n+    private final Type elementType;\n+    private final int hashCapacity;\n+    private final int hashMask;\n+\n+    private int size;  // size is the number of elements added to the TypedSet (including null).\n+    private Block[] blocks;   // Keeps track of the added blocks, even if the elements of the block was not inserted into the set. Array is used to get higher performance in getInsertPosition()\n+    private List<SelectedPositions> positionsForBlocks;  // The selected positions for the added blocks, one for each added block\n+    private long[] blockPositionByHash;  // Each 64-bit long is 32-bit index for blocks + 32-bit position within block\n+    private int currentBlockIndex = -1;  // The index into the blocks array and positionsForBlocks list\n+\n+    public OptimizedTypedSet(Type elementType, int maxPositionCount)\n+    {\n+        this(elementType, INITIAL_BLOCK_COUNT, maxPositionCount);\n+    }\n+\n+    public OptimizedTypedSet(Type elementType, int expectedBlockCount, int maxPositionCount)\n+    {\n+        checkArgument(expectedBlockCount >= 0, \"expectedBlockCount must not be negative\");\n+        checkArgument(maxPositionCount >= 0, \"maxPositionCount must not be negative\");\n+\n+        this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n+        this.hashCapacity = arraySize(maxPositionCount, FILL_RATIO);\n+        this.hashMask = hashCapacity - 1;\n+\n+        blocks = new Block[expectedBlockCount];\n+        positionsForBlocks = new ArrayList<>(expectedBlockCount);\n+        blockPositionByHash = initializeHashTable();\n+    }\n+\n+    /**\n+     * Union the set by adding the elements of the block, eliminating duplicates.\n+     */\n+    public void union(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        int positionCount = block.getPositionCount();\n+        int[] positions = new int[positionCount];\n+\n+        // Add the elements to the hash table. Since union can only increase the set size, there is no need to create a separate hashtable.\n+        int positionsIndex = 0;\n+        for (int i = 0; i < positionCount; i++) {\n+            int hashPosition = getInsertPosition(blockPositionByHash, getMaskedHash(hashPosition(elementType, block, i)), block, i);\n+            if (hashPosition != INVALID_POSITION) {\n+                // There is no need to test if adding element is successful since it's on the same hash table\n+                addElement(blockPositionByHash, hashPosition, block, i);\n+                positions[positionsIndex++] = i;\n+            }\n+        }\n+\n+        getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+        size += positionsIndex;\n+    }\n+\n+    /**\n+     * Intersect the set with the elements of the block, eliminating duplicates.\n+     */\n+    public void intersect(Block block)\n+    {\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        if (currentBlockIndex == 0) {\n+            // This set was an empty set, so the result set should also be an empty set.\n+            positionsForBlocks.add(EMPTY_SELECTED_POSITIONS);\n+            return;\n+        }\n+\n+        int positionCount = block.getPositionCount();\n+        int[] positions = ensureCapacity(positionsForBlocks.get(currentBlockIndex - 1).getPositions(), positionCount);\n+\n+        // We need to create a new hash table because the elements in the set may be removed\n+        long[] newBlockPositionByHash = initializeHashTable();\n+\n+        int positionsIndex = 0;\n+        for (int i = 0; i < positionCount; i++) {\n+            int hash = getMaskedHash(hashPosition(elementType, block, i));\n+            int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+            if (positionInBlockPositionByHash == INVALID_POSITION) {\n+                // add to the hash table if it exists in blockPositionByHash\n+                if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                    positions[positionsIndex++] = i;\n+                }\n+            }\n+        }\n+\n+        blockPositionByHash = newBlockPositionByHash;\n+        getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+        size = positionsIndex;\n+\n+        clearPreviousBlocks();\n+    }\n+\n+    /**\n+     * Add the elements of the block that do not exist in the set, eliminating duplicates, and remove all previously existing elements.\n+     */\n+    public void except(Block block)\n+    {\n+        int positionCount = block.getPositionCount();\n+\n+        if (currentBlockIndex == -1) {\n+            // This set was an empty set. Call union() to remove duplicates.\n+            union(block);\n+            return;\n+        }\n+\n+        currentBlockIndex++;\n+        ensureBlocksCapacity(currentBlockIndex + 1);\n+        blocks[currentBlockIndex] = block;\n+\n+        int[] positions = new int[positionCount];\n+\n+        // We need to create a new hash table because the elements in the set need be removed\n+        long[] newBlockPositionByHash = initializeHashTable();\n+\n+        int positionsIndex = 0;\n+        for (int i = 0; i < positionCount; i++) {\n+            int hash = getMaskedHash(hashPosition(elementType, block, i));\n+            int positionInBlockPositionByHash = getInsertPosition(blockPositionByHash, hash, block, i);\n+\n+            // add to the hash table if it does not exist in blockPositionByHash\n+            if (positionInBlockPositionByHash != INVALID_POSITION) {\n+                if (addElement(newBlockPositionByHash, hash, block, i)) {\n+                    positions[positionsIndex++] = i;\n+                }\n+            }\n+        }\n+\n+        blockPositionByHash = newBlockPositionByHash;\n+        getPositionsForBlocks().add(positionsList(positions, 0, positionsIndex));\n+        size = positionsIndex;\n+\n+        clearPreviousBlocks();\n+    }\n+\n+    /**\n+     * Build and return the block representing this set\n+     */\n+    public Block getBlock()\n+    {\n+        if (size == 0) {\n+            return elementType.createBlockBuilder(null, 0).build();\n+        }\n+\n+        if (currentBlockIndex == 0) {\n+            // Just one block. Return a DictionaryBlock\n+            Block block = blocks[currentBlockIndex];\n+            SelectedPositions selectedPositions = getPositionsForBlocks().get(currentBlockIndex);\n+\n+            if (!selectedPositions.isList()) {\n+                if (selectedPositions.size() == block.getPositionCount()) {\n+                    return block;\n+                }\n+                else {\n+                    return block.getRegion(selectedPositions.getOffset(), selectedPositions.size());\n+                }\n+            }\n+            return new DictionaryBlock(\n+                    selectedPositions.getOffset(),\n+                    selectedPositions.size(),\n+                    block,\n+                    selectedPositions.getPositions(),\n+                    false,\n+                    DictionaryId.randomDictionaryId());\n+        }\n+\n+        Block firstBlock = blocks[0];\n+        BlockBuilder blockBuilder = elementType.createBlockBuilder(\n+                null,\n+                size,\n+                toIntExact(firstBlock.getApproximateRegionLogicalSizeInBytes(0, firstBlock.getPositionCount()) / max(1, toIntExact(firstBlock.getPositionCount()))));\n+        for (int i = 0; i <= currentBlockIndex; i++) {\n+            Block block = blocks[i];\n+            SelectedPositions selectedPositions = getPositionsForBlocks().get(i);\n+            int positionCount = selectedPositions.size();\n+\n+            if (!selectedPositions.isList()) {", "originalCommit": "a10eb17e18b2b206f0ce2c1c97d82aa5b606f730", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNTg3MDM4OQ==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r525870389", "bodyText": "curious: when would this happen? (in that case we will return the current block positions.\n\n@wenleix Nice catch. Right now there isn't. I put the code there in case there is cases where the whole block(without duplicates) is added. Do you think I should remove this?", "author": "yingsu00", "createdAt": "2020-11-18T07:42:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkwNjEyNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzUyOTgzNg==", "url": "https://github.com/prestodb/presto/pull/15362#discussion_r527529836", "bodyText": "curious: when would this happen? (in that case we will return the current block positions.\n\n@wenleix I removed the if (!selectedPositions.isList()) {}  code block. Thank you for the catch. Will you be able to take another look? Thank you!", "author": "yingsu00", "createdAt": "2020-11-20T08:45:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNDkwNjEyNw=="}], "type": "inlineReview"}, {"oid": "eeffc976e2d0d20d0ad90d350ba35be5a0dd29b6", "url": "https://github.com/prestodb/presto/commit/eeffc976e2d0d20d0ad90d350ba35be5a0dd29b6", "message": "Add different sizes to BenchmarkMapConcat", "committedDate": "2020-11-19T09:29:10Z", "type": "forcePushed"}, {"oid": "bb9f3f20d6df0611ab9d17456a6d2fd3600dd24e", "url": "https://github.com/prestodb/presto/commit/bb9f3f20d6df0611ab9d17456a6d2fd3600dd24e", "message": "Introducing OptimizedTypedSet", "committedDate": "2020-11-20T04:15:58Z", "type": "commit"}, {"oid": "9fa35e6895978088dcdc54c45437e83cf133912d", "url": "https://github.com/prestodb/presto/commit/9fa35e6895978088dcdc54c45437e83cf133912d", "message": "Optimize map_concat using OptimizedTypedSet\n\nJMH benchmark shows 1.82x improvement for non_empty case when keyCount=100\nand POSITIONS=1000:\n\nBaseline\nBenchmark                     Mode  Cnt      Score      Error  Units\nBenchmarkMapConcat.mapConcat  avgt   20  26710.925 \u00b1 2005.756  ns/op\nRetained Size: 1,402,374 bytes\n\nAfter\nBenchmark                     Mode  Cnt      Score      Error  Units\nBenchmarkMapConcat.mapConcat  avgt   20  14605.437 \u00b1 1209.786  ns/op\nRetained Size: 1,373,273 bytes\n\nWhen keyCount=1000 and POSITIONS=1000, the baseline just OOMed. The\noptimized version succeeded.\n\nAdd different sizes to BenchmarkMapConcat", "committedDate": "2020-11-20T08:04:27Z", "type": "commit"}, {"oid": "5efff893a855e7af4b5409e972561ee1c35e65e2", "url": "https://github.com/prestodb/presto/commit/5efff893a855e7af4b5409e972561ee1c35e65e2", "message": "Optimize array_union using OptimizedTypedSet\n\nJMH benchmark shows up to 40% improvement:\n\nType       | Baseline  | Specialized Baseline | OptimizedTypedSet | Gain%\n-----------|-----------|----------------------|-------------------|----------\nBIGINT     |      5511 |                 3742 |            3320   |      40%\nVARCHAR    |     20414 |                 N/A  |            14155  |      31%", "committedDate": "2020-11-20T08:30:07Z", "type": "commit"}, {"oid": "766de45aa6fe2efb86647c8edb79ab6a04618085", "url": "https://github.com/prestodb/presto/commit/766de45aa6fe2efb86647c8edb79ab6a04618085", "message": "Optimize array_except by using OptimizedTypedSet\n\nJMH benchmark shows 40% improvement:\n\nBefore\nBenchmark                               Mode  Cnt       Score        Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  618074.452 \u00b1 119912.203  ns/op\n\nAfter\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  376854.064 \u00b1 21616.063  ns/op", "committedDate": "2020-11-20T08:30:08Z", "type": "commit"}, {"oid": "87d7f180fc6dec2f403cdbaf2098ffac2d91e2a2", "url": "https://github.com/prestodb/presto/commit/87d7f180fc6dec2f403cdbaf2098ffac2d91e2a2", "message": "Optimize array_intersect by using OptimizedTypedSet\n\nJMH benchmark shows 35% improvement:\n\nBefore\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  540349.423 \u00b1 66298.751  ns/op\n\nAfter\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  350934.564 \u00b1 34092.598  ns/op", "committedDate": "2020-11-20T08:30:08Z", "type": "commit"}, {"oid": "87d7f180fc6dec2f403cdbaf2098ffac2d91e2a2", "url": "https://github.com/prestodb/presto/commit/87d7f180fc6dec2f403cdbaf2098ffac2d91e2a2", "message": "Optimize array_intersect by using OptimizedTypedSet\n\nJMH benchmark shows 35% improvement:\n\nBefore\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  540349.423 \u00b1 66298.751  ns/op\n\nAfter\nBenchmark                               Mode  Cnt       Score       Error  Units\nBenchmarkArrayIntersect.arrayIntersect  avgt   10  350934.564 \u00b1 34092.598  ns/op", "committedDate": "2020-11-20T08:30:08Z", "type": "forcePushed"}]}