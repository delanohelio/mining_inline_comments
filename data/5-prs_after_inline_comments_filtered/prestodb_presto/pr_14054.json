{"pr_number": 14054, "pr_title": "Improve verification for map columns", "pr_createdAt": "2020-02-03T21:44:47Z", "pr_url": "https://github.com/prestodb/presto/pull/14054", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM3NTA1MQ==", "url": "https://github.com/prestodb/presto/pull/14054#discussion_r374375051", "bodyText": "This doesn't seem right. I think we need to have multiple columns here, e.g. checksum(m), checksum(array_sort(map_keys(m))) and checksum(array_sort(map_values(m)))", "author": "mbasmanova", "createdAt": "2020-02-03T22:21:48Z", "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/checksum/MapColumnValidator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.verifier.checksum;\n+\n+import com.facebook.presto.spi.type.MapType;\n+import com.facebook.presto.spi.type.Type;\n+import com.facebook.presto.sql.tree.CoalesceExpression;\n+import com.facebook.presto.sql.tree.Expression;\n+import com.facebook.presto.sql.tree.FunctionCall;\n+import com.facebook.presto.sql.tree.LongLiteral;\n+import com.facebook.presto.sql.tree.QualifiedName;\n+import com.facebook.presto.sql.tree.SingleColumn;\n+import com.facebook.presto.verifier.framework.Column;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.inject.Inject;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.verifier.framework.VerifierUtil.delimitedIdentifier;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.lang.String.format;\n+\n+public class MapColumnValidator\n+        implements ColumnValidator\n+{\n+    @Inject\n+    public MapColumnValidator()\n+    {\n+    }\n+\n+    @Override\n+    public List<SingleColumn> generateChecksumColumns(Column column)\n+    {\n+        checkArgument(column.getType() instanceof MapType, \"Expect MapType, found %s\", column.getType().getDisplayName());\n+        Type keyType = ((MapType) column.getType()).getKeyType();\n+        Type valueType = ((MapType) column.getType()).getValueType();\n+\n+        ImmutableList.Builder<Expression> checksums = ImmutableList.builder();\n+        checksums.add(new FunctionCall(QualifiedName.of(\"checksum\"), ImmutableList.of(column.getIdentifier())));\n+\n+        Expression mapCardinalitySum = new CoalesceExpression(\n+                new FunctionCall(\n+                        QualifiedName.of(\"sum\"),\n+                        ImmutableList.of(new FunctionCall(QualifiedName.of(\"cardinality\"), ImmutableList.of(column.getIdentifier())))),\n+                new LongLiteral(\"0\"));\n+\n+        if (keyType.isOrderable()) {\n+            FunctionCall mapKeys = new FunctionCall(QualifiedName.of(\"map_keys\"), ImmutableList.of(column.getIdentifier()));\n+            FunctionCall sortKeys = new FunctionCall(QualifiedName.of(\"array_sort\"), ImmutableList.of(mapKeys));\n+            checksums.add(new FunctionCall(QualifiedName.of(\"checksum\"), ImmutableList.of(sortKeys)));\n+        }\n+\n+        if (valueType.isOrderable()) {\n+            FunctionCall mapValues = new FunctionCall(QualifiedName.of(\"map_values\"), ImmutableList.of(column.getIdentifier()));\n+            FunctionCall sortValues = new FunctionCall(QualifiedName.of(\"array_sort\"), ImmutableList.of(mapValues));\n+            checksums.add(new FunctionCall(QualifiedName.of(\"checksum\"), ImmutableList.of(sortValues)));\n+        }\n+\n+        return ImmutableList.of(\n+                new SingleColumn(new CoalesceExpression(checksums.build()), Optional.of(delimitedIdentifier(getChecksumColumnAlias(column)))),", "originalCommit": "a80129143eb365ef0d5c8a8111dd625d629927a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NDM3NTIwNA==", "url": "https://github.com/prestodb/presto/pull/14054#discussion_r374375204", "bodyText": "Shouldn't there be separate checksums for keys and values?", "author": "mbasmanova", "createdAt": "2020-02-03T22:22:12Z", "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/checksum/MapColumnValidator.java", "diffHunk": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.verifier.checksum;\n+\n+import com.facebook.presto.spi.type.MapType;\n+import com.facebook.presto.spi.type.Type;\n+import com.facebook.presto.sql.tree.CoalesceExpression;\n+import com.facebook.presto.sql.tree.Expression;\n+import com.facebook.presto.sql.tree.FunctionCall;\n+import com.facebook.presto.sql.tree.LongLiteral;\n+import com.facebook.presto.sql.tree.QualifiedName;\n+import com.facebook.presto.sql.tree.SingleColumn;\n+import com.facebook.presto.verifier.framework.Column;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.inject.Inject;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.verifier.framework.VerifierUtil.delimitedIdentifier;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.lang.String.format;\n+\n+public class MapColumnValidator\n+        implements ColumnValidator\n+{\n+    @Inject\n+    public MapColumnValidator()\n+    {\n+    }\n+\n+    @Override\n+    public List<SingleColumn> generateChecksumColumns(Column column)\n+    {\n+        checkArgument(column.getType() instanceof MapType, \"Expect MapType, found %s\", column.getType().getDisplayName());\n+        Type keyType = ((MapType) column.getType()).getKeyType();\n+        Type valueType = ((MapType) column.getType()).getValueType();\n+\n+        ImmutableList.Builder<Expression> checksums = ImmutableList.builder();\n+        checksums.add(new FunctionCall(QualifiedName.of(\"checksum\"), ImmutableList.of(column.getIdentifier())));\n+\n+        Expression mapCardinalitySum = new CoalesceExpression(\n+                new FunctionCall(\n+                        QualifiedName.of(\"sum\"),\n+                        ImmutableList.of(new FunctionCall(QualifiedName.of(\"cardinality\"), ImmutableList.of(column.getIdentifier())))),\n+                new LongLiteral(\"0\"));\n+\n+        if (keyType.isOrderable()) {\n+            FunctionCall mapKeys = new FunctionCall(QualifiedName.of(\"map_keys\"), ImmutableList.of(column.getIdentifier()));\n+            FunctionCall sortKeys = new FunctionCall(QualifiedName.of(\"array_sort\"), ImmutableList.of(mapKeys));\n+            checksums.add(new FunctionCall(QualifiedName.of(\"checksum\"), ImmutableList.of(sortKeys)));\n+        }\n+\n+        if (valueType.isOrderable()) {\n+            FunctionCall mapValues = new FunctionCall(QualifiedName.of(\"map_values\"), ImmutableList.of(column.getIdentifier()));\n+            FunctionCall sortValues = new FunctionCall(QualifiedName.of(\"array_sort\"), ImmutableList.of(mapValues));\n+            checksums.add(new FunctionCall(QualifiedName.of(\"checksum\"), ImmutableList.of(sortValues)));\n+        }\n+\n+        return ImmutableList.of(\n+                new SingleColumn(new CoalesceExpression(checksums.build()), Optional.of(delimitedIdentifier(getChecksumColumnAlias(column)))),\n+                new SingleColumn(mapCardinalitySum, Optional.of(delimitedIdentifier(getCardinalitySumColumnAlias(column)))));\n+    }\n+\n+    @Override\n+    public ColumnMatchResult validate(Column column, ChecksumResult controlResult, ChecksumResult testResult)\n+    {\n+        String checksumColumnAlias = getChecksumColumnAlias(column);\n+        Object controlChecksum = controlResult.getChecksum(checksumColumnAlias);\n+        Object testChecksum = testResult.getChecksum(checksumColumnAlias);\n+\n+        String cardinalitySumColumnAlias = getCardinalitySumColumnAlias(column);\n+        Object controlCardinalitySum = controlResult.getChecksum(cardinalitySumColumnAlias);\n+        Object testCardinalitySum = testResult.getChecksum(cardinalitySumColumnAlias);\n+\n+        return new ColumnMatchResult(\n+                Objects.equals(controlChecksum, testChecksum) && Objects.equals(controlCardinalitySum, testCardinalitySum),\n+                format(\n+                        \"control(checksum: %s, cardinality_sum: %s) test(checksum: %s, cardinality_sum: %s)\",", "originalCommit": "a80129143eb365ef0d5c8a8111dd625d629927a0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ3OTkyMA==", "url": "https://github.com/prestodb/presto/pull/14054#discussion_r375479920", "bodyText": "typo: value", "author": "caithagoras", "createdAt": "2020-02-05T20:05:21Z", "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/checksum/MapColumnValidator.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.verifier.checksum;\n+\n+import com.facebook.presto.spi.type.MapType;\n+import com.facebook.presto.spi.type.Type;\n+import com.facebook.presto.sql.tree.CoalesceExpression;\n+import com.facebook.presto.sql.tree.Expression;\n+import com.facebook.presto.sql.tree.FunctionCall;\n+import com.facebook.presto.sql.tree.LongLiteral;\n+import com.facebook.presto.sql.tree.QualifiedName;\n+import com.facebook.presto.sql.tree.SingleColumn;\n+import com.facebook.presto.verifier.framework.Column;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.inject.Inject;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.verifier.framework.VerifierUtil.delimitedIdentifier;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.lang.String.format;\n+\n+public class MapColumnValidator\n+        implements ColumnValidator\n+{\n+    @Inject\n+    public MapColumnValidator()\n+    {\n+    }\n+\n+    @Override\n+    public List<SingleColumn> generateChecksumColumns(Column column)\n+    {\n+        checkArgument(column.getType() instanceof MapType, \"Expect MapType, found %s\", column.getType().getDisplayName());\n+        Type keyType = ((MapType) column.getType()).getKeyType();\n+        Type valueType = ((MapType) column.getType()).getValueType();\n+\n+        Expression checksum = new FunctionCall(QualifiedName.of(\"checksum\"), ImmutableList.of(column.getIdentifier()));\n+\n+        Expression keysChecksum;\n+        FunctionCall mapKeys = new FunctionCall(QualifiedName.of(\"map_keys\"), ImmutableList.of(column.getIdentifier()));\n+        if (keyType.isOrderable()) {\n+            FunctionCall sortKeys = new FunctionCall(QualifiedName.of(\"array_sort\"), ImmutableList.of(mapKeys));\n+            keysChecksum = new FunctionCall(QualifiedName.of(\"checksum\"), ImmutableList.of(sortKeys));\n+        }\n+        else {\n+            keysChecksum = new FunctionCall(QualifiedName.of(\"checksum\"), ImmutableList.of(mapKeys));\n+        }\n+\n+        Expression valuesChecksum;\n+        FunctionCall mapValues = new FunctionCall(QualifiedName.of(\"map_values\"), ImmutableList.of(column.getIdentifier()));\n+        if (valueType.isOrderable()) {\n+            FunctionCall sortValues = new FunctionCall(QualifiedName.of(\"array_sort\"), ImmutableList.of(mapValues));\n+            valuesChecksum = new FunctionCall(QualifiedName.of(\"checksum\"), ImmutableList.of(sortValues));\n+        }\n+        else {\n+            valuesChecksum = new FunctionCall(QualifiedName.of(\"checksum\"), ImmutableList.of(mapValues));\n+        }\n+\n+        Expression mapCardinalitySum = new CoalesceExpression(\n+                new FunctionCall(\n+                        QualifiedName.of(\"sum\"),\n+                        ImmutableList.of(new FunctionCall(QualifiedName.of(\"cardinality\"), ImmutableList.of(column.getIdentifier())))),\n+                new LongLiteral(\"0\"));\n+\n+        return ImmutableList.of(\n+                new SingleColumn(checksum, Optional.of(delimitedIdentifier(getChecksumColumnAlias(column)))),\n+                new SingleColumn(keysChecksum, Optional.of(delimitedIdentifier(getKeysChecksumColumnAlias(column)))),\n+                new SingleColumn(valuesChecksum, Optional.of(delimitedIdentifier(getValuesChecksumColumnAlias(column)))),\n+                new SingleColumn(mapCardinalitySum, Optional.of(delimitedIdentifier(getCardinalitySumColumnAlias(column)))));\n+    }\n+\n+    @Override\n+    public ColumnMatchResult validate(Column column, ChecksumResult controlResult, ChecksumResult testResult)\n+    {\n+        String checksumColumnAlias = getChecksumColumnAlias(column);\n+        Object controlChecksum = controlResult.getChecksum(checksumColumnAlias);\n+        Object testChecksum = testResult.getChecksum(checksumColumnAlias);\n+\n+        String keysChecksumColumnAlias = getKeysChecksumColumnAlias(column);\n+        Object controlKeysChecksum = controlResult.getChecksum(keysChecksumColumnAlias);\n+        Object testKeysChecksum = testResult.getChecksum(keysChecksumColumnAlias);\n+\n+        String valuesChecksumColumnAlias = getValuesChecksumColumnAlias(column);\n+        Object controlValuesChecksum = controlResult.getChecksum(valuesChecksumColumnAlias);\n+        Object testValuesChecksum = testResult.getChecksum(valuesChecksumColumnAlias);\n+\n+        String cardinalitySumColumnAlias = getCardinalitySumColumnAlias(column);\n+        Object controlCardinalitySum = controlResult.getChecksum(cardinalitySumColumnAlias);\n+        Object testCardinalitySum = testResult.getChecksum(cardinalitySumColumnAlias);\n+\n+        return new ColumnMatchResult(\n+                Objects.equals(controlChecksum, testChecksum) && Objects.equals(controlCardinalitySum, testCardinalitySum),\n+                format(\n+                        \"control(checksum: %s, keys_checksum: %s, alues_checksum: %s, cardinality_sum: %s) \" +", "originalCommit": "e7a519d9f9153feb5349e185b8e73524ff8ec56b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ4MTM2Mw==", "url": "https://github.com/prestodb/presto/pull/14054#discussion_r375481363", "bodyText": "Can be simplified as, as below\nFunctionCall keys = ...\nif (keyType.isOrderable()) {\n   keys = ...\n}\nExpression keysChecksum = new FunctionCall(QualifiedName.of(\"checksum\"), ImmutableList.of(keys));", "author": "caithagoras", "createdAt": "2020-02-05T20:08:38Z", "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/checksum/MapColumnValidator.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.verifier.checksum;\n+\n+import com.facebook.presto.spi.type.MapType;\n+import com.facebook.presto.spi.type.Type;\n+import com.facebook.presto.sql.tree.CoalesceExpression;\n+import com.facebook.presto.sql.tree.Expression;\n+import com.facebook.presto.sql.tree.FunctionCall;\n+import com.facebook.presto.sql.tree.LongLiteral;\n+import com.facebook.presto.sql.tree.QualifiedName;\n+import com.facebook.presto.sql.tree.SingleColumn;\n+import com.facebook.presto.verifier.framework.Column;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.inject.Inject;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.verifier.framework.VerifierUtil.delimitedIdentifier;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.lang.String.format;\n+\n+public class MapColumnValidator\n+        implements ColumnValidator\n+{\n+    @Inject\n+    public MapColumnValidator()\n+    {\n+    }\n+\n+    @Override\n+    public List<SingleColumn> generateChecksumColumns(Column column)\n+    {\n+        checkArgument(column.getType() instanceof MapType, \"Expect MapType, found %s\", column.getType().getDisplayName());\n+        Type keyType = ((MapType) column.getType()).getKeyType();\n+        Type valueType = ((MapType) column.getType()).getValueType();\n+\n+        Expression checksum = new FunctionCall(QualifiedName.of(\"checksum\"), ImmutableList.of(column.getIdentifier()));\n+\n+        Expression keysChecksum;\n+        FunctionCall mapKeys = new FunctionCall(QualifiedName.of(\"map_keys\"), ImmutableList.of(column.getIdentifier()));\n+        if (keyType.isOrderable()) {\n+            FunctionCall sortKeys = new FunctionCall(QualifiedName.of(\"array_sort\"), ImmutableList.of(mapKeys));\n+            keysChecksum = new FunctionCall(QualifiedName.of(\"checksum\"), ImmutableList.of(sortKeys));\n+        }\n+        else {\n+            keysChecksum = new FunctionCall(QualifiedName.of(\"checksum\"), ImmutableList.of(mapKeys));\n+        }", "originalCommit": "e7a519d9f9153feb5349e185b8e73524ff8ec56b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTQ4Mjk3MA==", "url": "https://github.com/prestodb/presto/pull/14054#discussion_r375482970", "bodyText": "Also make sure key checksum matches and and value checksum matches.\nnit: one condition per line for long line:\nObject.equals(...)\n    && Object.equals(...)\n    && Object.equals(...)\n    && Object.equals(...)", "author": "caithagoras", "createdAt": "2020-02-05T20:12:08Z", "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/checksum/MapColumnValidator.java", "diffHunk": "@@ -0,0 +1,140 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.verifier.checksum;\n+\n+import com.facebook.presto.spi.type.MapType;\n+import com.facebook.presto.spi.type.Type;\n+import com.facebook.presto.sql.tree.CoalesceExpression;\n+import com.facebook.presto.sql.tree.Expression;\n+import com.facebook.presto.sql.tree.FunctionCall;\n+import com.facebook.presto.sql.tree.LongLiteral;\n+import com.facebook.presto.sql.tree.QualifiedName;\n+import com.facebook.presto.sql.tree.SingleColumn;\n+import com.facebook.presto.verifier.framework.Column;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.inject.Inject;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.verifier.framework.VerifierUtil.delimitedIdentifier;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.lang.String.format;\n+\n+public class MapColumnValidator\n+        implements ColumnValidator\n+{\n+    @Inject\n+    public MapColumnValidator()\n+    {\n+    }\n+\n+    @Override\n+    public List<SingleColumn> generateChecksumColumns(Column column)\n+    {\n+        checkArgument(column.getType() instanceof MapType, \"Expect MapType, found %s\", column.getType().getDisplayName());\n+        Type keyType = ((MapType) column.getType()).getKeyType();\n+        Type valueType = ((MapType) column.getType()).getValueType();\n+\n+        Expression checksum = new FunctionCall(QualifiedName.of(\"checksum\"), ImmutableList.of(column.getIdentifier()));\n+\n+        Expression keysChecksum;\n+        FunctionCall mapKeys = new FunctionCall(QualifiedName.of(\"map_keys\"), ImmutableList.of(column.getIdentifier()));\n+        if (keyType.isOrderable()) {\n+            FunctionCall sortKeys = new FunctionCall(QualifiedName.of(\"array_sort\"), ImmutableList.of(mapKeys));\n+            keysChecksum = new FunctionCall(QualifiedName.of(\"checksum\"), ImmutableList.of(sortKeys));\n+        }\n+        else {\n+            keysChecksum = new FunctionCall(QualifiedName.of(\"checksum\"), ImmutableList.of(mapKeys));\n+        }\n+\n+        Expression valuesChecksum;\n+        FunctionCall mapValues = new FunctionCall(QualifiedName.of(\"map_values\"), ImmutableList.of(column.getIdentifier()));\n+        if (valueType.isOrderable()) {\n+            FunctionCall sortValues = new FunctionCall(QualifiedName.of(\"array_sort\"), ImmutableList.of(mapValues));\n+            valuesChecksum = new FunctionCall(QualifiedName.of(\"checksum\"), ImmutableList.of(sortValues));\n+        }\n+        else {\n+            valuesChecksum = new FunctionCall(QualifiedName.of(\"checksum\"), ImmutableList.of(mapValues));\n+        }\n+\n+        Expression mapCardinalitySum = new CoalesceExpression(\n+                new FunctionCall(\n+                        QualifiedName.of(\"sum\"),\n+                        ImmutableList.of(new FunctionCall(QualifiedName.of(\"cardinality\"), ImmutableList.of(column.getIdentifier())))),\n+                new LongLiteral(\"0\"));\n+\n+        return ImmutableList.of(\n+                new SingleColumn(checksum, Optional.of(delimitedIdentifier(getChecksumColumnAlias(column)))),\n+                new SingleColumn(keysChecksum, Optional.of(delimitedIdentifier(getKeysChecksumColumnAlias(column)))),\n+                new SingleColumn(valuesChecksum, Optional.of(delimitedIdentifier(getValuesChecksumColumnAlias(column)))),\n+                new SingleColumn(mapCardinalitySum, Optional.of(delimitedIdentifier(getCardinalitySumColumnAlias(column)))));\n+    }\n+\n+    @Override\n+    public ColumnMatchResult validate(Column column, ChecksumResult controlResult, ChecksumResult testResult)\n+    {\n+        String checksumColumnAlias = getChecksumColumnAlias(column);\n+        Object controlChecksum = controlResult.getChecksum(checksumColumnAlias);\n+        Object testChecksum = testResult.getChecksum(checksumColumnAlias);\n+\n+        String keysChecksumColumnAlias = getKeysChecksumColumnAlias(column);\n+        Object controlKeysChecksum = controlResult.getChecksum(keysChecksumColumnAlias);\n+        Object testKeysChecksum = testResult.getChecksum(keysChecksumColumnAlias);\n+\n+        String valuesChecksumColumnAlias = getValuesChecksumColumnAlias(column);\n+        Object controlValuesChecksum = controlResult.getChecksum(valuesChecksumColumnAlias);\n+        Object testValuesChecksum = testResult.getChecksum(valuesChecksumColumnAlias);\n+\n+        String cardinalitySumColumnAlias = getCardinalitySumColumnAlias(column);\n+        Object controlCardinalitySum = controlResult.getChecksum(cardinalitySumColumnAlias);\n+        Object testCardinalitySum = testResult.getChecksum(cardinalitySumColumnAlias);\n+\n+        return new ColumnMatchResult(\n+                Objects.equals(controlChecksum, testChecksum) && Objects.equals(controlCardinalitySum, testCardinalitySum),", "originalCommit": "e7a519d9f9153feb5349e185b8e73524ff8ec56b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU0NTI4Mg==", "url": "https://github.com/prestodb/presto/pull/14054#discussion_r375545282", "bodyText": "Your formatting is off. Please follow 7e and 7f  in https://our.internmc.facebook.com/intern/wiki/DataInfra/Presto/Source/\nto install Airlift code style, and then format the file with (option + cmd + L).", "author": "caithagoras", "createdAt": "2020-02-05T22:31:38Z", "path": "presto-verifier/src/test/java/com/facebook/presto/verifier/checksum/TestChecksumValidator.java", "diffHunk": "@@ -297,9 +304,9 @@ public void testArray()\n         ChecksumResult controlChecksum = new ChecksumResult(\n                 5,\n                 ImmutableMap.<String, Object>builder()\n-                        .put(\"int_array_checksum\", new SqlVarbinary(new byte[] {0xa}))\n+                        .put(\"int_array_checksum\", new SqlVarbinary(new byte[]{0xa}))", "originalCommit": "3dfe36c5e4b016c2b0ac1877e41ab82f04d46550", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3NTU0Njg4Mw==", "url": "https://github.com/prestodb/presto/pull/14054#discussion_r375546883", "bodyText": "nit: all arguments on the same line, or one argument per line. Same below.", "author": "caithagoras", "createdAt": "2020-02-05T22:35:54Z", "path": "presto-verifier/src/test/java/com/facebook/presto/verifier/checksum/TestChecksumValidator.java", "diffHunk": "@@ -387,4 +394,70 @@ public void testRow()\n                         .put(ROW_COLUMN, new ColumnMatchResult(false, \"control(row_checksum: 0a, row$$col3_checksum: 0d) test(row_checksum: 1a, row$$col3_checksum: 1d)\"))\n                         .build());\n     }\n+\n+    @Test\n+    public void testMap()\n+    {\n+        List<Column> columns = ImmutableList.of(MAP_COLUMN);\n+\n+        ChecksumResult controlChecksum = new ChecksumResult(\n+                5,\n+                ImmutableMap.<String, Object>builder()\n+                        .put(\"map_checksum\", new SqlVarbinary(new byte[] {0xa}))\n+                        .put(\"map_keys_checksum\", new SqlVarbinary(new byte[] {0xb}))\n+                        .put(\"map_values_checksum\", new SqlVarbinary(new byte[] {0xc}))\n+                        .put(\"map_cardinality_sum\", 3L)\n+                        .build());\n+\n+        // Matched\n+        assertTrue(checksumValidator.getMismatchedColumns(columns, controlChecksum, controlChecksum).isEmpty());\n+\n+        // Mismatched map checksum\n+        ChecksumResult testChecksum = new ChecksumResult(\n+                5,\n+                ImmutableMap.<String, Object>builder()\n+                        .put(\"map_checksum\", new SqlVarbinary(new byte[]{0x1a}))\n+                        .put(\"map_keys_checksum\", new SqlVarbinary(new byte[]{0x0b}))\n+                        .put(\"map_values_checksum\", new SqlVarbinary(new byte[]{0x0c}))\n+                        .put(\"map_cardinality_sum\", 3L)\n+                        .build());\n+        assertEquals(\n+                checksumValidator.getMismatchedColumns(columns, controlChecksum, testChecksum),\n+                ImmutableMap.builder()\n+                        .put(MAP_COLUMN, new ColumnMatchResult(false, \"control(checksum: 0a, keys_checksum: 0b, values_checksum: 0c, cardinality_sum: 3) \" +\n+                                \"test(checksum: 1a, keys_checksum: 0b, values_checksum: 0c, cardinality_sum: 3)\"))", "originalCommit": "3dfe36c5e4b016c2b0ac1877e41ab82f04d46550", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cb58b5928b9b111581bcc9d547436164ae874183", "url": "https://github.com/prestodb/presto/commit/cb58b5928b9b111581bcc9d547436164ae874183", "message": "Initial commit: add verification mismatch info for map columns\n\nAdd separate columns for map keys checksum and values checksum\n\nAddress code comments and add tests\n\nFix formatting\n\nFix formatting", "committedDate": "2020-02-06T16:28:26Z", "type": "forcePushed"}, {"oid": "c36408419e2eb8820390d27a6a2aff9e1d5fb33b", "url": "https://github.com/prestodb/presto/commit/c36408419e2eb8820390d27a6a2aff9e1d5fb33b", "message": "Improve verification for map columns", "committedDate": "2020-02-07T15:59:43Z", "type": "forcePushed"}, {"oid": "2cbe26951bf8480f2bced6848bb3da6f9b0206ba", "url": "https://github.com/prestodb/presto/commit/2cbe26951bf8480f2bced6848bb3da6f9b0206ba", "message": "Resolve merge conflicts", "committedDate": "2020-02-10T16:06:25Z", "type": "forcePushed"}, {"oid": "1022df1279ef704f4b37d77b01769fa0ceca8db0", "url": "https://github.com/prestodb/presto/commit/1022df1279ef704f4b37d77b01769fa0ceca8db0", "message": "Improve verification for map columns\n\nAdd checksums for map key, values and map sizes.", "committedDate": "2020-02-10T16:23:40Z", "type": "forcePushed"}, {"oid": "a8a94472ea4c9d0964faac46082c829a94a2c2a2", "url": "https://github.com/prestodb/presto/commit/a8a94472ea4c9d0964faac46082c829a94a2c2a2", "message": "Improve verification for map columns\n\nAdd checksums for map key, values and map sizes.", "committedDate": "2020-02-12T16:54:23Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY0MDkwMw==", "url": "https://github.com/prestodb/presto/pull/14054#discussion_r378640903", "bodyText": "You can combine those mismatched cases into one.\nAlso, add a test case where the key/value are not orderable and hence the array_sort function call is not used.", "author": "caithagoras", "createdAt": "2020-02-13T04:02:55Z", "path": "presto-verifier/src/test/java/com/facebook/presto/verifier/checksum/TestChecksumValidator.java", "diffHunk": "@@ -387,6 +393,78 @@ public void testRow()\n                         .build());\n     }\n \n+    @Test\n+    public void testMap()\n+    {\n+        List<Column> columns = ImmutableList.of(MAP_COLUMN);\n+\n+        ChecksumResult controlChecksum = new ChecksumResult(\n+                5,\n+                ImmutableMap.<String, Object>builder()\n+                        .put(\"map_checksum\", new SqlVarbinary(new byte[] {0xa}))\n+                        .put(\"map_keys_checksum\", new SqlVarbinary(new byte[] {0xb}))\n+                        .put(\"map_values_checksum\", new SqlVarbinary(new byte[] {0xc}))\n+                        .put(\"map_cardinality_sum\", 3L)\n+                        .build());\n+\n+        // Matched\n+        assertTrue(checksumValidator.getMismatchedColumns(columns, controlChecksum, controlChecksum).isEmpty());\n+\n+        // Mismatched map checksum\n+        ChecksumResult testChecksum = new ChecksumResult(\n+                5,\n+                ImmutableMap.<String, Object>builder()\n+                        .put(\"map_checksum\", new SqlVarbinary(new byte[] {0x1a}))\n+                        .put(\"map_keys_checksum\", new SqlVarbinary(new byte[] {0x0b}))\n+                        .put(\"map_values_checksum\", new SqlVarbinary(new byte[] {0x0c}))\n+                        .put(\"map_cardinality_sum\", 3L)\n+                        .build());\n+\n+        String expectedOutput = \"control(checksum: 0a, keys_checksum: 0b, values_checksum: 0c, cardinality_sum: 3) \" +\n+                \"test(checksum: 1a, keys_checksum: 0b, values_checksum: 0c, cardinality_sum: 3)\";\n+        assertEquals(\n+                checksumValidator.getMismatchedColumns(columns, controlChecksum, testChecksum),\n+                ImmutableMap.builder()\n+                        .put(MAP_COLUMN, new ColumnMatchResult(false, MAP_COLUMN, expectedOutput))\n+                        .build());\n+\n+        // Mismatched map keys & values checksum\n+        testChecksum = new ChecksumResult(\n+                5,\n+                ImmutableMap.<String, Object>builder()\n+                        .put(\"map_checksum\", new SqlVarbinary(new byte[] {0x0a}))\n+                        .put(\"map_keys_checksum\", new SqlVarbinary(new byte[] {0x1b}))\n+                        .put(\"map_values_checksum\", new SqlVarbinary(new byte[] {0x1c}))\n+                        .put(\"map_cardinality_sum\", 3L)\n+                        .build());\n+\n+        expectedOutput = \"control(checksum: 0a, keys_checksum: 0b, values_checksum: 0c, cardinality_sum: 3) \" +\n+                \"test(checksum: 0a, keys_checksum: 1b, values_checksum: 1c, cardinality_sum: 3)\";\n+        assertEquals(\n+                checksumValidator.getMismatchedColumns(columns, controlChecksum, testChecksum),\n+                ImmutableMap.builder()\n+                        .put(MAP_COLUMN, new ColumnMatchResult(false, MAP_COLUMN, expectedOutput))\n+                        .build());\n+\n+        // Mismatched map cardinality sum\n+        testChecksum = new ChecksumResult(\n+                5,\n+                ImmutableMap.<String, Object>builder()\n+                        .put(\"map_checksum\", new SqlVarbinary(new byte[] {0x0a}))\n+                        .put(\"map_keys_checksum\", new SqlVarbinary(new byte[] {0x0b}))\n+                        .put(\"map_values_checksum\", new SqlVarbinary(new byte[] {0x0c}))\n+                        .put(\"map_cardinality_sum\", 4L)\n+                        .build());\n+\n+        expectedOutput = \"control(checksum: 0a, keys_checksum: 0b, values_checksum: 0c, cardinality_sum: 3) \" +\n+                \"test(checksum: 0a, keys_checksum: 0b, values_checksum: 0c, cardinality_sum: 4)\";\n+        assertEquals(\n+                checksumValidator.getMismatchedColumns(columns, controlChecksum, testChecksum),\n+                ImmutableMap.builder()\n+                        .put(MAP_COLUMN, new ColumnMatchResult(false, MAP_COLUMN, expectedOutput))\n+                        .build());\n+    }", "originalCommit": "a8a94472ea4c9d0964faac46082c829a94a2c2a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3ODY0MTA2Ng==", "url": "https://github.com/prestodb/presto/pull/14054#discussion_r378641066", "bodyText": "Usually, one line for empty constructor:\npublic MapColumnValidator() {}", "author": "caithagoras", "createdAt": "2020-02-13T04:03:36Z", "path": "presto-verifier/src/main/java/com/facebook/presto/verifier/checksum/MapColumnValidator.java", "diffHunk": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.verifier.checksum;\n+\n+import com.facebook.presto.spi.type.MapType;\n+import com.facebook.presto.spi.type.Type;\n+import com.facebook.presto.sql.tree.CoalesceExpression;\n+import com.facebook.presto.sql.tree.Expression;\n+import com.facebook.presto.sql.tree.LongLiteral;\n+import com.facebook.presto.sql.tree.SingleColumn;\n+import com.facebook.presto.verifier.framework.Column;\n+import com.google.common.collect.ImmutableList;\n+\n+import javax.inject.Inject;\n+\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.sql.QueryUtil.functionCall;\n+import static com.facebook.presto.verifier.framework.VerifierUtil.delimitedIdentifier;\n+import static com.google.common.base.Preconditions.checkArgument;\n+import static java.lang.String.format;\n+\n+public class MapColumnValidator\n+        implements ColumnValidator\n+{\n+    @Inject\n+    public MapColumnValidator()\n+    {\n+    }", "originalCommit": "a8a94472ea4c9d0964faac46082c829a94a2c2a2", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3b6846fd4419c4f3212ae47be128c78c068d0fb1", "url": "https://github.com/prestodb/presto/commit/3b6846fd4419c4f3212ae47be128c78c068d0fb1", "message": "Improve verification for map columns\n\nAdd checksums for map key, values and map sizes.", "committedDate": "2020-02-13T18:38:39Z", "type": "commit"}, {"oid": "3b6846fd4419c4f3212ae47be128c78c068d0fb1", "url": "https://github.com/prestodb/presto/commit/3b6846fd4419c4f3212ae47be128c78c068d0fb1", "message": "Improve verification for map columns\n\nAdd checksums for map key, values and map sizes.", "committedDate": "2020-02-13T18:38:39Z", "type": "forcePushed"}]}