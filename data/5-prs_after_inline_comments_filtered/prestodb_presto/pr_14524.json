{"pr_number": 14524, "pr_title": "canonicalize body of LambdaDefinitionExpression", "pr_createdAt": "2020-05-14T00:39:02Z", "pr_url": "https://github.com/prestodb/presto/pull/14524", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgwOTEwNw==", "url": "https://github.com/prestodb/presto/pull/14524#discussion_r424809107", "bodyText": "literal.toString() doesn't work very well here because it would just write string literals as Slice[...]. I want to preserve the equals trait of literals. Better suggestions are welcome.", "author": "rongrong", "createdAt": "2020-05-14T00:43:49Z", "path": "presto-spi/src/main/java/com/facebook/presto/spi/relation/LambdaDefinitionExpression.java", "diffHunk": "@@ -111,4 +115,55 @@ private static void checkArgument(boolean condition, String message, Object... m\n             throw new IllegalArgumentException(format(message, messageArgs));\n         }\n     }\n+    private static class CanonicalizeExpression\n+            implements RowExpressionVisitor<String, Void>\n+{\n+        private final Map<String, String> canonicalizedArguments = new HashMap<>();\n+\n+        public CanonicalizeExpression(List<String> arguments, List<Type> argumentTypes)\n+        {\n+            for (int i = 0; i < arguments.size(); i++) {\n+                canonicalizedArguments.put(arguments.get(i), format(\"%s_%d\", argumentTypes.get(i).toString(), i));\n+            }\n+        }\n+\n+        @Override\n+        public String visitCall(CallExpression call, Void context)\n+        {\n+            return format(\"%s(%s)\", call.getDisplayName(), String.join(\", \", call.getArguments().stream().map(e -> e.accept(this, null)).collect(Collectors.toList())));\n+        }\n+\n+        @Override\n+        public String visitInputReference(InputReferenceExpression reference, Void context)\n+        {\n+            return reference.toString();\n+        }\n+\n+        @Override\n+        public String visitConstant(ConstantExpression literal, Void context)\n+        {\n+            return format(\"%d\", literal.hashCode());", "originalCommit": "ba1dc02c42a5f57a832d6d89eb3aad3770035b48", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyODc2Mg==", "url": "https://github.com/prestodb/presto/pull/14524#discussion_r426228762", "bodyText": "This is too dangerous, isn't it? int32 hash collision is pretty high.", "author": "highker", "createdAt": "2020-05-17T07:36:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgwOTEwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg4NTA2OQ==", "url": "https://github.com/prestodb/presto/pull/14524#discussion_r426885069", "bodyText": "I thought about this, but if there's a collision does that mean equals and map operations would give bogus results as well? I don't like this either, so if there's better alternatives, I'd take them. One other possibility is just to special handle Slice. That would look quite ugly, and it still won't solve Object types. But if the concern behind this is real, that's an ok alternative.", "author": "rongrong", "createdAt": "2020-05-18T20:48:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgwOTEwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODQ5Mg==", "url": "https://github.com/prestodb/presto/pull/14524#discussion_r427058492", "bodyText": "One idea is to use the JSON representation for ConstantExpression  (this actually also applies to other RowExpression here ! )\nHowever it might be difficult to inject JsonCodec<RowExpression> here. If we look at ConstantExpression#getValueBlock, it actually calls to Utils#nativeValueToBlock:\nOtherwise, doing an instanceof Slice might be OK... We did this in a couple of place, such as LiteralEncoder. And here we are \"encoding constant literal\" :)\n\n  \n    \n      presto/presto-main/src/main/java/com/facebook/presto/sql/planner/LiteralEncoder.java\n    \n    \n        Lines 235 to 241\n      in\n      f43e444\n    \n    \n    \n    \n\n        \n          \n           if (object instanceof Slice) { \n        \n\n        \n          \n               // HACK: we need to serialize VARBINARY in a format that can be embedded in an expression to be \n        \n\n        \n          \n               // able to encode it in the plan that gets sent to workers. \n        \n\n        \n          \n               // We do this by transforming the in-memory varbinary into a call to from_base64(<base64-encoded value>) \n        \n\n        \n          \n               FunctionCall fromBase64 = new FunctionCall(QualifiedName.of(\"from_base64\"), ImmutableList.of(new StringLiteral(VarbinaryFunctions.toBase64((Slice) object).toStringUtf8()))); \n        \n\n        \n          \n               return new FunctionCall(QualifiedName.of(signature.getNameSuffix()), ImmutableList.of(fromBase64)); \n        \n\n        \n          \n           }", "author": "wenleix", "createdAt": "2020-05-19T06:28:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgwOTEwNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1ODUyOA==", "url": "https://github.com/prestodb/presto/pull/14524#discussion_r427058528", "bodyText": "but if there's a collision does that mean equals and map operations would give bogus results as well?\n\nIf I understand correctly the answer is yes right? Since the equals implementation essentially compares the argumentTypes and canonicalizedBody string?:\nreturn Objects.equals(argumentTypes, that.argumentTypes) &&\n        Objects.equals(canonicalizedBody, that.canonicalizedBody);", "author": "wenleix", "createdAt": "2020-05-19T06:29:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNDgwOTEwNw=="}], "type": "inlineReview"}, {"oid": "6029a0a62d98b31d12a23583f0900dc9ba326968", "url": "https://github.com/prestodb/presto/commit/6029a0a62d98b31d12a23583f0900dc9ba326968", "message": "Canonicalize body of LambdaDefinitionExpression\n\nFor two LambdaDefinitionExpressions if their input argument types are the same and how arguments are used\nare the same, they should be considered the same and can use the same generated bytecode.", "committedDate": "2020-05-14T01:00:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyOTU4MA==", "url": "https://github.com/prestodb/presto/pull/14524#discussion_r426229580", "bodyText": "Will this handle duplicated variables with the same name in different scopes?\nSELECT\n    TRANSFORM(elements, v -> REDUCE(v, 0, (s, v) -> s + v, s -> s)) AS multiplied_elements\nFROM (\n    VALUES\n        (ARRAY[ARRAY[1, 2]]),\n        (ARRAY[ARRAY[1, 2]]),\n        (ARRAY[ARRAY[1, 2]])\n) AS t(elements)", "author": "highker", "createdAt": "2020-05-17T07:46:27Z", "path": "presto-spi/src/main/java/com/facebook/presto/spi/relation/LambdaDefinitionExpression.java", "diffHunk": "@@ -111,4 +115,55 @@ private static void checkArgument(boolean condition, String message, Object... m\n             throw new IllegalArgumentException(format(message, messageArgs));\n         }\n     }\n+    private static class CanonicalizeExpression\n+            implements RowExpressionVisitor<String, Void>\n+    {\n+        private final Map<String, String> canonicalizedArguments = new HashMap<>();\n+\n+        public CanonicalizeExpression(List<String> arguments, List<Type> argumentTypes)\n+        {\n+            for (int i = 0; i < arguments.size(); i++) {\n+                canonicalizedArguments.put(arguments.get(i), format(\"%s_%d\", argumentTypes.get(i).toString(), i));\n+            }\n+        }\n+\n+        @Override\n+        public String visitCall(CallExpression call, Void context)\n+        {\n+            return format(\"%s(%s)\", call.getDisplayName(), String.join(\", \", call.getArguments().stream().map(e -> e.accept(this, null)).collect(Collectors.toList())));\n+        }\n+\n+        @Override\n+        public String visitInputReference(InputReferenceExpression reference, Void context)\n+        {\n+            return reference.toString();\n+        }\n+\n+        @Override\n+        public String visitConstant(ConstantExpression literal, Void context)\n+        {\n+            return format(\"%d\", literal.hashCode());\n+        }\n+\n+        @Override\n+        public String visitLambda(LambdaDefinitionExpression lambda, Void context)\n+        {\n+            return format(\"(%s) -> %s\", String.join(\", \", lambda.argumentTypes.stream().map(Type::toString).collect(Collectors.toList())), lambda.body.accept(this, null));\n+        }\n+\n+        @Override\n+        public String visitVariableReference(VariableReferenceExpression reference, Void context)\n+        {\n+            if (canonicalizedArguments.containsKey(reference.getName())) {", "originalCommit": "6029a0a62d98b31d12a23583f0900dc9ba326968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg4MjI1Mg==", "url": "https://github.com/prestodb/presto/pull/14524#discussion_r426882252", "bodyText": "we always assign a new variable in planning so the two vs will not have the same name in plan.", "author": "rongrong", "createdAt": "2020-05-18T20:42:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyOTU4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA2MDAzMg==", "url": "https://github.com/prestodb/presto/pull/14524#discussion_r427060032", "bodyText": "@rongrong : One random thought, after canonicalization, argument name can be the same in different scopes right? For example the second BIGINT argument in different scope will always be canonicalized into bigint_2. Will this be handled correctly?", "author": "wenleix", "createdAt": "2020-05-19T06:32:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyOTU4MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4ODAyNg==", "url": "https://github.com/prestodb/presto/pull/14524#discussion_r427488026", "bodyText": "@rongrong : One random thought, after canonicalization, argument name can be the same in different scopes right? For example the second BIGINT argument in different scope will always be canonicalized into bigint_2. Will this be handled correctly?\n\nYes, the goal is to make two argument of the same type in different lambda the same. They are logically the same. You can invoke the same function (even if you generate two functions they will be the same anyways). The whole purpose of this is to enable common sub expressions for lambdas.", "author": "rongrong", "createdAt": "2020-05-19T17:48:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyOTU4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyOTg2Ng==", "url": "https://github.com/prestodb/presto/pull/14524#discussion_r426229866", "bodyText": "What if someone defines a variable called bigint_2 in the lambda body. Will that cause a collision?", "author": "highker", "createdAt": "2020-05-17T07:50:08Z", "path": "presto-spi/src/main/java/com/facebook/presto/spi/relation/LambdaDefinitionExpression.java", "diffHunk": "@@ -111,4 +115,55 @@ private static void checkArgument(boolean condition, String message, Object... m\n             throw new IllegalArgumentException(format(message, messageArgs));\n         }\n     }\n+    private static class CanonicalizeExpression\n+            implements RowExpressionVisitor<String, Void>\n+    {\n+        private final Map<String, String> canonicalizedArguments = new HashMap<>();\n+\n+        public CanonicalizeExpression(List<String> arguments, List<Type> argumentTypes)\n+        {\n+            for (int i = 0; i < arguments.size(); i++) {\n+                canonicalizedArguments.put(arguments.get(i), format(\"%s_%d\", argumentTypes.get(i).toString(), i));", "originalCommit": "6029a0a62d98b31d12a23583f0900dc9ba326968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjg4Mzg5MA==", "url": "https://github.com/prestodb/presto/pull/14524#discussion_r426883890", "bodyText": "Non of these variable names are going to keep the original form of what the users' specified at this point. So I don't think that would happen. That's said, there's no guarantee it won't happen in the future, so if there are ways to introduce tests to validate these assumptions I'd be happy to add those. We can also add special character like format(%s$%d) so it would not collide.", "author": "rongrong", "createdAt": "2020-05-18T20:45:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyOTg2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1MDQ5Mg==", "url": "https://github.com/prestodb/presto/pull/14524#discussion_r427050492", "bodyText": "Maybe I am missing some thing, But I thought we cannot (yet) define variable inside lambda body right?\nThe only thing I can think is refer other columns inside lambda (through InputReferenceExpression). However lambda capture will be desugared during expression optimization (LambdaCaptureDesugaringRewriter). We just need to make sure this happens before canonicalization.\nUse special character like $ is also an standard trick in Presto \ud83d\ude03", "author": "wenleix", "createdAt": "2020-05-19T06:07:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyOTg2Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4MzU0NQ==", "url": "https://github.com/prestodb/presto/pull/14524#discussion_r427483545", "bodyText": "Yes, this is not defining new variables, it's rewriting reference to input variable to normalize them. For example, if we have two LambaDefinitionExpression:\nlambda1: (expr_1) -> if (expr_1, 1, 2)\nlambda2: (expr_2) -> if (expr_2, 1, 2)\n\nand both expr_1 and expr_2 are of time BOOLEAN. The two lambdas are logically the same. They can be compiled to the same bytecode. This change will rewrite both of them to (boolean_1) -> if (boolean_1, 1, 2) and the lambda1.equals(lambda2) would be true.", "author": "rongrong", "createdAt": "2020-05-19T17:41:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNjIyOTg2Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1NzA4MQ==", "url": "https://github.com/prestodb/presto/pull/14524#discussion_r427057081", "bodyText": "Is displayName guarantee to be distinct for each function call? :)\nAlso I personally like to have line breaks when using Stream API. This helps read the code from cellphone \ud83d\ude1b :\n        return format(\n                \"%s(%s)\", \n                call.getDisplayName(), \n                String.join(\", \", call.getArguments().stream()\n                        .map(e -> e.accept(this, null))\n                        .collect(Collectors.toList())));", "author": "wenleix", "createdAt": "2020-05-19T06:25:22Z", "path": "presto-spi/src/main/java/com/facebook/presto/spi/relation/LambdaDefinitionExpression.java", "diffHunk": "@@ -111,4 +115,55 @@ private static void checkArgument(boolean condition, String message, Object... m\n             throw new IllegalArgumentException(format(message, messageArgs));\n         }\n     }\n+    private static class CanonicalizeExpression\n+            implements RowExpressionVisitor<String, Void>\n+    {\n+        private final Map<String, String> canonicalizedArguments = new HashMap<>();\n+\n+        public CanonicalizeExpression(List<String> arguments, List<Type> argumentTypes)\n+        {\n+            for (int i = 0; i < arguments.size(); i++) {\n+                canonicalizedArguments.put(arguments.get(i), format(\"%s_%d\", argumentTypes.get(i).toString(), i));\n+            }\n+        }\n+\n+        @Override\n+        public String visitCall(CallExpression call, Void context)\n+        {\n+            return format(\"%s(%s)\", call.getDisplayName(), String.join(\", \", call.getArguments().stream().map(e -> e.accept(this, null)).collect(Collectors.toList())));", "originalCommit": "6029a0a62d98b31d12a23583f0900dc9ba326968", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzQ4NjQ5NQ==", "url": "https://github.com/prestodb/presto/pull/14524#discussion_r427486495", "bodyText": "What do you mean distinct name for each function call? If two functions have the same name with same input they are the same function right?", "author": "rongrong", "createdAt": "2020-05-19T17:46:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1NzA4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzcyOTU2NA==", "url": "https://github.com/prestodb/presto/pull/14524#discussion_r427729564", "bodyText": "@rongrong : Right. Just wondering why it's called \"display name\". Is there \"internal name\" as well? \ud83d\ude1b", "author": "wenleix", "createdAt": "2020-05-20T04:07:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1NzA4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDYyMzQzMg==", "url": "https://github.com/prestodb/presto/pull/14524#discussion_r430623432", "bodyText": "Hmm, good point. The display name could theoretically be different from the function name in signature but I don't think we ever do that. I think this was added to get the name of a function for \"display\" purpose (vs. resolve) because some call site does not have information to get function name from function handle (no access to FunctionManager). I don't remember the details though. So theoretically there could be a conflict but practically as long as we always pass in the same name for display name (which I believe we do) it should fine.", "author": "rongrong", "createdAt": "2020-05-26T18:33:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzA1NzA4MQ=="}], "type": "inlineReview"}, {"oid": "ca0e06862e29e7c171edf47d58e242ad7d5d4501", "url": "https://github.com/prestodb/presto/commit/ca0e06862e29e7c171edf47d58e242ad7d5d4501", "message": "Canonicalize body of LambdaDefinitionExpression\n\nFor two LambdaDefinitionExpressions if their input argument types are the same and how arguments are used\nare the same, they should be considered the same and can use the same generated bytecode.", "committedDate": "2020-05-28T22:19:01Z", "type": "forcePushed"}, {"oid": "77bb5344b692f4cf2f9ea8131c118072862c0063", "url": "https://github.com/prestodb/presto/commit/77bb5344b692f4cf2f9ea8131c118072862c0063", "message": "Canonicalize body of LambdaDefinitionExpression\n\nFor two LambdaDefinitionExpressions if their input argument types are the same and how arguments are used\nare the same, they should be considered the same and can use the same generated bytecode.", "committedDate": "2020-06-02T20:53:54Z", "type": "forcePushed"}, {"oid": "628f67390e541521dbfb60b68695f701c540697f", "url": "https://github.com/prestodb/presto/commit/628f67390e541521dbfb60b68695f701c540697f", "message": "Canonicalize body of LambdaDefinitionExpression\n\nFor two LambdaDefinitionExpressions if their input argument types are the same and how arguments are used\nare the same, they should be considered the same and can use the same generated bytecode.", "committedDate": "2020-06-05T21:01:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTkwODA1OA==", "url": "https://github.com/prestodb/presto/pull/14524#discussion_r439908058", "bodyText": "Maybe add a comment to indicate this is the implementation of toBase64", "author": "highker", "createdAt": "2020-06-15T03:01:02Z", "path": "presto-spi/src/main/java/com/facebook/presto/spi/relation/LambdaDefinitionExpression.java", "diffHunk": "@@ -111,4 +118,64 @@ private static void checkArgument(boolean condition, String message, Object... m\n             throw new IllegalArgumentException(format(message, messageArgs));\n         }\n     }\n+    private static class CanonicalizeExpression\n+            implements RowExpressionVisitor<String, Void>\n+    {\n+        private final Map<String, String> canonicalizedArguments = new HashMap<>();\n+\n+        public CanonicalizeExpression(List<String> arguments, List<Type> argumentTypes)\n+        {\n+            for (int i = 0; i < arguments.size(); i++) {\n+                canonicalizedArguments.put(arguments.get(i), format(\"%s_%d\", argumentTypes.get(i).toString(), i));\n+            }\n+        }\n+\n+        @Override\n+        public String visitCall(CallExpression call, Void context)\n+        {\n+            return format(\"%s.%s(%s)\", call.getFunctionHandle().getFunctionNamespace(), call.getDisplayName(), String.join(\", \", call.getArguments().stream().map(e -> e.accept(this, null)).collect(Collectors.toList())));\n+        }\n+\n+        @Override\n+        public String visitInputReference(InputReferenceExpression reference, Void context)\n+        {\n+            return reference.toString();\n+        }\n+\n+        @Override\n+        public String visitConstant(ConstantExpression literal, Void context)\n+        {\n+            // Handle varchar constant specifically\n+            if (literal.getValue() instanceof Slice) {\n+                Slice slice = (Slice) literal.getValue();\n+                if (slice.hasByteArray()) {\n+                    return Slices.wrappedBuffer(Base64.getEncoder().encode(slice.toByteBuffer())).toStringUtf8();\n+                }\n+                return Slices.wrappedBuffer(Base64.getEncoder().encode(slice.getBytes())).toStringUtf8();", "originalCommit": "628f67390e541521dbfb60b68695f701c540697f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "928752b32b045ff4c0208e93721435015e6df943", "url": "https://github.com/prestodb/presto/commit/928752b32b045ff4c0208e93721435015e6df943", "message": "Canonicalize body of LambdaDefinitionExpression\n\nFor two LambdaDefinitionExpressions if their input argument types are the same and how arguments are used\nare the same, they should be considered the same and can use the same generated bytecode.", "committedDate": "2020-06-15T19:48:55Z", "type": "commit"}, {"oid": "928752b32b045ff4c0208e93721435015e6df943", "url": "https://github.com/prestodb/presto/commit/928752b32b045ff4c0208e93721435015e6df943", "message": "Canonicalize body of LambdaDefinitionExpression\n\nFor two LambdaDefinitionExpressions if their input argument types are the same and how arguments are used\nare the same, they should be considered the same and can use the same generated bytecode.", "committedDate": "2020-06-15T19:48:55Z", "type": "forcePushed"}]}