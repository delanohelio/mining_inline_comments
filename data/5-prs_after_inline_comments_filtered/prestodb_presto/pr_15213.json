{"pr_number": 15213, "pr_title": "Improve nested loop operator performance", "pr_createdAt": "2020-09-23T15:44:16Z", "pr_url": "https://github.com/prestodb/presto/pull/15213", "timeline": [{"oid": "2fbd3ee323eb9d5baf1912e37c2988c5eb71aa50", "url": "https://github.com/prestodb/presto/commit/2fbd3ee323eb9d5baf1912e37c2988c5eb71aa50", "message": "Improve NestedLoopJoinOperator performance\n\nAvoids unnecessary block array creations and extra work copying\nblocks from the \"larger\" page per iteration of the nested loop.", "committedDate": "2020-09-23T17:34:26Z", "type": "forcePushed"}, {"oid": "c0a86a2e0eeef9c3bbd3f2729bf87c0d7eccc565", "url": "https://github.com/prestodb/presto/commit/c0a86a2e0eeef9c3bbd3f2729bf87c0d7eccc565", "message": "Improve NestedLoopJoinOperator performance\n\nAvoids unnecessary block array creations and extra work copying\nblocks from the \"larger\" page per iteration of the nested loop.", "committedDate": "2020-09-23T22:44:03Z", "type": "forcePushed"}, {"oid": "a914ed9723fd0fcc25231f659b0b2417ffa13503", "url": "https://github.com/prestodb/presto/commit/a914ed9723fd0fcc25231f659b0b2417ffa13503", "message": "Improve NestedLoopJoinOperator performance\n\n- Modifies NestedLoopJoinPagesBuilder to combine empty pages (aka:\npositionCount only pages) when the build side of the nested loop\njoin is empty\n- Handles the case where either probe or build side outputs are empty\nand position counts are fewer by emitting the same page repeatedly,\navoiding unnecessary per-iteration allocations\n- Reduces the amount of block array copies made in the standard case\nby reusing a block buffer to build each page and letting the Page\nconstructor clone it (ie: 1/2 as many allocations)\n- Nullifies the output iterator as well as the probe page when finished\niterating through it to make the referenced pages elligible for GC. Also\nnullifies more fields when the operator is closed for the same reason.", "committedDate": "2020-10-08T14:09:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ3Mjg4Mg==", "url": "https://github.com/prestodb/presto/pull/15213#discussion_r515472882", "bodyText": "nit: Remove this. for line 333- 336", "author": "yingsu00", "createdAt": "2020-10-31T08:33:35Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/NestedLoopJoinOperator.java", "diffHunk": "@@ -217,59 +224,120 @@ public void close()\n         afterClose.run();\n     }\n \n+    @VisibleForTesting\n+    static NestedLoopOutputIterator createNestedLoopOutputIterator(Page probePage, Page buildPage)\n+    {\n+        if (probePage.getChannelCount() == 0 && buildPage.getChannelCount() == 0) {\n+            int probePositions = probePage.getPositionCount();\n+            int buildPositions = buildPage.getPositionCount();\n+            try {\n+                // positionCount is an int. Make sure the product can still fit in an int.\n+                int outputPositions = multiplyExact(probePositions, buildPositions);\n+                if (outputPositions <= PageProcessor.MAX_BATCH_SIZE) {\n+                    return new PageRepeatingIterator(new Page(outputPositions), 1);\n+                }\n+            }\n+            catch (ArithmeticException overflow) {\n+            }\n+            // Repeat larger position count a smaller position count number of times\n+            Page outputPage = new Page(max(probePositions, buildPositions));\n+            return new PageRepeatingIterator(outputPage, min(probePositions, buildPositions));\n+        }\n+        else if (probePage.getChannelCount() == 0 && probePage.getPositionCount() <= buildPage.getPositionCount()) {\n+            return new PageRepeatingIterator(buildPage, probePage.getPositionCount());\n+        }\n+        else if (buildPage.getChannelCount() == 0 && buildPage.getPositionCount() <= probePage.getPositionCount()) {\n+            return new PageRepeatingIterator(probePage, buildPage.getPositionCount());\n+        }\n+        else {\n+            return new NestedLoopPageBuilder(probePage, buildPage);\n+        }\n+    }\n+\n+    // bi-morphic parent class for the two implementations allowed. Adding a third implementation will make getOutput megamorphic and\n+    // should be avoided\n+    @VisibleForTesting\n+    abstract static class NestedLoopOutputIterator\n+    {\n+        public abstract boolean hasNext();\n+\n+        public abstract Page next();\n+    }\n+\n+    private static final class PageRepeatingIterator\n+            extends NestedLoopOutputIterator\n+    {\n+        private final Page page;\n+        private int remainingCount;\n+\n+        private PageRepeatingIterator(Page page, int repetitions)\n+        {\n+            this.page = requireNonNull(page, \"page is null\");\n+            this.remainingCount = repetitions;\n+        }\n+\n+        @Override\n+        public boolean hasNext()\n+        {\n+            return remainingCount > 0;\n+        }\n+\n+        @Override\n+        public Page next()\n+        {\n+            if (!hasNext()) {\n+                throw new NoSuchElementException();\n+            }\n+            remainingCount--;\n+            return page;\n+        }\n+    }\n+\n     /**\n      * This class takes one probe page(p rows) and one build page(b rows) and\n      * build n pages with m rows in each page, where n = min(p, b) and m = max(p, b)\n      */\n-    @VisibleForTesting\n-    static class NestedLoopPageBuilder\n-            implements Iterator<Page>\n+    private static final class NestedLoopPageBuilder\n+            extends NestedLoopOutputIterator\n     {\n-        private final int numberOfProbeColumns;\n-        private final int numberOfBuildColumns;\n-        private final boolean buildPageLarger;\n-        private final Page largePage;\n+        //  Avoids allocation a new block array per iteration\n+        private final Block[] resultBlockBuffer;\n         private final Page smallPage;\n+        private final int indexForRleBlocks;\n+        private final int largePagePositionCount;\n         private final int maxRowIndex; // number of rows - 1\n \n-        private int rowIndex; // Iterator on the rows in the page with less rows.\n-        private final int noColumnShortcutResult; // Only used if select count(*) from cross join.\n+        private int rowIndex = -1; // Iterator on the rows in the page with less rows.\n \n         NestedLoopPageBuilder(Page probePage, Page buildPage)\n         {\n             requireNonNull(probePage, \"probePage is null\");\n             checkArgument(probePage.getPositionCount() > 0, \"probePage has no rows\");\n             requireNonNull(buildPage, \"buildPage is null\");\n             checkArgument(buildPage.getPositionCount() > 0, \"buildPage has no rows\");\n-            this.numberOfProbeColumns = probePage.getChannelCount();\n-            this.numberOfBuildColumns = buildPage.getChannelCount();\n \n-            // We will loop through all rows in the page with less rows.\n-            this.rowIndex = -1;\n-            this.buildPageLarger = buildPage.getPositionCount() > probePage.getPositionCount();\n-            this.maxRowIndex = Math.min(buildPage.getPositionCount(), probePage.getPositionCount()) - 1;\n-            this.largePage = buildPageLarger ? buildPage : probePage;\n-            this.smallPage = buildPageLarger ? probePage : buildPage;\n-\n-            this.noColumnShortcutResult = calculateUseNoColumnShortcut(numberOfProbeColumns, numberOfBuildColumns, probePage.getPositionCount(), buildPage.getPositionCount());\n-        }\n+            Page largePage;\n+            int indexForPageBlocks;\n+            if (buildPage.getPositionCount() > probePage.getPositionCount()) {\n+                largePage = buildPage;\n+                smallPage = probePage;\n+                indexForPageBlocks = probePage.getChannelCount();\n+                this.indexForRleBlocks = 0;\n+            }\n+            else {\n+                largePage = probePage;\n+                smallPage = buildPage;\n+                indexForPageBlocks = 0;\n+                this.indexForRleBlocks = probePage.getChannelCount();\n+            }\n+            this.largePagePositionCount = largePage.getPositionCount();", "originalCommit": "a914ed9723fd0fcc25231f659b0b2417ffa13503", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAzNjEwNA==", "url": "https://github.com/prestodb/presto/pull/15213#discussion_r516036104", "bodyText": "Done", "author": "pettyjamesm", "createdAt": "2020-11-02T15:07:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ3Mjg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ3NDA3Mw==", "url": "https://github.com/prestodb/presto/pull/15213#discussion_r515474073", "bodyText": "rename this variable to nestedLoopOutputIterator", "author": "yingsu00", "createdAt": "2020-10-31T08:48:23Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/NestedLoopJoinOperator.java", "diffHunk": "@@ -112,7 +115,7 @@ public OperatorFactory duplicate()\n     private List<Page> buildPages;\n     private Page probePage;\n     private Iterator<Page> buildPageIterator;\n-    private NestedLoopPageBuilder nestedLoopPageBuilder;\n+    private NestedLoopOutputIterator nestedLoopPageBuilder;", "originalCommit": "a914ed9723fd0fcc25231f659b0b2417ffa13503", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjAzNjMyMw==", "url": "https://github.com/prestodb/presto/pull/15213#discussion_r516036323", "bodyText": "Renamed", "author": "pettyjamesm", "createdAt": "2020-11-02T15:08:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ3NDA3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ3NTIwOQ==", "url": "https://github.com/prestodb/presto/pull/15213#discussion_r515475209", "bodyText": "I think it's better to be an interface than an abstract static class since it's just describing what the implementors should do but do not share functional code.", "author": "yingsu00", "createdAt": "2020-10-31T09:02:06Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/NestedLoopJoinOperator.java", "diffHunk": "@@ -217,59 +224,120 @@ public void close()\n         afterClose.run();\n     }\n \n+    @VisibleForTesting\n+    static NestedLoopOutputIterator createNestedLoopOutputIterator(Page probePage, Page buildPage)\n+    {\n+        if (probePage.getChannelCount() == 0 && buildPage.getChannelCount() == 0) {\n+            int probePositions = probePage.getPositionCount();\n+            int buildPositions = buildPage.getPositionCount();\n+            try {\n+                // positionCount is an int. Make sure the product can still fit in an int.\n+                int outputPositions = multiplyExact(probePositions, buildPositions);\n+                if (outputPositions <= PageProcessor.MAX_BATCH_SIZE) {\n+                    return new PageRepeatingIterator(new Page(outputPositions), 1);\n+                }\n+            }\n+            catch (ArithmeticException overflow) {\n+            }\n+            // Repeat larger position count a smaller position count number of times\n+            Page outputPage = new Page(max(probePositions, buildPositions));\n+            return new PageRepeatingIterator(outputPage, min(probePositions, buildPositions));\n+        }\n+        else if (probePage.getChannelCount() == 0 && probePage.getPositionCount() <= buildPage.getPositionCount()) {\n+            return new PageRepeatingIterator(buildPage, probePage.getPositionCount());\n+        }\n+        else if (buildPage.getChannelCount() == 0 && buildPage.getPositionCount() <= probePage.getPositionCount()) {\n+            return new PageRepeatingIterator(probePage, buildPage.getPositionCount());\n+        }\n+        else {\n+            return new NestedLoopPageBuilder(probePage, buildPage);\n+        }\n+    }\n+\n+    // bi-morphic parent class for the two implementations allowed. Adding a third implementation will make getOutput megamorphic and\n+    // should be avoided\n+    @VisibleForTesting\n+    abstract static class NestedLoopOutputIterator", "originalCommit": "a914ed9723fd0fcc25231f659b0b2417ffa13503", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA0MDgzNA==", "url": "https://github.com/prestodb/presto/pull/15213#discussion_r516040834", "bodyText": "I thought about that and I'm still ok with changing this to an interface, but I initially preferred an abstract class with a comment about making the implementations bimorphic to make sure someone doesn't come along and refactor this into implementing Iterator<Page> and/or add another implementation to avoid making this megamorphic. See the comments about this choice in prestosql's review for some more context. Let me know if you'd still prefer an interface there should be no performance difference after optimization by C2  since as long as the interface stays bimorphic.", "author": "pettyjamesm", "createdAt": "2020-11-02T15:14:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ3NTIwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk4MzYzMw==", "url": "https://github.com/prestodb/presto/pull/15213#discussion_r516983633", "bodyText": "@pettyjamesm I don't think making it an Abstract class can prevent people making it megamorphic. That's why having a JMH benchmark covering these cases is important. Pasting before and after results would usually be very helpful and future regression, if any, can be easily identified. How did you test the performance otherwise? Was it something easy to merge to the code base?\nOther than this, the PR looks good. Thanks for making the changes.\ncc @mbasmanova", "author": "yingsu00", "createdAt": "2020-11-03T22:07:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ3NTIwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjk4ODMyNA==", "url": "https://github.com/prestodb/presto/pull/15213#discussion_r516988324", "bodyText": "Thanks. Performance was assessed by running targeted queries against a live cluster to test the empty channel scenarios as well as the \"standard case\". The standard case improvement is marginal but proportional to the number of columns since the allocation rate is the only major difference in the two scenarios. I don't currently have a JMH setup available so I'd have to implement that to put down some numbers.", "author": "pettyjamesm", "createdAt": "2020-11-03T22:18:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ3NTIwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNzc3ODgyMA==", "url": "https://github.com/prestodb/presto/pull/15213#discussion_r517778820", "bodyText": "@pettyjamesm Thank you for letting me know the test results. JMH doesn't need any set up and can directly run in IntelliJ. Furthermore it can collect CPU profiles and GC profiles easily. I'll approve it for now but it'll be helpful to include JMH benchmark results for future performance improvement PRs. Thank you!\n@mbasmanova Do you want to take another look at this PR?", "author": "yingsu00", "createdAt": "2020-11-05T03:57:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ3NTIwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ3NjA5Mg==", "url": "https://github.com/prestodb/presto/pull/15213#discussion_r515476092", "bodyText": "This PR might be structurally cleaner to put this change (the new PageRepeatingIterator and PageRepeatingIterator logic) in a separate commit other than the change within NestedLoopPageBuilder class. Maybe put different things in different commits in the future PRs? It'll be easier to review.", "author": "yingsu00", "createdAt": "2020-10-31T09:12:00Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/NestedLoopJoinOperator.java", "diffHunk": "@@ -217,59 +224,120 @@ public void close()\n         afterClose.run();\n     }\n \n+    @VisibleForTesting\n+    static NestedLoopOutputIterator createNestedLoopOutputIterator(Page probePage, Page buildPage)", "originalCommit": "a914ed9723fd0fcc25231f659b0b2417ffa13503", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNjA0MTA0MQ==", "url": "https://github.com/prestodb/presto/pull/15213#discussion_r516041041", "bodyText": "Sure, will keep that in mind next time.", "author": "pettyjamesm", "createdAt": "2020-11-02T15:14:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTQ3NjA5Mg=="}], "type": "inlineReview"}, {"oid": "a261743c800240839644c30aabf415c016e1e822", "url": "https://github.com/prestodb/presto/commit/a261743c800240839644c30aabf415c016e1e822", "message": "Add Page constructor for empty blocks case\n\nAvoids varargs empty array creation per call for these usage sites", "committedDate": "2020-11-02T14:24:34Z", "type": "commit"}, {"oid": "e16b125e067f07e8d736ad1273a7ba8b9d896ec4", "url": "https://github.com/prestodb/presto/commit/e16b125e067f07e8d736ad1273a7ba8b9d896ec4", "message": "Improve NestedLoopJoinOperator performance\n\n- Modifies NestedLoopJoinPagesBuilder to combine empty pages (aka:\npositionCount only pages) when the build side of the nested loop\njoin is empty\n- Handles the case where either probe or build side outputs are empty\nand position counts are fewer by emitting the same page repeatedly,\navoiding unnecessary per-iteration allocations\n- Reduces the amount of block array copies made in the standard case\nby reusing a block buffer to build each page and letting the Page\nconstructor clone it (ie: 1/2 as many allocations)\n- Nullifies the output iterator as well as the probe page when finished\niterating through it to make the referenced pages elligible for GC. Also\nnullifies more fields when the operator is closed for the same reason.", "committedDate": "2020-11-02T15:07:20Z", "type": "commit"}, {"oid": "e16b125e067f07e8d736ad1273a7ba8b9d896ec4", "url": "https://github.com/prestodb/presto/commit/e16b125e067f07e8d736ad1273a7ba8b9d896ec4", "message": "Improve NestedLoopJoinOperator performance\n\n- Modifies NestedLoopJoinPagesBuilder to combine empty pages (aka:\npositionCount only pages) when the build side of the nested loop\njoin is empty\n- Handles the case where either probe or build side outputs are empty\nand position counts are fewer by emitting the same page repeatedly,\navoiding unnecessary per-iteration allocations\n- Reduces the amount of block array copies made in the standard case\nby reusing a block buffer to build each page and letting the Page\nconstructor clone it (ie: 1/2 as many allocations)\n- Nullifies the output iterator as well as the probe page when finished\niterating through it to make the referenced pages elligible for GC. Also\nnullifies more fields when the operator is closed for the same reason.", "committedDate": "2020-11-02T15:07:20Z", "type": "forcePushed"}]}