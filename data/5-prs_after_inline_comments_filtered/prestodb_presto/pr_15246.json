{"pr_number": 15246, "pr_title": "Remove TypeManager.resolveOperator", "pr_createdAt": "2020-09-29T21:18:01Z", "pr_url": "https://github.com/prestodb/presto/pull/15246", "timeline": [{"oid": "d686255bcc25b11a6280ba89fe92e75698b8d9cc", "url": "https://github.com/prestodb/presto/commit/d686255bcc25b11a6280ba89fe92e75698b8d9cc", "message": "Remove TypeManager.resolveOperator\n\nThis API is a hack. TypeManager.resolveOperator internally will call\nFunctionManager.resolveOperator. However, FunctionManager is not initialized\nin TypeRegistry constructor, but set in FunctionManager's constructo, due to\ncyclic dependency. So to be able to call this API, we see following hacky code\nin test everywhere:\n    TypeManager typeManager = new TypeRegistr();\n    // associate typeManager with a function manager\n    new FunctionManager(typeManager, ....);\n\nThe only reason that this API exists is because MapParametricType.createType\nneeds to use it. So we did\n1) adding TypeManager to ParamatricType.createType\n2) adding TypeManager.resolveOperator\n\njust so MapParametricType could provide MethodHandle that would be used to\nbuild hashtable in Map block, while no other API needs\nTypeManager.resolveOperator, and no other ParametricType needs access to\nTypeManager. Another problem is that the API directly returns a MethodHandle,\nwhich means this API will not work once we support user defined types with\noperator implementation that's not a Java MethodHandle.\n\nSince the solution will not work for future generalized caase, removing it for\nnow, and directly check for MapParametricType in TypeRegistry to special handle\nmap types.", "committedDate": "2020-09-29T21:11:52Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI0MDI5OQ==", "url": "https://github.com/prestodb/presto/pull/15246#discussion_r497240299", "bodyText": "What if map is a subtype of some other types. For example Array<Map<...>>. createType should be recursive.", "author": "highker", "createdAt": "2020-09-30T04:45:55Z", "path": "presto-main/src/main/java/com/facebook/presto/type/TypeRegistry.java", "diffHunk": "@@ -213,8 +210,11 @@ private Type instantiateParametricType(TypeSignature signature)\n         if (parametricType == null) {\n             throw new IllegalArgumentException(\"Unknown type \" + signature);\n         }\n+        else if (parametricType instanceof MapParametricType) {\n+            return ((MapParametricType) parametricType).createType(functionManager, parameters);\n+        }", "originalCommit": "d686255bcc25b11a6280ba89fe92e75698b8d9cc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzY1ODIzNw==", "url": "https://github.com/prestodb/presto/pull/15246#discussion_r497658237", "bodyText": "The interesting (or surprising part) is TypeParameter already contains Type. So it's not recursive.\n\n  \n    \n      presto/presto-main/src/main/java/com/facebook/presto/type/ArrayParametricType.java\n    \n    \n        Lines 44 to 52\n      in\n      e6ad497\n    \n    \n    \n    \n\n        \n          \n           public Type createType(TypeManager typeManager, List<TypeParameter> parameters) \n        \n\n        \n          \n           { \n        \n\n        \n          \n               checkArgument(parameters.size() == 1, \"Array type expects exactly one type as a parameter, got %s\", parameters); \n        \n\n        \n          \n               checkArgument( \n        \n\n        \n          \n                       parameters.get(0).getKind() == ParameterKind.TYPE, \n        \n\n        \n          \n                       \"Array expects type as a parameter, got %s\", \n        \n\n        \n          \n                       parameters); \n        \n\n        \n          \n               return new ArrayType(parameters.get(0).getType()); \n        \n\n        \n          \n           }", "author": "wenleix", "createdAt": "2020-09-30T16:50:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzI0MDI5OQ=="}], "type": "inlineReview"}]}