{"pr_number": 15369, "pr_title": "Handle query level timeouts in Presto on Spark", "pr_createdAt": "2020-10-28T23:34:39Z", "pr_url": "https://github.com/prestodb/presto/pull/15369", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDc4NjUzMA==", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r514786530", "bodyText": "nextTimeoutInMillis variable can be removed.", "author": "viczhang861", "createdAt": "2020-10-30T03:36:07Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -1047,33 +1074,77 @@ private void logShuffleStatsSummary(ShuffleStatsKey key, List<PrestoSparkShuffle\n                     DataSize.succinctBytes(bytesPerSecond));\n         }\n \n-        private static <T> void waitFor(Collection<Future<T>> futures)\n-                throws SparkException\n+        private long computeNextTimeout()\n+                throws TimeoutException\n         {\n-            try {\n-                for (Future<?> future : futures) {\n-                    future.get();\n+            long timeout = queryCompletionDeadline - System.currentTimeMillis();\n+            if (timeout <= 0) {\n+                throw new TimeoutException();\n+            }\n+            return timeout;\n+        }\n+    }\n+\n+    private static <T> void waitForActionsCompletionWithTimeout(Collection<JavaFutureAction<T>> actions, long timeout, TimeUnit timeUnit)\n+            throws SparkException, TimeoutException\n+    {\n+        long deadline = System.currentTimeMillis() + timeUnit.toMillis(timeout);\n+\n+        try {\n+            for (JavaFutureAction<?> action : actions) {\n+                long nextTimeoutInMillis = deadline - System.currentTimeMillis();\n+                if (nextTimeoutInMillis <= 0) {\n+                    throw new TimeoutException();\n                 }\n+                getActionResultWithTimeout(action, nextTimeoutInMillis, MILLISECONDS);\n             }\n-            catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n-                throw new RuntimeException(e);\n+        }\n+        finally {\n+            for (JavaFutureAction<?> action : actions) {\n+                if (!action.isDone()) {\n+                    action.cancel(true);\n+                }\n             }\n-            catch (ExecutionException e) {\n-                propagateIfPossible(e.getCause(), SparkException.class);\n-                propagateIfPossible(e.getCause(), RuntimeException.class);\n+        }\n+    }\n \n-                // this should never happen\n-                throw new UncheckedExecutionException(e.getCause());\n-            }\n-            finally {\n-                for (Future<?> future : futures) {\n-                    if (!future.isDone()) {\n-                        future.cancel(true);\n+    private static <T> T getActionResultWithTimeout(JavaFutureAction<T> action, long timeout, TimeUnit timeUnit)\n+            throws SparkException, TimeoutException\n+    {\n+        long deadline = System.currentTimeMillis() + timeUnit.toMillis(timeout);\n+        try {\n+            while (true) {\n+                long nextTimeoutInMillis = deadline - System.currentTimeMillis();\n+                if (nextTimeoutInMillis <= 0) {", "originalCommit": "690225f1ef49eaf39f783ea176e15f8f01a3435e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE3ODQ0OA==", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r515178448", "bodyText": "This is actually a bug. The nextTimeoutInMillis has to be used in the next action.get", "author": "arhimondr", "createdAt": "2020-10-30T15:23:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDc4NjUzMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDc5OTI5MQ==", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r514799291", "bodyText": "queryCompletionDeadline can be initialized immediately after queryStateTimer is created.", "author": "viczhang861", "createdAt": "2020-10-30T03:49:55Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -728,13 +746,16 @@ private PrestoSparkQueryExecution(\n             this.transactionManager = requireNonNull(transactionManager, \"transactionManager is null\");\n             this.pagesSerde = requireNonNull(pagesSerde, \"pagesSerde is null\");\n             this.executionExceptionFactory = requireNonNull(executionExceptionFactory, \"executionExceptionFactory is null\");\n+            this.queryTimeout = requireNonNull(queryTimeout, \"queryTimeout is null\");\n             this.queryStatusInfoOutputPath = requireNonNull(queryStatusInfoOutputPath, \"queryStatusInfoOutputPath is null\");\n             this.queryDataOutputPath = requireNonNull(queryDataOutputPath, \"queryDataOutputPath is null\");\n         }\n \n         @Override\n         public List<List<Object>> execute()\n         {\n+            queryCompletionDeadline = System.currentTimeMillis() + queryTimeout.toMillis();", "originalCommit": "690225f1ef49eaf39f783ea176e15f8f01a3435e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE4NDY2Nw==", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r515184667", "bodyText": "Done", "author": "arhimondr", "createdAt": "2020-10-30T15:31:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDc5OTI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgwMTU2OQ==", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r514801569", "bodyText": "Why private static,  we can always read queryCompletionDeadline directly, which is simpler and guaranteed to be accurate.  Parameters timeout, timeUnit can be calculated from queryCompletionDeadline  and current time.", "author": "viczhang861", "createdAt": "2020-10-30T03:52:24Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -1047,33 +1074,77 @@ private void logShuffleStatsSummary(ShuffleStatsKey key, List<PrestoSparkShuffle\n                     DataSize.succinctBytes(bytesPerSecond));\n         }\n \n-        private static <T> void waitFor(Collection<Future<T>> futures)\n-                throws SparkException\n+        private long computeNextTimeout()\n+                throws TimeoutException\n         {\n-            try {\n-                for (Future<?> future : futures) {\n-                    future.get();\n+            long timeout = queryCompletionDeadline - System.currentTimeMillis();\n+            if (timeout <= 0) {\n+                throw new TimeoutException();\n+            }\n+            return timeout;\n+        }\n+    }\n+\n+    private static <T> void waitForActionsCompletionWithTimeout(Collection<JavaFutureAction<T>> actions, long timeout, TimeUnit timeUnit)", "originalCommit": "690225f1ef49eaf39f783ea176e15f8f01a3435e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDg5MjU0MQ==", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r514892541", "bodyText": "Same question :)", "author": "wenleix", "createdAt": "2020-10-30T06:20:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgwMTU2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE4MjUzMQ==", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r515182531", "bodyText": "How strongly do you feel about that? I just thought that with encapsulation it will be more readable. Basically the logic in the PrestoSparkQueryExecution is responsible for determining now much time we need to wait for the next operation to finish, and this method simply implements waiting.", "author": "arhimondr", "createdAt": "2020-10-30T15:29:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgwMTU2OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTMzOTE5Mg==", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r515339192", "bodyText": "Maybe we can reuse this static function later", "author": "viczhang861", "createdAt": "2020-10-30T19:45:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgwMTU2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgwMjQ3Mg==", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r514802472", "bodyText": "Curious, when would this scenario happens?", "author": "viczhang861", "createdAt": "2020-10-30T03:53:27Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -1047,33 +1074,77 @@ private void logShuffleStatsSummary(ShuffleStatsKey key, List<PrestoSparkShuffle\n                     DataSize.succinctBytes(bytesPerSecond));\n         }\n \n-        private static <T> void waitFor(Collection<Future<T>> futures)\n-                throws SparkException\n+        private long computeNextTimeout()\n+                throws TimeoutException\n         {\n-            try {\n-                for (Future<?> future : futures) {\n-                    future.get();\n+            long timeout = queryCompletionDeadline - System.currentTimeMillis();\n+            if (timeout <= 0) {\n+                throw new TimeoutException();\n+            }\n+            return timeout;\n+        }\n+    }\n+\n+    private static <T> void waitForActionsCompletionWithTimeout(Collection<JavaFutureAction<T>> actions, long timeout, TimeUnit timeUnit)\n+            throws SparkException, TimeoutException\n+    {\n+        long deadline = System.currentTimeMillis() + timeUnit.toMillis(timeout);\n+\n+        try {\n+            for (JavaFutureAction<?> action : actions) {\n+                long nextTimeoutInMillis = deadline - System.currentTimeMillis();\n+                if (nextTimeoutInMillis <= 0) {\n+                    throw new TimeoutException();\n                 }\n+                getActionResultWithTimeout(action, nextTimeoutInMillis, MILLISECONDS);\n             }\n-            catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n-                throw new RuntimeException(e);\n+        }\n+        finally {\n+            for (JavaFutureAction<?> action : actions) {\n+                if (!action.isDone()) {\n+                    action.cancel(true);\n+                }\n             }\n-            catch (ExecutionException e) {\n-                propagateIfPossible(e.getCause(), SparkException.class);\n-                propagateIfPossible(e.getCause(), RuntimeException.class);\n+        }\n+    }\n \n-                // this should never happen\n-                throw new UncheckedExecutionException(e.getCause());\n-            }\n-            finally {\n-                for (Future<?> future : futures) {\n-                    if (!future.isDone()) {\n-                        future.cancel(true);\n+    private static <T> T getActionResultWithTimeout(JavaFutureAction<T> action, long timeout, TimeUnit timeUnit)\n+            throws SparkException, TimeoutException\n+    {\n+        long deadline = System.currentTimeMillis() + timeUnit.toMillis(timeout);\n+        try {\n+            while (true) {\n+                long nextTimeoutInMillis = deadline - System.currentTimeMillis();\n+                if (nextTimeoutInMillis <= 0) {\n+                    throw new TimeoutException();\n+                }\n+                try {\n+                    return action.get(timeout, timeUnit);\n+                }\n+                catch (TimeoutException e) {\n+                    // guard against spurious wakeup", "originalCommit": "690225f1ef49eaf39f783ea176e15f8f01a3435e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE4MTAwNg==", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r515181006", "bodyText": "I'm just being paranoid, in case the timeout mechanism in Spark is buggy. If you feel strongly about removing it - I can, i don't feel very strong.", "author": "arhimondr", "createdAt": "2020-10-30T15:27:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgwMjQ3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgwNTU4Mw==", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r514805583", "bodyText": "Same comment as  waitForActionsCompletionWithTimeout", "author": "viczhang861", "createdAt": "2020-10-30T03:56:36Z", "path": "presto-spark-base/src/main/java/com/facebook/presto/spark/PrestoSparkQueryExecutionFactory.java", "diffHunk": "@@ -1047,33 +1074,77 @@ private void logShuffleStatsSummary(ShuffleStatsKey key, List<PrestoSparkShuffle\n                     DataSize.succinctBytes(bytesPerSecond));\n         }\n \n-        private static <T> void waitFor(Collection<Future<T>> futures)\n-                throws SparkException\n+        private long computeNextTimeout()\n+                throws TimeoutException\n         {\n-            try {\n-                for (Future<?> future : futures) {\n-                    future.get();\n+            long timeout = queryCompletionDeadline - System.currentTimeMillis();\n+            if (timeout <= 0) {\n+                throw new TimeoutException();\n+            }\n+            return timeout;\n+        }\n+    }\n+\n+    private static <T> void waitForActionsCompletionWithTimeout(Collection<JavaFutureAction<T>> actions, long timeout, TimeUnit timeUnit)\n+            throws SparkException, TimeoutException\n+    {\n+        long deadline = System.currentTimeMillis() + timeUnit.toMillis(timeout);\n+\n+        try {\n+            for (JavaFutureAction<?> action : actions) {\n+                long nextTimeoutInMillis = deadline - System.currentTimeMillis();\n+                if (nextTimeoutInMillis <= 0) {\n+                    throw new TimeoutException();\n                 }\n+                getActionResultWithTimeout(action, nextTimeoutInMillis, MILLISECONDS);\n             }\n-            catch (InterruptedException e) {\n-                Thread.currentThread().interrupt();\n-                throw new RuntimeException(e);\n+        }\n+        finally {\n+            for (JavaFutureAction<?> action : actions) {\n+                if (!action.isDone()) {\n+                    action.cancel(true);\n+                }\n             }\n-            catch (ExecutionException e) {\n-                propagateIfPossible(e.getCause(), SparkException.class);\n-                propagateIfPossible(e.getCause(), RuntimeException.class);\n+        }\n+    }\n \n-                // this should never happen\n-                throw new UncheckedExecutionException(e.getCause());\n-            }\n-            finally {\n-                for (Future<?> future : futures) {\n-                    if (!future.isDone()) {\n-                        future.cancel(true);\n+    private static <T> T getActionResultWithTimeout(JavaFutureAction<T> action, long timeout, TimeUnit timeUnit)", "originalCommit": "690225f1ef49eaf39f783ea176e15f8f01a3435e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNTE3NzU4MA==", "url": "https://github.com/prestodb/presto/pull/15369#discussion_r515177580", "bodyText": "getActionResultWithTimeout  is used by the RddAndMore#collectAndDestroyDependenciesWithTimeout", "author": "arhimondr", "createdAt": "2020-10-30T15:22:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxNDgwNTU4Mw=="}], "type": "inlineReview"}, {"oid": "216840446852fba36269496519fd9dd00f2650e2", "url": "https://github.com/prestodb/presto/commit/216840446852fba36269496519fd9dd00f2650e2", "message": "Handle query level timeouts in Presto on Spark", "committedDate": "2020-10-30T15:32:56Z", "type": "commit"}, {"oid": "216840446852fba36269496519fd9dd00f2650e2", "url": "https://github.com/prestodb/presto/commit/216840446852fba36269496519fd9dd00f2650e2", "message": "Handle query level timeouts in Presto on Spark", "committedDate": "2020-10-30T15:32:56Z", "type": "forcePushed"}]}