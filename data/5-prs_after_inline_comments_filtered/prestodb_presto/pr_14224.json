{"pr_number": 14224, "pr_title": "Aggregation Pushdown for Druid connector", "pr_createdAt": "2020-03-07T00:27:47Z", "pr_url": "https://github.com/prestodb/presto/pull/14224", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5MTk5MA==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r389991990", "bodyText": "not used", "author": "highker", "createdAt": "2020-03-09T22:16:12Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.FunctionMetadata;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.OperatorType;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.slice.Slice;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidExpression.derived;\n+import static com.facebook.presto.druid.DruidPushdownUtils.getLiteralAsString;\n+import static java.lang.String.format;\n+import static java.util.Locale.ENGLISH;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidAggregationProjectConverter\n+        extends DruidProjectExpressionConverter\n+{\n+    private static final Map<String, String> PRESTO_TO_DRUID_OPERATORS = ImmutableMap.of(\n+            \"-\", \"SUB\",\n+            \"+\", \"ADD\",\n+            \"*\", \"MULT\",\n+            \"/\", \"DIV\");\n+    private static final String FROM_UNIXTIME = \"from_unixtime\";\n+\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final ConnectorSession session;", "originalCommit": "01dd5e96cd75fa9eb31e9f1241012bc4fa24d226", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5MjA3NA==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r389992074", "bodyText": "break a line", "author": "highker", "createdAt": "2020-03-09T22:16:28Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.FunctionMetadata;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.OperatorType;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.slice.Slice;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidExpression.derived;\n+import static com.facebook.presto.druid.DruidPushdownUtils.getLiteralAsString;\n+import static java.lang.String.format;\n+import static java.util.Locale.ENGLISH;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidAggregationProjectConverter\n+        extends DruidProjectExpressionConverter\n+{\n+    private static final Map<String, String> PRESTO_TO_DRUID_OPERATORS = ImmutableMap.of(\n+            \"-\", \"SUB\",\n+            \"+\", \"ADD\",\n+            \"*\", \"MULT\",\n+            \"/\", \"DIV\");\n+    private static final String FROM_UNIXTIME = \"from_unixtime\";\n+\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final ConnectorSession session;\n+\n+    public DruidAggregationProjectConverter(TypeManager typeManager, FunctionMetadataManager functionMetadataManager, StandardFunctionResolution standardFunctionResolution, ConnectorSession session)\n+    {\n+        super(typeManager, standardFunctionResolution);\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"functionMetadataManager is null\");\n+        this.session = requireNonNull(session, \"session is null\");\n+    }\n+\n+    @Override\n+    public DruidExpression visitCall(\n+            CallExpression call,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        Optional<DruidExpression> basicCallHandlingResult = basicCallHandling(call, context);\n+        if (basicCallHandlingResult.isPresent()) {\n+            return basicCallHandlingResult.get();\n+        }", "originalCommit": "01dd5e96cd75fa9eb31e9f1241012bc4fa24d226", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5MjI4Mw==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r389992283", "bodyText": "nit: replace the space with a period a the end.", "author": "highker", "createdAt": "2020-03-09T22:17:05Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.FunctionMetadata;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.OperatorType;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.slice.Slice;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidExpression.derived;\n+import static com.facebook.presto.druid.DruidPushdownUtils.getLiteralAsString;\n+import static java.lang.String.format;\n+import static java.util.Locale.ENGLISH;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidAggregationProjectConverter\n+        extends DruidProjectExpressionConverter\n+{\n+    private static final Map<String, String> PRESTO_TO_DRUID_OPERATORS = ImmutableMap.of(\n+            \"-\", \"SUB\",\n+            \"+\", \"ADD\",\n+            \"*\", \"MULT\",\n+            \"/\", \"DIV\");\n+    private static final String FROM_UNIXTIME = \"from_unixtime\";\n+\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final ConnectorSession session;\n+\n+    public DruidAggregationProjectConverter(TypeManager typeManager, FunctionMetadataManager functionMetadataManager, StandardFunctionResolution standardFunctionResolution, ConnectorSession session)\n+    {\n+        super(typeManager, standardFunctionResolution);\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"functionMetadataManager is null\");\n+        this.session = requireNonNull(session, \"session is null\");\n+    }\n+\n+    @Override\n+    public DruidExpression visitCall(\n+            CallExpression call,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        Optional<DruidExpression> basicCallHandlingResult = basicCallHandling(call, context);\n+        if (basicCallHandlingResult.isPresent()) {\n+            return basicCallHandlingResult.get();\n+        }\n+        FunctionMetadata functionMetadata = functionMetadataManager.getFunctionMetadata(call.getFunctionHandle());\n+        Optional<OperatorType> operatorTypeOptional = functionMetadata.getOperatorType();\n+        if (operatorTypeOptional.isPresent()) {\n+            OperatorType operatorType = operatorTypeOptional.get();\n+            if (operatorType.isArithmeticOperator()) {\n+                return handleArithmeticExpression(call, operatorType, context);\n+            }\n+            if (operatorType.isComparisonOperator()) {\n+                throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported operator: \" + call + \" to pushdown for Druid connector \");", "originalCommit": "01dd5e96cd75fa9eb31e9f1241012bc4fa24d226", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5MjM5NA==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r389992394", "bodyText": "one param per line; same for all other functions in this class.", "author": "highker", "createdAt": "2020-03-09T22:17:28Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.FunctionMetadata;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.OperatorType;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.slice.Slice;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidExpression.derived;\n+import static com.facebook.presto.druid.DruidPushdownUtils.getLiteralAsString;\n+import static java.lang.String.format;\n+import static java.util.Locale.ENGLISH;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidAggregationProjectConverter\n+        extends DruidProjectExpressionConverter\n+{\n+    private static final Map<String, String> PRESTO_TO_DRUID_OPERATORS = ImmutableMap.of(\n+            \"-\", \"SUB\",\n+            \"+\", \"ADD\",\n+            \"*\", \"MULT\",\n+            \"/\", \"DIV\");\n+    private static final String FROM_UNIXTIME = \"from_unixtime\";\n+\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final ConnectorSession session;\n+\n+    public DruidAggregationProjectConverter(TypeManager typeManager, FunctionMetadataManager functionMetadataManager, StandardFunctionResolution standardFunctionResolution, ConnectorSession session)\n+    {\n+        super(typeManager, standardFunctionResolution);\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"functionMetadataManager is null\");\n+        this.session = requireNonNull(session, \"session is null\");\n+    }\n+\n+    @Override\n+    public DruidExpression visitCall(\n+            CallExpression call,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        Optional<DruidExpression> basicCallHandlingResult = basicCallHandling(call, context);\n+        if (basicCallHandlingResult.isPresent()) {\n+            return basicCallHandlingResult.get();\n+        }\n+        FunctionMetadata functionMetadata = functionMetadataManager.getFunctionMetadata(call.getFunctionHandle());\n+        Optional<OperatorType> operatorTypeOptional = functionMetadata.getOperatorType();\n+        if (operatorTypeOptional.isPresent()) {\n+            OperatorType operatorType = operatorTypeOptional.get();\n+            if (operatorType.isArithmeticOperator()) {\n+                return handleArithmeticExpression(call, operatorType, context);\n+            }\n+            if (operatorType.isComparisonOperator()) {\n+                throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported operator: \" + call + \" to pushdown for Druid connector \");\n+            }\n+        }\n+        return handleFunction(call, context);\n+    }\n+\n+    @Override\n+    public DruidExpression visitConstant(\n+            ConstantExpression literal,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)", "originalCommit": "01dd5e96cd75fa9eb31e9f1241012bc4fa24d226", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDA2MjM3MQ==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r390062371", "bodyText": "yep", "author": "zhenxiao", "createdAt": "2020-03-10T02:29:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5MjM5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5MjU4Mw==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r389992583", "bodyText": "Use if", "author": "highker", "createdAt": "2020-03-09T22:18:02Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.FunctionMetadata;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.OperatorType;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.slice.Slice;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidExpression.derived;\n+import static com.facebook.presto.druid.DruidPushdownUtils.getLiteralAsString;\n+import static java.lang.String.format;\n+import static java.util.Locale.ENGLISH;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidAggregationProjectConverter\n+        extends DruidProjectExpressionConverter\n+{\n+    private static final Map<String, String> PRESTO_TO_DRUID_OPERATORS = ImmutableMap.of(\n+            \"-\", \"SUB\",\n+            \"+\", \"ADD\",\n+            \"*\", \"MULT\",\n+            \"/\", \"DIV\");\n+    private static final String FROM_UNIXTIME = \"from_unixtime\";\n+\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final ConnectorSession session;\n+\n+    public DruidAggregationProjectConverter(TypeManager typeManager, FunctionMetadataManager functionMetadataManager, StandardFunctionResolution standardFunctionResolution, ConnectorSession session)\n+    {\n+        super(typeManager, standardFunctionResolution);\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"functionMetadataManager is null\");\n+        this.session = requireNonNull(session, \"session is null\");\n+    }\n+\n+    @Override\n+    public DruidExpression visitCall(\n+            CallExpression call,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        Optional<DruidExpression> basicCallHandlingResult = basicCallHandling(call, context);\n+        if (basicCallHandlingResult.isPresent()) {\n+            return basicCallHandlingResult.get();\n+        }\n+        FunctionMetadata functionMetadata = functionMetadataManager.getFunctionMetadata(call.getFunctionHandle());\n+        Optional<OperatorType> operatorTypeOptional = functionMetadata.getOperatorType();\n+        if (operatorTypeOptional.isPresent()) {\n+            OperatorType operatorType = operatorTypeOptional.get();\n+            if (operatorType.isArithmeticOperator()) {\n+                return handleArithmeticExpression(call, operatorType, context);\n+            }\n+            if (operatorType.isComparisonOperator()) {\n+                throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported operator: \" + call + \" to pushdown for Druid connector \");\n+            }\n+        }\n+        return handleFunction(call, context);\n+    }\n+\n+    @Override\n+    public DruidExpression visitConstant(\n+            ConstantExpression literal,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        return new DruidExpression(getLiteralAsString(literal), DruidQueryGeneratorContext.Origin.LITERAL);\n+    }\n+\n+    private DruidExpression handleDateTruncationViaDateTruncation(\n+            CallExpression function,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        RowExpression timeInputParameter = function.getArguments().get(1);\n+        String inputColumn;\n+        String inputTimeZone;\n+        String inputFormat;\n+\n+        CallExpression timeConversion = getExpressionAsFunction(timeInputParameter, timeInputParameter);\n+        switch (timeConversion.getDisplayName().toLowerCase(ENGLISH)) {", "originalCommit": "01dd5e96cd75fa9eb31e9f1241012bc4fa24d226", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5Mjg5OQ==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r389992899", "bodyText": "same nit: .. Druid connector \"; there are many typos in this patch", "author": "highker", "createdAt": "2020-03-09T22:18:53Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.FunctionMetadata;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.OperatorType;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.slice.Slice;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidExpression.derived;\n+import static com.facebook.presto.druid.DruidPushdownUtils.getLiteralAsString;\n+import static java.lang.String.format;\n+import static java.util.Locale.ENGLISH;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidAggregationProjectConverter\n+        extends DruidProjectExpressionConverter\n+{\n+    private static final Map<String, String> PRESTO_TO_DRUID_OPERATORS = ImmutableMap.of(\n+            \"-\", \"SUB\",\n+            \"+\", \"ADD\",\n+            \"*\", \"MULT\",\n+            \"/\", \"DIV\");\n+    private static final String FROM_UNIXTIME = \"from_unixtime\";\n+\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final ConnectorSession session;\n+\n+    public DruidAggregationProjectConverter(TypeManager typeManager, FunctionMetadataManager functionMetadataManager, StandardFunctionResolution standardFunctionResolution, ConnectorSession session)\n+    {\n+        super(typeManager, standardFunctionResolution);\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"functionMetadataManager is null\");\n+        this.session = requireNonNull(session, \"session is null\");\n+    }\n+\n+    @Override\n+    public DruidExpression visitCall(\n+            CallExpression call,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        Optional<DruidExpression> basicCallHandlingResult = basicCallHandling(call, context);\n+        if (basicCallHandlingResult.isPresent()) {\n+            return basicCallHandlingResult.get();\n+        }\n+        FunctionMetadata functionMetadata = functionMetadataManager.getFunctionMetadata(call.getFunctionHandle());\n+        Optional<OperatorType> operatorTypeOptional = functionMetadata.getOperatorType();\n+        if (operatorTypeOptional.isPresent()) {\n+            OperatorType operatorType = operatorTypeOptional.get();\n+            if (operatorType.isArithmeticOperator()) {\n+                return handleArithmeticExpression(call, operatorType, context);\n+            }\n+            if (operatorType.isComparisonOperator()) {\n+                throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported operator: \" + call + \" to pushdown for Druid connector \");\n+            }\n+        }\n+        return handleFunction(call, context);\n+    }\n+\n+    @Override\n+    public DruidExpression visitConstant(\n+            ConstantExpression literal,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        return new DruidExpression(getLiteralAsString(literal), DruidQueryGeneratorContext.Origin.LITERAL);\n+    }\n+\n+    private DruidExpression handleDateTruncationViaDateTruncation(\n+            CallExpression function,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        RowExpression timeInputParameter = function.getArguments().get(1);\n+        String inputColumn;\n+        String inputTimeZone;\n+        String inputFormat;\n+\n+        CallExpression timeConversion = getExpressionAsFunction(timeInputParameter, timeInputParameter);\n+        switch (timeConversion.getDisplayName().toLowerCase(ENGLISH)) {\n+            case FROM_UNIXTIME:\n+                inputColumn = timeConversion.getArguments().get(0).accept(this, context).getDefinition();\n+                inputTimeZone = timeConversion.getArguments().size() > 1 ? getStringFromConstant(timeConversion.getArguments().get(1)) : DateTimeZone.UTC.getID();\n+                inputFormat = \"seconds\";\n+                break;\n+            default:\n+                throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported time function: \" + timeConversion.getDisplayName() + \" to pushdown for Druid connector \");", "originalCommit": "01dd5e96cd75fa9eb31e9f1241012bc4fa24d226", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5MzAxNA==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r389993014", "bodyText": "if", "author": "highker", "createdAt": "2020-03-09T22:19:13Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java", "diffHunk": "@@ -0,0 +1,187 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.ConnectorSession;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.FunctionMetadata;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.OperatorType;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.slice.Slice;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidExpression.derived;\n+import static com.facebook.presto.druid.DruidPushdownUtils.getLiteralAsString;\n+import static java.lang.String.format;\n+import static java.util.Locale.ENGLISH;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidAggregationProjectConverter\n+        extends DruidProjectExpressionConverter\n+{\n+    private static final Map<String, String> PRESTO_TO_DRUID_OPERATORS = ImmutableMap.of(\n+            \"-\", \"SUB\",\n+            \"+\", \"ADD\",\n+            \"*\", \"MULT\",\n+            \"/\", \"DIV\");\n+    private static final String FROM_UNIXTIME = \"from_unixtime\";\n+\n+    private final FunctionMetadataManager functionMetadataManager;\n+    private final ConnectorSession session;\n+\n+    public DruidAggregationProjectConverter(TypeManager typeManager, FunctionMetadataManager functionMetadataManager, StandardFunctionResolution standardFunctionResolution, ConnectorSession session)\n+    {\n+        super(typeManager, standardFunctionResolution);\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"functionMetadataManager is null\");\n+        this.session = requireNonNull(session, \"session is null\");\n+    }\n+\n+    @Override\n+    public DruidExpression visitCall(\n+            CallExpression call,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        Optional<DruidExpression> basicCallHandlingResult = basicCallHandling(call, context);\n+        if (basicCallHandlingResult.isPresent()) {\n+            return basicCallHandlingResult.get();\n+        }\n+        FunctionMetadata functionMetadata = functionMetadataManager.getFunctionMetadata(call.getFunctionHandle());\n+        Optional<OperatorType> operatorTypeOptional = functionMetadata.getOperatorType();\n+        if (operatorTypeOptional.isPresent()) {\n+            OperatorType operatorType = operatorTypeOptional.get();\n+            if (operatorType.isArithmeticOperator()) {\n+                return handleArithmeticExpression(call, operatorType, context);\n+            }\n+            if (operatorType.isComparisonOperator()) {\n+                throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported operator: \" + call + \" to pushdown for Druid connector \");\n+            }\n+        }\n+        return handleFunction(call, context);\n+    }\n+\n+    @Override\n+    public DruidExpression visitConstant(\n+            ConstantExpression literal,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        return new DruidExpression(getLiteralAsString(literal), DruidQueryGeneratorContext.Origin.LITERAL);\n+    }\n+\n+    private DruidExpression handleDateTruncationViaDateTruncation(\n+            CallExpression function,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        RowExpression timeInputParameter = function.getArguments().get(1);\n+        String inputColumn;\n+        String inputTimeZone;\n+        String inputFormat;\n+\n+        CallExpression timeConversion = getExpressionAsFunction(timeInputParameter, timeInputParameter);\n+        switch (timeConversion.getDisplayName().toLowerCase(ENGLISH)) {\n+            case FROM_UNIXTIME:\n+                inputColumn = timeConversion.getArguments().get(0).accept(this, context).getDefinition();\n+                inputTimeZone = timeConversion.getArguments().size() > 1 ? getStringFromConstant(timeConversion.getArguments().get(1)) : DateTimeZone.UTC.getID();\n+                inputFormat = \"seconds\";\n+                break;\n+            default:\n+                throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported time function: \" + timeConversion.getDisplayName() + \" to pushdown for Druid connector \");\n+        }\n+\n+        RowExpression intervalParameter = function.getArguments().get(0);\n+        if (!(intervalParameter instanceof ConstantExpression)) {\n+            throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported interval unit: \" + intervalParameter + \" to pushdown for Druid connector \");\n+        }\n+\n+        return derived(\"dateTrunc(\" + inputColumn + \",\" + inputFormat + \", \" + inputTimeZone + \", \" + getStringFromConstant(intervalParameter) + \")\");\n+    }\n+\n+    private DruidExpression handleArithmeticExpression(\n+            CallExpression expression,\n+            OperatorType operatorType,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        List<RowExpression> arguments = expression.getArguments();\n+        if (arguments.size() == 1) {\n+            String prefix = operatorType == OperatorType.NEGATION ? \"-\" : \"\";\n+            return derived(prefix + arguments.get(0).accept(this, context).getDefinition());\n+        }\n+        if (arguments.size() == 2) {\n+            DruidExpression left = arguments.get(0).accept(this, context);\n+            DruidExpression right = arguments.get(1).accept(this, context);\n+            String prestoOperator = operatorType.getOperator();\n+            String druidOperator = PRESTO_TO_DRUID_OPERATORS.get(prestoOperator);\n+            if (druidOperator == null) {\n+                throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported binary expression: \" + prestoOperator + \" to pushdown for Druid connector \");\n+            }\n+            return derived(format(\"%s(%s, %s)\", druidOperator, left.getDefinition(), right.getDefinition()));\n+        }\n+        throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported arithmetic expression: \" + expression + \" to pushdown for Druid connector \");\n+    }\n+\n+    private DruidExpression handleFunction(\n+            CallExpression function,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        switch (function.getDisplayName().toLowerCase(ENGLISH)) {", "originalCommit": "01dd5e96cd75fa9eb31e9f1241012bc4fa24d226", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NDU4Ng==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r389994586", "bodyText": "Having a public enum in a util class doesn't sound good. Can you make AggregationColumnNode a top-level class and call it DruidAggregationColumnNode? Put the enum and two implementations as the inner class of it.", "author": "highker", "createdAt": "2020-03-09T22:23:50Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidPushdownUtils.java", "diffHunk": "@@ -42,6 +47,106 @@\n {\n     private DruidPushdownUtils() {}\n \n+    public enum ExpressionType\n+    {\n+        GROUP_BY,\n+        AGGREGATE,\n+    }\n+\n+    public static class GroupByColumnNode", "originalCommit": "01dd5e96cd75fa9eb31e9f1241012bc4fa24d226", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NDg0OQ==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r389994849", "bodyText": "Move to the end of the class", "author": "highker", "createdAt": "2020-03-09T22:24:38Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -220,9 +243,112 @@ public DruidQueryGeneratorContext visitTableScan(TableScanNode node, DruidQueryG\n             Map<VariableReferenceExpression, Selection> selections = new LinkedHashMap<>();\n             node.getOutputVariables().forEach(outputColumn -> {\n                 DruidColumnHandle druidColumn = (DruidColumnHandle) (node.getAssignments().get(outputColumn));\n+                checkArgument(druidColumn.getType().equals(DruidColumnHandle.DruidColumnType.REGULAR), \"Unexpected druid column handle that is not regular: \" + druidColumn);\n                 selections.put(outputColumn, new Selection(druidColumn.getColumnName(), TABLE_COLUMN));\n             });\n             return new DruidQueryGeneratorContext(selections, tableHandle.getTableName());\n         }\n+\n+        private String handleAggregationFunction(CallExpression aggregation, Map<VariableReferenceExpression, Selection> inputSelections)", "originalCommit": "01dd5e96cd75fa9eb31e9f1241012bc4fa24d226", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NDg5Mg==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r389994892", "bodyText": "if", "author": "highker", "createdAt": "2020-03-09T22:24:45Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -220,9 +243,112 @@ public DruidQueryGeneratorContext visitTableScan(TableScanNode node, DruidQueryG\n             Map<VariableReferenceExpression, Selection> selections = new LinkedHashMap<>();\n             node.getOutputVariables().forEach(outputColumn -> {\n                 DruidColumnHandle druidColumn = (DruidColumnHandle) (node.getAssignments().get(outputColumn));\n+                checkArgument(druidColumn.getType().equals(DruidColumnHandle.DruidColumnType.REGULAR), \"Unexpected druid column handle that is not regular: \" + druidColumn);\n                 selections.put(outputColumn, new Selection(druidColumn.getColumnName(), TABLE_COLUMN));\n             });\n             return new DruidQueryGeneratorContext(selections, tableHandle.getTableName());\n         }\n+\n+        private String handleAggregationFunction(CallExpression aggregation, Map<VariableReferenceExpression, Selection> inputSelections)\n+        {\n+            String prestoAggregation = aggregation.getDisplayName().toLowerCase(ENGLISH);\n+            List<RowExpression> parameters = aggregation.getArguments();\n+            switch (prestoAggregation) {", "originalCommit": "01dd5e96cd75fa9eb31e9f1241012bc4fa24d226", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NTA1Mw==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r389995053", "bodyText": "leave a space after function:", "author": "highker", "createdAt": "2020-03-09T22:25:12Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -220,9 +243,112 @@ public DruidQueryGeneratorContext visitTableScan(TableScanNode node, DruidQueryG\n             Map<VariableReferenceExpression, Selection> selections = new LinkedHashMap<>();\n             node.getOutputVariables().forEach(outputColumn -> {\n                 DruidColumnHandle druidColumn = (DruidColumnHandle) (node.getAssignments().get(outputColumn));\n+                checkArgument(druidColumn.getType().equals(DruidColumnHandle.DruidColumnType.REGULAR), \"Unexpected druid column handle that is not regular: \" + druidColumn);\n                 selections.put(outputColumn, new Selection(druidColumn.getColumnName(), TABLE_COLUMN));\n             });\n             return new DruidQueryGeneratorContext(selections, tableHandle.getTableName());\n         }\n+\n+        private String handleAggregationFunction(CallExpression aggregation, Map<VariableReferenceExpression, Selection> inputSelections)\n+        {\n+            String prestoAggregation = aggregation.getDisplayName().toLowerCase(ENGLISH);\n+            List<RowExpression> parameters = aggregation.getArguments();\n+            switch (prestoAggregation) {\n+                case \"count\":\n+                    if (parameters.size() <= 1) {\n+                        return format(\"count(%s)\", parameters.isEmpty() ? \"*\" : inputSelections.get(getVariableReference(parameters.get(0))));\n+                    }\n+                    break;\n+                default:\n+                    if (UNARY_AGGREGATION_MAP.containsKey(prestoAggregation) && aggregation.getArguments().size() == 1) {\n+                        return format(\"%s(%s)\", UNARY_AGGREGATION_MAP.get(prestoAggregation), inputSelections.get(getVariableReference(parameters.get(0))));\n+                    }\n+            }\n+\n+            throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector. Aggregation function:\" + aggregation + \" not supported\");", "originalCommit": "01dd5e96cd75fa9eb31e9f1241012bc4fa24d226", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTk5NTE2Mw==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r389995163", "bodyText": "typo aggregatin", "author": "highker", "createdAt": "2020-03-09T22:25:29Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -220,9 +243,112 @@ public DruidQueryGeneratorContext visitTableScan(TableScanNode node, DruidQueryG\n             Map<VariableReferenceExpression, Selection> selections = new LinkedHashMap<>();\n             node.getOutputVariables().forEach(outputColumn -> {\n                 DruidColumnHandle druidColumn = (DruidColumnHandle) (node.getAssignments().get(outputColumn));\n+                checkArgument(druidColumn.getType().equals(DruidColumnHandle.DruidColumnType.REGULAR), \"Unexpected druid column handle that is not regular: \" + druidColumn);\n                 selections.put(outputColumn, new Selection(druidColumn.getColumnName(), TABLE_COLUMN));\n             });\n             return new DruidQueryGeneratorContext(selections, tableHandle.getTableName());\n         }\n+\n+        private String handleAggregationFunction(CallExpression aggregation, Map<VariableReferenceExpression, Selection> inputSelections)\n+        {\n+            String prestoAggregation = aggregation.getDisplayName().toLowerCase(ENGLISH);\n+            List<RowExpression> parameters = aggregation.getArguments();\n+            switch (prestoAggregation) {\n+                case \"count\":\n+                    if (parameters.size() <= 1) {\n+                        return format(\"count(%s)\", parameters.isEmpty() ? \"*\" : inputSelections.get(getVariableReference(parameters.get(0))));\n+                    }\n+                    break;\n+                default:\n+                    if (UNARY_AGGREGATION_MAP.containsKey(prestoAggregation) && aggregation.getArguments().size() == 1) {\n+                        return format(\"%s(%s)\", UNARY_AGGREGATION_MAP.get(prestoAggregation), inputSelections.get(getVariableReference(parameters.get(0))));\n+                    }\n+            }\n+\n+            throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector. Aggregation function:\" + aggregation + \" not supported\");\n+        }\n+\n+        @Override\n+        public DruidQueryGeneratorContext visitAggregation(AggregationNode node, DruidQueryGeneratorContext contextIn)\n+        {\n+            List<AggregationColumnNode> aggregationColumnNodes = computeAggregationNodes(node);\n+\n+            // Make two passes over the aggregatinColumnNodes: In the first pass identify all the variables that will be used", "originalCommit": "01dd5e96cd75fa9eb31e9f1241012bc4fa24d226", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c8e75f8af24a4b6b14ef7b2eaffa275c84366b60", "url": "https://github.com/prestodb/presto/commit/c8e75f8af24a4b6b14ef7b2eaffa275c84366b60", "message": "Aggregation Pushdown for Druid connector", "committedDate": "2020-03-10T02:27:55Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU0MDkxNA==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r390540914", "bodyText": "so this refers to query without Group By clause?", "author": "luohao", "createdAt": "2020-03-10T18:55:55Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -220,9 +244,108 @@ public DruidQueryGeneratorContext visitTableScan(TableScanNode node, DruidQueryG\n             Map<VariableReferenceExpression, Selection> selections = new LinkedHashMap<>();\n             node.getOutputVariables().forEach(outputColumn -> {\n                 DruidColumnHandle druidColumn = (DruidColumnHandle) (node.getAssignments().get(outputColumn));\n+                checkArgument(druidColumn.getType().equals(DruidColumnHandle.DruidColumnType.REGULAR), \"Unexpected druid column handle that is not regular: \" + druidColumn);\n                 selections.put(outputColumn, new Selection(druidColumn.getColumnName(), TABLE_COLUMN));\n             });\n             return new DruidQueryGeneratorContext(selections, tableHandle.getTableName());\n         }\n+\n+        @Override\n+        public DruidQueryGeneratorContext visitAggregation(AggregationNode node, DruidQueryGeneratorContext contextIn)\n+        {\n+            List<DruidAggregationColumnNode> aggregationColumnNodes = computeAggregationNodes(node);\n+\n+            // Make two passes over the aggregationColumnNodes: In the first pass identify all the variables that will be used\n+            // Then pass that context to the source\n+            // And finally, in the second pass actually generate the PQL\n+\n+            // 1st pass\n+            Set<VariableReferenceExpression> variablesInAggregation = new HashSet<>();\n+            for (DruidAggregationColumnNode expression : aggregationColumnNodes) {\n+                switch (expression.getExpressionType()) {\n+                    case GROUP_BY: {\n+                        GroupByColumnNode groupByColumn = (GroupByColumnNode) expression;\n+                        VariableReferenceExpression groupByInputColumn = getVariableReference(groupByColumn.getInputColumn());\n+                        variablesInAggregation.add(groupByInputColumn);\n+                        break;\n+                    }\n+                    case AGGREGATE: {\n+                        AggregationFunctionColumnNode aggregationNode = (AggregationFunctionColumnNode) expression;\n+                        variablesInAggregation.addAll(\n+                                aggregationNode\n+                                        .getCallExpression()\n+                                        .getArguments()\n+                                        .stream()\n+                                        .filter(argument -> argument instanceof VariableReferenceExpression)\n+                                        .map(argument -> (VariableReferenceExpression) argument)\n+                                        .collect(Collectors.toList()));\n+                        break;\n+                    }\n+                    default:\n+                        throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector. Unknown aggregation expression:\" + expression.getExpressionType());\n+                }\n+            }\n+\n+            // now visit the child project node\n+            DruidQueryGeneratorContext context = node.getSource().accept(this, contextIn.withVariablesInAggregation(variablesInAggregation));\n+            requireNonNull(context, \"context is null\");\n+            checkArgument(!node.getStep().isOutputPartial(), \"Druid pushdown does not support partial aggregations\");\n+\n+            // 2nd pass\n+            Map<VariableReferenceExpression, Selection> newSelections = new LinkedHashMap<>();\n+            Set<VariableReferenceExpression> groupByColumns = new LinkedHashSet<>();\n+            Set<VariableReferenceExpression> hiddenColumnSet = new HashSet<>(context.getHiddenColumnSet());\n+            int aggregations = 0;\n+            boolean groupByExists = false;\n+\n+            for (DruidAggregationColumnNode expression : aggregationColumnNodes) {\n+                switch (expression.getExpressionType()) {\n+                    case GROUP_BY: {\n+                        GroupByColumnNode groupByColumn = (GroupByColumnNode) expression;\n+                        VariableReferenceExpression groupByInputColumn = getVariableReference(groupByColumn.getInputColumn());\n+                        VariableReferenceExpression outputColumn = getVariableReference(groupByColumn.getOutputColumn());\n+                        Selection druidColumn = requireNonNull(context.getSelections().get(groupByInputColumn), \"Group By column \" + groupByInputColumn + \" doesn't exist in input \" + context.getSelections());\n+\n+                        newSelections.put(outputColumn, new Selection(druidColumn.getDefinition(), druidColumn.getOrigin()));\n+                        groupByColumns.add(outputColumn);\n+                        groupByExists = true;\n+                        break;\n+                    }\n+                    case AGGREGATE: {\n+                        AggregationFunctionColumnNode aggregationNode = (AggregationFunctionColumnNode) expression;\n+                        String druidAggregationFunction = handleAggregationFunction(aggregationNode.getCallExpression(), context.getSelections());\n+                        newSelections.put(getVariableReference(aggregationNode.getOutputColumn()), new Selection(druidAggregationFunction, DERIVED));\n+                        aggregations++;\n+                        break;\n+                    }\n+                    default:\n+                        throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector. Unknown aggregation expression:\" + expression.getExpressionType());\n+                }\n+            }\n+\n+            // Handling non-aggregated group by", "originalCommit": "c8e75f8af24a4b6b14ef7b2eaffa275c84366b60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY2MzY0Nw==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r390663647", "bodyText": "query with Group By, but no aggregations, e.g. count(*)", "author": "zhenxiao", "createdAt": "2020-03-10T23:13:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU0MDkxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU0Mjg3Mg==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r390542872", "bodyText": "Druid seems to support more than just min/max/avg/sum. Some of them should have a mapping to Presto aggreation functions(https://druid.apache.org/docs/latest/querying/sql.html#aggregation-functions), while the others may not apply due to implementation(e.g., need to be careful with HLL).\nDo you plan to add other functions?", "author": "luohao", "createdAt": "2020-03-10T18:59:10Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -19,33 +19,56 @@\n import com.facebook.presto.spi.PrestoException;\n import com.facebook.presto.spi.function.FunctionMetadataManager;\n import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.AggregationNode;\n import com.facebook.presto.spi.plan.FilterNode;\n import com.facebook.presto.spi.plan.LimitNode;\n import com.facebook.presto.spi.plan.PlanNode;\n import com.facebook.presto.spi.plan.PlanVisitor;\n import com.facebook.presto.spi.plan.ProjectNode;\n import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.CallExpression;\n import com.facebook.presto.spi.relation.RowExpression;\n import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.BigintType;\n import com.facebook.presto.spi.type.TypeManager;\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableMap;\n \n import javax.inject.Inject;\n \n+import java.util.HashSet;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n \n+import static com.facebook.presto.druid.DruidAggregationColumnNode.AggregationFunctionColumnNode;\n+import static com.facebook.presto.druid.DruidAggregationColumnNode.ExpressionType.AGGREGATE;\n+import static com.facebook.presto.druid.DruidAggregationColumnNode.ExpressionType.GROUP_BY;\n+import static com.facebook.presto.druid.DruidAggregationColumnNode.GroupByColumnNode;\n import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidPushdownUtils.computeAggregationNodes;\n+import static com.facebook.presto.druid.DruidQueryGeneratorContext.Origin.DERIVED;\n import static com.facebook.presto.druid.DruidQueryGeneratorContext.Origin.TABLE_COLUMN;\n import static com.google.common.base.MoreObjects.toStringHelper;\n import static com.google.common.base.Preconditions.checkArgument;\n+import static java.lang.String.format;\n+import static java.util.Locale.ENGLISH;\n import static java.util.Objects.requireNonNull;\n \n public class DruidQueryGenerator\n {\n     private static final Logger log = Logger.get(DruidQueryGenerator.class);\n+    private static final Map<String, String> UNARY_AGGREGATION_MAP = ImmutableMap.of(", "originalCommit": "c8e75f8af24a4b6b14ef7b2eaffa275c84366b60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY2MzQ3OQ==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r390663479", "bodyText": "yep, will add in following PRs. Start with easy ones :)", "author": "zhenxiao", "createdAt": "2020-03-10T23:12:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU0Mjg3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU0MzE4Nw==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r390543187", "bodyText": "what is PQL?", "author": "luohao", "createdAt": "2020-03-10T18:59:44Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -220,9 +244,108 @@ public DruidQueryGeneratorContext visitTableScan(TableScanNode node, DruidQueryG\n             Map<VariableReferenceExpression, Selection> selections = new LinkedHashMap<>();\n             node.getOutputVariables().forEach(outputColumn -> {\n                 DruidColumnHandle druidColumn = (DruidColumnHandle) (node.getAssignments().get(outputColumn));\n+                checkArgument(druidColumn.getType().equals(DruidColumnHandle.DruidColumnType.REGULAR), \"Unexpected druid column handle that is not regular: \" + druidColumn);\n                 selections.put(outputColumn, new Selection(druidColumn.getColumnName(), TABLE_COLUMN));\n             });\n             return new DruidQueryGeneratorContext(selections, tableHandle.getTableName());\n         }\n+\n+        @Override\n+        public DruidQueryGeneratorContext visitAggregation(AggregationNode node, DruidQueryGeneratorContext contextIn)\n+        {\n+            List<DruidAggregationColumnNode> aggregationColumnNodes = computeAggregationNodes(node);\n+\n+            // Make two passes over the aggregationColumnNodes: In the first pass identify all the variables that will be used\n+            // Then pass that context to the source\n+            // And finally, in the second pass actually generate the PQL", "originalCommit": "c8e75f8af24a4b6b14ef7b2eaffa275c84366b60", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU0NDM3Mg==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r390544372", "bodyText": "Is count the only aggregation function in this case?", "author": "luohao", "createdAt": "2020-03-10T19:01:47Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -220,9 +244,108 @@ public DruidQueryGeneratorContext visitTableScan(TableScanNode node, DruidQueryG\n             Map<VariableReferenceExpression, Selection> selections = new LinkedHashMap<>();\n             node.getOutputVariables().forEach(outputColumn -> {\n                 DruidColumnHandle druidColumn = (DruidColumnHandle) (node.getAssignments().get(outputColumn));\n+                checkArgument(druidColumn.getType().equals(DruidColumnHandle.DruidColumnType.REGULAR), \"Unexpected druid column handle that is not regular: \" + druidColumn);\n                 selections.put(outputColumn, new Selection(druidColumn.getColumnName(), TABLE_COLUMN));\n             });\n             return new DruidQueryGeneratorContext(selections, tableHandle.getTableName());\n         }\n+\n+        @Override\n+        public DruidQueryGeneratorContext visitAggregation(AggregationNode node, DruidQueryGeneratorContext contextIn)\n+        {\n+            List<DruidAggregationColumnNode> aggregationColumnNodes = computeAggregationNodes(node);\n+\n+            // Make two passes over the aggregationColumnNodes: In the first pass identify all the variables that will be used\n+            // Then pass that context to the source\n+            // And finally, in the second pass actually generate the PQL\n+\n+            // 1st pass\n+            Set<VariableReferenceExpression> variablesInAggregation = new HashSet<>();\n+            for (DruidAggregationColumnNode expression : aggregationColumnNodes) {\n+                switch (expression.getExpressionType()) {\n+                    case GROUP_BY: {\n+                        GroupByColumnNode groupByColumn = (GroupByColumnNode) expression;\n+                        VariableReferenceExpression groupByInputColumn = getVariableReference(groupByColumn.getInputColumn());\n+                        variablesInAggregation.add(groupByInputColumn);\n+                        break;\n+                    }\n+                    case AGGREGATE: {\n+                        AggregationFunctionColumnNode aggregationNode = (AggregationFunctionColumnNode) expression;\n+                        variablesInAggregation.addAll(\n+                                aggregationNode\n+                                        .getCallExpression()\n+                                        .getArguments()\n+                                        .stream()\n+                                        .filter(argument -> argument instanceof VariableReferenceExpression)\n+                                        .map(argument -> (VariableReferenceExpression) argument)\n+                                        .collect(Collectors.toList()));\n+                        break;\n+                    }\n+                    default:\n+                        throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector. Unknown aggregation expression:\" + expression.getExpressionType());\n+                }\n+            }\n+\n+            // now visit the child project node\n+            DruidQueryGeneratorContext context = node.getSource().accept(this, contextIn.withVariablesInAggregation(variablesInAggregation));\n+            requireNonNull(context, \"context is null\");\n+            checkArgument(!node.getStep().isOutputPartial(), \"Druid pushdown does not support partial aggregations\");\n+\n+            // 2nd pass\n+            Map<VariableReferenceExpression, Selection> newSelections = new LinkedHashMap<>();\n+            Set<VariableReferenceExpression> groupByColumns = new LinkedHashSet<>();\n+            Set<VariableReferenceExpression> hiddenColumnSet = new HashSet<>(context.getHiddenColumnSet());\n+            int aggregations = 0;\n+            boolean groupByExists = false;\n+\n+            for (DruidAggregationColumnNode expression : aggregationColumnNodes) {\n+                switch (expression.getExpressionType()) {\n+                    case GROUP_BY: {\n+                        GroupByColumnNode groupByColumn = (GroupByColumnNode) expression;\n+                        VariableReferenceExpression groupByInputColumn = getVariableReference(groupByColumn.getInputColumn());\n+                        VariableReferenceExpression outputColumn = getVariableReference(groupByColumn.getOutputColumn());\n+                        Selection druidColumn = requireNonNull(context.getSelections().get(groupByInputColumn), \"Group By column \" + groupByInputColumn + \" doesn't exist in input \" + context.getSelections());\n+\n+                        newSelections.put(outputColumn, new Selection(druidColumn.getDefinition(), druidColumn.getOrigin()));\n+                        groupByColumns.add(outputColumn);\n+                        groupByExists = true;\n+                        break;\n+                    }\n+                    case AGGREGATE: {\n+                        AggregationFunctionColumnNode aggregationNode = (AggregationFunctionColumnNode) expression;\n+                        String druidAggregationFunction = handleAggregationFunction(aggregationNode.getCallExpression(), context.getSelections());\n+                        newSelections.put(getVariableReference(aggregationNode.getOutputColumn()), new Selection(druidAggregationFunction, DERIVED));\n+                        aggregations++;\n+                        break;\n+                    }\n+                    default:\n+                        throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector. Unknown aggregation expression:\" + expression.getExpressionType());\n+                }\n+            }\n+\n+            // Handling non-aggregated group by\n+            if (groupByExists && aggregations == 0) {\n+                VariableReferenceExpression hidden = new VariableReferenceExpression(UUID.randomUUID().toString(), BigintType.BIGINT);\n+                newSelections.put(hidden, new Selection(\"count(*)\", DERIVED));", "originalCommit": "c8e75f8af24a4b6b14ef7b2eaffa275c84366b60", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDY2Mzc1OA==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r390663758", "bodyText": "yep, count(*) is the only case", "author": "zhenxiao", "createdAt": "2020-03-10T23:13:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDU0NDM3Mg=="}], "type": "inlineReview"}, {"oid": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "url": "https://github.com/prestodb/presto/commit/d8b92c3527cf1c936be599843e2c54d6a5803e71", "message": "Aggregation Pushdown for Druid connector", "committedDate": "2020-03-10T23:11:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE1OTM2Mg==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393159362", "bodyText": "requireNonNull", "author": "highker", "createdAt": "2020-03-16T16:40:12Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationColumnNode.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+\n+public abstract class DruidAggregationColumnNode\n+{\n+    private final ExpressionType expressionType;\n+    private final VariableReferenceExpression outputColumn;\n+\n+    public DruidAggregationColumnNode(ExpressionType expressionType, VariableReferenceExpression outputColumn)\n+    {\n+        this.expressionType = expressionType;", "originalCommit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE2MDI1OQ==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393160259", "bodyText": "requireNonNull", "author": "highker", "createdAt": "2020-03-16T16:41:27Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationColumnNode.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+\n+public abstract class DruidAggregationColumnNode\n+{\n+    private final ExpressionType expressionType;\n+    private final VariableReferenceExpression outputColumn;\n+\n+    public DruidAggregationColumnNode(ExpressionType expressionType, VariableReferenceExpression outputColumn)\n+    {\n+        this.expressionType = expressionType;\n+        this.outputColumn = outputColumn;\n+    }\n+\n+    public VariableReferenceExpression getOutputColumn()\n+    {\n+        return outputColumn;\n+    }\n+\n+    public ExpressionType getExpressionType()\n+    {\n+        return expressionType;\n+    }\n+\n+    public enum ExpressionType\n+    {\n+        GROUP_BY,\n+        AGGREGATE,\n+    }\n+\n+    public static class GroupByColumnNode\n+            extends DruidAggregationColumnNode\n+    {\n+        private final VariableReferenceExpression inputColumn;\n+\n+        public GroupByColumnNode(VariableReferenceExpression inputColumn, VariableReferenceExpression output)\n+        {\n+            super(ExpressionType.GROUP_BY, output);\n+            this.inputColumn = inputColumn;", "originalCommit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE2MDQ2MA==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393160460", "bodyText": "same", "author": "highker", "createdAt": "2020-03-16T16:41:40Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationColumnNode.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+\n+public abstract class DruidAggregationColumnNode\n+{\n+    private final ExpressionType expressionType;\n+    private final VariableReferenceExpression outputColumn;\n+\n+    public DruidAggregationColumnNode(ExpressionType expressionType, VariableReferenceExpression outputColumn)\n+    {\n+        this.expressionType = expressionType;\n+        this.outputColumn = outputColumn;\n+    }\n+\n+    public VariableReferenceExpression getOutputColumn()\n+    {\n+        return outputColumn;\n+    }\n+\n+    public ExpressionType getExpressionType()\n+    {\n+        return expressionType;\n+    }\n+\n+    public enum ExpressionType\n+    {\n+        GROUP_BY,\n+        AGGREGATE,\n+    }\n+\n+    public static class GroupByColumnNode\n+            extends DruidAggregationColumnNode\n+    {\n+        private final VariableReferenceExpression inputColumn;\n+\n+        public GroupByColumnNode(VariableReferenceExpression inputColumn, VariableReferenceExpression output)\n+        {\n+            super(ExpressionType.GROUP_BY, output);\n+            this.inputColumn = inputColumn;\n+        }\n+\n+        public VariableReferenceExpression getInputColumn()\n+        {\n+            return inputColumn;\n+        }\n+\n+        @Override\n+        public String toString()\n+        {\n+            return inputColumn.toString();\n+        }\n+    }\n+\n+    public static class AggregationFunctionColumnNode\n+            extends DruidAggregationColumnNode\n+    {\n+        private final CallExpression callExpression;\n+\n+        public AggregationFunctionColumnNode(VariableReferenceExpression output, CallExpression callExpression)\n+        {\n+            super(ExpressionType.AGGREGATE, output);\n+            this.callExpression = callExpression;", "originalCommit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE2MTkxMg==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393161912", "bodyText": "if (!...) {\n    throw new\n}\n\n// remove the `else`", "author": "highker", "createdAt": "2020-03-16T16:43:50Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidAggregationProjectConverter.java", "diffHunk": "@@ -0,0 +1,183 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.druid;\n+\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.FunctionMetadata;\n+import com.facebook.presto.spi.function.FunctionMetadataManager;\n+import com.facebook.presto.spi.function.OperatorType;\n+import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.relation.CallExpression;\n+import com.facebook.presto.spi.relation.ConstantExpression;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.TypeManager;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.slice.Slice;\n+import org.joda.time.DateTimeZone;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.druid.DruidErrorCode.DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION;\n+import static com.facebook.presto.druid.DruidExpression.derived;\n+import static com.facebook.presto.druid.DruidPushdownUtils.getLiteralAsString;\n+import static java.lang.String.format;\n+import static java.util.Locale.ENGLISH;\n+import static java.util.Objects.requireNonNull;\n+\n+public class DruidAggregationProjectConverter\n+        extends DruidProjectExpressionConverter\n+{\n+    private static final Map<String, String> PRESTO_TO_DRUID_OPERATORS = ImmutableMap.of(\n+            \"-\", \"SUB\",\n+            \"+\", \"ADD\",\n+            \"*\", \"MULT\",\n+            \"/\", \"DIV\");\n+    private static final String FROM_UNIXTIME = \"from_unixtime\";\n+    private static final String DATE_TRUNC = \"date_trunc\";\n+\n+    private final FunctionMetadataManager functionMetadataManager;\n+\n+    public DruidAggregationProjectConverter(TypeManager typeManager, FunctionMetadataManager functionMetadataManager, StandardFunctionResolution standardFunctionResolution)\n+    {\n+        super(typeManager, standardFunctionResolution);\n+        this.functionMetadataManager = requireNonNull(functionMetadataManager, \"functionMetadataManager is null\");\n+    }\n+\n+    @Override\n+    public DruidExpression visitCall(\n+            CallExpression call,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        Optional<DruidExpression> basicCallHandlingResult = basicCallHandling(call, context);\n+        if (basicCallHandlingResult.isPresent()) {\n+            return basicCallHandlingResult.get();\n+        }\n+\n+        FunctionMetadata functionMetadata = functionMetadataManager.getFunctionMetadata(call.getFunctionHandle());\n+        Optional<OperatorType> operatorTypeOptional = functionMetadata.getOperatorType();\n+        if (operatorTypeOptional.isPresent()) {\n+            OperatorType operatorType = operatorTypeOptional.get();\n+            if (operatorType.isArithmeticOperator()) {\n+                return handleArithmeticExpression(call, operatorType, context);\n+            }\n+            if (operatorType.isComparisonOperator()) {\n+                throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported operator: \" + call + \" to pushdown for Druid connector.\");\n+            }\n+        }\n+        return handleFunction(call, context);\n+    }\n+\n+    @Override\n+    public DruidExpression visitConstant(\n+            ConstantExpression literal,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        return new DruidExpression(getLiteralAsString(literal), DruidQueryGeneratorContext.Origin.LITERAL);\n+    }\n+\n+    private DruidExpression handleDateTruncationViaDateTruncation(\n+            CallExpression function,\n+            Map<VariableReferenceExpression, DruidQueryGeneratorContext.Selection> context)\n+    {\n+        RowExpression timeInputParameter = function.getArguments().get(1);\n+        String inputColumn;\n+        String inputTimeZone;\n+        String inputFormat;\n+\n+        CallExpression timeConversion = getExpressionAsFunction(timeInputParameter, timeInputParameter);\n+        if (timeConversion.getDisplayName().toLowerCase(ENGLISH).equals(FROM_UNIXTIME)) {", "originalCommit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE2NzU3Nw==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393167577", "bodyText": "unused", "author": "highker", "createdAt": "2020-03-16T16:52:24Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -19,33 +19,56 @@\n import com.facebook.presto.spi.PrestoException;\n import com.facebook.presto.spi.function.FunctionMetadataManager;\n import com.facebook.presto.spi.function.StandardFunctionResolution;\n+import com.facebook.presto.spi.plan.AggregationNode;\n import com.facebook.presto.spi.plan.FilterNode;\n import com.facebook.presto.spi.plan.LimitNode;\n import com.facebook.presto.spi.plan.PlanNode;\n import com.facebook.presto.spi.plan.PlanVisitor;\n import com.facebook.presto.spi.plan.ProjectNode;\n import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.CallExpression;\n import com.facebook.presto.spi.relation.RowExpression;\n import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.spi.type.BigintType;\n import com.facebook.presto.spi.type.TypeManager;\n import com.fasterxml.jackson.annotation.JsonCreator;\n import com.fasterxml.jackson.annotation.JsonProperty;\n+import com.google.common.collect.ImmutableMap;\n \n import javax.inject.Inject;\n \n+import java.util.HashSet;\n import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n import java.util.Map;\n import java.util.Optional;\n+import java.util.Set;\n+import java.util.UUID;\n+import java.util.stream.Collectors;\n \n+import static com.facebook.presto.druid.DruidAggregationColumnNode.AggregationFunctionColumnNode;\n+import static com.facebook.presto.druid.DruidAggregationColumnNode.ExpressionType.AGGREGATE;\n+import static com.facebook.presto.druid.DruidAggregationColumnNode.ExpressionType.GROUP_BY;", "originalCommit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5MDg4MA==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393290880", "bodyText": "? It is used in a few switch cases", "author": "zhenxiao", "createdAt": "2020-03-16T20:27:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE2NzU3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE3MzIxNg==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393173216", "bodyText": "Make it an if/else maybe for readability", "author": "highker", "createdAt": "2020-03-16T16:58:49Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -194,7 +217,8 @@ public DruidQueryGeneratorContext visitProject(ProjectNode node, DruidQueryGener\n             node.getOutputVariables().forEach(variable -> {\n                 RowExpression expression = node.getAssignments().get(variable);\n                 DruidExpression druidExpression = expression.accept(\n-                        druidProjectExpressionConverter,\n+                        contextIn.getVariablesInAggregation().contains(variable) ?", "originalCommit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE3NTk5Mg==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393175992", "bodyText": "break after .stream()\naggregationNode.getCallExpression().getArguments().stream()\n        .filter(...\n        .map..", "author": "highker", "createdAt": "2020-03-16T17:01:43Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -220,9 +244,108 @@ public DruidQueryGeneratorContext visitTableScan(TableScanNode node, DruidQueryG\n             Map<VariableReferenceExpression, Selection> selections = new LinkedHashMap<>();\n             node.getOutputVariables().forEach(outputColumn -> {\n                 DruidColumnHandle druidColumn = (DruidColumnHandle) (node.getAssignments().get(outputColumn));\n+                checkArgument(druidColumn.getType().equals(DruidColumnHandle.DruidColumnType.REGULAR), \"Unexpected druid column handle that is not regular: \" + druidColumn);\n                 selections.put(outputColumn, new Selection(druidColumn.getColumnName(), TABLE_COLUMN));\n             });\n             return new DruidQueryGeneratorContext(selections, tableHandle.getTableName());\n         }\n+\n+        @Override\n+        public DruidQueryGeneratorContext visitAggregation(AggregationNode node, DruidQueryGeneratorContext contextIn)\n+        {\n+            List<DruidAggregationColumnNode> aggregationColumnNodes = computeAggregationNodes(node);\n+\n+            // Make two passes over the aggregationColumnNodes: In the first pass identify all the variables that will be used\n+            // Then pass that context to the source\n+            // And finally, in the second pass actually generate the DQL\n+\n+            // 1st pass\n+            Set<VariableReferenceExpression> variablesInAggregation = new HashSet<>();\n+            for (DruidAggregationColumnNode expression : aggregationColumnNodes) {\n+                switch (expression.getExpressionType()) {\n+                    case GROUP_BY: {\n+                        GroupByColumnNode groupByColumn = (GroupByColumnNode) expression;\n+                        VariableReferenceExpression groupByInputColumn = getVariableReference(groupByColumn.getInputColumn());\n+                        variablesInAggregation.add(groupByInputColumn);\n+                        break;\n+                    }\n+                    case AGGREGATE: {\n+                        AggregationFunctionColumnNode aggregationNode = (AggregationFunctionColumnNode) expression;\n+                        variablesInAggregation.addAll(\n+                                aggregationNode", "originalCommit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE3Njg3OA==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393176878", "bodyText": "this is always false", "author": "highker", "createdAt": "2020-03-16T17:02:43Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGenerator.java", "diffHunk": "@@ -220,9 +244,108 @@ public DruidQueryGeneratorContext visitTableScan(TableScanNode node, DruidQueryG\n             Map<VariableReferenceExpression, Selection> selections = new LinkedHashMap<>();\n             node.getOutputVariables().forEach(outputColumn -> {\n                 DruidColumnHandle druidColumn = (DruidColumnHandle) (node.getAssignments().get(outputColumn));\n+                checkArgument(druidColumn.getType().equals(DruidColumnHandle.DruidColumnType.REGULAR), \"Unexpected druid column handle that is not regular: \" + druidColumn);\n                 selections.put(outputColumn, new Selection(druidColumn.getColumnName(), TABLE_COLUMN));\n             });\n             return new DruidQueryGeneratorContext(selections, tableHandle.getTableName());\n         }\n+\n+        @Override\n+        public DruidQueryGeneratorContext visitAggregation(AggregationNode node, DruidQueryGeneratorContext contextIn)\n+        {\n+            List<DruidAggregationColumnNode> aggregationColumnNodes = computeAggregationNodes(node);\n+\n+            // Make two passes over the aggregationColumnNodes: In the first pass identify all the variables that will be used\n+            // Then pass that context to the source\n+            // And finally, in the second pass actually generate the DQL\n+\n+            // 1st pass\n+            Set<VariableReferenceExpression> variablesInAggregation = new HashSet<>();\n+            for (DruidAggregationColumnNode expression : aggregationColumnNodes) {\n+                switch (expression.getExpressionType()) {\n+                    case GROUP_BY: {\n+                        GroupByColumnNode groupByColumn = (GroupByColumnNode) expression;\n+                        VariableReferenceExpression groupByInputColumn = getVariableReference(groupByColumn.getInputColumn());\n+                        variablesInAggregation.add(groupByInputColumn);\n+                        break;\n+                    }\n+                    case AGGREGATE: {\n+                        AggregationFunctionColumnNode aggregationNode = (AggregationFunctionColumnNode) expression;\n+                        variablesInAggregation.addAll(\n+                                aggregationNode\n+                                        .getCallExpression()\n+                                        .getArguments()\n+                                        .stream()\n+                                        .filter(argument -> argument instanceof VariableReferenceExpression)\n+                                        .map(argument -> (VariableReferenceExpression) argument)\n+                                        .collect(Collectors.toList()));\n+                        break;\n+                    }\n+                    default:\n+                        throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector. Unknown aggregation expression:\" + expression.getExpressionType());\n+                }\n+            }\n+\n+            // now visit the child project node\n+            DruidQueryGeneratorContext context = node.getSource().accept(this, contextIn.withVariablesInAggregation(variablesInAggregation));\n+            requireNonNull(context, \"context is null\");\n+            checkArgument(!node.getStep().isOutputPartial(), \"Druid pushdown does not support partial aggregations\");\n+\n+            // 2nd pass\n+            Map<VariableReferenceExpression, Selection> newSelections = new LinkedHashMap<>();\n+            Set<VariableReferenceExpression> groupByColumns = new LinkedHashSet<>();\n+            Set<VariableReferenceExpression> hiddenColumnSet = new HashSet<>(context.getHiddenColumnSet());\n+            int aggregations = 0;\n+            boolean groupByExists = false;\n+\n+            for (DruidAggregationColumnNode expression : aggregationColumnNodes) {\n+                switch (expression.getExpressionType()) {\n+                    case GROUP_BY: {\n+                        GroupByColumnNode groupByColumn = (GroupByColumnNode) expression;\n+                        VariableReferenceExpression groupByInputColumn = getVariableReference(groupByColumn.getInputColumn());\n+                        VariableReferenceExpression outputColumn = getVariableReference(groupByColumn.getOutputColumn());\n+                        Selection druidColumn = requireNonNull(context.getSelections().get(groupByInputColumn), \"Group By column \" + groupByInputColumn + \" doesn't exist in input \" + context.getSelections());\n+\n+                        newSelections.put(outputColumn, new Selection(druidColumn.getDefinition(), druidColumn.getOrigin()));\n+                        groupByColumns.add(outputColumn);\n+                        groupByExists = true;\n+                        break;\n+                    }\n+                    case AGGREGATE: {\n+                        AggregationFunctionColumnNode aggregationNode = (AggregationFunctionColumnNode) expression;\n+                        String druidAggregationFunction = handleAggregationFunction(aggregationNode.getCallExpression(), context.getSelections());\n+                        newSelections.put(getVariableReference(aggregationNode.getOutputColumn()), new Selection(druidAggregationFunction, DERIVED));\n+                        aggregations++;\n+                        break;\n+                    }\n+                    default:\n+                        throw new PrestoException(DRUID_PUSHDOWN_UNSUPPORTED_EXPRESSION, \"Unsupported pushdown for Druid connector. Unknown aggregation expression:\" + expression.getExpressionType());\n+                }\n+            }\n+\n+            // Handling non-aggregated group by\n+            if (groupByExists && aggregations == 0) {\n+                VariableReferenceExpression hidden = new VariableReferenceExpression(UUID.randomUUID().toString(), BigintType.BIGINT);\n+                newSelections.put(hidden, new Selection(\"count(*)\", DERIVED));\n+                hiddenColumnSet.add(hidden);\n+                aggregations++;\n+            }\n+            return context.withAggregation(newSelections, groupByColumns, aggregations, hiddenColumnSet);\n+        }\n+\n+        private String handleAggregationFunction(CallExpression aggregation, Map<VariableReferenceExpression, Selection> inputSelections)\n+        {\n+            String prestoAggregation = aggregation.getDisplayName().toLowerCase(ENGLISH);\n+            List<RowExpression> parameters = aggregation.getArguments();\n+            if (prestoAggregation.equals(\"count\")) {\n+                if (parameters.size() <= 1) {\n+                    return format(\"count(%s)\", parameters.isEmpty() ? \"*\" : inputSelections.get(getVariableReference(parameters.get(0))));\n+                }\n+                else if (UNARY_AGGREGATION_MAP.containsKey(prestoAggregation) && aggregation.getArguments().size() == 1) {", "originalCommit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzI5NjIzOQ==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393296239", "bodyText": "oh, my bad. Let me fix it", "author": "zhenxiao", "createdAt": "2020-03-16T20:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE3Njg3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE4MDc1MA==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393180750", "bodyText": "merge this two ifs", "author": "highker", "createdAt": "2020-03-16T17:07:05Z", "path": "presto-druid/src/main/java/com/facebook/presto/druid/DruidQueryGeneratorContext.java", "diffHunk": "@@ -140,17 +227,25 @@ private boolean hasFilter()\n             pushdown = true;\n         }\n \n-        if (limit.isPresent()) {\n-            query += \" LIMIT \" + limit.getAsLong();\n+        if (!groupByColumns.isEmpty()) {\n+            String groupByExpression = groupByColumns.stream().map(x -> selections.get(x).getDefinition()).collect(Collectors.joining(\", \"));\n+            query = query + \" GROUP BY \" + groupByExpression;\n             pushdown = true;\n         }\n+\n+        if (!hasAggregation()) {\n+            if (limit.isPresent()) {", "originalCommit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE4MTI3NA==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393181274", "bodyText": "one param per line", "author": "highker", "createdAt": "2020-03-16T17:07:49Z", "path": "presto-druid/src/test/java/com/facebook/presto/druid/TestDruidQueryGenerator.java", "diffHunk": "@@ -92,4 +93,31 @@ public void testSimpleSelectWithFilterLimit()\n         testDQL(planBuilder -> limit(planBuilder, 30L, project(planBuilder, filter(planBuilder, tableScan(planBuilder, druidTable, regionId, city, fare, secondsSinceEpoch), getRowExpression(\"secondssinceepoch > 20\", defaultSessionHolder)), ImmutableList.of(\"city\", \"secondssinceepoch\"))),\n                 \"SELECT city, secondsSinceEpoch FROM realtimeOnly WHERE (secondsSinceEpoch > 20) LIMIT 30\");\n     }\n+\n+    @Test\n+    public void testCountStar()\n+    {\n+        BiConsumer<PlanBuilder, PlanBuilder.AggregationBuilder> aggregationFunctionBuilder = (planBuilder, aggregationBuilder) -> aggregationBuilder.addAggregation(planBuilder.variable(\"agg\"), getRowExpression(\"count(*)\", defaultSessionHolder));\n+        PlanNode justScan = buildPlan(planBuilder -> tableScan(planBuilder, druidTable, regionId, secondsSinceEpoch, city, fare));\n+        PlanNode filter = buildPlan(planBuilder -> filter(planBuilder, tableScan(planBuilder, druidTable, regionId, secondsSinceEpoch, city, fare), getRowExpression(\"fare > 3\", defaultSessionHolder)));\n+        PlanNode anotherFilter = buildPlan(planBuilder -> filter(planBuilder, tableScan(planBuilder, druidTable, regionId, secondsSinceEpoch, city, fare), getRowExpression(\"secondssinceepoch between 200 and 300 and regionid >= 40\", defaultSessionHolder)));\n+        testDQL(planBuilder -> planBuilder.aggregation(aggBuilder -> aggregationFunctionBuilder.accept(planBuilder, aggBuilder.source(justScan).globalGrouping())),", "originalCommit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMwNDM4Mw==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393304383", "bodyText": "yep, just 2 params for testDQL. current format seems OK?", "author": "zhenxiao", "createdAt": "2020-03-16T20:53:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE4MTI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzMxMzQ2Nw==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393313467", "bodyText": "the first line should be empty; the first param starts at the second line. No param needs to follow right after (", "author": "highker", "createdAt": "2020-03-16T21:12:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE4MTI3NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzM3MTIyMA==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393371220", "bodyText": "get it. will fix", "author": "zhenxiao", "createdAt": "2020-03-16T23:45:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE4MTI3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MzE4MTQxMw==", "url": "https://github.com/prestodb/presto/pull/14224#discussion_r393181413", "bodyText": "same", "author": "highker", "createdAt": "2020-03-16T17:08:03Z", "path": "presto-druid/src/test/java/com/facebook/presto/druid/TestDruidQueryGenerator.java", "diffHunk": "@@ -92,4 +93,31 @@ public void testSimpleSelectWithFilterLimit()\n         testDQL(planBuilder -> limit(planBuilder, 30L, project(planBuilder, filter(planBuilder, tableScan(planBuilder, druidTable, regionId, city, fare, secondsSinceEpoch), getRowExpression(\"secondssinceepoch > 20\", defaultSessionHolder)), ImmutableList.of(\"city\", \"secondssinceepoch\"))),\n                 \"SELECT city, secondsSinceEpoch FROM realtimeOnly WHERE (secondsSinceEpoch > 20) LIMIT 30\");\n     }\n+\n+    @Test\n+    public void testCountStar()\n+    {\n+        BiConsumer<PlanBuilder, PlanBuilder.AggregationBuilder> aggregationFunctionBuilder = (planBuilder, aggregationBuilder) -> aggregationBuilder.addAggregation(planBuilder.variable(\"agg\"), getRowExpression(\"count(*)\", defaultSessionHolder));\n+        PlanNode justScan = buildPlan(planBuilder -> tableScan(planBuilder, druidTable, regionId, secondsSinceEpoch, city, fare));\n+        PlanNode filter = buildPlan(planBuilder -> filter(planBuilder, tableScan(planBuilder, druidTable, regionId, secondsSinceEpoch, city, fare), getRowExpression(\"fare > 3\", defaultSessionHolder)));\n+        PlanNode anotherFilter = buildPlan(planBuilder -> filter(planBuilder, tableScan(planBuilder, druidTable, regionId, secondsSinceEpoch, city, fare), getRowExpression(\"secondssinceepoch between 200 and 300 and regionid >= 40\", defaultSessionHolder)));\n+        testDQL(planBuilder -> planBuilder.aggregation(aggBuilder -> aggregationFunctionBuilder.accept(planBuilder, aggBuilder.source(justScan).globalGrouping())),\n+                \"SELECT count(*) FROM realtimeOnly\");\n+        testDQL(planBuilder -> planBuilder.aggregation(aggBuilder -> aggregationFunctionBuilder.accept(planBuilder, aggBuilder.source(filter).globalGrouping())),\n+                \"SELECT count(*) FROM realtimeOnly WHERE (fare > 3)\");\n+        testDQL(planBuilder -> planBuilder.aggregation(aggBuilder -> aggregationFunctionBuilder.accept(planBuilder, aggBuilder.source(filter).singleGroupingSet(v(\"regionid\")))),\n+                \"SELECT regionId, count(*) FROM realtimeOnly WHERE (fare > 3) GROUP BY regionId\");\n+        testDQL(planBuilder -> planBuilder.aggregation(aggBuilder -> aggregationFunctionBuilder.accept(planBuilder, aggBuilder.source(justScan).singleGroupingSet(v(\"regionid\")))),\n+                \"SELECT regionId, count(*) FROM realtimeOnly GROUP BY regionId\");\n+        testDQL(planBuilder -> planBuilder.aggregation(aggBuilder -> aggregationFunctionBuilder.accept(planBuilder, aggBuilder.source(anotherFilter).singleGroupingSet(v(\"regionid\"), v(\"city\")))),\n+                \"SELECT regionId, city, count(*) FROM realtimeOnly WHERE ((secondsSinceEpoch BETWEEN 200 AND 300) AND (regionId >= 40)) GROUP BY regionId, city\");\n+    }\n+\n+    @Test\n+    public void testDistinctSelection()\n+    {\n+        PlanNode justScan = buildPlan(planBuilder -> tableScan(planBuilder, druidTable, regionId, secondsSinceEpoch, city, fare));\n+        testDQL(planBuilder -> planBuilder.aggregation(aggBuilder -> aggBuilder.source(justScan).singleGroupingSet(v(\"regionid\"))),", "originalCommit": "d8b92c3527cf1c936be599843e2c54d6a5803e71", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "d4d132f0934101d7f14c6b550b70d132f6d5c0bd", "url": "https://github.com/prestodb/presto/commit/d4d132f0934101d7f14c6b550b70d132f6d5c0bd", "message": "Aggregation Pushdown for Druid connector", "committedDate": "2020-03-16T20:52:41Z", "type": "forcePushed"}, {"oid": "36a28ed53fda629b614102a18fc6a039a5e1cabf", "url": "https://github.com/prestodb/presto/commit/36a28ed53fda629b614102a18fc6a039a5e1cabf", "message": "Aggregation Pushdown for Druid connector", "committedDate": "2020-03-16T23:45:23Z", "type": "commit"}, {"oid": "36a28ed53fda629b614102a18fc6a039a5e1cabf", "url": "https://github.com/prestodb/presto/commit/36a28ed53fda629b614102a18fc6a039a5e1cabf", "message": "Aggregation Pushdown for Druid connector", "committedDate": "2020-03-16T23:45:23Z", "type": "forcePushed"}]}