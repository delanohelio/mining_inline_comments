{"pr_number": 14961, "pr_title": "Dynamic filtering implementation", "pr_createdAt": "2020-08-05T03:35:30Z", "pr_url": "https://github.com/prestodb/presto/pull/14961", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2MTAwMA==", "url": "https://github.com/prestodb/presto/pull/14961#discussion_r465461000", "bodyText": "DataSize::toBytes", "author": "highker", "createdAt": "2020-08-05T04:12:41Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/aggregation/TypedSet.java", "diffHunk": "@@ -65,11 +67,17 @@ public TypedSet(Type elementType, int expectedSize, String functionName)\n     }\n \n     public TypedSet(Type elementType, BlockBuilder blockBuilder, int expectedSize, String functionName)\n+    {\n+        this(elementType, blockBuilder, expectedSize, functionName, Optional.of(MAX_FUNCTION_MEMORY));\n+    }\n+\n+    public TypedSet(Type elementType, BlockBuilder blockBuilder, int expectedSize, String functionName, Optional<DataSize> maxBlockMemory)\n     {\n         checkArgument(expectedSize >= 0, \"expectedSize must not be negative\");\n         this.elementType = requireNonNull(elementType, \"elementType must not be null\");\n         this.elementBlock = requireNonNull(blockBuilder, \"blockBuilder must not be null\");\n         this.functionName = functionName;\n+        this.maxBlockMemoryInBytes = requireNonNull(maxBlockMemory, \"maxBlockMemory must not be null\").map(value -> value.toBytes()).orElse(Long.MAX_VALUE);", "originalCommit": "840662d0c9db017e7b7da80e50010c47a9f5a6d4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2Mjc1MQ==", "url": "https://github.com/prestodb/presto/pull/14961#discussion_r465462751", "bodyText": "one param per line", "author": "highker", "createdAt": "2020-08-05T04:20:08Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator;\n+\n+import com.facebook.presto.common.Page;\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.predicate.Domain;\n+import com.facebook.presto.common.predicate.TupleDomain;\n+import com.facebook.presto.common.predicate.ValueSet;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.common.type.TypeUtils;\n+import com.facebook.presto.operator.aggregation.TypedSet;\n+import com.facebook.presto.spi.plan.PlanNodeId;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.units.DataSize;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Verify.verify;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.toSet;\n+\n+/**\n+ * This operator acts as a simple \"pass-through\" pipe, while saving its input pages.\n+ * The collected pages' value are used for creating a run-time filtering constraint (for probe-side table scan in an inner join).\n+ * We support only small build-side pages (which should be the case when using \"broadcast\" join).\n+ */\n+public class DynamicFilterSourceOperator\n+        implements Operator\n+{\n+    private static final int EXPECTED_BLOCK_BUILDER_SIZE = 8;\n+\n+    public static class Channel\n+    {\n+        private final String filterId;\n+        private final Type type;\n+        private final int index;\n+\n+        public Channel(String filterId, Type type, int index)\n+        {\n+            this.filterId = filterId;\n+            this.type = type;\n+            this.index = index;\n+        }\n+    }\n+\n+    public static class DynamicFilterSourceOperatorFactory\n+            implements OperatorFactory\n+    {\n+        private final int operatorId;\n+        private final PlanNodeId planNodeId;\n+        private final Consumer<TupleDomain<String>> dynamicPredicateConsumer;\n+        private final List<Channel> channels;\n+        private final int maxFilterPositionsCount;\n+        private final DataSize maxFilterSize;\n+\n+        private boolean closed;\n+\n+        public DynamicFilterSourceOperatorFactory(\n+                int operatorId,\n+                PlanNodeId planNodeId,\n+                Consumer<TupleDomain<String>> dynamicPredicateConsumer,\n+                List<Channel> channels,\n+                int maxFilterPositionsCount,\n+                DataSize maxFilterSize)\n+        {\n+            this.operatorId = operatorId;\n+            this.planNodeId = requireNonNull(planNodeId, \"planNodeId is null\");\n+            this.dynamicPredicateConsumer = requireNonNull(dynamicPredicateConsumer, \"dynamicPredicateConsumer is null\");\n+            this.channels = requireNonNull(channels, \"channels is null\");\n+            verify(channels.stream().map(channel -> channel.filterId).collect(toSet()).size() == channels.size(),\n+                    \"duplicate dynamic filters are not allowed\");\n+            verify(channels.stream().map(channel -> channel.index).collect(toSet()).size() == channels.size(),\n+                    \"duplicate channel indices are not allowed\");", "originalCommit": "6253e8ab153fb7bd2aa69d570a253608d0b9e890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2Mjk4OA==", "url": "https://github.com/prestodb/presto/pull/14961#discussion_r465462988", "bodyText": "Let's move all final variables together and non-final together. Break a line between these two.", "author": "highker", "createdAt": "2020-08-05T04:20:59Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator;\n+\n+import com.facebook.presto.common.Page;\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.predicate.Domain;\n+import com.facebook.presto.common.predicate.TupleDomain;\n+import com.facebook.presto.common.predicate.ValueSet;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.common.type.TypeUtils;\n+import com.facebook.presto.operator.aggregation.TypedSet;\n+import com.facebook.presto.spi.plan.PlanNodeId;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.units.DataSize;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Verify.verify;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.toSet;\n+\n+/**\n+ * This operator acts as a simple \"pass-through\" pipe, while saving its input pages.\n+ * The collected pages' value are used for creating a run-time filtering constraint (for probe-side table scan in an inner join).\n+ * We support only small build-side pages (which should be the case when using \"broadcast\" join).\n+ */\n+public class DynamicFilterSourceOperator\n+        implements Operator\n+{\n+    private static final int EXPECTED_BLOCK_BUILDER_SIZE = 8;\n+\n+    public static class Channel\n+    {\n+        private final String filterId;\n+        private final Type type;\n+        private final int index;\n+\n+        public Channel(String filterId, Type type, int index)\n+        {\n+            this.filterId = filterId;\n+            this.type = type;\n+            this.index = index;\n+        }\n+    }\n+\n+    public static class DynamicFilterSourceOperatorFactory\n+            implements OperatorFactory\n+    {\n+        private final int operatorId;\n+        private final PlanNodeId planNodeId;\n+        private final Consumer<TupleDomain<String>> dynamicPredicateConsumer;\n+        private final List<Channel> channels;\n+        private final int maxFilterPositionsCount;\n+        private final DataSize maxFilterSize;\n+\n+        private boolean closed;\n+\n+        public DynamicFilterSourceOperatorFactory(\n+                int operatorId,\n+                PlanNodeId planNodeId,\n+                Consumer<TupleDomain<String>> dynamicPredicateConsumer,\n+                List<Channel> channels,\n+                int maxFilterPositionsCount,\n+                DataSize maxFilterSize)\n+        {\n+            this.operatorId = operatorId;\n+            this.planNodeId = requireNonNull(planNodeId, \"planNodeId is null\");\n+            this.dynamicPredicateConsumer = requireNonNull(dynamicPredicateConsumer, \"dynamicPredicateConsumer is null\");\n+            this.channels = requireNonNull(channels, \"channels is null\");\n+            verify(channels.stream().map(channel -> channel.filterId).collect(toSet()).size() == channels.size(),\n+                    \"duplicate dynamic filters are not allowed\");\n+            verify(channels.stream().map(channel -> channel.index).collect(toSet()).size() == channels.size(),\n+                    \"duplicate channel indices are not allowed\");\n+            this.maxFilterPositionsCount = maxFilterPositionsCount;\n+            this.maxFilterSize = maxFilterSize;\n+        }\n+\n+        @Override\n+        public Operator createOperator(DriverContext driverContext)\n+        {\n+            checkState(!closed, \"Factory is already closed\");\n+            return new DynamicFilterSourceOperator(\n+                    driverContext.addOperatorContext(operatorId, planNodeId, DynamicFilterSourceOperator.class.getSimpleName()),\n+                    dynamicPredicateConsumer,\n+                    channels,\n+                    planNodeId,\n+                    maxFilterPositionsCount,\n+                    maxFilterSize);\n+        }\n+\n+        @Override\n+        public void noMoreOperators()\n+        {\n+            checkState(!closed, \"Factory is already closed\");\n+            closed = true;\n+        }\n+\n+        @Override\n+        public OperatorFactory duplicate()\n+        {\n+            throw new UnsupportedOperationException(\"duplicate() is not supported for DynamicFilterSourceOperatorFactory\");\n+        }\n+    }\n+\n+    private final OperatorContext context;\n+    private boolean finished;\n+    private Page current;\n+    private final Consumer<TupleDomain<String>> dynamicPredicateConsumer;\n+    private final int maxFilterPositionsCount;\n+    private final long maxFilterSizeInBytes;\n+\n+    private final List<Channel> channels;", "originalCommit": "6253e8ab153fb7bd2aa69d570a253608d0b9e890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2MzQyOQ==", "url": "https://github.com/prestodb/presto/pull/14961#discussion_r465463429", "bodyText": "verify blockBuilders is not null before the loop", "author": "highker", "createdAt": "2020-08-05T04:22:36Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator;\n+\n+import com.facebook.presto.common.Page;\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.predicate.Domain;\n+import com.facebook.presto.common.predicate.TupleDomain;\n+import com.facebook.presto.common.predicate.ValueSet;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.common.type.TypeUtils;\n+import com.facebook.presto.operator.aggregation.TypedSet;\n+import com.facebook.presto.spi.plan.PlanNodeId;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.units.DataSize;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Verify.verify;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.toSet;\n+\n+/**\n+ * This operator acts as a simple \"pass-through\" pipe, while saving its input pages.\n+ * The collected pages' value are used for creating a run-time filtering constraint (for probe-side table scan in an inner join).\n+ * We support only small build-side pages (which should be the case when using \"broadcast\" join).\n+ */\n+public class DynamicFilterSourceOperator\n+        implements Operator\n+{\n+    private static final int EXPECTED_BLOCK_BUILDER_SIZE = 8;\n+\n+    public static class Channel\n+    {\n+        private final String filterId;\n+        private final Type type;\n+        private final int index;\n+\n+        public Channel(String filterId, Type type, int index)\n+        {\n+            this.filterId = filterId;\n+            this.type = type;\n+            this.index = index;\n+        }\n+    }\n+\n+    public static class DynamicFilterSourceOperatorFactory\n+            implements OperatorFactory\n+    {\n+        private final int operatorId;\n+        private final PlanNodeId planNodeId;\n+        private final Consumer<TupleDomain<String>> dynamicPredicateConsumer;\n+        private final List<Channel> channels;\n+        private final int maxFilterPositionsCount;\n+        private final DataSize maxFilterSize;\n+\n+        private boolean closed;\n+\n+        public DynamicFilterSourceOperatorFactory(\n+                int operatorId,\n+                PlanNodeId planNodeId,\n+                Consumer<TupleDomain<String>> dynamicPredicateConsumer,\n+                List<Channel> channels,\n+                int maxFilterPositionsCount,\n+                DataSize maxFilterSize)\n+        {\n+            this.operatorId = operatorId;\n+            this.planNodeId = requireNonNull(planNodeId, \"planNodeId is null\");\n+            this.dynamicPredicateConsumer = requireNonNull(dynamicPredicateConsumer, \"dynamicPredicateConsumer is null\");\n+            this.channels = requireNonNull(channels, \"channels is null\");\n+            verify(channels.stream().map(channel -> channel.filterId).collect(toSet()).size() == channels.size(),\n+                    \"duplicate dynamic filters are not allowed\");\n+            verify(channels.stream().map(channel -> channel.index).collect(toSet()).size() == channels.size(),\n+                    \"duplicate channel indices are not allowed\");\n+            this.maxFilterPositionsCount = maxFilterPositionsCount;\n+            this.maxFilterSize = maxFilterSize;\n+        }\n+\n+        @Override\n+        public Operator createOperator(DriverContext driverContext)\n+        {\n+            checkState(!closed, \"Factory is already closed\");\n+            return new DynamicFilterSourceOperator(\n+                    driverContext.addOperatorContext(operatorId, planNodeId, DynamicFilterSourceOperator.class.getSimpleName()),\n+                    dynamicPredicateConsumer,\n+                    channels,\n+                    planNodeId,\n+                    maxFilterPositionsCount,\n+                    maxFilterSize);\n+        }\n+\n+        @Override\n+        public void noMoreOperators()\n+        {\n+            checkState(!closed, \"Factory is already closed\");\n+            closed = true;\n+        }\n+\n+        @Override\n+        public OperatorFactory duplicate()\n+        {\n+            throw new UnsupportedOperationException(\"duplicate() is not supported for DynamicFilterSourceOperatorFactory\");\n+        }\n+    }\n+\n+    private final OperatorContext context;\n+    private boolean finished;\n+    private Page current;\n+    private final Consumer<TupleDomain<String>> dynamicPredicateConsumer;\n+    private final int maxFilterPositionsCount;\n+    private final long maxFilterSizeInBytes;\n+\n+    private final List<Channel> channels;\n+\n+    // May be dropped if the predicate becomes too large.\n+    @Nullable\n+    private BlockBuilder[] blockBuilders;\n+    @Nullable\n+    private TypedSet[] valueSets;\n+\n+    private DynamicFilterSourceOperator(\n+            OperatorContext context,\n+            Consumer<TupleDomain<String>> dynamicPredicateConsumer,\n+            List<Channel> channels,\n+            PlanNodeId planNodeId,\n+            int maxFilterPositionsCount,\n+            DataSize maxFilterSize)\n+    {\n+        this.context = requireNonNull(context, \"context is null\");\n+        this.maxFilterPositionsCount = maxFilterPositionsCount;\n+        this.maxFilterSizeInBytes = maxFilterSize.toBytes();\n+\n+        this.dynamicPredicateConsumer = requireNonNull(dynamicPredicateConsumer, \"dynamicPredicateConsumer is null\");\n+        this.channels = requireNonNull(channels, \"channels is null\");\n+\n+        this.blockBuilders = new BlockBuilder[channels.size()];\n+        this.valueSets = new TypedSet[channels.size()];\n+        for (int channelIndex = 0; channelIndex < channels.size(); ++channelIndex) {\n+            Type type = channels.get(channelIndex).type;\n+            this.blockBuilders[channelIndex] = type.createBlockBuilder(null, EXPECTED_BLOCK_BUILDER_SIZE);\n+            this.valueSets[channelIndex] = new TypedSet(\n+                    type,\n+                    blockBuilders[channelIndex],\n+                    EXPECTED_BLOCK_BUILDER_SIZE,\n+                    String.format(\"DynamicFilterSourceOperator_%s_%d\", planNodeId, channelIndex),\n+                    Optional.empty() /* maxBlockMemory */);\n+        }\n+    }\n+\n+    @Override\n+    public OperatorContext getOperatorContext()\n+    {\n+        return context;\n+    }\n+\n+    @Override\n+    public boolean needsInput()\n+    {\n+        return current == null && !finished;\n+    }\n+\n+    @Override\n+    public void addInput(Page page)\n+    {\n+        verify(!finished, \"DynamicFilterSourceOperator: addInput() may not be called after finish()\");\n+        current = page;\n+        if (valueSets == null) {\n+            return;  // the predicate became too large.\n+        }\n+\n+        // TODO: we should account for the memory used for collecting build-side values using MemoryContext\n+        long filterSizeInBytes = 0;\n+        int filterPositionsCount = 0;\n+        // Collect only the columns which are relevant for the JOIN.\n+        for (int channelIndex = 0; channelIndex < channels.size(); ++channelIndex) {\n+            Block block = page.getBlock(channels.get(channelIndex).index);\n+            TypedSet valueSet = valueSets[channelIndex];\n+            for (int position = 0; position < block.getPositionCount(); ++position) {\n+                valueSet.add(block, position);\n+            }\n+            filterSizeInBytes += valueSet.getRetainedSizeInBytes();\n+            filterPositionsCount += valueSet.size();\n+        }\n+        if (filterPositionsCount > maxFilterPositionsCount || filterSizeInBytes > maxFilterSizeInBytes) {\n+            // The whole filter (summed over all columns) contains too much values or exceeds maxFilterSizeInBytes.\n+            handleTooLargePredicate();\n+        }\n+    }\n+\n+    private void handleTooLargePredicate()\n+    {\n+        // The resulting predicate is too large, allow all probe-side values to be read.\n+        dynamicPredicateConsumer.accept(TupleDomain.all());\n+        // Drop references to collected values.\n+        valueSets = null;\n+        blockBuilders = null;\n+    }\n+\n+    @Override\n+    public Page getOutput()\n+    {\n+        Page result = current;\n+        current = null;\n+        return result;\n+    }\n+\n+    @Override\n+    public void finish()\n+    {\n+        if (finished) {\n+            // NOTE: finish() may be called multiple times (see comment at Driver::processInternal).\n+            return;\n+        }\n+        finished = true;\n+        if (valueSets == null) {\n+            return; // the predicate became too large.\n+        }\n+\n+        ImmutableMap.Builder<String, Domain> domainsBuilder = new ImmutableMap.Builder<>();\n+        for (int channelIndex = 0; channelIndex < channels.size(); ++channelIndex) {", "originalCommit": "6253e8ab153fb7bd2aa69d570a253608d0b9e890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2MzQ3NA==", "url": "https://github.com/prestodb/presto/pull/14961#discussion_r465463474", "bodyText": "ImmutableMap.builder()", "author": "highker", "createdAt": "2020-08-05T04:22:49Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator;\n+\n+import com.facebook.presto.common.Page;\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.predicate.Domain;\n+import com.facebook.presto.common.predicate.TupleDomain;\n+import com.facebook.presto.common.predicate.ValueSet;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.common.type.TypeUtils;\n+import com.facebook.presto.operator.aggregation.TypedSet;\n+import com.facebook.presto.spi.plan.PlanNodeId;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.units.DataSize;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Verify.verify;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.toSet;\n+\n+/**\n+ * This operator acts as a simple \"pass-through\" pipe, while saving its input pages.\n+ * The collected pages' value are used for creating a run-time filtering constraint (for probe-side table scan in an inner join).\n+ * We support only small build-side pages (which should be the case when using \"broadcast\" join).\n+ */\n+public class DynamicFilterSourceOperator\n+        implements Operator\n+{\n+    private static final int EXPECTED_BLOCK_BUILDER_SIZE = 8;\n+\n+    public static class Channel\n+    {\n+        private final String filterId;\n+        private final Type type;\n+        private final int index;\n+\n+        public Channel(String filterId, Type type, int index)\n+        {\n+            this.filterId = filterId;\n+            this.type = type;\n+            this.index = index;\n+        }\n+    }\n+\n+    public static class DynamicFilterSourceOperatorFactory\n+            implements OperatorFactory\n+    {\n+        private final int operatorId;\n+        private final PlanNodeId planNodeId;\n+        private final Consumer<TupleDomain<String>> dynamicPredicateConsumer;\n+        private final List<Channel> channels;\n+        private final int maxFilterPositionsCount;\n+        private final DataSize maxFilterSize;\n+\n+        private boolean closed;\n+\n+        public DynamicFilterSourceOperatorFactory(\n+                int operatorId,\n+                PlanNodeId planNodeId,\n+                Consumer<TupleDomain<String>> dynamicPredicateConsumer,\n+                List<Channel> channels,\n+                int maxFilterPositionsCount,\n+                DataSize maxFilterSize)\n+        {\n+            this.operatorId = operatorId;\n+            this.planNodeId = requireNonNull(planNodeId, \"planNodeId is null\");\n+            this.dynamicPredicateConsumer = requireNonNull(dynamicPredicateConsumer, \"dynamicPredicateConsumer is null\");\n+            this.channels = requireNonNull(channels, \"channels is null\");\n+            verify(channels.stream().map(channel -> channel.filterId).collect(toSet()).size() == channels.size(),\n+                    \"duplicate dynamic filters are not allowed\");\n+            verify(channels.stream().map(channel -> channel.index).collect(toSet()).size() == channels.size(),\n+                    \"duplicate channel indices are not allowed\");\n+            this.maxFilterPositionsCount = maxFilterPositionsCount;\n+            this.maxFilterSize = maxFilterSize;\n+        }\n+\n+        @Override\n+        public Operator createOperator(DriverContext driverContext)\n+        {\n+            checkState(!closed, \"Factory is already closed\");\n+            return new DynamicFilterSourceOperator(\n+                    driverContext.addOperatorContext(operatorId, planNodeId, DynamicFilterSourceOperator.class.getSimpleName()),\n+                    dynamicPredicateConsumer,\n+                    channels,\n+                    planNodeId,\n+                    maxFilterPositionsCount,\n+                    maxFilterSize);\n+        }\n+\n+        @Override\n+        public void noMoreOperators()\n+        {\n+            checkState(!closed, \"Factory is already closed\");\n+            closed = true;\n+        }\n+\n+        @Override\n+        public OperatorFactory duplicate()\n+        {\n+            throw new UnsupportedOperationException(\"duplicate() is not supported for DynamicFilterSourceOperatorFactory\");\n+        }\n+    }\n+\n+    private final OperatorContext context;\n+    private boolean finished;\n+    private Page current;\n+    private final Consumer<TupleDomain<String>> dynamicPredicateConsumer;\n+    private final int maxFilterPositionsCount;\n+    private final long maxFilterSizeInBytes;\n+\n+    private final List<Channel> channels;\n+\n+    // May be dropped if the predicate becomes too large.\n+    @Nullable\n+    private BlockBuilder[] blockBuilders;\n+    @Nullable\n+    private TypedSet[] valueSets;\n+\n+    private DynamicFilterSourceOperator(\n+            OperatorContext context,\n+            Consumer<TupleDomain<String>> dynamicPredicateConsumer,\n+            List<Channel> channels,\n+            PlanNodeId planNodeId,\n+            int maxFilterPositionsCount,\n+            DataSize maxFilterSize)\n+    {\n+        this.context = requireNonNull(context, \"context is null\");\n+        this.maxFilterPositionsCount = maxFilterPositionsCount;\n+        this.maxFilterSizeInBytes = maxFilterSize.toBytes();\n+\n+        this.dynamicPredicateConsumer = requireNonNull(dynamicPredicateConsumer, \"dynamicPredicateConsumer is null\");\n+        this.channels = requireNonNull(channels, \"channels is null\");\n+\n+        this.blockBuilders = new BlockBuilder[channels.size()];\n+        this.valueSets = new TypedSet[channels.size()];\n+        for (int channelIndex = 0; channelIndex < channels.size(); ++channelIndex) {\n+            Type type = channels.get(channelIndex).type;\n+            this.blockBuilders[channelIndex] = type.createBlockBuilder(null, EXPECTED_BLOCK_BUILDER_SIZE);\n+            this.valueSets[channelIndex] = new TypedSet(\n+                    type,\n+                    blockBuilders[channelIndex],\n+                    EXPECTED_BLOCK_BUILDER_SIZE,\n+                    String.format(\"DynamicFilterSourceOperator_%s_%d\", planNodeId, channelIndex),\n+                    Optional.empty() /* maxBlockMemory */);\n+        }\n+    }\n+\n+    @Override\n+    public OperatorContext getOperatorContext()\n+    {\n+        return context;\n+    }\n+\n+    @Override\n+    public boolean needsInput()\n+    {\n+        return current == null && !finished;\n+    }\n+\n+    @Override\n+    public void addInput(Page page)\n+    {\n+        verify(!finished, \"DynamicFilterSourceOperator: addInput() may not be called after finish()\");\n+        current = page;\n+        if (valueSets == null) {\n+            return;  // the predicate became too large.\n+        }\n+\n+        // TODO: we should account for the memory used for collecting build-side values using MemoryContext\n+        long filterSizeInBytes = 0;\n+        int filterPositionsCount = 0;\n+        // Collect only the columns which are relevant for the JOIN.\n+        for (int channelIndex = 0; channelIndex < channels.size(); ++channelIndex) {\n+            Block block = page.getBlock(channels.get(channelIndex).index);\n+            TypedSet valueSet = valueSets[channelIndex];\n+            for (int position = 0; position < block.getPositionCount(); ++position) {\n+                valueSet.add(block, position);\n+            }\n+            filterSizeInBytes += valueSet.getRetainedSizeInBytes();\n+            filterPositionsCount += valueSet.size();\n+        }\n+        if (filterPositionsCount > maxFilterPositionsCount || filterSizeInBytes > maxFilterSizeInBytes) {\n+            // The whole filter (summed over all columns) contains too much values or exceeds maxFilterSizeInBytes.\n+            handleTooLargePredicate();\n+        }\n+    }\n+\n+    private void handleTooLargePredicate()\n+    {\n+        // The resulting predicate is too large, allow all probe-side values to be read.\n+        dynamicPredicateConsumer.accept(TupleDomain.all());\n+        // Drop references to collected values.\n+        valueSets = null;\n+        blockBuilders = null;\n+    }\n+\n+    @Override\n+    public Page getOutput()\n+    {\n+        Page result = current;\n+        current = null;\n+        return result;\n+    }\n+\n+    @Override\n+    public void finish()\n+    {\n+        if (finished) {\n+            // NOTE: finish() may be called multiple times (see comment at Driver::processInternal).\n+            return;\n+        }\n+        finished = true;\n+        if (valueSets == null) {\n+            return; // the predicate became too large.\n+        }\n+\n+        ImmutableMap.Builder<String, Domain> domainsBuilder = new ImmutableMap.Builder<>();", "originalCommit": "6253e8ab153fb7bd2aa69d570a253608d0b9e890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2MzY3NA==", "url": "https://github.com/prestodb/presto/pull/14961#discussion_r465463674", "bodyText": "requireNonNull", "author": "highker", "createdAt": "2020-08-05T04:23:41Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator;\n+\n+import com.facebook.presto.common.Page;\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.predicate.Domain;\n+import com.facebook.presto.common.predicate.TupleDomain;\n+import com.facebook.presto.common.predicate.ValueSet;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.common.type.TypeUtils;\n+import com.facebook.presto.operator.aggregation.TypedSet;\n+import com.facebook.presto.spi.plan.PlanNodeId;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.units.DataSize;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Verify.verify;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.toSet;\n+\n+/**\n+ * This operator acts as a simple \"pass-through\" pipe, while saving its input pages.\n+ * The collected pages' value are used for creating a run-time filtering constraint (for probe-side table scan in an inner join).\n+ * We support only small build-side pages (which should be the case when using \"broadcast\" join).\n+ */\n+public class DynamicFilterSourceOperator\n+        implements Operator\n+{\n+    private static final int EXPECTED_BLOCK_BUILDER_SIZE = 8;\n+\n+    public static class Channel\n+    {\n+        private final String filterId;\n+        private final Type type;\n+        private final int index;\n+\n+        public Channel(String filterId, Type type, int index)\n+        {\n+            this.filterId = filterId;\n+            this.type = type;", "originalCommit": "6253e8ab153fb7bd2aa69d570a253608d0b9e890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2Mzc3MQ==", "url": "https://github.com/prestodb/presto/pull/14961#discussion_r465463771", "bodyText": "create getters for these variables. Do not access them directly", "author": "highker", "createdAt": "2020-08-05T04:24:01Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/DynamicFilterSourceOperator.java", "diffHunk": "@@ -0,0 +1,266 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator;\n+\n+import com.facebook.presto.common.Page;\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.block.BlockBuilder;\n+import com.facebook.presto.common.predicate.Domain;\n+import com.facebook.presto.common.predicate.TupleDomain;\n+import com.facebook.presto.common.predicate.ValueSet;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.common.type.TypeUtils;\n+import com.facebook.presto.operator.aggregation.TypedSet;\n+import com.facebook.presto.spi.plan.PlanNodeId;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import io.airlift.units.DataSize;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+import static com.google.common.base.Verify.verify;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.toSet;\n+\n+/**\n+ * This operator acts as a simple \"pass-through\" pipe, while saving its input pages.\n+ * The collected pages' value are used for creating a run-time filtering constraint (for probe-side table scan in an inner join).\n+ * We support only small build-side pages (which should be the case when using \"broadcast\" join).\n+ */\n+public class DynamicFilterSourceOperator\n+        implements Operator\n+{\n+    private static final int EXPECTED_BLOCK_BUILDER_SIZE = 8;\n+\n+    public static class Channel\n+    {\n+        private final String filterId;\n+        private final Type type;\n+        private final int index;", "originalCommit": "6253e8ab153fb7bd2aa69d570a253608d0b9e890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NjI1Ng==", "url": "https://github.com/prestodb/presto/pull/14961#discussion_r465466256", "bodyText": "planNode.getDynamicFilters().entrySet().stream() in one line", "author": "highker", "createdAt": "2020-08-05T04:33:28Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/LocalDynamicFilter.java", "diffHunk": "@@ -0,0 +1,182 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.planner;\n+\n+import com.facebook.presto.common.predicate.Domain;\n+import com.facebook.presto.common.predicate.TupleDomain;\n+import com.facebook.presto.expressions.DynamicFilters.DynamicFilterExtractResult;\n+import com.facebook.presto.expressions.DynamicFilters.DynamicFilterPlaceholder;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.sql.planner.optimizations.PlanNodeSearcher;\n+import com.facebook.presto.sql.planner.plan.JoinNode;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.Multimap;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import com.google.common.util.concurrent.SettableFuture;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Consumer;\n+\n+import static com.facebook.presto.expressions.DynamicFilters.extractDynamicFilters;\n+import static com.google.common.base.MoreObjects.toStringHelper;\n+import static com.google.common.base.Verify.verify;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.stream.Collectors.toMap;\n+\n+public class LocalDynamicFilter\n+{\n+    // Mapping from dynamic filter ID to its probe variables.\n+    private final Multimap<String, VariableReferenceExpression> probeVariables;\n+\n+    // Mapping from dynamic filter ID to its build channel indices.\n+    private final Map<String, Integer> buildChannels;\n+\n+    private final SettableFuture<TupleDomain<VariableReferenceExpression>> resultFuture;\n+\n+    // The resulting predicate for local dynamic filtering.\n+    private TupleDomain<String> result;\n+\n+    // Number of partitions left to be processed.\n+    private int partitionsLeft;\n+\n+    public LocalDynamicFilter(Multimap<String, VariableReferenceExpression> probeVariables, Map<String, Integer> buildChannels, int partitionCount)\n+    {\n+        this.probeVariables = requireNonNull(probeVariables, \"probeVariables is null\");\n+        this.buildChannels = requireNonNull(buildChannels, \"buildChannels is null\");\n+        verify(probeVariables.keySet().equals(buildChannels.keySet()), \"probeVariables and buildChannels must have same keys\");\n+\n+        this.resultFuture = SettableFuture.create();\n+\n+        this.result = TupleDomain.none();\n+        this.partitionsLeft = partitionCount;\n+    }\n+\n+    private synchronized void addPartition(TupleDomain<String> tupleDomain)\n+    {\n+        // Called concurrently by each DynamicFilterSourceOperator instance (when collection is over).\n+        partitionsLeft -= 1;\n+        verify(partitionsLeft >= 0);\n+        // NOTE: may result in a bit more relaxed constraint if there are multiple columns and multiple rows.\n+        // See the comment at TupleDomain::columnWiseUnion() for more details.\n+        result = TupleDomain.columnWiseUnion(result, tupleDomain);\n+        if (partitionsLeft == 0) {\n+            // No more partitions are left to be processed.\n+            verify(resultFuture.set(convertTupleDomain(result)), \"dynamic filter result is provided more than once\");\n+        }\n+    }\n+\n+    private TupleDomain<VariableReferenceExpression> convertTupleDomain(TupleDomain<String> result)\n+    {\n+        if (result.isNone()) {\n+            return TupleDomain.none();\n+        }\n+        // Convert the predicate to use probe variables (instead dynamic filter IDs).\n+        // Note that in case of a probe-side union, a single dynamic filter may match multiple probe variables.\n+        ImmutableMap.Builder<VariableReferenceExpression, Domain> builder = ImmutableMap.builder();\n+        for (Map.Entry<String, Domain> entry : result.getDomains().get().entrySet()) {\n+            Domain domain = entry.getValue();\n+            // Store all matching variables for each build channel index.\n+            for (VariableReferenceExpression probeVariable : probeVariables.get(entry.getKey())) {\n+                builder.put(probeVariable, domain);\n+            }\n+        }\n+        return TupleDomain.withColumnDomains(builder.build());\n+    }\n+\n+    public static Optional<LocalDynamicFilter> create(JoinNode planNode, int partitionCount)\n+    {\n+        Set<String> joinDynamicFilters = planNode.getDynamicFilters().keySet();\n+        List<FilterNode> filterNodes = PlanNodeSearcher\n+                .searchFrom(planNode.getLeft())\n+                .where(LocalDynamicFilter::isFilterAboveTableScan)\n+                .findAll();\n+\n+        // Mapping from probe-side dynamic filters' IDs to their matching probe variables.\n+        ImmutableMultimap.Builder<String, VariableReferenceExpression> probeVariablesBuilder = ImmutableMultimap.builder();\n+        for (FilterNode filterNode : filterNodes) {\n+            DynamicFilterExtractResult extractResult = extractDynamicFilters(filterNode.getPredicate());\n+            for (DynamicFilterPlaceholder placeholder : extractResult.getDynamicConjuncts()) {\n+                if (placeholder.getInput() instanceof VariableReferenceExpression) {\n+                    // Add descriptors that match the local dynamic filter (from the current join node).\n+                    if (joinDynamicFilters.contains(placeholder.getId())) {\n+                        VariableReferenceExpression probeVariable = (VariableReferenceExpression) placeholder.getInput();\n+                        probeVariablesBuilder.put(placeholder.getId(), probeVariable);\n+                    }\n+                }\n+            }\n+        }\n+\n+        Multimap<String, VariableReferenceExpression> probeVariables = probeVariablesBuilder.build();\n+        PlanNode buildNode = planNode.getRight();\n+        Map<String, Integer> buildChannels = planNode", "originalCommit": "6253e8ab153fb7bd2aa69d570a253608d0b9e890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2NjU1NA==", "url": "https://github.com/prestodb/presto/pull/14961#discussion_r465466554", "bodyText": "remove this todo", "author": "highker", "createdAt": "2020-08-05T04:34:45Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/LocalExecutionPlanner.java", "diffHunk": "@@ -1301,8 +1318,11 @@ private PhysicalOperation visitScanFilterAndProject(\n \n             // TODO: Execution must be plugged in here", "originalCommit": "6253e8ab153fb7bd2aa69d570a253608d0b9e890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2Nzc2OQ==", "url": "https://github.com/prestodb/presto/pull/14961#discussion_r465467769", "bodyText": "Make this a constant", "author": "highker", "createdAt": "2020-08-05T04:39:18Z", "path": "presto-main/src/test/java/com/facebook/presto/operator/BenchmarkDynamicFilterSourceOperator.java", "diffHunk": "@@ -0,0 +1,194 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator;\n+\n+import com.facebook.presto.common.Page;\n+import com.facebook.presto.common.PageBuilder;\n+import com.facebook.presto.spi.plan.PlanNodeId;\n+import com.facebook.presto.testing.TestingTaskContext;\n+import com.google.common.collect.ImmutableList;\n+import io.airlift.tpch.LineItem;\n+import io.airlift.tpch.LineItemGenerator;\n+import io.airlift.units.DataSize;\n+import org.openjdk.jmh.annotations.Benchmark;\n+import org.openjdk.jmh.annotations.Fork;\n+import org.openjdk.jmh.annotations.Measurement;\n+import org.openjdk.jmh.annotations.OutputTimeUnit;\n+import org.openjdk.jmh.annotations.Param;\n+import org.openjdk.jmh.annotations.Scope;\n+import org.openjdk.jmh.annotations.Setup;\n+import org.openjdk.jmh.annotations.State;\n+import org.openjdk.jmh.annotations.TearDown;\n+import org.openjdk.jmh.annotations.Warmup;\n+import org.openjdk.jmh.runner.Runner;\n+import org.openjdk.jmh.runner.RunnerException;\n+import org.openjdk.jmh.runner.options.Options;\n+import org.openjdk.jmh.runner.options.OptionsBuilder;\n+import org.openjdk.jmh.runner.options.VerboseMode;\n+import org.testng.annotations.Test;\n+\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.facebook.airlift.concurrent.Threads.daemonThreadsNamed;\n+import static com.facebook.presto.SessionTestUtils.TEST_SESSION;\n+import static com.facebook.presto.SystemSessionProperties.getDynamicFilteringMaxPerDriverRowCount;\n+import static com.facebook.presto.SystemSessionProperties.getDynamicFilteringMaxPerDriverSize;\n+import static com.facebook.presto.common.type.BigintType.BIGINT;\n+import static io.airlift.units.DataSize.Unit.GIGABYTE;\n+import static java.util.concurrent.Executors.newCachedThreadPool;\n+import static java.util.concurrent.Executors.newScheduledThreadPool;\n+import static org.testng.Assert.assertEquals;\n+\n+@State(Scope.Thread)\n+@OutputTimeUnit(TimeUnit.SECONDS)\n+@Fork(3)\n+@Warmup(iterations = 20, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+@Measurement(iterations = 20, time = 500, timeUnit = TimeUnit.MILLISECONDS)\n+public class BenchmarkDynamicFilterSourceOperator\n+{\n+    private static final int TOTAL_POSITIONS = 1_000_000;\n+\n+    @State(Scope.Thread)\n+    public static class BenchmarkContext\n+    {\n+        @Param({\"32\", \"256\", \"1024\"})\n+        private String positionsPerPage = \"32\";", "originalCommit": "6253e8ab153fb7bd2aa69d570a253608d0b9e890", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTUyODA2Mw==", "url": "https://github.com/prestodb/presto/pull/14961#discussion_r465528063", "bodyText": "It will run with different settings (\"32\", \"256\", \"1024\")", "author": "kewang1024", "createdAt": "2020-08-05T07:28:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2Nzc2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2ODAxMA==", "url": "https://github.com/prestodb/presto/pull/14961#discussion_r465468010", "bodyText": "verifyPassThrough", "author": "highker", "createdAt": "2020-08-05T04:40:14Z", "path": "presto-main/src/test/java/com/facebook/presto/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator;\n+\n+import com.facebook.presto.common.Page;\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.predicate.Domain;\n+import com.facebook.presto.common.predicate.TupleDomain;\n+import com.facebook.presto.common.predicate.ValueSet;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.spi.plan.PlanNodeId;\n+import com.facebook.presto.testing.MaterializedResult;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import static com.facebook.airlift.concurrent.Threads.daemonThreadsNamed;\n+import static com.facebook.presto.SequencePageBuilder.createSequencePage;\n+import static com.facebook.presto.SessionTestUtils.TEST_SESSION;\n+import static com.facebook.presto.SystemSessionProperties.getDynamicFilteringMaxPerDriverRowCount;\n+import static com.facebook.presto.SystemSessionProperties.getDynamicFilteringMaxPerDriverSize;\n+import static com.facebook.presto.block.BlockAssertions.createBooleansBlock;\n+import static com.facebook.presto.block.BlockAssertions.createDoublesBlock;\n+import static com.facebook.presto.block.BlockAssertions.createLongRepeatBlock;\n+import static com.facebook.presto.block.BlockAssertions.createLongsBlock;\n+import static com.facebook.presto.block.BlockAssertions.createStringsBlock;\n+import static com.facebook.presto.common.type.BigintType.BIGINT;\n+import static com.facebook.presto.common.type.BooleanType.BOOLEAN;\n+import static com.facebook.presto.common.type.DoubleType.DOUBLE;\n+import static com.facebook.presto.common.type.IntegerType.INTEGER;\n+import static com.facebook.presto.common.type.VarcharType.VARCHAR;\n+import static com.facebook.presto.operator.OperatorAssertion.toMaterializedResult;\n+import static com.facebook.presto.operator.OperatorAssertion.toPages;\n+import static com.facebook.presto.testing.TestingTaskContext.createTaskContext;\n+import static com.facebook.presto.testing.assertions.Assert.assertEquals;\n+import static com.google.common.base.Strings.repeat;\n+import static java.util.concurrent.Executors.newCachedThreadPool;\n+import static java.util.concurrent.Executors.newScheduledThreadPool;\n+import static java.util.stream.Collectors.toList;\n+\n+@Test(singleThreaded = true)\n+public class TestDynamicFilterSourceOperator\n+{\n+    private ExecutorService executor;\n+    private ScheduledExecutorService scheduledExecutor;\n+    private PipelineContext pipelineContext;\n+\n+    private ImmutableList.Builder<TupleDomain<String>> partitions;\n+\n+    @BeforeMethod\n+    public void setUp()\n+    {\n+        executor = newCachedThreadPool(daemonThreadsNamed(\"test-executor-%s\"));\n+        scheduledExecutor = newScheduledThreadPool(2, daemonThreadsNamed(\"test-scheduledExecutor-%s\"));\n+        pipelineContext = createTaskContext(executor, scheduledExecutor, TEST_SESSION)\n+                .addPipelineContext(0, true, true, false);\n+\n+        partitions = ImmutableList.builder();\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void tearDown()\n+    {\n+        executor.shutdownNow();\n+        scheduledExecutor.shutdownNow();\n+    }\n+\n+    private void verifyPassthrough(Operator operator, List<Type> types, Page... pages)", "originalCommit": "6253e8ab153fb7bd2aa69d570a253608d0b9e890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2ODEwMw==", "url": "https://github.com/prestodb/presto/pull/14961#discussion_r465468103", "bodyText": "operator1, operator2", "author": "highker", "createdAt": "2020-08-05T04:40:37Z", "path": "presto-main/src/test/java/com/facebook/presto/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator;\n+\n+import com.facebook.presto.common.Page;\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.predicate.Domain;\n+import com.facebook.presto.common.predicate.TupleDomain;\n+import com.facebook.presto.common.predicate.ValueSet;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.spi.plan.PlanNodeId;\n+import com.facebook.presto.testing.MaterializedResult;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import static com.facebook.airlift.concurrent.Threads.daemonThreadsNamed;\n+import static com.facebook.presto.SequencePageBuilder.createSequencePage;\n+import static com.facebook.presto.SessionTestUtils.TEST_SESSION;\n+import static com.facebook.presto.SystemSessionProperties.getDynamicFilteringMaxPerDriverRowCount;\n+import static com.facebook.presto.SystemSessionProperties.getDynamicFilteringMaxPerDriverSize;\n+import static com.facebook.presto.block.BlockAssertions.createBooleansBlock;\n+import static com.facebook.presto.block.BlockAssertions.createDoublesBlock;\n+import static com.facebook.presto.block.BlockAssertions.createLongRepeatBlock;\n+import static com.facebook.presto.block.BlockAssertions.createLongsBlock;\n+import static com.facebook.presto.block.BlockAssertions.createStringsBlock;\n+import static com.facebook.presto.common.type.BigintType.BIGINT;\n+import static com.facebook.presto.common.type.BooleanType.BOOLEAN;\n+import static com.facebook.presto.common.type.DoubleType.DOUBLE;\n+import static com.facebook.presto.common.type.IntegerType.INTEGER;\n+import static com.facebook.presto.common.type.VarcharType.VARCHAR;\n+import static com.facebook.presto.operator.OperatorAssertion.toMaterializedResult;\n+import static com.facebook.presto.operator.OperatorAssertion.toPages;\n+import static com.facebook.presto.testing.TestingTaskContext.createTaskContext;\n+import static com.facebook.presto.testing.assertions.Assert.assertEquals;\n+import static com.google.common.base.Strings.repeat;\n+import static java.util.concurrent.Executors.newCachedThreadPool;\n+import static java.util.concurrent.Executors.newScheduledThreadPool;\n+import static java.util.stream.Collectors.toList;\n+\n+@Test(singleThreaded = true)\n+public class TestDynamicFilterSourceOperator\n+{\n+    private ExecutorService executor;\n+    private ScheduledExecutorService scheduledExecutor;\n+    private PipelineContext pipelineContext;\n+\n+    private ImmutableList.Builder<TupleDomain<String>> partitions;\n+\n+    @BeforeMethod\n+    public void setUp()\n+    {\n+        executor = newCachedThreadPool(daemonThreadsNamed(\"test-executor-%s\"));\n+        scheduledExecutor = newScheduledThreadPool(2, daemonThreadsNamed(\"test-scheduledExecutor-%s\"));\n+        pipelineContext = createTaskContext(executor, scheduledExecutor, TEST_SESSION)\n+                .addPipelineContext(0, true, true, false);\n+\n+        partitions = ImmutableList.builder();\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void tearDown()\n+    {\n+        executor.shutdownNow();\n+        scheduledExecutor.shutdownNow();\n+    }\n+\n+    private void verifyPassthrough(Operator operator, List<Type> types, Page... pages)\n+    {\n+        List<Page> inputPages = ImmutableList.copyOf(pages);\n+        List<Page> outputPages = toPages(operator, inputPages.iterator());\n+        MaterializedResult actual = toMaterializedResult(pipelineContext.getSession(), types, outputPages);\n+        MaterializedResult expected = toMaterializedResult(pipelineContext.getSession(), types, inputPages);\n+        assertEquals(actual, expected);\n+    }\n+\n+    private OperatorFactory createOperatorFactory(DynamicFilterSourceOperator.Channel... buildChannels)\n+    {\n+        return new DynamicFilterSourceOperator.DynamicFilterSourceOperatorFactory(\n+                0,\n+                new PlanNodeId(\"PLAN_NODE_ID\"),\n+                this::consumePredicate,\n+                Arrays.stream(buildChannels).collect(toList()),\n+                getDynamicFilteringMaxPerDriverRowCount(TEST_SESSION),\n+                getDynamicFilteringMaxPerDriverSize(TEST_SESSION));\n+    }\n+\n+    private void consumePredicate(TupleDomain<String> partitionPredicate)\n+    {\n+        partitions.add(partitionPredicate);\n+    }\n+\n+    private Operator createOperator(OperatorFactory operatorFactory)\n+    {\n+        return operatorFactory.createOperator(pipelineContext.addDriverContext());\n+    }\n+\n+    private static DynamicFilterSourceOperator.Channel channel(int index, Type type)\n+    {\n+        return new DynamicFilterSourceOperator.Channel(Integer.toString(index), type, index);\n+    }\n+\n+    @Test\n+    public void testCollectMultipleOperators()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT));\n+\n+        Operator op1 = createOperator(operatorFactory); // will finish before noMoreOperators()\n+        verifyPassthrough(op1,\n+                          ImmutableList.of(BIGINT),\n+                          new Page(createLongsBlock(1, 2)),\n+                          new Page(createLongsBlock(3, 5)));\n+\n+        Operator op2 = createOperator(operatorFactory); // will finish after noMoreOperators()", "originalCommit": "6253e8ab153fb7bd2aa69d570a253608d0b9e890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2ODE4Nw==", "url": "https://github.com/prestodb/presto/pull/14961#discussion_r465468187", "bodyText": "One param per line", "author": "highker", "createdAt": "2020-08-05T04:40:53Z", "path": "presto-main/src/test/java/com/facebook/presto/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator;\n+\n+import com.facebook.presto.common.Page;\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.predicate.Domain;\n+import com.facebook.presto.common.predicate.TupleDomain;\n+import com.facebook.presto.common.predicate.ValueSet;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.spi.plan.PlanNodeId;\n+import com.facebook.presto.testing.MaterializedResult;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import static com.facebook.airlift.concurrent.Threads.daemonThreadsNamed;\n+import static com.facebook.presto.SequencePageBuilder.createSequencePage;\n+import static com.facebook.presto.SessionTestUtils.TEST_SESSION;\n+import static com.facebook.presto.SystemSessionProperties.getDynamicFilteringMaxPerDriverRowCount;\n+import static com.facebook.presto.SystemSessionProperties.getDynamicFilteringMaxPerDriverSize;\n+import static com.facebook.presto.block.BlockAssertions.createBooleansBlock;\n+import static com.facebook.presto.block.BlockAssertions.createDoublesBlock;\n+import static com.facebook.presto.block.BlockAssertions.createLongRepeatBlock;\n+import static com.facebook.presto.block.BlockAssertions.createLongsBlock;\n+import static com.facebook.presto.block.BlockAssertions.createStringsBlock;\n+import static com.facebook.presto.common.type.BigintType.BIGINT;\n+import static com.facebook.presto.common.type.BooleanType.BOOLEAN;\n+import static com.facebook.presto.common.type.DoubleType.DOUBLE;\n+import static com.facebook.presto.common.type.IntegerType.INTEGER;\n+import static com.facebook.presto.common.type.VarcharType.VARCHAR;\n+import static com.facebook.presto.operator.OperatorAssertion.toMaterializedResult;\n+import static com.facebook.presto.operator.OperatorAssertion.toPages;\n+import static com.facebook.presto.testing.TestingTaskContext.createTaskContext;\n+import static com.facebook.presto.testing.assertions.Assert.assertEquals;\n+import static com.google.common.base.Strings.repeat;\n+import static java.util.concurrent.Executors.newCachedThreadPool;\n+import static java.util.concurrent.Executors.newScheduledThreadPool;\n+import static java.util.stream.Collectors.toList;\n+\n+@Test(singleThreaded = true)\n+public class TestDynamicFilterSourceOperator\n+{\n+    private ExecutorService executor;\n+    private ScheduledExecutorService scheduledExecutor;\n+    private PipelineContext pipelineContext;\n+\n+    private ImmutableList.Builder<TupleDomain<String>> partitions;\n+\n+    @BeforeMethod\n+    public void setUp()\n+    {\n+        executor = newCachedThreadPool(daemonThreadsNamed(\"test-executor-%s\"));\n+        scheduledExecutor = newScheduledThreadPool(2, daemonThreadsNamed(\"test-scheduledExecutor-%s\"));\n+        pipelineContext = createTaskContext(executor, scheduledExecutor, TEST_SESSION)\n+                .addPipelineContext(0, true, true, false);\n+\n+        partitions = ImmutableList.builder();\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void tearDown()\n+    {\n+        executor.shutdownNow();\n+        scheduledExecutor.shutdownNow();\n+    }\n+\n+    private void verifyPassthrough(Operator operator, List<Type> types, Page... pages)\n+    {\n+        List<Page> inputPages = ImmutableList.copyOf(pages);\n+        List<Page> outputPages = toPages(operator, inputPages.iterator());\n+        MaterializedResult actual = toMaterializedResult(pipelineContext.getSession(), types, outputPages);\n+        MaterializedResult expected = toMaterializedResult(pipelineContext.getSession(), types, inputPages);\n+        assertEquals(actual, expected);\n+    }\n+\n+    private OperatorFactory createOperatorFactory(DynamicFilterSourceOperator.Channel... buildChannels)\n+    {\n+        return new DynamicFilterSourceOperator.DynamicFilterSourceOperatorFactory(\n+                0,\n+                new PlanNodeId(\"PLAN_NODE_ID\"),\n+                this::consumePredicate,\n+                Arrays.stream(buildChannels).collect(toList()),\n+                getDynamicFilteringMaxPerDriverRowCount(TEST_SESSION),\n+                getDynamicFilteringMaxPerDriverSize(TEST_SESSION));\n+    }\n+\n+    private void consumePredicate(TupleDomain<String> partitionPredicate)\n+    {\n+        partitions.add(partitionPredicate);\n+    }\n+\n+    private Operator createOperator(OperatorFactory operatorFactory)\n+    {\n+        return operatorFactory.createOperator(pipelineContext.addDriverContext());\n+    }\n+\n+    private static DynamicFilterSourceOperator.Channel channel(int index, Type type)\n+    {\n+        return new DynamicFilterSourceOperator.Channel(Integer.toString(index), type, index);\n+    }\n+\n+    @Test\n+    public void testCollectMultipleOperators()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT));\n+\n+        Operator op1 = createOperator(operatorFactory); // will finish before noMoreOperators()\n+        verifyPassthrough(op1,\n+                          ImmutableList.of(BIGINT),\n+                          new Page(createLongsBlock(1, 2)),\n+                          new Page(createLongsBlock(3, 5)));\n+\n+        Operator op2 = createOperator(operatorFactory); // will finish after noMoreOperators()\n+        operatorFactory.noMoreOperators();\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L, 5L))))));\n+\n+        verifyPassthrough(op2,\n+                          ImmutableList.of(BIGINT),\n+                          new Page(createLongsBlock(2, 3)),\n+                          new Page(createLongsBlock(1, 4)));", "originalCommit": "6253e8ab153fb7bd2aa69d570a253608d0b9e890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2ODI0Mg==", "url": "https://github.com/prestodb/presto/pull/14961#discussion_r465468242", "bodyText": "same and all other places in this class", "author": "highker", "createdAt": "2020-08-05T04:41:07Z", "path": "presto-main/src/test/java/com/facebook/presto/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator;\n+\n+import com.facebook.presto.common.Page;\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.predicate.Domain;\n+import com.facebook.presto.common.predicate.TupleDomain;\n+import com.facebook.presto.common.predicate.ValueSet;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.spi.plan.PlanNodeId;\n+import com.facebook.presto.testing.MaterializedResult;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import static com.facebook.airlift.concurrent.Threads.daemonThreadsNamed;\n+import static com.facebook.presto.SequencePageBuilder.createSequencePage;\n+import static com.facebook.presto.SessionTestUtils.TEST_SESSION;\n+import static com.facebook.presto.SystemSessionProperties.getDynamicFilteringMaxPerDriverRowCount;\n+import static com.facebook.presto.SystemSessionProperties.getDynamicFilteringMaxPerDriverSize;\n+import static com.facebook.presto.block.BlockAssertions.createBooleansBlock;\n+import static com.facebook.presto.block.BlockAssertions.createDoublesBlock;\n+import static com.facebook.presto.block.BlockAssertions.createLongRepeatBlock;\n+import static com.facebook.presto.block.BlockAssertions.createLongsBlock;\n+import static com.facebook.presto.block.BlockAssertions.createStringsBlock;\n+import static com.facebook.presto.common.type.BigintType.BIGINT;\n+import static com.facebook.presto.common.type.BooleanType.BOOLEAN;\n+import static com.facebook.presto.common.type.DoubleType.DOUBLE;\n+import static com.facebook.presto.common.type.IntegerType.INTEGER;\n+import static com.facebook.presto.common.type.VarcharType.VARCHAR;\n+import static com.facebook.presto.operator.OperatorAssertion.toMaterializedResult;\n+import static com.facebook.presto.operator.OperatorAssertion.toPages;\n+import static com.facebook.presto.testing.TestingTaskContext.createTaskContext;\n+import static com.facebook.presto.testing.assertions.Assert.assertEquals;\n+import static com.google.common.base.Strings.repeat;\n+import static java.util.concurrent.Executors.newCachedThreadPool;\n+import static java.util.concurrent.Executors.newScheduledThreadPool;\n+import static java.util.stream.Collectors.toList;\n+\n+@Test(singleThreaded = true)\n+public class TestDynamicFilterSourceOperator\n+{\n+    private ExecutorService executor;\n+    private ScheduledExecutorService scheduledExecutor;\n+    private PipelineContext pipelineContext;\n+\n+    private ImmutableList.Builder<TupleDomain<String>> partitions;\n+\n+    @BeforeMethod\n+    public void setUp()\n+    {\n+        executor = newCachedThreadPool(daemonThreadsNamed(\"test-executor-%s\"));\n+        scheduledExecutor = newScheduledThreadPool(2, daemonThreadsNamed(\"test-scheduledExecutor-%s\"));\n+        pipelineContext = createTaskContext(executor, scheduledExecutor, TEST_SESSION)\n+                .addPipelineContext(0, true, true, false);\n+\n+        partitions = ImmutableList.builder();\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void tearDown()\n+    {\n+        executor.shutdownNow();\n+        scheduledExecutor.shutdownNow();\n+    }\n+\n+    private void verifyPassthrough(Operator operator, List<Type> types, Page... pages)\n+    {\n+        List<Page> inputPages = ImmutableList.copyOf(pages);\n+        List<Page> outputPages = toPages(operator, inputPages.iterator());\n+        MaterializedResult actual = toMaterializedResult(pipelineContext.getSession(), types, outputPages);\n+        MaterializedResult expected = toMaterializedResult(pipelineContext.getSession(), types, inputPages);\n+        assertEquals(actual, expected);\n+    }\n+\n+    private OperatorFactory createOperatorFactory(DynamicFilterSourceOperator.Channel... buildChannels)\n+    {\n+        return new DynamicFilterSourceOperator.DynamicFilterSourceOperatorFactory(\n+                0,\n+                new PlanNodeId(\"PLAN_NODE_ID\"),\n+                this::consumePredicate,\n+                Arrays.stream(buildChannels).collect(toList()),\n+                getDynamicFilteringMaxPerDriverRowCount(TEST_SESSION),\n+                getDynamicFilteringMaxPerDriverSize(TEST_SESSION));\n+    }\n+\n+    private void consumePredicate(TupleDomain<String> partitionPredicate)\n+    {\n+        partitions.add(partitionPredicate);\n+    }\n+\n+    private Operator createOperator(OperatorFactory operatorFactory)\n+    {\n+        return operatorFactory.createOperator(pipelineContext.addDriverContext());\n+    }\n+\n+    private static DynamicFilterSourceOperator.Channel channel(int index, Type type)\n+    {\n+        return new DynamicFilterSourceOperator.Channel(Integer.toString(index), type, index);\n+    }\n+\n+    @Test\n+    public void testCollectMultipleOperators()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT));\n+\n+        Operator op1 = createOperator(operatorFactory); // will finish before noMoreOperators()\n+        verifyPassthrough(op1,\n+                          ImmutableList.of(BIGINT),\n+                          new Page(createLongsBlock(1, 2)),\n+                          new Page(createLongsBlock(3, 5)));\n+\n+        Operator op2 = createOperator(operatorFactory); // will finish after noMoreOperators()\n+        operatorFactory.noMoreOperators();\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L, 5L))))));\n+\n+        verifyPassthrough(op2,\n+                          ImmutableList.of(BIGINT),\n+                          new Page(createLongsBlock(2, 3)),\n+                          new Page(createLongsBlock(1, 4)));\n+\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L, 5L)))),\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L, 4L))))));", "originalCommit": "6253e8ab153fb7bd2aa69d570a253608d0b9e890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2ODUxNA==", "url": "https://github.com/prestodb/presto/pull/14961#discussion_r465468514", "bodyText": "move this to the previous line", "author": "highker", "createdAt": "2020-08-05T04:42:13Z", "path": "presto-main/src/test/java/com/facebook/presto/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator;\n+\n+import com.facebook.presto.common.Page;\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.predicate.Domain;\n+import com.facebook.presto.common.predicate.TupleDomain;\n+import com.facebook.presto.common.predicate.ValueSet;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.spi.plan.PlanNodeId;\n+import com.facebook.presto.testing.MaterializedResult;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import static com.facebook.airlift.concurrent.Threads.daemonThreadsNamed;\n+import static com.facebook.presto.SequencePageBuilder.createSequencePage;\n+import static com.facebook.presto.SessionTestUtils.TEST_SESSION;\n+import static com.facebook.presto.SystemSessionProperties.getDynamicFilteringMaxPerDriverRowCount;\n+import static com.facebook.presto.SystemSessionProperties.getDynamicFilteringMaxPerDriverSize;\n+import static com.facebook.presto.block.BlockAssertions.createBooleansBlock;\n+import static com.facebook.presto.block.BlockAssertions.createDoublesBlock;\n+import static com.facebook.presto.block.BlockAssertions.createLongRepeatBlock;\n+import static com.facebook.presto.block.BlockAssertions.createLongsBlock;\n+import static com.facebook.presto.block.BlockAssertions.createStringsBlock;\n+import static com.facebook.presto.common.type.BigintType.BIGINT;\n+import static com.facebook.presto.common.type.BooleanType.BOOLEAN;\n+import static com.facebook.presto.common.type.DoubleType.DOUBLE;\n+import static com.facebook.presto.common.type.IntegerType.INTEGER;\n+import static com.facebook.presto.common.type.VarcharType.VARCHAR;\n+import static com.facebook.presto.operator.OperatorAssertion.toMaterializedResult;\n+import static com.facebook.presto.operator.OperatorAssertion.toPages;\n+import static com.facebook.presto.testing.TestingTaskContext.createTaskContext;\n+import static com.facebook.presto.testing.assertions.Assert.assertEquals;\n+import static com.google.common.base.Strings.repeat;\n+import static java.util.concurrent.Executors.newCachedThreadPool;\n+import static java.util.concurrent.Executors.newScheduledThreadPool;\n+import static java.util.stream.Collectors.toList;\n+\n+@Test(singleThreaded = true)\n+public class TestDynamicFilterSourceOperator\n+{\n+    private ExecutorService executor;\n+    private ScheduledExecutorService scheduledExecutor;\n+    private PipelineContext pipelineContext;\n+\n+    private ImmutableList.Builder<TupleDomain<String>> partitions;\n+\n+    @BeforeMethod\n+    public void setUp()\n+    {\n+        executor = newCachedThreadPool(daemonThreadsNamed(\"test-executor-%s\"));\n+        scheduledExecutor = newScheduledThreadPool(2, daemonThreadsNamed(\"test-scheduledExecutor-%s\"));\n+        pipelineContext = createTaskContext(executor, scheduledExecutor, TEST_SESSION)\n+                .addPipelineContext(0, true, true, false);\n+\n+        partitions = ImmutableList.builder();\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void tearDown()\n+    {\n+        executor.shutdownNow();\n+        scheduledExecutor.shutdownNow();\n+    }\n+\n+    private void verifyPassthrough(Operator operator, List<Type> types, Page... pages)\n+    {\n+        List<Page> inputPages = ImmutableList.copyOf(pages);\n+        List<Page> outputPages = toPages(operator, inputPages.iterator());\n+        MaterializedResult actual = toMaterializedResult(pipelineContext.getSession(), types, outputPages);\n+        MaterializedResult expected = toMaterializedResult(pipelineContext.getSession(), types, inputPages);\n+        assertEquals(actual, expected);\n+    }\n+\n+    private OperatorFactory createOperatorFactory(DynamicFilterSourceOperator.Channel... buildChannels)\n+    {\n+        return new DynamicFilterSourceOperator.DynamicFilterSourceOperatorFactory(\n+                0,\n+                new PlanNodeId(\"PLAN_NODE_ID\"),\n+                this::consumePredicate,\n+                Arrays.stream(buildChannels).collect(toList()),\n+                getDynamicFilteringMaxPerDriverRowCount(TEST_SESSION),\n+                getDynamicFilteringMaxPerDriverSize(TEST_SESSION));\n+    }\n+\n+    private void consumePredicate(TupleDomain<String> partitionPredicate)\n+    {\n+        partitions.add(partitionPredicate);\n+    }\n+\n+    private Operator createOperator(OperatorFactory operatorFactory)\n+    {\n+        return operatorFactory.createOperator(pipelineContext.addDriverContext());\n+    }\n+\n+    private static DynamicFilterSourceOperator.Channel channel(int index, Type type)\n+    {\n+        return new DynamicFilterSourceOperator.Channel(Integer.toString(index), type, index);\n+    }\n+\n+    @Test\n+    public void testCollectMultipleOperators()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT));\n+\n+        Operator op1 = createOperator(operatorFactory); // will finish before noMoreOperators()\n+        verifyPassthrough(op1,\n+                          ImmutableList.of(BIGINT),\n+                          new Page(createLongsBlock(1, 2)),\n+                          new Page(createLongsBlock(3, 5)));\n+\n+        Operator op2 = createOperator(operatorFactory); // will finish after noMoreOperators()\n+        operatorFactory.noMoreOperators();\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L, 5L))))));\n+\n+        verifyPassthrough(op2,\n+                          ImmutableList.of(BIGINT),\n+                          new Page(createLongsBlock(2, 3)),\n+                          new Page(createLongsBlock(1, 4)));\n+\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L, 5L)))),\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L, 4L))))));\n+    }\n+\n+    @Test\n+    public void testCollectMultipleColumns()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BOOLEAN), channel(1, DOUBLE));\n+        verifyPassthrough(createOperator(operatorFactory),\n+                          ImmutableList.of(BOOLEAN, DOUBLE),\n+                          new Page(createBooleansBlock(true, 2), createDoublesBlock(1.5, 3.0)),\n+                          new Page(createBooleansBlock(false, 1), createDoublesBlock(4.5)));\n+        operatorFactory.noMoreOperators();\n+\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.multipleValues(BOOLEAN, ImmutableList.of(true, false)),\n+                        \"1\", Domain.multipleValues(DOUBLE, ImmutableList.of(1.5, 3.0, 4.5))))));\n+    }\n+\n+    @Test\n+    public void testCollectOnlyFirstColumn()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BOOLEAN));\n+        verifyPassthrough(createOperator(operatorFactory),\n+                          ImmutableList.of(BOOLEAN, DOUBLE),\n+                          new Page(createBooleansBlock(true, 2), createDoublesBlock(1.5, 3.0)),\n+                          new Page(createBooleansBlock(false, 1), createDoublesBlock(4.5)));\n+        operatorFactory.noMoreOperators();\n+\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.multipleValues(BOOLEAN, ImmutableList.of(true, false))))));\n+    }\n+\n+    @Test\n+    public void testCollectOnlyLastColumn()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(1, DOUBLE));\n+        verifyPassthrough(createOperator(operatorFactory),\n+                          ImmutableList.of(BOOLEAN, DOUBLE),\n+                          new Page(createBooleansBlock(true, 2), createDoublesBlock(1.5, 3.0)),\n+                          new Page(createBooleansBlock(false, 1), createDoublesBlock(4.5)));\n+        operatorFactory.noMoreOperators();\n+\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"1\", Domain.multipleValues(DOUBLE, ImmutableList.of(1.5, 3.0, 4.5))))));\n+    }\n+\n+    @Test\n+    public void testCollectWithNulls()\n+    {\n+        Block blockWithNulls = INTEGER\n+                .createFixedSizeBlockBuilder(0)", "originalCommit": "6253e8ab153fb7bd2aa69d570a253608d0b9e890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2ODU2Nw==", "url": "https://github.com/prestodb/presto/pull/14961#discussion_r465468567", "bodyText": "remove final", "author": "highker", "createdAt": "2020-08-05T04:42:22Z", "path": "presto-main/src/test/java/com/facebook/presto/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator;\n+\n+import com.facebook.presto.common.Page;\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.predicate.Domain;\n+import com.facebook.presto.common.predicate.TupleDomain;\n+import com.facebook.presto.common.predicate.ValueSet;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.spi.plan.PlanNodeId;\n+import com.facebook.presto.testing.MaterializedResult;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import static com.facebook.airlift.concurrent.Threads.daemonThreadsNamed;\n+import static com.facebook.presto.SequencePageBuilder.createSequencePage;\n+import static com.facebook.presto.SessionTestUtils.TEST_SESSION;\n+import static com.facebook.presto.SystemSessionProperties.getDynamicFilteringMaxPerDriverRowCount;\n+import static com.facebook.presto.SystemSessionProperties.getDynamicFilteringMaxPerDriverSize;\n+import static com.facebook.presto.block.BlockAssertions.createBooleansBlock;\n+import static com.facebook.presto.block.BlockAssertions.createDoublesBlock;\n+import static com.facebook.presto.block.BlockAssertions.createLongRepeatBlock;\n+import static com.facebook.presto.block.BlockAssertions.createLongsBlock;\n+import static com.facebook.presto.block.BlockAssertions.createStringsBlock;\n+import static com.facebook.presto.common.type.BigintType.BIGINT;\n+import static com.facebook.presto.common.type.BooleanType.BOOLEAN;\n+import static com.facebook.presto.common.type.DoubleType.DOUBLE;\n+import static com.facebook.presto.common.type.IntegerType.INTEGER;\n+import static com.facebook.presto.common.type.VarcharType.VARCHAR;\n+import static com.facebook.presto.operator.OperatorAssertion.toMaterializedResult;\n+import static com.facebook.presto.operator.OperatorAssertion.toPages;\n+import static com.facebook.presto.testing.TestingTaskContext.createTaskContext;\n+import static com.facebook.presto.testing.assertions.Assert.assertEquals;\n+import static com.google.common.base.Strings.repeat;\n+import static java.util.concurrent.Executors.newCachedThreadPool;\n+import static java.util.concurrent.Executors.newScheduledThreadPool;\n+import static java.util.stream.Collectors.toList;\n+\n+@Test(singleThreaded = true)\n+public class TestDynamicFilterSourceOperator\n+{\n+    private ExecutorService executor;\n+    private ScheduledExecutorService scheduledExecutor;\n+    private PipelineContext pipelineContext;\n+\n+    private ImmutableList.Builder<TupleDomain<String>> partitions;\n+\n+    @BeforeMethod\n+    public void setUp()\n+    {\n+        executor = newCachedThreadPool(daemonThreadsNamed(\"test-executor-%s\"));\n+        scheduledExecutor = newScheduledThreadPool(2, daemonThreadsNamed(\"test-scheduledExecutor-%s\"));\n+        pipelineContext = createTaskContext(executor, scheduledExecutor, TEST_SESSION)\n+                .addPipelineContext(0, true, true, false);\n+\n+        partitions = ImmutableList.builder();\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void tearDown()\n+    {\n+        executor.shutdownNow();\n+        scheduledExecutor.shutdownNow();\n+    }\n+\n+    private void verifyPassthrough(Operator operator, List<Type> types, Page... pages)\n+    {\n+        List<Page> inputPages = ImmutableList.copyOf(pages);\n+        List<Page> outputPages = toPages(operator, inputPages.iterator());\n+        MaterializedResult actual = toMaterializedResult(pipelineContext.getSession(), types, outputPages);\n+        MaterializedResult expected = toMaterializedResult(pipelineContext.getSession(), types, inputPages);\n+        assertEquals(actual, expected);\n+    }\n+\n+    private OperatorFactory createOperatorFactory(DynamicFilterSourceOperator.Channel... buildChannels)\n+    {\n+        return new DynamicFilterSourceOperator.DynamicFilterSourceOperatorFactory(\n+                0,\n+                new PlanNodeId(\"PLAN_NODE_ID\"),\n+                this::consumePredicate,\n+                Arrays.stream(buildChannels).collect(toList()),\n+                getDynamicFilteringMaxPerDriverRowCount(TEST_SESSION),\n+                getDynamicFilteringMaxPerDriverSize(TEST_SESSION));\n+    }\n+\n+    private void consumePredicate(TupleDomain<String> partitionPredicate)\n+    {\n+        partitions.add(partitionPredicate);\n+    }\n+\n+    private Operator createOperator(OperatorFactory operatorFactory)\n+    {\n+        return operatorFactory.createOperator(pipelineContext.addDriverContext());\n+    }\n+\n+    private static DynamicFilterSourceOperator.Channel channel(int index, Type type)\n+    {\n+        return new DynamicFilterSourceOperator.Channel(Integer.toString(index), type, index);\n+    }\n+\n+    @Test\n+    public void testCollectMultipleOperators()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT));\n+\n+        Operator op1 = createOperator(operatorFactory); // will finish before noMoreOperators()\n+        verifyPassthrough(op1,\n+                          ImmutableList.of(BIGINT),\n+                          new Page(createLongsBlock(1, 2)),\n+                          new Page(createLongsBlock(3, 5)));\n+\n+        Operator op2 = createOperator(operatorFactory); // will finish after noMoreOperators()\n+        operatorFactory.noMoreOperators();\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L, 5L))))));\n+\n+        verifyPassthrough(op2,\n+                          ImmutableList.of(BIGINT),\n+                          new Page(createLongsBlock(2, 3)),\n+                          new Page(createLongsBlock(1, 4)));\n+\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L, 5L)))),\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L, 4L))))));\n+    }\n+\n+    @Test\n+    public void testCollectMultipleColumns()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BOOLEAN), channel(1, DOUBLE));\n+        verifyPassthrough(createOperator(operatorFactory),\n+                          ImmutableList.of(BOOLEAN, DOUBLE),\n+                          new Page(createBooleansBlock(true, 2), createDoublesBlock(1.5, 3.0)),\n+                          new Page(createBooleansBlock(false, 1), createDoublesBlock(4.5)));\n+        operatorFactory.noMoreOperators();\n+\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.multipleValues(BOOLEAN, ImmutableList.of(true, false)),\n+                        \"1\", Domain.multipleValues(DOUBLE, ImmutableList.of(1.5, 3.0, 4.5))))));\n+    }\n+\n+    @Test\n+    public void testCollectOnlyFirstColumn()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BOOLEAN));\n+        verifyPassthrough(createOperator(operatorFactory),\n+                          ImmutableList.of(BOOLEAN, DOUBLE),\n+                          new Page(createBooleansBlock(true, 2), createDoublesBlock(1.5, 3.0)),\n+                          new Page(createBooleansBlock(false, 1), createDoublesBlock(4.5)));\n+        operatorFactory.noMoreOperators();\n+\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.multipleValues(BOOLEAN, ImmutableList.of(true, false))))));\n+    }\n+\n+    @Test\n+    public void testCollectOnlyLastColumn()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(1, DOUBLE));\n+        verifyPassthrough(createOperator(operatorFactory),\n+                          ImmutableList.of(BOOLEAN, DOUBLE),\n+                          new Page(createBooleansBlock(true, 2), createDoublesBlock(1.5, 3.0)),\n+                          new Page(createBooleansBlock(false, 1), createDoublesBlock(4.5)));\n+        operatorFactory.noMoreOperators();\n+\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"1\", Domain.multipleValues(DOUBLE, ImmutableList.of(1.5, 3.0, 4.5))))));\n+    }\n+\n+    @Test\n+    public void testCollectWithNulls()\n+    {\n+        Block blockWithNulls = INTEGER\n+                .createFixedSizeBlockBuilder(0)\n+                .writeInt(3)\n+                .appendNull()\n+                .writeInt(4)\n+                .build();\n+\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, INTEGER));\n+        verifyPassthrough(createOperator(operatorFactory),\n+                          ImmutableList.of(INTEGER),\n+                          new Page(createLongsBlock(1, 2, 3)),\n+                          new Page(blockWithNulls),\n+                          new Page(createLongsBlock(4, 5)));\n+        operatorFactory.noMoreOperators();\n+\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.create(ValueSet.of(INTEGER, 1L, 2L, 3L, 4L, 5L), false)))));\n+    }\n+\n+    @Test\n+    public void testCollectNoFilters()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory();\n+        verifyPassthrough(createOperator(operatorFactory),\n+                          ImmutableList.of(BIGINT),\n+                          new Page(createLongsBlock(1, 2, 3)));\n+        operatorFactory.noMoreOperators();\n+        assertEquals(partitions.build(), ImmutableList.of(TupleDomain.all()));\n+    }\n+\n+    @Test\n+    public void testCollectEmptyBuildSide()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT));\n+        verifyPassthrough(createOperator(operatorFactory),\n+                          ImmutableList.of(BIGINT));\n+        operatorFactory.noMoreOperators();\n+        assertEquals(partitions.build(), ImmutableList.of(TupleDomain.none()));\n+    }\n+\n+    @Test\n+    public void testCollectTooMuchRows()\n+    {\n+        final int maxRowCount = getDynamicFilteringMaxPerDriverRowCount(pipelineContext.getSession());", "originalCommit": "6253e8ab153fb7bd2aa69d570a253608d0b9e890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2ODYwNQ==", "url": "https://github.com/prestodb/presto/pull/14961#discussion_r465468605", "bodyText": "one para per line", "author": "highker", "createdAt": "2020-08-05T04:42:30Z", "path": "presto-main/src/test/java/com/facebook/presto/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator;\n+\n+import com.facebook.presto.common.Page;\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.predicate.Domain;\n+import com.facebook.presto.common.predicate.TupleDomain;\n+import com.facebook.presto.common.predicate.ValueSet;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.spi.plan.PlanNodeId;\n+import com.facebook.presto.testing.MaterializedResult;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import static com.facebook.airlift.concurrent.Threads.daemonThreadsNamed;\n+import static com.facebook.presto.SequencePageBuilder.createSequencePage;\n+import static com.facebook.presto.SessionTestUtils.TEST_SESSION;\n+import static com.facebook.presto.SystemSessionProperties.getDynamicFilteringMaxPerDriverRowCount;\n+import static com.facebook.presto.SystemSessionProperties.getDynamicFilteringMaxPerDriverSize;\n+import static com.facebook.presto.block.BlockAssertions.createBooleansBlock;\n+import static com.facebook.presto.block.BlockAssertions.createDoublesBlock;\n+import static com.facebook.presto.block.BlockAssertions.createLongRepeatBlock;\n+import static com.facebook.presto.block.BlockAssertions.createLongsBlock;\n+import static com.facebook.presto.block.BlockAssertions.createStringsBlock;\n+import static com.facebook.presto.common.type.BigintType.BIGINT;\n+import static com.facebook.presto.common.type.BooleanType.BOOLEAN;\n+import static com.facebook.presto.common.type.DoubleType.DOUBLE;\n+import static com.facebook.presto.common.type.IntegerType.INTEGER;\n+import static com.facebook.presto.common.type.VarcharType.VARCHAR;\n+import static com.facebook.presto.operator.OperatorAssertion.toMaterializedResult;\n+import static com.facebook.presto.operator.OperatorAssertion.toPages;\n+import static com.facebook.presto.testing.TestingTaskContext.createTaskContext;\n+import static com.facebook.presto.testing.assertions.Assert.assertEquals;\n+import static com.google.common.base.Strings.repeat;\n+import static java.util.concurrent.Executors.newCachedThreadPool;\n+import static java.util.concurrent.Executors.newScheduledThreadPool;\n+import static java.util.stream.Collectors.toList;\n+\n+@Test(singleThreaded = true)\n+public class TestDynamicFilterSourceOperator\n+{\n+    private ExecutorService executor;\n+    private ScheduledExecutorService scheduledExecutor;\n+    private PipelineContext pipelineContext;\n+\n+    private ImmutableList.Builder<TupleDomain<String>> partitions;\n+\n+    @BeforeMethod\n+    public void setUp()\n+    {\n+        executor = newCachedThreadPool(daemonThreadsNamed(\"test-executor-%s\"));\n+        scheduledExecutor = newScheduledThreadPool(2, daemonThreadsNamed(\"test-scheduledExecutor-%s\"));\n+        pipelineContext = createTaskContext(executor, scheduledExecutor, TEST_SESSION)\n+                .addPipelineContext(0, true, true, false);\n+\n+        partitions = ImmutableList.builder();\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void tearDown()\n+    {\n+        executor.shutdownNow();\n+        scheduledExecutor.shutdownNow();\n+    }\n+\n+    private void verifyPassthrough(Operator operator, List<Type> types, Page... pages)\n+    {\n+        List<Page> inputPages = ImmutableList.copyOf(pages);\n+        List<Page> outputPages = toPages(operator, inputPages.iterator());\n+        MaterializedResult actual = toMaterializedResult(pipelineContext.getSession(), types, outputPages);\n+        MaterializedResult expected = toMaterializedResult(pipelineContext.getSession(), types, inputPages);\n+        assertEquals(actual, expected);\n+    }\n+\n+    private OperatorFactory createOperatorFactory(DynamicFilterSourceOperator.Channel... buildChannels)\n+    {\n+        return new DynamicFilterSourceOperator.DynamicFilterSourceOperatorFactory(\n+                0,\n+                new PlanNodeId(\"PLAN_NODE_ID\"),\n+                this::consumePredicate,\n+                Arrays.stream(buildChannels).collect(toList()),\n+                getDynamicFilteringMaxPerDriverRowCount(TEST_SESSION),\n+                getDynamicFilteringMaxPerDriverSize(TEST_SESSION));\n+    }\n+\n+    private void consumePredicate(TupleDomain<String> partitionPredicate)\n+    {\n+        partitions.add(partitionPredicate);\n+    }\n+\n+    private Operator createOperator(OperatorFactory operatorFactory)\n+    {\n+        return operatorFactory.createOperator(pipelineContext.addDriverContext());\n+    }\n+\n+    private static DynamicFilterSourceOperator.Channel channel(int index, Type type)\n+    {\n+        return new DynamicFilterSourceOperator.Channel(Integer.toString(index), type, index);\n+    }\n+\n+    @Test\n+    public void testCollectMultipleOperators()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT));\n+\n+        Operator op1 = createOperator(operatorFactory); // will finish before noMoreOperators()\n+        verifyPassthrough(op1,\n+                          ImmutableList.of(BIGINT),\n+                          new Page(createLongsBlock(1, 2)),\n+                          new Page(createLongsBlock(3, 5)));\n+\n+        Operator op2 = createOperator(operatorFactory); // will finish after noMoreOperators()\n+        operatorFactory.noMoreOperators();\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L, 5L))))));\n+\n+        verifyPassthrough(op2,\n+                          ImmutableList.of(BIGINT),\n+                          new Page(createLongsBlock(2, 3)),\n+                          new Page(createLongsBlock(1, 4)));\n+\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L, 5L)))),\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L, 4L))))));\n+    }\n+\n+    @Test\n+    public void testCollectMultipleColumns()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BOOLEAN), channel(1, DOUBLE));\n+        verifyPassthrough(createOperator(operatorFactory),\n+                          ImmutableList.of(BOOLEAN, DOUBLE),\n+                          new Page(createBooleansBlock(true, 2), createDoublesBlock(1.5, 3.0)),\n+                          new Page(createBooleansBlock(false, 1), createDoublesBlock(4.5)));\n+        operatorFactory.noMoreOperators();\n+\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.multipleValues(BOOLEAN, ImmutableList.of(true, false)),\n+                        \"1\", Domain.multipleValues(DOUBLE, ImmutableList.of(1.5, 3.0, 4.5))))));\n+    }\n+\n+    @Test\n+    public void testCollectOnlyFirstColumn()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BOOLEAN));\n+        verifyPassthrough(createOperator(operatorFactory),\n+                          ImmutableList.of(BOOLEAN, DOUBLE),\n+                          new Page(createBooleansBlock(true, 2), createDoublesBlock(1.5, 3.0)),\n+                          new Page(createBooleansBlock(false, 1), createDoublesBlock(4.5)));\n+        operatorFactory.noMoreOperators();\n+\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.multipleValues(BOOLEAN, ImmutableList.of(true, false))))));\n+    }\n+\n+    @Test\n+    public void testCollectOnlyLastColumn()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(1, DOUBLE));\n+        verifyPassthrough(createOperator(operatorFactory),\n+                          ImmutableList.of(BOOLEAN, DOUBLE),\n+                          new Page(createBooleansBlock(true, 2), createDoublesBlock(1.5, 3.0)),\n+                          new Page(createBooleansBlock(false, 1), createDoublesBlock(4.5)));\n+        operatorFactory.noMoreOperators();\n+\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"1\", Domain.multipleValues(DOUBLE, ImmutableList.of(1.5, 3.0, 4.5))))));\n+    }\n+\n+    @Test\n+    public void testCollectWithNulls()\n+    {\n+        Block blockWithNulls = INTEGER\n+                .createFixedSizeBlockBuilder(0)\n+                .writeInt(3)\n+                .appendNull()\n+                .writeInt(4)\n+                .build();\n+\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, INTEGER));\n+        verifyPassthrough(createOperator(operatorFactory),\n+                          ImmutableList.of(INTEGER),\n+                          new Page(createLongsBlock(1, 2, 3)),\n+                          new Page(blockWithNulls),\n+                          new Page(createLongsBlock(4, 5)));\n+        operatorFactory.noMoreOperators();\n+\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.create(ValueSet.of(INTEGER, 1L, 2L, 3L, 4L, 5L), false)))));\n+    }\n+\n+    @Test\n+    public void testCollectNoFilters()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory();\n+        verifyPassthrough(createOperator(operatorFactory),\n+                          ImmutableList.of(BIGINT),\n+                          new Page(createLongsBlock(1, 2, 3)));\n+        operatorFactory.noMoreOperators();\n+        assertEquals(partitions.build(), ImmutableList.of(TupleDomain.all()));\n+    }\n+\n+    @Test\n+    public void testCollectEmptyBuildSide()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT));\n+        verifyPassthrough(createOperator(operatorFactory),\n+                          ImmutableList.of(BIGINT));\n+        operatorFactory.noMoreOperators();\n+        assertEquals(partitions.build(), ImmutableList.of(TupleDomain.none()));\n+    }\n+\n+    @Test\n+    public void testCollectTooMuchRows()\n+    {\n+        final int maxRowCount = getDynamicFilteringMaxPerDriverRowCount(pipelineContext.getSession());\n+        Page largePage = createSequencePage(ImmutableList.of(BIGINT), maxRowCount + 1);\n+\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT));\n+        verifyPassthrough(createOperator(operatorFactory),\n+                          ImmutableList.of(BIGINT),\n+                          largePage);", "originalCommit": "6253e8ab153fb7bd2aa69d570a253608d0b9e890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2ODczNA==", "url": "https://github.com/prestodb/presto/pull/14961#discussion_r465468734", "bodyText": "This class has many conflicts with our coding style. Please verify each of them.", "author": "highker", "createdAt": "2020-08-05T04:43:01Z", "path": "presto-main/src/test/java/com/facebook/presto/operator/TestDynamicFilterSourceOperator.java", "diffHunk": "@@ -0,0 +1,300 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator;\n+\n+import com.facebook.presto.common.Page;\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.predicate.Domain;\n+import com.facebook.presto.common.predicate.TupleDomain;\n+import com.facebook.presto.common.predicate.ValueSet;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.spi.plan.PlanNodeId;\n+import com.facebook.presto.testing.MaterializedResult;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.ScheduledExecutorService;\n+\n+import static com.facebook.airlift.concurrent.Threads.daemonThreadsNamed;\n+import static com.facebook.presto.SequencePageBuilder.createSequencePage;\n+import static com.facebook.presto.SessionTestUtils.TEST_SESSION;\n+import static com.facebook.presto.SystemSessionProperties.getDynamicFilteringMaxPerDriverRowCount;\n+import static com.facebook.presto.SystemSessionProperties.getDynamicFilteringMaxPerDriverSize;\n+import static com.facebook.presto.block.BlockAssertions.createBooleansBlock;\n+import static com.facebook.presto.block.BlockAssertions.createDoublesBlock;\n+import static com.facebook.presto.block.BlockAssertions.createLongRepeatBlock;\n+import static com.facebook.presto.block.BlockAssertions.createLongsBlock;\n+import static com.facebook.presto.block.BlockAssertions.createStringsBlock;\n+import static com.facebook.presto.common.type.BigintType.BIGINT;\n+import static com.facebook.presto.common.type.BooleanType.BOOLEAN;\n+import static com.facebook.presto.common.type.DoubleType.DOUBLE;\n+import static com.facebook.presto.common.type.IntegerType.INTEGER;\n+import static com.facebook.presto.common.type.VarcharType.VARCHAR;\n+import static com.facebook.presto.operator.OperatorAssertion.toMaterializedResult;\n+import static com.facebook.presto.operator.OperatorAssertion.toPages;\n+import static com.facebook.presto.testing.TestingTaskContext.createTaskContext;\n+import static com.facebook.presto.testing.assertions.Assert.assertEquals;\n+import static com.google.common.base.Strings.repeat;\n+import static java.util.concurrent.Executors.newCachedThreadPool;\n+import static java.util.concurrent.Executors.newScheduledThreadPool;\n+import static java.util.stream.Collectors.toList;\n+\n+@Test(singleThreaded = true)\n+public class TestDynamicFilterSourceOperator\n+{\n+    private ExecutorService executor;\n+    private ScheduledExecutorService scheduledExecutor;\n+    private PipelineContext pipelineContext;\n+\n+    private ImmutableList.Builder<TupleDomain<String>> partitions;\n+\n+    @BeforeMethod\n+    public void setUp()\n+    {\n+        executor = newCachedThreadPool(daemonThreadsNamed(\"test-executor-%s\"));\n+        scheduledExecutor = newScheduledThreadPool(2, daemonThreadsNamed(\"test-scheduledExecutor-%s\"));\n+        pipelineContext = createTaskContext(executor, scheduledExecutor, TEST_SESSION)\n+                .addPipelineContext(0, true, true, false);\n+\n+        partitions = ImmutableList.builder();\n+    }\n+\n+    @AfterMethod(alwaysRun = true)\n+    public void tearDown()\n+    {\n+        executor.shutdownNow();\n+        scheduledExecutor.shutdownNow();\n+    }\n+\n+    private void verifyPassthrough(Operator operator, List<Type> types, Page... pages)\n+    {\n+        List<Page> inputPages = ImmutableList.copyOf(pages);\n+        List<Page> outputPages = toPages(operator, inputPages.iterator());\n+        MaterializedResult actual = toMaterializedResult(pipelineContext.getSession(), types, outputPages);\n+        MaterializedResult expected = toMaterializedResult(pipelineContext.getSession(), types, inputPages);\n+        assertEquals(actual, expected);\n+    }\n+\n+    private OperatorFactory createOperatorFactory(DynamicFilterSourceOperator.Channel... buildChannels)\n+    {\n+        return new DynamicFilterSourceOperator.DynamicFilterSourceOperatorFactory(\n+                0,\n+                new PlanNodeId(\"PLAN_NODE_ID\"),\n+                this::consumePredicate,\n+                Arrays.stream(buildChannels).collect(toList()),\n+                getDynamicFilteringMaxPerDriverRowCount(TEST_SESSION),\n+                getDynamicFilteringMaxPerDriverSize(TEST_SESSION));\n+    }\n+\n+    private void consumePredicate(TupleDomain<String> partitionPredicate)\n+    {\n+        partitions.add(partitionPredicate);\n+    }\n+\n+    private Operator createOperator(OperatorFactory operatorFactory)\n+    {\n+        return operatorFactory.createOperator(pipelineContext.addDriverContext());\n+    }\n+\n+    private static DynamicFilterSourceOperator.Channel channel(int index, Type type)\n+    {\n+        return new DynamicFilterSourceOperator.Channel(Integer.toString(index), type, index);\n+    }\n+\n+    @Test\n+    public void testCollectMultipleOperators()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT));\n+\n+        Operator op1 = createOperator(operatorFactory); // will finish before noMoreOperators()\n+        verifyPassthrough(op1,\n+                          ImmutableList.of(BIGINT),\n+                          new Page(createLongsBlock(1, 2)),\n+                          new Page(createLongsBlock(3, 5)));\n+\n+        Operator op2 = createOperator(operatorFactory); // will finish after noMoreOperators()\n+        operatorFactory.noMoreOperators();\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L, 5L))))));\n+\n+        verifyPassthrough(op2,\n+                          ImmutableList.of(BIGINT),\n+                          new Page(createLongsBlock(2, 3)),\n+                          new Page(createLongsBlock(1, 4)));\n+\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L, 5L)))),\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.multipleValues(BIGINT, ImmutableList.of(1L, 2L, 3L, 4L))))));\n+    }\n+\n+    @Test\n+    public void testCollectMultipleColumns()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BOOLEAN), channel(1, DOUBLE));\n+        verifyPassthrough(createOperator(operatorFactory),\n+                          ImmutableList.of(BOOLEAN, DOUBLE),\n+                          new Page(createBooleansBlock(true, 2), createDoublesBlock(1.5, 3.0)),\n+                          new Page(createBooleansBlock(false, 1), createDoublesBlock(4.5)));\n+        operatorFactory.noMoreOperators();\n+\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.multipleValues(BOOLEAN, ImmutableList.of(true, false)),\n+                        \"1\", Domain.multipleValues(DOUBLE, ImmutableList.of(1.5, 3.0, 4.5))))));\n+    }\n+\n+    @Test\n+    public void testCollectOnlyFirstColumn()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BOOLEAN));\n+        verifyPassthrough(createOperator(operatorFactory),\n+                          ImmutableList.of(BOOLEAN, DOUBLE),\n+                          new Page(createBooleansBlock(true, 2), createDoublesBlock(1.5, 3.0)),\n+                          new Page(createBooleansBlock(false, 1), createDoublesBlock(4.5)));\n+        operatorFactory.noMoreOperators();\n+\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.multipleValues(BOOLEAN, ImmutableList.of(true, false))))));\n+    }\n+\n+    @Test\n+    public void testCollectOnlyLastColumn()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(1, DOUBLE));\n+        verifyPassthrough(createOperator(operatorFactory),\n+                          ImmutableList.of(BOOLEAN, DOUBLE),\n+                          new Page(createBooleansBlock(true, 2), createDoublesBlock(1.5, 3.0)),\n+                          new Page(createBooleansBlock(false, 1), createDoublesBlock(4.5)));\n+        operatorFactory.noMoreOperators();\n+\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"1\", Domain.multipleValues(DOUBLE, ImmutableList.of(1.5, 3.0, 4.5))))));\n+    }\n+\n+    @Test\n+    public void testCollectWithNulls()\n+    {\n+        Block blockWithNulls = INTEGER\n+                .createFixedSizeBlockBuilder(0)\n+                .writeInt(3)\n+                .appendNull()\n+                .writeInt(4)\n+                .build();\n+\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, INTEGER));\n+        verifyPassthrough(createOperator(operatorFactory),\n+                          ImmutableList.of(INTEGER),\n+                          new Page(createLongsBlock(1, 2, 3)),\n+                          new Page(blockWithNulls),\n+                          new Page(createLongsBlock(4, 5)));\n+        operatorFactory.noMoreOperators();\n+\n+        assertEquals(partitions.build(), ImmutableList.of(\n+                TupleDomain.withColumnDomains(ImmutableMap.of(\n+                        \"0\", Domain.create(ValueSet.of(INTEGER, 1L, 2L, 3L, 4L, 5L), false)))));\n+    }\n+\n+    @Test\n+    public void testCollectNoFilters()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory();\n+        verifyPassthrough(createOperator(operatorFactory),\n+                          ImmutableList.of(BIGINT),\n+                          new Page(createLongsBlock(1, 2, 3)));\n+        operatorFactory.noMoreOperators();\n+        assertEquals(partitions.build(), ImmutableList.of(TupleDomain.all()));\n+    }\n+\n+    @Test\n+    public void testCollectEmptyBuildSide()\n+    {\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT));\n+        verifyPassthrough(createOperator(operatorFactory),\n+                          ImmutableList.of(BIGINT));\n+        operatorFactory.noMoreOperators();\n+        assertEquals(partitions.build(), ImmutableList.of(TupleDomain.none()));\n+    }\n+\n+    @Test\n+    public void testCollectTooMuchRows()\n+    {\n+        final int maxRowCount = getDynamicFilteringMaxPerDriverRowCount(pipelineContext.getSession());\n+        Page largePage = createSequencePage(ImmutableList.of(BIGINT), maxRowCount + 1);\n+\n+        OperatorFactory operatorFactory = createOperatorFactory(channel(0, BIGINT));\n+        verifyPassthrough(createOperator(operatorFactory),\n+                          ImmutableList.of(BIGINT),\n+                          largePage);\n+        operatorFactory.noMoreOperators();\n+        assertEquals(partitions.build(), ImmutableList.of(TupleDomain.all()));\n+    }\n+\n+    @Test\n+    public void testCollectTooMuchBytesSingleColumn()\n+    {\n+        final long maxByteSize = getDynamicFilteringMaxPerDriverSize(pipelineContext.getSession()).toBytes();", "originalCommit": "6253e8ab153fb7bd2aa69d570a253608d0b9e890", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ2OTk0NQ==", "url": "https://github.com/prestodb/presto/pull/14961#discussion_r465469945", "bodyText": "merge into one line", "author": "highker", "createdAt": "2020-08-05T04:47:30Z", "path": "presto-main/src/test/java/com/facebook/presto/sql/planner/TestLocalDynamicFilter.java", "diffHunk": "@@ -0,0 +1,310 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.facebook.presto.sql.planner;\n+\n+import com.facebook.presto.Session;\n+import com.facebook.presto.common.predicate.Domain;\n+import com.facebook.presto.common.predicate.TupleDomain;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.sql.planner.assertions.BasePlanTest;\n+import com.facebook.presto.sql.planner.optimizations.PlanNodeSearcher;\n+import com.facebook.presto.sql.planner.plan.JoinNode;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableMultimap;\n+import com.google.common.collect.Iterables;\n+import com.google.common.util.concurrent.ListenableFuture;\n+import org.testng.annotations.Test;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutionException;\n+import java.util.function.Consumer;\n+\n+import static com.facebook.presto.SystemSessionProperties.ENABLE_DYNAMIC_FILTERING;\n+import static com.facebook.presto.SystemSessionProperties.FORCE_SINGLE_NODE_OUTPUT;\n+import static com.facebook.presto.SystemSessionProperties.JOIN_DISTRIBUTION_TYPE;\n+import static com.facebook.presto.common.type.BigintType.BIGINT;\n+import static com.facebook.presto.common.type.IntegerType.INTEGER;\n+import static com.facebook.presto.testing.assertions.Assert.assertEquals;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static org.testng.Assert.assertFalse;\n+\n+public class TestLocalDynamicFilter\n+        extends BasePlanTest\n+{\n+    public TestLocalDynamicFilter()\n+    {\n+        super(ImmutableMap.of(\n+                FORCE_SINGLE_NODE_OUTPUT, \"false\",\n+                JOIN_DISTRIBUTION_TYPE, \"BROADCAST\",\n+                ENABLE_DYNAMIC_FILTERING, \"true\"));\n+    }\n+\n+    @Test\n+    public void testSimple()\n+            throws ExecutionException, InterruptedException\n+    {\n+        LocalDynamicFilter filter = new LocalDynamicFilter(\n+                ImmutableMultimap.of(\"123\", new VariableReferenceExpression(\"a\", INTEGER)),\n+                ImmutableMap.of(\"123\", 0),\n+                1);\n+        assertEquals(filter.getBuildChannels(), ImmutableMap.of(\"123\", 0));\n+        Consumer<TupleDomain<String>> consumer = filter.getTupleDomainConsumer();\n+        ListenableFuture<TupleDomain<VariableReferenceExpression>> result = filter.getResultFuture();\n+        assertFalse(result.isDone());\n+\n+        consumer.accept(TupleDomain.withColumnDomains(ImmutableMap.of(\n+                \"123\", Domain.singleValue(INTEGER, 7L))));\n+        assertEquals(\n+                result.get(),\n+                TupleDomain.withColumnDomains(\n+                        ImmutableMap.of(new VariableReferenceExpression(\"a\", INTEGER), Domain.singleValue(INTEGER, 7L))));\n+    }\n+\n+    @Test\n+    public void testMultipleProbeVariables()\n+            throws ExecutionException, InterruptedException\n+    {\n+        LocalDynamicFilter filter = new LocalDynamicFilter(\n+                ImmutableMultimap.of(\"123\", new VariableReferenceExpression(\"a1\", INTEGER), \"123\", new VariableReferenceExpression(\"a2\", INTEGER)),\n+                ImmutableMap.of(\"123\", 0),\n+                1);\n+        assertEquals(filter.getBuildChannels(), ImmutableMap.of(\"123\", 0));\n+        Consumer<TupleDomain<String>> consumer = filter.getTupleDomainConsumer();\n+        ListenableFuture<TupleDomain<VariableReferenceExpression>> result = filter.getResultFuture();\n+        assertFalse(result.isDone());\n+\n+        consumer.accept(TupleDomain.withColumnDomains(ImmutableMap.of(\n+                \"123\", Domain.singleValue(INTEGER, 7L))));\n+        assertEquals(result.get(), TupleDomain.withColumnDomains(ImmutableMap.of(\n+                new VariableReferenceExpression(\"a1\", INTEGER), Domain.singleValue(INTEGER, 7L),\n+                new VariableReferenceExpression(\"a2\", INTEGER), Domain.singleValue(INTEGER, 7L))));\n+    }\n+\n+    @Test\n+    public void testMultiplePartitions()\n+            throws ExecutionException, InterruptedException\n+    {\n+        LocalDynamicFilter filter = new LocalDynamicFilter(\n+                ImmutableMultimap.of(\"123\", new VariableReferenceExpression(\"a\", INTEGER)),\n+                ImmutableMap.of(\"123\", 0),\n+                2);\n+        assertEquals(filter.getBuildChannels(), ImmutableMap.of(\"123\", 0));\n+        Consumer<TupleDomain<String>> consumer = filter.getTupleDomainConsumer();\n+        ListenableFuture<TupleDomain<VariableReferenceExpression>> result = filter.getResultFuture();\n+\n+        assertFalse(result.isDone());\n+        consumer.accept(TupleDomain.withColumnDomains(ImmutableMap.of(\n+                \"123\", Domain.singleValue(INTEGER, 10L))));\n+\n+        assertFalse(result.isDone());\n+        consumer.accept(TupleDomain.withColumnDomains(ImmutableMap.of(\n+                \"123\", Domain.singleValue(INTEGER, 20L))));\n+\n+        assertEquals(result.get(), TupleDomain.withColumnDomains(ImmutableMap.of(\n+                new VariableReferenceExpression(\"a\", INTEGER), Domain.multipleValues(INTEGER, ImmutableList.of(10L, 20L)))));\n+    }\n+\n+    @Test\n+    public void testNone()\n+            throws ExecutionException, InterruptedException\n+    {\n+        LocalDynamicFilter filter = new LocalDynamicFilter(\n+                ImmutableMultimap.of(\"123\", new VariableReferenceExpression(\"a\", INTEGER)),\n+                ImmutableMap.of(\"123\", 0),\n+                1);\n+        assertEquals(filter.getBuildChannels(), ImmutableMap.of(\"123\", 0));\n+        Consumer<TupleDomain<String>> consumer = filter.getTupleDomainConsumer();\n+        ListenableFuture<TupleDomain<VariableReferenceExpression>> result = filter.getResultFuture();\n+\n+        assertFalse(result.isDone());\n+        consumer.accept(TupleDomain.withColumnDomains(ImmutableMap.of(\n+                \"123\", Domain.none(INTEGER))));\n+\n+        assertEquals(result.get(), TupleDomain.withColumnDomains(ImmutableMap.of(\n+                new VariableReferenceExpression(\"a\", INTEGER), Domain.none(INTEGER))));\n+    }\n+\n+    @Test\n+    public void testMultipleColumns()\n+            throws ExecutionException, InterruptedException\n+    {\n+        LocalDynamicFilter filter = new LocalDynamicFilter(\n+                ImmutableMultimap.of(\"123\", new VariableReferenceExpression(\"a\", INTEGER), \"456\", new VariableReferenceExpression(\"b\", INTEGER)),\n+                ImmutableMap.of(\"123\", 0, \"456\", 1),\n+                1);\n+        assertEquals(filter.getBuildChannels(), ImmutableMap.of(\"123\", 0, \"456\", 1));\n+        Consumer<TupleDomain<String>> consumer = filter.getTupleDomainConsumer();\n+        ListenableFuture<TupleDomain<VariableReferenceExpression>> result = filter.getResultFuture();\n+        assertFalse(result.isDone());\n+\n+        consumer.accept(TupleDomain.withColumnDomains(ImmutableMap.of(\n+                \"123\", Domain.singleValue(INTEGER, 10L),\n+                \"456\", Domain.singleValue(INTEGER, 20L))));\n+        assertEquals(result.get(), TupleDomain.withColumnDomains(ImmutableMap.of(\n+                new VariableReferenceExpression(\"a\", INTEGER), Domain.singleValue(INTEGER, 10L),\n+                new VariableReferenceExpression(\"b\", INTEGER), Domain.singleValue(INTEGER, 20L))));\n+    }\n+\n+    @Test\n+    public void testMultiplePartitionsAndColumns()\n+            throws ExecutionException, InterruptedException\n+    {\n+        LocalDynamicFilter filter = new LocalDynamicFilter(\n+                ImmutableMultimap.of(\"123\", new VariableReferenceExpression(\"a\", INTEGER), \"456\", new VariableReferenceExpression(\"b\", BIGINT)),\n+                ImmutableMap.of(\"123\", 0, \"456\", 1),\n+                2);\n+        assertEquals(filter.getBuildChannels(), ImmutableMap.of(\"123\", 0, \"456\", 1));\n+        Consumer<TupleDomain<String>> consumer = filter.getTupleDomainConsumer();\n+        ListenableFuture<TupleDomain<VariableReferenceExpression>> result = filter.getResultFuture();\n+\n+        assertFalse(result.isDone());\n+        consumer.accept(TupleDomain.withColumnDomains(ImmutableMap.of(\n+                \"123\", Domain.singleValue(INTEGER, 10L),\n+                \"456\", Domain.singleValue(BIGINT, 100L))));\n+\n+        assertFalse(result.isDone());\n+        consumer.accept(TupleDomain.withColumnDomains(ImmutableMap.of(\n+                \"123\", Domain.singleValue(INTEGER, 20L),\n+                \"456\", Domain.singleValue(BIGINT, 200L))));\n+\n+        assertEquals(result.get(), TupleDomain.withColumnDomains(ImmutableMap.of(\n+                new VariableReferenceExpression(\"a\", INTEGER), Domain.multipleValues(INTEGER, ImmutableList.of(10L, 20L)),\n+                new VariableReferenceExpression(\"b\", BIGINT), Domain.multipleValues(BIGINT, ImmutableList.of(100L, 200L)))));\n+    }\n+\n+    @Test\n+    public void testCreateSingleColumn()\n+            throws ExecutionException, InterruptedException\n+    {\n+        SubPlan subplan = subplan(\n+                \"SELECT count() FROM lineitem, orders WHERE lineitem.orderkey = orders.orderkey \" +\n+                        \"AND orders.custkey < 10\",\n+                LogicalPlanner.Stage.OPTIMIZED_AND_VALIDATED,\n+                false);\n+        JoinNode joinNode = searchJoins(subplan.getChildren().get(0).getFragment()).findOnlyElement();\n+        LocalDynamicFilter filter = LocalDynamicFilter.create(joinNode, 1).orElseThrow(NoSuchElementException::new);\n+        String filterId = Iterables.getOnlyElement(filter.getBuildChannels().keySet());\n+        VariableReferenceExpression probeVariable = Iterables.getOnlyElement(joinNode.getCriteria()).getLeft();\n+\n+        filter.getTupleDomainConsumer().accept(TupleDomain.withColumnDomains(ImmutableMap.of(\n+                filterId, Domain.singleValue(BIGINT, 3L))));\n+        assertEquals(filter.getResultFuture().get(), TupleDomain.withColumnDomains(ImmutableMap.of(\n+                probeVariable, Domain.singleValue(BIGINT, 3L))));\n+    }\n+\n+    @Test\n+    public void testCreateDistributedJoin()\n+    {\n+        Session session = Session.builder(getQueryRunner().getDefaultSession())\n+                .setSystemProperty(JOIN_DISTRIBUTION_TYPE, \"PARTITIONED\")\n+                .build();\n+        SubPlan subplan = subplan(\n+                \"SELECT count() FROM nation, region WHERE nation.regionkey = region.regionkey \" +\n+                        \"AND region.comment = 'abc'\",", "originalCommit": "23d6ba73deeb217b84312504adfa2c237bdf264b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2NTQ3MDE4MA==", "url": "https://github.com/prestodb/presto/pull/14961#discussion_r465470180", "bodyText": "\"variable\"", "author": "highker", "createdAt": "2020-08-05T04:48:24Z", "path": "presto-main/src/test/java/com/facebook/presto/sql/planner/TestLocalDynamicFiltersCollector.java", "diffHunk": "@@ -0,0 +1,54 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.facebook.presto.sql.planner;\n+\n+import com.facebook.presto.common.predicate.Domain;\n+import com.facebook.presto.common.predicate.TupleDomain;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import org.testng.annotations.Test;\n+\n+import static com.facebook.presto.common.type.BigintType.BIGINT;\n+import static com.facebook.presto.testing.assertions.Assert.assertEquals;\n+\n+public class TestLocalDynamicFiltersCollector\n+{\n+    @Test\n+    public void testCollector()\n+    {\n+        VariableReferenceExpression variable = new VariableReferenceExpression(\"symbol\", BIGINT);", "originalCommit": "23d6ba73deeb217b84312504adfa2c237bdf264b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "23d6ba73deeb217b84312504adfa2c237bdf264b", "url": "https://github.com/prestodb/presto/commit/23d6ba73deeb217b84312504adfa2c237bdf264b", "message": "Add unit-tests for LocalDynamicFilter and LocalDynamicFilterCollector\n\nCherry-pick of https://github.com/prestosql/presto/pull/1702/commits/a458d9a582159ae82a430cfc00e88bc4c71babe1\n\nCo-Authored-By: James Sun <jamessun@fb.com>\nCo-Authored-By: Roman Zeyde <zeyde@varada.io>", "committedDate": "2020-08-05T01:02:20Z", "type": "forcePushed"}, {"oid": "876254284a12685eeedfa68fba48449f9f6fbd5f", "url": "https://github.com/prestodb/presto/commit/876254284a12685eeedfa68fba48449f9f6fbd5f", "message": "Allow creating unlimited TypedSet\n\nExisting constructors limit collected values to 4MB.\n\nCo-Authored-By: James Sun <jamessun@fb.com>\nCo-Authored-By: Roman Zeyde <zeyde@varada.io>", "committedDate": "2020-08-05T07:05:54Z", "type": "commit"}, {"oid": "0e293b9afb38ffe4717ea4ae705b39784b87a114", "url": "https://github.com/prestodb/presto/commit/0e293b9afb38ffe4717ea4ae705b39784b87a114", "message": "Implement local dynamic filtering for broadcast inner-joins\n\nWhen a broadcast inner-join is used, probe-side table scan and hash build\noperators are running in the same process - so the dynamic filter can be\nextracted and applied locally, without involving the coordinator.\n\nThe connector may optimize the probe-side scan significantly by applying\nthe dynamic filter during page source creation using run-time predicate pushdown.\n\nCo-Authored-By: James Sun <jamessun@fb.com>\nCo-Authored-By: Roman Zeyde <zeyde@varada.io>", "committedDate": "2020-08-05T07:17:49Z", "type": "commit"}, {"oid": "2fd1ca23a523c52d2629bc05555e7a5b7e5e1ce3", "url": "https://github.com/prestodb/presto/commit/2fd1ca23a523c52d2629bc05555e7a5b7e5e1ce3", "message": "Short circuit page source when dynamic filter is none and Clean up LocalDynamicFiltersCollector\n\nCherry-pick of https://github.com/prestosql/presto/commit/a9cad2dda67a07588bc1cbf43901546bd4974f2d\nCherry-pick of https://github.com/prestosql/presto/commit/cde503c22fd3c4579988303d17fe0939efec20f2\n\nCo-Authored-By: James Sun <jamessun@fb.com>\nCo-Authored-By: Dain Sundstrom <dain@iq80.com>", "committedDate": "2020-08-05T07:22:17Z", "type": "commit"}, {"oid": "270b358fd19420bdf3ba78140dd9e08a94d3ab4f", "url": "https://github.com/prestodb/presto/commit/270b358fd19420bdf3ba78140dd9e08a94d3ab4f", "message": "Add unit tests for LocalDynamicFilter and LocalDynamicFilterCollector\n\nCherry-pick of https://github.com/prestosql/presto/pull/1702/commits/a458d9a582159ae82a430cfc00e88bc4c71babe1\n\nCo-Authored-By: James Sun <jamessun@fb.com>\nCo-Authored-By: Roman Zeyde <zeyde@varada.io>", "committedDate": "2020-08-05T07:23:06Z", "type": "commit"}, {"oid": "270b358fd19420bdf3ba78140dd9e08a94d3ab4f", "url": "https://github.com/prestodb/presto/commit/270b358fd19420bdf3ba78140dd9e08a94d3ab4f", "message": "Add unit tests for LocalDynamicFilter and LocalDynamicFilterCollector\n\nCherry-pick of https://github.com/prestosql/presto/pull/1702/commits/a458d9a582159ae82a430cfc00e88bc4c71babe1\n\nCo-Authored-By: James Sun <jamessun@fb.com>\nCo-Authored-By: Roman Zeyde <zeyde@varada.io>", "committedDate": "2020-08-05T07:23:06Z", "type": "forcePushed"}]}