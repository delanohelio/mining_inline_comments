{"pr_number": 14728, "pr_title": "Enums support #1: base types and operators", "pr_createdAt": "2020-06-26T01:07:54Z", "pr_url": "https://github.com/prestodb/presto/pull/14728", "timeline": [{"oid": "fc41856743963f584268a49352beb72cbb883ef6", "url": "https://github.com/prestodb/presto/commit/fc41856743963f584268a49352beb72cbb883ef6", "message": "enum tests for row cast and array UDFs", "committedDate": "2020-07-13T19:58:02Z", "type": "forcePushed"}, {"oid": "7115366b16cd445f997a3e957e8dab545157c0c3", "url": "https://github.com/prestodb/presto/commit/7115366b16cd445f997a3e957e8dab545157c0c3", "message": "Enum tests for row cast and array UDFs", "committedDate": "2020-07-13T20:07:21Z", "type": "forcePushed"}, {"oid": "29d596ce6706ef4baf8bd5bb479d37b1b0048696", "url": "https://github.com/prestodb/presto/commit/29d596ce6706ef4baf8bd5bb479d37b1b0048696", "message": "Support enum <> JSON cast", "committedDate": "2020-07-16T02:17:45Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzM3MzQ4MA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r453373480", "bodyText": "We don't normally use null. In general the codebase assumed all objects are not null. If an object could be null, use Optional<T> explicitly.", "author": "rongrong", "createdAt": "2020-07-12T22:57:05Z", "path": "presto-main/src/main/java/com/facebook/presto/type/EnumOperators.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.type;\n+\n+import com.facebook.presto.annotation.UsedByGeneratedCode;\n+import com.facebook.presto.common.function.OperatorType;\n+import com.facebook.presto.common.type.AbstractLongType;\n+import com.facebook.presto.common.type.BigintType;\n+import com.facebook.presto.common.type.BooleanType;\n+import com.facebook.presto.common.type.EnumType;\n+import com.facebook.presto.common.type.IntegerEnumType;\n+import com.facebook.presto.common.type.IntegerType;\n+import com.facebook.presto.common.type.SmallintType;\n+import com.facebook.presto.common.type.StandardTypes;\n+import com.facebook.presto.common.type.StringEnumType;\n+import com.facebook.presto.common.type.TinyintType;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.common.type.TypeSignature;\n+import com.facebook.presto.metadata.PolymorphicScalarFunctionBuilder;\n+import com.facebook.presto.metadata.SignatureBuilder;\n+import com.facebook.presto.metadata.SqlScalarFunction;\n+import com.facebook.presto.operator.scalar.BuiltInScalarFunctionImplementation;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.Signature;\n+import com.facebook.presto.spi.function.SqlFunction;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import io.airlift.slice.XxHash64;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.facebook.presto.common.function.OperatorType.CAST;\n+import static com.facebook.presto.operator.scalar.BuiltInScalarFunctionImplementation.ArgumentProperty.valueTypeArgumentProperty;\n+import static com.facebook.presto.operator.scalar.BuiltInScalarFunctionImplementation.NullConvention.USE_NULL_FLAG;\n+import static com.facebook.presto.spi.StandardErrorCode.INVALID_CAST_ARGUMENT;\n+import static com.facebook.presto.spi.function.FunctionKind.SCALAR;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class EnumOperators\n+{\n+    private static final TypeSignature BOOLEAN_TYPE_SIGNATURE = BooleanType.BOOLEAN.getTypeSignature();\n+\n+    private EnumOperators() {}\n+\n+    private static final Set<TypeSignature> INTEGER_TYPES = Sets.newHashSet(\n+            Stream.of(TinyintType.TINYINT, SmallintType.SMALLINT, IntegerType.INTEGER, BigintType.BIGINT)\n+                    .map(Type::getTypeSignature).collect(Collectors.toSet()));\n+\n+    public static Optional<SqlFunction> makeOperator(OperatorType operatorType, List<Type> argTypes, @Nullable Type returnType)\n+    {\n+        if (!(returnType instanceof EnumType) && argTypes.stream().noneMatch(t -> t instanceof EnumType)) {\n+            return Optional.empty();\n+        }\n+\n+        boolean isInt = !argTypes.isEmpty() && argTypes.get(0) instanceof IntegerEnumType;\n+        List<TypeSignature> argTypeSignatures = argTypes.stream()\n+                .map(Type::getTypeSignature)\n+                .collect(Collectors.toList());\n+\n+        switch (operatorType) {\n+            case CAST:\n+                requireNonNull(returnType);  // return type must be provided for CAST function lookup\n+                if (returnType instanceof EnumType) {\n+                    return makeCastToEnum(argTypes.get(0).getTypeSignature(), (EnumType) returnType);\n+                }\n+                if (argTypes.get(0) instanceof EnumType) {\n+                    return makeCastFromEnum((EnumType) argTypes.get(0), returnType.getTypeSignature());\n+                }\n+                return Optional.empty();\n+            case EQUAL:\n+            case NOT_EQUAL:\n+                if (!(argTypes.get(0) instanceof EnumType) || !argTypes.get(0).equals(argTypes.get(1))) {\n+                    return Optional.empty();\n+                }\n+                return buildFunction(\n+                        operatorType,\n+                        argTypeSignatures,\n+                        BOOLEAN_TYPE_SIGNATURE,\n+                        true,\n+                        isInt ? \"integerEnumCompare\" : \"stringEnumCompare\",\n+                        ImmutableList.of(OperatorType.NOT_EQUAL.equals(operatorType)));\n+            case IS_DISTINCT_FROM:\n+                if (!(argTypes.get(0) instanceof EnumType) || !argTypes.get(0).equals(argTypes.get(1))) {\n+                    return Optional.empty();\n+                }\n+                return buildFunction(\n+                        operatorType,\n+                        argTypeSignatures,\n+                        BOOLEAN_TYPE_SIGNATURE,\n+                        false,\n+                        isInt ? \"integerEnumIsDistinct\" : \"stringEnumIsDistinct\",\n+                        ImmutableList.of(),\n+                        new BuiltInScalarFunctionImplementation.ArgumentProperty[] {\n+                                valueTypeArgumentProperty(USE_NULL_FLAG),\n+                                valueTypeArgumentProperty(USE_NULL_FLAG)\n+                        });\n+            case HASH_CODE:\n+                return buildFunction(\n+                        operatorType,\n+                        argTypeSignatures,\n+                        BigintType.BIGINT.getTypeSignature(),\n+                        false,\n+                        isInt ? \"integerEnumHash\" : \"stringEnumHash\",\n+                        ImmutableList.of());\n+            case XX_HASH_64:\n+                return buildFunction(\n+                        operatorType,\n+                        argTypeSignatures,\n+                        BigintType.BIGINT.getTypeSignature(),\n+                        false,\n+                        isInt ? \"integerEnumXxHash64\" : \"stringEnumHash\",\n+                        ImmutableList.of());\n+            case INDETERMINATE:\n+                return buildFunction(\n+                        operatorType,\n+                        argTypeSignatures,\n+                        BOOLEAN_TYPE_SIGNATURE,\n+                        false,\n+                        isInt ? \"integerEnumIndeterminate\" : \"stringEnumIndeterminate\",\n+                        ImmutableList.of(),\n+                        new BuiltInScalarFunctionImplementation.ArgumentProperty[] {\n+                                valueTypeArgumentProperty(USE_NULL_FLAG)\n+                        });\n+            default:\n+                return Optional.empty();\n+        }\n+    }\n+\n+    private static Optional<SqlFunction> makeCastToEnum(TypeSignature fromType, EnumType toType)\n+    {\n+        if (toType instanceof IntegerEnumType) {\n+            if (INTEGER_TYPES.contains(fromType)) {\n+                return buildCastToEnum(fromType, toType, \"integerEnumValueLookup\");\n+            }\n+            if (StandardTypes.VARCHAR.equals(fromType.getBase())) {\n+                return buildCastToEnum(fromType, toType, \"integerEnumKeyLookup\");\n+            }\n+        }\n+        if (toType instanceof StringEnumType) {\n+            if (StandardTypes.VARCHAR.equals(fromType.getBase())) {\n+                return buildCastToEnum(fromType, toType, \"stringEnumKeyOrValueLookup\");\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private static Optional<SqlFunction> makeCastFromEnum(EnumType fromType, TypeSignature toType)\n+    {\n+        if (fromType instanceof IntegerEnumType) {\n+            if (BigintType.BIGINT.getTypeSignature().equals(toType)) {\n+                return buildCastFromEnum(fromType, toType, \"integerEnumAsPrimitive\");\n+            }\n+        }\n+        if (fromType instanceof StringEnumType) {\n+            if (StandardTypes.VARCHAR.equals(toType.getBase())) {\n+                return buildCastFromEnum(fromType, toType, \"stringEnumAsPrimitive\");\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private static Optional<SqlFunction> buildCastToEnum(TypeSignature fromType, EnumType toType, String methodName)\n+    {\n+        return buildFunction(\n+                CAST,\n+                ImmutableList.of(fromType),\n+                toType.getTypeSignature(),\n+                false,\n+                methodName,\n+                ImmutableList.of(toType));\n+    }\n+\n+    private static Optional<SqlFunction> buildCastFromEnum(EnumType fromType, TypeSignature toType, String methodName)\n+    {\n+        return buildFunction(\n+                CAST,\n+                ImmutableList.of(fromType.getTypeSignature()),\n+                toType,\n+                false,\n+                methodName,\n+                ImmutableList.of());\n+    }\n+\n+    private static Optional<SqlFunction> buildFunction(OperatorType operatorType, List<TypeSignature> argTypes, TypeSignature returnType,\n+            boolean nullableResult, String methodName, List<Object> extraParams)\n+    {\n+        return buildFunction(operatorType, argTypes, returnType, nullableResult, methodName, extraParams, null);", "originalCommit": "761326b12b510d5cbda825a5b9db02295d8c4800", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ4MDEzMg==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r455480132", "bodyText": "Do you really want a bounded varchar type of max length? I think either an unbounded varchar type (UNBOUNDED_LENGTH) or get the max length of all values from enumMap and use varchar(maxValueLength) would make more sense. Also, static import from AbstractVarcharType.", "author": "rongrong", "createdAt": "2020-07-16T02:58:30Z", "path": "presto-common/src/main/java/com/facebook/presto/common/type/VarcharEnumType.java", "diffHunk": "@@ -0,0 +1,42 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.common.type;\n+\n+import java.util.Map;\n+\n+public class VarcharEnumType\n+        extends AbstractVarcharType\n+        implements EnumType<String>\n+{\n+    private final Map<String, String> enumMap;\n+\n+    public VarcharEnumType(String name, Map<String, String> enumMap)\n+    {\n+        super(VarcharType.MAX_LENGTH, TypeSignature.parseTypeSignature(name));", "originalCommit": "6ee1e6ace7a9da12094f056c7a577bdff90fa042", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ4MDI5NA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r455480294", "bodyText": "each parameter on a separate line.\n    super(\n            length,\n            new TypeSignature(...", "author": "rongrong", "createdAt": "2020-07-16T02:59:10Z", "path": "presto-common/src/main/java/com/facebook/presto/common/type/VarcharType.java", "diffHunk": "@@ -49,163 +39,10 @@ public static TypeSignature getParametrizedVarcharSignature(String param)\n         return new TypeSignature(StandardTypes.VARCHAR, TypeSignatureParameter.of(param));\n     }\n \n-    private final int length;\n-\n     private VarcharType(int length)\n     {\n-        super(\n-                new TypeSignature(\n-                        StandardTypes.VARCHAR,\n-                        singletonList(TypeSignatureParameter.of((long) length))),\n-                Slice.class);\n-\n-        if (length < 0) {\n-            throw new IllegalArgumentException(\"Invalid VARCHAR length \" + length);\n-        }\n-        this.length = length;\n-    }\n-\n-    @Deprecated\n-    public int getLength()\n-    {\n-        return length;\n-    }\n-\n-    public int getLengthSafe()\n-    {\n-        if (isUnbounded()) {\n-            throw new IllegalStateException(\"Cannot get size of unbounded VARCHAR.\");\n-        }\n-        return length;\n-    }\n-\n-    public boolean isUnbounded()\n-    {\n-        return length == UNBOUNDED_LENGTH;\n-    }\n-\n-    @Override\n-    public boolean isComparable()\n-    {\n-        return true;\n-    }\n-\n-    @Override\n-    public boolean isOrderable()\n-    {\n-        return true;\n-    }\n-\n-    @Override\n-    public Object getObjectValue(SqlFunctionProperties properties, Block block, int position)\n-    {\n-        if (block.isNull(position)) {\n-            return null;\n-        }\n-\n-        return block.getSlice(position, 0, block.getSliceLength(position)).toStringUtf8();\n-    }\n-\n-    @Override\n-    public boolean equalTo(Block leftBlock, int leftPosition, Block rightBlock, int rightPosition)\n-    {\n-        int leftLength = leftBlock.getSliceLength(leftPosition);\n-        int rightLength = rightBlock.getSliceLength(rightPosition);\n-        if (leftLength != rightLength) {\n-            return false;\n-        }\n-        return leftBlock.equals(leftPosition, 0, rightBlock, rightPosition, 0, leftLength);\n-    }\n-\n-    @Override\n-    public long hash(Block block, int position)\n-    {\n-        return block.hash(position, 0, block.getSliceLength(position));\n-    }\n-\n-    @Override\n-    public int compareTo(Block leftBlock, int leftPosition, Block rightBlock, int rightPosition)\n-    {\n-        int leftLength = leftBlock.getSliceLength(leftPosition);\n-        int rightLength = rightBlock.getSliceLength(rightPosition);\n-        return leftBlock.compareTo(leftPosition, 0, leftLength, rightBlock, rightPosition, 0, rightLength);\n-    }\n-\n-    @Override\n-    public void appendTo(Block block, int position, BlockBuilder blockBuilder)\n-    {\n-        if (block.isNull(position)) {\n-            blockBuilder.appendNull();\n-        }\n-        else {\n-            block.writeBytesTo(position, 0, block.getSliceLength(position), blockBuilder);\n-            blockBuilder.closeEntry();\n-        }\n-    }\n-\n-    @Override\n-    public Slice getSlice(Block block, int position)\n-    {\n-        return block.getSlice(position, 0, block.getSliceLength(position));\n-    }\n-\n-    @Override\n-    public Slice getSliceUnchecked(Block block, int internalPosition)\n-    {\n-        return block.getSliceUnchecked(internalPosition, 0, block.getSliceLengthUnchecked(internalPosition));\n-    }\n-\n-    public void writeString(BlockBuilder blockBuilder, String value)\n-    {\n-        writeSlice(blockBuilder, Slices.utf8Slice(value));\n-    }\n-\n-    @Override\n-    public void writeSlice(BlockBuilder blockBuilder, Slice value)\n-    {\n-        writeSlice(blockBuilder, value, 0, value.length());\n-    }\n-\n-    @Override\n-    public void writeSlice(BlockBuilder blockBuilder, Slice value, int offset, int length)\n-    {\n-        blockBuilder.writeBytes(value, offset, length).closeEntry();\n-    }\n-\n-    @Override\n-    public boolean equals(Object o)\n-    {\n-        if (this == o) {\n-            return true;\n-        }\n-        if (o == null || getClass() != o.getClass()) {\n-            return false;\n-        }\n-\n-        VarcharType other = (VarcharType) o;\n-\n-        return Objects.equals(this.length, other.length);\n-    }\n-\n-    @Override\n-    public int hashCode()\n-    {\n-        return Objects.hash(length);\n-    }\n-\n-    @Override\n-    public String getDisplayName()\n-    {\n-        if (length == UNBOUNDED_LENGTH) {\n-            return getTypeSignature().getBase();\n-        }\n-\n-        return getTypeSignature().toString();\n-    }\n-\n-    @Override\n-    public String toString()\n-    {\n-        return getDisplayName();\n+        super(length, new TypeSignature(", "originalCommit": "6ee1e6ace7a9da12094f056c7a577bdff90fa042", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ4MDg2Mw==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r455480863", "bodyText": "remove this.", "author": "rongrong", "createdAt": "2020-07-16T03:01:08Z", "path": "presto-main/src/main/java/com/facebook/presto/metadata/BuiltInFunctionNamespaceManager.java", "diffHunk": "@@ -901,6 +904,7 @@ private SpecializedFunctionKey doGetSpecializedFunctionKey(Signature signature)\n         Iterable<SqlFunction> candidates = getFunctions(null, signature.getName());\n         // search for exact match\n         Type returnType = typeManager.getType(signature.getReturnType());\n+", "originalCommit": "da9cb046a909bcef151b4f6f76d0e9ab0e32aa2e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ4MjAyNg==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r455482026", "bodyText": "This logic should be in BuiltInFunctionNamespaceManager. FunctionManager should delegate function resolution to the FunctionNamespaceManager managing the specific function namespace. There should be no special handling necessary.", "author": "rongrong", "createdAt": "2020-07-16T03:05:22Z", "path": "presto-main/src/main/java/com/facebook/presto/metadata/FunctionManager.java", "diffHunk": "@@ -306,6 +306,15 @@ private FunctionHandle resolveFunctionInternal(Optional<TransactionId> transacti\n             return new BuiltInFunctionHandle(getMagicLiteralFunctionSignature(type));\n         }\n \n+        Optional<SqlFunction> udtFunction = builtInFunctionNamespaceManager.getUdtFunctionImplementation(", "originalCommit": "da9cb046a909bcef151b4f6f76d0e9ab0e32aa2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3ODI4Ng==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r458478286", "bodyText": "went for a different approach using type constraints so I can have static function signatures here", "author": "daniel-ohayon", "createdAt": "2020-07-22T01:20:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ4MjAyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ4MjI5MQ==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r455482291", "bodyText": "I don't like special cases. It doesn't feel necessary. For database people, this behavior would be very unexpected. Either support orderable, or not. I think both are reasonable. The result of enum'A' > enum'B' might not make sense but that's ok I think.", "author": "rongrong", "createdAt": "2020-07-16T03:06:26Z", "path": "presto-main/src/main/java/com/facebook/presto/metadata/MetadataManager.java", "diffHunk": "@@ -236,7 +237,9 @@ public final void verifyComparableOrderableContract()\n                     missingOperators.put(type, NOT_EQUAL);\n                 }\n             }\n-            if (type.isOrderable()) {\n+            if (type.isOrderable() && !(type instanceof EnumType)) {", "originalCommit": "da9cb046a909bcef151b4f6f76d0e9ab0e32aa2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3NzgzOQ==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r458477839", "bodyText": "I implemented full comparison eventually", "author": "daniel-ohayon", "createdAt": "2020-07-22T01:18:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ4MjI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ4MzcwNw==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r455483707", "bodyText": "First of all, what is udt? I guess it's \"user defined type\". But the abbreviation is not obvious at all. So do not use it. Also FunctionImplementation has special meanings. If you search in this class, function implementation for builtin function means a java method handle. This is not a function implementation. This logic should be wrapped in BuiltinFunctionNamespaceManager.getFunctions. That way the function resolution for enum operators work the same way as function resolution works for all other functions. Just put the logic there, you don't need a function for this (thus avoid the naming issues).", "author": "rongrong", "createdAt": "2020-07-16T03:12:00Z", "path": "presto-main/src/main/java/com/facebook/presto/metadata/BuiltInFunctionNamespaceManager.java", "diffHunk": "@@ -962,9 +966,31 @@ private SpecializedFunctionKey doGetSpecializedFunctionKey(Signature signature)\n                     1);\n         }\n \n+        Optional<SqlFunction> udtFunction = getUdtFunctionImplementation(signature.getName(), signature.getArgumentTypes(), returnType);\n+        if (udtFunction.isPresent()) {\n+            return new SpecializedFunctionKey(udtFunction.get(), BoundVariables.builder().build(), argumentTypes.size());\n+        }\n+\n         throw new PrestoException(FUNCTION_IMPLEMENTATION_MISSING, format(\"%s not found\", signature));\n     }\n \n+    Optional<SqlFunction> getUdtFunctionImplementation(QualifiedFunctionName functionName, List<TypeSignature> argTypes, @Nullable Type returnType)", "originalCommit": "da9cb046a909bcef151b4f6f76d0e9ab0e32aa2e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODQ3Nzk5Mw==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r458477993", "bodyText": "going for a different approach where I can have static function signatures with a type constraint instead.", "author": "daniel-ohayon", "createdAt": "2020-07-22T01:19:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ4MzcwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ4NTAzMQ==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r455485031", "bodyText": "We normally use static import, so static import TINYINT, SMALLINT, etc.", "author": "rongrong", "createdAt": "2020-07-16T03:16:55Z", "path": "presto-main/src/main/java/com/facebook/presto/type/EnumOperators.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.type;\n+\n+import com.facebook.presto.annotation.UsedByGeneratedCode;\n+import com.facebook.presto.common.function.OperatorType;\n+import com.facebook.presto.common.type.AbstractLongType;\n+import com.facebook.presto.common.type.BigintType;\n+import com.facebook.presto.common.type.BooleanType;\n+import com.facebook.presto.common.type.EnumType;\n+import com.facebook.presto.common.type.LongEnumType;\n+import com.facebook.presto.common.type.IntegerType;\n+import com.facebook.presto.common.type.SmallintType;\n+import com.facebook.presto.common.type.StandardTypes;\n+import com.facebook.presto.common.type.VarcharEnumType;\n+import com.facebook.presto.common.type.TinyintType;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.common.type.TypeSignature;\n+import com.facebook.presto.metadata.PolymorphicScalarFunctionBuilder;\n+import com.facebook.presto.metadata.SignatureBuilder;\n+import com.facebook.presto.metadata.SqlScalarFunction;\n+import com.facebook.presto.operator.scalar.BuiltInScalarFunctionImplementation;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.Signature;\n+import com.facebook.presto.spi.function.SqlFunction;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import io.airlift.slice.XxHash64;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.facebook.presto.common.function.OperatorType.CAST;\n+import static com.facebook.presto.operator.scalar.BuiltInScalarFunctionImplementation.ArgumentProperty.valueTypeArgumentProperty;\n+import static com.facebook.presto.operator.scalar.BuiltInScalarFunctionImplementation.NullConvention.USE_NULL_FLAG;\n+import static com.facebook.presto.spi.StandardErrorCode.INVALID_CAST_ARGUMENT;\n+import static com.facebook.presto.spi.function.FunctionKind.SCALAR;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class EnumOperators\n+{\n+    private static final TypeSignature BOOLEAN_TYPE_SIGNATURE = BooleanType.BOOLEAN.getTypeSignature();\n+\n+    private EnumOperators() {}\n+\n+    private static final Set<TypeSignature> INTEGER_TYPES = Sets.newHashSet(\n+            Stream.of(TinyintType.TINYINT, SmallintType.SMALLINT, IntegerType.INTEGER, BigintType.BIGINT)", "originalCommit": "da9cb046a909bcef151b4f6f76d0e9ab0e32aa2e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ4NTM2Mg==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r455485362", "bodyText": "I think you can just do\n... = ImmutableSet.of(\n            TINYINT.getTypeSignature(),\n            SMALLINT.getTypeSignature(),\n            INTEGER.getTypeSignature(),\n            BIGINT.getTypeSignature());", "author": "rongrong", "createdAt": "2020-07-16T03:18:14Z", "path": "presto-main/src/main/java/com/facebook/presto/type/EnumOperators.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.type;\n+\n+import com.facebook.presto.annotation.UsedByGeneratedCode;\n+import com.facebook.presto.common.function.OperatorType;\n+import com.facebook.presto.common.type.AbstractLongType;\n+import com.facebook.presto.common.type.BigintType;\n+import com.facebook.presto.common.type.BooleanType;\n+import com.facebook.presto.common.type.EnumType;\n+import com.facebook.presto.common.type.LongEnumType;\n+import com.facebook.presto.common.type.IntegerType;\n+import com.facebook.presto.common.type.SmallintType;\n+import com.facebook.presto.common.type.StandardTypes;\n+import com.facebook.presto.common.type.VarcharEnumType;\n+import com.facebook.presto.common.type.TinyintType;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.common.type.TypeSignature;\n+import com.facebook.presto.metadata.PolymorphicScalarFunctionBuilder;\n+import com.facebook.presto.metadata.SignatureBuilder;\n+import com.facebook.presto.metadata.SqlScalarFunction;\n+import com.facebook.presto.operator.scalar.BuiltInScalarFunctionImplementation;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.Signature;\n+import com.facebook.presto.spi.function.SqlFunction;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import io.airlift.slice.XxHash64;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.facebook.presto.common.function.OperatorType.CAST;\n+import static com.facebook.presto.operator.scalar.BuiltInScalarFunctionImplementation.ArgumentProperty.valueTypeArgumentProperty;\n+import static com.facebook.presto.operator.scalar.BuiltInScalarFunctionImplementation.NullConvention.USE_NULL_FLAG;\n+import static com.facebook.presto.spi.StandardErrorCode.INVALID_CAST_ARGUMENT;\n+import static com.facebook.presto.spi.function.FunctionKind.SCALAR;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class EnumOperators\n+{\n+    private static final TypeSignature BOOLEAN_TYPE_SIGNATURE = BooleanType.BOOLEAN.getTypeSignature();\n+\n+    private EnumOperators() {}\n+\n+    private static final Set<TypeSignature> INTEGER_TYPES = Sets.newHashSet(", "originalCommit": "da9cb046a909bcef151b4f6f76d0e9ab0e32aa2e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ4NTgxMQ==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r455485811", "bodyText": "We don't normally use nullable parameters. Use Optional<Type> instead.", "author": "rongrong", "createdAt": "2020-07-16T03:19:54Z", "path": "presto-main/src/main/java/com/facebook/presto/type/EnumOperators.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.type;\n+\n+import com.facebook.presto.annotation.UsedByGeneratedCode;\n+import com.facebook.presto.common.function.OperatorType;\n+import com.facebook.presto.common.type.AbstractLongType;\n+import com.facebook.presto.common.type.BigintType;\n+import com.facebook.presto.common.type.BooleanType;\n+import com.facebook.presto.common.type.EnumType;\n+import com.facebook.presto.common.type.LongEnumType;\n+import com.facebook.presto.common.type.IntegerType;\n+import com.facebook.presto.common.type.SmallintType;\n+import com.facebook.presto.common.type.StandardTypes;\n+import com.facebook.presto.common.type.VarcharEnumType;\n+import com.facebook.presto.common.type.TinyintType;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.common.type.TypeSignature;\n+import com.facebook.presto.metadata.PolymorphicScalarFunctionBuilder;\n+import com.facebook.presto.metadata.SignatureBuilder;\n+import com.facebook.presto.metadata.SqlScalarFunction;\n+import com.facebook.presto.operator.scalar.BuiltInScalarFunctionImplementation;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.Signature;\n+import com.facebook.presto.spi.function.SqlFunction;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import io.airlift.slice.XxHash64;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.facebook.presto.common.function.OperatorType.CAST;\n+import static com.facebook.presto.operator.scalar.BuiltInScalarFunctionImplementation.ArgumentProperty.valueTypeArgumentProperty;\n+import static com.facebook.presto.operator.scalar.BuiltInScalarFunctionImplementation.NullConvention.USE_NULL_FLAG;\n+import static com.facebook.presto.spi.StandardErrorCode.INVALID_CAST_ARGUMENT;\n+import static com.facebook.presto.spi.function.FunctionKind.SCALAR;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class EnumOperators\n+{\n+    private static final TypeSignature BOOLEAN_TYPE_SIGNATURE = BooleanType.BOOLEAN.getTypeSignature();\n+\n+    private EnumOperators() {}\n+\n+    private static final Set<TypeSignature> INTEGER_TYPES = Sets.newHashSet(\n+            Stream.of(TinyintType.TINYINT, SmallintType.SMALLINT, IntegerType.INTEGER, BigintType.BIGINT)\n+                    .map(Type::getTypeSignature).collect(Collectors.toSet()));\n+\n+    public static Optional<SqlFunction> makeOperator(OperatorType operatorType, List<Type> argTypes, @Nullable Type returnType)", "originalCommit": "da9cb046a909bcef151b4f6f76d0e9ab0e32aa2e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ4NjIwOA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r455486208", "bodyText": "noneMatch(EnumType.class::isInstance)", "author": "rongrong", "createdAt": "2020-07-16T03:21:20Z", "path": "presto-main/src/main/java/com/facebook/presto/type/EnumOperators.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.type;\n+\n+import com.facebook.presto.annotation.UsedByGeneratedCode;\n+import com.facebook.presto.common.function.OperatorType;\n+import com.facebook.presto.common.type.AbstractLongType;\n+import com.facebook.presto.common.type.BigintType;\n+import com.facebook.presto.common.type.BooleanType;\n+import com.facebook.presto.common.type.EnumType;\n+import com.facebook.presto.common.type.LongEnumType;\n+import com.facebook.presto.common.type.IntegerType;\n+import com.facebook.presto.common.type.SmallintType;\n+import com.facebook.presto.common.type.StandardTypes;\n+import com.facebook.presto.common.type.VarcharEnumType;\n+import com.facebook.presto.common.type.TinyintType;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.common.type.TypeSignature;\n+import com.facebook.presto.metadata.PolymorphicScalarFunctionBuilder;\n+import com.facebook.presto.metadata.SignatureBuilder;\n+import com.facebook.presto.metadata.SqlScalarFunction;\n+import com.facebook.presto.operator.scalar.BuiltInScalarFunctionImplementation;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.Signature;\n+import com.facebook.presto.spi.function.SqlFunction;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import io.airlift.slice.XxHash64;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.facebook.presto.common.function.OperatorType.CAST;\n+import static com.facebook.presto.operator.scalar.BuiltInScalarFunctionImplementation.ArgumentProperty.valueTypeArgumentProperty;\n+import static com.facebook.presto.operator.scalar.BuiltInScalarFunctionImplementation.NullConvention.USE_NULL_FLAG;\n+import static com.facebook.presto.spi.StandardErrorCode.INVALID_CAST_ARGUMENT;\n+import static com.facebook.presto.spi.function.FunctionKind.SCALAR;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class EnumOperators\n+{\n+    private static final TypeSignature BOOLEAN_TYPE_SIGNATURE = BooleanType.BOOLEAN.getTypeSignature();\n+\n+    private EnumOperators() {}\n+\n+    private static final Set<TypeSignature> INTEGER_TYPES = Sets.newHashSet(\n+            Stream.of(TinyintType.TINYINT, SmallintType.SMALLINT, IntegerType.INTEGER, BigintType.BIGINT)\n+                    .map(Type::getTypeSignature).collect(Collectors.toSet()));\n+\n+    public static Optional<SqlFunction> makeOperator(OperatorType operatorType, List<Type> argTypes, @Nullable Type returnType)\n+    {\n+        if (!(returnType instanceof EnumType) && argTypes.stream().noneMatch(t -> t instanceof EnumType)) {", "originalCommit": "da9cb046a909bcef151b4f6f76d0e9ab0e32aa2e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NTQ4ODQxMg==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r455488412", "bodyText": "I don't think you need PolymorphicScalarFunction here. This is for special cases where there are multiple physical implementation of the same logical function (the same function signature has multiple java implementations). I don't think you need that for enum operator functions. So I think you can just create an abstract EnumSqlScalarFunction and override specialize to provide the implementation.", "author": "rongrong", "createdAt": "2020-07-16T03:30:38Z", "path": "presto-main/src/main/java/com/facebook/presto/type/EnumOperators.java", "diffHunk": "@@ -0,0 +1,349 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.type;\n+\n+import com.facebook.presto.annotation.UsedByGeneratedCode;\n+import com.facebook.presto.common.function.OperatorType;\n+import com.facebook.presto.common.type.AbstractLongType;\n+import com.facebook.presto.common.type.BigintType;\n+import com.facebook.presto.common.type.BooleanType;\n+import com.facebook.presto.common.type.EnumType;\n+import com.facebook.presto.common.type.LongEnumType;\n+import com.facebook.presto.common.type.IntegerType;\n+import com.facebook.presto.common.type.SmallintType;\n+import com.facebook.presto.common.type.StandardTypes;\n+import com.facebook.presto.common.type.VarcharEnumType;\n+import com.facebook.presto.common.type.TinyintType;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.common.type.TypeSignature;\n+import com.facebook.presto.metadata.PolymorphicScalarFunctionBuilder;\n+import com.facebook.presto.metadata.SignatureBuilder;\n+import com.facebook.presto.metadata.SqlScalarFunction;\n+import com.facebook.presto.operator.scalar.BuiltInScalarFunctionImplementation;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.function.Signature;\n+import com.facebook.presto.spi.function.SqlFunction;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Sets;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.Slices;\n+import io.airlift.slice.XxHash64;\n+\n+import javax.annotation.Nullable;\n+\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.Stream;\n+\n+import static com.facebook.presto.common.function.OperatorType.CAST;\n+import static com.facebook.presto.operator.scalar.BuiltInScalarFunctionImplementation.ArgumentProperty.valueTypeArgumentProperty;\n+import static com.facebook.presto.operator.scalar.BuiltInScalarFunctionImplementation.NullConvention.USE_NULL_FLAG;\n+import static com.facebook.presto.spi.StandardErrorCode.INVALID_CAST_ARGUMENT;\n+import static com.facebook.presto.spi.function.FunctionKind.SCALAR;\n+import static java.util.Objects.requireNonNull;\n+\n+public final class EnumOperators\n+{\n+    private static final TypeSignature BOOLEAN_TYPE_SIGNATURE = BooleanType.BOOLEAN.getTypeSignature();\n+\n+    private EnumOperators() {}\n+\n+    private static final Set<TypeSignature> INTEGER_TYPES = Sets.newHashSet(\n+            Stream.of(TinyintType.TINYINT, SmallintType.SMALLINT, IntegerType.INTEGER, BigintType.BIGINT)\n+                    .map(Type::getTypeSignature).collect(Collectors.toSet()));\n+\n+    public static Optional<SqlFunction> makeOperator(OperatorType operatorType, List<Type> argTypes, @Nullable Type returnType)\n+    {\n+        if (!(returnType instanceof EnumType) && argTypes.stream().noneMatch(t -> t instanceof EnumType)) {\n+            return Optional.empty();\n+        }\n+\n+        boolean isInt = !argTypes.isEmpty() && argTypes.get(0) instanceof LongEnumType;\n+        List<TypeSignature> argTypeSignatures = argTypes.stream()\n+                .map(Type::getTypeSignature)\n+                .collect(Collectors.toList());\n+\n+        switch (operatorType) {\n+            case CAST:\n+                requireNonNull(returnType);  // return type must be provided for CAST function lookup\n+                if (returnType instanceof EnumType) {\n+                    return makeCastToEnum(argTypes.get(0).getTypeSignature(), (EnumType) returnType);\n+                }\n+                if (argTypes.get(0) instanceof EnumType) {\n+                    return makeCastFromEnum((EnumType) argTypes.get(0), returnType.getTypeSignature());\n+                }\n+                return Optional.empty();\n+            case EQUAL:\n+            case NOT_EQUAL:\n+                if (!(argTypes.get(0) instanceof EnumType) || !argTypes.get(0).equals(argTypes.get(1))) {\n+                    return Optional.empty();\n+                }\n+                return buildFunction(\n+                        operatorType,\n+                        argTypeSignatures,\n+                        BOOLEAN_TYPE_SIGNATURE,\n+                        true,\n+                        isInt ? \"integerEnumCompare\" : \"stringEnumCompare\",\n+                        ImmutableList.of(OperatorType.NOT_EQUAL.equals(operatorType)));\n+            case IS_DISTINCT_FROM:\n+                if (!(argTypes.get(0) instanceof EnumType) || !argTypes.get(0).equals(argTypes.get(1))) {\n+                    return Optional.empty();\n+                }\n+                return buildFunction(\n+                        operatorType,\n+                        argTypeSignatures,\n+                        BOOLEAN_TYPE_SIGNATURE,\n+                        false,\n+                        isInt ? \"integerEnumIsDistinct\" : \"stringEnumIsDistinct\",\n+                        ImmutableList.of(),\n+                        new BuiltInScalarFunctionImplementation.ArgumentProperty[] {\n+                                valueTypeArgumentProperty(USE_NULL_FLAG),\n+                                valueTypeArgumentProperty(USE_NULL_FLAG)\n+                        });\n+            case HASH_CODE:\n+                return buildFunction(\n+                        operatorType,\n+                        argTypeSignatures,\n+                        BigintType.BIGINT.getTypeSignature(),\n+                        false,\n+                        isInt ? \"integerEnumHash\" : \"stringEnumHash\",\n+                        ImmutableList.of());\n+            case XX_HASH_64:\n+                return buildFunction(\n+                        operatorType,\n+                        argTypeSignatures,\n+                        BigintType.BIGINT.getTypeSignature(),\n+                        false,\n+                        isInt ? \"integerEnumXxHash64\" : \"stringEnumHash\",\n+                        ImmutableList.of());\n+            case INDETERMINATE:\n+                return buildFunction(\n+                        operatorType,\n+                        argTypeSignatures,\n+                        BOOLEAN_TYPE_SIGNATURE,\n+                        false,\n+                        isInt ? \"integerEnumIndeterminate\" : \"stringEnumIndeterminate\",\n+                        ImmutableList.of(),\n+                        new BuiltInScalarFunctionImplementation.ArgumentProperty[] {\n+                                valueTypeArgumentProperty(USE_NULL_FLAG)\n+                        });\n+            default:\n+                return Optional.empty();\n+        }\n+    }\n+\n+    private static Optional<SqlFunction> makeCastToEnum(TypeSignature fromType, EnumType toType)\n+    {\n+        if (toType instanceof LongEnumType) {\n+            if (INTEGER_TYPES.contains(fromType)) {\n+                return buildCastToEnum(fromType, toType, \"integerEnumValueLookup\");\n+            }\n+            if (StandardTypes.VARCHAR.equals(fromType.getBase())) {\n+                return buildCastToEnum(fromType, toType, \"integerEnumKeyLookup\");\n+            }\n+        }\n+        if (toType instanceof VarcharEnumType) {\n+            if (StandardTypes.VARCHAR.equals(fromType.getBase())) {\n+                return buildCastToEnum(fromType, toType, \"stringEnumKeyOrValueLookup\");\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private static Optional<SqlFunction> makeCastFromEnum(EnumType fromType, TypeSignature toType)\n+    {\n+        if (fromType instanceof LongEnumType) {\n+            if (BigintType.BIGINT.getTypeSignature().equals(toType)) {\n+                return buildCastFromEnum(fromType, toType, \"integerEnumAsPrimitive\");\n+            }\n+        }\n+        if (fromType instanceof VarcharEnumType) {\n+            if (StandardTypes.VARCHAR.equals(toType.getBase())) {\n+                return buildCastFromEnum(fromType, toType, \"stringEnumAsPrimitive\");\n+            }\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private static Optional<SqlFunction> buildCastToEnum(TypeSignature fromType, EnumType toType, String methodName)\n+    {\n+        return buildFunction(\n+                CAST,\n+                ImmutableList.of(fromType),\n+                toType.getTypeSignature(),\n+                false,\n+                methodName,\n+                ImmutableList.of(toType));\n+    }\n+\n+    private static Optional<SqlFunction> buildCastFromEnum(EnumType fromType, TypeSignature toType, String methodName)\n+    {\n+        return buildFunction(\n+                CAST,\n+                ImmutableList.of(fromType.getTypeSignature()),\n+                toType,\n+                false,\n+                methodName,\n+                ImmutableList.of());\n+    }\n+\n+    private static Optional<SqlFunction> buildFunction(OperatorType operatorType, List<TypeSignature> argTypes, TypeSignature returnType,\n+            boolean nullableResult, String methodName, List<Object> extraParams)\n+    {\n+        return buildFunction(operatorType, argTypes, returnType, nullableResult, methodName, extraParams, null);\n+    }\n+\n+    private static Optional<SqlFunction> buildFunction(OperatorType operatorType, List<TypeSignature> argTypes, TypeSignature returnType,\n+            boolean nullableResult, String methodName, List<Object> extraParams, BuiltInScalarFunctionImplementation.ArgumentProperty[] argumentProperties)\n+    {\n+        Signature signature = SignatureBuilder.builder()\n+                .kind(SCALAR)\n+                .operatorType(operatorType)\n+                .argumentTypes(argTypes)\n+                .returnType(returnType)\n+                .build();\n+\n+        return Optional.of(SqlScalarFunction.builder(EnumOperators.class)", "originalCommit": "da9cb046a909bcef151b4f6f76d0e9ab0e32aa2e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e163179061d68640267bd9e1988d927a2e657f18", "url": "https://github.com/prestodb/presto/commit/e163179061d68640267bd9e1988d927a2e657f18", "message": "Support enum <> JSON cast", "committedDate": "2020-07-22T01:09:52Z", "type": "forcePushed"}, {"oid": "cf37c7ddedb2e17908f2d718a935c6d789dc53cd", "url": "https://github.com/prestodb/presto/commit/cf37c7ddedb2e17908f2d718a935c6d789dc53cd", "message": "Support enum <> JSON cast", "committedDate": "2020-07-22T01:26:06Z", "type": "forcePushed"}, {"oid": "cf63560655a0ab742252e62ef2e3981e3a8a4622", "url": "https://github.com/prestodb/presto/commit/cf63560655a0ab742252e62ef2e3981e3a8a4622", "message": "Support enum <> JSON cast", "committedDate": "2020-07-22T03:20:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk3MDQ3OQ==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r458970479", "bodyText": "What does NONE mean?", "author": "rongrong", "createdAt": "2020-07-22T17:43:06Z", "path": "presto-common/src/main/java/com/facebook/presto/common/type/EnumTypeConstraint.java", "diffHunk": "@@ -0,0 +1,21 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.common.type;\n+\n+public enum EnumTypeConstraint\n+{\n+    NONE,", "originalCommit": "de1f2122db58b7065eb99d84202d4452d957aad1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk4MjkzNw==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r458982937", "bodyText": "NONE means no enum type constraint.\nThe reason I'm not using null to express \"no enum type constraint\" is because I wanted to add an enumTypeConstraint parameter with a default value to the @interface TypeParameter, but null is not accepted as a default value for @interface parameters.\nIf you think that looks weird, I could make separaate @interfaces instead like LongEnumTypeParameter and VarcharEnumTypeParameter", "author": "daniel-ohayon", "createdAt": "2020-07-22T18:03:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk3MDQ3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk4ODM3MQ==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r458988371", "bodyText": "If you want to add it to TypeParameter, why not add these values to ParameterKind?", "author": "rongrong", "createdAt": "2020-07-22T18:12:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk3MDQ3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk5MjczMg==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r458992732", "bodyText": "It feels awkward to require every type to have an EnumTypeConstraint. I think for TypeParameter it's better to wrap this information into ParameterKind. You can keep the EnumTypeConstraint in TypeVariableConstraint if you need to distinguish between LongEnumType and VarcharEnumType and use @Nullable if you wish.", "author": "rongrong", "createdAt": "2020-07-22T18:20:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk3MDQ3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk5NDIxMA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r458994210", "bodyText": "I meant the decorator TypeParameter, not the class TypeParameter\nThe @TypeParameter I'm talking about is only used as a shortcut to annotate Java methods as Presto function definitions (I do that in the \"Enum operators\" commit)", "author": "daniel-ohayon", "createdAt": "2020-07-22T18:23:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk3MDQ3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1OTA0ODU3OA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r459048578", "bodyText": "That sounds wrong. the @TypeParameter works like a generic. This definitely doesn't fit there. If necessary, introduce a new annotation and add it to ImplementationDependency.", "author": "rongrong", "createdAt": "2020-07-22T20:00:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk3MDQ3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk3MDkxMg==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r458970912", "bodyText": "Static import.", "author": "rongrong", "createdAt": "2020-07-22T17:43:48Z", "path": "presto-common/src/main/java/com/facebook/presto/common/type/LongEnumType.java", "diffHunk": "@@ -0,0 +1,61 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.common.type;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.function.SqlFunctionProperties;\n+\n+import java.util.Map;\n+\n+public class LongEnumType\n+        extends AbstractLongType\n+        implements EnumType<Long>\n+{\n+    private final Map<String, Long> enumMap;\n+\n+    public LongEnumType(String name, Map<String, Long> enumMap)\n+    {\n+        super(new TypeSignature(name));\n+        TypeUtils.validateEnumEntries(name, enumMap);", "originalCommit": "de1f2122db58b7065eb99d84202d4452d957aad1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk3MTI3Mw==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r458971273", "bodyText": "Static import", "author": "rongrong", "createdAt": "2020-07-22T17:44:24Z", "path": "presto-common/src/main/java/com/facebook/presto/common/type/VarcharEnumType.java", "diffHunk": "@@ -0,0 +1,48 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.common.type;\n+\n+import java.util.Map;\n+\n+public class VarcharEnumType\n+        extends AbstractVarcharType\n+        implements EnumType<String>\n+{\n+    private final Map<String, String> enumMap;\n+\n+    public VarcharEnumType(String name, Map<String, String> enumMap)\n+    {\n+        super(VarcharType.UNBOUNDED_LENGTH, TypeSignature.parseTypeSignature(name));\n+        TypeUtils.validateEnumEntries(name, enumMap);", "originalCommit": "de1f2122db58b7065eb99d84202d4452d957aad1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1ODk3NTY2Mg==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r458975662", "bodyText": "This can be simplified as\ncheckArgument(entries.values().stream().filter(value -> value != null).collect(toImmutableSet()).size() == entries.size(), format(\"Enum %s cannot contain null or duplicate values\", enumName));\n\nYou can use checkArgument for null check on key as well. These should be IllegalArgumentException.", "author": "rongrong", "createdAt": "2020-07-22T17:51:32Z", "path": "presto-common/src/main/java/com/facebook/presto/common/type/TypeUtils.java", "diffHunk": "@@ -101,4 +107,23 @@ static void checkElementNotNull(boolean isNull, String errorMsg)\n             throw new NotSupportedException(errorMsg);\n         }\n     }\n+\n+    static <V> void validateEnumEntries(String enumName, Map<String, V> entries)\n+    {\n+        requireNonNull(enumName, \"Enum name cannot be null\");\n+        requireNonNull(entries, \"Enum entries cannot be null\");\n+        if (entries.containsKey(null)) {\n+            throw new NotSupportedException(String.format(\"Enum %s cannot contain null key\", enumName));\n+        }\n+        Set<V> visited = new HashSet<>();\n+        for (V value : entries.values()) {", "originalCommit": "de1f2122db58b7065eb99d84202d4452d957aad1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "ca2a73106c5538189e11403ad04ee403dd26cfcf", "url": "https://github.com/prestodb/presto/commit/ca2a73106c5538189e11403ad04ee403dd26cfcf", "message": "Support enum <> JSON cast", "committedDate": "2020-07-22T18:46:27Z", "type": "forcePushed"}, {"oid": "11636eab4dbcf5faa1b31a39ae8f6df6b19bd17a", "url": "https://github.com/prestodb/presto/commit/11636eab4dbcf5faa1b31a39ae8f6df6b19bd17a", "message": "Support enum <> JSON cast", "committedDate": "2020-07-23T16:57:06Z", "type": "forcePushed"}, {"oid": "98331516d1e0e804f5ed638c637e90002fb2d334", "url": "https://github.com/prestodb/presto/commit/98331516d1e0e804f5ed638c637e90002fb2d334", "message": "Support enum <> JSON cast", "committedDate": "2020-07-24T21:43:17Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNDMwNw==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r460434307", "bodyText": "Would this allow casting from other numeric types to LongEnumType ? eg. CAST(1.01 AS Country). It will get tricky if there is implicit casting", "author": "tejasapatil", "createdAt": "2020-07-25T19:04:59Z", "path": "presto-common/src/main/java/com/facebook/presto/common/type/LongEnumType.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.common.type;\n+\n+import com.facebook.presto.common.block.Block;\n+import com.facebook.presto.common.function.SqlFunctionProperties;\n+\n+import java.util.Map;\n+\n+import static com.facebook.presto.common.type.BigintType.BIGINT;\n+import static com.facebook.presto.common.type.TypeUtils.validateEnumEntries;\n+\n+public class LongEnumType\n+        extends AbstractLongType", "originalCommit": "98331516d1e0e804f5ed638c637e90002fb2d334", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDU3NTc2Mw==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r460575763", "bodyText": "No, the Java class hierarchy of the type classes is separate from function signature resolution in Presto itself.\nWith the operators introduced in EnumOperators, I only allow casting from smallint/tinyint/integer/bigint to numeric enum.", "author": "daniel-ohayon", "createdAt": "2020-07-26T21:29:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MDQzNDMwNw=="}], "type": "inlineReview"}, {"oid": "d0491d5e529e409721cbb548b23026e7bd198759", "url": "https://github.com/prestodb/presto/commit/d0491d5e529e409721cbb548b23026e7bd198759", "message": "Support enum <> JSON cast", "committedDate": "2020-07-26T21:19:28Z", "type": "forcePushed"}, {"oid": "7da5d10e9938adf11f1ef793c7db4fca71d7e15c", "url": "https://github.com/prestodb/presto/commit/7da5d10e9938adf11f1ef793c7db4fca71d7e15c", "message": "Support enum <> JSON cast", "committedDate": "2020-07-26T23:54:43Z", "type": "forcePushed"}, {"oid": "88a0f147343f20082bc7e3ad1015ceec1103ceea", "url": "https://github.com/prestodb/presto/commit/88a0f147343f20082bc7e3ad1015ceec1103ceea", "message": "Support enum <> JSON cast", "committedDate": "2020-07-27T02:42:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA5NjkwOA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r461096908", "bodyText": "If you prefer to use the word bound, I think this is better named as boundTo / boundedBy. (Only for annotation, you can keep typeBound in TypeVariableConstraint.", "author": "rongrong", "createdAt": "2020-07-27T18:48:09Z", "path": "presto-spi/src/main/java/com/facebook/presto/spi/function/TypeParameter.java", "diffHunk": "@@ -28,4 +30,6 @@\n public @interface TypeParameter\n {\n     String value();\n+\n+    Class<? extends Type> typeBound() default Type.class;", "originalCommit": "29110d852fb3707ae959b7d80c7010525932e99b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTE2MzAxMw==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r461163013", "bodyText": "I like boundedBy \u2013 I like the word bound for consistency with https://docs.oracle.com/javase/tutorial/java/generics/bounded.html", "author": "daniel-ohayon", "createdAt": "2020-07-27T20:53:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA5NjkwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEwODA4OA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r461108088", "bodyText": "You might want to modify the comment on line 433 as well. Maybe just change it to something generic as // Handle qualified name. Then add additional comment for // Check whether the qualifiedName is a column reference and here you can just say // Check whether the qualifiedName is an enum literal", "author": "rongrong", "createdAt": "2020-07-27T19:08:41Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -437,6 +438,11 @@ protected Type visitDereferenceExpression(DereferenceExpression node, StackableA\n                     return handleResolvedField(node, resolvedField.get(), context);\n                 }\n                 if (!scope.isColumnReference(qualifiedName)) {\n+                    // try to match it to an enum literal (eg Mood.HAPPY)", "originalCommit": "1b4af2cdd6917e4642a9683229579672b9771b86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEwOTMzNA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r461109334", "bodyText": "Also the error thrown probably need to be changed as well. If you look at missingAttributeException it says \"column .. cannot be resolved\", which is no longer accurate.", "author": "rongrong", "createdAt": "2020-07-27T19:10:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEwODA4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMxMDU0Mg==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r461310542", "bodyText": "Hmm, I do want to keep some of that phrasing since most of the time that will be correct (it's more likely that people are misspelling a column name than an enum literal).\nWhat about: Column or qualified name '%s' cannot be resolved ?", "author": "daniel-ohayon", "createdAt": "2020-07-28T04:28:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEwODA4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTgwNjY3MQ==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r461806671", "bodyText": "Maybe just say Cannot resolve '%s'. When you tell people what cannot be resolved they'd know whether they meant it to be a column or enum. I agree that most of the time it's probably a column, but whenever it's not this would be a really confusing error message. (People might not know what's a qualified name so we might as well skip that confusion.)", "author": "rongrong", "createdAt": "2020-07-28T19:04:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEwODA4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTg5MDUwNA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r461890504", "bodyText": "That sounds reasonable \u2013 one thing though: there's tons of tests that need updating if we change that message, as many currently expect to see that particular error message.\nI can update those, but I'm worrying that we might break tests for other plugins/clients that are not in this repo if we change the error message. What do you think?", "author": "daniel-ohayon", "createdAt": "2020-07-28T21:28:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEwODA4OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU0MjkzMg==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r462542932", "bodyText": "After discussion, keeping \"Column %s cannot be resolved\" only when the qualifiedName has a single part", "author": "daniel-ohayon", "createdAt": "2020-07-29T19:41:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTEwODA4OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTExMDQ5Mw==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r461110493", "bodyText": "the function should directly take qualifiedName rather than the node.", "author": "rongrong", "createdAt": "2020-07-27T19:13:06Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -437,6 +438,11 @@ protected Type visitDereferenceExpression(DereferenceExpression node, StackableA\n                     return handleResolvedField(node, resolvedField.get(), context);\n                 }\n                 if (!scope.isColumnReference(qualifiedName)) {\n+                    // try to match it to an enum literal (eg Mood.HAPPY)\n+                    Optional<EnumType> enumType = ExpressionTreeUtils.maybeGetEnumTypeFromLiteral(node, typeManager);", "originalCommit": "1b4af2cdd6917e4642a9683229579672b9771b86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTExMTExMw==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r461111113", "bodyText": "toString is not safe here. node.getBase() potentially can be any expression. So you really want the input of this function to be just the QualifiedName and you want to use QualifiedName.getPrefix() here.", "author": "rongrong", "createdAt": "2020-07-27T19:14:21Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/ExpressionTreeUtils.java", "diffHunk": "@@ -112,4 +122,33 @@ public static boolean isEqualComparisonExpression(Expression expression)\n     {\n         return expression instanceof ComparisonExpression && ((ComparisonExpression) expression).getOperator() == ComparisonExpression.Operator.EQUAL;\n     }\n+\n+    public static Optional<EnumType> maybeGetEnumTypeFromLiteral(DereferenceExpression node, TypeManager typeManager)\n+    {\n+        try {\n+            Type baseType = typeManager.getType(parseTypeSignature(node.getBase().toString()));", "originalCommit": "1b4af2cdd6917e4642a9683229579672b9771b86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTExMTkwNA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r461111904", "bodyText": "These functions ideally should all just take QualifiedName if DereferenceExpression is used, either get QualifiedName from it, or you need to check the base is an Identifier. Blindly use toString is error prune.", "author": "rongrong", "createdAt": "2020-07-27T19:15:54Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/ExpressionTreeUtils.java", "diffHunk": "@@ -112,4 +122,33 @@ public static boolean isEqualComparisonExpression(Expression expression)\n     {\n         return expression instanceof ComparisonExpression && ((ComparisonExpression) expression).getOperator() == ComparisonExpression.Operator.EQUAL;\n     }\n+\n+    public static Optional<EnumType> maybeGetEnumTypeFromLiteral(DereferenceExpression node, TypeManager typeManager)\n+    {\n+        try {\n+            Type baseType = typeManager.getType(parseTypeSignature(node.getBase().toString()));\n+            if (baseType instanceof EnumType) {\n+                return Optional.of((EnumType) baseType);\n+            }\n+        }\n+        catch (IllegalArgumentException e) {\n+            return Optional.empty();\n+        }\n+        return Optional.empty();\n+    }\n+\n+    public static boolean isEnumLiteral(DereferenceExpression node, Type nodeType)\n+    {\n+        return nodeType instanceof EnumType && node.getBase().toString().equalsIgnoreCase(nodeType.toString());", "originalCommit": "1b4af2cdd6917e4642a9683229579672b9771b86", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTMwNjU2MA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r461306560", "bodyText": "I'm keeping the signature as-is because most of the callsites would have to extract the QualifiedName otherwise, but I'm following your suggestion to parse the QualifiedName inside the method.", "author": "daniel-ohayon", "createdAt": "2020-07-28T04:13:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTExMTkwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTExMjg2Mg==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r461112862", "bodyText": "Either put validation that the node is a valid enum, or make sure only valid enum can be used to call this. I think this function should call isEnumLiteral.", "author": "rongrong", "createdAt": "2020-07-27T19:17:46Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/ExpressionTreeUtils.java", "diffHunk": "@@ -112,4 +122,33 @@ public static boolean isEqualComparisonExpression(Expression expression)\n     {\n         return expression instanceof ComparisonExpression && ((ComparisonExpression) expression).getOperator() == ComparisonExpression.Operator.EQUAL;\n     }\n+\n+    public static Optional<EnumType> maybeGetEnumTypeFromLiteral(DereferenceExpression node, TypeManager typeManager)\n+    {\n+        try {\n+            Type baseType = typeManager.getType(parseTypeSignature(node.getBase().toString()));\n+            if (baseType instanceof EnumType) {\n+                return Optional.of((EnumType) baseType);\n+            }\n+        }\n+        catch (IllegalArgumentException e) {\n+            return Optional.empty();\n+        }\n+        return Optional.empty();\n+    }\n+\n+    public static boolean isEnumLiteral(DereferenceExpression node, Type nodeType)\n+    {\n+        return nodeType instanceof EnumType && node.getBase().toString().equalsIgnoreCase(nodeType.toString());\n+    }\n+\n+    public static Object resolveEnumLiteral(DereferenceExpression literal, EnumType enumType)", "originalCommit": "1b4af2cdd6917e4642a9683229579672b9771b86", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8faecd0e3aa8b8a06e66d652d65f4039752ffa59", "url": "https://github.com/prestodb/presto/commit/8faecd0e3aa8b8a06e66d652d65f4039752ffa59", "message": "Support enum <> JSON cast", "committedDate": "2020-07-28T04:22:52Z", "type": "forcePushed"}, {"oid": "0b8e3e180887c08f68a1cde23a3e7f3f1db3bf54", "url": "https://github.com/prestodb/presto/commit/0b8e3e180887c08f68a1cde23a3e7f3f1db3bf54", "message": "Support enum <> JSON cast", "committedDate": "2020-07-28T15:42:53Z", "type": "forcePushed"}, {"oid": "603c113f76754142a4127d0a6086aaaadf374b37", "url": "https://github.com/prestodb/presto/commit/603c113f76754142a4127d0a6086aaaadf374b37", "message": "Support enum <> JSON cast", "committedDate": "2020-07-29T01:06:51Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk1MDQ1NA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r461950454", "bodyText": "Do we foresee more usage of these newly added helper functions? If the only place we will need this is in FunctionParserHelper I prefer to directly inline this rather than defining more helper functions. Also Signature is in spi so these functions will be visible for all connectors as well.", "author": "rongrong", "createdAt": "2020-07-28T23:28:03Z", "path": "presto-spi/src/main/java/com/facebook/presto/spi/function/Signature.java", "diffHunk": "@@ -174,6 +175,11 @@ public static TypeVariableConstraint typeVariable(String name)\n         return new TypeVariableConstraint(name, false, false, null);\n     }\n \n+    public static TypeVariableConstraint typeVariable(String name, Class<? extends Type> typeBound)", "originalCommit": "01bee5b6de6374dc1d42cfb9dc18bf4e379f9737", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk5MzYzMQ==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r461993631", "bodyText": "Let's not do this. You can add a flag to enable / disable this at the very least. This logic doesn't belong here. Please keep interfaces clean.\nThe way I prefer would be to change the implementation of rewriteIdentifiersToSymbolReferences and add a rewriteDereference to check if (base instanceof Identifier) return node;", "author": "rongrong", "createdAt": "2020-07-29T02:01:38Z", "path": "presto-main/src/test/java/com/facebook/presto/operator/scalar/FunctionAssertions.java", "diffHunk": "@@ -751,7 +752,13 @@ public static Expression createExpression(Session session, String expression, Me\n     {\n         Expression parsedExpression = SQL_PARSER.createExpression(expression, createParsingOptions(session));\n \n-        parsedExpression = rewriteIdentifiersToSymbolReferences(parsedExpression);\n+        if (metadata.getTypeManager().getTypes().stream().noneMatch(EnumType.class::isInstance)) {", "originalCommit": "0fea9ac43f4c7a15c0a02889f3062cf9d9f6a89d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0MTU2MQ==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r463341561", "bodyText": "this direction ended up being pretty complicated to get tests working, so instead I'm going for a test file that uses a full-fledged DistributedQueryRunner to execute enum tests", "author": "daniel-ohayon", "createdAt": "2020-07-31T00:24:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTk5MzYzMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNDc5MA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r462004790", "bodyText": "I think our naming convention would be to name this class AbstractTestEnum", "author": "rongrong", "createdAt": "2020-07-29T02:44:15Z", "path": "presto-main/src/test/java/com/facebook/presto/type/TestEnumBase.java", "diffHunk": "@@ -0,0 +1,59 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.type;\n+\n+import com.facebook.presto.common.type.LongEnumType;\n+import com.facebook.presto.common.type.VarcharEnumType;\n+import com.facebook.presto.operator.scalar.AbstractTestFunctions;\n+import com.google.common.collect.ImmutableMap;\n+import org.testng.Assert.ThrowingRunnable;\n+import org.testng.annotations.BeforeClass;\n+\n+import static com.facebook.presto.sql.analyzer.SemanticErrorCode.INVALID_LITERAL;\n+import static org.testng.Assert.assertThrows;\n+\n+public abstract class TestEnumBase", "originalCommit": "0fea9ac43f4c7a15c0a02889f3062cf9d9f6a89d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNTA0Mg==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r462005042", "bodyText": "These are not functions, so why are we using assertFunction \ud83d\ude02", "author": "rongrong", "createdAt": "2020-07-29T02:45:01Z", "path": "presto-main/src/test/java/com/facebook/presto/type/TestEnumLiterals.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.type;\n+\n+import com.facebook.presto.common.type.VarcharEnumType;\n+import com.google.common.collect.ImmutableMap;\n+import org.testng.annotations.Test;\n+\n+public class TestEnumLiterals\n+        extends TestEnumBase\n+{\n+    @Test\n+    public void testLongEnumLiterals()\n+    {\n+        assertFunction(\"Mood.HAPPY\", MOOD_ENUM, 0L);", "originalCommit": "0fea9ac43f4c7a15c0a02889f3062cf9d9f6a89d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjQxNTU0OQ==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r462415549", "bodyText": "well technically it gets rewritten to a CAST so it's still a function \ud83d\ude48", "author": "daniel-ohayon", "createdAt": "2020-07-29T16:06:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNTA0Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzM0MTc1Ng==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r463341756", "bodyText": "changing directions for tests \u2013 see TestEnums.java", "author": "daniel-ohayon", "createdAt": "2020-07-31T00:24:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNTA0Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNjU0OQ==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r462006549", "bodyText": "Also add tests to test case-sensitivity of the types (Mood, mood, MOOD, MoOd etc)", "author": "rongrong", "createdAt": "2020-07-29T02:50:58Z", "path": "presto-main/src/test/java/com/facebook/presto/type/TestEnumLiterals.java", "diffHunk": "@@ -0,0 +1,65 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.type;\n+\n+import com.facebook.presto.common.type.VarcharEnumType;\n+import com.google.common.collect.ImmutableMap;\n+import org.testng.annotations.Test;\n+\n+public class TestEnumLiterals", "originalCommit": "0fea9ac43f4c7a15c0a02889f3062cf9d9f6a89d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNzM0NQ==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r462007345", "bodyText": "Hmm, so if enum types are qualified, as in catalog.schema.enumtype.enumvalue the part you should get is size()-2, not 0.", "author": "rongrong", "createdAt": "2020-07-29T02:54:03Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/ExpressionTreeUtils.java", "diffHunk": "@@ -112,4 +123,47 @@ public static boolean isEqualComparisonExpression(Expression expression)\n     {\n         return expression instanceof ComparisonExpression && ((ComparisonExpression) expression).getOperator() == ComparisonExpression.Operator.EQUAL;\n     }\n+\n+    static Optional<EnumType> maybeGetEnumTypeFromLiteral(QualifiedName qualifiedName, TypeManager typeManager)\n+    {\n+        if (qualifiedName.getParts().size() < 2) {\n+            // an enum literal should be of the form `MyEnum.my_key`\n+            return Optional.empty();\n+        }\n+        try {\n+            Type baseType = typeManager.getType(parseTypeSignature(qualifiedName.getParts().get(0)));\n+            if (baseType instanceof EnumType) {\n+                return Optional.of((EnumType) baseType);\n+            }\n+        }\n+        catch (IllegalArgumentException e) {\n+            return Optional.empty();\n+        }\n+        return Optional.empty();\n+    }\n+\n+    public static boolean isEnumLiteral(DereferenceExpression node, Type nodeType)\n+    {\n+        if (!(nodeType instanceof EnumType)) {\n+            return false;\n+        }\n+        QualifiedName qualifiedName = DereferenceExpression.getQualifiedName(node);\n+        return qualifiedName != null\n+                && qualifiedName.getParts().size() >= 2", "originalCommit": "0fea9ac43f4c7a15c0a02889f3062cf9d9f6a89d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwNzQ1Mw==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r462007453", "bodyText": "This should be getSuffix()", "author": "rongrong", "createdAt": "2020-07-29T02:54:30Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/ExpressionTreeUtils.java", "diffHunk": "@@ -112,4 +123,47 @@ public static boolean isEqualComparisonExpression(Expression expression)\n     {\n         return expression instanceof ComparisonExpression && ((ComparisonExpression) expression).getOperator() == ComparisonExpression.Operator.EQUAL;\n     }\n+\n+    static Optional<EnumType> maybeGetEnumTypeFromLiteral(QualifiedName qualifiedName, TypeManager typeManager)\n+    {\n+        if (qualifiedName.getParts().size() < 2) {\n+            // an enum literal should be of the form `MyEnum.my_key`\n+            return Optional.empty();\n+        }\n+        try {\n+            Type baseType = typeManager.getType(parseTypeSignature(qualifiedName.getParts().get(0)));\n+            if (baseType instanceof EnumType) {\n+                return Optional.of((EnumType) baseType);\n+            }\n+        }\n+        catch (IllegalArgumentException e) {\n+            return Optional.empty();\n+        }\n+        return Optional.empty();\n+    }\n+\n+    public static boolean isEnumLiteral(DereferenceExpression node, Type nodeType)\n+    {\n+        if (!(nodeType instanceof EnumType)) {\n+            return false;\n+        }\n+        QualifiedName qualifiedName = DereferenceExpression.getQualifiedName(node);\n+        return qualifiedName != null\n+                && qualifiedName.getParts().size() >= 2\n+                && qualifiedName.getParts().get(0).equalsIgnoreCase(nodeType.toString());\n+    }\n+\n+    public static Object resolveEnumLiteral(DereferenceExpression node, EnumType enumType)\n+    {\n+        QualifiedName qualifiedName = DereferenceExpression.getQualifiedName(node);\n+        if (qualifiedName == null || !isEnumLiteral(node, enumType)) {\n+            throw new SemanticException(INVALID_LITERAL, node, \"Node is not an enum literal\");\n+        }\n+        String enumKey = qualifiedName.getParts().get(1).toLowerCase(ENGLISH);", "originalCommit": "0fea9ac43f4c7a15c0a02889f3062cf9d9f6a89d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwODEzOA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r462008138", "bodyText": "It's the second to the last part that you are looking for. I'd do qualifiedName.getPrefix().getSuffix() here. Or get the size of get(size - 2).", "author": "rongrong", "createdAt": "2020-07-29T02:56:50Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/ExpressionTreeUtils.java", "diffHunk": "@@ -112,4 +123,47 @@ public static boolean isEqualComparisonExpression(Expression expression)\n     {\n         return expression instanceof ComparisonExpression && ((ComparisonExpression) expression).getOperator() == ComparisonExpression.Operator.EQUAL;\n     }\n+\n+    static Optional<EnumType> maybeGetEnumTypeFromLiteral(QualifiedName qualifiedName, TypeManager typeManager)\n+    {\n+        if (qualifiedName.getParts().size() < 2) {\n+            // an enum literal should be of the form `MyEnum.my_key`\n+            return Optional.empty();\n+        }\n+        try {\n+            Type baseType = typeManager.getType(parseTypeSignature(qualifiedName.getParts().get(0)));", "originalCommit": "0fea9ac43f4c7a15c0a02889f3062cf9d9f6a89d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjAwODk3OA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r462008978", "bodyText": "use tryResolveEnumLiteral to be consistent with tryResolveField", "author": "rongrong", "createdAt": "2020-07-29T02:59:52Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/ExpressionAnalyzer.java", "diffHunk": "@@ -429,14 +431,20 @@ protected Type visitDereferenceExpression(DereferenceExpression node, StackableA\n         {\n             QualifiedName qualifiedName = DereferenceExpression.getQualifiedName(node);\n \n-            // If this Dereference looks like column reference, try match it to column first.\n+            // Handle qualified name\n             if (qualifiedName != null) {\n+                // first, try to match it to a column name\n                 Scope scope = context.getContext().getScope();\n                 Optional<ResolvedField> resolvedField = scope.tryResolveField(node, qualifiedName);\n                 if (resolvedField.isPresent()) {\n                     return handleResolvedField(node, resolvedField.get(), context);\n                 }\n+                // otherwise, try to match it to an enum literal (eg Mood.HAPPY)\n                 if (!scope.isColumnReference(qualifiedName)) {\n+                    Optional<EnumType> enumType = maybeGetEnumTypeFromLiteral(qualifiedName, typeManager);", "originalCommit": "0fea9ac43f4c7a15c0a02889f3062cf9d9f6a89d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "144ed1ac8fb17ccf9a2b616a83fb897da02b848f", "url": "https://github.com/prestodb/presto/commit/144ed1ac8fb17ccf9a2b616a83fb897da02b848f", "message": "Support enum <> JSON cast", "committedDate": "2020-07-29T18:59:51Z", "type": "forcePushed"}, {"oid": "b8bf2cb86229774921e7cc1e62be0df1e51e59bb", "url": "https://github.com/prestodb/presto/commit/b8bf2cb86229774921e7cc1e62be0df1e51e59bb", "message": "Support client-side enum rendering\n\nWe want clients to know about enums so that they can pretty-print them, and so we can serialize varchar enum values correctly.", "committedDate": "2020-07-30T15:42:54Z", "type": "forcePushed"}, {"oid": "b56e3efdb9e609be7876ef5320fc1d0c1672836b", "url": "https://github.com/prestodb/presto/commit/b56e3efdb9e609be7876ef5320fc1d0c1672836b", "message": "Support client-side enum rendering\n\nWe want clients to know about enums so that they can pretty-print them, and so we can serialize varchar enum values correctly.", "committedDate": "2020-07-31T00:21:51Z", "type": "forcePushed"}, {"oid": "d0e29b71f7c96bde6a5a91463e152a9cbddf8fd5", "url": "https://github.com/prestodb/presto/commit/d0e29b71f7c96bde6a5a91463e152a9cbddf8fd5", "message": "Support client-side enum rendering\n\nWe want clients to know about enums so that they can pretty-print them, and so we can serialize varchar enum values correctly.", "committedDate": "2020-07-31T00:35:59Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgxNTM5OA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r463815398", "bodyText": "Sorry, my previous recommendation was wrong. You actually should just use parseTypeSignature(qualifiedName.getPrefix()) here. If the enum literal is of the form catalog.schema.EnumType.EnumValue, then the type should be catalog.schema.EnumType, rather than just EnumType alone.", "author": "rongrong", "createdAt": "2020-07-31T20:16:47Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/ExpressionTreeUtils.java", "diffHunk": "@@ -112,4 +123,51 @@ public static boolean isEqualComparisonExpression(Expression expression)\n     {\n         return expression instanceof ComparisonExpression && ((ComparisonExpression) expression).getOperator() == ComparisonExpression.Operator.EQUAL;\n     }\n+\n+    static Optional<EnumType> tryResolveEnumLiteralType(QualifiedName qualifiedName, TypeManager typeManager)\n+    {\n+        int nParts = qualifiedName.getParts().size();\n+        if (nParts < 2) {\n+            // an enum literal should be of the form `MyEnum.my_key`\n+            return Optional.empty();\n+        }\n+        try {\n+            Type baseType = typeManager.getType(parseTypeSignature(qualifiedName.getParts().get(nParts - 2)));", "originalCommit": "50ee9682086ced09b9c7beb3c6ba05d58c7db226", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgxNjE4MA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r463816180", "bodyText": "In what situation would the nodeType be enum but qualifiedName is null or of the wrong format?", "author": "rongrong", "createdAt": "2020-07-31T20:18:53Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/ExpressionTreeUtils.java", "diffHunk": "@@ -112,4 +123,51 @@ public static boolean isEqualComparisonExpression(Expression expression)\n     {\n         return expression instanceof ComparisonExpression && ((ComparisonExpression) expression).getOperator() == ComparisonExpression.Operator.EQUAL;\n     }\n+\n+    static Optional<EnumType> tryResolveEnumLiteralType(QualifiedName qualifiedName, TypeManager typeManager)\n+    {\n+        int nParts = qualifiedName.getParts().size();\n+        if (nParts < 2) {\n+            // an enum literal should be of the form `MyEnum.my_key`\n+            return Optional.empty();\n+        }\n+        try {\n+            Type baseType = typeManager.getType(parseTypeSignature(qualifiedName.getParts().get(nParts - 2)));\n+            if (baseType instanceof EnumType) {\n+                return Optional.of((EnumType) baseType);\n+            }\n+        }\n+        catch (IllegalArgumentException e) {\n+            return Optional.empty();\n+        }\n+        return Optional.empty();\n+    }\n+\n+    public static boolean isEnumLiteral(DereferenceExpression node, Type nodeType)\n+    {\n+        if (!(nodeType instanceof EnumType)) {\n+            return false;\n+        }\n+        QualifiedName qualifiedName = DereferenceExpression.getQualifiedName(node);\n+        if (qualifiedName == null) {", "originalCommit": "50ee9682086ced09b9c7beb3c6ba05d58c7db226", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODE3MTgxNg==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r468171816", "bodyText": "I don't think this should happen \u2013 will use requireNonNull instead", "author": "daniel-ohayon", "createdAt": "2020-08-10T20:37:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgxNjE4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgxODQ2Mw==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r463818463", "bodyText": "This function is too low level to throw an SemanticException. If you expect this function to be only called when node is a valid enum, it should throw IllegalArgumentException. You can change these logic to a checkArgument.", "author": "rongrong", "createdAt": "2020-07-31T20:24:21Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/ExpressionTreeUtils.java", "diffHunk": "@@ -112,4 +123,51 @@ public static boolean isEqualComparisonExpression(Expression expression)\n     {\n         return expression instanceof ComparisonExpression && ((ComparisonExpression) expression).getOperator() == ComparisonExpression.Operator.EQUAL;\n     }\n+\n+    static Optional<EnumType> tryResolveEnumLiteralType(QualifiedName qualifiedName, TypeManager typeManager)\n+    {\n+        int nParts = qualifiedName.getParts().size();\n+        if (nParts < 2) {\n+            // an enum literal should be of the form `MyEnum.my_key`\n+            return Optional.empty();\n+        }\n+        try {\n+            Type baseType = typeManager.getType(parseTypeSignature(qualifiedName.getParts().get(nParts - 2)));\n+            if (baseType instanceof EnumType) {\n+                return Optional.of((EnumType) baseType);\n+            }\n+        }\n+        catch (IllegalArgumentException e) {\n+            return Optional.empty();\n+        }\n+        return Optional.empty();\n+    }\n+\n+    public static boolean isEnumLiteral(DereferenceExpression node, Type nodeType)\n+    {\n+        if (!(nodeType instanceof EnumType)) {\n+            return false;\n+        }\n+        QualifiedName qualifiedName = DereferenceExpression.getQualifiedName(node);\n+        if (qualifiedName == null) {\n+            return false;\n+        }\n+        int nParts = qualifiedName.getParts().size();\n+        return nParts >= 2\n+                && qualifiedName.getParts().get(nParts - 2).equalsIgnoreCase(nodeType.toString());\n+    }\n+\n+    public static Object resolveEnumLiteral(DereferenceExpression node, EnumType enumType)\n+    {\n+        QualifiedName qualifiedName = DereferenceExpression.getQualifiedName(node);\n+        if (qualifiedName == null || !isEnumLiteral(node, enumType)) {\n+            throw new SemanticException(INVALID_LITERAL, node, \"Node is not an enum literal\");\n+        }\n+        String enumKey = qualifiedName.getSuffix().toLowerCase(ENGLISH);\n+        Object enumValue = enumType.getEnumMap().get(enumKey);\n+        if (enumValue == null) {\n+            throw new SemanticException(INVALID_LITERAL, node, format(\"No key '%s' in enum '%s'\", enumKey, enumType.getDisplayName()));", "originalCommit": "50ee9682086ced09b9c7beb3c6ba05d58c7db226", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyNDI5NQ==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r468224295", "bodyText": "Is it OK to have errors triggered by a checkArgument surfaced to users?\nThis is the only place where we check whether the provided key exists in the enum, so it will be very possible that users see this error.", "author": "daniel-ohayon", "createdAt": "2020-08-10T22:38:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgxODQ2Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyNzMxMw==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r468227313", "bodyText": "If it's not OK, we should add a catch at the correct level and translate the IllegalArgumentException to a SemanticException.", "author": "rongrong", "createdAt": "2020-08-10T22:47:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgxODQ2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgxODk2Nw==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r463818967", "bodyText": "nit: Either put the whole statement in one line or break at both ? and :.", "author": "rongrong", "createdAt": "2020-07-31T20:25:27Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/SemanticExceptions.java", "diffHunk": "@@ -29,7 +29,12 @@ private SemanticExceptions() {}\n \n     public static SemanticException missingAttributeException(Expression node, QualifiedName name)\n     {\n-        throw new SemanticException(MISSING_ATTRIBUTE, node, \"Column '%s' cannot be resolved\", name);\n+        throw new SemanticException(\n+                MISSING_ATTRIBUTE,\n+                node,\n+                name.getPrefix().isPresent() ? \"'%s' cannot be resolved\"", "originalCommit": "50ee9682086ced09b9c7beb3c6ba05d58c7db226", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgyMDYyNg==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r463820626", "bodyText": "I think you should just have a checkArgument(enumType instanceof LongEnumType || enumType instanceof VarcharEnumType, format(\"Unsupported enumType '%s (%s)'\", enumType, enumType.class)) at the beginning of the function. We normally do validation first.", "author": "rongrong", "createdAt": "2020-07-31T20:29:42Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/TranslationMap.java", "diffHunk": "@@ -270,6 +284,22 @@ private Expression coerceIfNecessary(Expression original, Expression rewritten)\n                 }\n                 return rewritten;\n             }\n+\n+            private Expression rewriteEnumLiteral(DereferenceExpression original, EnumType enumType)\n+            {\n+                Object enumValue = resolveEnumLiteral(original, enumType);\n+                if (enumType instanceof LongEnumType) {\n+                    return new Cast(\n+                            new LongLiteral(((Long) enumValue).toString()),\n+                            enumType.getTypeSignature().getBase());\n+                }\n+                if (enumType instanceof VarcharEnumType) {\n+                    return new Cast(\n+                            new StringLiteral(((Slice) enumValue).toStringUtf8()),\n+                            enumType.getTypeSignature().getBase());\n+                }\n+                throw new IllegalArgumentException(\"Unsupported enum type\");", "originalCommit": "50ee9682086ced09b9c7beb3c6ba05d58c7db226", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgyMDc3Mg==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r463820772", "bodyText": "Why are we removing a plan sanity checker?", "author": "rongrong", "createdAt": "2020-07-31T20:30:02Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/sanity/PlanChecker.java", "diffHunk": "@@ -47,7 +47,6 @@ public PlanChecker(FeaturesConfig featuresConfig, boolean forceSingleNode)\n                         new NoDuplicatePlanNodeIdsChecker(),\n                         new TypeValidator(),\n                         new NoSubqueryExpressionLeftChecker(),\n-                        new NoIdentifierLeftChecker(),", "originalCommit": "50ee9682086ced09b9c7beb3c6ba05d58c7db226", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyMzYwOA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r468223608", "bodyText": "woops, will fix it", "author": "daniel-ohayon", "createdAt": "2020-08-10T22:36:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgyMDc3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgyMTgwMA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r463821800", "bodyText": "Why don't we just return a GenericLiteral here, or if necessary, create a Literal that suits enum. It's a literal, why are we rewriting it to cast?", "author": "rongrong", "createdAt": "2020-07-31T20:32:22Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/TranslationMap.java", "diffHunk": "@@ -270,6 +284,22 @@ private Expression coerceIfNecessary(Expression original, Expression rewritten)\n                 }\n                 return rewritten;\n             }\n+\n+            private Expression rewriteEnumLiteral(DereferenceExpression original, EnumType enumType)\n+            {\n+                Object enumValue = resolveEnumLiteral(original, enumType);\n+                if (enumType instanceof LongEnumType) {", "originalCommit": "50ee9682086ced09b9c7beb3c6ba05d58c7db226", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgyMzc3OA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r463823778", "bodyText": "Let's remove this?", "author": "rongrong", "createdAt": "2020-07-31T20:36:58Z", "path": "presto-main/src/main/java/com/facebook/presto/metadata/MetadataManager.java", "diffHunk": "@@ -242,7 +243,9 @@ public final void verifyComparableOrderableContract()\n                     missingOperators.put(type, NOT_EQUAL);\n                 }\n             }\n-            if (type.isOrderable()) {\n+            if (type.isOrderable() && !(type instanceof EnumType)) {\n+                // Enum types can be used in ORDER BY clauses for convenience,", "originalCommit": "52cdeee359daa54038e9cdbc9adc7d410800f1a8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyMzM4MA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r468223380", "bodyText": "I believe we said we did want to support enum values in ORDER BY clauses?\n(but we wanted to possibly implement ordering based on the keys as opposed to the values, and control it with a session param)", "author": "daniel-ohayon", "createdAt": "2020-08-10T22:35:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgyMzc3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2ODIyNjk0Mw==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r468226943", "bodyText": "I'd assume if we set EnumType as comparable = false, orderable = true things will just work? Do we really need special handling?", "author": "rongrong", "createdAt": "2020-08-10T22:46:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgyMzc3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDAzMjMwMA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r470032300", "bodyText": "if we set comparable = false, we get semantic errors when we write things like mood.happy = mood.happy or use GROUP BY my_enum_column", "author": "daniel-ohayon", "createdAt": "2020-08-13T15:20:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgyMzc3OA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MDE4MjU1OA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r470182558", "bodyText": "Hmm, let's just keep both true then? While it doesn't make much sense to do enum >= value I don't really see a problem allowing it either, compare to the other option of inventing some new rules about type out of the spec.", "author": "rongrong", "createdAt": "2020-08-13T19:04:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgyMzc3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgyNTAyNg==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r463825026", "bodyText": "I think we should make the TypeSignature of enum types to include the information that they are enums.", "author": "rongrong", "createdAt": "2020-07-31T20:40:08Z", "path": "presto-main/src/main/java/com/facebook/presto/util/JsonUtil.java", "diffHunk": "@@ -201,7 +210,9 @@ private static boolean isValidJsonObjectKeyType(Type type)\n                 baseType.equals(StandardTypes.REAL) ||\n                 baseType.equals(StandardTypes.DOUBLE) ||\n                 baseType.equals(StandardTypes.DECIMAL) ||\n-                baseType.equals(StandardTypes.VARCHAR);\n+                baseType.equals(StandardTypes.VARCHAR) ||\n+                type instanceof LongEnumType ||", "originalCommit": "52cdeee359daa54038e9cdbc9adc7d410800f1a8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzgyNjIyNA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r463826224", "bodyText": "Conceptually this should not be in default... TypeSignature for enum types should work properly.", "author": "rongrong", "createdAt": "2020-07-31T20:43:14Z", "path": "presto-main/src/main/java/com/facebook/presto/util/JsonUtil.java", "diffHunk": "@@ -239,6 +250,12 @@ static ObjectKeyProvider createObjectKeyProvider(Type type)\n                 case StandardTypes.VARCHAR:\n                     return (block, position) -> type.getSlice(block, position).toStringUtf8();\n                 default:\n+                    if (type instanceof LongEnumType) {", "originalCommit": "52cdeee359daa54038e9cdbc9adc7d410800f1a8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "555ed466db30c2e0bef330ea0defb399283195d9", "url": "https://github.com/prestodb/presto/commit/555ed466db30c2e0bef330ea0defb399283195d9", "message": "Fix client-side string enum rendering", "committedDate": "2020-08-18T03:45:55Z", "type": "forcePushed"}, {"oid": "444ee9a4b2816c9cde18b4a9737c3aa0d5f750d9", "url": "https://github.com/prestodb/presto/commit/444ee9a4b2816c9cde18b4a9737c3aa0d5f750d9", "message": "Fix client-side string enum rendering", "committedDate": "2020-08-18T14:42:31Z", "type": "forcePushed"}, {"oid": "3f444ae412da626d6c552c1315629fee4a64ead7", "url": "https://github.com/prestodb/presto/commit/3f444ae412da626d6c552c1315629fee4a64ead7", "message": "Add enum operators\n\nSupport common operators like `=` on enum types", "committedDate": "2020-08-18T22:58:35Z", "type": "forcePushed"}, {"oid": "ba082183547190173c1aa873c3af3d0fafed6a26", "url": "https://github.com/prestodb/presto/commit/ba082183547190173c1aa873c3af3d0fafed6a26", "message": "Add enum operators\n\nSupport common operators like `=` on enum types", "committedDate": "2020-08-18T23:53:55Z", "type": "forcePushed"}, {"oid": "dfd4d95dbfe585c984a4c1fde39b96c2c170efdd", "url": "https://github.com/prestodb/presto/commit/dfd4d95dbfe585c984a4c1fde39b96c2c170efdd", "message": "Add enum operators\n\nSupport common operators like `=` on enum types", "committedDate": "2020-08-19T16:26:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI2ODM3NA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r473268374", "bodyText": "This is not necessary. Optional<> would be either empty (null) or non-null.", "author": "rongrong", "createdAt": "2020-08-19T19:27:43Z", "path": "presto-common/src/main/java/com/facebook/presto/common/type/TypeUtils.java", "diffHunk": "@@ -101,4 +111,28 @@ static void checkElementNotNull(boolean isNull, String errorMsg)\n             throw new NotSupportedException(errorMsg);\n         }\n     }\n+\n+    static <V> Map<String, V> normalizeEnumEntries(Optional<String> enumName, Map<String, V> entries)\n+    {\n+        enumName.ifPresent(name -> requireNonNull(name, \"Enum name cannot be null\"));", "originalCommit": "fdc4855b1d7a0acd3348b9dfe2f3a71406817c8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMwMzU4Nw==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r474303587", "bodyText": "I will actually remove this logic with the optional name altogether. this was mainly to help users with debugging but there will have to be code elsewhere to catch those errors anyway, so we can log the name of the offending enum at that point instead of here.", "author": "daniel-ohayon", "createdAt": "2020-08-20T22:19:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI2ODM3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI2OTU2MA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r473269560", "bodyText": "We usually just assume input are non-null. Usually we only check requireNonNull at constructor. Functions that expect null would use Optional. Otherwise it should not be invoked with null input.", "author": "rongrong", "createdAt": "2020-08-19T19:30:02Z", "path": "presto-common/src/main/java/com/facebook/presto/common/type/TypeUtils.java", "diffHunk": "@@ -101,4 +111,28 @@ static void checkElementNotNull(boolean isNull, String errorMsg)\n             throw new NotSupportedException(errorMsg);\n         }\n     }\n+\n+    static <V> Map<String, V> normalizeEnumEntries(Optional<String> enumName, Map<String, V> entries)\n+    {\n+        enumName.ifPresent(name -> requireNonNull(name, \"Enum name cannot be null\"));\n+        String maybeEnumName = enumName.isPresent() ? enumName + \" \" : \"\";\n+        requireNonNull(entries, \"Enum entries cannot be null\");", "originalCommit": "fdc4855b1d7a0acd3348b9dfe2f3a71406817c8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI3MDkwMQ==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r473270901", "bodyText": "Probably should check this in the constructor rather than here. Making sure the enum map is valid is the job of enum type constructor. It's fine if you want to have a separate utility function to check that. But for normalizeEnumEntries, it should just assume the input is already a valid enum.", "author": "rongrong", "createdAt": "2020-08-19T19:32:39Z", "path": "presto-common/src/main/java/com/facebook/presto/common/type/TypeUtils.java", "diffHunk": "@@ -101,4 +111,28 @@ static void checkElementNotNull(boolean isNull, String errorMsg)\n             throw new NotSupportedException(errorMsg);\n         }\n     }\n+\n+    static <V> Map<String, V> normalizeEnumEntries(Optional<String> enumName, Map<String, V> entries)\n+    {\n+        enumName.ifPresent(name -> requireNonNull(name, \"Enum name cannot be null\"));\n+        String maybeEnumName = enumName.isPresent() ? enumName + \" \" : \"\";\n+        requireNonNull(entries, \"Enum entries cannot be null\");\n+        if (entries.containsKey(null)) {", "originalCommit": "fdc4855b1d7a0acd3348b9dfe2f3a71406817c8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI3MTIyMA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r473271220", "bodyText": "Same here. Maybe you want to just add a validateEnum utility function.", "author": "rongrong", "createdAt": "2020-08-19T19:33:18Z", "path": "presto-common/src/main/java/com/facebook/presto/common/type/TypeUtils.java", "diffHunk": "@@ -101,4 +111,28 @@ static void checkElementNotNull(boolean isNull, String errorMsg)\n             throw new NotSupportedException(errorMsg);\n         }\n     }\n+\n+    static <V> Map<String, V> normalizeEnumEntries(Optional<String> enumName, Map<String, V> entries)\n+    {\n+        enumName.ifPresent(name -> requireNonNull(name, \"Enum name cannot be null\"));\n+        String maybeEnumName = enumName.isPresent() ? enumName + \" \" : \"\";\n+        requireNonNull(entries, \"Enum entries cannot be null\");\n+        if (entries.containsKey(null)) {\n+            throw new IllegalArgumentException(format(\"Enum %scannot contain null key\", enumName.isPresent() ? enumName + \" \" : \"\"));\n+        }\n+        int nUniqueAndNotNull = entries.values().stream()", "originalCommit": "fdc4855b1d7a0acd3348b9dfe2f3a71406817c8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMwMzc5MQ==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r474303791", "bodyText": "going for a separate validateEnumMap method", "author": "daniel-ohayon", "createdAt": "2020-08-20T22:20:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI3MTIyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI3MTY5Nw==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r473271697", "bodyText": "Feels that upper case makes more sense? Most enum names are defined in uppercase right?", "author": "rongrong", "createdAt": "2020-08-19T19:34:10Z", "path": "presto-common/src/main/java/com/facebook/presto/common/type/TypeUtils.java", "diffHunk": "@@ -101,4 +111,28 @@ static void checkElementNotNull(boolean isNull, String errorMsg)\n             throw new NotSupportedException(errorMsg);\n         }\n     }\n+\n+    static <V> Map<String, V> normalizeEnumEntries(Optional<String> enumName, Map<String, V> entries)\n+    {\n+        enumName.ifPresent(name -> requireNonNull(name, \"Enum name cannot be null\"));\n+        String maybeEnumName = enumName.isPresent() ? enumName + \" \" : \"\";\n+        requireNonNull(entries, \"Enum entries cannot be null\");\n+        if (entries.containsKey(null)) {\n+            throw new IllegalArgumentException(format(\"Enum %scannot contain null key\", enumName.isPresent() ? enumName + \" \" : \"\"));\n+        }\n+        int nUniqueAndNotNull = entries.values().stream()\n+                .filter(Objects::nonNull).collect(toSet()).size();\n+        if (nUniqueAndNotNull != entries.size()) {\n+            throw new IllegalArgumentException(\n+                    format(\"Enum %scannot contain null or duplicate values\", maybeEnumName));\n+        }\n+        try {\n+            return entries.entrySet().stream()\n+                    .collect(toMap(e -> e.getKey().toLowerCase(ENGLISH), Map.Entry::getValue));", "originalCommit": "fdc4855b1d7a0acd3348b9dfe2f3a71406817c8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI3MTk5NA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r473271994", "bodyText": "space after %s before cannot", "author": "rongrong", "createdAt": "2020-08-19T19:34:47Z", "path": "presto-common/src/main/java/com/facebook/presto/common/type/TypeUtils.java", "diffHunk": "@@ -101,4 +111,28 @@ static void checkElementNotNull(boolean isNull, String errorMsg)\n             throw new NotSupportedException(errorMsg);\n         }\n     }\n+\n+    static <V> Map<String, V> normalizeEnumEntries(Optional<String> enumName, Map<String, V> entries)\n+    {\n+        enumName.ifPresent(name -> requireNonNull(name, \"Enum name cannot be null\"));\n+        String maybeEnumName = enumName.isPresent() ? enumName + \" \" : \"\";\n+        requireNonNull(entries, \"Enum entries cannot be null\");\n+        if (entries.containsKey(null)) {\n+            throw new IllegalArgumentException(format(\"Enum %scannot contain null key\", enumName.isPresent() ? enumName + \" \" : \"\"));\n+        }\n+        int nUniqueAndNotNull = entries.values().stream()\n+                .filter(Objects::nonNull).collect(toSet()).size();\n+        if (nUniqueAndNotNull != entries.size()) {\n+            throw new IllegalArgumentException(\n+                    format(\"Enum %scannot contain null or duplicate values\", maybeEnumName));\n+        }\n+        try {\n+            return entries.entrySet().stream()\n+                    .collect(toMap(e -> e.getKey().toLowerCase(ENGLISH), Map.Entry::getValue));\n+        }\n+        catch (IllegalStateException e) {\n+            throw new IllegalArgumentException(\n+                    format(\"Enum %scannot contain case-insensitive duplicate keys: %s\", maybeEnumName, e.getMessage()));", "originalCommit": "fdc4855b1d7a0acd3348b9dfe2f3a71406817c8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQwNDI0Mw==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r473404243", "bodyText": "but then if the name is empty we end up with two spaces between \"Enum\" and \"cannot\" in the error msg", "author": "daniel-ohayon", "createdAt": "2020-08-19T22:50:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI3MTk5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzQyMjIwOQ==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r473422209", "bodyText": "I guess then we have to have two error messages and handle them separately.", "author": "rongrong", "createdAt": "2020-08-19T23:15:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI3MTk5NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMwMzg4Ng==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r474303886", "bodyText": "removing the optional name argument", "author": "daniel-ohayon", "createdAt": "2020-08-20T22:20:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI3MTk5NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI3MjYwMQ==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r473272601", "bodyText": "Feels like this class and the LongEnumMap should be inner class of VarcharEnumType and LongEnumType respectively (or maybe the parametric type versions). They don't make much sense as standalone classes.", "author": "rongrong", "createdAt": "2020-08-19T19:36:05Z", "path": "presto-common/src/main/java/com/facebook/presto/common/type/VarcharEnumMap.java", "diffHunk": "@@ -0,0 +1,76 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.common.type;\n+\n+import com.fasterxml.jackson.annotation.JsonCreator;\n+import com.fasterxml.jackson.annotation.JsonProperty;\n+\n+import java.util.Comparator;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import static com.facebook.presto.common.type.TypeUtils.normalizeEnumEntries;\n+import static java.lang.String.format;\n+\n+public class VarcharEnumMap", "originalCommit": "fdc4855b1d7a0acd3348b9dfe2f3a71406817c8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI3NTA5OQ==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r473275099", "bodyText": "It might be cleaner VarcharEnumType and LongEnumType should directly take VarcharEnumMap and LongEnumMap as input. That way you can wrap the validation into those classes and there's no need to validate them again.", "author": "rongrong", "createdAt": "2020-08-19T19:41:05Z", "path": "presto-common/src/main/java/com/facebook/presto/common/type/VarcharEnumType.java", "diffHunk": "@@ -0,0 +1,51 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.common.type;\n+\n+import java.util.Map;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.common.type.TypeUtils.normalizeEnumEntries;\n+import static com.facebook.presto.common.type.VarcharType.VARCHAR;\n+\n+public class VarcharEnumType\n+        extends AbstractVarcharType\n+        implements EnumType<String>\n+{\n+    private final Map<String, String> enumMap;\n+\n+    public VarcharEnumType(String name, Map<String, String> enumMap)", "originalCommit": "fdc4855b1d7a0acd3348b9dfe2f3a71406817c8c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NDMwMzk2Nw==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r474303967", "bodyText": "great idea!", "author": "daniel-ohayon", "createdAt": "2020-08-20T22:20:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI3NTA5OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3MzI4NDcyOQ==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r473284729", "bodyText": "The enum name probably should be just LONG_ENUM and VARCHAR_ENUM", "author": "rongrong", "createdAt": "2020-08-19T19:59:33Z", "path": "presto-common/src/main/java/com/facebook/presto/common/type/ParameterKind.java", "diffHunk": "@@ -23,7 +23,9 @@\n     TYPE(Optional.of(\"TYPE_SIGNATURE\")),\n     NAMED_TYPE(Optional.of(\"NAMED_TYPE_SIGNATURE\")),\n     LONG(Optional.of(\"LONG_LITERAL\")),\n-    VARIABLE(Optional.empty());\n+    VARIABLE(Optional.empty()),\n+    LONG_ENUM_MAP(Optional.of(\"LONG_ENUM_MAP\")),", "originalCommit": "fdc4855b1d7a0acd3348b9dfe2f3a71406817c8c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "1c07c547b741173ffa342d2711dd761e700af180", "url": "https://github.com/prestodb/presto/commit/1c07c547b741173ffa342d2711dd761e700af180", "message": "Add enum operators\n\nSupport common operators like `=` on enum types", "committedDate": "2020-08-20T23:07:18Z", "type": "forcePushed"}, {"oid": "90e139c1660d0bec1c24a3624e645c3a148adc06", "url": "https://github.com/prestodb/presto/commit/90e139c1660d0bec1c24a3624e645c3a148adc06", "message": "Add enum operators\n\nSupport common operators like `=` on enum types", "committedDate": "2020-08-23T23:11:50Z", "type": "forcePushed"}, {"oid": "74e8a69f115f7b89d27f0b7e995ffec38418852a", "url": "https://github.com/prestodb/presto/commit/74e8a69f115f7b89d27f0b7e995ffec38418852a", "message": "Add enum operators\n\nSupport common operators like `=` on enum types", "committedDate": "2020-08-23T23:33:09Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgxNTk1MA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r475815950", "bodyText": "Let's import the sub classes directly.", "author": "rongrong", "createdAt": "2020-08-24T18:34:27Z", "path": "presto-common/src/main/java/com/facebook/presto/common/type/TypeParameter.java", "diffHunk": "@@ -98,6 +112,16 @@ public Long getLongLiteral()\n         return getValue(ParameterKind.LONG, Long.class);\n     }\n \n+    public LongEnumType.LongEnumMap getLongEnumMap()", "originalCommit": "92554b83a8e87d842f8ed5afe8be8081cbba5d08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgxNjU4Mw==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r475816583", "bodyText": "Import subclass directly.", "author": "rongrong", "createdAt": "2020-08-24T18:35:37Z", "path": "presto-common/src/main/java/com/facebook/presto/common/type/TypeSignatureParameter.java", "diffHunk": "@@ -44,6 +44,16 @@ public static TypeSignatureParameter of(String variable)\n         return new TypeSignatureParameter(ParameterKind.VARIABLE, variable);\n     }\n \n+    public static TypeSignatureParameter of(LongEnumType.LongEnumMap enumMap)", "originalCommit": "92554b83a8e87d842f8ed5afe8be8081cbba5d08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgxNjkwNQ==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r475816905", "bodyText": "isLongEnum and isVarcharEnum maybe?", "author": "rongrong", "createdAt": "2020-08-24T18:36:16Z", "path": "presto-common/src/main/java/com/facebook/presto/common/type/TypeSignatureParameter.java", "diffHunk": "@@ -81,6 +91,16 @@ public boolean isVariable()\n         return kind == ParameterKind.VARIABLE;\n     }\n \n+    public boolean isLongEnumMap()", "originalCommit": "92554b83a8e87d842f8ed5afe8be8081cbba5d08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgxNzMwNw==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r475817307", "bodyText": "Import sub class directly.", "author": "rongrong", "createdAt": "2020-08-24T18:37:01Z", "path": "presto-common/src/test/java/com/facebook/presto/common/type/TestTypeSignature.java", "diffHunk": "@@ -289,6 +290,53 @@ public void testIsCalculated()\n         assertFalse(parseTypeSignature(\"row(a decimal(2,1),b decimal(3,2))\").isCalculated());\n     }\n \n+    @Test\n+    public void testEnumSignature()\n+    {\n+        assertEquals(\n+                parseTypeSignature(\"test_enum(enum:varchar{\\\"test\\\" :\\\"\\\"\\\"\\\", \\\"hello\\\": \\\" \\\" , \\\"a\\\":\\\"}{{\\\" })\"),\n+                new VarcharEnumType(\"test_enum\", new VarcharEnumType.VarcharEnumMap(ImmutableMap.of(\"a\", \"}{{\", \"hello\", \" \", \"test\", \"\\\"\"))).getTypeSignature());\n+\n+        assertEquals(\n+                parseTypeSignature(\"test_enum(enum:varchar{\\\"my  key\\\" :\\\"\u092e\u0942\u0932\u094d\u092f\\\"})\"),\n+                new VarcharEnumType(\"test_enum\", new VarcharEnumType.VarcharEnumMap(ImmutableMap.of(\"my  key\", \"\u092e\u0942\u0932\u094d\u092f\"))).getTypeSignature());\n+\n+        assertEquals(\n+                parseTypeSignature(\"other_enum(ENUM:bigint{\\\"hello\\\" :  -5, \\\"AaA\\\"  : 9999 })\"),\n+                new LongEnumType(\"other_enum\", new LongEnumType.LongEnumMap(ImmutableMap.of(\"hello\", -5L, \"AAA\", 9999L))).getTypeSignature());", "originalCommit": "92554b83a8e87d842f8ed5afe8be8081cbba5d08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgxNzkwMg==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r475817902", "bodyText": "Import subclass directly.", "author": "rongrong", "createdAt": "2020-08-24T18:38:14Z", "path": "presto-main/src/main/java/com/facebook/presto/type/LongEnumParametricType.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.type;\n+\n+import com.facebook.presto.common.type.LongEnumType;\n+import com.facebook.presto.common.type.ParameterKind;\n+import com.facebook.presto.common.type.ParametricType;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.common.type.TypeManager;\n+import com.facebook.presto.common.type.TypeParameter;\n+\n+import java.util.List;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+public final class LongEnumParametricType\n+        implements ParametricType\n+{\n+    private final String name;\n+    private final LongEnumType.LongEnumMap enumMap;", "originalCommit": "92554b83a8e87d842f8ed5afe8be8081cbba5d08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3NTgxODAzNg==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r475818036", "bodyText": "Import subclass directly.", "author": "rongrong", "createdAt": "2020-08-24T18:38:29Z", "path": "presto-main/src/main/java/com/facebook/presto/type/VarcharEnumParametricType.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.type;\n+\n+import com.facebook.presto.common.type.ParameterKind;\n+import com.facebook.presto.common.type.ParametricType;\n+import com.facebook.presto.common.type.Type;\n+import com.facebook.presto.common.type.TypeManager;\n+import com.facebook.presto.common.type.TypeParameter;\n+import com.facebook.presto.common.type.VarcharEnumType;\n+\n+import java.util.List;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+public final class VarcharEnumParametricType\n+        implements ParametricType\n+{\n+    private final String name;\n+    private final VarcharEnumType.VarcharEnumMap enumMap;", "originalCommit": "92554b83a8e87d842f8ed5afe8be8081cbba5d08", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "507127b5f78811e95c658a5ffc20cb1604e9908a", "url": "https://github.com/prestodb/presto/commit/507127b5f78811e95c658a5ffc20cb1604e9908a", "message": "Add long and varchar enum types", "committedDate": "2020-08-24T22:33:36Z", "type": "commit"}, {"oid": "1d6ea3bc17b47e84e5f1523a5496c32f4c59fda4", "url": "https://github.com/prestodb/presto/commit/1d6ea3bc17b47e84e5f1523a5496c32f4c59fda4", "message": "Support type bound in TypeVariableConstraint\n\nAdd an is-a constraint for type variables, so we can describe generic types of a certain kind.", "committedDate": "2020-08-24T22:33:36Z", "type": "commit"}, {"oid": "237f05b4d2c7361308b111295fceab8f78a5adb8", "url": "https://github.com/prestodb/presto/commit/237f05b4d2c7361308b111295fceab8f78a5adb8", "message": "Add enum operators\n\nSupport common operators like `=` on enum types", "committedDate": "2020-08-24T22:33:36Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1NTc0MA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r478755740", "bodyText": "This is a minor issue: Seems like you are always calling isEnumLiteral and resolveEnumLiteral together and then you can checking isEnumLiteral here again. So maybe worth have a tryResolveEnumLiteral that returns a Optional<Object> to avoid calling isEnumLiteral twice.", "author": "rongrong", "createdAt": "2020-08-27T23:49:11Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/ExpressionTreeUtils.java", "diffHunk": "@@ -112,4 +123,45 @@ public static boolean isEqualComparisonExpression(Expression expression)\n     {\n         return expression instanceof ComparisonExpression && ((ComparisonExpression) expression).getOperator() == ComparisonExpression.Operator.EQUAL;\n     }\n+\n+    static Optional<EnumType> tryResolveEnumLiteralType(QualifiedName qualifiedName, TypeManager typeManager)\n+    {\n+        Optional<QualifiedName> prefix = qualifiedName.getPrefix();\n+        if (!prefix.isPresent()) {\n+            // an enum literal should be of the form `MyEnum.my_key`\n+            return Optional.empty();\n+        }\n+        try {\n+            Type baseType = typeManager.getType(parseTypeSignature(prefix.get().toString()));\n+            if (baseType instanceof EnumType) {\n+                return Optional.of((EnumType) baseType);\n+            }\n+        }\n+        catch (IllegalArgumentException e) {\n+            return Optional.empty();\n+        }\n+        return Optional.empty();\n+    }\n+\n+    public static boolean isEnumLiteral(DereferenceExpression node, Type nodeType)\n+    {\n+        if (!(nodeType instanceof EnumType)) {\n+            return false;\n+        }\n+        QualifiedName qualifiedName = DereferenceExpression.getQualifiedName(node);\n+        requireNonNull(qualifiedName, \"qualifiedName is null\");\n+        Optional<QualifiedName> prefix = qualifiedName.getPrefix();\n+        return prefix.isPresent()\n+                && prefix.get().toString().equalsIgnoreCase(nodeType.getTypeSignature().getBase());\n+    }\n+\n+    public static Object resolveEnumLiteral(DereferenceExpression node, EnumType enumType)\n+    {\n+        QualifiedName qualifiedName = DereferenceExpression.getQualifiedName(node);\n+        checkArgument(qualifiedName != null && isEnumLiteral(node, enumType), \"Node is not an enum literal\");", "originalCommit": "bfea2539fc64a95cb178adac62412b7b722b9e38", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTMzMDUzMA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r479330530", "bodyText": "ha that's what I was doing before and you told me to change it to a precondition check \ud83d\ude06 \u2013 changing back", "author": "daniel-ohayon", "createdAt": "2020-08-28T14:12:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1NTc0MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3MjQ5MA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r479472490", "bodyText": "Ya, i kinda feel like i probably suggested this \ud83e\udd26\u200d\u2640\ufe0f. You can keep the isEnumLiteral function. This is more to suggest to only call 1 function at the call sites rather than changing this implementation (other than changing the return type to optional).", "author": "rongrong", "createdAt": "2020-08-28T18:35:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1NTc0MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1NjI0NQ==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r478756245", "bodyText": "Maybe you can incorporate this into the switch (baseType) part now?", "author": "rongrong", "createdAt": "2020-08-27T23:50:59Z", "path": "presto-main/src/main/java/com/facebook/presto/util/JsonUtil.java", "diffHunk": "@@ -211,7 +221,14 @@ private static boolean isValidJsonObjectKeyType(Type type)\n \n         static ObjectKeyProvider createObjectKeyProvider(Type type)\n         {\n-            String baseType = type.getTypeSignature().getBase();\n+            TypeSignature signature = type.getTypeSignature();\n+            String baseType = signature.getBase();\n+            if (signature.isLongEnum()) {", "originalCommit": "237f05b4d2c7361308b111295fceab8f78a5adb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTM0MTIyOA==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r479341228", "bodyText": "how do you mean? inside the default case?", "author": "daniel-ohayon", "createdAt": "2020-08-28T14:26:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1NjI0NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3NTQxNQ==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r479475415", "bodyText": "Oh nvm, I thought now the baseType would have \"enum\" in it.", "author": "rongrong", "createdAt": "2020-08-28T18:42:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1NjI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1Njc3Mg==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r478756772", "bodyText": "Can we add tests for all enum operators?", "author": "rongrong", "createdAt": "2020-08-27T23:52:49Z", "path": "presto-main/src/main/java/com/facebook/presto/type/VarcharEnumOperators.java", "diffHunk": "@@ -0,0 +1,143 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.type;\n+\n+import com.facebook.presto.common.type.StandardTypes;\n+import com.facebook.presto.common.type.VarcharEnumType;\n+import com.facebook.presto.spi.function.IsNull;\n+import com.facebook.presto.spi.function.ScalarOperator;\n+import com.facebook.presto.spi.function.SqlNullable;\n+import com.facebook.presto.spi.function.SqlType;\n+import com.facebook.presto.spi.function.TypeParameter;\n+import io.airlift.slice.Slice;\n+import io.airlift.slice.XxHash64;\n+\n+import static com.facebook.presto.common.function.OperatorType.BETWEEN;\n+import static com.facebook.presto.common.function.OperatorType.EQUAL;\n+import static com.facebook.presto.common.function.OperatorType.GREATER_THAN;\n+import static com.facebook.presto.common.function.OperatorType.GREATER_THAN_OR_EQUAL;\n+import static com.facebook.presto.common.function.OperatorType.HASH_CODE;\n+import static com.facebook.presto.common.function.OperatorType.INDETERMINATE;\n+import static com.facebook.presto.common.function.OperatorType.IS_DISTINCT_FROM;\n+import static com.facebook.presto.common.function.OperatorType.LESS_THAN;\n+import static com.facebook.presto.common.function.OperatorType.LESS_THAN_OR_EQUAL;\n+import static com.facebook.presto.common.function.OperatorType.NOT_EQUAL;\n+import static com.facebook.presto.common.function.OperatorType.XX_HASH_64;\n+import static com.facebook.presto.common.type.StandardTypes.BIGINT;\n+import static com.facebook.presto.common.type.StandardTypes.BOOLEAN;\n+\n+public final class VarcharEnumOperators", "originalCommit": "237f05b4d2c7361308b111295fceab8f78a5adb8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQxMTY2Mg==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r479411662", "bodyText": "done!", "author": "daniel-ohayon", "createdAt": "2020-08-28T16:29:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3ODc1Njc3Mg=="}], "type": "inlineReview"}, {"oid": "252b098a3bff2d78a8d93f0975655bcf8644e041", "url": "https://github.com/prestodb/presto/commit/252b098a3bff2d78a8d93f0975655bcf8644e041", "message": "Add enum operators\n\nSupport common operators like `=` on enum types", "committedDate": "2020-08-28T16:28:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ3OTQ3ODA1Ng==", "url": "https://github.com/prestodb/presto/pull/14728#discussion_r479478056", "bodyText": "You can remove this. the isEnumLiteral function already checks this. Or move it after the if statement.", "author": "rongrong", "createdAt": "2020-08-28T18:47:57Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/ExpressionTreeUtils.java", "diffHunk": "@@ -112,4 +123,49 @@ public static boolean isEqualComparisonExpression(Expression expression)\n     {\n         return expression instanceof ComparisonExpression && ((ComparisonExpression) expression).getOperator() == ComparisonExpression.Operator.EQUAL;\n     }\n+\n+    static Optional<EnumType> tryResolveEnumLiteralType(QualifiedName qualifiedName, TypeManager typeManager)\n+    {\n+        Optional<QualifiedName> prefix = qualifiedName.getPrefix();\n+        if (!prefix.isPresent()) {\n+            // an enum literal should be of the form `MyEnum.my_key`\n+            return Optional.empty();\n+        }\n+        try {\n+            Type baseType = typeManager.getType(parseTypeSignature(prefix.get().toString()));\n+            if (baseType instanceof EnumType) {\n+                return Optional.of((EnumType) baseType);\n+            }\n+        }\n+        catch (IllegalArgumentException e) {\n+            return Optional.empty();\n+        }\n+        return Optional.empty();\n+    }\n+\n+    private static boolean isEnumLiteral(DereferenceExpression node, Type nodeType)\n+    {\n+        if (!(nodeType instanceof EnumType)) {\n+            return false;\n+        }\n+        QualifiedName qualifiedName = DereferenceExpression.getQualifiedName(node);\n+        requireNonNull(qualifiedName, \"qualifiedName is null\");\n+        Optional<QualifiedName> prefix = qualifiedName.getPrefix();\n+        return prefix.isPresent()\n+                && prefix.get().toString().equalsIgnoreCase(nodeType.getTypeSignature().getBase());\n+    }\n+\n+    public static Optional<Object> tryResolveEnumLiteral(DereferenceExpression node, Type nodeType)\n+    {\n+        QualifiedName qualifiedName = DereferenceExpression.getQualifiedName(node);\n+        checkArgument(qualifiedName != null, \"qualifiedName is null\");", "originalCommit": "252b098a3bff2d78a8d93f0975655bcf8644e041", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "db53af7c6c56e69b74da0b59826b326ccec635cd", "url": "https://github.com/prestodb/presto/commit/db53af7c6c56e69b74da0b59826b326ccec635cd", "message": "Support enum literals in queries", "committedDate": "2020-08-28T19:48:36Z", "type": "commit"}, {"oid": "4a60a66b37c12719c9ec46b00de9063de8da221f", "url": "https://github.com/prestodb/presto/commit/4a60a66b37c12719c9ec46b00de9063de8da221f", "message": "Add enum operators\n\nSupport common operators like `=` on enum types", "committedDate": "2020-08-28T19:48:36Z", "type": "commit"}, {"oid": "4a60a66b37c12719c9ec46b00de9063de8da221f", "url": "https://github.com/prestodb/presto/commit/4a60a66b37c12719c9ec46b00de9063de8da221f", "message": "Add enum operators\n\nSupport common operators like `=` on enum types", "committedDate": "2020-08-28T19:48:36Z", "type": "forcePushed"}]}