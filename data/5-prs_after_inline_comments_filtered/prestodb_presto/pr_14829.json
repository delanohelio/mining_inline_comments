{"pr_number": 14829, "pr_title": "Pushdown dereference", "pr_createdAt": "2020-07-10T23:56:15Z", "pr_url": "https://github.com/prestodb/presto/pull/14829", "timeline": [{"oid": "ef42097370cd6ac120c960a690dd7fb98a19e43d", "url": "https://github.com/prestodb/presto/commit/ef42097370cd6ac120c960a690dd7fb98a19e43d", "message": "Add session property to enable dereference pushdown", "committedDate": "2020-07-11T13:24:56Z", "type": "forcePushed"}, {"oid": "079a57889335ec1213117cb6875422854b034303", "url": "https://github.com/prestodb/presto/commit/079a57889335ec1213117cb6875422854b034303", "message": "Add session property to enable dereference pushdown", "committedDate": "2020-07-11T20:35:39Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA4NTM3OQ==", "url": "https://github.com/prestodb/presto/pull/14829#discussion_r461085379", "bodyText": "Does this rule have to live above TranslateExpressions? If possible, we can have it between TranslateExpressions and AddExchange", "author": "highker", "createdAt": "2020-07-27T18:26:59Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/PlanOptimizers.java", "diffHunk": "@@ -365,6 +366,13 @@ public PlanOptimizers(\n                                 new TransformCorrelatedSingleRowSubqueryToProject())),\n                 new CheckSubqueryNodesAreRewritten(),\n                 predicatePushDown,\n+                new IterativeOptimizer(", "originalCommit": "965febd50c76cc59b4a3215d651be02abd1910af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM1OTM1Mg==", "url": "https://github.com/prestodb/presto/pull/14829#discussion_r461359352", "bodyText": "yep, intended to be above TranslateExpressions. Use OriginalExpressionUtils.", "author": "zhenxiao", "createdAt": "2020-07-28T06:56:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA4NTM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM2MDE0NA==", "url": "https://github.com/prestodb/presto/pull/14829#discussion_r461360144", "bodyText": "But why? Any other specific rule it has to run after?", "author": "highker", "createdAt": "2020-07-28T06:58:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA4NTM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTM5MjQ4OA==", "url": "https://github.com/prestodb/presto/pull/14829#discussion_r461392488", "bodyText": "ah...this work started long time ago, before TranslateExpressions introduced. When porting it to current code,  the implementation is based on OriginalExpressionUtils cast", "author": "zhenxiao", "createdAt": "2020-07-28T08:00:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA4NTM3OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MjU2NzcwNA==", "url": "https://github.com/prestodb/presto/pull/14829#discussion_r462567704", "bodyText": "Can we have this patch written in RowExpression only? Check #14914", "author": "highker", "createdAt": "2020-07-29T20:27:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MTA4NTM3OQ=="}], "type": "inlineReview"}, {"oid": "dfd615cf1910c67f54b7b597d34b4b226d3d04a5", "url": "https://github.com/prestodb/presto/commit/dfd615cf1910c67f54b7b597d34b4b226d3d04a5", "message": "Add session property to enable dereference pushdown", "committedDate": "2020-07-29T18:48:55Z", "type": "forcePushed"}, {"oid": "14e00f7f10b6dda96d61923619b0f0c50609f07d", "url": "https://github.com/prestodb/presto/commit/14e00f7f10b6dda96d61923619b0f0c50609f07d", "message": "Push down dereference expression\n\nCherry-pick of https://github.com/prestosql/presto/commit/69ef6824dc7d1c42b7912ee4c50be55780042f09\n\nCo-authored-by: qqibrow <qqibrow@gmail.com>\nCo-authored-by: Pratham Desai <prathamd94@gmail.com>", "committedDate": "2020-07-29T23:21:17Z", "type": "commit"}, {"oid": "8b86d35cb6ea41b6610aa8eacf0bfe5c1043bf97", "url": "https://github.com/prestodb/presto/commit/8b86d35cb6ea41b6610aa8eacf0bfe5c1043bf97", "message": "Add session property to enable dereference pushdown", "committedDate": "2020-07-29T23:21:28Z", "type": "commit"}, {"oid": "f896b32aeb9585bbc38e52177e2c158c71d731ea", "url": "https://github.com/prestodb/presto/commit/f896b32aeb9585bbc38e52177e2c158c71d731ea", "message": "Move dereference pushdown below TranslateExpressions", "committedDate": "2020-07-30T09:36:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkxOTk5NQ==", "url": "https://github.com/prestodb/presto/pull/14829#discussion_r463919995", "bodyText": "unused", "author": "highker", "createdAt": "2020-08-01T04:24:53Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/iterative/rule/PushDownDereferences.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.planner.iterative.rule;\n+\n+import com.facebook.presto.Session;\n+import com.facebook.presto.expressions.DefaultRowExpressionTraversalVisitor;\n+import com.facebook.presto.expressions.RowExpressionRewriter;\n+import com.facebook.presto.expressions.RowExpressionTreeRewriter;\n+import com.facebook.presto.matching.Capture;\n+import com.facebook.presto.matching.Captures;\n+import com.facebook.presto.matching.Pattern;\n+import com.facebook.presto.metadata.Metadata;\n+import com.facebook.presto.spi.plan.Assignments;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.LimitNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TopNNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.SpecialFormExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.sql.planner.iterative.Rule;\n+import com.facebook.presto.sql.planner.iterative.Rule.Context;\n+import com.facebook.presto.sql.planner.plan.AssignUniqueId;\n+import com.facebook.presto.sql.planner.plan.JoinNode;\n+import com.facebook.presto.sql.planner.plan.RowNumberNode;\n+import com.facebook.presto.sql.planner.plan.SemiJoinNode;\n+import com.facebook.presto.sql.planner.plan.SortNode;\n+import com.facebook.presto.sql.planner.plan.TopNRowNumberNode;\n+import com.facebook.presto.sql.planner.plan.UnnestNode;\n+import com.facebook.presto.sql.planner.plan.WindowNode;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static com.facebook.presto.SystemSessionProperties.isPushdownDereferenceEnabled;\n+import static com.facebook.presto.expressions.RowExpressionTreeRewriter.rewriteWith;\n+import static com.facebook.presto.matching.Capture.newCapture;\n+import static com.facebook.presto.spi.relation.SpecialFormExpression.Form.DEREFERENCE;\n+import static com.facebook.presto.sql.planner.ExpressionExtractor.extractExpressionsNonRecursive;\n+import static com.facebook.presto.sql.planner.VariablesExtractor.extractAll;\n+import static com.facebook.presto.sql.planner.plan.AssignmentUtils.identityAssignments;\n+import static com.facebook.presto.sql.planner.plan.Patterns.join;\n+import static com.facebook.presto.sql.planner.plan.Patterns.project;\n+import static com.facebook.presto.sql.planner.plan.Patterns.semiJoin;\n+import static com.facebook.presto.sql.planner.plan.Patterns.source;\n+import static com.facebook.presto.sql.planner.plan.Patterns.unnest;\n+import static com.facebook.presto.sql.tree.ExpressionTreeRewriter.rewriteWith;", "originalCommit": "f896b32aeb9585bbc38e52177e2c158c71d731ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkyMDA4Ng==", "url": "https://github.com/prestodb/presto/pull/14829#discussion_r463920086", "bodyText": "Map.Entry::getValue", "author": "highker", "createdAt": "2020-08-01T04:25:57Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/iterative/rule/PushDownDereferences.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.planner.iterative.rule;\n+\n+import com.facebook.presto.Session;\n+import com.facebook.presto.expressions.DefaultRowExpressionTraversalVisitor;\n+import com.facebook.presto.expressions.RowExpressionRewriter;\n+import com.facebook.presto.expressions.RowExpressionTreeRewriter;\n+import com.facebook.presto.matching.Capture;\n+import com.facebook.presto.matching.Captures;\n+import com.facebook.presto.matching.Pattern;\n+import com.facebook.presto.metadata.Metadata;\n+import com.facebook.presto.spi.plan.Assignments;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.LimitNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TopNNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.SpecialFormExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.sql.planner.iterative.Rule;\n+import com.facebook.presto.sql.planner.iterative.Rule.Context;\n+import com.facebook.presto.sql.planner.plan.AssignUniqueId;\n+import com.facebook.presto.sql.planner.plan.JoinNode;\n+import com.facebook.presto.sql.planner.plan.RowNumberNode;\n+import com.facebook.presto.sql.planner.plan.SemiJoinNode;\n+import com.facebook.presto.sql.planner.plan.SortNode;\n+import com.facebook.presto.sql.planner.plan.TopNRowNumberNode;\n+import com.facebook.presto.sql.planner.plan.UnnestNode;\n+import com.facebook.presto.sql.planner.plan.WindowNode;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static com.facebook.presto.SystemSessionProperties.isPushdownDereferenceEnabled;\n+import static com.facebook.presto.expressions.RowExpressionTreeRewriter.rewriteWith;\n+import static com.facebook.presto.matching.Capture.newCapture;\n+import static com.facebook.presto.spi.relation.SpecialFormExpression.Form.DEREFERENCE;\n+import static com.facebook.presto.sql.planner.ExpressionExtractor.extractExpressionsNonRecursive;\n+import static com.facebook.presto.sql.planner.VariablesExtractor.extractAll;\n+import static com.facebook.presto.sql.planner.plan.AssignmentUtils.identityAssignments;\n+import static com.facebook.presto.sql.planner.plan.Patterns.join;\n+import static com.facebook.presto.sql.planner.plan.Patterns.project;\n+import static com.facebook.presto.sql.planner.plan.Patterns.semiJoin;\n+import static com.facebook.presto.sql.planner.plan.Patterns.source;\n+import static com.facebook.presto.sql.planner.plan.Patterns.unnest;\n+import static com.facebook.presto.sql.tree.ExpressionTreeRewriter.rewriteWith;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Push down dereferences as follows:\n+ * <p>\n+ * Extract dereferences from PlanNode which has expressions\n+ * and push them down to a new ProjectNode right below the PlanNode.\n+ * After this step, All dereferences will be in ProjectNode.\n+ * <p>\n+ * Pushdown dereferences in ProjectNode down through other types of PlanNode,\n+ * e.g, Filter, Join etc.\n+ */\n+public class PushDownDereferences\n+{\n+    private final Metadata metadata;\n+\n+    public PushDownDereferences(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+    }\n+\n+    public Set<Rule<?>> rules()\n+    {\n+        return ImmutableSet.of(\n+                new ExtractFromFilter(),\n+                new ExtractFromJoin(),\n+                new PushDownDereferenceThrough<>(AssignUniqueId.class),\n+                new PushDownDereferenceThrough<>(WindowNode.class),\n+                new PushDownDereferenceThrough<>(TopNNode.class),\n+                new PushDownDereferenceThrough<>(RowNumberNode.class),\n+                new PushDownDereferenceThrough<>(TopNRowNumberNode.class),\n+                new PushDownDereferenceThrough<>(SortNode.class),\n+                new PushDownDereferenceThrough<>(FilterNode.class),\n+                new PushDownDereferenceThrough<>(LimitNode.class),\n+                new PushDownDereferenceThroughProject(),\n+                new PushDownDereferenceThroughUnnest(),\n+                new PushDownDereferenceThroughSemiJoin(),\n+                new PushDownDereferenceThroughJoin());\n+    }\n+\n+    /**\n+     * Extract dereferences and push them down to new ProjectNode below\n+     * Transforms:\n+     * <pre>\n+     *  TargetNode(expression(a.x))\n+     *  </pre>\n+     * to:\n+     * <pre>\n+     *   ProjectNode(original symbols)\n+     *    TargetNode(expression(symbol))\n+     *      Project(symbol := a.x)\n+     * </pre>\n+     */\n+    abstract class ExtractProjectDereferences<N extends PlanNode>\n+            implements Rule<N>\n+    {\n+        private final Class<N> planNodeClass;\n+\n+        ExtractProjectDereferences(Class<N> planNodeClass)\n+        {\n+            this.planNodeClass = planNodeClass;\n+        }\n+\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isPushdownDereferenceEnabled(session);\n+        }\n+\n+        @Override\n+        public Pattern<N> getPattern()\n+        {\n+            return Pattern.typeOf(planNodeClass);\n+        }\n+\n+        @Override\n+        public Result apply(N node, Captures captures, Context context)\n+        {\n+            Map<SpecialFormExpression, VariableReferenceExpression> expressions =\n+                    getDereferenceSymbolMap(extractExpressionsNonRecursive(node), context, metadata);\n+\n+            if (expressions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            return Result.ofPlanNode(new ProjectNode(context.getIdAllocator().getNextId(), rewrite(context, node, HashBiMap.create(expressions)), identityAssignments(node.getOutputVariables())));\n+        }\n+\n+        protected abstract N rewrite(Context context, N node, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions);\n+    }\n+\n+    class ExtractFromFilter\n+            extends ExtractProjectDereferences<FilterNode>\n+    {\n+        ExtractFromFilter()\n+        {\n+            super(FilterNode.class);\n+        }\n+\n+        @Override\n+        protected FilterNode rewrite(Context context, FilterNode node, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions)\n+        {\n+            PlanNode source = node.getSource();\n+\n+            Map<VariableReferenceExpression, RowExpression> dereferencesMap = expressions.inverse().entrySet().stream()\n+                    .collect(toImmutableMap(Map.Entry::getKey, entry -> entry.getValue()));", "originalCommit": "f896b32aeb9585bbc38e52177e2c158c71d731ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkyMDE0OQ==", "url": "https://github.com/prestodb/presto/pull/14829#discussion_r463920149", "bodyText": "childSourceVariables", "author": "highker", "createdAt": "2020-08-01T04:26:41Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/iterative/rule/PushDownDereferences.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.planner.iterative.rule;\n+\n+import com.facebook.presto.Session;\n+import com.facebook.presto.expressions.DefaultRowExpressionTraversalVisitor;\n+import com.facebook.presto.expressions.RowExpressionRewriter;\n+import com.facebook.presto.expressions.RowExpressionTreeRewriter;\n+import com.facebook.presto.matching.Capture;\n+import com.facebook.presto.matching.Captures;\n+import com.facebook.presto.matching.Pattern;\n+import com.facebook.presto.metadata.Metadata;\n+import com.facebook.presto.spi.plan.Assignments;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.LimitNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TopNNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.SpecialFormExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.sql.planner.iterative.Rule;\n+import com.facebook.presto.sql.planner.iterative.Rule.Context;\n+import com.facebook.presto.sql.planner.plan.AssignUniqueId;\n+import com.facebook.presto.sql.planner.plan.JoinNode;\n+import com.facebook.presto.sql.planner.plan.RowNumberNode;\n+import com.facebook.presto.sql.planner.plan.SemiJoinNode;\n+import com.facebook.presto.sql.planner.plan.SortNode;\n+import com.facebook.presto.sql.planner.plan.TopNRowNumberNode;\n+import com.facebook.presto.sql.planner.plan.UnnestNode;\n+import com.facebook.presto.sql.planner.plan.WindowNode;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static com.facebook.presto.SystemSessionProperties.isPushdownDereferenceEnabled;\n+import static com.facebook.presto.expressions.RowExpressionTreeRewriter.rewriteWith;\n+import static com.facebook.presto.matching.Capture.newCapture;\n+import static com.facebook.presto.spi.relation.SpecialFormExpression.Form.DEREFERENCE;\n+import static com.facebook.presto.sql.planner.ExpressionExtractor.extractExpressionsNonRecursive;\n+import static com.facebook.presto.sql.planner.VariablesExtractor.extractAll;\n+import static com.facebook.presto.sql.planner.plan.AssignmentUtils.identityAssignments;\n+import static com.facebook.presto.sql.planner.plan.Patterns.join;\n+import static com.facebook.presto.sql.planner.plan.Patterns.project;\n+import static com.facebook.presto.sql.planner.plan.Patterns.semiJoin;\n+import static com.facebook.presto.sql.planner.plan.Patterns.source;\n+import static com.facebook.presto.sql.planner.plan.Patterns.unnest;\n+import static com.facebook.presto.sql.tree.ExpressionTreeRewriter.rewriteWith;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Push down dereferences as follows:\n+ * <p>\n+ * Extract dereferences from PlanNode which has expressions\n+ * and push them down to a new ProjectNode right below the PlanNode.\n+ * After this step, All dereferences will be in ProjectNode.\n+ * <p>\n+ * Pushdown dereferences in ProjectNode down through other types of PlanNode,\n+ * e.g, Filter, Join etc.\n+ */\n+public class PushDownDereferences\n+{\n+    private final Metadata metadata;\n+\n+    public PushDownDereferences(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+    }\n+\n+    public Set<Rule<?>> rules()\n+    {\n+        return ImmutableSet.of(\n+                new ExtractFromFilter(),\n+                new ExtractFromJoin(),\n+                new PushDownDereferenceThrough<>(AssignUniqueId.class),\n+                new PushDownDereferenceThrough<>(WindowNode.class),\n+                new PushDownDereferenceThrough<>(TopNNode.class),\n+                new PushDownDereferenceThrough<>(RowNumberNode.class),\n+                new PushDownDereferenceThrough<>(TopNRowNumberNode.class),\n+                new PushDownDereferenceThrough<>(SortNode.class),\n+                new PushDownDereferenceThrough<>(FilterNode.class),\n+                new PushDownDereferenceThrough<>(LimitNode.class),\n+                new PushDownDereferenceThroughProject(),\n+                new PushDownDereferenceThroughUnnest(),\n+                new PushDownDereferenceThroughSemiJoin(),\n+                new PushDownDereferenceThroughJoin());\n+    }\n+\n+    /**\n+     * Extract dereferences and push them down to new ProjectNode below\n+     * Transforms:\n+     * <pre>\n+     *  TargetNode(expression(a.x))\n+     *  </pre>\n+     * to:\n+     * <pre>\n+     *   ProjectNode(original symbols)\n+     *    TargetNode(expression(symbol))\n+     *      Project(symbol := a.x)\n+     * </pre>\n+     */\n+    abstract class ExtractProjectDereferences<N extends PlanNode>\n+            implements Rule<N>\n+    {\n+        private final Class<N> planNodeClass;\n+\n+        ExtractProjectDereferences(Class<N> planNodeClass)\n+        {\n+            this.planNodeClass = planNodeClass;\n+        }\n+\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isPushdownDereferenceEnabled(session);\n+        }\n+\n+        @Override\n+        public Pattern<N> getPattern()\n+        {\n+            return Pattern.typeOf(planNodeClass);\n+        }\n+\n+        @Override\n+        public Result apply(N node, Captures captures, Context context)\n+        {\n+            Map<SpecialFormExpression, VariableReferenceExpression> expressions =\n+                    getDereferenceSymbolMap(extractExpressionsNonRecursive(node), context, metadata);\n+\n+            if (expressions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            return Result.ofPlanNode(new ProjectNode(context.getIdAllocator().getNextId(), rewrite(context, node, HashBiMap.create(expressions)), identityAssignments(node.getOutputVariables())));\n+        }\n+\n+        protected abstract N rewrite(Context context, N node, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions);\n+    }\n+\n+    class ExtractFromFilter\n+            extends ExtractProjectDereferences<FilterNode>\n+    {\n+        ExtractFromFilter()\n+        {\n+            super(FilterNode.class);\n+        }\n+\n+        @Override\n+        protected FilterNode rewrite(Context context, FilterNode node, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions)\n+        {\n+            PlanNode source = node.getSource();\n+\n+            Map<VariableReferenceExpression, RowExpression> dereferencesMap = expressions.inverse().entrySet().stream()\n+                    .collect(toImmutableMap(Map.Entry::getKey, entry -> entry.getValue()));\n+            Assignments assignments = Assignments.builder()\n+                    .putAll(identityAssignments(source.getOutputVariables()))\n+                    .putAll(dereferencesMap)\n+                    .build();\n+            ProjectNode projectNode = new ProjectNode(context.getIdAllocator().getNextId(), source, assignments);\n+            return new FilterNode(\n+                    context.getIdAllocator().getNextId(),\n+                    projectNode,\n+                    replaceDereferences(node.getPredicate(), expressions));\n+        }\n+    }\n+\n+    class ExtractFromJoin\n+            extends ExtractProjectDereferences<JoinNode>\n+    {\n+        ExtractFromJoin()\n+        {\n+            super(JoinNode.class);\n+        }\n+\n+        @Override\n+        protected JoinNode rewrite(Context context, JoinNode joinNode, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions)\n+        {\n+            Assignments.Builder leftSideDereferences = Assignments.builder();\n+            Assignments.Builder rightSideDereferences = Assignments.builder();\n+\n+            for (Map.Entry<VariableReferenceExpression, SpecialFormExpression> entry : expressions.inverse().entrySet()) {\n+                VariableReferenceExpression baseVariable = getBase(entry.getValue());\n+                if (joinNode.getLeft().getOutputVariables().contains(baseVariable)) {\n+                    leftSideDereferences.put(entry.getKey(), entry.getValue());\n+                }\n+                else {\n+                    rightSideDereferences.put(entry.getKey(), entry.getValue());\n+                }\n+            }\n+            PlanNode leftNode = createProject(joinNode.getLeft(), leftSideDereferences.build(), context.getIdAllocator());\n+            PlanNode rightNode = createProject(joinNode.getRight(), rightSideDereferences.build(), context.getIdAllocator());\n+\n+            return new JoinNode(\n+                    context.getIdAllocator().getNextId(),\n+                    joinNode.getType(),\n+                    leftNode,\n+                    rightNode,\n+                    joinNode.getCriteria(),\n+                    ImmutableList.<VariableReferenceExpression>builder()\n+                            .addAll(leftNode.getOutputVariables())\n+                            .addAll(rightNode.getOutputVariables())\n+                            .build(),\n+                    joinNode.getFilter().map(expression -> replaceDereferences(expression, expressions)),\n+                    joinNode.getLeftHashVariable(),\n+                    joinNode.getRightHashVariable(),\n+                    joinNode.getDistributionType());\n+        }\n+    }\n+\n+    /**\n+     * Push down dereferences from ProjectNode to child nodes if possible\n+     */\n+    private abstract class PushdownDereferencesInProject<N extends PlanNode>\n+            implements Rule<ProjectNode>\n+    {\n+        private final Capture<N> targetCapture = newCapture();\n+        private final Pattern<N> targetPattern;\n+\n+        protected PushdownDereferencesInProject(Pattern<N> targetPattern)\n+        {\n+            this.targetPattern = requireNonNull(targetPattern, \"targetPattern is null\");\n+        }\n+\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isPushdownDereferenceEnabled(session);\n+        }\n+\n+        @Override\n+        public Pattern<ProjectNode> getPattern()\n+        {\n+            return project().with(source().matching(targetPattern.capturedAs(targetCapture)));\n+        }\n+\n+        @Override\n+        public Result apply(ProjectNode node, Captures captures, Context context)\n+        {\n+            N child = captures.get(targetCapture);\n+            Map<SpecialFormExpression, VariableReferenceExpression> allDereferencesInProject = getDereferenceSymbolMap(node.getAssignments().getExpressions(), context, metadata);\n+\n+            Set<VariableReferenceExpression> childSourceSymbols = child.getSources().stream()", "originalCommit": "f896b32aeb9585bbc38e52177e2c158c71d731ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkyMDIwMg==", "url": "https://github.com/prestodb/presto/pull/14829#discussion_r463920202", "bodyText": "same", "author": "highker", "createdAt": "2020-08-01T04:27:22Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/iterative/rule/PushDownDereferences.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.planner.iterative.rule;\n+\n+import com.facebook.presto.Session;\n+import com.facebook.presto.expressions.DefaultRowExpressionTraversalVisitor;\n+import com.facebook.presto.expressions.RowExpressionRewriter;\n+import com.facebook.presto.expressions.RowExpressionTreeRewriter;\n+import com.facebook.presto.matching.Capture;\n+import com.facebook.presto.matching.Captures;\n+import com.facebook.presto.matching.Pattern;\n+import com.facebook.presto.metadata.Metadata;\n+import com.facebook.presto.spi.plan.Assignments;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.LimitNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TopNNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.SpecialFormExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.sql.planner.iterative.Rule;\n+import com.facebook.presto.sql.planner.iterative.Rule.Context;\n+import com.facebook.presto.sql.planner.plan.AssignUniqueId;\n+import com.facebook.presto.sql.planner.plan.JoinNode;\n+import com.facebook.presto.sql.planner.plan.RowNumberNode;\n+import com.facebook.presto.sql.planner.plan.SemiJoinNode;\n+import com.facebook.presto.sql.planner.plan.SortNode;\n+import com.facebook.presto.sql.planner.plan.TopNRowNumberNode;\n+import com.facebook.presto.sql.planner.plan.UnnestNode;\n+import com.facebook.presto.sql.planner.plan.WindowNode;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static com.facebook.presto.SystemSessionProperties.isPushdownDereferenceEnabled;\n+import static com.facebook.presto.expressions.RowExpressionTreeRewriter.rewriteWith;\n+import static com.facebook.presto.matching.Capture.newCapture;\n+import static com.facebook.presto.spi.relation.SpecialFormExpression.Form.DEREFERENCE;\n+import static com.facebook.presto.sql.planner.ExpressionExtractor.extractExpressionsNonRecursive;\n+import static com.facebook.presto.sql.planner.VariablesExtractor.extractAll;\n+import static com.facebook.presto.sql.planner.plan.AssignmentUtils.identityAssignments;\n+import static com.facebook.presto.sql.planner.plan.Patterns.join;\n+import static com.facebook.presto.sql.planner.plan.Patterns.project;\n+import static com.facebook.presto.sql.planner.plan.Patterns.semiJoin;\n+import static com.facebook.presto.sql.planner.plan.Patterns.source;\n+import static com.facebook.presto.sql.planner.plan.Patterns.unnest;\n+import static com.facebook.presto.sql.tree.ExpressionTreeRewriter.rewriteWith;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Push down dereferences as follows:\n+ * <p>\n+ * Extract dereferences from PlanNode which has expressions\n+ * and push them down to a new ProjectNode right below the PlanNode.\n+ * After this step, All dereferences will be in ProjectNode.\n+ * <p>\n+ * Pushdown dereferences in ProjectNode down through other types of PlanNode,\n+ * e.g, Filter, Join etc.\n+ */\n+public class PushDownDereferences\n+{\n+    private final Metadata metadata;\n+\n+    public PushDownDereferences(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+    }\n+\n+    public Set<Rule<?>> rules()\n+    {\n+        return ImmutableSet.of(\n+                new ExtractFromFilter(),\n+                new ExtractFromJoin(),\n+                new PushDownDereferenceThrough<>(AssignUniqueId.class),\n+                new PushDownDereferenceThrough<>(WindowNode.class),\n+                new PushDownDereferenceThrough<>(TopNNode.class),\n+                new PushDownDereferenceThrough<>(RowNumberNode.class),\n+                new PushDownDereferenceThrough<>(TopNRowNumberNode.class),\n+                new PushDownDereferenceThrough<>(SortNode.class),\n+                new PushDownDereferenceThrough<>(FilterNode.class),\n+                new PushDownDereferenceThrough<>(LimitNode.class),\n+                new PushDownDereferenceThroughProject(),\n+                new PushDownDereferenceThroughUnnest(),\n+                new PushDownDereferenceThroughSemiJoin(),\n+                new PushDownDereferenceThroughJoin());\n+    }\n+\n+    /**\n+     * Extract dereferences and push them down to new ProjectNode below\n+     * Transforms:\n+     * <pre>\n+     *  TargetNode(expression(a.x))\n+     *  </pre>\n+     * to:\n+     * <pre>\n+     *   ProjectNode(original symbols)\n+     *    TargetNode(expression(symbol))\n+     *      Project(symbol := a.x)\n+     * </pre>\n+     */\n+    abstract class ExtractProjectDereferences<N extends PlanNode>\n+            implements Rule<N>\n+    {\n+        private final Class<N> planNodeClass;\n+\n+        ExtractProjectDereferences(Class<N> planNodeClass)\n+        {\n+            this.planNodeClass = planNodeClass;\n+        }\n+\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isPushdownDereferenceEnabled(session);\n+        }\n+\n+        @Override\n+        public Pattern<N> getPattern()\n+        {\n+            return Pattern.typeOf(planNodeClass);\n+        }\n+\n+        @Override\n+        public Result apply(N node, Captures captures, Context context)\n+        {\n+            Map<SpecialFormExpression, VariableReferenceExpression> expressions =\n+                    getDereferenceSymbolMap(extractExpressionsNonRecursive(node), context, metadata);\n+\n+            if (expressions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            return Result.ofPlanNode(new ProjectNode(context.getIdAllocator().getNextId(), rewrite(context, node, HashBiMap.create(expressions)), identityAssignments(node.getOutputVariables())));\n+        }\n+\n+        protected abstract N rewrite(Context context, N node, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions);\n+    }\n+\n+    class ExtractFromFilter\n+            extends ExtractProjectDereferences<FilterNode>\n+    {\n+        ExtractFromFilter()\n+        {\n+            super(FilterNode.class);\n+        }\n+\n+        @Override\n+        protected FilterNode rewrite(Context context, FilterNode node, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions)\n+        {\n+            PlanNode source = node.getSource();\n+\n+            Map<VariableReferenceExpression, RowExpression> dereferencesMap = expressions.inverse().entrySet().stream()\n+                    .collect(toImmutableMap(Map.Entry::getKey, entry -> entry.getValue()));\n+            Assignments assignments = Assignments.builder()\n+                    .putAll(identityAssignments(source.getOutputVariables()))\n+                    .putAll(dereferencesMap)\n+                    .build();\n+            ProjectNode projectNode = new ProjectNode(context.getIdAllocator().getNextId(), source, assignments);\n+            return new FilterNode(\n+                    context.getIdAllocator().getNextId(),\n+                    projectNode,\n+                    replaceDereferences(node.getPredicate(), expressions));\n+        }\n+    }\n+\n+    class ExtractFromJoin\n+            extends ExtractProjectDereferences<JoinNode>\n+    {\n+        ExtractFromJoin()\n+        {\n+            super(JoinNode.class);\n+        }\n+\n+        @Override\n+        protected JoinNode rewrite(Context context, JoinNode joinNode, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions)\n+        {\n+            Assignments.Builder leftSideDereferences = Assignments.builder();\n+            Assignments.Builder rightSideDereferences = Assignments.builder();\n+\n+            for (Map.Entry<VariableReferenceExpression, SpecialFormExpression> entry : expressions.inverse().entrySet()) {\n+                VariableReferenceExpression baseVariable = getBase(entry.getValue());\n+                if (joinNode.getLeft().getOutputVariables().contains(baseVariable)) {\n+                    leftSideDereferences.put(entry.getKey(), entry.getValue());\n+                }\n+                else {\n+                    rightSideDereferences.put(entry.getKey(), entry.getValue());\n+                }\n+            }\n+            PlanNode leftNode = createProject(joinNode.getLeft(), leftSideDereferences.build(), context.getIdAllocator());\n+            PlanNode rightNode = createProject(joinNode.getRight(), rightSideDereferences.build(), context.getIdAllocator());\n+\n+            return new JoinNode(\n+                    context.getIdAllocator().getNextId(),\n+                    joinNode.getType(),\n+                    leftNode,\n+                    rightNode,\n+                    joinNode.getCriteria(),\n+                    ImmutableList.<VariableReferenceExpression>builder()\n+                            .addAll(leftNode.getOutputVariables())\n+                            .addAll(rightNode.getOutputVariables())\n+                            .build(),\n+                    joinNode.getFilter().map(expression -> replaceDereferences(expression, expressions)),\n+                    joinNode.getLeftHashVariable(),\n+                    joinNode.getRightHashVariable(),\n+                    joinNode.getDistributionType());\n+        }\n+    }\n+\n+    /**\n+     * Push down dereferences from ProjectNode to child nodes if possible\n+     */\n+    private abstract class PushdownDereferencesInProject<N extends PlanNode>\n+            implements Rule<ProjectNode>\n+    {\n+        private final Capture<N> targetCapture = newCapture();\n+        private final Pattern<N> targetPattern;\n+\n+        protected PushdownDereferencesInProject(Pattern<N> targetPattern)\n+        {\n+            this.targetPattern = requireNonNull(targetPattern, \"targetPattern is null\");\n+        }\n+\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isPushdownDereferenceEnabled(session);\n+        }\n+\n+        @Override\n+        public Pattern<ProjectNode> getPattern()\n+        {\n+            return project().with(source().matching(targetPattern.capturedAs(targetCapture)));\n+        }\n+\n+        @Override\n+        public Result apply(ProjectNode node, Captures captures, Context context)\n+        {\n+            N child = captures.get(targetCapture);\n+            Map<SpecialFormExpression, VariableReferenceExpression> allDereferencesInProject = getDereferenceSymbolMap(node.getAssignments().getExpressions(), context, metadata);\n+\n+            Set<VariableReferenceExpression> childSourceSymbols = child.getSources().stream()\n+                    .map(PlanNode::getOutputVariables).flatMap(Collection::stream)\n+                    .collect(toImmutableSet());\n+\n+            Map<SpecialFormExpression, VariableReferenceExpression> pushdownDereferences = allDereferencesInProject.entrySet().stream()\n+                    .filter(entry -> childSourceSymbols.contains(getBase(entry.getKey())))\n+                    .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+            if (pushdownDereferences.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            Result result = pushDownDereferences(context, child, HashBiMap.create(pushdownDereferences));\n+            if (result.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            Assignments.Builder builder = Assignments.builder();\n+            for (Map.Entry<VariableReferenceExpression, RowExpression> entry : node.getAssignments().entrySet()) {\n+                builder.put(entry.getKey(), replaceDereferences(entry.getValue(), pushdownDereferences));\n+            }\n+            return Result.ofPlanNode(new ProjectNode(context.getIdAllocator().getNextId(), result.getTransformedPlan().get(), builder.build()));\n+        }\n+\n+        protected abstract Result pushDownDereferences(Context context, N targetNode, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions);\n+    }\n+\n+    /**\n+     * Transforms:\n+     * <pre>\n+     *  Project(a_x := a.x)\n+     *    TargetNode(a)\n+     *  </pre>\n+     * to:\n+     * <pre>\n+     *  Project(a_x := symbol)\n+     *    TargetNode(symbol)\n+     *      Project(symbol := a.x)\n+     * </pre>\n+     */\n+    public class PushDownDereferenceThrough<N extends PlanNode>\n+            extends PushdownDereferencesInProject<N>\n+    {\n+        public PushDownDereferenceThrough(Class<N> planNodeClass)\n+        {\n+            super(Pattern.typeOf(planNodeClass));\n+        }\n+\n+        @Override\n+        protected Result pushDownDereferences(Context context, N targetNode, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions)\n+        {\n+            PlanNode source = getOnlyElement(targetNode.getSources());\n+\n+            Map<VariableReferenceExpression, RowExpression> dereferencesMap =\n+                    expressions.inverse().entrySet().stream()\n+                            .collect(toImmutableMap(Map.Entry::getKey, entry -> entry.getValue()));", "originalCommit": "f896b32aeb9585bbc38e52177e2c158c71d731ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkyMDIxOA==", "url": "https://github.com/prestodb/presto/pull/14829#discussion_r463920218", "bodyText": "same", "author": "highker", "createdAt": "2020-08-01T04:27:42Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/iterative/rule/PushDownDereferences.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.planner.iterative.rule;\n+\n+import com.facebook.presto.Session;\n+import com.facebook.presto.expressions.DefaultRowExpressionTraversalVisitor;\n+import com.facebook.presto.expressions.RowExpressionRewriter;\n+import com.facebook.presto.expressions.RowExpressionTreeRewriter;\n+import com.facebook.presto.matching.Capture;\n+import com.facebook.presto.matching.Captures;\n+import com.facebook.presto.matching.Pattern;\n+import com.facebook.presto.metadata.Metadata;\n+import com.facebook.presto.spi.plan.Assignments;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.LimitNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TopNNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.SpecialFormExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.sql.planner.iterative.Rule;\n+import com.facebook.presto.sql.planner.iterative.Rule.Context;\n+import com.facebook.presto.sql.planner.plan.AssignUniqueId;\n+import com.facebook.presto.sql.planner.plan.JoinNode;\n+import com.facebook.presto.sql.planner.plan.RowNumberNode;\n+import com.facebook.presto.sql.planner.plan.SemiJoinNode;\n+import com.facebook.presto.sql.planner.plan.SortNode;\n+import com.facebook.presto.sql.planner.plan.TopNRowNumberNode;\n+import com.facebook.presto.sql.planner.plan.UnnestNode;\n+import com.facebook.presto.sql.planner.plan.WindowNode;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static com.facebook.presto.SystemSessionProperties.isPushdownDereferenceEnabled;\n+import static com.facebook.presto.expressions.RowExpressionTreeRewriter.rewriteWith;\n+import static com.facebook.presto.matching.Capture.newCapture;\n+import static com.facebook.presto.spi.relation.SpecialFormExpression.Form.DEREFERENCE;\n+import static com.facebook.presto.sql.planner.ExpressionExtractor.extractExpressionsNonRecursive;\n+import static com.facebook.presto.sql.planner.VariablesExtractor.extractAll;\n+import static com.facebook.presto.sql.planner.plan.AssignmentUtils.identityAssignments;\n+import static com.facebook.presto.sql.planner.plan.Patterns.join;\n+import static com.facebook.presto.sql.planner.plan.Patterns.project;\n+import static com.facebook.presto.sql.planner.plan.Patterns.semiJoin;\n+import static com.facebook.presto.sql.planner.plan.Patterns.source;\n+import static com.facebook.presto.sql.planner.plan.Patterns.unnest;\n+import static com.facebook.presto.sql.tree.ExpressionTreeRewriter.rewriteWith;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Push down dereferences as follows:\n+ * <p>\n+ * Extract dereferences from PlanNode which has expressions\n+ * and push them down to a new ProjectNode right below the PlanNode.\n+ * After this step, All dereferences will be in ProjectNode.\n+ * <p>\n+ * Pushdown dereferences in ProjectNode down through other types of PlanNode,\n+ * e.g, Filter, Join etc.\n+ */\n+public class PushDownDereferences\n+{\n+    private final Metadata metadata;\n+\n+    public PushDownDereferences(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+    }\n+\n+    public Set<Rule<?>> rules()\n+    {\n+        return ImmutableSet.of(\n+                new ExtractFromFilter(),\n+                new ExtractFromJoin(),\n+                new PushDownDereferenceThrough<>(AssignUniqueId.class),\n+                new PushDownDereferenceThrough<>(WindowNode.class),\n+                new PushDownDereferenceThrough<>(TopNNode.class),\n+                new PushDownDereferenceThrough<>(RowNumberNode.class),\n+                new PushDownDereferenceThrough<>(TopNRowNumberNode.class),\n+                new PushDownDereferenceThrough<>(SortNode.class),\n+                new PushDownDereferenceThrough<>(FilterNode.class),\n+                new PushDownDereferenceThrough<>(LimitNode.class),\n+                new PushDownDereferenceThroughProject(),\n+                new PushDownDereferenceThroughUnnest(),\n+                new PushDownDereferenceThroughSemiJoin(),\n+                new PushDownDereferenceThroughJoin());\n+    }\n+\n+    /**\n+     * Extract dereferences and push them down to new ProjectNode below\n+     * Transforms:\n+     * <pre>\n+     *  TargetNode(expression(a.x))\n+     *  </pre>\n+     * to:\n+     * <pre>\n+     *   ProjectNode(original symbols)\n+     *    TargetNode(expression(symbol))\n+     *      Project(symbol := a.x)\n+     * </pre>\n+     */\n+    abstract class ExtractProjectDereferences<N extends PlanNode>\n+            implements Rule<N>\n+    {\n+        private final Class<N> planNodeClass;\n+\n+        ExtractProjectDereferences(Class<N> planNodeClass)\n+        {\n+            this.planNodeClass = planNodeClass;\n+        }\n+\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isPushdownDereferenceEnabled(session);\n+        }\n+\n+        @Override\n+        public Pattern<N> getPattern()\n+        {\n+            return Pattern.typeOf(planNodeClass);\n+        }\n+\n+        @Override\n+        public Result apply(N node, Captures captures, Context context)\n+        {\n+            Map<SpecialFormExpression, VariableReferenceExpression> expressions =\n+                    getDereferenceSymbolMap(extractExpressionsNonRecursive(node), context, metadata);\n+\n+            if (expressions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            return Result.ofPlanNode(new ProjectNode(context.getIdAllocator().getNextId(), rewrite(context, node, HashBiMap.create(expressions)), identityAssignments(node.getOutputVariables())));\n+        }\n+\n+        protected abstract N rewrite(Context context, N node, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions);\n+    }\n+\n+    class ExtractFromFilter\n+            extends ExtractProjectDereferences<FilterNode>\n+    {\n+        ExtractFromFilter()\n+        {\n+            super(FilterNode.class);\n+        }\n+\n+        @Override\n+        protected FilterNode rewrite(Context context, FilterNode node, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions)\n+        {\n+            PlanNode source = node.getSource();\n+\n+            Map<VariableReferenceExpression, RowExpression> dereferencesMap = expressions.inverse().entrySet().stream()\n+                    .collect(toImmutableMap(Map.Entry::getKey, entry -> entry.getValue()));\n+            Assignments assignments = Assignments.builder()\n+                    .putAll(identityAssignments(source.getOutputVariables()))\n+                    .putAll(dereferencesMap)\n+                    .build();\n+            ProjectNode projectNode = new ProjectNode(context.getIdAllocator().getNextId(), source, assignments);\n+            return new FilterNode(\n+                    context.getIdAllocator().getNextId(),\n+                    projectNode,\n+                    replaceDereferences(node.getPredicate(), expressions));\n+        }\n+    }\n+\n+    class ExtractFromJoin\n+            extends ExtractProjectDereferences<JoinNode>\n+    {\n+        ExtractFromJoin()\n+        {\n+            super(JoinNode.class);\n+        }\n+\n+        @Override\n+        protected JoinNode rewrite(Context context, JoinNode joinNode, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions)\n+        {\n+            Assignments.Builder leftSideDereferences = Assignments.builder();\n+            Assignments.Builder rightSideDereferences = Assignments.builder();\n+\n+            for (Map.Entry<VariableReferenceExpression, SpecialFormExpression> entry : expressions.inverse().entrySet()) {\n+                VariableReferenceExpression baseVariable = getBase(entry.getValue());\n+                if (joinNode.getLeft().getOutputVariables().contains(baseVariable)) {\n+                    leftSideDereferences.put(entry.getKey(), entry.getValue());\n+                }\n+                else {\n+                    rightSideDereferences.put(entry.getKey(), entry.getValue());\n+                }\n+            }\n+            PlanNode leftNode = createProject(joinNode.getLeft(), leftSideDereferences.build(), context.getIdAllocator());\n+            PlanNode rightNode = createProject(joinNode.getRight(), rightSideDereferences.build(), context.getIdAllocator());\n+\n+            return new JoinNode(\n+                    context.getIdAllocator().getNextId(),\n+                    joinNode.getType(),\n+                    leftNode,\n+                    rightNode,\n+                    joinNode.getCriteria(),\n+                    ImmutableList.<VariableReferenceExpression>builder()\n+                            .addAll(leftNode.getOutputVariables())\n+                            .addAll(rightNode.getOutputVariables())\n+                            .build(),\n+                    joinNode.getFilter().map(expression -> replaceDereferences(expression, expressions)),\n+                    joinNode.getLeftHashVariable(),\n+                    joinNode.getRightHashVariable(),\n+                    joinNode.getDistributionType());\n+        }\n+    }\n+\n+    /**\n+     * Push down dereferences from ProjectNode to child nodes if possible\n+     */\n+    private abstract class PushdownDereferencesInProject<N extends PlanNode>\n+            implements Rule<ProjectNode>\n+    {\n+        private final Capture<N> targetCapture = newCapture();\n+        private final Pattern<N> targetPattern;\n+\n+        protected PushdownDereferencesInProject(Pattern<N> targetPattern)\n+        {\n+            this.targetPattern = requireNonNull(targetPattern, \"targetPattern is null\");\n+        }\n+\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isPushdownDereferenceEnabled(session);\n+        }\n+\n+        @Override\n+        public Pattern<ProjectNode> getPattern()\n+        {\n+            return project().with(source().matching(targetPattern.capturedAs(targetCapture)));\n+        }\n+\n+        @Override\n+        public Result apply(ProjectNode node, Captures captures, Context context)\n+        {\n+            N child = captures.get(targetCapture);\n+            Map<SpecialFormExpression, VariableReferenceExpression> allDereferencesInProject = getDereferenceSymbolMap(node.getAssignments().getExpressions(), context, metadata);\n+\n+            Set<VariableReferenceExpression> childSourceSymbols = child.getSources().stream()\n+                    .map(PlanNode::getOutputVariables).flatMap(Collection::stream)\n+                    .collect(toImmutableSet());\n+\n+            Map<SpecialFormExpression, VariableReferenceExpression> pushdownDereferences = allDereferencesInProject.entrySet().stream()\n+                    .filter(entry -> childSourceSymbols.contains(getBase(entry.getKey())))\n+                    .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+            if (pushdownDereferences.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            Result result = pushDownDereferences(context, child, HashBiMap.create(pushdownDereferences));\n+            if (result.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            Assignments.Builder builder = Assignments.builder();\n+            for (Map.Entry<VariableReferenceExpression, RowExpression> entry : node.getAssignments().entrySet()) {\n+                builder.put(entry.getKey(), replaceDereferences(entry.getValue(), pushdownDereferences));\n+            }\n+            return Result.ofPlanNode(new ProjectNode(context.getIdAllocator().getNextId(), result.getTransformedPlan().get(), builder.build()));\n+        }\n+\n+        protected abstract Result pushDownDereferences(Context context, N targetNode, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions);\n+    }\n+\n+    /**\n+     * Transforms:\n+     * <pre>\n+     *  Project(a_x := a.x)\n+     *    TargetNode(a)\n+     *  </pre>\n+     * to:\n+     * <pre>\n+     *  Project(a_x := symbol)\n+     *    TargetNode(symbol)\n+     *      Project(symbol := a.x)\n+     * </pre>\n+     */\n+    public class PushDownDereferenceThrough<N extends PlanNode>\n+            extends PushdownDereferencesInProject<N>\n+    {\n+        public PushDownDereferenceThrough(Class<N> planNodeClass)\n+        {\n+            super(Pattern.typeOf(planNodeClass));\n+        }\n+\n+        @Override\n+        protected Result pushDownDereferences(Context context, N targetNode, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions)\n+        {\n+            PlanNode source = getOnlyElement(targetNode.getSources());\n+\n+            Map<VariableReferenceExpression, RowExpression> dereferencesMap =\n+                    expressions.inverse().entrySet().stream()\n+                            .collect(toImmutableMap(Map.Entry::getKey, entry -> entry.getValue()));\n+            ProjectNode projectNode = new ProjectNode(\n+                    context.getIdAllocator().getNextId(),\n+                    source,\n+                    Assignments.builder()\n+                            .putAll(identityAssignments(source.getOutputVariables()))\n+                            .putAll(dereferencesMap)\n+                            .build());\n+            return Result.ofPlanNode(targetNode.replaceChildren(ImmutableList.of(projectNode)));\n+        }\n+    }\n+\n+    /**\n+     * Transforms:\n+     * <pre>\n+     *  Project(a_x := a.msg.x)\n+     *    Join(a_y = b_y) => [a]\n+     *      Project(a_y := a.msg.y)\n+     *          Source(a)\n+     *      Project(b_y := b.msg.y)\n+     *          Source(b)\n+     *  </pre>\n+     * to:\n+     * <pre>\n+     *  Project(a_x := symbol)\n+     *    Join(a_y = b_y) => [symbol]\n+     *      Project(symbol := a.msg.x, a_y := a.msg.y)\n+     *        Source(a)\n+     *      Project(b_y := b.msg.y)\n+     *        Source(b)\n+     * </pre>\n+     */\n+    public class PushDownDereferenceThroughJoin\n+            extends PushdownDereferencesInProject<JoinNode>\n+    {\n+        PushDownDereferenceThroughJoin()\n+        {\n+            super(join());\n+        }\n+\n+        @Override\n+        protected Result pushDownDereferences(Context context, JoinNode joinNode, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions)\n+        {\n+            Assignments.Builder leftSideDereferences = Assignments.builder();\n+            Assignments.Builder rightSideDereferences = Assignments.builder();\n+\n+            for (Map.Entry<VariableReferenceExpression, SpecialFormExpression> entry : expressions.inverse().entrySet()) {\n+                VariableReferenceExpression baseVariable = getBase(entry.getValue());\n+                if (joinNode.getLeft().getOutputVariables().contains(baseVariable)) {\n+                    leftSideDereferences.put(entry.getKey(), entry.getValue());\n+                }\n+                else {\n+                    rightSideDereferences.put(entry.getKey(), entry.getValue());\n+                }\n+            }\n+            PlanNode leftNode = createProject(joinNode.getLeft(), leftSideDereferences.build(), context.getIdAllocator());\n+            PlanNode rightNode = createProject(joinNode.getRight(), rightSideDereferences.build(), context.getIdAllocator());\n+\n+            return Result.ofPlanNode(new JoinNode(\n+                    context.getIdAllocator().getNextId(),\n+                    joinNode.getType(),\n+                    leftNode,\n+                    rightNode,\n+                    joinNode.getCriteria(),\n+                    ImmutableList.<VariableReferenceExpression>builder()\n+                            .addAll(leftNode.getOutputVariables())\n+                            .addAll(rightNode.getOutputVariables())\n+                            .build(),\n+                    joinNode.getFilter().map(expression -> replaceDereferences(expression, expressions)),\n+                    joinNode.getLeftHashVariable(),\n+                    joinNode.getRightHashVariable(),\n+                    joinNode.getDistributionType()));\n+        }\n+    }\n+\n+    public class PushDownDereferenceThroughSemiJoin\n+            extends PushdownDereferencesInProject<SemiJoinNode>\n+    {\n+        PushDownDereferenceThroughSemiJoin()\n+        {\n+            super(semiJoin());\n+        }\n+\n+        @Override\n+        protected Result pushDownDereferences(Context context, SemiJoinNode semiJoinNode, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions)\n+        {\n+            Assignments.Builder filteringSourceDereferences = Assignments.builder();\n+            Assignments.Builder sourceDereferences = Assignments.builder();\n+\n+            for (Map.Entry<VariableReferenceExpression, SpecialFormExpression> entry : expressions.inverse().entrySet()) {\n+                VariableReferenceExpression baseVariable = getBase(entry.getValue());\n+                if (semiJoinNode.getFilteringSource().getOutputVariables().contains(baseVariable)) {\n+                    filteringSourceDereferences.put(entry.getKey(), entry.getValue());\n+                }\n+                else {\n+                    sourceDereferences.put(entry.getKey(), entry.getValue());\n+                }\n+            }\n+            PlanNode filteringSource = createProject(semiJoinNode.getFilteringSource(), filteringSourceDereferences.build(), context.getIdAllocator());\n+            PlanNode source = createProject(semiJoinNode.getSource(), sourceDereferences.build(), context.getIdAllocator());\n+            return Result.ofPlanNode(semiJoinNode.replaceChildren(ImmutableList.of(source, filteringSource)));\n+        }\n+    }\n+\n+    public class PushDownDereferenceThroughProject\n+            extends PushdownDereferencesInProject<ProjectNode>\n+    {\n+        PushDownDereferenceThroughProject()\n+        {\n+            super(project());\n+        }\n+\n+        @Override\n+        protected Result pushDownDereferences(Context context, ProjectNode projectNode, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions)\n+        {\n+            Map<VariableReferenceExpression, RowExpression> dereferencesMap = expressions.inverse().entrySet().stream()\n+                    .collect(toImmutableMap(Map.Entry::getKey, entry -> entry.getValue()));", "originalCommit": "f896b32aeb9585bbc38e52177e2c158c71d731ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkyMDIzMQ==", "url": "https://github.com/prestodb/presto/pull/14829#discussion_r463920231", "bodyText": "same", "author": "highker", "createdAt": "2020-08-01T04:27:49Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/iterative/rule/PushDownDereferences.java", "diffHunk": "@@ -0,0 +1,578 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.planner.iterative.rule;\n+\n+import com.facebook.presto.Session;\n+import com.facebook.presto.expressions.DefaultRowExpressionTraversalVisitor;\n+import com.facebook.presto.expressions.RowExpressionRewriter;\n+import com.facebook.presto.expressions.RowExpressionTreeRewriter;\n+import com.facebook.presto.matching.Capture;\n+import com.facebook.presto.matching.Captures;\n+import com.facebook.presto.matching.Pattern;\n+import com.facebook.presto.metadata.Metadata;\n+import com.facebook.presto.spi.plan.Assignments;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.LimitNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.PlanNodeIdAllocator;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TopNNode;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.SpecialFormExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.facebook.presto.sql.planner.iterative.Rule;\n+import com.facebook.presto.sql.planner.iterative.Rule.Context;\n+import com.facebook.presto.sql.planner.plan.AssignUniqueId;\n+import com.facebook.presto.sql.planner.plan.JoinNode;\n+import com.facebook.presto.sql.planner.plan.RowNumberNode;\n+import com.facebook.presto.sql.planner.plan.SemiJoinNode;\n+import com.facebook.presto.sql.planner.plan.SortNode;\n+import com.facebook.presto.sql.planner.plan.TopNRowNumberNode;\n+import com.facebook.presto.sql.planner.plan.UnnestNode;\n+import com.facebook.presto.sql.planner.plan.WindowNode;\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.HashBiMap;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static com.facebook.presto.SystemSessionProperties.isPushdownDereferenceEnabled;\n+import static com.facebook.presto.expressions.RowExpressionTreeRewriter.rewriteWith;\n+import static com.facebook.presto.matching.Capture.newCapture;\n+import static com.facebook.presto.spi.relation.SpecialFormExpression.Form.DEREFERENCE;\n+import static com.facebook.presto.sql.planner.ExpressionExtractor.extractExpressionsNonRecursive;\n+import static com.facebook.presto.sql.planner.VariablesExtractor.extractAll;\n+import static com.facebook.presto.sql.planner.plan.AssignmentUtils.identityAssignments;\n+import static com.facebook.presto.sql.planner.plan.Patterns.join;\n+import static com.facebook.presto.sql.planner.plan.Patterns.project;\n+import static com.facebook.presto.sql.planner.plan.Patterns.semiJoin;\n+import static com.facebook.presto.sql.planner.plan.Patterns.source;\n+import static com.facebook.presto.sql.planner.plan.Patterns.unnest;\n+import static com.facebook.presto.sql.tree.ExpressionTreeRewriter.rewriteWith;\n+import static com.google.common.collect.ImmutableMap.toImmutableMap;\n+import static com.google.common.collect.ImmutableSet.toImmutableSet;\n+import static com.google.common.collect.Iterables.getOnlyElement;\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Push down dereferences as follows:\n+ * <p>\n+ * Extract dereferences from PlanNode which has expressions\n+ * and push them down to a new ProjectNode right below the PlanNode.\n+ * After this step, All dereferences will be in ProjectNode.\n+ * <p>\n+ * Pushdown dereferences in ProjectNode down through other types of PlanNode,\n+ * e.g, Filter, Join etc.\n+ */\n+public class PushDownDereferences\n+{\n+    private final Metadata metadata;\n+\n+    public PushDownDereferences(Metadata metadata)\n+    {\n+        this.metadata = requireNonNull(metadata, \"metadata is null\");\n+    }\n+\n+    public Set<Rule<?>> rules()\n+    {\n+        return ImmutableSet.of(\n+                new ExtractFromFilter(),\n+                new ExtractFromJoin(),\n+                new PushDownDereferenceThrough<>(AssignUniqueId.class),\n+                new PushDownDereferenceThrough<>(WindowNode.class),\n+                new PushDownDereferenceThrough<>(TopNNode.class),\n+                new PushDownDereferenceThrough<>(RowNumberNode.class),\n+                new PushDownDereferenceThrough<>(TopNRowNumberNode.class),\n+                new PushDownDereferenceThrough<>(SortNode.class),\n+                new PushDownDereferenceThrough<>(FilterNode.class),\n+                new PushDownDereferenceThrough<>(LimitNode.class),\n+                new PushDownDereferenceThroughProject(),\n+                new PushDownDereferenceThroughUnnest(),\n+                new PushDownDereferenceThroughSemiJoin(),\n+                new PushDownDereferenceThroughJoin());\n+    }\n+\n+    /**\n+     * Extract dereferences and push them down to new ProjectNode below\n+     * Transforms:\n+     * <pre>\n+     *  TargetNode(expression(a.x))\n+     *  </pre>\n+     * to:\n+     * <pre>\n+     *   ProjectNode(original symbols)\n+     *    TargetNode(expression(symbol))\n+     *      Project(symbol := a.x)\n+     * </pre>\n+     */\n+    abstract class ExtractProjectDereferences<N extends PlanNode>\n+            implements Rule<N>\n+    {\n+        private final Class<N> planNodeClass;\n+\n+        ExtractProjectDereferences(Class<N> planNodeClass)\n+        {\n+            this.planNodeClass = planNodeClass;\n+        }\n+\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isPushdownDereferenceEnabled(session);\n+        }\n+\n+        @Override\n+        public Pattern<N> getPattern()\n+        {\n+            return Pattern.typeOf(planNodeClass);\n+        }\n+\n+        @Override\n+        public Result apply(N node, Captures captures, Context context)\n+        {\n+            Map<SpecialFormExpression, VariableReferenceExpression> expressions =\n+                    getDereferenceSymbolMap(extractExpressionsNonRecursive(node), context, metadata);\n+\n+            if (expressions.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            return Result.ofPlanNode(new ProjectNode(context.getIdAllocator().getNextId(), rewrite(context, node, HashBiMap.create(expressions)), identityAssignments(node.getOutputVariables())));\n+        }\n+\n+        protected abstract N rewrite(Context context, N node, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions);\n+    }\n+\n+    class ExtractFromFilter\n+            extends ExtractProjectDereferences<FilterNode>\n+    {\n+        ExtractFromFilter()\n+        {\n+            super(FilterNode.class);\n+        }\n+\n+        @Override\n+        protected FilterNode rewrite(Context context, FilterNode node, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions)\n+        {\n+            PlanNode source = node.getSource();\n+\n+            Map<VariableReferenceExpression, RowExpression> dereferencesMap = expressions.inverse().entrySet().stream()\n+                    .collect(toImmutableMap(Map.Entry::getKey, entry -> entry.getValue()));\n+            Assignments assignments = Assignments.builder()\n+                    .putAll(identityAssignments(source.getOutputVariables()))\n+                    .putAll(dereferencesMap)\n+                    .build();\n+            ProjectNode projectNode = new ProjectNode(context.getIdAllocator().getNextId(), source, assignments);\n+            return new FilterNode(\n+                    context.getIdAllocator().getNextId(),\n+                    projectNode,\n+                    replaceDereferences(node.getPredicate(), expressions));\n+        }\n+    }\n+\n+    class ExtractFromJoin\n+            extends ExtractProjectDereferences<JoinNode>\n+    {\n+        ExtractFromJoin()\n+        {\n+            super(JoinNode.class);\n+        }\n+\n+        @Override\n+        protected JoinNode rewrite(Context context, JoinNode joinNode, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions)\n+        {\n+            Assignments.Builder leftSideDereferences = Assignments.builder();\n+            Assignments.Builder rightSideDereferences = Assignments.builder();\n+\n+            for (Map.Entry<VariableReferenceExpression, SpecialFormExpression> entry : expressions.inverse().entrySet()) {\n+                VariableReferenceExpression baseVariable = getBase(entry.getValue());\n+                if (joinNode.getLeft().getOutputVariables().contains(baseVariable)) {\n+                    leftSideDereferences.put(entry.getKey(), entry.getValue());\n+                }\n+                else {\n+                    rightSideDereferences.put(entry.getKey(), entry.getValue());\n+                }\n+            }\n+            PlanNode leftNode = createProject(joinNode.getLeft(), leftSideDereferences.build(), context.getIdAllocator());\n+            PlanNode rightNode = createProject(joinNode.getRight(), rightSideDereferences.build(), context.getIdAllocator());\n+\n+            return new JoinNode(\n+                    context.getIdAllocator().getNextId(),\n+                    joinNode.getType(),\n+                    leftNode,\n+                    rightNode,\n+                    joinNode.getCriteria(),\n+                    ImmutableList.<VariableReferenceExpression>builder()\n+                            .addAll(leftNode.getOutputVariables())\n+                            .addAll(rightNode.getOutputVariables())\n+                            .build(),\n+                    joinNode.getFilter().map(expression -> replaceDereferences(expression, expressions)),\n+                    joinNode.getLeftHashVariable(),\n+                    joinNode.getRightHashVariable(),\n+                    joinNode.getDistributionType());\n+        }\n+    }\n+\n+    /**\n+     * Push down dereferences from ProjectNode to child nodes if possible\n+     */\n+    private abstract class PushdownDereferencesInProject<N extends PlanNode>\n+            implements Rule<ProjectNode>\n+    {\n+        private final Capture<N> targetCapture = newCapture();\n+        private final Pattern<N> targetPattern;\n+\n+        protected PushdownDereferencesInProject(Pattern<N> targetPattern)\n+        {\n+            this.targetPattern = requireNonNull(targetPattern, \"targetPattern is null\");\n+        }\n+\n+        @Override\n+        public boolean isEnabled(Session session)\n+        {\n+            return isPushdownDereferenceEnabled(session);\n+        }\n+\n+        @Override\n+        public Pattern<ProjectNode> getPattern()\n+        {\n+            return project().with(source().matching(targetPattern.capturedAs(targetCapture)));\n+        }\n+\n+        @Override\n+        public Result apply(ProjectNode node, Captures captures, Context context)\n+        {\n+            N child = captures.get(targetCapture);\n+            Map<SpecialFormExpression, VariableReferenceExpression> allDereferencesInProject = getDereferenceSymbolMap(node.getAssignments().getExpressions(), context, metadata);\n+\n+            Set<VariableReferenceExpression> childSourceSymbols = child.getSources().stream()\n+                    .map(PlanNode::getOutputVariables).flatMap(Collection::stream)\n+                    .collect(toImmutableSet());\n+\n+            Map<SpecialFormExpression, VariableReferenceExpression> pushdownDereferences = allDereferencesInProject.entrySet().stream()\n+                    .filter(entry -> childSourceSymbols.contains(getBase(entry.getKey())))\n+                    .collect(toImmutableMap(Map.Entry::getKey, Map.Entry::getValue));\n+\n+            if (pushdownDereferences.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            Result result = pushDownDereferences(context, child, HashBiMap.create(pushdownDereferences));\n+            if (result.isEmpty()) {\n+                return Result.empty();\n+            }\n+\n+            Assignments.Builder builder = Assignments.builder();\n+            for (Map.Entry<VariableReferenceExpression, RowExpression> entry : node.getAssignments().entrySet()) {\n+                builder.put(entry.getKey(), replaceDereferences(entry.getValue(), pushdownDereferences));\n+            }\n+            return Result.ofPlanNode(new ProjectNode(context.getIdAllocator().getNextId(), result.getTransformedPlan().get(), builder.build()));\n+        }\n+\n+        protected abstract Result pushDownDereferences(Context context, N targetNode, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions);\n+    }\n+\n+    /**\n+     * Transforms:\n+     * <pre>\n+     *  Project(a_x := a.x)\n+     *    TargetNode(a)\n+     *  </pre>\n+     * to:\n+     * <pre>\n+     *  Project(a_x := symbol)\n+     *    TargetNode(symbol)\n+     *      Project(symbol := a.x)\n+     * </pre>\n+     */\n+    public class PushDownDereferenceThrough<N extends PlanNode>\n+            extends PushdownDereferencesInProject<N>\n+    {\n+        public PushDownDereferenceThrough(Class<N> planNodeClass)\n+        {\n+            super(Pattern.typeOf(planNodeClass));\n+        }\n+\n+        @Override\n+        protected Result pushDownDereferences(Context context, N targetNode, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions)\n+        {\n+            PlanNode source = getOnlyElement(targetNode.getSources());\n+\n+            Map<VariableReferenceExpression, RowExpression> dereferencesMap =\n+                    expressions.inverse().entrySet().stream()\n+                            .collect(toImmutableMap(Map.Entry::getKey, entry -> entry.getValue()));\n+            ProjectNode projectNode = new ProjectNode(\n+                    context.getIdAllocator().getNextId(),\n+                    source,\n+                    Assignments.builder()\n+                            .putAll(identityAssignments(source.getOutputVariables()))\n+                            .putAll(dereferencesMap)\n+                            .build());\n+            return Result.ofPlanNode(targetNode.replaceChildren(ImmutableList.of(projectNode)));\n+        }\n+    }\n+\n+    /**\n+     * Transforms:\n+     * <pre>\n+     *  Project(a_x := a.msg.x)\n+     *    Join(a_y = b_y) => [a]\n+     *      Project(a_y := a.msg.y)\n+     *          Source(a)\n+     *      Project(b_y := b.msg.y)\n+     *          Source(b)\n+     *  </pre>\n+     * to:\n+     * <pre>\n+     *  Project(a_x := symbol)\n+     *    Join(a_y = b_y) => [symbol]\n+     *      Project(symbol := a.msg.x, a_y := a.msg.y)\n+     *        Source(a)\n+     *      Project(b_y := b.msg.y)\n+     *        Source(b)\n+     * </pre>\n+     */\n+    public class PushDownDereferenceThroughJoin\n+            extends PushdownDereferencesInProject<JoinNode>\n+    {\n+        PushDownDereferenceThroughJoin()\n+        {\n+            super(join());\n+        }\n+\n+        @Override\n+        protected Result pushDownDereferences(Context context, JoinNode joinNode, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions)\n+        {\n+            Assignments.Builder leftSideDereferences = Assignments.builder();\n+            Assignments.Builder rightSideDereferences = Assignments.builder();\n+\n+            for (Map.Entry<VariableReferenceExpression, SpecialFormExpression> entry : expressions.inverse().entrySet()) {\n+                VariableReferenceExpression baseVariable = getBase(entry.getValue());\n+                if (joinNode.getLeft().getOutputVariables().contains(baseVariable)) {\n+                    leftSideDereferences.put(entry.getKey(), entry.getValue());\n+                }\n+                else {\n+                    rightSideDereferences.put(entry.getKey(), entry.getValue());\n+                }\n+            }\n+            PlanNode leftNode = createProject(joinNode.getLeft(), leftSideDereferences.build(), context.getIdAllocator());\n+            PlanNode rightNode = createProject(joinNode.getRight(), rightSideDereferences.build(), context.getIdAllocator());\n+\n+            return Result.ofPlanNode(new JoinNode(\n+                    context.getIdAllocator().getNextId(),\n+                    joinNode.getType(),\n+                    leftNode,\n+                    rightNode,\n+                    joinNode.getCriteria(),\n+                    ImmutableList.<VariableReferenceExpression>builder()\n+                            .addAll(leftNode.getOutputVariables())\n+                            .addAll(rightNode.getOutputVariables())\n+                            .build(),\n+                    joinNode.getFilter().map(expression -> replaceDereferences(expression, expressions)),\n+                    joinNode.getLeftHashVariable(),\n+                    joinNode.getRightHashVariable(),\n+                    joinNode.getDistributionType()));\n+        }\n+    }\n+\n+    public class PushDownDereferenceThroughSemiJoin\n+            extends PushdownDereferencesInProject<SemiJoinNode>\n+    {\n+        PushDownDereferenceThroughSemiJoin()\n+        {\n+            super(semiJoin());\n+        }\n+\n+        @Override\n+        protected Result pushDownDereferences(Context context, SemiJoinNode semiJoinNode, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions)\n+        {\n+            Assignments.Builder filteringSourceDereferences = Assignments.builder();\n+            Assignments.Builder sourceDereferences = Assignments.builder();\n+\n+            for (Map.Entry<VariableReferenceExpression, SpecialFormExpression> entry : expressions.inverse().entrySet()) {\n+                VariableReferenceExpression baseVariable = getBase(entry.getValue());\n+                if (semiJoinNode.getFilteringSource().getOutputVariables().contains(baseVariable)) {\n+                    filteringSourceDereferences.put(entry.getKey(), entry.getValue());\n+                }\n+                else {\n+                    sourceDereferences.put(entry.getKey(), entry.getValue());\n+                }\n+            }\n+            PlanNode filteringSource = createProject(semiJoinNode.getFilteringSource(), filteringSourceDereferences.build(), context.getIdAllocator());\n+            PlanNode source = createProject(semiJoinNode.getSource(), sourceDereferences.build(), context.getIdAllocator());\n+            return Result.ofPlanNode(semiJoinNode.replaceChildren(ImmutableList.of(source, filteringSource)));\n+        }\n+    }\n+\n+    public class PushDownDereferenceThroughProject\n+            extends PushdownDereferencesInProject<ProjectNode>\n+    {\n+        PushDownDereferenceThroughProject()\n+        {\n+            super(project());\n+        }\n+\n+        @Override\n+        protected Result pushDownDereferences(Context context, ProjectNode projectNode, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions)\n+        {\n+            Map<VariableReferenceExpression, RowExpression> dereferencesMap = expressions.inverse().entrySet().stream()\n+                    .collect(toImmutableMap(Map.Entry::getKey, entry -> entry.getValue()));\n+\n+            return Result.ofPlanNode(\n+                    new ProjectNode(context.getIdAllocator().getNextId(),\n+                            projectNode.getSource(),\n+                            Assignments.builder()\n+                                    .putAll(projectNode.getAssignments())\n+                                    .putAll(dereferencesMap)\n+                                    .build()));\n+        }\n+    }\n+\n+    public class PushDownDereferenceThroughUnnest\n+            extends PushdownDereferencesInProject<UnnestNode>\n+    {\n+        PushDownDereferenceThroughUnnest()\n+        {\n+            super(unnest());\n+        }\n+\n+        @Override\n+        protected Result pushDownDereferences(Context context, UnnestNode unnestNode, BiMap<SpecialFormExpression, VariableReferenceExpression> expressions)\n+        {\n+            Map<VariableReferenceExpression, RowExpression> dereferencesMap = expressions.inverse().entrySet().stream()\n+                    .collect(toImmutableMap(Map.Entry::getKey, entry -> entry.getValue()));", "originalCommit": "f896b32aeb9585bbc38e52177e2c158c71d731ea", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkyMDQ3NQ==", "url": "https://github.com/prestodb/presto/pull/14829#discussion_r463920475", "bodyText": "why don't we have this before?", "author": "highker", "createdAt": "2020-08-01T04:30:50Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/iterative/rule/PushDownDereferences.java", "diffHunk": "@@ -401,7 +385,7 @@ protected Result pushDownDereferences(Context context, JoinNode joinNode, BiMap<\n                             .addAll(leftNode.getOutputVariables())\n                             .addAll(rightNode.getOutputVariables())\n                             .build(),\n-                    joinNode.getFilter(),\n+                    joinNode.getFilter().map(expression -> replaceDereferences(expression, expressions)),", "originalCommit": "f896b32aeb9585bbc38e52177e2c158c71d731ea", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkyNTEyNg==", "url": "https://github.com/prestodb/presto/pull/14829#discussion_r463925126", "bodyText": "not needed, we already have ExtractFromJoin. let me fix", "author": "zhenxiao", "createdAt": "2020-08-01T05:24:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkyMDQ3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ2MzkyMDY2NQ==", "url": "https://github.com/prestodb/presto/pull/14829#discussion_r463920665", "bodyText": "Let's have this to match the name TestPushDownDereferences. Or you wanna call the other DeferencePushDown. Personally I prefer the latter.", "author": "highker", "createdAt": "2020-08-01T04:33:28Z", "path": "presto-main/src/test/java/com/facebook/presto/sql/planner/TestDereferencePushDown.java", "diffHunk": "@@ -0,0 +1,203 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.planner;\n+\n+import com.facebook.presto.SystemSessionProperties;\n+import com.facebook.presto.sql.planner.assertions.BasePlanTest;\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.ImmutableMap;\n+import org.testng.annotations.Test;\n+\n+import java.util.Optional;\n+\n+import static com.facebook.presto.sql.planner.assertions.PlanMatchPattern.Ordering;\n+import static com.facebook.presto.sql.planner.assertions.PlanMatchPattern.anyTree;\n+import static com.facebook.presto.sql.planner.assertions.PlanMatchPattern.equiJoinClause;\n+import static com.facebook.presto.sql.planner.assertions.PlanMatchPattern.exchange;\n+import static com.facebook.presto.sql.planner.assertions.PlanMatchPattern.expression;\n+import static com.facebook.presto.sql.planner.assertions.PlanMatchPattern.filter;\n+import static com.facebook.presto.sql.planner.assertions.PlanMatchPattern.join;\n+import static com.facebook.presto.sql.planner.assertions.PlanMatchPattern.output;\n+import static com.facebook.presto.sql.planner.assertions.PlanMatchPattern.project;\n+import static com.facebook.presto.sql.planner.assertions.PlanMatchPattern.semiJoin;\n+import static com.facebook.presto.sql.planner.assertions.PlanMatchPattern.sort;\n+import static com.facebook.presto.sql.planner.assertions.PlanMatchPattern.unnest;\n+import static com.facebook.presto.sql.planner.assertions.PlanMatchPattern.values;\n+import static com.facebook.presto.sql.planner.plan.ExchangeNode.Scope.LOCAL;\n+import static com.facebook.presto.sql.planner.plan.ExchangeNode.Type.GATHER;\n+import static com.facebook.presto.sql.planner.plan.ExchangeNode.Type.REPARTITION;\n+import static com.facebook.presto.sql.planner.plan.JoinNode.Type.INNER;\n+import static com.facebook.presto.sql.tree.SortItem.NullOrdering.LAST;\n+import static com.facebook.presto.sql.tree.SortItem.Ordering.ASCENDING;\n+\n+public class TestDereferencePushDown", "originalCommit": "14e00f7f10b6dda96d61923619b0f0c50609f07d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2ea6dbe38eee312f3fbff865bd6b05e87007a11c", "url": "https://github.com/prestodb/presto/commit/2ea6dbe38eee312f3fbff865bd6b05e87007a11c", "message": "Move dereference pushdown below TranslateExpressions", "committedDate": "2020-08-01T05:28:19Z", "type": "commit"}, {"oid": "2ea6dbe38eee312f3fbff865bd6b05e87007a11c", "url": "https://github.com/prestodb/presto/commit/2ea6dbe38eee312f3fbff865bd6b05e87007a11c", "message": "Move dereference pushdown below TranslateExpressions", "committedDate": "2020-08-01T05:28:19Z", "type": "forcePushed"}]}