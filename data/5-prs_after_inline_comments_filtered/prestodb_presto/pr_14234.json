{"pr_number": 14234, "pr_title": "Reuse buffers in OptimizedPartitionedOutputOperator - part 1 serializedRowSizes, offsetsCopy, positions, mappedPositions and offsets", "pr_createdAt": "2020-03-10T10:13:13Z", "pr_url": "https://github.com/prestodb/presto/pull/14234", "timeline": [{"oid": "fba950636c6d10b74ed95f800d196da515ae7de9", "url": "https://github.com/prestodb/presto/commit/fba950636c6d10b74ed95f800d196da515ae7de9", "message": "Add GC profile to BenchmarkPartitionedOutputOperator", "committedDate": "2020-03-11T23:54:47Z", "type": "forcePushed"}, {"oid": "c7a467b1327e1d915d0a02d63626bdb1643c145b", "url": "https://github.com/prestodb/presto/commit/c7a467b1327e1d915d0a02d63626bdb1643c145b", "message": "Add GC profile to BenchmarkPartitionedOutputOperator", "committedDate": "2020-03-12T06:48:40Z", "type": "forcePushed"}, {"oid": "8d8308660e87e6fd7f6196e52867b130a696ce57", "url": "https://github.com/prestodb/presto/commit/8d8308660e87e6fd7f6196e52867b130a696ce57", "message": "Reuse positions, mappedPositions and offsets in BlockEncodingBuffer\n\nThe positions and offsets arrays for composite blocks and mappedPositions\nfor DictionaryBlock can be reused after appending the last batch in this\ncolumn to the BlockEncodingBuffers. For pages with two level nested array\ncolumns, this optimization can save 30% memory.", "committedDate": "2020-03-16T08:23:14Z", "type": "forcePushed"}, {"oid": "1a4373eaf3c291ce90444c2e8b97b77d331c60ca", "url": "https://github.com/prestodb/presto/commit/1a4373eaf3c291ce90444c2e8b97b77d331c60ca", "message": "Reuse positions, mappedPositions and offsets in BlockEncodingBuffer\n\nThe positions and offsets arrays for composite blocks and mappedPositions\nfor DictionaryBlock can be reused after appending the last batch in this\ncolumn to the BlockEncodingBuffers. For pages with two level nested array\ncolumns, this optimization can save 30% memory.", "committedDate": "2020-03-17T10:19:37Z", "type": "forcePushed"}, {"oid": "cd79bc1dd191bacc169ba708458ac08b2a412405", "url": "https://github.com/prestodb/presto/commit/cd79bc1dd191bacc169ba708458ac08b2a412405", "message": "Reuse positions, mappedPositions and offsets in BlockEncodingBuffer\n\nThe positions and offsets arrays for composite blocks and mappedPositions\nfor DictionaryBlock can be reused after appending the last batch in this\ncolumn to the BlockEncodingBuffers. For pages with two level nested array\ncolumns, this optimization can save 30% memory.", "committedDate": "2020-03-17T23:29:26Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMTM5OQ==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r395331399", "bodyText": "Math.min(buffer.length, capacity) -> buffer.length since buffer.length is known to be less than capacity", "author": "mbasmanova", "createdAt": "2020-03-19T21:31:35Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java", "diffHunk": "@@ -224,6 +226,32 @@ static DecodedBlockNode decodeBlock(BlockFlattener flattener, Closer blockLeaseC\n         return new DecodedBlockNode(decodedBlock, ImmutableList.of());\n     }\n \n+    static int[] ensureCapacityWithAllocator(int[] buffer, int capacity, ExpansionFactor expansionFactor, Arrays.ExpansionOption expansionOption, ArrayAllocator allocator)\n+    {\n+        int newCapacity = (int) (capacity * expansionFactor.getExpansionFactor());\n+\n+        int[] newBuffer;\n+        if (buffer == null) {\n+            newBuffer = allocator.borrowIntArray(newCapacity);\n+        }\n+        else if (buffer.length < capacity) {\n+            newBuffer = allocator.borrowIntArray(newCapacity);\n+            if (expansionOption == PRESERVE) {\n+                System.arraycopy(buffer, 0, newBuffer, 0, Math.min(buffer.length, capacity));", "originalCommit": "7f9743c8390914a2d4063d1c797f636855397b21", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMjQyMw==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r395332423", "bodyText": "Any reason not to put this method into Arrays class (and drop WithAllocator suffix)?\n\nstatic import Arrays.ExpansionOption", "author": "mbasmanova", "createdAt": "2020-03-19T21:33:55Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java", "diffHunk": "@@ -224,6 +226,32 @@ static DecodedBlockNode decodeBlock(BlockFlattener flattener, Closer blockLeaseC\n         return new DecodedBlockNode(decodedBlock, ImmutableList.of());\n     }\n \n+    static int[] ensureCapacityWithAllocator(int[] buffer, int capacity, ExpansionFactor expansionFactor, Arrays.ExpansionOption expansionOption, ArrayAllocator allocator)", "originalCommit": "7f9743c8390914a2d4063d1c797f636855397b21", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMjc4Mg==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r395332782", "bodyText": "Would it be possible to reuse existing arrayAllocator ?\n\n10000 -> 10_000 for readability", "author": "mbasmanova", "createdAt": "2020-03-19T21:34:43Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java", "diffHunk": "@@ -364,6 +392,7 @@ public OperatorFactory duplicate()\n         private final ArrayAllocator arrayAllocator = new SimpleArrayAllocator(5000);\n         private final BlockFlattener flattener = new BlockFlattener(arrayAllocator);\n         private final Closer blockLeaseCloser = Closer.create();\n+        private final ArrayAllocator bufferAllocator = new SimpleArrayAllocator(10000);", "originalCommit": "7f9743c8390914a2d4063d1c797f636855397b21", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA1ODIxNA==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r396058214", "bodyText": "@mbasmanova The difficulty using existing arrayAllocator is counting memory becomes a bit more difficult. The existing arrayAllocator is only used by BlockFlattener, and this part of memory borrowed would be still counted in DecodedBlock#getRetainedSizeInBytes(). Thus when we add a new bufferAllocator, we can simply add its retained size. If we merge the two allocators, then the counting of the dictionary ids array borrowed by BlockFlattener would be double counted in arrayAllocator and decodedBlocks. How about renaming original arrayAllocator to  blockDecodingAllocator and remain using bufferAllocator for reusing the buffers?", "author": "yingsu00", "createdAt": "2020-03-22T06:07:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMjc4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMzI0NQ==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r395333245", "bodyText": "this comment is now confusing (because bufferAllocator is an array allocator)", "author": "mbasmanova", "createdAt": "2020-03-19T21:35:45Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java", "diffHunk": "@@ -494,7 +523,7 @@ public long getRetainedSizeInBytes()\n             // When called in addInput(), the arrays have been returned to the arrayAllocator already,\n             // but they're still owned by the decodedBlock which will be counted as part of the decodedBlock.\n             // In both cases, the arrayAllocator doesn't need to be counted.", "originalCommit": "7f9743c8390914a2d4063d1c797f636855397b21", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA1OTExOA==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r396059118", "bodyText": "@mbasmanova For now I'm using blockDecodingAllocator and bufferAllocator in PagePartitioner, and changed this comment to the following:\n// When called by the operator constructor, the blockDecodingAllocator was empty at the moment.\n            // When called in addInput(), the arrays have been returned to the blockDecodingAllocator already,\n            // but they're still owned by the decodedBlock which will be counted as part of the decodedBlock.\n            // In both cases, the blockDecodingAllocator doesn't need to be counted. But we need to count\n            // bufferAllocator which contains buffers used during partitioning, e.g. serializedRowSizes,\n            // mappedPositions, etc.\n            long size = bufferAllocator.getEstimatedSizeInBytes();\n\nDoes this looks better? Or if you have better idea to count the memory using a single ArrayAllocator, we can remove this comment.", "author": "yingsu00", "createdAt": "2020-03-22T06:25:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMzI0NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMzQwOA==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r395333408", "bodyText": "allocator -> arrayAllocator", "author": "mbasmanova", "createdAt": "2020-03-19T21:36:08Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java", "diffHunk": "@@ -544,6 +573,7 @@ private static int getFixedWidthTypeSize(Type type)\n         private final Lifespan lifespan;\n         private final int capacity;\n         private final int channelCount;\n+        private final ArrayAllocator allocator;", "originalCommit": "7f9743c8390914a2d4063d1c797f636855397b21", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA1OTUzNA==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r396059534", "bodyText": "@mbasmanova I renamed it to bufferAllocator to be consistent with the one in PagePartitioner. Let me know if you prefer other names.", "author": "yingsu00", "createdAt": "2020-03-22T06:32:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzMzQwOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNjU5Ng==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r395336596", "bodyText": "This logic is confusing to me. calculateNextBatchSize is called in a do-while loop and therefore it is not clear that it won't be called anymore. I think it would be clearer to move allocation and freeing of the serializedRowSizes into appendData and change serializedRowSizes into a local variable:\n            int[] serializedRowSizes = ensureCapacityWithAllocator(null, positionCount, SMALL, INITIALIZE, allocator);\n            try {\n\n                populateSerializedRowSizes(fixedWidthRowSize, variableWidthChannels, serializedRowSizes);\n\n                // Due to the limitation of buffer size, we append the data batch by batch\n                int offset = 0;\n                do {\n                    int batchSize = calculateNextBatchSize(fixedWidthRowSize, variableWidthChannels, offset, serializedRowSizes);\n                    boolean lastBatchInPage = offset + batchSize >= positionCount;\n\n                    for (int i = 0; i < channelCount; i++) {\n                        blockEncodingBuffers[i].setNextBatch(offset, batchSize);\n                        blockEncodingBuffers[i].appendDataInBatch(lastBatchInPage);\n                    }\n\n                    bufferedRowCount += batchSize;\n                    offset += batchSize;\n\n                    if (bufferFull) {\n                        flush(outputBuffer);\n                        bufferFull = false;\n                    }\n                }\n                while (offset < positionCount);\n            }\n            finally {\n                // Return the borrowed array for serializedRowSizes when the current page will be finished in this batch.\n                // At this point the batchSize was already calculated and we don't need the serializedRowSizes any more.\n                allocator.returnArray(serializedRowSizes);\n            }", "author": "mbasmanova", "createdAt": "2020-03-19T21:43:22Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java", "diffHunk": "@@ -675,6 +706,11 @@ private int calculateNextBatchSize(int fixedWidthRowSize, List<Integer> variable\n                 }\n             }\n \n+            // Return the borrowed array for serializedRowSizes when the current page will be finished in this batch.\n+            // At this point the batchSize was already calculated and we don't need the serializedRowSizes any more.\n+            allocator.returnArray(serializedRowSizes);", "originalCommit": "7f9743c8390914a2d4063d1c797f636855397b21", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTk0NjQxOQ==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r395946419", "bodyText": "@mbasmanova The original logic was to release the serializedRowSizes after the size of the last batch of the page was calculated. For that purpose the returnArray() happens before the last line of calculateNextBatchSize(). If it's not the last batch in page, the code would have returned before reaching that point. I was doing it this way because I thought serializedRowSizes is an internal thing only used for calculating batchSize, therefore it was better to be confined inside of populateSerializedRowSizes() and calculateNextBatchSize(). As the caller of these two methods, appendData() doesn't need to care about how the serializedRowSizes is used. What's your opinion on this? If you think this is not important, I'll change it the way you suggested. Thanks!", "author": "yingsu00", "createdAt": "2020-03-21T01:10:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNjU5Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA3Mzc1OQ==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r396073759", "bodyText": "Masha, I updated the code as you suggested.", "author": "yingsu00", "createdAt": "2020-03-22T09:47:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNjU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzNzg3MA==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r395337870", "bodyText": "Make it final and add a constructor that takes ArrayAllocator.", "author": "mbasmanova", "createdAt": "2020-03-19T21:46:22Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/repartition/AbstractBlockEncodingBuffer.java", "diffHunk": "@@ -82,6 +83,9 @@\n     // Whether the positions array has already been mapped to mappedPositions\n     protected boolean positionsMapped;\n \n+    // The allocator for internal buffers\n+    protected ArrayAllocator allocator;", "originalCommit": "222f1b3cceab79a0a71401f91bbbb308018b751d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzOTAzNA==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r395339034", "bodyText": "Make offsetsCopy a local variable:\n        int[] offsetsCopy = ensureCapacityWithAllocator(null, positionCount + 1, SMALL, NONE, allocator);\n        try {\n            System.arraycopy(offsets, 0, offsetsCopy, 0, positionCount + 1);\n\n            ((AbstractBlockEncodingBuffer) valuesBuffers).accumulateSerializedRowSizes(offsetsCopy, positionCount, serializedRowSizes);\n        }\n        finally {\n            allocator.returnArray(offsetsCopy);   \n        }", "author": "mbasmanova", "createdAt": "2020-03-19T21:49:03Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/repartition/ArrayBlockEncodingBuffer.java", "diffHunk": "@@ -83,10 +86,13 @@ public void accumulateSerializedRowSizes(int[] serializedRowSizes)\n             serializedRowSizes[i] += POSITION_SIZE;\n         }\n \n-        offsetsCopy = ensureCapacity(offsetsCopy, positionCount + 1);\n+        offsetsCopy = ensureCapacityWithAllocator(offsetsCopy, positionCount + 1, SMALL, NONE, allocator);", "originalCommit": "7c8fe4bf7cd74e5aa0794bd6a91cdb3b263895ee", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTMzOTYyMg==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r395339622", "bodyText": "Make this final and add constructor that takes isNested flag.", "author": "mbasmanova", "createdAt": "2020-03-19T21:50:29Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/repartition/AbstractBlockEncodingBuffer.java", "diffHunk": "@@ -64,6 +64,9 @@\n public abstract class AbstractBlockEncodingBuffer\n         implements BlockEncodingBuffer\n {\n+    // Boolean indicating whether this is a buffer for a nested level block.\n+    protected boolean isNested;", "originalCommit": "80940bd10dd719d1377f4c7f46d19b699ac9f5f9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0MzA1Mg==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r395343052", "bodyText": "Debugging? Remove.", "author": "mbasmanova", "createdAt": "2020-03-19T21:58:48Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java", "diffHunk": "@@ -171,6 +171,8 @@ public void addInput(Page page)\n         page = pagePreprocessor.apply(page);\n         pagePartitioner.partitionPage(page);\n \n+        System.out.println(pagePartitioner.getRetainedSizeInBytes());", "originalCommit": "cd79bc1dd191bacc169ba708458ac08b2a412405", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NTQ2MA==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r395345460", "bodyText": "I'm wondering if it would be clearer to add separate API to signal that there will be no more batches and call it at the same time you call allocator.returnArray(serializedRowSizes). Also, it would be helpful to update documentation for BlockEncodingBuffer to explain in which order the methods are being called.\nint[] serializedRowSizes = ensureCapacityWithAllocator(null, positionCount, SMALL, INITIALIZE, allocator);\n            try {\n\n                populateSerializedRowSizes(fixedWidthRowSize, variableWidthChannels, serializedRowSizes);\n\n                // Due to the limitation of buffer size, we append the data batch by batch\n                int offset = 0;\n                do {\n                    int batchSize = calculateNextBatchSize(fixedWidthRowSize, variableWidthChannels, offset, serializedRowSizes);\n\n                    for (int i = 0; i < channelCount; i++) {\n                        blockEncodingBuffers[i].setNextBatch(offset, batchSize);\n                        blockEncodingBuffers[i].appendDataInBatch();\n                    }\n\n                    bufferedRowCount += batchSize;\n                    offset += batchSize;\n\n                    if (bufferFull) {\n                        flush(outputBuffer);\n                        bufferFull = false;\n                    }\n                }\n                while (offset < positionCount);\n            }\n            finally {\n                // Return the borrowed array for serializedRowSizes when the current page will be finished in this batch.\n                // At this point the batchSize was already calculated and we don't need the serializedRowSizes any more.\n                allocator.returnArray(serializedRowSizes);\n                for (int i = 0; i < channelCount; i++) {\n                    blockEncodingBuffers[i].noMoreBatches();\n                }\n            }", "author": "mbasmanova", "createdAt": "2020-03-19T22:04:46Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java", "diffHunk": "@@ -634,10 +636,11 @@ private void appendData(DecodedBlockNode[] decodedBlocks, int fixedWidthRowSize,\n             int offset = 0;\n             do {\n                 int batchSize = calculateNextBatchSize(fixedWidthRowSize, variableWidthChannels, offset);\n+                boolean lastBatchInPage = offset + batchSize >= positionCount;\n \n                 for (int i = 0; i < channelCount; i++) {\n                     blockEncodingBuffers[i].setNextBatch(offset, batchSize);\n-                    blockEncodingBuffers[i].appendDataInBatch();\n+                    blockEncodingBuffers[i].appendDataInBatch(lastBatchInPage);", "originalCommit": "cd79bc1dd191bacc169ba708458ac08b2a412405", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjA3MzcxMQ==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r396073711", "bodyText": "@mbasmanova Masha, thanks for the suggestion. I changed the code as you suggested. If in the future we want to share buffers among blockEncodingBuffers, we will need to do it in the   for (int i = 0; i < channelCount; i++) loop. Related issue #14274", "author": "yingsu00", "createdAt": "2020-03-22T09:46:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NTM0NTQ2MA=="}], "type": "inlineReview"}, {"oid": "9cd46f7787729826f5b1828a5719bc1e28857a99", "url": "https://github.com/prestodb/presto/commit/9cd46f7787729826f5b1828a5719bc1e28857a99", "message": "Reuse positions, mappedPositions and offsets in BlockEncodingBuffer\n\nThe positions and offsets arrays for composite blocks and mappedPositions\nfor DictionaryBlock can be reused after appending the last batch in this\ncolumn to the BlockEncodingBuffers. For pages with two level nested array\ncolumns, this optimization can save 30% memory.", "committedDate": "2020-03-22T09:31:29Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUzODQ5NQ==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r396538495", "bodyText": "Arrays.ExpansionOption -> ExpansionOption", "author": "mbasmanova", "createdAt": "2020-03-23T15:29:28Z", "path": "presto-array/src/main/java/com/facebook/presto/array/Arrays.java", "diffHunk": "@@ -49,6 +51,32 @@ else if (expansionOption == INITIALIZE) {\n         return buffer;\n     }\n \n+    public static int[] ensureCapacity(int[] buffer, int capacity, ExpansionFactor expansionFactor, Arrays.ExpansionOption expansionOption, ArrayAllocator allocator)", "originalCommit": "a536e2fcb0479659a1d7e18588a86b86eafd6d09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjUzOTY5MQ==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r396539691", "bodyText": "this method is not needed; just use expansionFactor.expansionFactor", "author": "mbasmanova", "createdAt": "2020-03-23T15:31:00Z", "path": "presto-array/src/main/java/com/facebook/presto/array/Arrays.java", "diffHunk": "@@ -128,6 +156,11 @@ else if (expansionOption == INITIALIZE) {\n         {\n             this.expansionFactor = expansionFactor;\n         }\n+\n+        public double getExpansionFactor()", "originalCommit": "a536e2fcb0479659a1d7e18588a86b86eafd6d09", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5NjYxNTQ3NQ==", "url": "https://github.com/prestodb/presto/pull/14234#discussion_r396615475", "bodyText": "this variable is not used; remove", "author": "mbasmanova", "createdAt": "2020-03-23T17:11:50Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/repartition/OptimizedPartitionedOutputOperator.java", "diffHunk": "@@ -612,6 +612,7 @@ private void appendData(DecodedBlockNode[] decodedBlocks, int fixedWidthRowSize,\n                 int offset = 0;\n                 do {\n                     int batchSize = calculateNextBatchSize(fixedWidthRowSize, variableWidthChannels, offset, serializedRowSizes);\n+                    boolean lastBatchInPage = offset + batchSize >= positionCount;", "originalCommit": "9cd46f7787729826f5b1828a5719bc1e28857a99", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "af751dd2067a72d5c15a90e00ed5432245a0d6ec", "url": "https://github.com/prestodb/presto/commit/af751dd2067a72d5c15a90e00ed5432245a0d6ec", "message": "Reuse serializedRowSizes buffer between different PartitionBuffers", "committedDate": "2020-03-23T18:27:09Z", "type": "commit"}, {"oid": "cdc37ee8b220e97234db8cc2aecb344a1e6bd721", "url": "https://github.com/prestodb/presto/commit/cdc37ee8b220e97234db8cc2aecb344a1e6bd721", "message": "Add ArrayAllocator to BlockEncodingBuffer", "committedDate": "2020-03-23T18:27:16Z", "type": "commit"}, {"oid": "2437894fb0cf2744e178461b8856bdcc7d41d75e", "url": "https://github.com/prestodb/presto/commit/2437894fb0cf2744e178461b8856bdcc7d41d75e", "message": "Reuse offsetsCopy in BlockEncodingBuffer", "committedDate": "2020-03-23T18:27:16Z", "type": "commit"}, {"oid": "7d4c57cb92bce69690a37fb3d3707240e3fded78", "url": "https://github.com/prestodb/presto/commit/7d4c57cb92bce69690a37fb3d3707240e3fded78", "message": "Add isNested flag to BlockEncodingBuffer", "committedDate": "2020-03-23T18:27:16Z", "type": "commit"}, {"oid": "d31e75307b837480c99a0794eec36582f6bd3fa8", "url": "https://github.com/prestodb/presto/commit/d31e75307b837480c99a0794eec36582f6bd3fa8", "message": "Reuse positions, mappedPositions and offsets in BlockEncodingBuffer\n\nThe positions and offsets arrays for composite blocks and mappedPositions\nfor DictionaryBlock can be reused after appending the last batch in this\ncolumn to the BlockEncodingBuffers. For pages with two level nested array\ncolumns, this optimization can save 30% memory.", "committedDate": "2020-03-23T18:27:55Z", "type": "commit"}, {"oid": "d31e75307b837480c99a0794eec36582f6bd3fa8", "url": "https://github.com/prestodb/presto/commit/d31e75307b837480c99a0794eec36582f6bd3fa8", "message": "Reuse positions, mappedPositions and offsets in BlockEncodingBuffer\n\nThe positions and offsets arrays for composite blocks and mappedPositions\nfor DictionaryBlock can be reused after appending the last batch in this\ncolumn to the BlockEncodingBuffers. For pages with two level nested array\ncolumns, this optimization can save 30% memory.", "committedDate": "2020-03-23T18:27:55Z", "type": "forcePushed"}]}