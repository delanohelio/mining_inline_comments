{"pr_number": 15269, "pr_title": "Add option to do more precise ACL checks", "pr_createdAt": "2020-10-05T23:30:43Z", "pr_url": "https://github.com/prestodb/presto/pull/15269", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyODQwMQ==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r499928401", "bodyText": "Make the constructor private and add a static function that analyzes it - stylistically better.", "author": "kaikalur", "createdAt": "2020-10-05T23:38:29Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/Analyzer.java", "diffHunk": "@@ -79,6 +80,7 @@ public Analysis analyze(Statement statement, boolean isDescribe)\n         Analysis analysis = new Analysis(rewrittenStatement, parameters, isDescribe);\n         StatementAnalyzer analyzer = new StatementAnalyzer(analysis, metadata, sqlParser, accessControl, session, warningCollector);\n         analyzer.analyze(rewrittenStatement, Optional.empty());\n+        new PostPruningTableColumnsAnalyzer(analysis).analyze(analysis.getStatement());", "originalCommit": "47ecbe88ec0bc49d8ec4cca0393e026b8f4548fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxOTY0MQ==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r502719641", "bodyText": "Done", "author": "prithvip", "createdAt": "2020-10-10T00:16:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyODQwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyOTQwNw==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r499929407", "bodyText": "You should not need the setter?", "author": "kaikalur", "createdAt": "2020-10-05T23:42:16Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/Analysis.java", "diffHunk": "@@ -668,6 +670,16 @@ public void addEmptyColumnReferencesForTable(AccessControl accessControl, Identi\n         return tableColumnReferences;\n     }\n \n+    public void setTableColumnReferencesAfterPruning(HashMultimap<QualifiedObjectName, String> tableColumnReferencesAfterPruning)", "originalCommit": "47ecbe88ec0bc49d8ec4cca0393e026b8f4548fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxOTY3OQ==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r502719679", "bodyText": "Removed the setter", "author": "prithvip", "createdAt": "2020-10-10T00:16:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyOTQwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyOTY0NA==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r499929644", "bodyText": "Add a helper function in Analysis that takes a table and returns columns so all the access checking logic is in one place.", "author": "kaikalur", "createdAt": "2020-10-05T23:43:13Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/Analyzer.java", "diffHunk": "@@ -88,7 +90,7 @@ public Analysis analyze(Statement statement, boolean isDescribe)\n                                 accessControlInfo.getIdentity(),\n                                 session.getAccessControlContext(),\n                                 tableName,\n-                                columns)));\n+                                isCheckAccessControlAfterColumnPruning(session) ? analysis.getTableColumnReferencesAfterPruning().get(tableName) : columns)));", "originalCommit": "47ecbe88ec0bc49d8ec4cca0393e026b8f4548fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxOTY5OQ==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r502719699", "bodyText": "Done", "author": "prithvip", "createdAt": "2020-10-10T00:17:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkyOTY0NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkzMDQ1MA==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r499930450", "bodyText": "I thought we originally thought we could use the maps from Analysis for this work? That didn't work out? One issue here is if we add some new clauses you might miss them if there is no visitor.", "author": "kaikalur", "createdAt": "2020-10-05T23:45:58Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/PostPruningTableColumnsAnalyzer.java", "diffHunk": "@@ -0,0 +1,327 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.analyzer;\n+\n+import com.facebook.presto.metadata.QualifiedObjectName;\n+import com.facebook.presto.sql.tree.AliasedRelation;\n+import com.facebook.presto.sql.tree.DefaultTraversalVisitor;\n+import com.facebook.presto.sql.tree.DereferenceExpression;\n+import com.facebook.presto.sql.tree.Except;\n+import com.facebook.presto.sql.tree.Expression;\n+import com.facebook.presto.sql.tree.FieldReference;\n+import com.facebook.presto.sql.tree.Identifier;\n+import com.facebook.presto.sql.tree.Intersect;\n+import com.facebook.presto.sql.tree.Join;\n+import com.facebook.presto.sql.tree.JoinOn;\n+import com.facebook.presto.sql.tree.Lateral;\n+import com.facebook.presto.sql.tree.Node;\n+import com.facebook.presto.sql.tree.NodeRef;\n+import com.facebook.presto.sql.tree.Query;\n+import com.facebook.presto.sql.tree.QuerySpecification;\n+import com.facebook.presto.sql.tree.Relation;\n+import com.facebook.presto.sql.tree.SampledRelation;\n+import com.facebook.presto.sql.tree.Table;\n+import com.facebook.presto.sql.tree.TableSubquery;\n+import com.facebook.presto.sql.tree.Union;\n+import com.facebook.presto.sql.tree.Unnest;\n+import com.facebook.presto.sql.tree.Values;\n+import com.google.common.collect.ArrayListMultimap;\n+import com.google.common.collect.HashMultimap;\n+import com.google.common.collect.ImmutableSet;\n+import com.google.common.collect.ListMultimap;\n+\n+import java.util.List;\n+\n+/**\n+ * Finds all fields in the query that would be read, after pruning.\n+ *\n+ * The high-level algorithm works as follows:\n+ * 1. Find all fields referenced in all clauses of the outermost SELECT query, and add them to an explore list.\n+ * 2. For each field reference F, find its relation R.\n+ * 3. If R is a SELECT query:\n+ *    a. Find the SELECT item expression that F references. Add all fields referenced by that expression to the explore list.\n+ *    b. Add all fields referenced by every other clause of the SELECT query to the explore list.\n+ * 4. Otherwise,\n+ *    a. Add F's referenced field to a referenced fields list.\n+ *    b. For each child of R, find the child field of F, and add it to the explore list.\n+ * 5. Repeat from step 2 for all fields in the explore list, until all have been resolved to a base table relation.\n+ *\n+ * The pruning step takes place in step 3a, where output expressions that have not been previously referenced, are ignored (pruned).\n+ * The referenced fields list at the end of this algorithm will contain all the columns referenced by the query, after pruning.\n+ */\n+public class PostPruningTableColumnsAnalyzer\n+{\n+    private final Analysis analysis;\n+\n+    public PostPruningTableColumnsAnalyzer(Analysis analysis)\n+    {\n+        this.analysis = analysis;\n+    }\n+\n+    public void analyze(Node node)", "originalCommit": "47ecbe88ec0bc49d8ec4cca0393e026b8f4548fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU1OTM3Mw==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r503559373", "bodyText": "The visitor pattern was a lot cleaner than a graph traversal of the maps in Analysis. This would only miss something, if we add a new Relation node to the AST. Other nodes would be visited by the default traversal.", "author": "prithvip", "createdAt": "2020-10-12T22:10:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5OTkzMDQ1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM1MzA4NA==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r501353084", "bodyText": "The name of the session is not clear. This is describing what it does rather than what it achieves. So maybe change to \"check_access_control_on_referenced_columns_only\" or something along that line.", "author": "rongrong", "createdAt": "2020-10-07T22:47:36Z", "path": "presto-main/src/main/java/com/facebook/presto/SystemSessionProperties.java", "diffHunk": "@@ -171,6 +171,7 @@\n     public static final String FRAGMENT_RESULT_CACHING_ENABLED = \"fragment_result_caching_enabled\";\n     public static final String LEGACY_TYPE_COERCION_WARNING_ENABLED = \"legacy_type_coercion_warning_enabled\";\n     public static final String INLINE_SQL_FUNCTIONS = \"inline_sql_functions\";\n+    public static final String CHECK_ACCESS_CONTROL_AFTER_COLUMN_PRUNING = \"check_access_control_after_column_pruning\";", "originalCommit": "47ecbe88ec0bc49d8ec4cca0393e026b8f4548fd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMjcxOTgwMA==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r502719800", "bodyText": "Changed the name to \"check_access_control_on_impacting_columns_only\"", "author": "prithvip", "createdAt": "2020-10-10T00:17:53Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMTM1MzA4NA=="}], "type": "inlineReview"}, {"oid": "be39ea8f5377492a1f48dbf8eb75d8885136a6a3", "url": "https://github.com/prestodb/presto/commit/be39ea8f5377492a1f48dbf8eb75d8885136a6a3", "message": "Add option to do more precise ACL checks\n\nBefore this change, Presto would check for column access permission on\nall columns referenced in any part of the query.\nThis behavior can sometimes be undesirable, for example, in this query:\n\n``SELECT name FROM (SELECT * FROM nation)``\n\nDuring execution of this query, access checks would be performed on all\ncolumns in the table nation, even though only the column ``name`` would\nactually be read during the execution of the query, and the other\ncolumns in the table have no impact on the query results.\n\nThis change introduces a new sesion property,\n``check_access_control_on_impacting_columns_only``, which, when\nenabled, will only perform access control checks on columns that would\nactually impact the query output.", "committedDate": "2020-10-10T00:14:58Z", "type": "forcePushed"}, {"oid": "cbd8b0f2fe4eb597a7ce9a91090c3867c7f7215a", "url": "https://github.com/prestodb/presto/commit/cbd8b0f2fe4eb597a7ce9a91090c3867c7f7215a", "message": "Add option to do more precise ACL checks\n\nBefore this change, Presto would check for column access permission on\nall columns referenced in any part of the query.\nThis behavior can sometimes be undesirable, for example, in this query:\n\n``SELECT name FROM (SELECT * FROM nation)``\n\nDuring execution of this query, access checks would be performed on all\ncolumns in the table nation, even though only the column ``name`` would\nactually be read during the execution of the query, and the other\ncolumns in the table have no impact on the query results.\n\nThis change introduces a new sesion property,\n``check_access_control_on_impacting_columns_only``, which, when\nenabled, will only perform access control checks on columns that would\nactually impact the query output.", "committedDate": "2020-10-10T00:44:31Z", "type": "forcePushed"}, {"oid": "bbc4184c8378fc7ccb155711763d9e58a586b4f8", "url": "https://github.com/prestodb/presto/commit/bbc4184c8378fc7ccb155711763d9e58a586b4f8", "message": "Add option to do more precise ACL checks\n\nBefore this change, Presto would check for column access permission on\nall columns referenced in any part of the query.\nThis behavior can sometimes be undesirable, for example, in this query:\n\n``SELECT name FROM (SELECT * FROM nation)``\n\nDuring execution of this query, access checks would be performed on all\ncolumns in the table nation, even though only the column ``name`` would\nactually be read during the execution of the query, and the other\ncolumns in the table have no impact on the query results.\n\nThis change introduces a new sesion property,\n``check_access_control_on_impacting_columns_only``, which, when\nenabled, will only perform access control checks on columns that would\nactually impact the query output.", "committedDate": "2020-10-10T04:02:10Z", "type": "forcePushed"}, {"oid": "f641d388866fce9678b710ae06644e05d5475cbb", "url": "https://github.com/prestodb/presto/commit/f641d388866fce9678b710ae06644e05d5475cbb", "message": "Add option to do more precise ACL checks\n\nBefore this change, Presto would check for column access permission on\nall columns referenced in any part of the query.\nThis behavior can sometimes be undesirable, for example, in this query:\n\n``SELECT name FROM (SELECT * FROM nation)``\n\nDuring execution of this query, access checks would be performed on all\ncolumns in the table nation, even though only the column ``name`` would\nactually be read during the execution of the query, and the other\ncolumns in the table have no impact on the query results.\n\nThis change introduces a new sesion property,\n``check_access_control_on_impacting_columns_only``, which, when\nenabled, will only perform access control checks on columns that would\nactually impact the query output.", "committedDate": "2020-10-12T16:10:00Z", "type": "forcePushed"}, {"oid": "b8e61659a424abc08869182cc9d1f54a2b2b7279", "url": "https://github.com/prestodb/presto/commit/b8e61659a424abc08869182cc9d1f54a2b2b7279", "message": "Add option to do more precise ACL checks\n\nBefore this change, Presto would check for column access permission on\nall columns referenced in any part of the query.\nThis behavior can sometimes be undesirable, for example, in this query:\n\n``SELECT name FROM (SELECT * FROM nation)``\n\nDuring execution of this query, access checks would be performed on all\ncolumns in the table nation, even though only the column ``name`` would\nactually be read during the execution of the query, and the other\ncolumns in the table have no impact on the query results.\n\nThis change introduces a new sesion property,\n``check_access_control_on_impacting_columns_only``, which, when\nenabled, will only perform access control checks on columns that would\nactually impact the query output.", "committedDate": "2020-10-12T17:24:12Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ4Nzc3Mw==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r503487773", "bodyText": "The word \"impacting\" is quite confusing to me. Does this have a specific meaning in SQL / language / compiler? I felt \"referenced\" makes more sense.", "author": "rongrong", "createdAt": "2020-10-12T19:21:30Z", "path": "presto-main/src/main/java/com/facebook/presto/SystemSessionProperties.java", "diffHunk": "@@ -170,6 +170,7 @@\n     public static final String FRAGMENT_RESULT_CACHING_ENABLED = \"fragment_result_caching_enabled\";\n     public static final String LEGACY_TYPE_COERCION_WARNING_ENABLED = \"legacy_type_coercion_warning_enabled\";\n     public static final String INLINE_SQL_FUNCTIONS = \"inline_sql_functions\";\n+    public static final String CHECK_ACCESS_CONTROL_ON_IMPACTING_COLUMNS_ONLY = \"check_access_control_on_impacting_columns_only\";", "originalCommit": "b8e61659a424abc08869182cc9d1f54a2b2b7279", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU1NzU1OQ==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r503557559", "bodyText": "I couldn't think of a better word. I didn't like \"referenced\" because a column could be \"referenced\" if it appears in a subquery, even if it might be pruned later. And this definition of \"referenced\" is what is used in the codebase, for example, in \"tableColumnReferences\" in analysis, or \"columnReferences\". What do you think of \"used columns\" or \"utilized columns\"? Other ideas: \"columns post pruning\", \"columns affecting output\", \"influencing columns\"?", "author": "prithvip", "createdAt": "2020-10-12T22:05:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ4Nzc3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzU3MDA3MA==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r503570070", "bodyText": "ya, my worry is that \"reference\" has a specific meaning. Maybe a more generic \"used\"?", "author": "rongrong", "createdAt": "2020-10-12T22:43:51Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ4Nzc3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTc5NTcyMg==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r505795722", "bodyText": "Changed \"impacting\" to \"utilized\"", "author": "prithvip", "createdAt": "2020-10-15T19:43:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwMzQ4Nzc3Mw=="}], "type": "inlineReview"}, {"oid": "e0b6bf9ab035daded86ff99940ada0eff42d6b67", "url": "https://github.com/prestodb/presto/commit/e0b6bf9ab035daded86ff99940ada0eff42d6b67", "message": "Add option to do more precise ACL checks\n\nBefore this change, Presto would check for column access permission on\nall columns referenced in any part of the query.\nThis behavior can sometimes be undesirable, for example, in this query:\n\n``SELECT name FROM (SELECT * FROM nation)``\n\nDuring execution of this query, access checks would be performed on all\ncolumns in the table nation, even though only the column ``name`` would\nactually be read during the execution of the query, and the other\ncolumns in the table have no impact on the query results.\n\nThis change introduces a new sesion property,\n``check_access_control_on_impacting_columns_only``, which, when\nenabled, will only perform access control checks on columns that would\nactually impact the query output.", "committedDate": "2020-10-12T22:12:56Z", "type": "forcePushed"}, {"oid": "a600db54a7beea3a36a37c69d9182c045c31b6b7", "url": "https://github.com/prestodb/presto/commit/a600db54a7beea3a36a37c69d9182c045c31b6b7", "message": "Add option to do more precise ACL checks\n\nBefore this change, Presto would check for column access permission on\nall columns referenced in any part of the query.\nThis behavior can sometimes be undesirable, for example, in this query:\n\n``SELECT name FROM (SELECT * FROM nation)``\n\nDuring execution of this query, access checks would be performed on all\ncolumns in the table nation, even though only the column ``name`` would\nactually be read during the execution of the query, and the other\ncolumns in the table have no impact on the query results.\n\nThis change introduces a new sesion property,\n``check_access_control_on_impacting_columns_only``, which, when\nenabled, will only perform access control checks on columns that would\nactually impact the query output.", "committedDate": "2020-10-12T22:48:19Z", "type": "forcePushed"}, {"oid": "9fe4d501ac85026c4949d6d4748921fe1fa86e45", "url": "https://github.com/prestodb/presto/commit/9fe4d501ac85026c4949d6d4748921fe1fa86e45", "message": "Add option to do more precise ACL checks\n\nBefore this change, Presto would check for column access permission on\nall columns referenced in any part of the query.\nThis behavior can sometimes be undesirable, for example, in this query:\n\n``SELECT name FROM (SELECT * FROM nation)``\n\nDuring execution of this query, access checks would be performed on all\ncolumns in the table nation, even though only the column ``name`` would\nactually be read during the execution of the query, and the other\ncolumns in the table have no impact on the query results.\n\nThis change introduces a new sesion property,\n``check_access_control_on_utilized_columns_only``, which, when\nenabled, will only perform access control checks on columns that would\nactually be required to produce the query output, ignoring columns that\nare referenced in the query, but are not required to compute the query\nresults.", "committedDate": "2020-10-15T19:42:03Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg1OTM4OQ==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r505859389", "bodyText": "A better style would be to send the session object to the function and do the flag check there for better encapsulation.", "author": "kaikalur", "createdAt": "2020-10-15T21:16:43Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/Analyzer.java", "diffHunk": "@@ -79,9 +81,10 @@ public Analysis analyze(Statement statement, boolean isDescribe)\n         Analysis analysis = new Analysis(rewrittenStatement, parameters, isDescribe);\n         StatementAnalyzer analyzer = new StatementAnalyzer(analysis, metadata, sqlParser, accessControl, session, warningCollector);\n         analyzer.analyze(rewrittenStatement, Optional.empty());\n+        analyzeForUtilizedColumns(analysis, analysis.getStatement());\n \n         // check column access permissions for each table\n-        analysis.getTableColumnReferences().forEach((accessControlInfo, tableColumnReferences) ->\n+        analysis.getTableColumnReferencesForAccessControl(isCheckAccessControlOnUtilizedColumnsOnly(session)).forEach((accessControlInfo, tableColumnReferences) ->", "originalCommit": "9fe4d501ac85026c4949d6d4748921fe1fa86e45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkyOTg4Mw==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r505929883", "bodyText": "Done", "author": "prithvip", "createdAt": "2020-10-16T00:01:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg1OTM4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg2MTQ3Ng==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r505861476", "bodyText": "This is missing still?", "author": "kaikalur", "createdAt": "2020-10-15T21:19:25Z", "path": "presto-main/src/test/java/com/facebook/presto/sql/analyzer/TestUtilizedColumnsAnalyzer.java", "diffHunk": "@@ -0,0 +1,444 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.analyzer;\n+\n+import com.facebook.presto.metadata.QualifiedObjectName;\n+import com.facebook.presto.spi.WarningCollector;\n+import com.facebook.presto.sql.tree.Statement;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.facebook.presto.transaction.TransactionBuilder.transaction;\n+import static org.testng.Assert.assertEquals;\n+\n+@Test(singleThreaded = true)\n+public class TestUtilizedColumnsAnalyzer\n+        extends AbstractAnalyzerTest\n+{\n+    @Test\n+    public void testWildcardSelect()\n+    {\n+        // Test wildcard select\n+        assertUtilizedTableColumns(\"SELECT * FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\", \"d\")));\n+\n+        // Test outer select * captures everything\n+        assertUtilizedTableColumns(\"SELECT * FROM (SELECT a + b FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+        assertUtilizedTableColumns(\"SELECT * FROM (SELECT a + b FROM (SELECT * FROM t1))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testCountStar()\n+    {\n+        // Test count(*) should not need column access for anything, but should still need table access\n+        assertUtilizedTableColumns(\"SELECT count(*) FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of()));\n+    }\n+\n+    @Test\n+    public void testRecursiveProjectionPruning()\n+    {\n+        // Test recursive pruning of projections in subquery\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT * FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT a, b FROM (SELECT a, b, c FROM t1))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+    }\n+\n+    @Test\n+    public void testAliasing()\n+    {\n+        // Test aliasing\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT *, a as x FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+\n+        // Test alias expression wih multiple columns referenced in alias\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT *, a + b as x FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test chained aliasing\n+        assertUtilizedTableColumns(\"SELECT x + 3 FROM (SELECT y + 2 as x FROM (SELECT z + 1 as y FROM (SELECT a as z FROM t1 WHERE b = 1)))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test aliased relation\n+        assertUtilizedTableColumns(\"SELECT mytable.a, mytable.b FROM (SELECT * FROM t1 WHERE t1.c = 1) mytable\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Test aliased relation for self-join\n+        assertUtilizedTableColumns(\"SELECT x.a, y.b FROM t1 x, t1 y\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test filter on aliased relation\n+        assertUtilizedTableColumns(\"SELECT count(x) FROM (SELECT a as x, * FROM t1) t WHERE t.b = 3\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test aliased relation with column aliases\n+        assertUtilizedTableColumns(\"SELECT y FROM (SELECT x, y FROM t1 AS mytable (w, x, y, z))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"c\")));\n+    }\n+\n+    @Test\n+    public void testJoin()\n+    {\n+        // Joins with column aliases\n+        assertUtilizedTableColumns(\"SELECT t2.a + y FROM t2 CROSS JOIN (SELECT *, c + d AS y FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"c\", \"d\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+        assertUtilizedTableColumns(\"SELECT mytable.a + myothertable.b AS f1, myothertable.z FROM t2 AS mytable CROSS JOIN (SELECT *, a + b AS x, c - 1 AS z FROM t1) myothertable\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // Columns in join criteria with ON should be checked\n+        assertUtilizedTableColumns(\"SELECT t1.a FROM t1 JOIN t2 ON t1.c = t2.b\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"b\")));\n+\n+        // TODO: Columns in join criteria with USING should be checked\n+        //assertUtilizedTableColumns(\"SELECT t1.c FROM t1 JOIN t2 USING (a, b)\",\n+        //        ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\", \"b\")));", "originalCommit": "9fe4d501ac85026c4949d6d4748921fe1fa86e45", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg2NDE1NA==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r505864154", "bodyText": "Need more join coverage - especially using nested subqueries and where clauses.", "author": "kaikalur", "createdAt": "2020-10-15T21:22:36Z", "path": "presto-main/src/test/java/com/facebook/presto/sql/analyzer/TestUtilizedColumnsAnalyzer.java", "diffHunk": "@@ -0,0 +1,444 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.analyzer;\n+\n+import com.facebook.presto.metadata.QualifiedObjectName;\n+import com.facebook.presto.spi.WarningCollector;\n+import com.facebook.presto.sql.tree.Statement;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.facebook.presto.transaction.TransactionBuilder.transaction;\n+import static org.testng.Assert.assertEquals;\n+\n+@Test(singleThreaded = true)\n+public class TestUtilizedColumnsAnalyzer\n+        extends AbstractAnalyzerTest\n+{\n+    @Test\n+    public void testWildcardSelect()\n+    {\n+        // Test wildcard select\n+        assertUtilizedTableColumns(\"SELECT * FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\", \"d\")));\n+\n+        // Test outer select * captures everything\n+        assertUtilizedTableColumns(\"SELECT * FROM (SELECT a + b FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+        assertUtilizedTableColumns(\"SELECT * FROM (SELECT a + b FROM (SELECT * FROM t1))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testCountStar()\n+    {\n+        // Test count(*) should not need column access for anything, but should still need table access\n+        assertUtilizedTableColumns(\"SELECT count(*) FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of()));\n+    }\n+\n+    @Test\n+    public void testRecursiveProjectionPruning()\n+    {\n+        // Test recursive pruning of projections in subquery\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT * FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT a, b FROM (SELECT a, b, c FROM t1))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+    }\n+\n+    @Test\n+    public void testAliasing()\n+    {\n+        // Test aliasing\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT *, a as x FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+\n+        // Test alias expression wih multiple columns referenced in alias\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT *, a + b as x FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test chained aliasing\n+        assertUtilizedTableColumns(\"SELECT x + 3 FROM (SELECT y + 2 as x FROM (SELECT z + 1 as y FROM (SELECT a as z FROM t1 WHERE b = 1)))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test aliased relation\n+        assertUtilizedTableColumns(\"SELECT mytable.a, mytable.b FROM (SELECT * FROM t1 WHERE t1.c = 1) mytable\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Test aliased relation for self-join\n+        assertUtilizedTableColumns(\"SELECT x.a, y.b FROM t1 x, t1 y\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test filter on aliased relation\n+        assertUtilizedTableColumns(\"SELECT count(x) FROM (SELECT a as x, * FROM t1) t WHERE t.b = 3\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test aliased relation with column aliases\n+        assertUtilizedTableColumns(\"SELECT y FROM (SELECT x, y FROM t1 AS mytable (w, x, y, z))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"c\")));\n+    }\n+\n+    @Test\n+    public void testJoin()\n+    {\n+        // Joins with column aliases\n+        assertUtilizedTableColumns(\"SELECT t2.a + y FROM t2 CROSS JOIN (SELECT *, c + d AS y FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"c\", \"d\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+        assertUtilizedTableColumns(\"SELECT mytable.a + myothertable.b AS f1, myothertable.z FROM t2 AS mytable CROSS JOIN (SELECT *, a + b AS x, c - 1 AS z FROM t1) myothertable\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // Columns in join criteria with ON should be checked\n+        assertUtilizedTableColumns(\"SELECT t1.a FROM t1 JOIN t2 ON t1.c = t2.b\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"b\")));", "originalCommit": "9fe4d501ac85026c4949d6d4748921fe1fa86e45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkyOTk5NQ==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r505929995", "bodyText": "Added more coverage here", "author": "prithvip", "createdAt": "2020-10-16T00:02:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg2NDE1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg2NDc1Mg==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r505864752", "bodyText": "Add some tests for group by ordinals - GROUP BY 1,2 etc.", "author": "kaikalur", "createdAt": "2020-10-15T21:23:21Z", "path": "presto-main/src/test/java/com/facebook/presto/sql/analyzer/TestUtilizedColumnsAnalyzer.java", "diffHunk": "@@ -0,0 +1,444 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.analyzer;\n+\n+import com.facebook.presto.metadata.QualifiedObjectName;\n+import com.facebook.presto.spi.WarningCollector;\n+import com.facebook.presto.sql.tree.Statement;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.facebook.presto.transaction.TransactionBuilder.transaction;\n+import static org.testng.Assert.assertEquals;\n+\n+@Test(singleThreaded = true)\n+public class TestUtilizedColumnsAnalyzer\n+        extends AbstractAnalyzerTest\n+{\n+    @Test\n+    public void testWildcardSelect()\n+    {\n+        // Test wildcard select\n+        assertUtilizedTableColumns(\"SELECT * FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\", \"d\")));\n+\n+        // Test outer select * captures everything\n+        assertUtilizedTableColumns(\"SELECT * FROM (SELECT a + b FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+        assertUtilizedTableColumns(\"SELECT * FROM (SELECT a + b FROM (SELECT * FROM t1))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testCountStar()\n+    {\n+        // Test count(*) should not need column access for anything, but should still need table access\n+        assertUtilizedTableColumns(\"SELECT count(*) FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of()));\n+    }\n+\n+    @Test\n+    public void testRecursiveProjectionPruning()\n+    {\n+        // Test recursive pruning of projections in subquery\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT * FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT a, b FROM (SELECT a, b, c FROM t1))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+    }\n+\n+    @Test\n+    public void testAliasing()\n+    {\n+        // Test aliasing\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT *, a as x FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+\n+        // Test alias expression wih multiple columns referenced in alias\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT *, a + b as x FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test chained aliasing\n+        assertUtilizedTableColumns(\"SELECT x + 3 FROM (SELECT y + 2 as x FROM (SELECT z + 1 as y FROM (SELECT a as z FROM t1 WHERE b = 1)))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test aliased relation\n+        assertUtilizedTableColumns(\"SELECT mytable.a, mytable.b FROM (SELECT * FROM t1 WHERE t1.c = 1) mytable\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Test aliased relation for self-join\n+        assertUtilizedTableColumns(\"SELECT x.a, y.b FROM t1 x, t1 y\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test filter on aliased relation\n+        assertUtilizedTableColumns(\"SELECT count(x) FROM (SELECT a as x, * FROM t1) t WHERE t.b = 3\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test aliased relation with column aliases\n+        assertUtilizedTableColumns(\"SELECT y FROM (SELECT x, y FROM t1 AS mytable (w, x, y, z))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"c\")));\n+    }\n+\n+    @Test\n+    public void testJoin()\n+    {\n+        // Joins with column aliases\n+        assertUtilizedTableColumns(\"SELECT t2.a + y FROM t2 CROSS JOIN (SELECT *, c + d AS y FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"c\", \"d\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+        assertUtilizedTableColumns(\"SELECT mytable.a + myothertable.b AS f1, myothertable.z FROM t2 AS mytable CROSS JOIN (SELECT *, a + b AS x, c - 1 AS z FROM t1) myothertable\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // Columns in join criteria with ON should be checked\n+        assertUtilizedTableColumns(\"SELECT t1.a FROM t1 JOIN t2 ON t1.c = t2.b\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"b\")));\n+\n+        // TODO: Columns in join criteria with USING should be checked\n+        //assertUtilizedTableColumns(\"SELECT t1.c FROM t1 JOIN t2 USING (a, b)\",\n+        //        ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testGroupBy()\n+    {\n+        // Capture column in GROUP BY\n+        assertUtilizedTableColumns(\"SELECT a, b FROM (SELECT count(a) AS a, avg(b) AS b FROM t1 GROUP BY c)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Capture columns in subquery in GROUP BY expression\n+        assertUtilizedTableColumns(\"SELECT a, b FROM (SELECT count(a) AS a, avg(b) AS b FROM t1 GROUP BY (c * (SELECT max(a) FROM t2)))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // Capture column in HAVING\n+        assertUtilizedTableColumns(\"SELECT count(a) AS c FROM t1 WHERE b = 0 GROUP BY c HAVING max(d) > 10\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\", \"d\")));\n+\n+        // Capture columns in subquery in HAVING expression\n+        assertUtilizedTableColumns(\"SELECT count(a) FROM t1 GROUP BY b HAVING count(a) > (SELECT max(a) FROM t2)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // ROLLUP, CUBE, and GROUPING SETS do not allow for expressions so we only need to test for explicit columns\n+\n+        // Capture column in ROLLUP\n+        assertUtilizedTableColumns(\"SELECT a, b FROM (SELECT count(a) AS a, avg(b) AS b FROM t1 GROUP BY ROLLUP(c))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Capture column in CUBE\n+        assertUtilizedTableColumns(\"SELECT a, b FROM (SELECT count(a) AS a, avg(b) AS b FROM t1 GROUP BY CUBE(c, d))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\", \"d\")));\n+\n+        // Capture columns in GROUPING SETS\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT sum(c) AS x FROM t1 GROUP BY GROUPING SETS (a, b))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT grouping(a, b) AS x FROM t1 GROUP BY GROUPING SETS (a, b))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));", "originalCommit": "9fe4d501ac85026c4949d6d4748921fe1fa86e45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg3ODQ0MQ==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r505878441", "bodyText": "I have a separate set of tests for ordinals in testOrdinal", "author": "prithvip", "createdAt": "2020-10-15T21:41:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg2NDc1Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkzMDA3Nw==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r505930077", "bodyText": "Moved ordinal coverage into this test", "author": "prithvip", "createdAt": "2020-10-16T00:02:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg2NDc1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg2NTUxNQ==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r505865515", "bodyText": "How about the columns of t2? Don't you need access for that?", "author": "kaikalur", "createdAt": "2020-10-15T21:24:18Z", "path": "presto-main/src/test/java/com/facebook/presto/sql/analyzer/TestUtilizedColumnsAnalyzer.java", "diffHunk": "@@ -0,0 +1,444 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.analyzer;\n+\n+import com.facebook.presto.metadata.QualifiedObjectName;\n+import com.facebook.presto.spi.WarningCollector;\n+import com.facebook.presto.sql.tree.Statement;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.facebook.presto.transaction.TransactionBuilder.transaction;\n+import static org.testng.Assert.assertEquals;\n+\n+@Test(singleThreaded = true)\n+public class TestUtilizedColumnsAnalyzer\n+        extends AbstractAnalyzerTest\n+{\n+    @Test\n+    public void testWildcardSelect()\n+    {\n+        // Test wildcard select\n+        assertUtilizedTableColumns(\"SELECT * FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\", \"d\")));\n+\n+        // Test outer select * captures everything\n+        assertUtilizedTableColumns(\"SELECT * FROM (SELECT a + b FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+        assertUtilizedTableColumns(\"SELECT * FROM (SELECT a + b FROM (SELECT * FROM t1))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testCountStar()\n+    {\n+        // Test count(*) should not need column access for anything, but should still need table access\n+        assertUtilizedTableColumns(\"SELECT count(*) FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of()));\n+    }\n+\n+    @Test\n+    public void testRecursiveProjectionPruning()\n+    {\n+        // Test recursive pruning of projections in subquery\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT * FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT a, b FROM (SELECT a, b, c FROM t1))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+    }\n+\n+    @Test\n+    public void testAliasing()\n+    {\n+        // Test aliasing\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT *, a as x FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+\n+        // Test alias expression wih multiple columns referenced in alias\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT *, a + b as x FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test chained aliasing\n+        assertUtilizedTableColumns(\"SELECT x + 3 FROM (SELECT y + 2 as x FROM (SELECT z + 1 as y FROM (SELECT a as z FROM t1 WHERE b = 1)))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test aliased relation\n+        assertUtilizedTableColumns(\"SELECT mytable.a, mytable.b FROM (SELECT * FROM t1 WHERE t1.c = 1) mytable\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Test aliased relation for self-join\n+        assertUtilizedTableColumns(\"SELECT x.a, y.b FROM t1 x, t1 y\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test filter on aliased relation\n+        assertUtilizedTableColumns(\"SELECT count(x) FROM (SELECT a as x, * FROM t1) t WHERE t.b = 3\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test aliased relation with column aliases\n+        assertUtilizedTableColumns(\"SELECT y FROM (SELECT x, y FROM t1 AS mytable (w, x, y, z))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"c\")));\n+    }\n+\n+    @Test\n+    public void testJoin()\n+    {\n+        // Joins with column aliases\n+        assertUtilizedTableColumns(\"SELECT t2.a + y FROM t2 CROSS JOIN (SELECT *, c + d AS y FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"c\", \"d\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+        assertUtilizedTableColumns(\"SELECT mytable.a + myothertable.b AS f1, myothertable.z FROM t2 AS mytable CROSS JOIN (SELECT *, a + b AS x, c - 1 AS z FROM t1) myothertable\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // Columns in join criteria with ON should be checked\n+        assertUtilizedTableColumns(\"SELECT t1.a FROM t1 JOIN t2 ON t1.c = t2.b\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"b\")));\n+\n+        // TODO: Columns in join criteria with USING should be checked\n+        //assertUtilizedTableColumns(\"SELECT t1.c FROM t1 JOIN t2 USING (a, b)\",\n+        //        ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testGroupBy()\n+    {\n+        // Capture column in GROUP BY\n+        assertUtilizedTableColumns(\"SELECT a, b FROM (SELECT count(a) AS a, avg(b) AS b FROM t1 GROUP BY c)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Capture columns in subquery in GROUP BY expression\n+        assertUtilizedTableColumns(\"SELECT a, b FROM (SELECT count(a) AS a, avg(b) AS b FROM t1 GROUP BY (c * (SELECT max(a) FROM t2)))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // Capture column in HAVING\n+        assertUtilizedTableColumns(\"SELECT count(a) AS c FROM t1 WHERE b = 0 GROUP BY c HAVING max(d) > 10\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\", \"d\")));\n+\n+        // Capture columns in subquery in HAVING expression\n+        assertUtilizedTableColumns(\"SELECT count(a) FROM t1 GROUP BY b HAVING count(a) > (SELECT max(a) FROM t2)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // ROLLUP, CUBE, and GROUPING SETS do not allow for expressions so we only need to test for explicit columns\n+\n+        // Capture column in ROLLUP\n+        assertUtilizedTableColumns(\"SELECT a, b FROM (SELECT count(a) AS a, avg(b) AS b FROM t1 GROUP BY ROLLUP(c))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Capture column in CUBE\n+        assertUtilizedTableColumns(\"SELECT a, b FROM (SELECT count(a) AS a, avg(b) AS b FROM t1 GROUP BY CUBE(c, d))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\", \"d\")));\n+\n+        // Capture columns in GROUPING SETS\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT sum(c) AS x FROM t1 GROUP BY GROUPING SETS (a, b))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT grouping(a, b) AS x FROM t1 GROUP BY GROUPING SETS (a, b))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testCTE()\n+    {\n+        // Test CTE columns are pruned\n+        assertUtilizedTableColumns(\"WITH mytable AS (SELECT * FROM t1) SELECT x FROM (SELECT a AS x FROM mytable)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+\n+        // CTE filter column is captured\n+        assertUtilizedTableColumns(\"WITH mytable AS (SELECT a as x, b as y FROM t1 WHERE c = 0) SELECT x FROM mytable\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"c\")));\n+\n+        // Unused CTE shouldn't require column level permissions, but should require table level permissions\n+        assertUtilizedTableColumns(\"WITH mytable AS (SELECT * FROM t1) SELECT a FROM t2\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+    }\n+\n+    @Test\n+    public void testInsert()\n+    {\n+        assertUtilizedTableColumns(\"INSERT INTO t2 SELECT a, b FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));", "originalCommit": "9fe4d501ac85026c4949d6d4748921fe1fa86e45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg4MDM5OQ==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r505880399", "bodyText": "These tests are only checking for columns that will be checked for a SELECT_COLUMN privilege. Inserting into t2 is a INSERT_TABLE privilege, and tests for that is covered in the access control tests in AbstractTestQueries.", "author": "prithvip", "createdAt": "2020-10-15T21:44:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg2NTUxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg2Nzk1Nw==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r505867957", "bodyText": "Add :\nselect a,b from (select a,b,c,d from T1 union all select w,x,y,z from T2) where c = 0 and d = c", "author": "kaikalur", "createdAt": "2020-10-15T21:27:09Z", "path": "presto-main/src/test/java/com/facebook/presto/sql/analyzer/TestUtilizedColumnsAnalyzer.java", "diffHunk": "@@ -0,0 +1,444 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.analyzer;\n+\n+import com.facebook.presto.metadata.QualifiedObjectName;\n+import com.facebook.presto.spi.WarningCollector;\n+import com.facebook.presto.sql.tree.Statement;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.facebook.presto.transaction.TransactionBuilder.transaction;\n+import static org.testng.Assert.assertEquals;\n+\n+@Test(singleThreaded = true)\n+public class TestUtilizedColumnsAnalyzer\n+        extends AbstractAnalyzerTest\n+{\n+    @Test\n+    public void testWildcardSelect()\n+    {\n+        // Test wildcard select\n+        assertUtilizedTableColumns(\"SELECT * FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\", \"d\")));\n+\n+        // Test outer select * captures everything\n+        assertUtilizedTableColumns(\"SELECT * FROM (SELECT a + b FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+        assertUtilizedTableColumns(\"SELECT * FROM (SELECT a + b FROM (SELECT * FROM t1))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testCountStar()\n+    {\n+        // Test count(*) should not need column access for anything, but should still need table access\n+        assertUtilizedTableColumns(\"SELECT count(*) FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of()));\n+    }\n+\n+    @Test\n+    public void testRecursiveProjectionPruning()\n+    {\n+        // Test recursive pruning of projections in subquery\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT * FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT a, b FROM (SELECT a, b, c FROM t1))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+    }\n+\n+    @Test\n+    public void testAliasing()\n+    {\n+        // Test aliasing\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT *, a as x FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+\n+        // Test alias expression wih multiple columns referenced in alias\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT *, a + b as x FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test chained aliasing\n+        assertUtilizedTableColumns(\"SELECT x + 3 FROM (SELECT y + 2 as x FROM (SELECT z + 1 as y FROM (SELECT a as z FROM t1 WHERE b = 1)))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test aliased relation\n+        assertUtilizedTableColumns(\"SELECT mytable.a, mytable.b FROM (SELECT * FROM t1 WHERE t1.c = 1) mytable\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Test aliased relation for self-join\n+        assertUtilizedTableColumns(\"SELECT x.a, y.b FROM t1 x, t1 y\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test filter on aliased relation\n+        assertUtilizedTableColumns(\"SELECT count(x) FROM (SELECT a as x, * FROM t1) t WHERE t.b = 3\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test aliased relation with column aliases\n+        assertUtilizedTableColumns(\"SELECT y FROM (SELECT x, y FROM t1 AS mytable (w, x, y, z))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"c\")));\n+    }\n+\n+    @Test\n+    public void testJoin()\n+    {\n+        // Joins with column aliases\n+        assertUtilizedTableColumns(\"SELECT t2.a + y FROM t2 CROSS JOIN (SELECT *, c + d AS y FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"c\", \"d\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+        assertUtilizedTableColumns(\"SELECT mytable.a + myothertable.b AS f1, myothertable.z FROM t2 AS mytable CROSS JOIN (SELECT *, a + b AS x, c - 1 AS z FROM t1) myothertable\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // Columns in join criteria with ON should be checked\n+        assertUtilizedTableColumns(\"SELECT t1.a FROM t1 JOIN t2 ON t1.c = t2.b\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"b\")));\n+\n+        // TODO: Columns in join criteria with USING should be checked\n+        //assertUtilizedTableColumns(\"SELECT t1.c FROM t1 JOIN t2 USING (a, b)\",\n+        //        ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testGroupBy()\n+    {\n+        // Capture column in GROUP BY\n+        assertUtilizedTableColumns(\"SELECT a, b FROM (SELECT count(a) AS a, avg(b) AS b FROM t1 GROUP BY c)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Capture columns in subquery in GROUP BY expression\n+        assertUtilizedTableColumns(\"SELECT a, b FROM (SELECT count(a) AS a, avg(b) AS b FROM t1 GROUP BY (c * (SELECT max(a) FROM t2)))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // Capture column in HAVING\n+        assertUtilizedTableColumns(\"SELECT count(a) AS c FROM t1 WHERE b = 0 GROUP BY c HAVING max(d) > 10\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\", \"d\")));\n+\n+        // Capture columns in subquery in HAVING expression\n+        assertUtilizedTableColumns(\"SELECT count(a) FROM t1 GROUP BY b HAVING count(a) > (SELECT max(a) FROM t2)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // ROLLUP, CUBE, and GROUPING SETS do not allow for expressions so we only need to test for explicit columns\n+\n+        // Capture column in ROLLUP\n+        assertUtilizedTableColumns(\"SELECT a, b FROM (SELECT count(a) AS a, avg(b) AS b FROM t1 GROUP BY ROLLUP(c))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Capture column in CUBE\n+        assertUtilizedTableColumns(\"SELECT a, b FROM (SELECT count(a) AS a, avg(b) AS b FROM t1 GROUP BY CUBE(c, d))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\", \"d\")));\n+\n+        // Capture columns in GROUPING SETS\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT sum(c) AS x FROM t1 GROUP BY GROUPING SETS (a, b))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT grouping(a, b) AS x FROM t1 GROUP BY GROUPING SETS (a, b))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testCTE()\n+    {\n+        // Test CTE columns are pruned\n+        assertUtilizedTableColumns(\"WITH mytable AS (SELECT * FROM t1) SELECT x FROM (SELECT a AS x FROM mytable)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+\n+        // CTE filter column is captured\n+        assertUtilizedTableColumns(\"WITH mytable AS (SELECT a as x, b as y FROM t1 WHERE c = 0) SELECT x FROM mytable\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"c\")));\n+\n+        // Unused CTE shouldn't require column level permissions, but should require table level permissions\n+        assertUtilizedTableColumns(\"WITH mytable AS (SELECT * FROM t1) SELECT a FROM t2\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+    }\n+\n+    @Test\n+    public void testInsert()\n+    {\n+        assertUtilizedTableColumns(\"INSERT INTO t2 SELECT a, b FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testCTAS()\n+    {\n+        assertUtilizedTableColumns(\"CREATE TABLE foo AS SELECT a, b FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testOrdinal()\n+    {\n+        // Test ordinal in GROUP BY\n+        assertUtilizedTableColumns(\"SELECT * FROM (SELECT count(a), count(b), c FROM t1 WHERE b = 0 GROUP BY 3)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Test ordinal in ORDER BY\n+        assertUtilizedTableColumns(\"SELECT * FROM (SELECT b, c FROM t1 WHERE b = 0 ORDER BY 2)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"b\", \"c\")));\n+    }\n+\n+    @Test\n+    public void testSetOperations()\n+    {\n+        // Test EXCEPT\n+        assertUtilizedTableColumns(\"SELECT a, b FROM t1 WHERE c = 0 EXCEPT SELECT * from t2\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test INTERSECT\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT * FROM t1 WHERE t1.b = 0 INTERSECT SELECT * from t1 WHERE t1.c = 0)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Test UNION\n+        assertUtilizedTableColumns(\"SELECT * FROM ((SELECT a, b FROM t1 WHERE c = 0) UNION (SELECT * FROM t2 WHERE b = 0))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\", \"b\")));", "originalCommit": "9fe4d501ac85026c4949d6d4748921fe1fa86e45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkzMDExMw==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r505930113", "bodyText": "Done", "author": "prithvip", "createdAt": "2020-10-16T00:02:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg2Nzk1Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg2OTQ4Mw==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r505869483", "bodyText": "We also have things in where clause so check that\nFB_NECTAR_SAMPLING_PCT(CAST(cms_business_id AS VARCHAR)) < 0.01", "author": "kaikalur", "createdAt": "2020-10-15T21:29:08Z", "path": "presto-main/src/test/java/com/facebook/presto/sql/analyzer/TestUtilizedColumnsAnalyzer.java", "diffHunk": "@@ -0,0 +1,444 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.analyzer;\n+\n+import com.facebook.presto.metadata.QualifiedObjectName;\n+import com.facebook.presto.spi.WarningCollector;\n+import com.facebook.presto.sql.tree.Statement;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.facebook.presto.transaction.TransactionBuilder.transaction;\n+import static org.testng.Assert.assertEquals;\n+\n+@Test(singleThreaded = true)\n+public class TestUtilizedColumnsAnalyzer\n+        extends AbstractAnalyzerTest\n+{\n+    @Test\n+    public void testWildcardSelect()\n+    {\n+        // Test wildcard select\n+        assertUtilizedTableColumns(\"SELECT * FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\", \"d\")));\n+\n+        // Test outer select * captures everything\n+        assertUtilizedTableColumns(\"SELECT * FROM (SELECT a + b FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+        assertUtilizedTableColumns(\"SELECT * FROM (SELECT a + b FROM (SELECT * FROM t1))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testCountStar()\n+    {\n+        // Test count(*) should not need column access for anything, but should still need table access\n+        assertUtilizedTableColumns(\"SELECT count(*) FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of()));\n+    }\n+\n+    @Test\n+    public void testRecursiveProjectionPruning()\n+    {\n+        // Test recursive pruning of projections in subquery\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT * FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT a, b FROM (SELECT a, b, c FROM t1))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+    }\n+\n+    @Test\n+    public void testAliasing()\n+    {\n+        // Test aliasing\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT *, a as x FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+\n+        // Test alias expression wih multiple columns referenced in alias\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT *, a + b as x FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test chained aliasing\n+        assertUtilizedTableColumns(\"SELECT x + 3 FROM (SELECT y + 2 as x FROM (SELECT z + 1 as y FROM (SELECT a as z FROM t1 WHERE b = 1)))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test aliased relation\n+        assertUtilizedTableColumns(\"SELECT mytable.a, mytable.b FROM (SELECT * FROM t1 WHERE t1.c = 1) mytable\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Test aliased relation for self-join\n+        assertUtilizedTableColumns(\"SELECT x.a, y.b FROM t1 x, t1 y\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test filter on aliased relation\n+        assertUtilizedTableColumns(\"SELECT count(x) FROM (SELECT a as x, * FROM t1) t WHERE t.b = 3\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test aliased relation with column aliases\n+        assertUtilizedTableColumns(\"SELECT y FROM (SELECT x, y FROM t1 AS mytable (w, x, y, z))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"c\")));\n+    }\n+\n+    @Test\n+    public void testJoin()\n+    {\n+        // Joins with column aliases\n+        assertUtilizedTableColumns(\"SELECT t2.a + y FROM t2 CROSS JOIN (SELECT *, c + d AS y FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"c\", \"d\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+        assertUtilizedTableColumns(\"SELECT mytable.a + myothertable.b AS f1, myothertable.z FROM t2 AS mytable CROSS JOIN (SELECT *, a + b AS x, c - 1 AS z FROM t1) myothertable\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // Columns in join criteria with ON should be checked\n+        assertUtilizedTableColumns(\"SELECT t1.a FROM t1 JOIN t2 ON t1.c = t2.b\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"b\")));\n+\n+        // TODO: Columns in join criteria with USING should be checked\n+        //assertUtilizedTableColumns(\"SELECT t1.c FROM t1 JOIN t2 USING (a, b)\",\n+        //        ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testGroupBy()\n+    {\n+        // Capture column in GROUP BY\n+        assertUtilizedTableColumns(\"SELECT a, b FROM (SELECT count(a) AS a, avg(b) AS b FROM t1 GROUP BY c)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Capture columns in subquery in GROUP BY expression\n+        assertUtilizedTableColumns(\"SELECT a, b FROM (SELECT count(a) AS a, avg(b) AS b FROM t1 GROUP BY (c * (SELECT max(a) FROM t2)))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // Capture column in HAVING\n+        assertUtilizedTableColumns(\"SELECT count(a) AS c FROM t1 WHERE b = 0 GROUP BY c HAVING max(d) > 10\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\", \"d\")));\n+\n+        // Capture columns in subquery in HAVING expression\n+        assertUtilizedTableColumns(\"SELECT count(a) FROM t1 GROUP BY b HAVING count(a) > (SELECT max(a) FROM t2)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // ROLLUP, CUBE, and GROUPING SETS do not allow for expressions so we only need to test for explicit columns\n+\n+        // Capture column in ROLLUP\n+        assertUtilizedTableColumns(\"SELECT a, b FROM (SELECT count(a) AS a, avg(b) AS b FROM t1 GROUP BY ROLLUP(c))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Capture column in CUBE\n+        assertUtilizedTableColumns(\"SELECT a, b FROM (SELECT count(a) AS a, avg(b) AS b FROM t1 GROUP BY CUBE(c, d))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\", \"d\")));\n+\n+        // Capture columns in GROUPING SETS\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT sum(c) AS x FROM t1 GROUP BY GROUPING SETS (a, b))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT grouping(a, b) AS x FROM t1 GROUP BY GROUPING SETS (a, b))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testCTE()\n+    {\n+        // Test CTE columns are pruned\n+        assertUtilizedTableColumns(\"WITH mytable AS (SELECT * FROM t1) SELECT x FROM (SELECT a AS x FROM mytable)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+\n+        // CTE filter column is captured\n+        assertUtilizedTableColumns(\"WITH mytable AS (SELECT a as x, b as y FROM t1 WHERE c = 0) SELECT x FROM mytable\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"c\")));\n+\n+        // Unused CTE shouldn't require column level permissions, but should require table level permissions\n+        assertUtilizedTableColumns(\"WITH mytable AS (SELECT * FROM t1) SELECT a FROM t2\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+    }\n+\n+    @Test\n+    public void testInsert()\n+    {\n+        assertUtilizedTableColumns(\"INSERT INTO t2 SELECT a, b FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testCTAS()\n+    {\n+        assertUtilizedTableColumns(\"CREATE TABLE foo AS SELECT a, b FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testOrdinal()\n+    {\n+        // Test ordinal in GROUP BY\n+        assertUtilizedTableColumns(\"SELECT * FROM (SELECT count(a), count(b), c FROM t1 WHERE b = 0 GROUP BY 3)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Test ordinal in ORDER BY\n+        assertUtilizedTableColumns(\"SELECT * FROM (SELECT b, c FROM t1 WHERE b = 0 ORDER BY 2)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"b\", \"c\")));\n+    }\n+\n+    @Test\n+    public void testSetOperations()\n+    {\n+        // Test EXCEPT\n+        assertUtilizedTableColumns(\"SELECT a, b FROM t1 WHERE c = 0 EXCEPT SELECT * from t2\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test INTERSECT\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT * FROM t1 WHERE t1.b = 0 INTERSECT SELECT * from t1 WHERE t1.c = 0)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Test UNION\n+        assertUtilizedTableColumns(\"SELECT * FROM ((SELECT a, b FROM t1 WHERE c = 0) UNION (SELECT * FROM t2 WHERE b = 0))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testLateral()\n+    {\n+        // Select item in lateral should be checked\n+        assertUtilizedTableColumns(\"SELECT a, x FROM t1 CROSS JOIN LATERAL (SELECT b as x)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test pruning of select items in lateral if they are unused\n+        assertUtilizedTableColumns(\"SELECT a FROM t1 CROSS JOIN LATERAL (SELECT b as x)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+\n+        // Test lateral from different table\n+        assertUtilizedTableColumns(\"SELECT * FROM t1 CROSS JOIN LATERAL (SELECT b FROM t2)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\", \"d\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"b\")));\n+\n+        // Test chained lateral\n+        assertUtilizedTableColumns(\"SELECT a, x, y FROM t1 CROSS JOIN LATERAL (SELECT a + 1 as x) CROSS JOIN LATERAL (SELECT x + 2 as y)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+    }\n+\n+    @Test\n+    public void testSampledRelation()\n+    {\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT * FROM t1 TABLESAMPLE BERNOULLI (10))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));", "originalCommit": "9fe4d501ac85026c4949d6d4748921fe1fa86e45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg4NjI0Mw==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r505886243", "bodyText": "Hmm, I don't understand this comment? This test is making sure we handle sampled relations properly, like all other relations.", "author": "prithvip", "createdAt": "2020-10-15T21:53:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg2OTQ4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjY1NDM0NA==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r506654344", "bodyText": "FB_NECTAR_SAMPLING_PCT is a UDF that people use quite a bit to do stable sampling based on certain criteria and is used very heavily - this is in a WHERE clause. So let's make sure to have a test case that covers this because it takes a field and quite often people use things like userid/fbid etc.", "author": "kaikalur", "createdAt": "2020-10-16T18:31:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg2OTQ4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjc0MTc5OQ==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r506741799", "bodyText": "Added test cases for making sure we pick up column references in a UDF", "author": "prithvip", "createdAt": "2020-10-16T22:08:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg2OTQ4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg3MDM3Ng==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r505870376", "bodyText": "Also from a subquery:\ncross join unnest(select array[x] from T) AS T(a)\nshould acl T.x", "author": "kaikalur", "createdAt": "2020-10-15T21:30:10Z", "path": "presto-main/src/test/java/com/facebook/presto/sql/analyzer/TestUtilizedColumnsAnalyzer.java", "diffHunk": "@@ -0,0 +1,444 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.analyzer;\n+\n+import com.facebook.presto.metadata.QualifiedObjectName;\n+import com.facebook.presto.spi.WarningCollector;\n+import com.facebook.presto.sql.tree.Statement;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.facebook.presto.transaction.TransactionBuilder.transaction;\n+import static org.testng.Assert.assertEquals;\n+\n+@Test(singleThreaded = true)\n+public class TestUtilizedColumnsAnalyzer\n+        extends AbstractAnalyzerTest\n+{\n+    @Test\n+    public void testWildcardSelect()\n+    {\n+        // Test wildcard select\n+        assertUtilizedTableColumns(\"SELECT * FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\", \"d\")));\n+\n+        // Test outer select * captures everything\n+        assertUtilizedTableColumns(\"SELECT * FROM (SELECT a + b FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+        assertUtilizedTableColumns(\"SELECT * FROM (SELECT a + b FROM (SELECT * FROM t1))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testCountStar()\n+    {\n+        // Test count(*) should not need column access for anything, but should still need table access\n+        assertUtilizedTableColumns(\"SELECT count(*) FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of()));\n+    }\n+\n+    @Test\n+    public void testRecursiveProjectionPruning()\n+    {\n+        // Test recursive pruning of projections in subquery\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT * FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT a, b FROM (SELECT a, b, c FROM t1))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+    }\n+\n+    @Test\n+    public void testAliasing()\n+    {\n+        // Test aliasing\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT *, a as x FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+\n+        // Test alias expression wih multiple columns referenced in alias\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT *, a + b as x FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test chained aliasing\n+        assertUtilizedTableColumns(\"SELECT x + 3 FROM (SELECT y + 2 as x FROM (SELECT z + 1 as y FROM (SELECT a as z FROM t1 WHERE b = 1)))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test aliased relation\n+        assertUtilizedTableColumns(\"SELECT mytable.a, mytable.b FROM (SELECT * FROM t1 WHERE t1.c = 1) mytable\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Test aliased relation for self-join\n+        assertUtilizedTableColumns(\"SELECT x.a, y.b FROM t1 x, t1 y\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test filter on aliased relation\n+        assertUtilizedTableColumns(\"SELECT count(x) FROM (SELECT a as x, * FROM t1) t WHERE t.b = 3\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test aliased relation with column aliases\n+        assertUtilizedTableColumns(\"SELECT y FROM (SELECT x, y FROM t1 AS mytable (w, x, y, z))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"c\")));\n+    }\n+\n+    @Test\n+    public void testJoin()\n+    {\n+        // Joins with column aliases\n+        assertUtilizedTableColumns(\"SELECT t2.a + y FROM t2 CROSS JOIN (SELECT *, c + d AS y FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"c\", \"d\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+        assertUtilizedTableColumns(\"SELECT mytable.a + myothertable.b AS f1, myothertable.z FROM t2 AS mytable CROSS JOIN (SELECT *, a + b AS x, c - 1 AS z FROM t1) myothertable\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // Columns in join criteria with ON should be checked\n+        assertUtilizedTableColumns(\"SELECT t1.a FROM t1 JOIN t2 ON t1.c = t2.b\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"b\")));\n+\n+        // TODO: Columns in join criteria with USING should be checked\n+        //assertUtilizedTableColumns(\"SELECT t1.c FROM t1 JOIN t2 USING (a, b)\",\n+        //        ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testGroupBy()\n+    {\n+        // Capture column in GROUP BY\n+        assertUtilizedTableColumns(\"SELECT a, b FROM (SELECT count(a) AS a, avg(b) AS b FROM t1 GROUP BY c)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Capture columns in subquery in GROUP BY expression\n+        assertUtilizedTableColumns(\"SELECT a, b FROM (SELECT count(a) AS a, avg(b) AS b FROM t1 GROUP BY (c * (SELECT max(a) FROM t2)))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // Capture column in HAVING\n+        assertUtilizedTableColumns(\"SELECT count(a) AS c FROM t1 WHERE b = 0 GROUP BY c HAVING max(d) > 10\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\", \"d\")));\n+\n+        // Capture columns in subquery in HAVING expression\n+        assertUtilizedTableColumns(\"SELECT count(a) FROM t1 GROUP BY b HAVING count(a) > (SELECT max(a) FROM t2)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // ROLLUP, CUBE, and GROUPING SETS do not allow for expressions so we only need to test for explicit columns\n+\n+        // Capture column in ROLLUP\n+        assertUtilizedTableColumns(\"SELECT a, b FROM (SELECT count(a) AS a, avg(b) AS b FROM t1 GROUP BY ROLLUP(c))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Capture column in CUBE\n+        assertUtilizedTableColumns(\"SELECT a, b FROM (SELECT count(a) AS a, avg(b) AS b FROM t1 GROUP BY CUBE(c, d))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\", \"d\")));\n+\n+        // Capture columns in GROUPING SETS\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT sum(c) AS x FROM t1 GROUP BY GROUPING SETS (a, b))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT grouping(a, b) AS x FROM t1 GROUP BY GROUPING SETS (a, b))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testCTE()\n+    {\n+        // Test CTE columns are pruned\n+        assertUtilizedTableColumns(\"WITH mytable AS (SELECT * FROM t1) SELECT x FROM (SELECT a AS x FROM mytable)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+\n+        // CTE filter column is captured\n+        assertUtilizedTableColumns(\"WITH mytable AS (SELECT a as x, b as y FROM t1 WHERE c = 0) SELECT x FROM mytable\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"c\")));\n+\n+        // Unused CTE shouldn't require column level permissions, but should require table level permissions\n+        assertUtilizedTableColumns(\"WITH mytable AS (SELECT * FROM t1) SELECT a FROM t2\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+    }\n+\n+    @Test\n+    public void testInsert()\n+    {\n+        assertUtilizedTableColumns(\"INSERT INTO t2 SELECT a, b FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testCTAS()\n+    {\n+        assertUtilizedTableColumns(\"CREATE TABLE foo AS SELECT a, b FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testOrdinal()\n+    {\n+        // Test ordinal in GROUP BY\n+        assertUtilizedTableColumns(\"SELECT * FROM (SELECT count(a), count(b), c FROM t1 WHERE b = 0 GROUP BY 3)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Test ordinal in ORDER BY\n+        assertUtilizedTableColumns(\"SELECT * FROM (SELECT b, c FROM t1 WHERE b = 0 ORDER BY 2)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"b\", \"c\")));\n+    }\n+\n+    @Test\n+    public void testSetOperations()\n+    {\n+        // Test EXCEPT\n+        assertUtilizedTableColumns(\"SELECT a, b FROM t1 WHERE c = 0 EXCEPT SELECT * from t2\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test INTERSECT\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT * FROM t1 WHERE t1.b = 0 INTERSECT SELECT * from t1 WHERE t1.c = 0)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Test UNION\n+        assertUtilizedTableColumns(\"SELECT * FROM ((SELECT a, b FROM t1 WHERE c = 0) UNION (SELECT * FROM t2 WHERE b = 0))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testLateral()\n+    {\n+        // Select item in lateral should be checked\n+        assertUtilizedTableColumns(\"SELECT a, x FROM t1 CROSS JOIN LATERAL (SELECT b as x)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test pruning of select items in lateral if they are unused\n+        assertUtilizedTableColumns(\"SELECT a FROM t1 CROSS JOIN LATERAL (SELECT b as x)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+\n+        // Test lateral from different table\n+        assertUtilizedTableColumns(\"SELECT * FROM t1 CROSS JOIN LATERAL (SELECT b FROM t2)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\", \"d\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"b\")));\n+\n+        // Test chained lateral\n+        assertUtilizedTableColumns(\"SELECT a, x, y FROM t1 CROSS JOIN LATERAL (SELECT a + 1 as x) CROSS JOIN LATERAL (SELECT x + 2 as y)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+    }\n+\n+    @Test\n+    public void testSampledRelation()\n+    {\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT * FROM t1 TABLESAMPLE BERNOULLI (10))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+    }\n+\n+    @Test\n+    public void testUnnest()\n+    {\n+        // Unnest column gets pruned if unused\n+        assertUtilizedTableColumns(\"SELECT a FROM t7 CROSS JOIN UNNEST (c) AS t(x)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t7\"), ImmutableSet.of(\"a\")));\n+\n+        // Unnest column used through alias\n+        assertUtilizedTableColumns(\"SELECT a, x FROM t7 CROSS JOIN UNNEST (c) AS t(x)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t7\"), ImmutableSet.of(\"a\", \"c\")));\n+\n+        // Multiple unnest columns\n+        assertUtilizedTableColumns(\"SELECT a, x, y FROM t7 CROSS JOIN UNNEST (c, d) AS t(x, y)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t7\"), ImmutableSet.of(\"a\", \"c\", \"d\")));\n+\n+        // Unused unnest columns are pruned, but used ones are kept\n+        assertUtilizedTableColumns(\"SELECT a, y FROM t7 CROSS JOIN UNNEST (c, d) AS t(x, y)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t7\"), ImmutableSet.of(\"a\", \"d\")));", "originalCommit": "9fe4d501ac85026c4949d6d4748921fe1fa86e45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkzMDI1Mg==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r505930252", "bodyText": "Done", "author": "prithvip", "createdAt": "2020-10-16T00:03:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg3MDM3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg3MjU2OA==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r505872568", "bodyText": "Add some array. map constructors and lambdas like transform/filter/reduce as they are widely used.", "author": "kaikalur", "createdAt": "2020-10-15T21:33:04Z", "path": "presto-main/src/test/java/com/facebook/presto/sql/analyzer/TestUtilizedColumnsAnalyzer.java", "diffHunk": "@@ -0,0 +1,444 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.analyzer;\n+\n+import com.facebook.presto.metadata.QualifiedObjectName;\n+import com.facebook.presto.spi.WarningCollector;\n+import com.facebook.presto.sql.tree.Statement;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.ImmutableSet;\n+import org.intellij.lang.annotations.Language;\n+import org.testng.annotations.Test;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+import static com.facebook.presto.transaction.TransactionBuilder.transaction;\n+import static org.testng.Assert.assertEquals;\n+\n+@Test(singleThreaded = true)\n+public class TestUtilizedColumnsAnalyzer\n+        extends AbstractAnalyzerTest\n+{\n+    @Test\n+    public void testWildcardSelect()\n+    {\n+        // Test wildcard select\n+        assertUtilizedTableColumns(\"SELECT * FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\", \"d\")));\n+\n+        // Test outer select * captures everything\n+        assertUtilizedTableColumns(\"SELECT * FROM (SELECT a + b FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+        assertUtilizedTableColumns(\"SELECT * FROM (SELECT a + b FROM (SELECT * FROM t1))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testCountStar()\n+    {\n+        // Test count(*) should not need column access for anything, but should still need table access\n+        assertUtilizedTableColumns(\"SELECT count(*) FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of()));\n+    }\n+\n+    @Test\n+    public void testRecursiveProjectionPruning()\n+    {\n+        // Test recursive pruning of projections in subquery\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT * FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT a, b FROM (SELECT a, b, c FROM t1))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+    }\n+\n+    @Test\n+    public void testAliasing()\n+    {\n+        // Test aliasing\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT *, a as x FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+\n+        // Test alias expression wih multiple columns referenced in alias\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT *, a + b as x FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test chained aliasing\n+        assertUtilizedTableColumns(\"SELECT x + 3 FROM (SELECT y + 2 as x FROM (SELECT z + 1 as y FROM (SELECT a as z FROM t1 WHERE b = 1)))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test aliased relation\n+        assertUtilizedTableColumns(\"SELECT mytable.a, mytable.b FROM (SELECT * FROM t1 WHERE t1.c = 1) mytable\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Test aliased relation for self-join\n+        assertUtilizedTableColumns(\"SELECT x.a, y.b FROM t1 x, t1 y\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test filter on aliased relation\n+        assertUtilizedTableColumns(\"SELECT count(x) FROM (SELECT a as x, * FROM t1) t WHERE t.b = 3\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test aliased relation with column aliases\n+        assertUtilizedTableColumns(\"SELECT y FROM (SELECT x, y FROM t1 AS mytable (w, x, y, z))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"c\")));\n+    }\n+\n+    @Test\n+    public void testJoin()\n+    {\n+        // Joins with column aliases\n+        assertUtilizedTableColumns(\"SELECT t2.a + y FROM t2 CROSS JOIN (SELECT *, c + d AS y FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"c\", \"d\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+        assertUtilizedTableColumns(\"SELECT mytable.a + myothertable.b AS f1, myothertable.z FROM t2 AS mytable CROSS JOIN (SELECT *, a + b AS x, c - 1 AS z FROM t1) myothertable\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // Columns in join criteria with ON should be checked\n+        assertUtilizedTableColumns(\"SELECT t1.a FROM t1 JOIN t2 ON t1.c = t2.b\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"b\")));\n+\n+        // TODO: Columns in join criteria with USING should be checked\n+        //assertUtilizedTableColumns(\"SELECT t1.c FROM t1 JOIN t2 USING (a, b)\",\n+        //        ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testGroupBy()\n+    {\n+        // Capture column in GROUP BY\n+        assertUtilizedTableColumns(\"SELECT a, b FROM (SELECT count(a) AS a, avg(b) AS b FROM t1 GROUP BY c)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Capture columns in subquery in GROUP BY expression\n+        assertUtilizedTableColumns(\"SELECT a, b FROM (SELECT count(a) AS a, avg(b) AS b FROM t1 GROUP BY (c * (SELECT max(a) FROM t2)))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // Capture column in HAVING\n+        assertUtilizedTableColumns(\"SELECT count(a) AS c FROM t1 WHERE b = 0 GROUP BY c HAVING max(d) > 10\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\", \"d\")));\n+\n+        // Capture columns in subquery in HAVING expression\n+        assertUtilizedTableColumns(\"SELECT count(a) FROM t1 GROUP BY b HAVING count(a) > (SELECT max(a) FROM t2)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // ROLLUP, CUBE, and GROUPING SETS do not allow for expressions so we only need to test for explicit columns\n+\n+        // Capture column in ROLLUP\n+        assertUtilizedTableColumns(\"SELECT a, b FROM (SELECT count(a) AS a, avg(b) AS b FROM t1 GROUP BY ROLLUP(c))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Capture column in CUBE\n+        assertUtilizedTableColumns(\"SELECT a, b FROM (SELECT count(a) AS a, avg(b) AS b FROM t1 GROUP BY CUBE(c, d))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\", \"d\")));\n+\n+        // Capture columns in GROUPING SETS\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT sum(c) AS x FROM t1 GROUP BY GROUPING SETS (a, b))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+        assertUtilizedTableColumns(\"SELECT x FROM (SELECT grouping(a, b) AS x FROM t1 GROUP BY GROUPING SETS (a, b))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testCTE()\n+    {\n+        // Test CTE columns are pruned\n+        assertUtilizedTableColumns(\"WITH mytable AS (SELECT * FROM t1) SELECT x FROM (SELECT a AS x FROM mytable)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+\n+        // CTE filter column is captured\n+        assertUtilizedTableColumns(\"WITH mytable AS (SELECT a as x, b as y FROM t1 WHERE c = 0) SELECT x FROM mytable\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"c\")));\n+\n+        // Unused CTE shouldn't require column level permissions, but should require table level permissions\n+        assertUtilizedTableColumns(\"WITH mytable AS (SELECT * FROM t1) SELECT a FROM t2\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+    }\n+\n+    @Test\n+    public void testInsert()\n+    {\n+        assertUtilizedTableColumns(\"INSERT INTO t2 SELECT a, b FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testCTAS()\n+    {\n+        assertUtilizedTableColumns(\"CREATE TABLE foo AS SELECT a, b FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testOrdinal()\n+    {\n+        // Test ordinal in GROUP BY\n+        assertUtilizedTableColumns(\"SELECT * FROM (SELECT count(a), count(b), c FROM t1 WHERE b = 0 GROUP BY 3)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Test ordinal in ORDER BY\n+        assertUtilizedTableColumns(\"SELECT * FROM (SELECT b, c FROM t1 WHERE b = 0 ORDER BY 2)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"b\", \"c\")));\n+    }\n+\n+    @Test\n+    public void testSetOperations()\n+    {\n+        // Test EXCEPT\n+        assertUtilizedTableColumns(\"SELECT a, b FROM t1 WHERE c = 0 EXCEPT SELECT * from t2\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test INTERSECT\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT * FROM t1 WHERE t1.b = 0 INTERSECT SELECT * from t1 WHERE t1.c = 0)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Test UNION\n+        assertUtilizedTableColumns(\"SELECT * FROM ((SELECT a, b FROM t1 WHERE c = 0) UNION (SELECT * FROM t2 WHERE b = 0))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testLateral()\n+    {\n+        // Select item in lateral should be checked\n+        assertUtilizedTableColumns(\"SELECT a, x FROM t1 CROSS JOIN LATERAL (SELECT b as x)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Test pruning of select items in lateral if they are unused\n+        assertUtilizedTableColumns(\"SELECT a FROM t1 CROSS JOIN LATERAL (SELECT b as x)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+\n+        // Test lateral from different table\n+        assertUtilizedTableColumns(\"SELECT * FROM t1 CROSS JOIN LATERAL (SELECT b FROM t2)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\", \"d\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"b\")));\n+\n+        // Test chained lateral\n+        assertUtilizedTableColumns(\"SELECT a, x, y FROM t1 CROSS JOIN LATERAL (SELECT a + 1 as x) CROSS JOIN LATERAL (SELECT x + 2 as y)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+    }\n+\n+    @Test\n+    public void testSampledRelation()\n+    {\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT * FROM t1 TABLESAMPLE BERNOULLI (10))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+    }\n+\n+    @Test\n+    public void testUnnest()\n+    {\n+        // Unnest column gets pruned if unused\n+        assertUtilizedTableColumns(\"SELECT a FROM t7 CROSS JOIN UNNEST (c) AS t(x)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t7\"), ImmutableSet.of(\"a\")));\n+\n+        // Unnest column used through alias\n+        assertUtilizedTableColumns(\"SELECT a, x FROM t7 CROSS JOIN UNNEST (c) AS t(x)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t7\"), ImmutableSet.of(\"a\", \"c\")));\n+\n+        // Multiple unnest columns\n+        assertUtilizedTableColumns(\"SELECT a, x, y FROM t7 CROSS JOIN UNNEST (c, d) AS t(x, y)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t7\"), ImmutableSet.of(\"a\", \"c\", \"d\")));\n+\n+        // Unused unnest columns are pruned, but used ones are kept\n+        assertUtilizedTableColumns(\"SELECT a, y FROM t7 CROSS JOIN UNNEST (c, d) AS t(x, y)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t7\"), ImmutableSet.of(\"a\", \"d\")));\n+    }\n+\n+    @Test\n+    public void testValues()\n+    {\n+        assertUtilizedTableColumns(\"SELECT * FROM (VALUES 1, 2, 3)\", ImmutableMap.of());\n+        assertUtilizedTableColumns(\"SELECT * FROM (VALUES array[2, 2]) a(x) CROSS JOIN UNNEST(x)\", ImmutableMap.of());\n+        assertUtilizedTableColumns(\"SELECT a, b FROM t1 CROSS JOIN (VALUES 1, 2, 3)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    @Test\n+    public void testInSubquery()\n+    {\n+        // IN/NOT IN subqueries should keep all their select columns\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT * FROM t1 WHERE t1.b IN (SELECT b FROM t2))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"b\")));\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT * FROM t1 WHERE t1.b IN (SELECT b FROM t2 WHERE t2.a = 0) AND t1.c = 0)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\", \"b\")));\n+        assertUtilizedTableColumns(\"SELECT a, b FROM t1 WHERE t1.b IN (SELECT b FROM t2 WHERE t2.a NOT IN (SELECT x FROM t3) AND t1.c = 0)\",\n+                ImmutableMap.of(\n+                        QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\"),\n+                        QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\", \"b\"),\n+                        QualifiedObjectName.valueOf(\"tpch.s1.t3\"), ImmutableSet.of(\"x\")));\n+\n+        // Test aliased IN subquery (self join)\n+        assertUtilizedTableColumns(\"SELECT r1.a, r1.b FROM t1 as r1 WHERE r1.b IN (SELECT r2.c FROM t1 as r2 WHERE r2.d = 0)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\", \"d\")));\n+\n+        // Test correlated IN subquery\n+        assertUtilizedTableColumns(\"SELECT r1.a, r1.b, r2.a FROM t1 as r1 JOIN t2 as r2 ON r1.a = r2.a WHERE 0 IN (SELECT x FROM t3 r3 WHERE r2.a = r3.a)\",\n+                ImmutableMap.of(\n+                        QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\"),\n+                        QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\"),\n+                        QualifiedObjectName.valueOf(\"tpch.s1.t3\"), ImmutableSet.of(\"a\", \"x\")));\n+    }\n+\n+    @Test\n+    public void testExistsSubquery()\n+    {\n+        // In exists/not exists subqueries, the select list should be ignored\n+        assertUtilizedTableColumns(\"SELECT a FROM t1 WHERE NOT EXISTS (SELECT * FROM t2)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of()));\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT * FROM t1 WHERE EXISTS (SELECT * FROM t2 WHERE t2.b = t1.b))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"b\")));\n+\n+        // Chain of correlated exists subquery (self join)\n+        assertUtilizedTableColumns(\"SELECT r1.a, r1.b FROM t2 r1, t1 WHERE EXISTS (SELECT r2.a, r2.b FROM t2 r2 WHERE r2.a = r1.b AND EXISTS (SELECT r3.a, r3.b FROM t2 r3 WHERE r3.a = r2.b AND r3.b = t1.c))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"c\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Exists subquery in SELECT\n+        assertUtilizedTableColumns(\"SELECT EXISTS(SELECT * FROM t1) = EXISTS(SELECT * FROM t2)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of()));\n+        assertUtilizedTableColumns(\"SELECT EXISTS(SELECT * FROM t1 WHERE t1.a = 0) = EXISTS(SELECT * FROM t2)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of()));\n+    }\n+\n+    @Test\n+    public void testScalarSubquery()\n+    {\n+        // Scalar subquery in SELECT expression\n+        assertUtilizedTableColumns(\"SELECT a, (SELECT avg(a) FROM t2) FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+        assertUtilizedTableColumns(\"SELECT mycolumn FROM (SELECT a, ((SELECT avg(a) FROM t2) * 5) as mycolumn FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // Scalar subquery in SELECT should be pruned if unreferenced\n+        assertUtilizedTableColumns(\"SELECT a FROM (SELECT a, (SELECT avg(a) FROM t2) as mycolumn FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of()));\n+\n+        // Scalar subquery in GROUP BY\n+        assertUtilizedTableColumns(\"SELECT count(a) FROM t1 GROUP BY (b * (SELECT avg(a) FROM t2))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+        assertUtilizedTableColumns(\"SELECT count(a) FROM t1 GROUP BY (b * (SELECT avg(c)))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Scalar subquery in HAVING\n+        assertUtilizedTableColumns(\"SELECT count(a) FROM t1 GROUP BY b HAVING count(a) > (SELECT avg(a) FROM t2)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+        assertUtilizedTableColumns(\"SELECT count(r1.a) FROM t1 as r1 GROUP BY b HAVING count(r1.a) > (SELECT avg(r1.b))\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Scalar subquery in where with ANY/ALL\n+        assertUtilizedTableColumns(\"SELECT t1.c FROM t1 WHERE t1.b >= ANY(SELECT max(t1.a) FROM t1 GROUP BY t1.b)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+        assertUtilizedTableColumns(\"SELECT a FROM t1 WHERE t1.b >= ALL(SELECT b FROM t2)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"b\")));\n+    }\n+\n+    @Test\n+    public void testDerivedColumns()\n+    {\n+        assertUtilizedTableColumns(\"SELECT b_is_zero FROM (SELECT *, b = 0 AS b_is_zero FROM t1 WHERE a = 0)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+        assertUtilizedTableColumns(\"WITH mycte AS (SELECT *, b = 0 as b_is_zero FROM t1 WHERE a = 0) SELECT a FROM mycte\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+    }\n+\n+    @Test\n+    public void testOrderByInAggregation()\n+    {\n+        assertUtilizedTableColumns(\"SELECT myarray FROM (SELECT array_agg(a ORDER BY b, c DESC) AS myarray FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+    }\n+\n+    @Test\n+    public void testWindowFunction()\n+    {\n+        assertUtilizedTableColumns(\"SELECT mycolumn FROM (SELECT sum(a) OVER (PARTITION BY b ORDER BY c) AS mycolumn FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+    }\n+\n+    @Test\n+    public void testAggregationFilter()\n+    {\n+        // Filter expression should be captured\n+        assertUtilizedTableColumns(\"SELECT mycolumn FROM (SELECT sum(a) FILTER (WHERE b > 0) AS mycolumn FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Filter expression should be captured for count star\n+        assertUtilizedTableColumns(\"SELECT count(*) FILTER (WHERE a > 5) FROM t1\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+\n+        // If the filter expression is an IN subquery, all select items of the subquery should be captured\n+        assertUtilizedTableColumns(\"SELECT mycolumn FROM (SELECT sum(a) FILTER (WHERE b IN (SELECT c FROM t1)) AS mycolumn FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\", \"c\")));\n+\n+        // Filter expression referencing different table should be captured\n+        assertUtilizedTableColumns(\"SELECT mycolumn FROM (SELECT sum(a) FILTER (WHERE b IN (SELECT b FROM t2)) AS mycolumn FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"b\")));\n+    }\n+\n+    @Test\n+    public void testLambdaExpressions()\n+    {\n+        // Column reference inside lambda should be captured\n+        assertUtilizedTableColumns(\"SELECT mycolumn FROM (SELECT apply(0, x -> x + a) as mycolumn FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+\n+        // Aggregated column as lambda argument\n+        assertUtilizedTableColumns(\"SELECT mycolumn FROM (SELECT apply(sum(a), x -> x * x) as mycolumn FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\")));\n+    }\n+\n+    @Test\n+    public void testConditionals()\n+    {\n+        // If expression with subquery\n+        assertUtilizedTableColumns(\"SELECT mycolumn FROM (SELECT if(false, a, (SELECT max(a) FROM t2)) as mycolumn FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // Simple case expression with subquery\n+        assertUtilizedTableColumns(\"SELECT mycolumn FROM (SELECT CASE a WHEN 1 THEN 1 WHEN 2 THEN (SELECT max(a) FROM t2) ELSE 0 END as mycolumn FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // Searched case expression with subquery\n+        assertUtilizedTableColumns(\"SELECT mycolumn FROM (SELECT CASE WHEN a = 1 THEN 1 WHEN b = 2 THEN (SELECT max(a) FROM t2) ELSE 0 END as mycolumn FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // Coalesce expression with subquery\n+        assertUtilizedTableColumns(\"SELECT mycolumn FROM (SELECT COALESCE(a, b, (SELECT max(a) FROM t2), (SELECT max(b) FROM t2)) as mycolumn FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\", \"b\")));\n+\n+        // Nullif expression with subquery\n+        assertUtilizedTableColumns(\"SELECT mycolumn FROM (SELECT NULLIF(a, (SELECT max(a) FROM t2)) as mycolumn FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // Try expression with subquery\n+        assertUtilizedTableColumns(\"SELECT mycolumn FROM (SELECT TRY(a / (SELECT max(a) FROM t2)) as mycolumn FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\"), QualifiedObjectName.valueOf(\"tpch.s1.t2\"), ImmutableSet.of(\"a\")));\n+\n+        // Should not prune even if conditional is a constant\n+        assertUtilizedTableColumns(\"SELECT mycolumn FROM (SELECT if(false, a, b) as mycolumn FROM t1)\",\n+                ImmutableMap.of(QualifiedObjectName.valueOf(\"tpch.s1.t1\"), ImmutableSet.of(\"a\", \"b\")));\n+    }\n+\n+    private void assertUtilizedTableColumns(@Language(\"SQL\") String query, Map<QualifiedObjectName, Set<String>> expected)\n+    {\n+        transaction(transactionManager, accessControl)\n+                .singleStatement()\n+                .readUncommitted()\n+                .readOnly()\n+                .execute(CLIENT_SESSION, session -> {\n+                    Analyzer analyzer = createAnalyzer(session, metadata, WarningCollector.NOOP);\n+                    Statement statement = SQL_PARSER.createStatement(query);\n+                    Analysis analysis = analyzer.analyze(statement);\n+                    assertEquals(analysis.getUtilizedTableColumnReferences().values().stream().findFirst().get(), expected);\n+                });\n+    }", "originalCommit": "9fe4d501ac85026c4949d6d4748921fe1fa86e45", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkzMDQzMQ==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r505930431", "bodyText": "Added tests for array, map, and row constructors. And added more coverage to lambda expressions, including transform/filter/reduce", "author": "prithvip", "createdAt": "2020-10-16T00:03:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTg3MjU2OA=="}], "type": "inlineReview"}, {"oid": "5e75f09b8df95d840cebcb61fa90149041428b1f", "url": "https://github.com/prestodb/presto/commit/5e75f09b8df95d840cebcb61fa90149041428b1f", "message": "Add option to do more precise ACL checks\n\nBefore this change, Presto would check for column access permission on\nall columns referenced in any part of the query.\nThis behavior can sometimes be undesirable, for example, in this query:\n\n``SELECT name FROM (SELECT * FROM nation)``\n\nDuring execution of this query, access checks would be performed on all\ncolumns in the table nation, even though only the column ``name`` would\nactually be read during the execution of the query, and the other\ncolumns in the table have no impact on the query results.\n\nThis change introduces a new sesion property,\n``check_access_control_on_utilized_columns_only``, which, when\nenabled, will only perform access control checks on columns that would\nactually be required to produce the query output, ignoring columns that\nare referenced in the query, but are not required to compute the query\nresults.", "committedDate": "2020-10-16T00:00:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkzNjYwOQ==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r505936609", "bodyText": "Generally we rarely return mutable containers in Presto codebase. So instead of have this method and call getUtilizedTableColumnReferences.put(...), it's preferable to introduce a function addUtializedTableColumnRefereces(...). Correspondingly, it's probably better for the next function to return ImmutableMap.copyof(...).", "author": "rongrong", "createdAt": "2020-10-16T00:27:29Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/analyzer/Analysis.java", "diffHunk": "@@ -668,6 +676,16 @@ public void addEmptyColumnReferencesForTable(AccessControl accessControl, Identi\n         return tableColumnReferences;\n     }\n \n+    public Map<AccessControlInfo, Map<QualifiedObjectName, Set<String>>> getUtilizedTableColumnReferences()", "originalCommit": "5e75f09b8df95d840cebcb61fa90149041428b1f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNjAxNzUyOQ==", "url": "https://github.com/prestodb/presto/pull/15269#discussion_r506017529", "bodyText": "Done", "author": "prithvip", "createdAt": "2020-10-16T03:10:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUwNTkzNjYwOQ=="}], "type": "inlineReview"}, {"oid": "e0f2a8c1a3e02555e40fb6c43532106e783032b2", "url": "https://github.com/prestodb/presto/commit/e0f2a8c1a3e02555e40fb6c43532106e783032b2", "message": "Add option to do more precise ACL checks\n\nBefore this change, Presto would check for column access permission on\nall columns referenced in any part of the query.\nThis behavior can sometimes be undesirable, for example, in this query:\n\n``SELECT name FROM (SELECT * FROM nation)``\n\nDuring execution of this query, access checks would be performed on all\ncolumns in the table nation, even though only the column ``name`` would\nactually be read during the execution of the query, and the other\ncolumns in the table have no impact on the query results.\n\nThis change introduces a new sesion property,\n``check_access_control_on_utilized_columns_only``, which, when\nenabled, will only perform access control checks on columns that would\nactually be required to produce the query output, ignoring columns that\nare referenced in the query, but are not required to compute the query\nresults.", "committedDate": "2020-10-16T03:03:22Z", "type": "forcePushed"}, {"oid": "3e5e74d98eaa562ea155c6c604774f0a2368fcd4", "url": "https://github.com/prestodb/presto/commit/3e5e74d98eaa562ea155c6c604774f0a2368fcd4", "message": "Add option to do more precise ACL checks\n\nBefore this change, Presto would check for column access permission on\nall columns referenced in any part of the query.\nThis behavior can sometimes be undesirable, for example, in this query:\n\n``SELECT name FROM (SELECT * FROM nation)``\n\nDuring execution of this query, access checks would be performed on all\ncolumns in the table nation, even though only the column ``name`` would\nactually be read during the execution of the query, and the other\ncolumns in the table have no impact on the query results.\n\nThis change introduces a new sesion property,\n``check_access_control_on_utilized_columns_only``, which, when\nenabled, will only perform access control checks on columns that would\nactually be required to produce the query output, ignoring columns that\nare referenced in the query, but are not required to compute the query\nresults.", "committedDate": "2020-10-16T21:21:18Z", "type": "forcePushed"}, {"oid": "29467d87b9ae5709f3a7798286dc3db21785dc3b", "url": "https://github.com/prestodb/presto/commit/29467d87b9ae5709f3a7798286dc3db21785dc3b", "message": "Add option to do more precise ACL checks\n\nBefore this change, Presto would check for column access permission on\nall columns referenced in any part of the query.\nThis behavior can sometimes be undesirable, for example, in this query:\n\n``SELECT name FROM (SELECT * FROM nation)``\n\nDuring execution of this query, access checks would be performed on all\ncolumns in the table nation, even though only the column ``name`` would\nactually be read during the execution of the query, and the other\ncolumns in the table have no impact on the query results.\n\nThis change introduces a new sesion property,\n``check_access_control_on_utilized_columns_only``, which, when\nenabled, will only perform access control checks on columns that would\nactually be required to produce the query output, ignoring columns that\nare referenced in the query, but are not required to compute the query\nresults.", "committedDate": "2020-10-16T22:07:23Z", "type": "commit"}, {"oid": "29467d87b9ae5709f3a7798286dc3db21785dc3b", "url": "https://github.com/prestodb/presto/commit/29467d87b9ae5709f3a7798286dc3db21785dc3b", "message": "Add option to do more precise ACL checks\n\nBefore this change, Presto would check for column access permission on\nall columns referenced in any part of the query.\nThis behavior can sometimes be undesirable, for example, in this query:\n\n``SELECT name FROM (SELECT * FROM nation)``\n\nDuring execution of this query, access checks would be performed on all\ncolumns in the table nation, even though only the column ``name`` would\nactually be read during the execution of the query, and the other\ncolumns in the table have no impact on the query results.\n\nThis change introduces a new sesion property,\n``check_access_control_on_utilized_columns_only``, which, when\nenabled, will only perform access control checks on columns that would\nactually be required to produce the query output, ignoring columns that\nare referenced in the query, but are not required to compute the query\nresults.", "committedDate": "2020-10-16T22:07:23Z", "type": "forcePushed"}]}