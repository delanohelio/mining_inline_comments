{"pr_number": 14090, "pr_title": "Add IPPREFIX functions", "pr_createdAt": "2020-02-12T19:10:01Z", "pr_url": "https://github.com/prestodb/presto/pull/14090", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE4MzM1MQ==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r379183351", "bodyText": "I don't understand this description. The grammar doesn't compute to me... -_-", "author": "rongrong", "createdAt": "2020-02-13T23:49:34Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/IpPrefixFunctions.java", "diffHunk": "@@ -40,16 +50,101 @@ private IpPrefixFunctions() {}\n     @ScalarFunction(\"ip_prefix\")\n     @SqlType(StandardTypes.IPPREFIX)\n     public static Slice ipPrefix(@SqlType(StandardTypes.IPADDRESS) Slice value, @SqlType(StandardTypes.BIGINT) long subnetSize)\n+    {\n+        InetAddress address = validateIpAddress(value);\n+        validateSubnetSize(address.getAddress(), subnetSize);\n+\n+        return castFromVarcharToIpPrefix(utf8Slice(InetAddresses.toAddrString(address) + \"/\" + subnetSize));\n+    }\n+\n+    @Description(\"IP prefix for a given IP address and subnet size\")\n+    @ScalarFunction(\"ip_prefix\")\n+    @LiteralParameters(\"x\")\n+    @SqlType(StandardTypes.IPPREFIX)\n+    public static Slice stringIpPrefix(@SqlType(\"varchar(x)\") Slice slice, @SqlType(StandardTypes.BIGINT) long subnetSize)\n+    {\n+        return ipPrefix(castFromVarcharToIpAddress(slice), subnetSize);\n+    }\n+\n+    @Description(\"First/Smallest subnet IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_min\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMin(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        validateIpPrefixAndGetBytes(value);\n+        return castFromIpPrefixToIpAddress(value);\n+    }\n+\n+    @Description(\"Last/Maximum subnet IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_max\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMax(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        byte[] address = validateIpPrefixAndGetBytes(value);\n+        int subnetSize = value.getByte(IPPREFIX.getFixedSize() - 1) & 0xFF;\n+\n+        if (address.length == 4) {\n+            for (int i = 0; i < 4; i++) {\n+                address[3 - i] |= (byte) ~(~0 << min(max((32 - subnetSize) - 8 * i, 0), 8));\n+            }\n+            byte[] bytes = new byte[16];\n+            bytes[10] = (byte) 0xff;\n+            bytes[11] = (byte) 0xff;\n+            arraycopy(address, 0, bytes, 12, 4);\n+            address = bytes;\n+        }\n+        else if (address.length == 16) {\n+            for (int i = 0; i < 16; i++) {\n+                address[15 - i] |= (byte) ~(~0 << min(max((128 - subnetSize) - 8 * i, 0), 8));\n+            }\n+        }\n+        return wrappedBuffer(address);\n+    }\n+\n+    @Description(\"Range of IP address's in the subnet of the IP prefix\")", "originalCommit": "1509128a9f55fdcf9efd68be443d377f10e2fae7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU2OTkzMA==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r379569930", "bodyText": "Changed it to\n\"Array of smallest and largest IP address in the subnet of the given IP prefix\"", "author": "NikhilCollooru", "createdAt": "2020-02-14T18:05:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE4MzM1MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE4Mzc5NQ==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r379183795", "bodyText": "You can annotate this with `@ScalarFunction(\"is_subnet_of\") so the name of the function is consistent with the other one.", "author": "rongrong", "createdAt": "2020-02-13T23:51:05Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/IpPrefixFunctions.java", "diffHunk": "@@ -40,16 +50,101 @@ private IpPrefixFunctions() {}\n     @ScalarFunction(\"ip_prefix\")\n     @SqlType(StandardTypes.IPPREFIX)\n     public static Slice ipPrefix(@SqlType(StandardTypes.IPADDRESS) Slice value, @SqlType(StandardTypes.BIGINT) long subnetSize)\n+    {\n+        InetAddress address = validateIpAddress(value);\n+        validateSubnetSize(address.getAddress(), subnetSize);\n+\n+        return castFromVarcharToIpPrefix(utf8Slice(InetAddresses.toAddrString(address) + \"/\" + subnetSize));\n+    }\n+\n+    @Description(\"IP prefix for a given IP address and subnet size\")\n+    @ScalarFunction(\"ip_prefix\")\n+    @LiteralParameters(\"x\")\n+    @SqlType(StandardTypes.IPPREFIX)\n+    public static Slice stringIpPrefix(@SqlType(\"varchar(x)\") Slice slice, @SqlType(StandardTypes.BIGINT) long subnetSize)\n+    {\n+        return ipPrefix(castFromVarcharToIpAddress(slice), subnetSize);\n+    }\n+\n+    @Description(\"First/Smallest subnet IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_min\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMin(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        validateIpPrefixAndGetBytes(value);\n+        return castFromIpPrefixToIpAddress(value);\n+    }\n+\n+    @Description(\"Last/Maximum subnet IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_max\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMax(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        byte[] address = validateIpPrefixAndGetBytes(value);\n+        int subnetSize = value.getByte(IPPREFIX.getFixedSize() - 1) & 0xFF;\n+\n+        if (address.length == 4) {\n+            for (int i = 0; i < 4; i++) {\n+                address[3 - i] |= (byte) ~(~0 << min(max((32 - subnetSize) - 8 * i, 0), 8));\n+            }\n+            byte[] bytes = new byte[16];\n+            bytes[10] = (byte) 0xff;\n+            bytes[11] = (byte) 0xff;\n+            arraycopy(address, 0, bytes, 12, 4);\n+            address = bytes;\n+        }\n+        else if (address.length == 16) {\n+            for (int i = 0; i < 16; i++) {\n+                address[15 - i] |= (byte) ~(~0 << min(max((128 - subnetSize) - 8 * i, 0), 8));\n+            }\n+        }\n+        return wrappedBuffer(address);\n+    }\n+\n+    @Description(\"Range of IP address's in the subnet of the IP prefix\")\n+    @ScalarFunction(\"ip_subnet_range\")\n+    @SqlType(\"array(IPADDRESS)\")\n+    public static Block ipSubnetRange(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        validateIpPrefixAndGetBytes(value);\n+        BlockBuilder blockBuilder = IPADDRESS.createBlockBuilder(null, 2);\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMin(value));\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMax(value));\n+        return blockBuilder.build();\n+    }\n+\n+    @Description(\"Is the IP address in the subnet of IP prefix\")\n+    @ScalarFunction(\"is_subnet_of\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean isSubnetOf(@SqlType(StandardTypes.IPPREFIX) Slice left, @SqlType(StandardTypes.IPADDRESS) Slice right)\n+    {\n+        validateIpAddress(right);\n+        return between(right, ipSubnetMin(left), ipSubnetMax(left));\n+    }\n+\n+    @Description(\"Is the second IP prefix argument within the subnet of the first IP prefix argument\")\n+    @ScalarFunction(\"is_prefix_subnet_of\")", "originalCommit": "1509128a9f55fdcf9efd68be443d377f10e2fae7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE4NDYxNw==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r379184617", "bodyText": "You can just name the variable ipAddress. The function should be named toInetAddress.", "author": "rongrong", "createdAt": "2020-02-13T23:54:08Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/IpPrefixFunctions.java", "diffHunk": "@@ -40,16 +50,101 @@ private IpPrefixFunctions() {}\n     @ScalarFunction(\"ip_prefix\")\n     @SqlType(StandardTypes.IPPREFIX)\n     public static Slice ipPrefix(@SqlType(StandardTypes.IPADDRESS) Slice value, @SqlType(StandardTypes.BIGINT) long subnetSize)\n+    {\n+        InetAddress address = validateIpAddress(value);\n+        validateSubnetSize(address.getAddress(), subnetSize);\n+\n+        return castFromVarcharToIpPrefix(utf8Slice(InetAddresses.toAddrString(address) + \"/\" + subnetSize));\n+    }\n+\n+    @Description(\"IP prefix for a given IP address and subnet size\")\n+    @ScalarFunction(\"ip_prefix\")\n+    @LiteralParameters(\"x\")\n+    @SqlType(StandardTypes.IPPREFIX)\n+    public static Slice stringIpPrefix(@SqlType(\"varchar(x)\") Slice slice, @SqlType(StandardTypes.BIGINT) long subnetSize)\n+    {\n+        return ipPrefix(castFromVarcharToIpAddress(slice), subnetSize);\n+    }\n+\n+    @Description(\"First/Smallest subnet IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_min\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMin(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        validateIpPrefixAndGetBytes(value);\n+        return castFromIpPrefixToIpAddress(value);\n+    }\n+\n+    @Description(\"Last/Maximum subnet IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_max\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMax(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        byte[] address = validateIpPrefixAndGetBytes(value);\n+        int subnetSize = value.getByte(IPPREFIX.getFixedSize() - 1) & 0xFF;\n+\n+        if (address.length == 4) {\n+            for (int i = 0; i < 4; i++) {\n+                address[3 - i] |= (byte) ~(~0 << min(max((32 - subnetSize) - 8 * i, 0), 8));\n+            }\n+            byte[] bytes = new byte[16];\n+            bytes[10] = (byte) 0xff;\n+            bytes[11] = (byte) 0xff;\n+            arraycopy(address, 0, bytes, 12, 4);\n+            address = bytes;\n+        }\n+        else if (address.length == 16) {\n+            for (int i = 0; i < 16; i++) {\n+                address[15 - i] |= (byte) ~(~0 << min(max((128 - subnetSize) - 8 * i, 0), 8));\n+            }\n+        }\n+        return wrappedBuffer(address);\n+    }\n+\n+    @Description(\"Range of IP address's in the subnet of the IP prefix\")\n+    @ScalarFunction(\"ip_subnet_range\")\n+    @SqlType(\"array(IPADDRESS)\")\n+    public static Block ipSubnetRange(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        validateIpPrefixAndGetBytes(value);\n+        BlockBuilder blockBuilder = IPADDRESS.createBlockBuilder(null, 2);\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMin(value));\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMax(value));\n+        return blockBuilder.build();\n+    }\n+\n+    @Description(\"Is the IP address in the subnet of IP prefix\")\n+    @ScalarFunction(\"is_subnet_of\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean isSubnetOf(@SqlType(StandardTypes.IPPREFIX) Slice left, @SqlType(StandardTypes.IPADDRESS) Slice right)\n+    {\n+        validateIpAddress(right);\n+        return between(right, ipSubnetMin(left), ipSubnetMax(left));\n+    }\n+\n+    @Description(\"Is the second IP prefix argument within the subnet of the first IP prefix argument\")\n+    @ScalarFunction(\"is_prefix_subnet_of\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean isPrefixSubnetOf(@SqlType(StandardTypes.IPPREFIX) Slice left, @SqlType(StandardTypes.IPPREFIX) Slice right)\n+    {\n+        return between(ipSubnetMin(right), ipSubnetMin(left), ipSubnetMax(left)) && between(ipSubnetMax(right), ipSubnetMin(left), ipSubnetMax(left));\n+    }\n+\n+    private static InetAddress validateIpAddress(Slice ipAddressSlice)", "originalCommit": "1509128a9f55fdcf9efd68be443d377f10e2fae7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE4NTY4OA==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r379185688", "bodyText": "Maybe just \"Smallest IP address for a given IP prefix\"", "author": "rongrong", "createdAt": "2020-02-13T23:57:44Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/IpPrefixFunctions.java", "diffHunk": "@@ -40,16 +50,101 @@ private IpPrefixFunctions() {}\n     @ScalarFunction(\"ip_prefix\")\n     @SqlType(StandardTypes.IPPREFIX)\n     public static Slice ipPrefix(@SqlType(StandardTypes.IPADDRESS) Slice value, @SqlType(StandardTypes.BIGINT) long subnetSize)\n+    {\n+        InetAddress address = validateIpAddress(value);\n+        validateSubnetSize(address.getAddress(), subnetSize);\n+\n+        return castFromVarcharToIpPrefix(utf8Slice(InetAddresses.toAddrString(address) + \"/\" + subnetSize));\n+    }\n+\n+    @Description(\"IP prefix for a given IP address and subnet size\")\n+    @ScalarFunction(\"ip_prefix\")\n+    @LiteralParameters(\"x\")\n+    @SqlType(StandardTypes.IPPREFIX)\n+    public static Slice stringIpPrefix(@SqlType(\"varchar(x)\") Slice slice, @SqlType(StandardTypes.BIGINT) long subnetSize)\n+    {\n+        return ipPrefix(castFromVarcharToIpAddress(slice), subnetSize);\n+    }\n+\n+    @Description(\"First/Smallest subnet IP address for a given IP prefix\")", "originalCommit": "1509128a9f55fdcf9efd68be443d377f10e2fae7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5MTg3NA==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r379191874", "bodyText": "The value is validated 3 times in this function.", "author": "rongrong", "createdAt": "2020-02-14T00:19:48Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/IpPrefixFunctions.java", "diffHunk": "@@ -40,16 +50,101 @@ private IpPrefixFunctions() {}\n     @ScalarFunction(\"ip_prefix\")\n     @SqlType(StandardTypes.IPPREFIX)\n     public static Slice ipPrefix(@SqlType(StandardTypes.IPADDRESS) Slice value, @SqlType(StandardTypes.BIGINT) long subnetSize)\n+    {\n+        InetAddress address = validateIpAddress(value);\n+        validateSubnetSize(address.getAddress(), subnetSize);\n+\n+        return castFromVarcharToIpPrefix(utf8Slice(InetAddresses.toAddrString(address) + \"/\" + subnetSize));\n+    }\n+\n+    @Description(\"IP prefix for a given IP address and subnet size\")\n+    @ScalarFunction(\"ip_prefix\")\n+    @LiteralParameters(\"x\")\n+    @SqlType(StandardTypes.IPPREFIX)\n+    public static Slice stringIpPrefix(@SqlType(\"varchar(x)\") Slice slice, @SqlType(StandardTypes.BIGINT) long subnetSize)\n+    {\n+        return ipPrefix(castFromVarcharToIpAddress(slice), subnetSize);\n+    }\n+\n+    @Description(\"First/Smallest subnet IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_min\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMin(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        validateIpPrefixAndGetBytes(value);\n+        return castFromIpPrefixToIpAddress(value);\n+    }\n+\n+    @Description(\"Last/Maximum subnet IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_max\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMax(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        byte[] address = validateIpPrefixAndGetBytes(value);\n+        int subnetSize = value.getByte(IPPREFIX.getFixedSize() - 1) & 0xFF;\n+\n+        if (address.length == 4) {\n+            for (int i = 0; i < 4; i++) {\n+                address[3 - i] |= (byte) ~(~0 << min(max((32 - subnetSize) - 8 * i, 0), 8));\n+            }\n+            byte[] bytes = new byte[16];\n+            bytes[10] = (byte) 0xff;\n+            bytes[11] = (byte) 0xff;\n+            arraycopy(address, 0, bytes, 12, 4);\n+            address = bytes;\n+        }\n+        else if (address.length == 16) {\n+            for (int i = 0; i < 16; i++) {\n+                address[15 - i] |= (byte) ~(~0 << min(max((128 - subnetSize) - 8 * i, 0), 8));\n+            }\n+        }\n+        return wrappedBuffer(address);\n+    }\n+\n+    @Description(\"Range of IP address's in the subnet of the IP prefix\")\n+    @ScalarFunction(\"ip_subnet_range\")\n+    @SqlType(\"array(IPADDRESS)\")\n+    public static Block ipSubnetRange(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        validateIpPrefixAndGetBytes(value);", "originalCommit": "1509128a9f55fdcf9efd68be443d377f10e2fae7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTU3MDE5OA==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r379570198", "bodyText": "Removed the validation part. Since the IPREFIX input will always be valid.", "author": "NikhilCollooru", "createdAt": "2020-02-14T18:05:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5MTg3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM3OTE5MjAzNA==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r379192034", "bodyText": "The input has to be a valid ipprefix so you don't need to validate it.", "author": "rongrong", "createdAt": "2020-02-14T00:20:34Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/IpPrefixFunctions.java", "diffHunk": "@@ -40,16 +50,101 @@ private IpPrefixFunctions() {}\n     @ScalarFunction(\"ip_prefix\")\n     @SqlType(StandardTypes.IPPREFIX)\n     public static Slice ipPrefix(@SqlType(StandardTypes.IPADDRESS) Slice value, @SqlType(StandardTypes.BIGINT) long subnetSize)\n+    {\n+        InetAddress address = validateIpAddress(value);\n+        validateSubnetSize(address.getAddress(), subnetSize);\n+\n+        return castFromVarcharToIpPrefix(utf8Slice(InetAddresses.toAddrString(address) + \"/\" + subnetSize));\n+    }\n+\n+    @Description(\"IP prefix for a given IP address and subnet size\")\n+    @ScalarFunction(\"ip_prefix\")\n+    @LiteralParameters(\"x\")\n+    @SqlType(StandardTypes.IPPREFIX)\n+    public static Slice stringIpPrefix(@SqlType(\"varchar(x)\") Slice slice, @SqlType(StandardTypes.BIGINT) long subnetSize)\n+    {\n+        return ipPrefix(castFromVarcharToIpAddress(slice), subnetSize);\n+    }\n+\n+    @Description(\"First/Smallest subnet IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_min\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMin(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        validateIpPrefixAndGetBytes(value);", "originalCommit": "1509128a9f55fdcf9efd68be443d377f10e2fae7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "40fc1302ce768ee1a677f204e1f06552f309b487", "url": "https://github.com/prestodb/presto/commit/40fc1302ce768ee1a677f204e1f06552f309b487", "message": "Add IPPREFIX functions", "committedDate": "2020-02-14T18:06:42Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1MTM5Mg==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380351392", "bodyText": "What about: Is the second IP prefix in the subnet of the first IP prefix", "author": "caithagoras", "createdAt": "2020-02-17T20:11:20Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/IpPrefixFunctions.java", "diffHunk": "@@ -71,4 +74,78 @@ public static Slice stringIpPrefix(@SqlType(\"varchar(x)\") Slice slice, @SqlType(\n     {\n         return ipPrefix(castFromVarcharToIpAddress(slice), subnetSize);\n     }\n+\n+    @Description(\"Smallest IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_min\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMin(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        return castFromIpPrefixToIpAddress(value);\n+    }\n+\n+    @Description(\"Largest IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_max\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMax(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        byte[] address = toInetAddress(value.slice(0, IPADDRESS.getFixedSize())).getAddress();\n+        int subnetSize = value.getByte(IPPREFIX.getFixedSize() - 1) & 0xFF;\n+\n+        if (address.length == 4) {\n+            for (int i = 0; i < 4; i++) {\n+                address[3 - i] |= (byte) ~(~0 << min(max((32 - subnetSize) - 8 * i, 0), 8));\n+            }\n+            byte[] bytes = new byte[16];\n+            bytes[10] = (byte) 0xff;\n+            bytes[11] = (byte) 0xff;\n+            arraycopy(address, 0, bytes, 12, 4);\n+            address = bytes;\n+        }\n+        else if (address.length == 16) {\n+            for (int i = 0; i < 16; i++) {\n+                address[15 - i] |= (byte) ~(~0 << min(max((128 - subnetSize) - 8 * i, 0), 8));\n+            }\n+        }\n+        return wrappedBuffer(address);\n+    }\n+\n+    @Description(\"Array of smallest and largest IP address in the subnet of the given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_range\")\n+    @SqlType(\"array(IPADDRESS)\")\n+    public static Block ipSubnetRange(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        BlockBuilder blockBuilder = IPADDRESS.createBlockBuilder(null, 2);\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMin(value));\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMax(value));\n+        return blockBuilder.build();\n+    }\n+\n+    @Description(\"Is the IP address in the subnet of IP prefix\")\n+    @ScalarFunction(\"is_subnet_of\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean isSubnetOf(@SqlType(StandardTypes.IPPREFIX) Slice left, @SqlType(StandardTypes.IPADDRESS) Slice right)\n+    {\n+        toInetAddress(right);\n+        return between(right, ipSubnetMin(left), ipSubnetMax(left));\n+    }\n+\n+    @Description(\"Is the second IP prefix argument within the subnet of the first IP prefix argument\")", "originalCommit": "40fc1302ce768ee1a677f204e1f06552f309b487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1Mjc4Nw==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380352787", "bodyText": "Now that this is a standalone function. You can just do return InetAdress.get... here, and remove the temporary variable.", "author": "caithagoras", "createdAt": "2020-02-17T20:16:48Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/IpPrefixFunctions.java", "diffHunk": "@@ -71,4 +74,78 @@ public static Slice stringIpPrefix(@SqlType(\"varchar(x)\") Slice slice, @SqlType(\n     {\n         return ipPrefix(castFromVarcharToIpAddress(slice), subnetSize);\n     }\n+\n+    @Description(\"Smallest IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_min\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMin(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        return castFromIpPrefixToIpAddress(value);\n+    }\n+\n+    @Description(\"Largest IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_max\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMax(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        byte[] address = toInetAddress(value.slice(0, IPADDRESS.getFixedSize())).getAddress();\n+        int subnetSize = value.getByte(IPPREFIX.getFixedSize() - 1) & 0xFF;\n+\n+        if (address.length == 4) {\n+            for (int i = 0; i < 4; i++) {\n+                address[3 - i] |= (byte) ~(~0 << min(max((32 - subnetSize) - 8 * i, 0), 8));\n+            }\n+            byte[] bytes = new byte[16];\n+            bytes[10] = (byte) 0xff;\n+            bytes[11] = (byte) 0xff;\n+            arraycopy(address, 0, bytes, 12, 4);\n+            address = bytes;\n+        }\n+        else if (address.length == 16) {\n+            for (int i = 0; i < 16; i++) {\n+                address[15 - i] |= (byte) ~(~0 << min(max((128 - subnetSize) - 8 * i, 0), 8));\n+            }\n+        }\n+        return wrappedBuffer(address);\n+    }\n+\n+    @Description(\"Array of smallest and largest IP address in the subnet of the given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_range\")\n+    @SqlType(\"array(IPADDRESS)\")\n+    public static Block ipSubnetRange(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        BlockBuilder blockBuilder = IPADDRESS.createBlockBuilder(null, 2);\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMin(value));\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMax(value));\n+        return blockBuilder.build();\n+    }\n+\n+    @Description(\"Is the IP address in the subnet of IP prefix\")\n+    @ScalarFunction(\"is_subnet_of\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean isSubnetOf(@SqlType(StandardTypes.IPPREFIX) Slice left, @SqlType(StandardTypes.IPADDRESS) Slice right)\n+    {\n+        toInetAddress(right);\n+        return between(right, ipSubnetMin(left), ipSubnetMax(left));\n+    }\n+\n+    @Description(\"Is the second IP prefix argument within the subnet of the first IP prefix argument\")\n+    @ScalarFunction(\"is_subnet_of\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean isPrefixSubnetOf(@SqlType(StandardTypes.IPPREFIX) Slice left, @SqlType(StandardTypes.IPPREFIX) Slice right)\n+    {\n+        return between(ipSubnetMin(right), ipSubnetMin(left), ipSubnetMax(left)) && between(ipSubnetMax(right), ipSubnetMin(left), ipSubnetMax(left));\n+    }\n+\n+    private static InetAddress toInetAddress(Slice ipAddress)\n+    {\n+        InetAddress address;\n+        try {\n+            address = InetAddress.getByAddress(ipAddress.getBytes());", "originalCommit": "40fc1302ce768ee1a677f204e1f06552f309b487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1MzE0OA==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380353148", "bodyText": "nit: what about naming the parameters as (prefix, address), or (ipPrefix, ipAddress).", "author": "caithagoras", "createdAt": "2020-02-17T20:18:25Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/IpPrefixFunctions.java", "diffHunk": "@@ -71,4 +74,78 @@ public static Slice stringIpPrefix(@SqlType(\"varchar(x)\") Slice slice, @SqlType(\n     {\n         return ipPrefix(castFromVarcharToIpAddress(slice), subnetSize);\n     }\n+\n+    @Description(\"Smallest IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_min\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMin(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        return castFromIpPrefixToIpAddress(value);\n+    }\n+\n+    @Description(\"Largest IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_max\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMax(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        byte[] address = toInetAddress(value.slice(0, IPADDRESS.getFixedSize())).getAddress();\n+        int subnetSize = value.getByte(IPPREFIX.getFixedSize() - 1) & 0xFF;\n+\n+        if (address.length == 4) {\n+            for (int i = 0; i < 4; i++) {\n+                address[3 - i] |= (byte) ~(~0 << min(max((32 - subnetSize) - 8 * i, 0), 8));\n+            }\n+            byte[] bytes = new byte[16];\n+            bytes[10] = (byte) 0xff;\n+            bytes[11] = (byte) 0xff;\n+            arraycopy(address, 0, bytes, 12, 4);\n+            address = bytes;\n+        }\n+        else if (address.length == 16) {\n+            for (int i = 0; i < 16; i++) {\n+                address[15 - i] |= (byte) ~(~0 << min(max((128 - subnetSize) - 8 * i, 0), 8));\n+            }\n+        }\n+        return wrappedBuffer(address);\n+    }\n+\n+    @Description(\"Array of smallest and largest IP address in the subnet of the given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_range\")\n+    @SqlType(\"array(IPADDRESS)\")\n+    public static Block ipSubnetRange(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        BlockBuilder blockBuilder = IPADDRESS.createBlockBuilder(null, 2);\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMin(value));\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMax(value));\n+        return blockBuilder.build();\n+    }\n+\n+    @Description(\"Is the IP address in the subnet of IP prefix\")\n+    @ScalarFunction(\"is_subnet_of\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean isSubnetOf(@SqlType(StandardTypes.IPPREFIX) Slice left, @SqlType(StandardTypes.IPADDRESS) Slice right)", "originalCommit": "40fc1302ce768ee1a677f204e1f06552f309b487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1MzM4NQ==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380353385", "bodyText": "nit: What about naming those variables as first and second, as corresponding to the description.", "author": "caithagoras", "createdAt": "2020-02-17T20:19:21Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/IpPrefixFunctions.java", "diffHunk": "@@ -71,4 +74,78 @@ public static Slice stringIpPrefix(@SqlType(\"varchar(x)\") Slice slice, @SqlType(\n     {\n         return ipPrefix(castFromVarcharToIpAddress(slice), subnetSize);\n     }\n+\n+    @Description(\"Smallest IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_min\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMin(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        return castFromIpPrefixToIpAddress(value);\n+    }\n+\n+    @Description(\"Largest IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_max\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMax(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        byte[] address = toInetAddress(value.slice(0, IPADDRESS.getFixedSize())).getAddress();\n+        int subnetSize = value.getByte(IPPREFIX.getFixedSize() - 1) & 0xFF;\n+\n+        if (address.length == 4) {\n+            for (int i = 0; i < 4; i++) {\n+                address[3 - i] |= (byte) ~(~0 << min(max((32 - subnetSize) - 8 * i, 0), 8));\n+            }\n+            byte[] bytes = new byte[16];\n+            bytes[10] = (byte) 0xff;\n+            bytes[11] = (byte) 0xff;\n+            arraycopy(address, 0, bytes, 12, 4);\n+            address = bytes;\n+        }\n+        else if (address.length == 16) {\n+            for (int i = 0; i < 16; i++) {\n+                address[15 - i] |= (byte) ~(~0 << min(max((128 - subnetSize) - 8 * i, 0), 8));\n+            }\n+        }\n+        return wrappedBuffer(address);\n+    }\n+\n+    @Description(\"Array of smallest and largest IP address in the subnet of the given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_range\")\n+    @SqlType(\"array(IPADDRESS)\")\n+    public static Block ipSubnetRange(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        BlockBuilder blockBuilder = IPADDRESS.createBlockBuilder(null, 2);\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMin(value));\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMax(value));\n+        return blockBuilder.build();\n+    }\n+\n+    @Description(\"Is the IP address in the subnet of IP prefix\")\n+    @ScalarFunction(\"is_subnet_of\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean isSubnetOf(@SqlType(StandardTypes.IPPREFIX) Slice left, @SqlType(StandardTypes.IPADDRESS) Slice right)\n+    {\n+        toInetAddress(right);\n+        return between(right, ipSubnetMin(left), ipSubnetMax(left));\n+    }\n+\n+    @Description(\"Is the second IP prefix argument within the subnet of the first IP prefix argument\")\n+    @ScalarFunction(\"is_subnet_of\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean isPrefixSubnetOf(@SqlType(StandardTypes.IPPREFIX) Slice left, @SqlType(StandardTypes.IPPREFIX) Slice right)", "originalCommit": "40fc1302ce768ee1a677f204e1f06552f309b487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1NDA4OQ==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380354089", "bodyText": "Those 2 test cases do not belong to this test method. Unlike the IP_PREFIX, which can take VARCHAR  as the input, those 2 test cases are not testing the behavior of IP_SUBNET_MIN, but the behavior of casting VARCHAR to IPPREFIX.", "author": "caithagoras", "createdAt": "2020-02-17T20:21:59Z", "path": "presto-main/src/test/java/com/facebook/presto/operator/scalar/TestIpPrefixFunctions.java", "diffHunk": "@@ -57,4 +61,65 @@ public void testStringIpPrefix()\n         assertInvalidCast(\"IP_PREFIX('64:face:book::10', 24)\", \"Cannot cast value to IPADDRESS: 64:face:book::10\");\n         assertInvalidCast(\"IP_PREFIX('123.456.789.012', 24)\", \"Cannot cast value to IPADDRESS: 123.456.789.012\");\n     }\n+\n+    @Test\n+    public void testIpSubnetMin()\n+    {\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '1.2.3.4/24')\", IPADDRESS, \"1.2.3.0\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '1.2.3.4/32')\", IPADDRESS, \"1.2.3.4\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/64')\", IPADDRESS, \"64:ff9b::\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/127')\", IPADDRESS, \"64:ff9b::16\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/128')\", IPADDRESS, \"64:ff9b::17\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/0')\", IPADDRESS, \"::\");\n+        assertInvalidCast(\"IP_SUBNET_MIN(IPPREFIX '64::ff9b::10/48')\", \"Cannot cast value to IPPREFIX: 64::ff9b::10/48\");\n+        assertInvalidCast(\"IP_SUBNET_MIN(IPPREFIX '123.456.789.012/24')\", \"Cannot cast value to IPPREFIX: 123.456.789.012/24\");", "originalCommit": "40fc1302ce768ee1a677f204e1f06552f309b487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM4NTExNw==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380385117", "bodyText": "I added these tests based on Rongrong's earlier comment. But i agree that they do not test the IP_SUBNET_MIN  function. If the argument IPPREFIX is always valid then we need not test the invalid input cases.", "author": "NikhilCollooru", "createdAt": "2020-02-17T22:28:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1NDA4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1NDE4Nw==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380354187", "bodyText": "Same here, remove.", "author": "caithagoras", "createdAt": "2020-02-17T20:22:22Z", "path": "presto-main/src/test/java/com/facebook/presto/operator/scalar/TestIpPrefixFunctions.java", "diffHunk": "@@ -57,4 +61,65 @@ public void testStringIpPrefix()\n         assertInvalidCast(\"IP_PREFIX('64:face:book::10', 24)\", \"Cannot cast value to IPADDRESS: 64:face:book::10\");\n         assertInvalidCast(\"IP_PREFIX('123.456.789.012', 24)\", \"Cannot cast value to IPADDRESS: 123.456.789.012\");\n     }\n+\n+    @Test\n+    public void testIpSubnetMin()\n+    {\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '1.2.3.4/24')\", IPADDRESS, \"1.2.3.0\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '1.2.3.4/32')\", IPADDRESS, \"1.2.3.4\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/64')\", IPADDRESS, \"64:ff9b::\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/127')\", IPADDRESS, \"64:ff9b::16\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/128')\", IPADDRESS, \"64:ff9b::17\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/0')\", IPADDRESS, \"::\");\n+        assertInvalidCast(\"IP_SUBNET_MIN(IPPREFIX '64::ff9b::10/48')\", \"Cannot cast value to IPPREFIX: 64::ff9b::10/48\");\n+        assertInvalidCast(\"IP_SUBNET_MIN(IPPREFIX '123.456.789.012/24')\", \"Cannot cast value to IPPREFIX: 123.456.789.012/24\");\n+    }\n+\n+    @Test\n+    public void testIpSubnetMax()\n+    {\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '1.2.3.128/26')\", IPADDRESS, \"1.2.3.191\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '192.168.128.4/32')\", IPADDRESS, \"192.168.128.4\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '10.1.16.3/9')\", IPADDRESS, \"10.127.255.255\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '2001:db8::16/127')\", IPADDRESS, \"2001:db8::17\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '2001:db8::16/128')\", IPADDRESS, \"2001:db8::16\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '64:ff9b::17/64')\", IPADDRESS, \"64:ff9b::ffff:ffff:ffff:ffff\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '64:ff9b::17/72')\", IPADDRESS, \"64:ff9b::ff:ffff:ffff:ffff\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '64:ff9b::17/0')\", IPADDRESS, \"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\");\n+        assertInvalidCast(\"IP_SUBNET_MAX(IPPREFIX '64::ff9b::10/24')\", \"Cannot cast value to IPPREFIX: 64::ff9b::10/24\");\n+        assertInvalidCast(\"IP_SUBNET_MAX(IPPREFIX '123.456.789.012/-1')\", \"Cannot cast value to IPPREFIX: 123.456.789.012/-1\");", "originalCommit": "40fc1302ce768ee1a677f204e1f06552f309b487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1NDIyNg==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380354226", "bodyText": "Same here.", "author": "caithagoras", "createdAt": "2020-02-17T20:22:28Z", "path": "presto-main/src/test/java/com/facebook/presto/operator/scalar/TestIpPrefixFunctions.java", "diffHunk": "@@ -57,4 +61,65 @@ public void testStringIpPrefix()\n         assertInvalidCast(\"IP_PREFIX('64:face:book::10', 24)\", \"Cannot cast value to IPADDRESS: 64:face:book::10\");\n         assertInvalidCast(\"IP_PREFIX('123.456.789.012', 24)\", \"Cannot cast value to IPADDRESS: 123.456.789.012\");\n     }\n+\n+    @Test\n+    public void testIpSubnetMin()\n+    {\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '1.2.3.4/24')\", IPADDRESS, \"1.2.3.0\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '1.2.3.4/32')\", IPADDRESS, \"1.2.3.4\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/64')\", IPADDRESS, \"64:ff9b::\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/127')\", IPADDRESS, \"64:ff9b::16\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/128')\", IPADDRESS, \"64:ff9b::17\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/0')\", IPADDRESS, \"::\");\n+        assertInvalidCast(\"IP_SUBNET_MIN(IPPREFIX '64::ff9b::10/48')\", \"Cannot cast value to IPPREFIX: 64::ff9b::10/48\");\n+        assertInvalidCast(\"IP_SUBNET_MIN(IPPREFIX '123.456.789.012/24')\", \"Cannot cast value to IPPREFIX: 123.456.789.012/24\");\n+    }\n+\n+    @Test\n+    public void testIpSubnetMax()\n+    {\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '1.2.3.128/26')\", IPADDRESS, \"1.2.3.191\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '192.168.128.4/32')\", IPADDRESS, \"192.168.128.4\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '10.1.16.3/9')\", IPADDRESS, \"10.127.255.255\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '2001:db8::16/127')\", IPADDRESS, \"2001:db8::17\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '2001:db8::16/128')\", IPADDRESS, \"2001:db8::16\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '64:ff9b::17/64')\", IPADDRESS, \"64:ff9b::ffff:ffff:ffff:ffff\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '64:ff9b::17/72')\", IPADDRESS, \"64:ff9b::ff:ffff:ffff:ffff\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '64:ff9b::17/0')\", IPADDRESS, \"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\");\n+        assertInvalidCast(\"IP_SUBNET_MAX(IPPREFIX '64::ff9b::10/24')\", \"Cannot cast value to IPPREFIX: 64::ff9b::10/24\");\n+        assertInvalidCast(\"IP_SUBNET_MAX(IPPREFIX '123.456.789.012/-1')\", \"Cannot cast value to IPPREFIX: 123.456.789.012/-1\");\n+    }\n+\n+    @Test\n+    public void testIpSubnetRange()\n+    {\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '1.2.3.160/24')\", new ArrayType(IPADDRESS), ImmutableList.of(\"1.2.3.0\", \"1.2.3.255\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '1.2.3.128/31')\", new ArrayType(IPADDRESS), ImmutableList.of(\"1.2.3.128\", \"1.2.3.129\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '10.1.6.46/32')\", new ArrayType(IPADDRESS), ImmutableList.of(\"10.1.6.46\", \"10.1.6.46\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '10.1.6.46/0')\", new ArrayType(IPADDRESS), ImmutableList.of(\"0.0.0.0\", \"255.255.255.255\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '64:ff9b::17/64')\", new ArrayType(IPADDRESS), ImmutableList.of(\"64:ff9b::\", \"64:ff9b::ffff:ffff:ffff:ffff\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '64:ff9b::52f4/120')\", new ArrayType(IPADDRESS), ImmutableList.of(\"64:ff9b::5200\", \"64:ff9b::52ff\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '64:ff9b::17/128')\", new ArrayType(IPADDRESS), ImmutableList.of(\"64:ff9b::17\", \"64:ff9b::17\"));\n+        assertInvalidCast(\"IP_SUBNET_RANGE(IPPREFIX '64::ff9b::10/24')\", \"Cannot cast value to IPPREFIX: 64::ff9b::10/24\");\n+        assertInvalidCast(\"IP_SUBNET_RANGE(IPPREFIX '123.456.789.012/-1')\", \"Cannot cast value to IPPREFIX: 123.456.789.012/-1\");", "originalCommit": "40fc1302ce768ee1a677f204e1f06552f309b487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1NDI1MA==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380354250", "bodyText": "Same here.", "author": "caithagoras", "createdAt": "2020-02-17T20:22:35Z", "path": "presto-main/src/test/java/com/facebook/presto/operator/scalar/TestIpPrefixFunctions.java", "diffHunk": "@@ -57,4 +61,65 @@ public void testStringIpPrefix()\n         assertInvalidCast(\"IP_PREFIX('64:face:book::10', 24)\", \"Cannot cast value to IPADDRESS: 64:face:book::10\");\n         assertInvalidCast(\"IP_PREFIX('123.456.789.012', 24)\", \"Cannot cast value to IPADDRESS: 123.456.789.012\");\n     }\n+\n+    @Test\n+    public void testIpSubnetMin()\n+    {\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '1.2.3.4/24')\", IPADDRESS, \"1.2.3.0\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '1.2.3.4/32')\", IPADDRESS, \"1.2.3.4\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/64')\", IPADDRESS, \"64:ff9b::\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/127')\", IPADDRESS, \"64:ff9b::16\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/128')\", IPADDRESS, \"64:ff9b::17\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/0')\", IPADDRESS, \"::\");\n+        assertInvalidCast(\"IP_SUBNET_MIN(IPPREFIX '64::ff9b::10/48')\", \"Cannot cast value to IPPREFIX: 64::ff9b::10/48\");\n+        assertInvalidCast(\"IP_SUBNET_MIN(IPPREFIX '123.456.789.012/24')\", \"Cannot cast value to IPPREFIX: 123.456.789.012/24\");\n+    }\n+\n+    @Test\n+    public void testIpSubnetMax()\n+    {\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '1.2.3.128/26')\", IPADDRESS, \"1.2.3.191\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '192.168.128.4/32')\", IPADDRESS, \"192.168.128.4\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '10.1.16.3/9')\", IPADDRESS, \"10.127.255.255\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '2001:db8::16/127')\", IPADDRESS, \"2001:db8::17\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '2001:db8::16/128')\", IPADDRESS, \"2001:db8::16\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '64:ff9b::17/64')\", IPADDRESS, \"64:ff9b::ffff:ffff:ffff:ffff\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '64:ff9b::17/72')\", IPADDRESS, \"64:ff9b::ff:ffff:ffff:ffff\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '64:ff9b::17/0')\", IPADDRESS, \"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\");\n+        assertInvalidCast(\"IP_SUBNET_MAX(IPPREFIX '64::ff9b::10/24')\", \"Cannot cast value to IPPREFIX: 64::ff9b::10/24\");\n+        assertInvalidCast(\"IP_SUBNET_MAX(IPPREFIX '123.456.789.012/-1')\", \"Cannot cast value to IPPREFIX: 123.456.789.012/-1\");\n+    }\n+\n+    @Test\n+    public void testIpSubnetRange()\n+    {\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '1.2.3.160/24')\", new ArrayType(IPADDRESS), ImmutableList.of(\"1.2.3.0\", \"1.2.3.255\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '1.2.3.128/31')\", new ArrayType(IPADDRESS), ImmutableList.of(\"1.2.3.128\", \"1.2.3.129\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '10.1.6.46/32')\", new ArrayType(IPADDRESS), ImmutableList.of(\"10.1.6.46\", \"10.1.6.46\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '10.1.6.46/0')\", new ArrayType(IPADDRESS), ImmutableList.of(\"0.0.0.0\", \"255.255.255.255\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '64:ff9b::17/64')\", new ArrayType(IPADDRESS), ImmutableList.of(\"64:ff9b::\", \"64:ff9b::ffff:ffff:ffff:ffff\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '64:ff9b::52f4/120')\", new ArrayType(IPADDRESS), ImmutableList.of(\"64:ff9b::5200\", \"64:ff9b::52ff\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '64:ff9b::17/128')\", new ArrayType(IPADDRESS), ImmutableList.of(\"64:ff9b::17\", \"64:ff9b::17\"));\n+        assertInvalidCast(\"IP_SUBNET_RANGE(IPPREFIX '64::ff9b::10/24')\", \"Cannot cast value to IPPREFIX: 64::ff9b::10/24\");\n+        assertInvalidCast(\"IP_SUBNET_RANGE(IPPREFIX '123.456.789.012/-1')\", \"Cannot cast value to IPPREFIX: 123.456.789.012/-1\");\n+    }\n+\n+    @Test\n+    public void testIsSubnetOf()\n+    {\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '1.2.3.128/26', IPADDRESS '1.2.3.129')\", BOOLEAN, true);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '1.2.3.128/26', IPADDRESS '1.2.5.1')\", BOOLEAN, false);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '1.2.3.128/32', IPADDRESS '1.2.3.128')\", BOOLEAN, true);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '1.2.3.128/0', IPADDRESS '192.168.5.1')\", BOOLEAN, true);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '64:ff9b::17/64', IPADDRESS '64:ff9b::ffff:ff')\", BOOLEAN, true);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '64:ff9b::17/64', IPADDRESS '64:ffff::17')\", BOOLEAN, false);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '192.168.3.131/26', IPPREFIX '192.168.3.144/30')\", BOOLEAN, true);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '1.2.3.128/26', IPPREFIX '1.2.5.1/30')\", BOOLEAN, false);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '1.2.3.128/26', IPPREFIX '1.2.3.128/26')\", BOOLEAN, true);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '64:ff9b::17/64', IPPREFIX '64:ff9b::ff:25/80')\", BOOLEAN, true);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '64:ff9b::17/64', IPPREFIX '64:ffff::17/64')\", BOOLEAN, false);\n+        assertInvalidCast(\"IS_SUBNET_OF(IPPREFIX '64:ff9b::17/64', IPPREFIX '64::ffff::17/64')\", \"Cannot cast value to IPPREFIX: 64::ffff::17/64\");\n+        assertInvalidCast(\"IS_SUBNET_OF(IPPREFIX '123.456.789.012/-1', IPPREFIX '10.1.1.10/20')\", \"Cannot cast value to IPPREFIX: 123.456.789.012/-1\");\n+        assertInvalidCast(\"IS_SUBNET_OF(IPPREFIX '123.456.789.012/-1', IPPREFIX '10.1.1.10/99')\", \"Cannot cast value to IPPREFIX: 123.456.789.012/-1\");", "originalCommit": "40fc1302ce768ee1a677f204e1f06552f309b487", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1NTY2NA==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380355664", "bodyText": "@rongrong Correct me if I'm wrong here: I believe the second between is redundant?\nIf\nbetween(ipSubnetMin(right), ipSubnetMin(left), ipSubnetMax(left))\n\nis true,\nbetween(ipSubnetMax(right), ipSubnetMin(left), ipSubnetMax(left))\n\nmust be true, and vice versa.", "author": "caithagoras", "createdAt": "2020-02-17T20:27:53Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/scalar/IpPrefixFunctions.java", "diffHunk": "@@ -71,4 +74,78 @@ public static Slice stringIpPrefix(@SqlType(\"varchar(x)\") Slice slice, @SqlType(\n     {\n         return ipPrefix(castFromVarcharToIpAddress(slice), subnetSize);\n     }\n+\n+    @Description(\"Smallest IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_min\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMin(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        return castFromIpPrefixToIpAddress(value);\n+    }\n+\n+    @Description(\"Largest IP address for a given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_max\")\n+    @SqlType(StandardTypes.IPADDRESS)\n+    public static Slice ipSubnetMax(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        byte[] address = toInetAddress(value.slice(0, IPADDRESS.getFixedSize())).getAddress();\n+        int subnetSize = value.getByte(IPPREFIX.getFixedSize() - 1) & 0xFF;\n+\n+        if (address.length == 4) {\n+            for (int i = 0; i < 4; i++) {\n+                address[3 - i] |= (byte) ~(~0 << min(max((32 - subnetSize) - 8 * i, 0), 8));\n+            }\n+            byte[] bytes = new byte[16];\n+            bytes[10] = (byte) 0xff;\n+            bytes[11] = (byte) 0xff;\n+            arraycopy(address, 0, bytes, 12, 4);\n+            address = bytes;\n+        }\n+        else if (address.length == 16) {\n+            for (int i = 0; i < 16; i++) {\n+                address[15 - i] |= (byte) ~(~0 << min(max((128 - subnetSize) - 8 * i, 0), 8));\n+            }\n+        }\n+        return wrappedBuffer(address);\n+    }\n+\n+    @Description(\"Array of smallest and largest IP address in the subnet of the given IP prefix\")\n+    @ScalarFunction(\"ip_subnet_range\")\n+    @SqlType(\"array(IPADDRESS)\")\n+    public static Block ipSubnetRange(@SqlType(StandardTypes.IPPREFIX) Slice value)\n+    {\n+        BlockBuilder blockBuilder = IPADDRESS.createBlockBuilder(null, 2);\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMin(value));\n+        IPADDRESS.writeSlice(blockBuilder, ipSubnetMax(value));\n+        return blockBuilder.build();\n+    }\n+\n+    @Description(\"Is the IP address in the subnet of IP prefix\")\n+    @ScalarFunction(\"is_subnet_of\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean isSubnetOf(@SqlType(StandardTypes.IPPREFIX) Slice left, @SqlType(StandardTypes.IPADDRESS) Slice right)\n+    {\n+        toInetAddress(right);\n+        return between(right, ipSubnetMin(left), ipSubnetMax(left));\n+    }\n+\n+    @Description(\"Is the second IP prefix argument within the subnet of the first IP prefix argument\")\n+    @ScalarFunction(\"is_subnet_of\")\n+    @SqlType(StandardTypes.BOOLEAN)\n+    public static boolean isPrefixSubnetOf(@SqlType(StandardTypes.IPPREFIX) Slice left, @SqlType(StandardTypes.IPPREFIX) Slice right)\n+    {\n+        return between(ipSubnetMin(right), ipSubnetMin(left), ipSubnetMax(left)) && between(ipSubnetMax(right), ipSubnetMin(left), ipSubnetMax(left));", "originalCommit": "40fc1302ce768ee1a677f204e1f06552f309b487", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM4NTI2MA==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380385260", "bodyText": "Agree. I thought about it but added the redundant check just to be sure. Anyways we can remove it.", "author": "NikhilCollooru", "createdAt": "2020-02-17T22:29:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM1NTY2NA=="}], "type": "inlineReview"}, {"oid": "905a033fe7122a993ccb7093c8ece30118ddd75d", "url": "https://github.com/prestodb/presto/commit/905a033fe7122a993ccb7093c8ece30118ddd75d", "message": "Add IPPREFIX functions", "committedDate": "2020-02-17T22:35:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MDM5NjA2Mg==", "url": "https://github.com/prestodb/presto/pull/14090#discussion_r380396062", "bodyText": "nit: Add a line break between line 109 and line 110 for readability.", "author": "caithagoras", "createdAt": "2020-02-17T23:23:08Z", "path": "presto-main/src/test/java/com/facebook/presto/operator/scalar/TestIpPrefixFunctions.java", "diffHunk": "@@ -57,4 +61,56 @@ public void testStringIpPrefix()\n         assertInvalidCast(\"IP_PREFIX('64:face:book::10', 24)\", \"Cannot cast value to IPADDRESS: 64:face:book::10\");\n         assertInvalidCast(\"IP_PREFIX('123.456.789.012', 24)\", \"Cannot cast value to IPADDRESS: 123.456.789.012\");\n     }\n+\n+    @Test\n+    public void testIpSubnetMin()\n+    {\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '1.2.3.4/24')\", IPADDRESS, \"1.2.3.0\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '1.2.3.4/32')\", IPADDRESS, \"1.2.3.4\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/64')\", IPADDRESS, \"64:ff9b::\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/127')\", IPADDRESS, \"64:ff9b::16\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/128')\", IPADDRESS, \"64:ff9b::17\");\n+        assertFunction(\"IP_SUBNET_MIN(IPPREFIX '64:ff9b::17/0')\", IPADDRESS, \"::\");\n+    }\n+\n+    @Test\n+    public void testIpSubnetMax()\n+    {\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '1.2.3.128/26')\", IPADDRESS, \"1.2.3.191\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '192.168.128.4/32')\", IPADDRESS, \"192.168.128.4\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '10.1.16.3/9')\", IPADDRESS, \"10.127.255.255\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '2001:db8::16/127')\", IPADDRESS, \"2001:db8::17\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '2001:db8::16/128')\", IPADDRESS, \"2001:db8::16\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '64:ff9b::17/64')\", IPADDRESS, \"64:ff9b::ffff:ffff:ffff:ffff\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '64:ff9b::17/72')\", IPADDRESS, \"64:ff9b::ff:ffff:ffff:ffff\");\n+        assertFunction(\"IP_SUBNET_MAX(IPPREFIX '64:ff9b::17/0')\", IPADDRESS, \"ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff\");\n+    }\n+\n+    @Test\n+    public void testIpSubnetRange()\n+    {\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '1.2.3.160/24')\", new ArrayType(IPADDRESS), ImmutableList.of(\"1.2.3.0\", \"1.2.3.255\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '1.2.3.128/31')\", new ArrayType(IPADDRESS), ImmutableList.of(\"1.2.3.128\", \"1.2.3.129\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '10.1.6.46/32')\", new ArrayType(IPADDRESS), ImmutableList.of(\"10.1.6.46\", \"10.1.6.46\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '10.1.6.46/0')\", new ArrayType(IPADDRESS), ImmutableList.of(\"0.0.0.0\", \"255.255.255.255\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '64:ff9b::17/64')\", new ArrayType(IPADDRESS), ImmutableList.of(\"64:ff9b::\", \"64:ff9b::ffff:ffff:ffff:ffff\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '64:ff9b::52f4/120')\", new ArrayType(IPADDRESS), ImmutableList.of(\"64:ff9b::5200\", \"64:ff9b::52ff\"));\n+        assertFunction(\"IP_SUBNET_RANGE(IPPREFIX '64:ff9b::17/128')\", new ArrayType(IPADDRESS), ImmutableList.of(\"64:ff9b::17\", \"64:ff9b::17\"));\n+    }\n+\n+    @Test\n+    public void testIsSubnetOf()\n+    {\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '1.2.3.128/26', IPADDRESS '1.2.3.129')\", BOOLEAN, true);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '1.2.3.128/26', IPADDRESS '1.2.5.1')\", BOOLEAN, false);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '1.2.3.128/32', IPADDRESS '1.2.3.128')\", BOOLEAN, true);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '1.2.3.128/0', IPADDRESS '192.168.5.1')\", BOOLEAN, true);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '64:ff9b::17/64', IPADDRESS '64:ff9b::ffff:ff')\", BOOLEAN, true);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '64:ff9b::17/64', IPADDRESS '64:ffff::17')\", BOOLEAN, false);\n+        assertFunction(\"IS_SUBNET_OF(IPPREFIX '192.168.3.131/26', IPPREFIX '192.168.3.144/30')\", BOOLEAN, true);", "originalCommit": "905a033fe7122a993ccb7093c8ece30118ddd75d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6ca981677126aa72f5d64b3d4bf37812be99126a", "url": "https://github.com/prestodb/presto/commit/6ca981677126aa72f5d64b3d4bf37812be99126a", "message": "Add IPPREFIX functions", "committedDate": "2020-02-18T20:26:23Z", "type": "commit"}, {"oid": "6ca981677126aa72f5d64b3d4bf37812be99126a", "url": "https://github.com/prestodb/presto/commit/6ca981677126aa72f5d64b3d4bf37812be99126a", "message": "Add IPPREFIX functions", "committedDate": "2020-02-18T20:26:23Z", "type": "forcePushed"}]}