{"pr_number": 15155, "pr_title": "Support fragment result caching", "pr_createdAt": "2020-09-10T01:05:08Z", "pr_url": "https://github.com/prestodb/presto/pull/15155", "timeline": [{"oid": "096f70197ebf6dfa915049b647c74c4b7aa398f7", "url": "https://github.com/prestodb/presto/commit/096f70197ebf6dfa915049b647c74c4b7aa398f7", "message": "Support fragment result caching", "committedDate": "2020-09-10T19:03:22Z", "type": "forcePushed"}, {"oid": "e6fd95be91c302c93139d028ce5e29cb8ecafa82", "url": "https://github.com/prestodb/presto/commit/e6fd95be91c302c93139d028ce5e29cb8ecafa82", "message": "Support fragment result caching", "committedDate": "2020-09-10T22:27:20Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NjE5Nw==", "url": "https://github.com/prestodb/presto/pull/15155#discussion_r487166197", "bodyText": "put FragmentResultCacheManager & fragmentResultCachingEnabled in dirverContext?", "author": "highker", "createdAt": "2020-09-11T16:47:27Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/Driver.java", "diffHunk": "@@ -90,22 +95,27 @@\n \n     private final AtomicReference<SettableFuture<?>> driverBlockedFuture = new AtomicReference<>();\n \n+    private final AtomicReference<Optional<Iterator<Page>>> cachedResult = new AtomicReference<>(Optional.empty());\n+    private final AtomicReference<Split> split = new AtomicReference<>();\n+    private final List<Page> outputPages = new ArrayList<>();\n+\n     private enum State\n     {\n         ALIVE, NEED_DESTRUCTION, DESTROYED\n     }\n \n-    public static Driver createDriver(DriverContext driverContext, List<Operator> operators)\n+    public static Driver createDriver(DriverContext driverContext, FragmentResultCacheManager fragmentResultCacheManager, boolean fragmentResultCachingEnabled, List<Operator> operators)\n     {\n         requireNonNull(driverContext, \"driverContext is null\");\n+        requireNonNull(fragmentResultCacheManager, \"fragmentResultCacheManager is null\");\n         requireNonNull(operators, \"operators is null\");\n-        Driver driver = new Driver(driverContext, operators);\n+        Driver driver = new Driver(driverContext, fragmentResultCacheManager, fragmentResultCachingEnabled, operators);\n         driver.initialize();\n         return driver;\n     }\n \n     @VisibleForTesting\n-    public static Driver createDriver(DriverContext driverContext, Operator firstOperator, Operator... otherOperators)\n+    public static Driver createDriver(DriverContext driverContext, FragmentResultCacheManager fragmentResultCacheManager, boolean fragmentResultCachingEnabled, Operator firstOperator, Operator... otherOperators)", "originalCommit": "e6fd95be91c302c93139d028ce5e29cb8ecafa82", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzIyMTY0OA==", "url": "https://github.com/prestodb/presto/pull/15155#discussion_r487221648", "bodyText": "I thought about it and then felt this would impact how the Driver works so it is more than a context. But since we already have plan in the context, maybe it does not hurt to put these into context as well. I'll take a look.", "author": "shixuan-fan", "createdAt": "2020-09-11T18:37:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzE2NjE5Nw=="}], "type": "inlineReview"}, {"oid": "803fa1b002cc40bcfae25db8592cce492ecfe2cb", "url": "https://github.com/prestodb/presto/commit/803fa1b002cc40bcfae25db8592cce492ecfe2cb", "message": "Support fragment result caching", "committedDate": "2020-09-12T00:47:22Z", "type": "forcePushed"}, {"oid": "85bb0de782aea7272b46d2248e4b825e0f165885", "url": "https://github.com/prestodb/presto/commit/85bb0de782aea7272b46d2248e4b825e0f165885", "message": "Support fragment result caching", "committedDate": "2020-09-13T18:29:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY2NzkyOQ==", "url": "https://github.com/prestodb/presto/pull/15155#discussion_r487667929", "bodyText": "Since this cache is on the driver's side, is there any sanity check in protection from oom? just curious if this cache size can be stored for monitoring so caching on the driver is in a controlled manner.", "author": "fgwang7w", "createdAt": "2020-09-14T05:59:20Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/Driver.java", "diffHunk": "@@ -412,6 +449,12 @@ private OperationTimer createTimer()\n                         throwIfUnchecked(throwable);\n                         throw new RuntimeException(throwable);\n                     }\n+\n+                    if (fragmentResultCachingEnabled) {", "originalCommit": "85bb0de782aea7272b46d2248e4b825e0f165885", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODEyNTE5OA==", "url": "https://github.com/prestodb/presto/pull/15155#discussion_r488125198", "bodyText": "Good point. FragmentResultCacheManager would be a singleton on each Presto worker, and cache instrumentation would be  part of the FragmentResultCacheManager implementation (which is still work-in-progress).\nCurrently the plan is to store the map keys (plan-split pair) in memory and actual result pages in local disk. We should be able to set configuration to limit the cache entries so that we could keep memory usage in check.", "author": "shixuan-fan", "createdAt": "2020-09-14T18:07:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NzY2NzkyOQ=="}], "type": "inlineReview"}, {"oid": "18879b8a88edd6f11150a18d5be9f26d01fd1163", "url": "https://github.com/prestodb/presto/commit/18879b8a88edd6f11150a18d5be9f26d01fd1163", "message": "Support fragment result caching", "committedDate": "2020-09-14T20:18:29Z", "type": "forcePushed"}, {"oid": "a822f821af4cc07456e0d84664799397b0d693ae", "url": "https://github.com/prestodb/presto/commit/a822f821af4cc07456e0d84664799397b0d693ae", "message": "Support fragment result caching", "committedDate": "2020-09-15T16:38:22Z", "type": "forcePushed"}, {"oid": "7c0b178aaccda80c8e77784c09ca663f36fa4164", "url": "https://github.com/prestodb/presto/commit/7c0b178aaccda80c8e77784c09ca663f36fa4164", "message": "Support fragment result caching", "committedDate": "2020-09-15T19:18:38Z", "type": "forcePushed"}, {"oid": "f169fc72f8aa6d3e78735cffc396514d638163be", "url": "https://github.com/prestodb/presto/commit/f169fc72f8aa6d3e78735cffc396514d638163be", "message": "Support fragment result caching", "committedDate": "2020-09-15T21:59:46Z", "type": "forcePushed"}, {"oid": "d2be4dd601033a507b2253f7b965d8547194bae1", "url": "https://github.com/prestodb/presto/commit/d2be4dd601033a507b2253f7b965d8547194bae1", "message": "Support fragment result caching", "committedDate": "2020-09-15T22:03:38Z", "type": "forcePushed"}, {"oid": "2faaa48816e0672dda0dc32a17704ce3d7cac166", "url": "https://github.com/prestodb/presto/commit/2faaa48816e0672dda0dc32a17704ce3d7cac166", "message": "Support fragment result caching", "committedDate": "2020-09-15T23:45:54Z", "type": "forcePushed"}, {"oid": "bb9fb05544ad129cacf3240091bb213a8f3ed5f3", "url": "https://github.com/prestodb/presto/commit/bb9fb05544ad129cacf3240091bb213a8f3ed5f3", "message": "Support fragment result caching", "committedDate": "2020-09-19T00:28:16Z", "type": "forcePushed"}, {"oid": "1ee7806051b458fb0dfa12469d8acbbc5e28519a", "url": "https://github.com/prestodb/presto/commit/1ee7806051b458fb0dfa12469d8acbbc5e28519a", "message": "Support fragment result caching", "committedDate": "2020-09-19T05:50:05Z", "type": "forcePushed"}, {"oid": "001db72b9950d93fddcdcfbaca97dfee738ad6f6", "url": "https://github.com/prestodb/presto/commit/001db72b9950d93fddcdcfbaca97dfee738ad6f6", "message": "Support fragment result caching", "committedDate": "2020-09-19T17:02:20Z", "type": "forcePushed"}, {"oid": "e88f3186f1a934d2ad8abf4b50d8bc1f819097e6", "url": "https://github.com/prestodb/presto/commit/e88f3186f1a934d2ad8abf4b50d8bc1f819097e6", "message": "Support fragment result caching", "committedDate": "2020-09-22T01:18:29Z", "type": "forcePushed"}, {"oid": "3eaad3df45e8bcefeffe9682993a23b34e09dd83", "url": "https://github.com/prestodb/presto/commit/3eaad3df45e8bcefeffe9682993a23b34e09dd83", "message": "Support fragment result caching", "committedDate": "2020-09-22T17:34:40Z", "type": "forcePushed"}, {"oid": "062015e423ab4eecb99e471e38067cfd54607545", "url": "https://github.com/prestodb/presto/commit/062015e423ab4eecb99e471e38067cfd54607545", "message": "Support fragment result caching", "committedDate": "2020-09-22T17:37:27Z", "type": "forcePushed"}, {"oid": "081135681db5acd9829826e3082832a3523794f6", "url": "https://github.com/prestodb/presto/commit/081135681db5acd9829826e3082832a3523794f6", "message": "Support fragment result caching", "committedDate": "2020-09-22T22:18:36Z", "type": "forcePushed"}, {"oid": "38f21ff7081566fa62d38ba83046a680e955407a", "url": "https://github.com/prestodb/presto/commit/38f21ff7081566fa62d38ba83046a680e955407a", "message": "Support fragment result caching", "committedDate": "2020-09-23T01:26:57Z", "type": "forcePushed"}, {"oid": "efa9c3deac9fa58dd7e1780a90585020c22eb2a7", "url": "https://github.com/prestodb/presto/commit/efa9c3deac9fa58dd7e1780a90585020c22eb2a7", "message": "Support fragment result caching", "committedDate": "2020-09-23T05:51:10Z", "type": "forcePushed"}, {"oid": "f97b5698df0542079affe0d4c39f8803d0bdb85b", "url": "https://github.com/prestodb/presto/commit/f97b5698df0542079affe0d4c39f8803d0bdb85b", "message": "Support fragment result caching", "committedDate": "2020-09-23T22:09:50Z", "type": "forcePushed"}, {"oid": "22c01b69fa5123909bcffba7247bdded7345789e", "url": "https://github.com/prestodb/presto/commit/22c01b69fa5123909bcffba7247bdded7345789e", "message": "Support fragment result caching", "committedDate": "2020-09-23T22:13:27Z", "type": "forcePushed"}, {"oid": "a421eb99586f6d7d0296de4129786436659ed344", "url": "https://github.com/prestodb/presto/commit/a421eb99586f6d7d0296de4129786436659ed344", "message": "Support fragment result caching", "committedDate": "2020-09-23T22:31:27Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTUyMzU2OQ==", "url": "https://github.com/prestodb/presto/pull/15155#discussion_r495523569", "bodyText": "Maybe add a comment to explain we don't we need the whole stack of variables", "author": "highker", "createdAt": "2020-09-27T03:43:34Z", "path": "presto-hive/src/main/java/com/facebook/presto/hive/HiveTableLayoutHandle.java", "diffHunk": "@@ -226,4 +226,15 @@ public boolean isPartialAggregationsPushedDown()\n     {\n         return partialAggregationsPushedDown;\n     }\n+\n+    @Override\n+    public Object getIdentifier()\n+    {\n+        return ImmutableMap.builder()", "originalCommit": "a85ad67e9ea3c025e9110bf266263110c199d3e5", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTUyODQ4Mg==", "url": "https://github.com/prestodb/presto/pull/15155#discussion_r495528482", "bodyText": "We have a lot of CanonicalXXX counter part in this commit. Shall we add some tests to make sure the canonical part is in sync with the original class? Meaning that if the original class changes, we should fail some tests or automatically fix the CanonicalXXX", "author": "highker", "createdAt": "2020-09-27T04:50:58Z", "path": "presto-main/src/main/java/com/facebook/presto/sql/planner/CanonicalPartitioningScheme.java", "diffHunk": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.sql.planner;\n+\n+import com.facebook.presto.spi.ConnectorId;\n+import com.facebook.presto.spi.connector.ConnectorPartitioningHandle;\n+import com.facebook.presto.spi.relation.RowExpression;\n+import com.facebook.presto.spi.relation.VariableReferenceExpression;\n+import com.google.common.collect.ImmutableList;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+\n+import static com.facebook.presto.sql.planner.RowExpressionVariableInliner.inlineVariables;\n+import static com.google.common.collect.ImmutableList.toImmutableList;\n+import static java.util.Objects.requireNonNull;\n+\n+public class CanonicalPartitioningScheme", "originalCommit": "a85ad67e9ea3c025e9110bf266263110c199d3e5", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjI5MzQ0NQ==", "url": "https://github.com/prestodb/presto/pull/15155#discussion_r496293445", "bodyText": "Great idea. Let me try to add some tests for this.", "author": "shixuan-fan", "createdAt": "2020-09-28T23:38:57Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTUyODQ4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NzEyODAzMg==", "url": "https://github.com/prestodb/presto/pull/15155#discussion_r497128032", "bodyText": "Added some field assertion tests in TestCanonicalPlanGenerator", "author": "shixuan-fan", "createdAt": "2020-09-29T23:15:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTUyODQ4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTUyODU5OA==", "url": "https://github.com/prestodb/presto/pull/15155#discussion_r495528598", "bodyText": "This collides with the one in presto-cache. Maybe call it FragmentCacheStats or just merge with existing class", "author": "highker", "createdAt": "2020-09-27T04:53:01Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/CacheStats.java", "diffHunk": "@@ -0,0 +1,58 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator;\n+\n+import org.weakref.jmx.Managed;\n+\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+public class CacheStats", "originalCommit": "71e2e413bd9ad233e842f20d5a6d39680cf1954c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMwNjAxMQ==", "url": "https://github.com/prestodb/presto/pull/15155#discussion_r496306011", "bodyText": "I'll rename it to FragmentCacheStats. There are two reasons:\n\nThe fields actually are different, and quotaExceed might not make sense for FragmentCacheStats.\npresto-common and presto-main are independent and I don't want to introduce this dependency, unless we want to move this to spi.", "author": "shixuan-fan", "createdAt": "2020-09-29T00:23:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTUyODU5OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTUyOTA2MA==", "url": "https://github.com/prestodb/presto/pull/15155#discussion_r495529060", "bodyText": "put it into finally incase tryDeleteFile directly throws", "author": "highker", "createdAt": "2020-09-27T05:00:17Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/FileFragmentResultCacheManager.java", "diffHunk": "@@ -0,0 +1,255 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator;\n+\n+import com.facebook.airlift.log.Logger;\n+import com.facebook.presto.common.Page;\n+import com.facebook.presto.common.block.BlockEncodingSerde;\n+import com.facebook.presto.execution.buffer.PagesSerdeFactory;\n+import com.facebook.presto.metadata.Split;\n+import com.facebook.presto.metadata.Split.SplitIdentifier;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.page.PagesSerde;\n+import com.facebook.presto.sql.planner.CanonicalPlanFragment;\n+import com.google.common.cache.Cache;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.RemovalListener;\n+import com.google.common.cache.RemovalNotification;\n+import io.airlift.slice.InputStreamSliceInput;\n+import io.airlift.slice.OutputStreamSliceOutput;\n+import io.airlift.slice.SliceOutput;\n+\n+import javax.inject.Inject;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+import static com.facebook.presto.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static com.facebook.presto.spi.page.PagesSerdeUtil.readPages;\n+import static com.facebook.presto.spi.page.PagesSerdeUtil.writePages;\n+import static com.google.common.util.concurrent.Futures.immediateFuture;\n+import static java.nio.file.Files.newInputStream;\n+import static java.nio.file.Files.newOutputStream;\n+import static java.nio.file.StandardOpenOption.APPEND;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.UUID.randomUUID;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public class FileFragmentResultCacheManager\n+        implements FragmentResultCacheManager\n+{\n+    private static final Logger log = Logger.get(FileFragmentResultCacheManager.class);\n+\n+    private final Path baseDirectory;\n+    private final long maxInFlightBytes;\n+    private final PagesSerde pagesSerde;\n+    private final CacheStats cacheStats;\n+    private final ExecutorService flushExecutor;\n+    private final ExecutorService removalExecutor;\n+\n+    private final Cache<CacheKey, Path> cache;\n+\n+    // TODO: Decouple CacheKey by encoding PlanNode and SplitIdentifier separately so we don't have to keep too many objects in memory\n+    @Inject\n+    public FileFragmentResultCacheManager(\n+            FileFragmentResultCacheConfig cacheConfig,\n+            BlockEncodingSerde blockEncodingSerde,\n+            CacheStats cacheStats,\n+            ExecutorService flushExecutor,\n+            ExecutorService removalExecutor)\n+    {\n+        requireNonNull(cacheConfig, \"cacheConfig is null\");\n+        requireNonNull(blockEncodingSerde, \"blockEncodingSerde is null\");\n+\n+        this.baseDirectory = Paths.get(cacheConfig.getBaseDirectory());\n+        this.maxInFlightBytes = cacheConfig.getMaxInFlightSize().toBytes();\n+        this.pagesSerde = new PagesSerdeFactory(blockEncodingSerde, cacheConfig.isBlockEncodingCompressionEnabled()).createPagesSerde();\n+        this.cacheStats = requireNonNull(cacheStats, \"cacheStats is null\");\n+        this.flushExecutor = requireNonNull(flushExecutor, \"flushExecutor is null\");\n+        this.removalExecutor = requireNonNull(removalExecutor, \"removalExecutor is null\");\n+        this.cache = CacheBuilder.newBuilder()\n+                .maximumSize(cacheConfig.getMaxCachedEntries())\n+                .expireAfterAccess(cacheConfig.getCacheTtl().toMillis(), MILLISECONDS)\n+                .removalListener(new CacheRemovalListener())\n+                .recordStats()\n+                .build();\n+\n+        File target = new File(baseDirectory.toUri());\n+        if (!target.exists()) {\n+            try {\n+                Files.createDirectories(target.toPath());\n+            }\n+            catch (IOException e) {\n+                throw new PrestoException(GENERIC_INTERNAL_ERROR, \"cannot create cache directory \" + target, e);\n+            }\n+        }\n+        else {\n+            File[] files = target.listFiles();\n+            if (files == null) {\n+                return;\n+            }\n+\n+            this.removalExecutor.submit(() -> Arrays.stream(files).forEach(file -> {\n+                try {\n+                    Files.delete(file.toPath());\n+                }\n+                catch (IOException e) {\n+                    // ignore\n+                }\n+            }));\n+        }\n+    }\n+\n+    @Override\n+    public Future<?> put(CanonicalPlanFragment plan, Split split, List<Page> result)\n+    {\n+        CacheKey key = new CacheKey(plan, split.getSplitIdentifier());\n+        long resultSize = getPagesSize(result);\n+        if (cacheStats.getInFlightBytes() + resultSize > maxInFlightBytes || cache.getIfPresent(key) != null) {\n+            return immediateFuture(null);\n+        }\n+\n+        cacheStats.addInFlightBytes(resultSize);\n+        Path path = baseDirectory.resolve(randomUUID().toString().replaceAll(\"-\", \"_\"));\n+        return flushExecutor.submit(() -> cachePages(key, path, result));\n+    }\n+\n+    private static long getPagesSize(List<Page> pages)\n+    {\n+        return pages.stream()\n+                .mapToLong(Page::getSizeInBytes)\n+                .sum();\n+    }\n+\n+    private void cachePages(CacheKey key, Path path, List<Page> pages)\n+    {\n+        // TODO: To support both memory and disk limit, we should check cache size before putting to cache and use written bytes as weight for cache\n+        try {\n+            Files.createFile(path);\n+            try (SliceOutput output = new OutputStreamSliceOutput(newOutputStream(path, APPEND))) {\n+                writePages(pagesSerde, output, pages.iterator());\n+                cache.put(key, path);\n+            }\n+            catch (UncheckedIOException | IOException e) {\n+                log.warn(e, \"%s encountered an error while writing to path %s\", Thread.currentThread().getName(), path);\n+                tryDeleteFile(path);\n+            }\n+        }\n+        catch (UncheckedIOException | IOException e) {\n+            log.warn(e, \"%s encountered an error while writing to path %s\", Thread.currentThread().getName(), path);\n+            tryDeleteFile(path);\n+        }\n+        cacheStats.addInFlightBytes(-getPagesSize(pages));", "originalCommit": "71e2e413bd9ad233e842f20d5a6d39680cf1954c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTUyOTI0OA==", "url": "https://github.com/prestodb/presto/pull/15155#discussion_r495529248", "bodyText": "No AggregationNode?\nSet<Class<? extends PlanNode>>", "author": "highker", "createdAt": "2020-09-27T05:02:48Z", "path": "presto-main/src/main/java/com/facebook/presto/execution/FragmentResultCacheContext.java", "diffHunk": "@@ -0,0 +1,88 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.execution;\n+\n+import com.facebook.presto.Session;\n+import com.facebook.presto.SystemSessionProperties;\n+import com.facebook.presto.operator.FragmentResultCacheManager;\n+import com.facebook.presto.spi.plan.AggregationNode;\n+import com.facebook.presto.spi.plan.FilterNode;\n+import com.facebook.presto.spi.plan.PlanNode;\n+import com.facebook.presto.spi.plan.ProjectNode;\n+import com.facebook.presto.spi.plan.TableScanNode;\n+import com.facebook.presto.sql.planner.CanonicalPlanFragment;\n+import com.facebook.presto.sql.planner.PartitioningScheme;\n+import com.facebook.presto.sql.planner.plan.GroupIdNode;\n+import com.google.common.collect.ImmutableSet;\n+\n+import java.util.Optional;\n+import java.util.Set;\n+\n+import static com.facebook.presto.spi.plan.AggregationNode.Step.PARTIAL;\n+import static com.facebook.presto.sql.planner.CanonicalPlanGenerator.generateCanonicalPlan;\n+import static java.util.Objects.requireNonNull;\n+\n+public class FragmentResultCacheContext\n+{\n+    private static final Set<Class> ALLOWED_NODES = ImmutableSet.of(TableScanNode.class, FilterNode.class, ProjectNode.class, GroupIdNode.class);", "originalCommit": "a421eb99586f6d7d0296de4129786436659ed344", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NjMxMDA0OA==", "url": "https://github.com/prestodb/presto/pull/15155#discussion_r496310048", "bodyText": "No AggregationNode?\n\nAggregationNode is a bit different and right now we require it to be the root in isEligibleForFragmentResultCaching. ALLOWED_NODES here is for the children of AggregationNode. I'll rename this constant to ALLOWED_CHILDREN_NODES\n\nSet<Class<? extends PlanNode>>\n\nGood point :)", "author": "shixuan-fan", "createdAt": "2020-09-29T00:39:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5NTUyOTI0OA=="}], "type": "inlineReview"}, {"oid": "9583de36693b07f02abaa8a685897de2ee6d386a", "url": "https://github.com/prestodb/presto/commit/9583de36693b07f02abaa8a685897de2ee6d386a", "message": "Support fragment result caching", "committedDate": "2020-09-29T00:44:54Z", "type": "forcePushed"}, {"oid": "3e1b7b1ed192c8673c2c9e00bb1a004920c67bc3", "url": "https://github.com/prestodb/presto/commit/3e1b7b1ed192c8673c2c9e00bb1a004920c67bc3", "message": "Support fragment result caching", "committedDate": "2020-09-29T23:14:16Z", "type": "forcePushed"}, {"oid": "ef934e38d95ad7222505ef98e6e0b1d1f9a79b80", "url": "https://github.com/prestodb/presto/commit/ef934e38d95ad7222505ef98e6e0b1d1f9a79b80", "message": "Support fragment result caching", "committedDate": "2020-09-29T23:16:26Z", "type": "forcePushed"}, {"oid": "f9fdb934292f7928c660ed66fe444db5743651c6", "url": "https://github.com/prestodb/presto/commit/f9fdb934292f7928c660ed66fe444db5743651c6", "message": "Support fragment result caching", "committedDate": "2020-09-29T23:34:26Z", "type": "forcePushed"}, {"oid": "dcbc0dd39bacafbecd371bb1bfecb50714a9f0d0", "url": "https://github.com/prestodb/presto/commit/dcbc0dd39bacafbecd371bb1bfecb50714a9f0d0", "message": "Support fragment result caching", "committedDate": "2020-09-29T23:56:09Z", "type": "forcePushed"}, {"oid": "cb9c8b7c2218a00a6b051af58ea6e87122e233eb", "url": "https://github.com/prestodb/presto/commit/cb9c8b7c2218a00a6b051af58ea6e87122e233eb", "message": "Support fragment result caching", "committedDate": "2020-10-01T03:53:59Z", "type": "forcePushed"}, {"oid": "353aea4527dfe5684e746d9b1cb0620b6da19e28", "url": "https://github.com/prestodb/presto/commit/353aea4527dfe5684e746d9b1cb0620b6da19e28", "message": "Support fragment result caching", "committedDate": "2020-10-01T04:34:41Z", "type": "forcePushed"}, {"oid": "3d9b1e4de425bb2db252628830e560817702b63e", "url": "https://github.com/prestodb/presto/commit/3d9b1e4de425bb2db252628830e560817702b63e", "message": "Support fragment result caching", "committedDate": "2020-10-01T04:36:55Z", "type": "forcePushed"}, {"oid": "57ceea465eb574f3c9307619a6c544dfb63b3268", "url": "https://github.com/prestodb/presto/commit/57ceea465eb574f3c9307619a6c544dfb63b3268", "message": "Introduce CanonicalPlanGenerator", "committedDate": "2020-10-01T05:43:39Z", "type": "commit"}, {"oid": "a3cb64593058bf432b9dfab5c522caf75111f0a6", "url": "https://github.com/prestodb/presto/commit/a3cb64593058bf432b9dfab5c522caf75111f0a6", "message": "Introduce split identifier", "committedDate": "2020-10-01T05:43:42Z", "type": "commit"}, {"oid": "3ef8f7c8051b573271723e640a910e1e35bb6e58", "url": "https://github.com/prestodb/presto/commit/3ef8f7c8051b573271723e640a910e1e35bb6e58", "message": "Support fragment result caching", "committedDate": "2020-10-01T05:43:42Z", "type": "forcePushed"}, {"oid": "3f1ef09c90ee10f6ae23cb1f0a238d887fa8e328", "url": "https://github.com/prestodb/presto/commit/3f1ef09c90ee10f6ae23cb1f0a238d887fa8e328", "message": "Introduce fragment result cache manager", "committedDate": "2020-10-01T07:07:04Z", "type": "commit"}, {"oid": "5e776d9a5ff5227c3f28991418d70c04cd153129", "url": "https://github.com/prestodb/presto/commit/5e776d9a5ff5227c3f28991418d70c04cd153129", "message": "Use static import and lambda in TestDriver", "committedDate": "2020-10-01T07:07:08Z", "type": "commit"}, {"oid": "9d96609bdaf783e8b904da8112bd75d109f0f68e", "url": "https://github.com/prestodb/presto/commit/9d96609bdaf783e8b904da8112bd75d109f0f68e", "message": "Support fragment result caching", "committedDate": "2020-10-01T07:07:08Z", "type": "commit"}, {"oid": "9d96609bdaf783e8b904da8112bd75d109f0f68e", "url": "https://github.com/prestodb/presto/commit/9d96609bdaf783e8b904da8112bd75d109f0f68e", "message": "Support fragment result caching", "committedDate": "2020-10-01T07:07:08Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxODUzMjcxMA==", "url": "https://github.com/prestodb/presto/pull/15155#discussion_r518532710", "bodyText": "this part of code looks so similar to FileSingleStreamSpiller lol.", "author": "wenleix", "createdAt": "2020-11-06T05:34:55Z", "path": "presto-main/src/main/java/com/facebook/presto/operator/FileFragmentResultCacheManager.java", "diffHunk": "@@ -0,0 +1,283 @@\n+/*\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.facebook.presto.operator;\n+\n+import com.facebook.airlift.log.Logger;\n+import com.facebook.presto.common.Page;\n+import com.facebook.presto.common.block.BlockEncodingSerde;\n+import com.facebook.presto.execution.buffer.PagesSerdeFactory;\n+import com.facebook.presto.metadata.Split;\n+import com.facebook.presto.metadata.Split.SplitIdentifier;\n+import com.facebook.presto.spi.PrestoException;\n+import com.facebook.presto.spi.page.PagesSerde;\n+import com.facebook.presto.sql.planner.CanonicalPlanFragment;\n+import com.google.common.cache.Cache;\n+import com.google.common.cache.CacheBuilder;\n+import com.google.common.cache.RemovalListener;\n+import com.google.common.cache.RemovalNotification;\n+import com.google.common.collect.AbstractIterator;\n+import io.airlift.slice.InputStreamSliceInput;\n+import io.airlift.slice.OutputStreamSliceOutput;\n+import io.airlift.slice.SliceOutput;\n+\n+import javax.inject.Inject;\n+\n+import java.io.Closeable;\n+import java.io.File;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.UncheckedIOException;\n+import java.nio.file.Files;\n+import java.nio.file.Path;\n+import java.nio.file.Paths;\n+import java.util.Arrays;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Future;\n+\n+import static com.facebook.presto.spi.StandardErrorCode.GENERIC_INTERNAL_ERROR;\n+import static com.facebook.presto.spi.page.PagesSerdeUtil.readPages;\n+import static com.facebook.presto.spi.page.PagesSerdeUtil.writePages;\n+import static com.google.common.util.concurrent.Futures.immediateFuture;\n+import static java.nio.file.Files.newInputStream;\n+import static java.nio.file.Files.newOutputStream;\n+import static java.nio.file.StandardOpenOption.APPEND;\n+import static java.util.Objects.requireNonNull;\n+import static java.util.UUID.randomUUID;\n+import static java.util.concurrent.TimeUnit.MILLISECONDS;\n+\n+public class FileFragmentResultCacheManager\n+        implements FragmentResultCacheManager\n+{\n+    private static final Logger log = Logger.get(FileFragmentResultCacheManager.class);\n+\n+    private final Path baseDirectory;\n+    private final long maxInFlightBytes;\n+    private final PagesSerde pagesSerde;\n+    private final FragmentCacheStats fragmentCacheStats;\n+    private final ExecutorService flushExecutor;\n+    private final ExecutorService removalExecutor;\n+\n+    private final Cache<CacheKey, Path> cache;\n+\n+    // TODO: Decouple CacheKey by encoding PlanNode and SplitIdentifier separately so we don't have to keep too many objects in memory\n+    @Inject\n+    public FileFragmentResultCacheManager(\n+            FileFragmentResultCacheConfig cacheConfig,\n+            BlockEncodingSerde blockEncodingSerde,\n+            FragmentCacheStats fragmentCacheStats,\n+            ExecutorService flushExecutor,\n+            ExecutorService removalExecutor)\n+    {\n+        requireNonNull(cacheConfig, \"cacheConfig is null\");\n+        requireNonNull(blockEncodingSerde, \"blockEncodingSerde is null\");\n+\n+        this.baseDirectory = Paths.get(cacheConfig.getBaseDirectory());\n+        this.maxInFlightBytes = cacheConfig.getMaxInFlightSize().toBytes();\n+        this.pagesSerde = new PagesSerdeFactory(blockEncodingSerde, cacheConfig.isBlockEncodingCompressionEnabled()).createPagesSerde();\n+        this.fragmentCacheStats = requireNonNull(fragmentCacheStats, \"fragmentCacheStats is null\");\n+        this.flushExecutor = requireNonNull(flushExecutor, \"flushExecutor is null\");\n+        this.removalExecutor = requireNonNull(removalExecutor, \"removalExecutor is null\");\n+        this.cache = CacheBuilder.newBuilder()\n+                .maximumSize(cacheConfig.getMaxCachedEntries())\n+                .expireAfterAccess(cacheConfig.getCacheTtl().toMillis(), MILLISECONDS)\n+                .removalListener(new CacheRemovalListener())\n+                .recordStats()\n+                .build();\n+\n+        File target = new File(baseDirectory.toUri());\n+        if (!target.exists()) {\n+            try {\n+                Files.createDirectories(target.toPath());\n+            }\n+            catch (IOException e) {\n+                throw new PrestoException(GENERIC_INTERNAL_ERROR, \"cannot create cache directory \" + target, e);\n+            }\n+        }\n+        else {\n+            File[] files = target.listFiles();\n+            if (files == null) {\n+                return;\n+            }\n+\n+            this.removalExecutor.submit(() -> Arrays.stream(files).forEach(file -> {\n+                try {\n+                    Files.delete(file.toPath());\n+                }\n+                catch (IOException e) {\n+                    // ignore\n+                }\n+            }));\n+        }\n+    }\n+\n+    @Override\n+    public Future<?> put(CanonicalPlanFragment plan, Split split, List<Page> result)\n+    {\n+        CacheKey key = new CacheKey(plan, split.getSplitIdentifier());\n+        long resultSize = getPagesSize(result);\n+        if (fragmentCacheStats.getInFlightBytes() + resultSize > maxInFlightBytes || cache.getIfPresent(key) != null) {\n+            return immediateFuture(null);\n+        }\n+\n+        fragmentCacheStats.addInFlightBytes(resultSize);\n+        Path path = baseDirectory.resolve(randomUUID().toString().replaceAll(\"-\", \"_\"));\n+        return flushExecutor.submit(() -> cachePages(key, path, result));\n+    }\n+\n+    private static long getPagesSize(List<Page> pages)\n+    {\n+        return pages.stream()\n+                .mapToLong(Page::getSizeInBytes)\n+                .sum();\n+    }\n+\n+    private void cachePages(CacheKey key, Path path, List<Page> pages)\n+    {\n+        // TODO: To support both memory and disk limit, we should check cache size before putting to cache and use written bytes as weight for cache\n+        try {\n+            Files.createFile(path);\n+            try (SliceOutput output = new OutputStreamSliceOutput(newOutputStream(path, APPEND))) {\n+                writePages(pagesSerde, output, pages.iterator());\n+                cache.put(key, path);\n+            }\n+            catch (UncheckedIOException | IOException e) {\n+                log.warn(e, \"%s encountered an error while writing to path %s\", Thread.currentThread().getName(), path);\n+                tryDeleteFile(path);\n+            }\n+        }\n+        catch (UncheckedIOException | IOException e) {\n+            log.warn(e, \"%s encountered an error while writing to path %s\", Thread.currentThread().getName(), path);\n+            tryDeleteFile(path);\n+        }\n+        finally {\n+            fragmentCacheStats.addInFlightBytes(-getPagesSize(pages));\n+        }\n+    }\n+\n+    private static void tryDeleteFile(Path path)\n+    {\n+        try {\n+            File file = new File(path.toUri());\n+            if (file.exists()) {\n+                Files.delete(file.toPath());\n+            }\n+        }\n+        catch (IOException e) {\n+            // ignore\n+        }\n+    }\n+\n+    @Override\n+    public Optional<Iterator<Page>> get(CanonicalPlanFragment plan, Split split)\n+    {\n+        CacheKey key = new CacheKey(plan, split.getSplitIdentifier());\n+        Path path = cache.getIfPresent(key);\n+        if (path == null) {\n+            fragmentCacheStats.incrementCacheMiss();\n+            return Optional.empty();\n+        }\n+\n+        try {\n+            InputStream inputStream = newInputStream(path);\n+            Iterator<Page> result = readPages(pagesSerde, new InputStreamSliceInput(inputStream));\n+            fragmentCacheStats.incrementCacheHit();\n+            return Optional.of(closeWhenExhausted(result, inputStream));\n+        }\n+        catch (UncheckedIOException | IOException e) {\n+            // there might be a chance the file has been deleted. We would return cache miss in this case.\n+            fragmentCacheStats.incrementCacheMiss();\n+            return Optional.empty();\n+        }\n+    }\n+\n+    private static <T> Iterator<T> closeWhenExhausted(Iterator<T> iterator, Closeable resource)", "originalCommit": "3f1ef09c90ee10f6ae23cb1f0a238d887fa8e328", "replyToReviewId": null, "replies": null, "type": "inlineReview"}]}