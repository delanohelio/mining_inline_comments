{"pr_number": 5765, "pr_title": "[2.19.x] DDF-5716 G-7628 Add support for specifying UTM coords with the hemisphere notation in the gazetteer", "pr_createdAt": "2020-01-13T23:24:34Z", "pr_url": "https://github.com/codice/ddf/pull/5765", "timeline": [{"oid": "89ef1ffb19a289b2691e6283c21e5bfc20edd5bd", "url": "https://github.com/codice/ddf/commit/89ef1ffb19a289b2691e6283c21e5bfc20edd5bd", "message": "DDF-5716 G-7628 Add support for specifying UTM coords with the hemisphere notation in the gazetteer  (#5718)\n\n* DDF-5716 Added hemisphere support\r\n\r\nDDF-0000 Added multiple suggestions for single UTM/UPS coord\r\n\r\nDDF-0000 Add support for hemisphere suggestions\r\n\r\n* DDF-5716 Clean up unit tests\r\n\r\n* DDF-5716 Remove comment\r\n\r\n* DDF-5716 Split up \"UTM/UPS\" prefix, make hemisphere suggestion more explicit\r\n\r\n* DDF-5716 Only show UTM/UPS prefix if both UTM and UPS points are entered\r\n\r\n* DDF-5716 Removed left over TODO\r\n\r\n* DDF-5716 Removed Nullable annotation\r\n\r\n* DDF-5716 Fixed javadoc", "committedDate": "2020-01-13T23:21:07Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY1MzQ0OQ==", "url": "https://github.com/codice/ddf/pull/5765#discussion_r366653449", "bodyText": "\u2757\ufe0f This is not going to accomplish exactly what you want. The isUTM and isUPS functions tell you if the coordinate \"data\" exists in the \"space\", not what the text format is. On top of that, there is overlap, so both functions could return true. They are not mutually exclusive.\nSee my comments on my review of the PR against master: #5718 (review)", "author": "Lambeaux", "createdAt": "2020-01-15T01:10:42Z", "path": "catalog/ui/catalog-ui-search/src/main/java/org/codice/ddf/catalog/ui/query/suggestion/UtmUpsCoordinateProcessor.java", "diffHunk": "@@ -76,42 +79,178 @@ public UtmUpsCoordinateProcessor(CoordinateSystemTranslator translator) {\n    */\n   public void enhanceResults(final List<Suggestion> results, final String query) {\n     LOGGER.trace(\"(UTM/UPS) Adding result for query [{}]\", query);\n-    final LiteralSuggestion literal = getUtmUpsSuggestion(query);\n-    if (literal != null && literal.hasGeo()) {\n-      LOGGER.trace(\"Adding the UTM/UPS suggestion to results [{}]\", literal);\n-      results.add(0, literal);\n-    }\n+    final List<LiteralSuggestion> literals = getUtmUpsSuggestions(query);\n+    literals\n+        .stream()\n+        .filter(Objects::nonNull)\n+        .filter(LiteralSuggestion::hasGeo)\n+        .forEach(\n+            literal -> {\n+              LOGGER.trace(\"Adding the UTM/UPS suggestion to results [{}]\", literal);\n+              results.add(0, literal);\n+            });\n     LOGGER.trace(\"(UTM/UPS) Done\");\n   }\n \n-  @Nullable\n-  private LiteralSuggestion getUtmUpsSuggestion(final String query) {\n+  private List<LiteralSuggestion> getUtmUpsSuggestions(final String query) {\n     final Matcher matcher = PATTERN_UTM_OR_UPS_COORDINATE.matcher(query);\n-    final StringBuilder nameBuilder = new StringBuilder(\"UTM/UPS:\");\n-    final List<UtmUpsCoordinate> utmUpsCoords = new ArrayList<>();\n+    final List<String> utmUpsMatches = new ArrayList<>();\n     while (matcher.find()) {\n       final String group = matcher.group();\n       LOGGER.trace(\"Match found [{}]\", group);\n-      final String utmOrUpsText = normalizeCoordinate(group);\n-      final UtmUpsCoordinate utmUps = parseUtmUpsString(utmOrUpsText);\n-      if (utmUps != null) {\n-        nameBuilder.append(\" [ \").append(utmUps.toString()).append(\" ]\");\n-        utmUpsCoords.add(utmUps);\n-      }\n+      utmUpsMatches.add(capitalizeLatBand(group));\n     }\n-    if (utmUpsCoords.isEmpty()) {\n+\n+    if (utmUpsMatches.isEmpty()) {\n       LOGGER.trace(\"No valid UTM or UPS strings could be inferred from query [{}]\", query);\n-      return null;\n+      return Collections.emptyList();\n+    }\n+\n+    return utmUpsMatches.size() == 1\n+        ? suggestionsForSinglePoint(utmUpsMatches.get(0))\n+        : Collections.singletonList(suggestionForMultiplePoints(utmUpsMatches));\n+  }\n+\n+  /**\n+   * Generates a list of {@link LiteralSuggestion}s based on the given {@code utmUpsCoord} string.\n+   * This method is only used to generate suggestions when the user enters a single UTM/UPS\n+   * coordinate. The following suggestions are returned depending on the information provided in the\n+   * coordinate:\n+   *\n+   * <ul>\n+   *   <li>If the {@code utmUpsCoord} does not have a latitude band, then two suggestions are\n+   *       returned - one for each hemisphere - and the hemisphere is denoted by a \"N\" or \"S\"\n+   *       suffix. Example: \"18 631054mE 4776851mN\" -> \"UTM/UPS: [ 18N 631054mE 4776851mN N ]\",\n+   *       \"UTM/UPS: [ 18S 631054mE 4776851mN S ]\"\n+   *   <li>If the {@code utmpUpsCoord} has an S latitude band, then two suggestions are also\n+   *       returned: one for the S latitude band coordinate and another for the Southern hemisphere\n+   *       coordinate. This is because the \"S\" is ambiguous - it can either refer to the latitude\n+   *       band or the Southern hemisphere. Example: \"15S 533427mE 3796272mN\" -> \"UTM/UPS: [ 15S\n+   *       533427mE 3796272mN ]\", \"UTM/UPS: [ 15S 533427mE 3796272mN S ]\"\n+   *   <li>If the {@code utmUpsCoord} has an N latitude band, then two suggestions are returned: one\n+   *       for the N latitude band and another for the Northern hemisphere. The \"N\" isn't ambiguous\n+   *       in this case, but the Northern hemisphere suggestion is included for consistency and to\n+   *       teach users about the N/S hemisphere syntax. Example: \"9N 365103mE 659568mN\" -> \"UTM/UPS:\n+   *       [ 9N 365103mE 659568mN ]\", \"UTM/UPS: [ 9N 365103mE 659568mN N ]\"\n+   *   <li>Otherwise, one suggestion is returned. Example: \"20M 48831mE09437282mN\" -> \"UTM/UPS: [\n+   *       20M 48831mE09437282mN ]\"\n+   * </ul>\n+   *\n+   * @param utmUpsCoord the user-provided gazetteer query text. It must match the {@code\n+   *     PATTERN_UTM_OR_UPS_COORDINATE} pattern.\n+   * @return a list of either one or two {@link LiteralSuggestion}s, depending on the latitude band\n+   *     of {@code utmUpsCoord}\n+   */\n+  private List<LiteralSuggestion> suggestionsForSinglePoint(String utmUpsCoord) {\n+    final Character latBand = getLatBand(utmUpsCoord);\n+    if (latBand == null) {\n+      // A coordinate without an NS indicator and a lat band is invalid so show two suggestions,\n+      // one for the northern hemisphere and another for the southern hemisphere.\n+      return Stream.of(parseUtmUpsString(utmUpsCoord + \" S\"), parseUtmUpsString(utmUpsCoord + \" N\"))\n+          .filter(Objects::nonNull)\n+          .map(this::suggestion)\n+          .collect(toList());\n+    } else if (latBand.equals('N')) {\n+      // If the coordinate has a N lat band, include the northern hemisphere suggestion for\n+      // convenience\n+      return Stream.of(\n+              parseUtmUpsString(removeLatBand(utmUpsCoord) + \" N\"), parseUtmUpsString(utmUpsCoord))\n+          .filter(Objects::nonNull)\n+          .map(this::suggestion)\n+          .collect(toList());\n+    } else if (latBand.equals('S')) {\n+      // Similarly, if the coordinate has an S lat band, include the southern hemisphere\n+      // suggestion for convenience\n+      return Stream.of(\n+              parseUtmUpsString(removeLatBand(utmUpsCoord) + \" S\"), parseUtmUpsString(utmUpsCoord))\n+          .filter(Objects::nonNull)\n+          .map(this::suggestion)\n+          .collect(toList());\n+    } else {\n+      return Stream.of(parseUtmUpsString(utmUpsCoord))\n+          .filter(Objects::nonNull)\n+          .map(this::suggestion)\n+          .collect(toList());\n     }\n+  }\n+\n+  private LiteralSuggestion suggestion(UtmUpsCoordinate utmUps) {\n     return new LiteralSuggestion(\n         LITERAL_SUGGESTION_ID,\n-        nameBuilder.toString(),\n+        makeSuggestionText(utmUps),\n+        Collections.singletonList(latLonFromUtmUtps(utmUps)));\n+  }\n+\n+  /**\n+   * Generates one {@link LiteralSuggestion} by combining the latitude/longitude values of each\n+   * UTM/UPS coordinate in the {@code utmUpsCoords} list. This method is used to generate a\n+   * suggestion when the user enters multiple UTM/UPS coordinates. No additional suggestions are\n+   * made for each point for simplicity since the map will pan to the extent or bounding box of all\n+   * the points. As a result, the N/S characters of each coordinate are always treated as latitude\n+   * bands and a coordinate is considered invalid if a latitude band is not included. Example: \"12S\n+   * 241451mE 4101052mN 13R 37090mE 63394439mN\" -> \"UTM/UPS: [ 12S 241451mE 4101052mN ] [ 13R\n+   * 37090mE 63394439mN ]\"\n+   *\n+   * @param utmUpsCoords a list of strings matching the {@code PATTERN_UTM_OR_UPS_COORDINATE}\n+   *     pattern, created from the user-provided gazetteer query text.\n+   * @return a singleton list with one {@link LiteralSuggestion} with the combined list of\n+   *     latitude/longitude values.\n+   */\n+  private LiteralSuggestion suggestionForMultiplePoints(final List<String> utmUpsCoords) {\n+    List<UtmUpsCoordinate> utmUpsList =\n         utmUpsCoords\n             .stream()\n-            .map(this::toLatLon)\n+            .map(this::parseUtmUpsString)\n             .filter(Objects::nonNull)\n-            .map(d -> new LatLon(d.getLat(), d.getLon()))\n-            .collect(Collectors.toList()));\n+            .collect(toList());\n+    List<LatLon> latLonList =\n+        utmUpsList.stream().map(this::latLonFromUtmUtps).filter(Objects::nonNull).collect(toList());\n+    String suggestionText = makeSuggestionText(utmUpsList);\n+\n+    return new LiteralSuggestion(LITERAL_SUGGESTION_ID, suggestionText, latLonList);\n+  }\n+\n+  private static String makeSuggestionText(UtmUpsCoordinate utmUps) {\n+    final StringBuilder nameBuilder = new StringBuilder();\n+    if (utmUps.isUTM()) {\n+      nameBuilder.append(\"UTM: [ \").append(utmUps.toString()).append(\" ]\");\n+      if (utmUps.getLatitudeBand() == null) {\n+        if (utmUps.getNSIndicator() == NSIndicator.SOUTH) {\n+          nameBuilder.append(\" (Southern)\");\n+        } else {\n+          nameBuilder.append(\" (Northern)\");\n+        }\n+      }\n+    } else {\n+      nameBuilder.append(\"UPS: [ \").append(utmUps.toString()).append(\" ]\");\n+    }\n+    return nameBuilder.toString();\n+  }\n+\n+  private static String makeSuggestionText(List<UtmUpsCoordinate> utmUpsList) {\n+    final StringBuilder nameBuilder = new StringBuilder();\n+    long numberOfUtmCoords = utmUpsList.stream().filter(UtmUpsCoordinate::isUTM).count();\n+    int total = utmUpsList.size();\n+    if (numberOfUtmCoords == total) {", "originalCommit": "89ef1ffb19a289b2691e6283c21e5bfc20edd5bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEzMDQzMQ==", "url": "https://github.com/codice/ddf/pull/5765#discussion_r367130431", "bodyText": "\u2705 After further analysis we could not reproduce the problem. Turns out the semantics of UtmUpsCoordinate are different from the other coordinate impls. This is fine.", "author": "Lambeaux", "createdAt": "2020-01-15T22:01:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY1MzQ0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY1MzU3Mg==", "url": "https://github.com/codice/ddf/pull/5765#discussion_r366653572", "bodyText": "\u2757\ufe0f Same here. This isn't exactly what you want.", "author": "Lambeaux", "createdAt": "2020-01-15T01:11:17Z", "path": "catalog/ui/catalog-ui-search/src/main/java/org/codice/ddf/catalog/ui/query/suggestion/UtmUpsCoordinateProcessor.java", "diffHunk": "@@ -76,42 +79,178 @@ public UtmUpsCoordinateProcessor(CoordinateSystemTranslator translator) {\n    */\n   public void enhanceResults(final List<Suggestion> results, final String query) {\n     LOGGER.trace(\"(UTM/UPS) Adding result for query [{}]\", query);\n-    final LiteralSuggestion literal = getUtmUpsSuggestion(query);\n-    if (literal != null && literal.hasGeo()) {\n-      LOGGER.trace(\"Adding the UTM/UPS suggestion to results [{}]\", literal);\n-      results.add(0, literal);\n-    }\n+    final List<LiteralSuggestion> literals = getUtmUpsSuggestions(query);\n+    literals\n+        .stream()\n+        .filter(Objects::nonNull)\n+        .filter(LiteralSuggestion::hasGeo)\n+        .forEach(\n+            literal -> {\n+              LOGGER.trace(\"Adding the UTM/UPS suggestion to results [{}]\", literal);\n+              results.add(0, literal);\n+            });\n     LOGGER.trace(\"(UTM/UPS) Done\");\n   }\n \n-  @Nullable\n-  private LiteralSuggestion getUtmUpsSuggestion(final String query) {\n+  private List<LiteralSuggestion> getUtmUpsSuggestions(final String query) {\n     final Matcher matcher = PATTERN_UTM_OR_UPS_COORDINATE.matcher(query);\n-    final StringBuilder nameBuilder = new StringBuilder(\"UTM/UPS:\");\n-    final List<UtmUpsCoordinate> utmUpsCoords = new ArrayList<>();\n+    final List<String> utmUpsMatches = new ArrayList<>();\n     while (matcher.find()) {\n       final String group = matcher.group();\n       LOGGER.trace(\"Match found [{}]\", group);\n-      final String utmOrUpsText = normalizeCoordinate(group);\n-      final UtmUpsCoordinate utmUps = parseUtmUpsString(utmOrUpsText);\n-      if (utmUps != null) {\n-        nameBuilder.append(\" [ \").append(utmUps.toString()).append(\" ]\");\n-        utmUpsCoords.add(utmUps);\n-      }\n+      utmUpsMatches.add(capitalizeLatBand(group));\n     }\n-    if (utmUpsCoords.isEmpty()) {\n+\n+    if (utmUpsMatches.isEmpty()) {\n       LOGGER.trace(\"No valid UTM or UPS strings could be inferred from query [{}]\", query);\n-      return null;\n+      return Collections.emptyList();\n+    }\n+\n+    return utmUpsMatches.size() == 1\n+        ? suggestionsForSinglePoint(utmUpsMatches.get(0))\n+        : Collections.singletonList(suggestionForMultiplePoints(utmUpsMatches));\n+  }\n+\n+  /**\n+   * Generates a list of {@link LiteralSuggestion}s based on the given {@code utmUpsCoord} string.\n+   * This method is only used to generate suggestions when the user enters a single UTM/UPS\n+   * coordinate. The following suggestions are returned depending on the information provided in the\n+   * coordinate:\n+   *\n+   * <ul>\n+   *   <li>If the {@code utmUpsCoord} does not have a latitude band, then two suggestions are\n+   *       returned - one for each hemisphere - and the hemisphere is denoted by a \"N\" or \"S\"\n+   *       suffix. Example: \"18 631054mE 4776851mN\" -> \"UTM/UPS: [ 18N 631054mE 4776851mN N ]\",\n+   *       \"UTM/UPS: [ 18S 631054mE 4776851mN S ]\"\n+   *   <li>If the {@code utmpUpsCoord} has an S latitude band, then two suggestions are also\n+   *       returned: one for the S latitude band coordinate and another for the Southern hemisphere\n+   *       coordinate. This is because the \"S\" is ambiguous - it can either refer to the latitude\n+   *       band or the Southern hemisphere. Example: \"15S 533427mE 3796272mN\" -> \"UTM/UPS: [ 15S\n+   *       533427mE 3796272mN ]\", \"UTM/UPS: [ 15S 533427mE 3796272mN S ]\"\n+   *   <li>If the {@code utmUpsCoord} has an N latitude band, then two suggestions are returned: one\n+   *       for the N latitude band and another for the Northern hemisphere. The \"N\" isn't ambiguous\n+   *       in this case, but the Northern hemisphere suggestion is included for consistency and to\n+   *       teach users about the N/S hemisphere syntax. Example: \"9N 365103mE 659568mN\" -> \"UTM/UPS:\n+   *       [ 9N 365103mE 659568mN ]\", \"UTM/UPS: [ 9N 365103mE 659568mN N ]\"\n+   *   <li>Otherwise, one suggestion is returned. Example: \"20M 48831mE09437282mN\" -> \"UTM/UPS: [\n+   *       20M 48831mE09437282mN ]\"\n+   * </ul>\n+   *\n+   * @param utmUpsCoord the user-provided gazetteer query text. It must match the {@code\n+   *     PATTERN_UTM_OR_UPS_COORDINATE} pattern.\n+   * @return a list of either one or two {@link LiteralSuggestion}s, depending on the latitude band\n+   *     of {@code utmUpsCoord}\n+   */\n+  private List<LiteralSuggestion> suggestionsForSinglePoint(String utmUpsCoord) {\n+    final Character latBand = getLatBand(utmUpsCoord);\n+    if (latBand == null) {\n+      // A coordinate without an NS indicator and a lat band is invalid so show two suggestions,\n+      // one for the northern hemisphere and another for the southern hemisphere.\n+      return Stream.of(parseUtmUpsString(utmUpsCoord + \" S\"), parseUtmUpsString(utmUpsCoord + \" N\"))\n+          .filter(Objects::nonNull)\n+          .map(this::suggestion)\n+          .collect(toList());\n+    } else if (latBand.equals('N')) {\n+      // If the coordinate has a N lat band, include the northern hemisphere suggestion for\n+      // convenience\n+      return Stream.of(\n+              parseUtmUpsString(removeLatBand(utmUpsCoord) + \" N\"), parseUtmUpsString(utmUpsCoord))\n+          .filter(Objects::nonNull)\n+          .map(this::suggestion)\n+          .collect(toList());\n+    } else if (latBand.equals('S')) {\n+      // Similarly, if the coordinate has an S lat band, include the southern hemisphere\n+      // suggestion for convenience\n+      return Stream.of(\n+              parseUtmUpsString(removeLatBand(utmUpsCoord) + \" S\"), parseUtmUpsString(utmUpsCoord))\n+          .filter(Objects::nonNull)\n+          .map(this::suggestion)\n+          .collect(toList());\n+    } else {\n+      return Stream.of(parseUtmUpsString(utmUpsCoord))\n+          .filter(Objects::nonNull)\n+          .map(this::suggestion)\n+          .collect(toList());\n     }\n+  }\n+\n+  private LiteralSuggestion suggestion(UtmUpsCoordinate utmUps) {\n     return new LiteralSuggestion(\n         LITERAL_SUGGESTION_ID,\n-        nameBuilder.toString(),\n+        makeSuggestionText(utmUps),\n+        Collections.singletonList(latLonFromUtmUtps(utmUps)));\n+  }\n+\n+  /**\n+   * Generates one {@link LiteralSuggestion} by combining the latitude/longitude values of each\n+   * UTM/UPS coordinate in the {@code utmUpsCoords} list. This method is used to generate a\n+   * suggestion when the user enters multiple UTM/UPS coordinates. No additional suggestions are\n+   * made for each point for simplicity since the map will pan to the extent or bounding box of all\n+   * the points. As a result, the N/S characters of each coordinate are always treated as latitude\n+   * bands and a coordinate is considered invalid if a latitude band is not included. Example: \"12S\n+   * 241451mE 4101052mN 13R 37090mE 63394439mN\" -> \"UTM/UPS: [ 12S 241451mE 4101052mN ] [ 13R\n+   * 37090mE 63394439mN ]\"\n+   *\n+   * @param utmUpsCoords a list of strings matching the {@code PATTERN_UTM_OR_UPS_COORDINATE}\n+   *     pattern, created from the user-provided gazetteer query text.\n+   * @return a singleton list with one {@link LiteralSuggestion} with the combined list of\n+   *     latitude/longitude values.\n+   */\n+  private LiteralSuggestion suggestionForMultiplePoints(final List<String> utmUpsCoords) {\n+    List<UtmUpsCoordinate> utmUpsList =\n         utmUpsCoords\n             .stream()\n-            .map(this::toLatLon)\n+            .map(this::parseUtmUpsString)\n             .filter(Objects::nonNull)\n-            .map(d -> new LatLon(d.getLat(), d.getLon()))\n-            .collect(Collectors.toList()));\n+            .collect(toList());\n+    List<LatLon> latLonList =\n+        utmUpsList.stream().map(this::latLonFromUtmUtps).filter(Objects::nonNull).collect(toList());\n+    String suggestionText = makeSuggestionText(utmUpsList);\n+\n+    return new LiteralSuggestion(LITERAL_SUGGESTION_ID, suggestionText, latLonList);\n+  }\n+\n+  private static String makeSuggestionText(UtmUpsCoordinate utmUps) {\n+    final StringBuilder nameBuilder = new StringBuilder();\n+    if (utmUps.isUTM()) {", "originalCommit": "89ef1ffb19a289b2691e6283c21e5bfc20edd5bd", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NzEzMDQ5Mg==", "url": "https://github.com/codice/ddf/pull/5765#discussion_r367130492", "bodyText": "\u2705 After further analysis we could not reproduce the problem. Turns out the semantics of UtmUpsCoordinate are different from the other coordinate impls. This is fine.", "author": "Lambeaux", "createdAt": "2020-01-15T22:01:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM2NjY1MzU3Mg=="}], "type": "inlineReview"}]}