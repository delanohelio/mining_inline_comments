{"pr_number": 6455, "pr_title": "[2.26.x] Improve audit logs for authentication and session events", "pr_createdAt": "2020-12-10T22:39:47Z", "pr_url": "https://github.com/codice/ddf/pull/6455", "timeline": [{"oid": "0fe0d375e43f24062a75b4f0f0441d3dbc0fba13", "url": "https://github.com/codice/ddf/commit/0fe0d375e43f24062a75b4f0f0441d3dbc0fba13", "message": "Audit login success/failure and session creation", "committedDate": "2020-12-08T21:57:11Z", "type": "commit"}, {"oid": "f8b675fb93a9ed8dc5ffd9fc1405b8c054234c16", "url": "https://github.com/codice/ddf/commit/f8b675fb93a9ed8dc5ffd9fc1405b8c054234c16", "message": "Audit logout events for all users and fix auditing of invalid session ids", "committedDate": "2020-12-09T02:55:44Z", "type": "commit"}, {"oid": "430c24f20f682c7a4682d98e75a34fa22426b891", "url": "https://github.com/codice/ddf/commit/430c24f20f682c7a4682d98e75a34fa22426b891", "message": "Fix auditing of session deletion/expiration", "committedDate": "2020-12-10T22:27:04Z", "type": "commit"}, {"oid": "608196e1586e5641abbd9a05a93ca5c6c0837c78", "url": "https://github.com/codice/ddf/commit/608196e1586e5641abbd9a05a93ca5c6c0837c78", "message": "Fix tests", "committedDate": "2020-12-10T22:27:04Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU1NTE3NA==", "url": "https://github.com/codice/ddf/pull/6455#discussion_r540555174", "bodyText": "Made this fail the bundle so we actually see an error if session auditing stops working. Last time session auditing stopped working and nobody noticed (it's been broken since this change in 2018 #3783)", "author": "SmithJosh", "createdAt": "2020-12-10T22:50:02Z", "path": "platform/platform-paxweb-jettyconfig/src/main/java/org/codice/ddf/security/session/AttributeSharingHashSessionIdManager.java", "diffHunk": "@@ -68,73 +74,57 @@\n   private static final Logger LOGGER =\n       LoggerFactory.getLogger(AttributeSharingHashSessionIdManager.class);\n \n-  static class SharingSessionInvalidator implements HttpSessionInvalidator {\n-\n-    private final AttributeSharingHashSessionIdManager idManager;\n-\n-    SharingSessionInvalidator(AttributeSharingHashSessionIdManager idManager) {\n-      this.idManager = idManager;\n-    }\n-\n-    @Override\n-    public void invalidateSession(\n-        String subjectName, Function<Map<String, Object>, String> sessionSubjectExtractor) {\n-\n-      final Optional<String> sessionIdOptional =\n-          idManager.dataStores.stream()\n-              .map(AttributeSharingSessionDataStore::getSessionDataMap)\n-              .map(Map::entrySet)\n-              .flatMap(Collection::stream)\n-              .filter(\n-                  e ->\n-                      subjectName.equals(\n-                          sessionSubjectExtractor.apply(e.getValue().getAllAttributes())))\n-              .map(Map.Entry::getKey)\n-              .findFirst();\n-\n-      sessionIdOptional.ifPresent(idManager::invalidateSession);\n-    }\n-  }\n+  private final BundleContext bundleContext;\n+  private final ServiceTracker<SecurityLogger, SecurityLogger> securityLogger;\n \n   private List<AttributeSharingSessionDataStore> dataStores = new CopyOnWriteArrayList<>();\n \n-  private void registerSessionManager() {\n+  private static BundleContext getContext() {\n     Bundle bundle = FrameworkUtil.getBundle(AttributeSharingHashSessionIdManager.class);\n-    if (bundle == null) {\n-      LOGGER.error(\"Error initializing Session Manager\");\n-      return;\n-    }\n-    final BundleContext bundleContext = bundle.getBundleContext();\n-    if (bundleContext == null) {\n-      LOGGER.error(\"Error initializing Session Manager\");\n-      return;\n-    }\n-\n-    final SharingSessionInvalidator sm = new SharingSessionInvalidator(this);\n-    final Dictionary<String, Object> props = new DictionaryMap<>();\n-    props.put(Constants.SERVICE_PID, sm.getClass().getName());\n-    props.put(Constants.SERVICE_DESCRIPTION, \"Sharing Session Invalidator\");\n-    props.put(Constants.SERVICE_VENDOR, \"Codice Foundation\");\n-    props.put(Constants.SERVICE_RANKING, Integer.MIN_VALUE);\n-\n-    bundleContext.registerService(HttpSessionInvalidator.class.getName(), sm, props);\n+    return (bundle != null) ? bundle.getBundleContext() : null;\n   }\n \n-  public AttributeSharingHashSessionIdManager(Server server) {\n+  @VisibleForTesting\n+  public AttributeSharingHashSessionIdManager(Server server, BundleContext context) {\n     super(server);\n+    bundleContext = Objects.requireNonNull(context, \"bundleContext cannot be null\");\n+    securityLogger = new ServiceTracker<>(bundleContext, SecurityLogger.class.getName(), null);\n     registerSessionManager();\n   }\n \n+  public AttributeSharingHashSessionIdManager(Server server) {\n+    this(server, getContext());\n+  }\n+\n   public AttributeSharingHashSessionIdManager(Server server, Random random) {\n     super(server, random);\n+    bundleContext = Objects.requireNonNull(getContext(), \"bundleContext cannot be null\");", "originalCommit": "608196e1586e5641abbd9a05a93ca5c6c0837c78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU2MTAzNQ==", "url": "https://github.com/codice/ddf/pull/6455#discussion_r540561035", "bodyText": "I couldn't find a better way to inject the SecurityLogger service into this class. This class is created by Jetty via jetty.xml so not managed by blueprint. I tried CDI but couldn't get it working.\nThis made things a little weird for the unit test for this class, too, which starts up a Jetty server (not OSGi). The BundleContext injection is a little ugly, but couldn't find a better way to make things work. Open to suggestions if anybody has any.", "author": "SmithJosh", "createdAt": "2020-12-10T22:58:56Z", "path": "platform/platform-paxweb-jettyconfig/src/main/java/org/codice/ddf/security/session/AttributeSharingHashSessionIdManager.java", "diffHunk": "@@ -68,73 +74,57 @@\n   private static final Logger LOGGER =\n       LoggerFactory.getLogger(AttributeSharingHashSessionIdManager.class);\n \n-  static class SharingSessionInvalidator implements HttpSessionInvalidator {\n-\n-    private final AttributeSharingHashSessionIdManager idManager;\n-\n-    SharingSessionInvalidator(AttributeSharingHashSessionIdManager idManager) {\n-      this.idManager = idManager;\n-    }\n-\n-    @Override\n-    public void invalidateSession(\n-        String subjectName, Function<Map<String, Object>, String> sessionSubjectExtractor) {\n-\n-      final Optional<String> sessionIdOptional =\n-          idManager.dataStores.stream()\n-              .map(AttributeSharingSessionDataStore::getSessionDataMap)\n-              .map(Map::entrySet)\n-              .flatMap(Collection::stream)\n-              .filter(\n-                  e ->\n-                      subjectName.equals(\n-                          sessionSubjectExtractor.apply(e.getValue().getAllAttributes())))\n-              .map(Map.Entry::getKey)\n-              .findFirst();\n-\n-      sessionIdOptional.ifPresent(idManager::invalidateSession);\n-    }\n-  }\n+  private final BundleContext bundleContext;\n+  private final ServiceTracker<SecurityLogger, SecurityLogger> securityLogger;\n \n   private List<AttributeSharingSessionDataStore> dataStores = new CopyOnWriteArrayList<>();\n \n-  private void registerSessionManager() {\n+  private static BundleContext getContext() {\n     Bundle bundle = FrameworkUtil.getBundle(AttributeSharingHashSessionIdManager.class);\n-    if (bundle == null) {\n-      LOGGER.error(\"Error initializing Session Manager\");\n-      return;\n-    }\n-    final BundleContext bundleContext = bundle.getBundleContext();\n-    if (bundleContext == null) {\n-      LOGGER.error(\"Error initializing Session Manager\");\n-      return;\n-    }\n-\n-    final SharingSessionInvalidator sm = new SharingSessionInvalidator(this);\n-    final Dictionary<String, Object> props = new DictionaryMap<>();\n-    props.put(Constants.SERVICE_PID, sm.getClass().getName());\n-    props.put(Constants.SERVICE_DESCRIPTION, \"Sharing Session Invalidator\");\n-    props.put(Constants.SERVICE_VENDOR, \"Codice Foundation\");\n-    props.put(Constants.SERVICE_RANKING, Integer.MIN_VALUE);\n-\n-    bundleContext.registerService(HttpSessionInvalidator.class.getName(), sm, props);\n+    return (bundle != null) ? bundle.getBundleContext() : null;\n   }\n \n-  public AttributeSharingHashSessionIdManager(Server server) {\n+  @VisibleForTesting\n+  public AttributeSharingHashSessionIdManager(Server server, BundleContext context) {\n     super(server);\n+    bundleContext = Objects.requireNonNull(context, \"bundleContext cannot be null\");\n+    securityLogger = new ServiceTracker<>(bundleContext, SecurityLogger.class.getName(), null);", "originalCommit": "608196e1586e5641abbd9a05a93ca5c6c0837c78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDU2NDEwNw==", "url": "https://github.com/codice/ddf/pull/6455#discussion_r540564107", "bodyText": "Registering this as a service doesn't work because of a limitation in Pax Web. See https://ops4j1.jira.com/browse/PAXWEB-1123. If we wanted to use an HttpSessionListener for all servlet contexts, we'd have to inject it the same way we do error pages, which is a bit of a hack. So I opted to audit from the AttributeSharingHashSessionIdManager", "author": "SmithJosh", "createdAt": "2020-12-10T23:02:44Z", "path": "platform/security/core/security-core-services/src/main/java/ddf/security/listener/AuditingHttpSessionListener.java", "diffHunk": "@@ -1,48 +0,0 @@\n-/**\n- * Copyright (c) Codice Foundation\n- *\n- * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n- * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n- * the License, or any later version.\n- *\n- * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n- * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n- * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n- * License is distributed along with this program and can be found at\n- * <http://www.gnu.org/licenses/lgpl.html>.\n- */\n-package ddf.security.listener;\n-\n-import com.google.common.hash.Hashing;\n-import ddf.security.audit.SecurityLogger;\n-import java.nio.charset.StandardCharsets;\n-import javax.servlet.http.HttpSession;\n-import javax.servlet.http.HttpSessionEvent;\n-import javax.servlet.http.HttpSessionListener;\n-\n-public class AuditingHttpSessionListener implements HttpSessionListener {", "originalCommit": "608196e1586e5641abbd9a05a93ca5c6c0837c78", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9fe663e54115533be18b925be3465efe09e26693", "url": "https://github.com/codice/ddf/commit/9fe663e54115533be18b925be3465efe09e26693", "message": "Add logout message for OIDC", "committedDate": "2020-12-14T18:47:18Z", "type": "commit"}, {"oid": "ccbb85a579b2fa60cfb19c6f439e1d085a21414b", "url": "https://github.com/codice/ddf/commit/ccbb85a579b2fa60cfb19c6f439e1d085a21414b", "message": "Revert WCPM changes", "committedDate": "2020-12-14T18:51:13Z", "type": "commit"}, {"oid": "ee7ef7ae49e1947ddbb7bf889d618687a7e5f257", "url": "https://github.com/codice/ddf/commit/ee7ef7ae49e1947ddbb7bf889d618687a7e5f257", "message": "Fix audited subject name for PKI logout", "committedDate": "2020-12-14T21:18:15Z", "type": "commit"}]}