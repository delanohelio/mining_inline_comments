{"pr_number": 6426, "pr_title": "DDF-4729 adds WFS 1.1.0 sorting", "pr_createdAt": "2020-11-19T17:56:30Z", "pr_url": "https://github.com/codice/ddf/pull/6426", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkwNTYzMA==", "url": "https://github.com/codice/ddf/pull/6426#discussion_r527905630", "bodyText": "The argument should be distanceSortProperty.", "author": "jrnorth", "createdAt": "2020-11-20T18:49:26Z", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/test/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSourceTest.java", "diffHunk": "@@ -1371,6 +1389,206 @@ public void testQuerySendsHitsRequestBeforeResultsRequest() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testSortingNoSortBy() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    propertyIsLikeQuery.setPageSize(1);\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    final GetFeatureType getResults = captor.getAllValues().get(1);\n+    assertThat(getResults.getResultType(), is(ResultTypeType.RESULTS));\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+      final QueryType queryType = getFeatureType.getQuery().get(0);\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  /**\n+   * WFS 1.1.0 Sorting uses the following format: Valid sort orders are \"ASC\" and \"DESC\". Ref:\n+   * http://schemas.opengis.net/filter/1.1.0/sort.xsd <wfs:Query typeName=\"QName QName\">\n+   * <wfs:PropertyName>QName</wfs:PropertyName> <ogc:Filter> <ogc:Equals> <ogc:PropertyName/>\n+   * <gml:Point>... </gml:Point> </ogc:Equals> </ogc:Filter> <ogc:SortBy> <ogc:SortProperty>\n+   * <ogc:PropertyName>property</ogc:PropertyName> <ogc:SortOrder>ASC</ogc:SortOrder>\n+   * </ogc:SortProperty> </ogc:SortBy> </wfs:Query>\n+   */\n+  @Test\n+  public void testSortingSortOrderAscending() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROPERTY, MOCK_RELEVANCE_SORT_PROPERTY, MOCK_DISTANCE_SORT_PROPERTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROPERTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingSortOrderDescending() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROPERTY, MOCK_RELEVANCE_SORT_PROPERTY, MOCK_DISTANCE_SORT_PROPERTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.DESCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROPERTY, \"DESC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingDisabled() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROPERTY, MOCK_RELEVANCE_SORT_PROPERTY, MOCK_DISTANCE_SORT_PROPERTY);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(true);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, false, MOCK_TEMPORAL_SORT_PROPERTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingNoSortMapping() throws Exception {\n+    // if sorting is enabled but there is no sort mapping, throw an UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\"Source WFS_ID does not support specified sort property title\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(null, null, null);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(false);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(\"title\", SortOrder.ASCENDING));\n+\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortOrder() throws Exception {\n+    // if sort order is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order null\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROPERTY, MOCK_RELEVANCE_SORT_PROPERTY, MOCK_DISTANCE_SORT_PROPERTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, (String) null));\n+\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortProperty() throws Exception {\n+    // if sort property is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property null with sort order SortOrder[ASCENDING]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROPERTY, MOCK_RELEVANCE_SORT_PROPERTY, MOCK_DISTANCE_SORT_PROPERTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(null, \"ASC\"));\n+\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingBadSortOrder() throws Exception {\n+    // if sort order is invalid throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order SortOrder[foo]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROPERTY, MOCK_RELEVANCE_SORT_PROPERTY, MOCK_DISTANCE_SORT_PROPERTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, \"foo\"));\n+\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  private void assertFeature(\n+      GetFeatureType getFeatureType,\n+      boolean sortingEnabled,\n+      String sortProperty,\n+      String sortOrder) {\n+    assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+    final QueryType queryType = getFeatureType.getQuery().get(0);\n+    if (sortingEnabled) {\n+      assertThat(queryType.isSetSortBy(), is(true));\n+      assertThat(queryType.getSortBy().getSortProperty().size(), is(1));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getPropertyName().getContent().size(),\n+          is(1));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getPropertyName().getContent().get(0),\n+          is(sortProperty));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getSortOrder().value(), is(sortOrder));\n+    } else {\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  private void setupMapper(\n+      String temporalSortProperty, String relevanceSortProperty, String distanceSortProperty) {\n+    final MetacardMapperImpl metacardMapper = new MetacardMapperImpl();\n+    metacardMapper.setSortByTemporalFeatureProperty(temporalSortProperty);\n+    metacardMapper.setSortByDistanceFeatureProperty(relevanceSortProperty);", "originalCommit": "fbc39c5a5cbe25a6e1e0bf8eb1c13cb81f616744", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkwNTc1OQ==", "url": "https://github.com/codice/ddf/pull/6426#discussion_r527905759", "bodyText": "The argument should be relevanceSortProperty.", "author": "jrnorth", "createdAt": "2020-11-20T18:49:40Z", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/test/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSourceTest.java", "diffHunk": "@@ -1371,6 +1389,206 @@ public void testQuerySendsHitsRequestBeforeResultsRequest() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testSortingNoSortBy() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    propertyIsLikeQuery.setPageSize(1);\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    final GetFeatureType getResults = captor.getAllValues().get(1);\n+    assertThat(getResults.getResultType(), is(ResultTypeType.RESULTS));\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+      final QueryType queryType = getFeatureType.getQuery().get(0);\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  /**\n+   * WFS 1.1.0 Sorting uses the following format: Valid sort orders are \"ASC\" and \"DESC\". Ref:\n+   * http://schemas.opengis.net/filter/1.1.0/sort.xsd <wfs:Query typeName=\"QName QName\">\n+   * <wfs:PropertyName>QName</wfs:PropertyName> <ogc:Filter> <ogc:Equals> <ogc:PropertyName/>\n+   * <gml:Point>... </gml:Point> </ogc:Equals> </ogc:Filter> <ogc:SortBy> <ogc:SortProperty>\n+   * <ogc:PropertyName>property</ogc:PropertyName> <ogc:SortOrder>ASC</ogc:SortOrder>\n+   * </ogc:SortProperty> </ogc:SortBy> </wfs:Query>\n+   */\n+  @Test\n+  public void testSortingSortOrderAscending() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROPERTY, MOCK_RELEVANCE_SORT_PROPERTY, MOCK_DISTANCE_SORT_PROPERTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROPERTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingSortOrderDescending() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROPERTY, MOCK_RELEVANCE_SORT_PROPERTY, MOCK_DISTANCE_SORT_PROPERTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.DESCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROPERTY, \"DESC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingDisabled() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROPERTY, MOCK_RELEVANCE_SORT_PROPERTY, MOCK_DISTANCE_SORT_PROPERTY);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(true);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, false, MOCK_TEMPORAL_SORT_PROPERTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingNoSortMapping() throws Exception {\n+    // if sorting is enabled but there is no sort mapping, throw an UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\"Source WFS_ID does not support specified sort property title\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(null, null, null);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(false);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(\"title\", SortOrder.ASCENDING));\n+\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortOrder() throws Exception {\n+    // if sort order is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order null\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROPERTY, MOCK_RELEVANCE_SORT_PROPERTY, MOCK_DISTANCE_SORT_PROPERTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, (String) null));\n+\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortProperty() throws Exception {\n+    // if sort property is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property null with sort order SortOrder[ASCENDING]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROPERTY, MOCK_RELEVANCE_SORT_PROPERTY, MOCK_DISTANCE_SORT_PROPERTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(null, \"ASC\"));\n+\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingBadSortOrder() throws Exception {\n+    // if sort order is invalid throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order SortOrder[foo]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROPERTY, MOCK_RELEVANCE_SORT_PROPERTY, MOCK_DISTANCE_SORT_PROPERTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, \"foo\"));\n+\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  private void assertFeature(\n+      GetFeatureType getFeatureType,\n+      boolean sortingEnabled,\n+      String sortProperty,\n+      String sortOrder) {\n+    assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+    final QueryType queryType = getFeatureType.getQuery().get(0);\n+    if (sortingEnabled) {\n+      assertThat(queryType.isSetSortBy(), is(true));\n+      assertThat(queryType.getSortBy().getSortProperty().size(), is(1));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getPropertyName().getContent().size(),\n+          is(1));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getPropertyName().getContent().get(0),\n+          is(sortProperty));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getSortOrder().value(), is(sortOrder));\n+    } else {\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  private void setupMapper(\n+      String temporalSortProperty, String relevanceSortProperty, String distanceSortProperty) {\n+    final MetacardMapperImpl metacardMapper = new MetacardMapperImpl();\n+    metacardMapper.setSortByTemporalFeatureProperty(temporalSortProperty);\n+    metacardMapper.setSortByDistanceFeatureProperty(relevanceSortProperty);\n+    metacardMapper.setSortByRelevanceFeatureProperty(distanceSortProperty);", "originalCommit": "fbc39c5a5cbe25a6e1e0bf8eb1c13cb81f616744", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkwNzY3Ng==", "url": "https://github.com/codice/ddf/pull/6426#discussion_r527907676", "bodyText": "\u270f\ufe0f StringUtils is already imported.", "author": "jrnorth", "createdAt": "2020-11-20T18:53:36Z", "path": "catalog/spatial/wfs/spatial-wfs-common/src/main/java/org/codice/ddf/spatial/ogc/wfs/catalog/common/AbstractWfsSource.java", "diffHunk": "@@ -58,4 +69,72 @@ public String getSslProtocol() {\n   public void setSslProtocol(String sslProtocol) {\n     this.sslProtocol = sslProtocol;\n   }\n+\n+  /**\n+   * If a MetacardMapper cannot be found or there is no mapping for the incomingPropertyName, return\n+   * null. This will cause a query to be constructed without an AbstractSortingClause.\n+   */\n+  protected String mapSortByPropertyName(\n+      QName featureType, String incomingPropertyName, List<MetacardMapper> metacardMapperList) {\n+    if (featureType == null || incomingPropertyName == null || metacardMapperList == null) {\n+      return null;\n+    }\n+    if (LOGGER.isDebugEnabled()) {\n+      metacardMapperList.forEach(\n+          m -> {\n+            LOGGER.debug(\n+                \"Sorting: Mapper: featureType {}, mapped property for {} : {}\",\n+                m.getFeatureType(),\n+                incomingPropertyName,\n+                m.getFeatureProperty(incomingPropertyName));\n+          });\n+      LOGGER.debug(\n+          \"Mapping sort property: featureType {}, incomingPropertyName {}\",\n+          featureType,\n+          incomingPropertyName);\n+    }\n+    MetacardMapper metacardToFeaturePropertyMapper =\n+        lookupMetacardAttributeToFeaturePropertyMapper(featureType, metacardMapperList);\n+    String mappedPropertyName = null;\n+\n+    if (metacardToFeaturePropertyMapper != null) {\n+\n+      if (StringUtils.equals(Result.TEMPORAL, incomingPropertyName)\n+          || StringUtils.equals(Metacard.EFFECTIVE, incomingPropertyName)) {\n+        mappedPropertyName =\n+            StringUtils.defaultIfBlank(\n+                metacardToFeaturePropertyMapper.getSortByTemporalFeatureProperty(), null);\n+      } else if (StringUtils.equals(Result.RELEVANCE, incomingPropertyName)) {\n+        mappedPropertyName =\n+            StringUtils.defaultIfBlank(\n+                metacardToFeaturePropertyMapper.getSortByRelevanceFeatureProperty(), null);\n+      } else if (org.apache.commons.lang.StringUtils.equals(", "originalCommit": "fbc39c5a5cbe25a6e1e0bf8eb1c13cb81f616744", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzkwODEwMA==", "url": "https://github.com/codice/ddf/pull/6426#discussion_r527908100", "bodyText": "\u270f\ufe0f PROEPRTY -> PROPERTY", "author": "jrnorth", "createdAt": "2020-11-20T18:54:27Z", "path": "catalog/spatial/wfs/spatial-wfs-common/src/test/java/org/codice/ddf/spatial/ogc/wfs/catalog/common/AbstractWfsSourceTest.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package org.codice.ddf.spatial.ogc.wfs.catalog.common;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.hamcrest.core.Is.is;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+\n+import ddf.catalog.data.ContentType;\n+import ddf.catalog.data.Metacard;\n+import ddf.catalog.data.Result;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.ResourceResponse;\n+import ddf.catalog.operation.SourceResponse;\n+import ddf.catalog.resource.ResourceNotFoundException;\n+import ddf.catalog.resource.ResourceNotSupportedException;\n+import ddf.catalog.source.SourceMonitor;\n+import ddf.catalog.source.UnsupportedQueryException;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.xml.namespace.QName;\n+import org.codice.ddf.spatial.ogc.wfs.catalog.mapper.MetacardMapper;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class AbstractWfsSourceTest {\n+  private AbstractWfsSource wfsSource;\n+  private static final String FEATURE_NAME = \"SampleFeature\";\n+  private static final String TEMPORAL_SORT_PROEPRTY = \"myTemporalSortProperty\";", "originalCommit": "fbc39c5a5cbe25a6e1e0bf8eb1c13cb81f616744", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9e340a659410379a9af25cfaf204c85f1f3e24a8", "url": "https://github.com/codice/ddf/commit/9e340a659410379a9af25cfaf204c85f1f3e24a8", "message": "DDF-4729 adds WFS 1.1.0 sorting (#6419)\n\n* DDF-4729 adds WFS 1.1.0 sorting\n\n- adds flag to enable/disable sorting\n- adds mapping of DDF sort attributes to WFS attributes", "committedDate": "2021-02-01T18:48:42Z", "type": "commit"}, {"oid": "14fd8a2e3cb3fb4f8098ec4e80862a22dfb878de", "url": "https://github.com/codice/ddf/commit/14fd8a2e3cb3fb4f8098ec4e80862a22dfb878de", "message": "DDF-4729 code cleanup", "committedDate": "2021-02-01T18:56:12Z", "type": "commit"}, {"oid": "14fd8a2e3cb3fb4f8098ec4e80862a22dfb878de", "url": "https://github.com/codice/ddf/commit/14fd8a2e3cb3fb4f8098ec4e80862a22dfb878de", "message": "DDF-4729 code cleanup", "committedDate": "2021-02-01T18:56:12Z", "type": "forcePushed"}]}