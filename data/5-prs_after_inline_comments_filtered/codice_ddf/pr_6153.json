{"pr_number": 6153, "pr_title": "DDF-6152 Added standalone solr gazetteer", "pr_createdAt": "2020-06-25T23:23:13Z", "pr_url": "https://github.com/codice/ddf/pull/6153", "timeline": [{"oid": "3d7b2b05b2443c407fb7c2a16395eca1ccbe53f8", "url": "https://github.com/codice/ddf/commit/3d7b2b05b2443c407fb7c2a16395eca1ccbe53f8", "message": "DDF-6152 Added standalone solr gazetteer", "committedDate": "2020-06-29T22:00:15Z", "type": "forcePushed"}, {"oid": "d0d3ce3d1325fabd1b65e6953f678e19e75329cf", "url": "https://github.com/codice/ddf/commit/d0d3ce3d1325fabd1b65e6953f678e19e75329cf", "message": "DDF-6152 Added standalone solr gazetteer", "committedDate": "2020-06-29T22:30:13Z", "type": "forcePushed"}, {"oid": "cc7d19c20f926c1b37a7b3926608b9f97d5d66f9", "url": "https://github.com/codice/ddf/commit/cc7d19c20f926c1b37a7b3926608b9f97d5d66f9", "message": "DDF-6152 Added standalone solr gazetteer", "committedDate": "2020-06-30T17:11:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5ODEwMg==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r447898102", "bodyText": "@paouelle may be interested in this -- It seems that with this karaf command (and the other here) if i attempted to use the solrClient returned by clientFactory.newClient too 'quickly' , it would throw a SolrServerException because the client had not connected yet. Hence, I added the retry to have it retry a few times to give it a chance to connect (which did seem to alleviate the issue).", "author": "rzwiefel", "createdAt": "2020-06-30T18:35:43Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/RemoveAllOfflineSolrGazetteerCommand.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.util.concurrent.TimeUnit;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.karaf.shell.api.action.Action;\n+import org.apache.karaf.shell.api.action.Command;\n+import org.apache.karaf.shell.api.action.Option;\n+import org.apache.karaf.shell.api.action.lifecycle.Reference;\n+import org.apache.karaf.shell.api.action.lifecycle.Service;\n+import org.apache.karaf.shell.api.console.Session;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.client.solrj.UnavailableSolrException;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Service\n+@Command(\n+  scope = \"offline-solr-gazetteer\",\n+  name = \"removeall\",\n+  description = \"Deletes all items in the offline solr gazetteer solr core\"\n+)\n+public class RemoveAllOfflineSolrGazetteerCommand implements Action {\n+  private static final Logger LOGGER =\n+      LoggerFactory.getLogger(RemoveAllOfflineSolrGazetteerCommand.class);\n+\n+  @Reference protected Session session;\n+\n+  @Reference private SolrClientFactory clientFactory;\n+\n+  @Option(\n+    name = \"--force\",\n+    aliases = {\"-f\"},\n+    description = \"Force the removal without a confirmation message.\"\n+  )\n+  boolean force = false;\n+\n+  private final RetryPolicy retryPolicy =\n+      new RetryPolicy()\n+          .retryOn(ImmutableList.of(UnavailableSolrException.class, SolrServerException.class))\n+          .withMaxDuration(5, TimeUnit.SECONDS)\n+          .withBackoff(25, 1_000, TimeUnit.MILLISECONDS);\n+\n+  @Override\n+  public Object execute() throws Exception {\n+    if (!force) {\n+      String answer =\n+          session\n+              .readLine(\n+                  \"Are you sure you want to remove all gazetteer entries inside of the offline solr gazetteer core?(y/n)\",\n+                  ' ')\n+              .toLowerCase();\n+      if (!(\"y\".equals(answer) || \"yes\".equals(answer))) {\n+        session.getConsole().println(\"Aborting.\");\n+        return null;\n+      }\n+    }\n+    try {\n+      SolrClient solrClient =\n+          clientFactory.newClient(OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME);\n+\n+      Failsafe.with(retryPolicy).get(() -> solrClient.deleteByQuery(\"*:*\"));", "originalCommit": "cc7d19c20f926c1b37a7b3926608b9f97d5d66f9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzNzM5OA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451237398", "bodyText": "Here's an alternative to save you the trouble.\nhttps://github.com/codice/ddf/blob/master/platform/solr/solr-factory/src/main/java/org/codice/solr/client/solrj/SolrClient.java#L118-L133", "author": "Lambeaux", "createdAt": "2020-07-08T01:53:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5ODEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzNzc1MQ==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451237751", "bodyText": "Another option for you in the event you prefer to manage things yourself, with Failsafe, to preserve more synchronous behavior.\nhttps://github.com/codice/ddf/blob/master/platform/solr/solr-factory/src/main/java/org/codice/solr/client/solrj/SolrClient.java#L65-L76", "author": "Lambeaux", "createdAt": "2020-07-08T01:55:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5ODEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY1ODE2Nw==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451658167", "bodyText": "i have seen this as well on the splitcatalogprovider. should newClient bake in the logic to check/wait with timeout before returning?", "author": "lamhuy", "createdAt": "2020-07-08T16:05:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5ODEwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgyNzA1MA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451827050", "bodyText": "probably not - there are api methods available on the client itself for either sync or async behavior - see above links.", "author": "Lambeaux", "createdAt": "2020-07-08T21:10:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzg5ODEwMg=="}], "type": "inlineReview"}, {"oid": "65fc73ff76bd9e398c6031a454a6c8dd592ee4c7", "url": "https://github.com/codice/ddf/commit/65fc73ff76bd9e398c6031a454a6c8dd592ee4c7", "message": "DDF-6152 Added standalone solr gazetteer", "committedDate": "2020-06-30T20:50:25Z", "type": "forcePushed"}, {"oid": "efb03e911a482cafa6c5f88d21322c3b031c8a27", "url": "https://github.com/codice/ddf/commit/efb03e911a482cafa6c5f88d21322c3b031c8a27", "message": "DDF-6152 Added standalone solr gazetteer", "committedDate": "2020-06-30T20:51:45Z", "type": "forcePushed"}, {"oid": "88f357102c5f89f5b129ad7e7cdb633387426b7e", "url": "https://github.com/codice/ddf/commit/88f357102c5f89f5b129ad7e7cdb633387426b7e", "message": "DDF-6152 Added standalone solr gazetteer", "committedDate": "2020-06-30T20:52:40Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExMzM5Mg==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r449113392", "bodyText": "\u2757  Sadly RetryPolicy is not thread safe.  Looks like only the constructor uses it currently.  I would suggest moving this to the constructor so no one accidentally reuses it in the future.\nfailsafe-lib/failsafe#47", "author": "pklinef", "createdAt": "2020-07-02T15:53:07Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.client.solrj.response.SolrPingResponse;\n+import org.apache.solr.client.solrj.response.SuggesterResponse;\n+import org.apache.solr.client.solrj.util.ClientUtils;\n+import org.apache.solr.common.SolrDocument;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntry;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryException;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryable;\n+import org.codice.ddf.spatial.geocoding.Suggestion;\n+import org.codice.ddf.spatial.geocoding.context.NearbyLocation;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.io.WKTReader;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GazetteerQueryOfflineSolr implements GeoEntryQueryable {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GazetteerQueryOfflineSolr.class);\n+\n+  private static final String CITY_SOLR_QUERY =\n+      GeoCodingConstants.CITY_FEATURE_CODES\n+          .stream()\n+          .map(fc -> String.format(\"ext.feature-code_txt:%s\", fc))\n+          .collect(Collectors.joining(\" OR \", \"(\", \")\"));\n+\n+  private static final ThreadLocal<WKTWriter> WKT_WRITER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTWriter::new);\n+\n+  private static final ThreadLocal<WKTReader> WKT_READER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTReader::new);\n+\n+  private static final RetryPolicy RETRY_POLICY =", "originalCommit": "88f357102c5f89f5b129ad7e7cdb633387426b7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE4NTMwOQ==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451185309", "bodyText": "Done", "author": "rzwiefel", "createdAt": "2020-07-07T22:45:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTExMzM5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MTgwNA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r449141804", "bodyText": "\u2753 Why couple the gazetteer collection fields to the catalog attribute taxonomy?\nWhile rare, if any of these attribute names change then the gazetteer collection would need to be re-indexed as well.  If the gazetteer had its own independent field names, then this plugin would be the only one that has to know about the mapping of catalog attribute names to gazetteer field names.  Then this plugin could be extracted later making the bundle with GazetteerQueryOfflineSolr able to remove any direct dependencies on the Catalog API (currently spatial-geocoding-api still has a dependency on the catalog core API but that can be fixed eventually).", "author": "pklinef", "createdAt": "2020-07-02T16:39:59Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/OfflineGazetteerPlugin.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import static ddf.catalog.Constants.SUGGESTION_BUILD_KEY;\n+\n+import ddf.catalog.data.Attribute;\n+import ddf.catalog.data.Metacard;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import ddf.catalog.operation.CreateResponse;\n+import ddf.catalog.operation.DeleteResponse;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.Update;\n+import ddf.catalog.operation.UpdateResponse;\n+import ddf.catalog.plugin.PluginExecutionException;\n+import ddf.catalog.plugin.PostIngestPlugin;\n+import ddf.catalog.plugin.PreQueryPlugin;\n+import ddf.catalog.plugin.StopProcessingException;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class OfflineGazetteerPlugin implements PostIngestPlugin, PreQueryPlugin {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(OfflineGazetteerPlugin.class);\n+  private static final String GAZETTEER_METACARD_TAG = \"gazetteer\";\n+  public static final String STANDALONE_GAZETTEER_CORE_NAME = \"standalone-solr-gazetteer\";\n+\n+  private final SolrClientFactory clientFactory;\n+  private final SolrClient solrClient;\n+\n+  public OfflineGazetteerPlugin(SolrClientFactory clientFactory) {\n+    this.clientFactory = clientFactory;\n+    this.solrClient = clientFactory.newClient(STANDALONE_GAZETTEER_CORE_NAME);\n+  }\n+\n+  @Override\n+  public CreateResponse process(CreateResponse input) throws PluginExecutionException {\n+    List<Metacard> gazetteerMetacards =\n+        input\n+            .getCreatedMetacards()\n+            .stream()\n+            .filter(this::isGazetteerMetacard)\n+            .collect(Collectors.toList());\n+\n+    if (gazetteerMetacards.isEmpty()) {\n+      return input;\n+    }\n+\n+    try {\n+      solrClient.add(\n+          STANDALONE_GAZETTEER_CORE_NAME,\n+          gazetteerMetacards\n+              .stream()\n+              .map(OfflineGazetteerPlugin::convert)\n+              .collect(Collectors.toList()));\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Error while processing gazetteer data\", e);\n+      throw new PluginExecutionException(e);\n+    }\n+\n+    return input;\n+  }\n+\n+  @Override\n+  public UpdateResponse process(UpdateResponse input) throws PluginExecutionException {\n+    List<Metacard> gazetteerMetacards =\n+        input\n+            .getUpdatedMetacards()\n+            .stream()\n+            .map(Update::getNewMetacard)\n+            .filter(this::isGazetteerMetacard)\n+            .collect(Collectors.toList());\n+\n+    if (gazetteerMetacards.isEmpty()) {\n+      return input;\n+    }\n+\n+    try {\n+      solrClient.add(\n+          STANDALONE_GAZETTEER_CORE_NAME,\n+          gazetteerMetacards\n+              .stream()\n+              .map(OfflineGazetteerPlugin::convert)\n+              .collect(Collectors.toList()));\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Error while processing gazetteer data\", e);\n+      throw new PluginExecutionException(e);\n+    }\n+    return input;\n+  }\n+\n+  @Override\n+  public DeleteResponse process(DeleteResponse input) throws PluginExecutionException {\n+    List<String> ids =\n+        input\n+            .getDeletedMetacards()\n+            .stream()\n+            .filter(this::isGazetteerMetacard)\n+            .map(Metacard::getId)\n+            .collect(Collectors.toList());\n+    if (ids.isEmpty()) {\n+      return input;\n+    }\n+\n+    try {\n+      solrClient.deleteById(ids);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Error while processing gazetteer data\", e);\n+      throw new PluginExecutionException(e);\n+    }\n+\n+    return input;\n+  }\n+\n+  protected static SolrInputDocument convert(Metacard metacard) {\n+    SolrInputDocument solrDoc = new SolrInputDocument();\n+    Consumer<String> getAttrAndAdd =\n+        (attribute) ->\n+            Optional.ofNullable(getStringAttribute(metacard, attribute))\n+                .ifPresent(attr -> solrDoc.addField(attribute + \"_txt\", attr));\n+\n+    getAttrAndAdd.accept(Metacard.DESCRIPTION);", "originalCommit": "88f357102c5f89f5b129ad7e7cdb633387426b7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzNDUzNw==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451234537", "bodyText": "\u2753 @pklinef Are you suggesting to just hardcode the catalog attribute strings locally? Isn't that still pseudo coupling? I'm not sure how else you could establish this mapping.\nUnless you're suggesting to operate on attributes in a more generic fashion instead of coding your control flow around specific ones. So iterating and mapping based off of metacard type and not specific attribute would insulate this logic from changes, I think.", "author": "Lambeaux", "createdAt": "2020-07-08T01:42:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MTgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY1NzE5NQ==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451657195", "bodyText": "I am not suggesting to hardcode catalog attributes for the plugin.  The catalog plugin can use the constants for attributes.  But it should then map those catalog attributes into gazetteer fields or call some gazetteer API to add the document that would know those field names.  By doing either of those, the GazetteerQueryOfflineSolr will not need to know anything about the catalog.  So for example, convert metacard title to gazetteer name.  Generally a gazetteer would not talk about titles.\nhttps://www.geonames.org/5308655/phoenix.html", "author": "pklinef", "createdAt": "2020-07-08T16:03:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MTgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTgxOTYzNQ==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451819635", "bodyText": "Initially I almost did create a mapping from catalog attributes to its own fields, but I passed it off as me being overzealous \ud83d\ude02 . Will update to its own mapping \ud83d\udc4c", "author": "rzwiefel", "createdAt": "2020-07-08T20:54:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MTgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTg2MDMyOA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451860328", "bodyText": "I will join you in being overzealous then. \ud83d\ude0e", "author": "pklinef", "createdAt": "2020-07-08T22:29:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MTgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg3NTM2NQ==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r453875365", "bodyText": "I did do the mapping but to your specific example of 'title' I can't change because that is the field the suggester is configured to make suggestions off of \ud83d\ude04", "author": "rzwiefel", "createdAt": "2020-07-13T19:18:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MTgwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjU2NTEyMQ==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r456565121", "bodyText": "Updated title to name now that the solrconfig has a separate suggester.", "author": "rzwiefel", "createdAt": "2020-07-17T17:04:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE0MTgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3NjkyMA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r449176920", "bodyText": "\u270f\ufe0f Maybe mention it was a query by id.  Something like Error while querying by ID. Nice to have the sanity check instead of relying fully on stacktrace line number.  It also help differentiate this exception from the one thrown in the other query method.", "author": "pklinef", "createdAt": "2020-07-02T17:46:02Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.client.solrj.response.SolrPingResponse;\n+import org.apache.solr.client.solrj.response.SuggesterResponse;\n+import org.apache.solr.client.solrj.util.ClientUtils;\n+import org.apache.solr.common.SolrDocument;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntry;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryException;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryable;\n+import org.codice.ddf.spatial.geocoding.Suggestion;\n+import org.codice.ddf.spatial.geocoding.context.NearbyLocation;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.io.WKTReader;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GazetteerQueryOfflineSolr implements GeoEntryQueryable {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GazetteerQueryOfflineSolr.class);\n+\n+  private static final String CITY_SOLR_QUERY =\n+      GeoCodingConstants.CITY_FEATURE_CODES\n+          .stream()\n+          .map(fc -> String.format(\"ext.feature-code_txt:%s\", fc))\n+          .collect(Collectors.joining(\" OR \", \"(\", \")\"));\n+\n+  private static final ThreadLocal<WKTWriter> WKT_WRITER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTWriter::new);\n+\n+  private static final ThreadLocal<WKTReader> WKT_READER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTReader::new);\n+\n+  private static final RetryPolicy RETRY_POLICY =\n+      new RetryPolicy()\n+          .withMaxDuration(20, TimeUnit.SECONDS)\n+          .withBackoff(100, 1_000, TimeUnit.MILLISECONDS);\n+\n+  protected static final String SUGGEST_Q = \"suggest.q\";\n+  protected static final String SUGGEST_DICT = \"suggest.dictionary\";\n+  protected static final String SUGGEST_PLACE_KEY = \"suggestPlace\";\n+\n+  public static final int MAX_RESULTS = 100;\n+  public static final double KM_PER_DEGREE = 111.139;\n+\n+  private SolrClientFactory clientFactory;\n+\n+  private SolrClient client;\n+\n+  private ExecutorService executor = Executors.newSingleThreadExecutor();\n+\n+  public GazetteerQueryOfflineSolr(SolrClientFactory clientFactory) {\n+    this.clientFactory = clientFactory;\n+    this.client = clientFactory.newClient(OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME);\n+    executor.submit(\n+        () -> {\n+          SolrPingResponse ping =\n+              Failsafe.with(RETRY_POLICY)\n+                  .onFailure(\n+                      e ->\n+                          LOGGER.error(\n+                              \"Could not get solrclient to start initial suggester build for {} core. Please try to start a build manually with the `build-suggester-index` karaf command or by sending a request to solr with the property `suggest.build=true`\",\n+                              OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME,\n+                              e))\n+                  .get(() -> client.ping());\n+          SolrQuery query = new SolrQuery();\n+          query.setRequestHandler(\"/suggest\");\n+          query.setParam(\"suggest.build\", true);\n+          query.setParam(\"suggest.q\", \"GQOSInitialSuggesterBuild\");\n+          query.setParam(\"suggest.dictionary\", \"suggestPlace\");\n+          try {\n+            QueryResponse response = client.query(query);\n+            LOGGER.debug(\"Initial Suggester build response: {}\", response);\n+          } catch (SolrServerException | IOException e) {\n+            LOGGER.error(\n+                \"Error while trying to build initial suggester for {}\",\n+                OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME,\n+                e);\n+          }\n+        });\n+  }\n+\n+  @Override\n+  public List<GeoEntry> query(String queryString, int maxResults) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"title_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(queryString)));\n+    solrQuery.setRows(Math.min(maxResults, GazetteerQueryOfflineSolr.MAX_RESULTS));\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public GeoEntry queryById(String id) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"id_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(id)));\n+    solrQuery.setRows(1);\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);", "originalCommit": "88f357102c5f89f5b129ad7e7cdb633387426b7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3ODMyMw==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r449178323", "bodyText": "\u2753 Why the log and throw here?", "author": "pklinef", "createdAt": "2020-07-02T17:48:56Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.client.solrj.response.SolrPingResponse;\n+import org.apache.solr.client.solrj.response.SuggesterResponse;\n+import org.apache.solr.client.solrj.util.ClientUtils;\n+import org.apache.solr.common.SolrDocument;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntry;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryException;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryable;\n+import org.codice.ddf.spatial.geocoding.Suggestion;\n+import org.codice.ddf.spatial.geocoding.context.NearbyLocation;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.io.WKTReader;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GazetteerQueryOfflineSolr implements GeoEntryQueryable {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GazetteerQueryOfflineSolr.class);\n+\n+  private static final String CITY_SOLR_QUERY =\n+      GeoCodingConstants.CITY_FEATURE_CODES\n+          .stream()\n+          .map(fc -> String.format(\"ext.feature-code_txt:%s\", fc))\n+          .collect(Collectors.joining(\" OR \", \"(\", \")\"));\n+\n+  private static final ThreadLocal<WKTWriter> WKT_WRITER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTWriter::new);\n+\n+  private static final ThreadLocal<WKTReader> WKT_READER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTReader::new);\n+\n+  private static final RetryPolicy RETRY_POLICY =\n+      new RetryPolicy()\n+          .withMaxDuration(20, TimeUnit.SECONDS)\n+          .withBackoff(100, 1_000, TimeUnit.MILLISECONDS);\n+\n+  protected static final String SUGGEST_Q = \"suggest.q\";\n+  protected static final String SUGGEST_DICT = \"suggest.dictionary\";\n+  protected static final String SUGGEST_PLACE_KEY = \"suggestPlace\";\n+\n+  public static final int MAX_RESULTS = 100;\n+  public static final double KM_PER_DEGREE = 111.139;\n+\n+  private SolrClientFactory clientFactory;\n+\n+  private SolrClient client;\n+\n+  private ExecutorService executor = Executors.newSingleThreadExecutor();\n+\n+  public GazetteerQueryOfflineSolr(SolrClientFactory clientFactory) {\n+    this.clientFactory = clientFactory;\n+    this.client = clientFactory.newClient(OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME);\n+    executor.submit(\n+        () -> {\n+          SolrPingResponse ping =\n+              Failsafe.with(RETRY_POLICY)\n+                  .onFailure(\n+                      e ->\n+                          LOGGER.error(\n+                              \"Could not get solrclient to start initial suggester build for {} core. Please try to start a build manually with the `build-suggester-index` karaf command or by sending a request to solr with the property `suggest.build=true`\",\n+                              OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME,\n+                              e))\n+                  .get(() -> client.ping());\n+          SolrQuery query = new SolrQuery();\n+          query.setRequestHandler(\"/suggest\");\n+          query.setParam(\"suggest.build\", true);\n+          query.setParam(\"suggest.q\", \"GQOSInitialSuggesterBuild\");\n+          query.setParam(\"suggest.dictionary\", \"suggestPlace\");\n+          try {\n+            QueryResponse response = client.query(query);\n+            LOGGER.debug(\"Initial Suggester build response: {}\", response);\n+          } catch (SolrServerException | IOException e) {\n+            LOGGER.error(\n+                \"Error while trying to build initial suggester for {}\",\n+                OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME,\n+                e);\n+          }\n+        });\n+  }\n+\n+  @Override\n+  public List<GeoEntry> query(String queryString, int maxResults) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"title_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(queryString)));\n+    solrQuery.setRows(Math.min(maxResults, GazetteerQueryOfflineSolr.MAX_RESULTS));\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public GeoEntry queryById(String id) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"id_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(id)));\n+    solrQuery.setRows(1);\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .findFirst()\n+        .orElseThrow(() -> new GeoEntryQueryException(\"Could not find id\"));\n+  }\n+\n+  @Override\n+  public List<Suggestion> getSuggestedNames(String queryString, int maxResults)\n+      throws GeoEntryQueryException {\n+    SolrQuery solrQuery = new SolrQuery();\n+    solrQuery.setRequestHandler(\"/suggest\");\n+    solrQuery.setParam(SUGGEST_Q, ClientUtils.escapeQueryChars(queryString));\n+    solrQuery.setParam(SUGGEST_DICT, SUGGEST_PLACE_KEY);\n+    solrQuery.setParam(\"suggest.count\", Integer.toString(Math.min(maxResults, MAX_RESULTS)));\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Something went wrong when querying\", e);", "originalCommit": "88f357102c5f89f5b129ad7e7cdb633387426b7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE3OTY0NA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r449179644", "bodyText": "\u270f\ufe0f Could be final too.", "author": "pklinef", "createdAt": "2020-07-02T17:51:30Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.client.solrj.response.SolrPingResponse;\n+import org.apache.solr.client.solrj.response.SuggesterResponse;\n+import org.apache.solr.client.solrj.util.ClientUtils;\n+import org.apache.solr.common.SolrDocument;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntry;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryException;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryable;\n+import org.codice.ddf.spatial.geocoding.Suggestion;\n+import org.codice.ddf.spatial.geocoding.context.NearbyLocation;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.io.WKTReader;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GazetteerQueryOfflineSolr implements GeoEntryQueryable {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GazetteerQueryOfflineSolr.class);\n+\n+  private static final String CITY_SOLR_QUERY =\n+      GeoCodingConstants.CITY_FEATURE_CODES\n+          .stream()\n+          .map(fc -> String.format(\"ext.feature-code_txt:%s\", fc))\n+          .collect(Collectors.joining(\" OR \", \"(\", \")\"));\n+\n+  private static final ThreadLocal<WKTWriter> WKT_WRITER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTWriter::new);\n+\n+  private static final ThreadLocal<WKTReader> WKT_READER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTReader::new);\n+\n+  private static final RetryPolicy RETRY_POLICY =\n+      new RetryPolicy()\n+          .withMaxDuration(20, TimeUnit.SECONDS)\n+          .withBackoff(100, 1_000, TimeUnit.MILLISECONDS);\n+\n+  protected static final String SUGGEST_Q = \"suggest.q\";\n+  protected static final String SUGGEST_DICT = \"suggest.dictionary\";\n+  protected static final String SUGGEST_PLACE_KEY = \"suggestPlace\";\n+\n+  public static final int MAX_RESULTS = 100;\n+  public static final double KM_PER_DEGREE = 111.139;\n+\n+  private SolrClientFactory clientFactory;\n+\n+  private SolrClient client;\n+\n+  private ExecutorService executor = Executors.newSingleThreadExecutor();\n+\n+  public GazetteerQueryOfflineSolr(SolrClientFactory clientFactory) {\n+    this.clientFactory = clientFactory;\n+    this.client = clientFactory.newClient(OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME);\n+    executor.submit(\n+        () -> {\n+          SolrPingResponse ping =\n+              Failsafe.with(RETRY_POLICY)\n+                  .onFailure(\n+                      e ->\n+                          LOGGER.error(\n+                              \"Could not get solrclient to start initial suggester build for {} core. Please try to start a build manually with the `build-suggester-index` karaf command or by sending a request to solr with the property `suggest.build=true`\",\n+                              OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME,\n+                              e))\n+                  .get(() -> client.ping());\n+          SolrQuery query = new SolrQuery();\n+          query.setRequestHandler(\"/suggest\");\n+          query.setParam(\"suggest.build\", true);\n+          query.setParam(\"suggest.q\", \"GQOSInitialSuggesterBuild\");\n+          query.setParam(\"suggest.dictionary\", \"suggestPlace\");\n+          try {\n+            QueryResponse response = client.query(query);\n+            LOGGER.debug(\"Initial Suggester build response: {}\", response);\n+          } catch (SolrServerException | IOException e) {\n+            LOGGER.error(\n+                \"Error while trying to build initial suggester for {}\",\n+                OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME,\n+                e);\n+          }\n+        });\n+  }\n+\n+  @Override\n+  public List<GeoEntry> query(String queryString, int maxResults) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"title_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(queryString)));\n+    solrQuery.setRows(Math.min(maxResults, GazetteerQueryOfflineSolr.MAX_RESULTS));\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public GeoEntry queryById(String id) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"id_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(id)));\n+    solrQuery.setRows(1);\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .findFirst()\n+        .orElseThrow(() -> new GeoEntryQueryException(\"Could not find id\"));\n+  }\n+\n+  @Override\n+  public List<Suggestion> getSuggestedNames(String queryString, int maxResults)\n+      throws GeoEntryQueryException {\n+    SolrQuery solrQuery = new SolrQuery();\n+    solrQuery.setRequestHandler(\"/suggest\");\n+    solrQuery.setParam(SUGGEST_Q, ClientUtils.escapeQueryChars(queryString));\n+    solrQuery.setParam(SUGGEST_DICT, SUGGEST_PLACE_KEY);\n+    solrQuery.setParam(\"suggest.count\", Integer.toString(Math.min(maxResults, MAX_RESULTS)));\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Something went wrong when querying\", e);\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+\n+    return Optional.ofNullable(response)\n+        .map(QueryResponse::getSuggesterResponse)\n+        .map(SuggesterResponse::getSuggestions)\n+        .map(suggestionsPerDict -> suggestionsPerDict.get(SUGGEST_PLACE_KEY))\n+        .orElse(Collections.emptyList())\n+        .stream()\n+        .map(suggestion -> new SuggestionImpl(suggestion.getPayload(), suggestion.getTerm()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  public static class SuggestionImpl implements Suggestion {", "originalCommit": "88f357102c5f89f5b129ad7e7cdb633387426b7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4MDkxMQ==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r449180911", "bodyText": "\u270f\ufe0f conver to convert\nCould extract these lines to a method named something like convertKilometerToDegree and remove the comment instead.", "author": "pklinef", "createdAt": "2020-07-02T17:54:02Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.client.solrj.response.SolrPingResponse;\n+import org.apache.solr.client.solrj.response.SuggesterResponse;\n+import org.apache.solr.client.solrj.util.ClientUtils;\n+import org.apache.solr.common.SolrDocument;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntry;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryException;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryable;\n+import org.codice.ddf.spatial.geocoding.Suggestion;\n+import org.codice.ddf.spatial.geocoding.context.NearbyLocation;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.io.WKTReader;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GazetteerQueryOfflineSolr implements GeoEntryQueryable {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GazetteerQueryOfflineSolr.class);\n+\n+  private static final String CITY_SOLR_QUERY =\n+      GeoCodingConstants.CITY_FEATURE_CODES\n+          .stream()\n+          .map(fc -> String.format(\"ext.feature-code_txt:%s\", fc))\n+          .collect(Collectors.joining(\" OR \", \"(\", \")\"));\n+\n+  private static final ThreadLocal<WKTWriter> WKT_WRITER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTWriter::new);\n+\n+  private static final ThreadLocal<WKTReader> WKT_READER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTReader::new);\n+\n+  private static final RetryPolicy RETRY_POLICY =\n+      new RetryPolicy()\n+          .withMaxDuration(20, TimeUnit.SECONDS)\n+          .withBackoff(100, 1_000, TimeUnit.MILLISECONDS);\n+\n+  protected static final String SUGGEST_Q = \"suggest.q\";\n+  protected static final String SUGGEST_DICT = \"suggest.dictionary\";\n+  protected static final String SUGGEST_PLACE_KEY = \"suggestPlace\";\n+\n+  public static final int MAX_RESULTS = 100;\n+  public static final double KM_PER_DEGREE = 111.139;\n+\n+  private SolrClientFactory clientFactory;\n+\n+  private SolrClient client;\n+\n+  private ExecutorService executor = Executors.newSingleThreadExecutor();\n+\n+  public GazetteerQueryOfflineSolr(SolrClientFactory clientFactory) {\n+    this.clientFactory = clientFactory;\n+    this.client = clientFactory.newClient(OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME);\n+    executor.submit(\n+        () -> {\n+          SolrPingResponse ping =\n+              Failsafe.with(RETRY_POLICY)\n+                  .onFailure(\n+                      e ->\n+                          LOGGER.error(\n+                              \"Could not get solrclient to start initial suggester build for {} core. Please try to start a build manually with the `build-suggester-index` karaf command or by sending a request to solr with the property `suggest.build=true`\",\n+                              OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME,\n+                              e))\n+                  .get(() -> client.ping());\n+          SolrQuery query = new SolrQuery();\n+          query.setRequestHandler(\"/suggest\");\n+          query.setParam(\"suggest.build\", true);\n+          query.setParam(\"suggest.q\", \"GQOSInitialSuggesterBuild\");\n+          query.setParam(\"suggest.dictionary\", \"suggestPlace\");\n+          try {\n+            QueryResponse response = client.query(query);\n+            LOGGER.debug(\"Initial Suggester build response: {}\", response);\n+          } catch (SolrServerException | IOException e) {\n+            LOGGER.error(\n+                \"Error while trying to build initial suggester for {}\",\n+                OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME,\n+                e);\n+          }\n+        });\n+  }\n+\n+  @Override\n+  public List<GeoEntry> query(String queryString, int maxResults) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"title_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(queryString)));\n+    solrQuery.setRows(Math.min(maxResults, GazetteerQueryOfflineSolr.MAX_RESULTS));\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public GeoEntry queryById(String id) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"id_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(id)));\n+    solrQuery.setRows(1);\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .findFirst()\n+        .orElseThrow(() -> new GeoEntryQueryException(\"Could not find id\"));\n+  }\n+\n+  @Override\n+  public List<Suggestion> getSuggestedNames(String queryString, int maxResults)\n+      throws GeoEntryQueryException {\n+    SolrQuery solrQuery = new SolrQuery();\n+    solrQuery.setRequestHandler(\"/suggest\");\n+    solrQuery.setParam(SUGGEST_Q, ClientUtils.escapeQueryChars(queryString));\n+    solrQuery.setParam(SUGGEST_DICT, SUGGEST_PLACE_KEY);\n+    solrQuery.setParam(\"suggest.count\", Integer.toString(Math.min(maxResults, MAX_RESULTS)));\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Something went wrong when querying\", e);\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+\n+    return Optional.ofNullable(response)\n+        .map(QueryResponse::getSuggesterResponse)\n+        .map(SuggesterResponse::getSuggestions)\n+        .map(suggestionsPerDict -> suggestionsPerDict.get(SUGGEST_PLACE_KEY))\n+        .orElse(Collections.emptyList())\n+        .stream()\n+        .map(suggestion -> new SuggestionImpl(suggestion.getPayload(), suggestion.getTerm()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  public static class SuggestionImpl implements Suggestion {\n+    private final String id;\n+    private final String name;\n+\n+    public SuggestionImpl(String id, String name) {\n+      this.id = id;\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public String getId() {\n+      return id;\n+    }\n+\n+    @Override\n+    public String getName() {\n+      return name;\n+    }\n+  }\n+\n+  @Override\n+  public List<NearbyLocation> getNearestCities(String location, int radiusInKm, int maxResults)\n+      throws ParseException, GeoEntryQueryException {\n+    Geometry geometry;\n+    try {\n+      geometry = WKT_READER_THREAD_LOCAL.get().read(location);\n+    } catch (org.locationtech.jts.io.ParseException e) {\n+      throw new GeoEntryQueryException(\"Could not parse location\");\n+    }\n+    // conver km to rough degree measurement, approximately 111km per degree", "originalCommit": "88f357102c5f89f5b129ad7e7cdb633387426b7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyMjY2Mw==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451222663", "bodyText": "I think these are parts of the computation I mentioned earlier that you could extract into a separate class and test separately - then some constants needn't be public and shared anymore but the class that does the computation would just be injected instead.", "author": "Lambeaux", "createdAt": "2020-07-08T00:55:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4MDkxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzg4MDU3Mg==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r453880572", "bodyText": "@Lambeaux I did extract to methods so they are reused, though I don't feel like I have enough here to justify a full class for them.", "author": "rzwiefel", "createdAt": "2020-07-13T19:27:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4MDkxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4MTcwNg==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r449181706", "bodyText": "\u270f\ufe0f Another log and throw.", "author": "pklinef", "createdAt": "2020-07-02T17:55:41Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.client.solrj.response.SolrPingResponse;\n+import org.apache.solr.client.solrj.response.SuggesterResponse;\n+import org.apache.solr.client.solrj.util.ClientUtils;\n+import org.apache.solr.common.SolrDocument;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntry;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryException;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryable;\n+import org.codice.ddf.spatial.geocoding.Suggestion;\n+import org.codice.ddf.spatial.geocoding.context.NearbyLocation;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.io.WKTReader;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GazetteerQueryOfflineSolr implements GeoEntryQueryable {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GazetteerQueryOfflineSolr.class);\n+\n+  private static final String CITY_SOLR_QUERY =\n+      GeoCodingConstants.CITY_FEATURE_CODES\n+          .stream()\n+          .map(fc -> String.format(\"ext.feature-code_txt:%s\", fc))\n+          .collect(Collectors.joining(\" OR \", \"(\", \")\"));\n+\n+  private static final ThreadLocal<WKTWriter> WKT_WRITER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTWriter::new);\n+\n+  private static final ThreadLocal<WKTReader> WKT_READER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTReader::new);\n+\n+  private static final RetryPolicy RETRY_POLICY =\n+      new RetryPolicy()\n+          .withMaxDuration(20, TimeUnit.SECONDS)\n+          .withBackoff(100, 1_000, TimeUnit.MILLISECONDS);\n+\n+  protected static final String SUGGEST_Q = \"suggest.q\";\n+  protected static final String SUGGEST_DICT = \"suggest.dictionary\";\n+  protected static final String SUGGEST_PLACE_KEY = \"suggestPlace\";\n+\n+  public static final int MAX_RESULTS = 100;\n+  public static final double KM_PER_DEGREE = 111.139;\n+\n+  private SolrClientFactory clientFactory;\n+\n+  private SolrClient client;\n+\n+  private ExecutorService executor = Executors.newSingleThreadExecutor();\n+\n+  public GazetteerQueryOfflineSolr(SolrClientFactory clientFactory) {\n+    this.clientFactory = clientFactory;\n+    this.client = clientFactory.newClient(OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME);\n+    executor.submit(\n+        () -> {\n+          SolrPingResponse ping =\n+              Failsafe.with(RETRY_POLICY)\n+                  .onFailure(\n+                      e ->\n+                          LOGGER.error(\n+                              \"Could not get solrclient to start initial suggester build for {} core. Please try to start a build manually with the `build-suggester-index` karaf command or by sending a request to solr with the property `suggest.build=true`\",\n+                              OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME,\n+                              e))\n+                  .get(() -> client.ping());\n+          SolrQuery query = new SolrQuery();\n+          query.setRequestHandler(\"/suggest\");\n+          query.setParam(\"suggest.build\", true);\n+          query.setParam(\"suggest.q\", \"GQOSInitialSuggesterBuild\");\n+          query.setParam(\"suggest.dictionary\", \"suggestPlace\");\n+          try {\n+            QueryResponse response = client.query(query);\n+            LOGGER.debug(\"Initial Suggester build response: {}\", response);\n+          } catch (SolrServerException | IOException e) {\n+            LOGGER.error(\n+                \"Error while trying to build initial suggester for {}\",\n+                OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME,\n+                e);\n+          }\n+        });\n+  }\n+\n+  @Override\n+  public List<GeoEntry> query(String queryString, int maxResults) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"title_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(queryString)));\n+    solrQuery.setRows(Math.min(maxResults, GazetteerQueryOfflineSolr.MAX_RESULTS));\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public GeoEntry queryById(String id) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"id_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(id)));\n+    solrQuery.setRows(1);\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .findFirst()\n+        .orElseThrow(() -> new GeoEntryQueryException(\"Could not find id\"));\n+  }\n+\n+  @Override\n+  public List<Suggestion> getSuggestedNames(String queryString, int maxResults)\n+      throws GeoEntryQueryException {\n+    SolrQuery solrQuery = new SolrQuery();\n+    solrQuery.setRequestHandler(\"/suggest\");\n+    solrQuery.setParam(SUGGEST_Q, ClientUtils.escapeQueryChars(queryString));\n+    solrQuery.setParam(SUGGEST_DICT, SUGGEST_PLACE_KEY);\n+    solrQuery.setParam(\"suggest.count\", Integer.toString(Math.min(maxResults, MAX_RESULTS)));\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Something went wrong when querying\", e);\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+\n+    return Optional.ofNullable(response)\n+        .map(QueryResponse::getSuggesterResponse)\n+        .map(SuggesterResponse::getSuggestions)\n+        .map(suggestionsPerDict -> suggestionsPerDict.get(SUGGEST_PLACE_KEY))\n+        .orElse(Collections.emptyList())\n+        .stream()\n+        .map(suggestion -> new SuggestionImpl(suggestion.getPayload(), suggestion.getTerm()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  public static class SuggestionImpl implements Suggestion {\n+    private final String id;\n+    private final String name;\n+\n+    public SuggestionImpl(String id, String name) {\n+      this.id = id;\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public String getId() {\n+      return id;\n+    }\n+\n+    @Override\n+    public String getName() {\n+      return name;\n+    }\n+  }\n+\n+  @Override\n+  public List<NearbyLocation> getNearestCities(String location, int radiusInKm, int maxResults)\n+      throws ParseException, GeoEntryQueryException {\n+    Geometry geometry;\n+    try {\n+      geometry = WKT_READER_THREAD_LOCAL.get().read(location);\n+    } catch (org.locationtech.jts.io.ParseException e) {\n+      throw new GeoEntryQueryException(\"Could not parse location\");\n+    }\n+    // conver km to rough degree measurement, approximately 111km per degree\n+    double distanceInDegrees = radiusInKm / KM_PER_DEGREE;\n+    final Geometry originalGeometry = geometry;\n+    Geometry bufferedGeo = originalGeometry.buffer(distanceInDegrees, 14);\n+    String wkt = WKT_WRITER_THREAD_LOCAL.get().write(bufferedGeo);\n+\n+    String q =\n+        String.format(\n+            \"location_geo_index:\\\"Intersects( %s ) AND %s\\\"\",\n+            ClientUtils.escapeQueryChars(wkt), CITY_SOLR_QUERY);\n+\n+    SolrQuery solrQuery = new SolrQuery(q);\n+    solrQuery.setRows(Math.min(maxResults, MAX_RESULTS));\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Error executing query for nearest cities\", e);", "originalCommit": "88f357102c5f89f5b129ad7e7cdb633387426b7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NTczOA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r449185738", "bodyText": "\u270f\ufe0f .filter(s -> !s.isEmpty())\nhttps://docs.oracle.com/javase/7/docs/api/java/lang/String.html#isEmpty()", "author": "pklinef", "createdAt": "2020-07-02T18:03:10Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.client.solrj.response.SolrPingResponse;\n+import org.apache.solr.client.solrj.response.SuggesterResponse;\n+import org.apache.solr.client.solrj.util.ClientUtils;\n+import org.apache.solr.common.SolrDocument;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntry;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryException;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryable;\n+import org.codice.ddf.spatial.geocoding.Suggestion;\n+import org.codice.ddf.spatial.geocoding.context.NearbyLocation;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.io.WKTReader;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GazetteerQueryOfflineSolr implements GeoEntryQueryable {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GazetteerQueryOfflineSolr.class);\n+\n+  private static final String CITY_SOLR_QUERY =\n+      GeoCodingConstants.CITY_FEATURE_CODES\n+          .stream()\n+          .map(fc -> String.format(\"ext.feature-code_txt:%s\", fc))\n+          .collect(Collectors.joining(\" OR \", \"(\", \")\"));\n+\n+  private static final ThreadLocal<WKTWriter> WKT_WRITER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTWriter::new);\n+\n+  private static final ThreadLocal<WKTReader> WKT_READER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTReader::new);\n+\n+  private static final RetryPolicy RETRY_POLICY =\n+      new RetryPolicy()\n+          .withMaxDuration(20, TimeUnit.SECONDS)\n+          .withBackoff(100, 1_000, TimeUnit.MILLISECONDS);\n+\n+  protected static final String SUGGEST_Q = \"suggest.q\";\n+  protected static final String SUGGEST_DICT = \"suggest.dictionary\";\n+  protected static final String SUGGEST_PLACE_KEY = \"suggestPlace\";\n+\n+  public static final int MAX_RESULTS = 100;\n+  public static final double KM_PER_DEGREE = 111.139;\n+\n+  private SolrClientFactory clientFactory;\n+\n+  private SolrClient client;\n+\n+  private ExecutorService executor = Executors.newSingleThreadExecutor();\n+\n+  public GazetteerQueryOfflineSolr(SolrClientFactory clientFactory) {\n+    this.clientFactory = clientFactory;\n+    this.client = clientFactory.newClient(OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME);\n+    executor.submit(\n+        () -> {\n+          SolrPingResponse ping =\n+              Failsafe.with(RETRY_POLICY)\n+                  .onFailure(\n+                      e ->\n+                          LOGGER.error(\n+                              \"Could not get solrclient to start initial suggester build for {} core. Please try to start a build manually with the `build-suggester-index` karaf command or by sending a request to solr with the property `suggest.build=true`\",\n+                              OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME,\n+                              e))\n+                  .get(() -> client.ping());\n+          SolrQuery query = new SolrQuery();\n+          query.setRequestHandler(\"/suggest\");\n+          query.setParam(\"suggest.build\", true);\n+          query.setParam(\"suggest.q\", \"GQOSInitialSuggesterBuild\");\n+          query.setParam(\"suggest.dictionary\", \"suggestPlace\");\n+          try {\n+            QueryResponse response = client.query(query);\n+            LOGGER.debug(\"Initial Suggester build response: {}\", response);\n+          } catch (SolrServerException | IOException e) {\n+            LOGGER.error(\n+                \"Error while trying to build initial suggester for {}\",\n+                OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME,\n+                e);\n+          }\n+        });\n+  }\n+\n+  @Override\n+  public List<GeoEntry> query(String queryString, int maxResults) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"title_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(queryString)));\n+    solrQuery.setRows(Math.min(maxResults, GazetteerQueryOfflineSolr.MAX_RESULTS));\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public GeoEntry queryById(String id) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"id_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(id)));\n+    solrQuery.setRows(1);\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .findFirst()\n+        .orElseThrow(() -> new GeoEntryQueryException(\"Could not find id\"));\n+  }\n+\n+  @Override\n+  public List<Suggestion> getSuggestedNames(String queryString, int maxResults)\n+      throws GeoEntryQueryException {\n+    SolrQuery solrQuery = new SolrQuery();\n+    solrQuery.setRequestHandler(\"/suggest\");\n+    solrQuery.setParam(SUGGEST_Q, ClientUtils.escapeQueryChars(queryString));\n+    solrQuery.setParam(SUGGEST_DICT, SUGGEST_PLACE_KEY);\n+    solrQuery.setParam(\"suggest.count\", Integer.toString(Math.min(maxResults, MAX_RESULTS)));\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Something went wrong when querying\", e);\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+\n+    return Optional.ofNullable(response)\n+        .map(QueryResponse::getSuggesterResponse)\n+        .map(SuggesterResponse::getSuggestions)\n+        .map(suggestionsPerDict -> suggestionsPerDict.get(SUGGEST_PLACE_KEY))\n+        .orElse(Collections.emptyList())\n+        .stream()\n+        .map(suggestion -> new SuggestionImpl(suggestion.getPayload(), suggestion.getTerm()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  public static class SuggestionImpl implements Suggestion {\n+    private final String id;\n+    private final String name;\n+\n+    public SuggestionImpl(String id, String name) {\n+      this.id = id;\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public String getId() {\n+      return id;\n+    }\n+\n+    @Override\n+    public String getName() {\n+      return name;\n+    }\n+  }\n+\n+  @Override\n+  public List<NearbyLocation> getNearestCities(String location, int radiusInKm, int maxResults)\n+      throws ParseException, GeoEntryQueryException {\n+    Geometry geometry;\n+    try {\n+      geometry = WKT_READER_THREAD_LOCAL.get().read(location);\n+    } catch (org.locationtech.jts.io.ParseException e) {\n+      throw new GeoEntryQueryException(\"Could not parse location\");\n+    }\n+    // conver km to rough degree measurement, approximately 111km per degree\n+    double distanceInDegrees = radiusInKm / KM_PER_DEGREE;\n+    final Geometry originalGeometry = geometry;\n+    Geometry bufferedGeo = originalGeometry.buffer(distanceInDegrees, 14);\n+    String wkt = WKT_WRITER_THREAD_LOCAL.get().write(bufferedGeo);\n+\n+    String q =\n+        String.format(\n+            \"location_geo_index:\\\"Intersects( %s ) AND %s\\\"\",\n+            ClientUtils.escapeQueryChars(wkt), CITY_SOLR_QUERY);\n+\n+    SolrQuery solrQuery = new SolrQuery(q);\n+    solrQuery.setRows(Math.min(maxResults, MAX_RESULTS));\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Error executing query for nearest cities\", e);\n+      throw new GeoEntryQueryException(\"Error executing query\", e);\n+    }\n+\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(result -> convert(result, originalGeometry))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private NearbyLocation convert(SolrDocument doc, Geometry originalLocation) {\n+    String location = getField(doc, \"location_geo\", String.class);\n+    String title =\n+        Optional.ofNullable(getField(doc, \"title_txt\", String.class))\n+            .filter(Objects::nonNull)\n+            .filter(s -> !\"\".equals(s))", "originalCommit": "88f357102c5f89f5b129ad7e7cdb633387426b7e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyMzY5Ng==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451223696", "bodyText": "Because of the .filter(Objects::nonNull) I agree with @pklinef otherwise yeah I see why you did this.", "author": "Lambeaux", "createdAt": "2020-07-08T00:59:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NTczOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY0ODI2NA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451648264", "bodyText": "Either way is fine.  Here is what the other implementation will do instead.\nhttps://github.com/AdoptOpenJDK/openjdk-jdk8u/blob/master/jdk/src/share/classes/java/lang/String.java#L634-L636", "author": "pklinef", "createdAt": "2020-07-08T15:50:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTE4NTczOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI4OTQyOA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r449289428", "bodyText": "\u2753 Wonder if we need to worry about self intersecting geometries here too.  I think we might have to.\n\n  \n    \n      ddf/catalog/solr/catalog-solr-core/src/main/java/ddf/catalog/source/solr/SolrFilterDelegate.java\n    \n    \n        Lines 738 to 763\n      in\n      21ddc98\n    \n    \n    \n    \n\n        \n          \n           private Geometry getGeometry(String wkt) { \n        \n\n        \n          \n             WKTReader reader = new WKTReader(GEOMETRY_FACTORY); \n        \n\n        \n          \n            \n        \n\n        \n          \n             Geometry geo = null; \n        \n\n        \n          \n             try { \n        \n\n        \n          \n               geo = reader.read(fixSelfIntersectingGeometry(wkt)); \n        \n\n        \n          \n             } catch (ParseException e) { \n        \n\n        \n          \n               LOGGER.info(\"Failed to read WKT: {}\", wkt, e); \n        \n\n        \n          \n             } \n        \n\n        \n          \n             return geo; \n        \n\n        \n          \n           } \n        \n\n        \n          \n            \n        \n\n        \n          \n           private String fixSelfIntersectingGeometry(String wkt) { \n        \n\n        \n          \n             try { \n        \n\n        \n          \n               Shape wktShape = WKT_READER.read(wkt); \n        \n\n        \n          \n               // All polygons will be an instance of JtsGeometry. If it is not a polygon we don't need \n        \n\n        \n          \n               // to do anything with it so just return the original wkt string. \n        \n\n        \n          \n               if (!(wktShape instanceof JtsGeometry)) { \n        \n\n        \n          \n                 return wkt; \n        \n\n        \n          \n               } \n        \n\n        \n          \n               return SPATIAL_CONTEXT.getFormats().getWktWriter().toString(wktShape); \n        \n\n        \n          \n             } catch (IOException | java.text.ParseException | InvalidShapeException e) { \n        \n\n        \n          \n               LOGGER.info(\"Failed to fix or read WKT: {}\", wkt, e); \n        \n\n        \n          \n             } \n        \n\n        \n          \n             return wkt; \n        \n\n        \n          \n           }", "author": "pklinef", "createdAt": "2020-07-02T22:15:48Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java", "diffHunk": "@@ -0,0 +1,425 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.Executors;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.client.solrj.response.SolrPingResponse;\n+import org.apache.solr.client.solrj.response.SuggesterResponse;\n+import org.apache.solr.client.solrj.util.ClientUtils;\n+import org.apache.solr.common.SolrDocument;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntry;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryException;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryable;\n+import org.codice.ddf.spatial.geocoding.Suggestion;\n+import org.codice.ddf.spatial.geocoding.context.NearbyLocation;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.io.WKTReader;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GazetteerQueryOfflineSolr implements GeoEntryQueryable {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GazetteerQueryOfflineSolr.class);\n+\n+  private static final String CITY_SOLR_QUERY =\n+      GeoCodingConstants.CITY_FEATURE_CODES\n+          .stream()\n+          .map(fc -> String.format(\"ext.feature-code_txt:%s\", fc))\n+          .collect(Collectors.joining(\" OR \", \"(\", \")\"));\n+\n+  private static final ThreadLocal<WKTWriter> WKT_WRITER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTWriter::new);\n+\n+  private static final ThreadLocal<WKTReader> WKT_READER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTReader::new);\n+\n+  private static final RetryPolicy RETRY_POLICY =\n+      new RetryPolicy()\n+          .withMaxDuration(20, TimeUnit.SECONDS)\n+          .withBackoff(100, 1_000, TimeUnit.MILLISECONDS);\n+\n+  protected static final String SUGGEST_Q = \"suggest.q\";\n+  protected static final String SUGGEST_DICT = \"suggest.dictionary\";\n+  protected static final String SUGGEST_PLACE_KEY = \"suggestPlace\";\n+\n+  public static final int MAX_RESULTS = 100;\n+  public static final double KM_PER_DEGREE = 111.139;\n+\n+  private SolrClientFactory clientFactory;\n+\n+  private SolrClient client;\n+\n+  private ExecutorService executor = Executors.newSingleThreadExecutor();\n+\n+  public GazetteerQueryOfflineSolr(SolrClientFactory clientFactory) {\n+    this.clientFactory = clientFactory;\n+    this.client = clientFactory.newClient(OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME);\n+    executor.submit(\n+        () -> {\n+          SolrPingResponse ping =\n+              Failsafe.with(RETRY_POLICY)\n+                  .onFailure(\n+                      e ->\n+                          LOGGER.error(\n+                              \"Could not get solrclient to start initial suggester build for {} core. Please try to start a build manually with the `build-suggester-index` karaf command or by sending a request to solr with the property `suggest.build=true`\",\n+                              OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME,\n+                              e))\n+                  .get(() -> client.ping());\n+          SolrQuery query = new SolrQuery();\n+          query.setRequestHandler(\"/suggest\");\n+          query.setParam(\"suggest.build\", true);\n+          query.setParam(\"suggest.q\", \"GQOSInitialSuggesterBuild\");\n+          query.setParam(\"suggest.dictionary\", \"suggestPlace\");\n+          try {\n+            QueryResponse response = client.query(query);\n+            LOGGER.debug(\"Initial Suggester build response: {}\", response);\n+          } catch (SolrServerException | IOException e) {\n+            LOGGER.error(\n+                \"Error while trying to build initial suggester for {}\",\n+                OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME,\n+                e);\n+          }\n+        });\n+  }\n+\n+  @Override\n+  public List<GeoEntry> query(String queryString, int maxResults) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"title_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(queryString)));\n+    solrQuery.setRows(Math.min(maxResults, GazetteerQueryOfflineSolr.MAX_RESULTS));\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public GeoEntry queryById(String id) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"id_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(id)));\n+    solrQuery.setRows(1);\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .findFirst()\n+        .orElseThrow(() -> new GeoEntryQueryException(\"Could not find id\"));\n+  }\n+\n+  @Override\n+  public List<Suggestion> getSuggestedNames(String queryString, int maxResults)\n+      throws GeoEntryQueryException {\n+    SolrQuery solrQuery = new SolrQuery();\n+    solrQuery.setRequestHandler(\"/suggest\");\n+    solrQuery.setParam(SUGGEST_Q, ClientUtils.escapeQueryChars(queryString));\n+    solrQuery.setParam(SUGGEST_DICT, SUGGEST_PLACE_KEY);\n+    solrQuery.setParam(\"suggest.count\", Integer.toString(Math.min(maxResults, MAX_RESULTS)));\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Something went wrong when querying\", e);\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+\n+    return Optional.ofNullable(response)\n+        .map(QueryResponse::getSuggesterResponse)\n+        .map(SuggesterResponse::getSuggestions)\n+        .map(suggestionsPerDict -> suggestionsPerDict.get(SUGGEST_PLACE_KEY))\n+        .orElse(Collections.emptyList())\n+        .stream()\n+        .map(suggestion -> new SuggestionImpl(suggestion.getPayload(), suggestion.getTerm()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  public static class SuggestionImpl implements Suggestion {\n+    private final String id;\n+    private final String name;\n+\n+    public SuggestionImpl(String id, String name) {\n+      this.id = id;\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public String getId() {\n+      return id;\n+    }\n+\n+    @Override\n+    public String getName() {\n+      return name;\n+    }\n+  }\n+\n+  @Override\n+  public List<NearbyLocation> getNearestCities(String location, int radiusInKm, int maxResults)\n+      throws ParseException, GeoEntryQueryException {\n+    Geometry geometry;\n+    try {\n+      geometry = WKT_READER_THREAD_LOCAL.get().read(location);\n+    } catch (org.locationtech.jts.io.ParseException e) {\n+      throw new GeoEntryQueryException(\"Could not parse location\");\n+    }\n+    // conver km to rough degree measurement, approximately 111km per degree\n+    double distanceInDegrees = radiusInKm / KM_PER_DEGREE;\n+    final Geometry originalGeometry = geometry;\n+    Geometry bufferedGeo = originalGeometry.buffer(distanceInDegrees, 14);\n+    String wkt = WKT_WRITER_THREAD_LOCAL.get().write(bufferedGeo);\n+\n+    String q =\n+        String.format(\n+            \"location_geo_index:\\\"Intersects( %s ) AND %s\\\"\",\n+            ClientUtils.escapeQueryChars(wkt), CITY_SOLR_QUERY);\n+\n+    SolrQuery solrQuery = new SolrQuery(q);\n+    solrQuery.setRows(Math.min(maxResults, MAX_RESULTS));\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Error executing query for nearest cities\", e);\n+      throw new GeoEntryQueryException(\"Error executing query\", e);\n+    }\n+\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(result -> convert(result, originalGeometry))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private NearbyLocation convert(SolrDocument doc, Geometry originalLocation) {\n+    String location = getField(doc, \"location_geo\", String.class);\n+    String title =\n+        Optional.ofNullable(getField(doc, \"title_txt\", String.class))\n+            .filter(Objects::nonNull)\n+            .filter(s -> !\"\".equals(s))\n+            .orElse(\"NO TITLE\");\n+\n+    String cardinalDirection = \"\";\n+    double distance = 0;\n+    try {\n+      Geometry geo = WKT_READER_THREAD_LOCAL.get().read(location);\n+      cardinalDirection =\n+          bearingToCardinalDirection(getBearing(originalLocation.getCentroid(), geo.getCentroid()));\n+      // convert distance to KM\n+      distance = originalLocation.distance(geo.getCentroid()) * KM_PER_DEGREE;\n+    } catch (org.locationtech.jts.io.ParseException e) {\n+      LOGGER.debug(\"Could not parse location for item (object: {})\", doc.toString(), e);\n+    }\n+\n+    return new NearbyLocationImpl(title, cardinalDirection, distance);\n+  }\n+\n+  public static class NearbyLocationImpl implements NearbyLocation {\n+    private final String name;\n+    private final String cardinalDirection;\n+    private final double distance;\n+\n+    public NearbyLocationImpl(String name, String cardinalDirection, double distance) {\n+      this.name = name;\n+      this.cardinalDirection = cardinalDirection;\n+      this.distance = distance;\n+    }\n+\n+    @Override\n+    public String getName() {\n+      return name;\n+    }\n+\n+    @Override\n+    public String getCardinalDirection() {\n+      return cardinalDirection;\n+    }\n+\n+    @Override\n+    public double getDistance() {\n+      return distance;\n+    }\n+  }\n+  /**\n+   * Calculates the bearing from the start point to the end point (i.e., the <em>initial bearing\n+   * </em>) in degrees.\n+   *\n+   * @param startPoint the point from which to start\n+   * @param endPoint the point at which to end\n+   * @return the bearing from {@code startPoint} to {@code endPoint}, in degrees\n+   */\n+  private static double getBearing(final Point startPoint, final Point endPoint) {\n+    final double lat1 = startPoint.getY();\n+    final double lon1 = startPoint.getX();\n+\n+    final double lat2 = endPoint.getY();\n+    final double lon2 = endPoint.getX();\n+\n+    final double lonDiffRads = Math.toRadians(lon2 - lon1);\n+    final double lat1Rads = Math.toRadians(lat1);\n+    final double lat2Rads = Math.toRadians(lat2);\n+    final double y = Math.sin(lonDiffRads) * Math.cos(lat2Rads);\n+    final double x =\n+        Math.cos(lat1Rads) * Math.sin(lat2Rads)\n+            - Math.sin(lat1Rads) * Math.cos(lat2Rads) * Math.cos(lonDiffRads);\n+\n+    return (Math.toDegrees(Math.atan2(y, x)) + 360) % 360;\n+  }\n+\n+  /**\n+   * Takes a bearing in degrees and returns the corresponding cardinal direction as a string.\n+   *\n+   * @param bearing the bearing, in degrees\n+   * @return the cardinal direction corresponding to {@code bearing} (N, NE, E, SE, S, SW, W, NW)\n+   */\n+  private static String bearingToCardinalDirection(final double bearing) {\n+    final String[] directions = {\"N\", \"NE\", \"E\", \"SE\", \"S\", \"SW\", \"W\", \"NW\", \"N\"};\n+    return directions[(int) Math.round(bearing / 45)];\n+  }\n+\n+  @Override\n+  public Optional<String> getCountryCode(String wktLocation, int radius)\n+      throws GeoEntryQueryException, ParseException {\n+    String wkt;\n+    try {\n+      Point center = WKT_READER_THREAD_LOCAL.get().read(wktLocation).getCentroid();", "originalCommit": "88f357102c5f89f5b129ad7e7cdb633387426b7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0OTI5MzE4MQ==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r449293181", "bodyText": "\u270f\ufe0f More log and throw to remove in this class.", "author": "pklinef", "createdAt": "2020-07-02T22:29:19Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/OfflineGazetteerPlugin.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import static ddf.catalog.Constants.SUGGESTION_BUILD_KEY;\n+\n+import ddf.catalog.data.Attribute;\n+import ddf.catalog.data.Metacard;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import ddf.catalog.operation.CreateResponse;\n+import ddf.catalog.operation.DeleteResponse;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.Update;\n+import ddf.catalog.operation.UpdateResponse;\n+import ddf.catalog.plugin.PluginExecutionException;\n+import ddf.catalog.plugin.PostIngestPlugin;\n+import ddf.catalog.plugin.PreQueryPlugin;\n+import ddf.catalog.plugin.StopProcessingException;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class OfflineGazetteerPlugin implements PostIngestPlugin, PreQueryPlugin {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(OfflineGazetteerPlugin.class);\n+  private static final String GAZETTEER_METACARD_TAG = \"gazetteer\";\n+  public static final String STANDALONE_GAZETTEER_CORE_NAME = \"standalone-solr-gazetteer\";\n+\n+  private final SolrClientFactory clientFactory;\n+  private final SolrClient solrClient;\n+\n+  public OfflineGazetteerPlugin(SolrClientFactory clientFactory) {\n+    this.clientFactory = clientFactory;\n+    this.solrClient = clientFactory.newClient(STANDALONE_GAZETTEER_CORE_NAME);\n+  }\n+\n+  @Override\n+  public CreateResponse process(CreateResponse input) throws PluginExecutionException {\n+    List<Metacard> gazetteerMetacards =\n+        input\n+            .getCreatedMetacards()\n+            .stream()\n+            .filter(this::isGazetteerMetacard)\n+            .collect(Collectors.toList());\n+\n+    if (gazetteerMetacards.isEmpty()) {\n+      return input;\n+    }\n+\n+    try {\n+      solrClient.add(\n+          STANDALONE_GAZETTEER_CORE_NAME,\n+          gazetteerMetacards\n+              .stream()\n+              .map(OfflineGazetteerPlugin::convert)\n+              .collect(Collectors.toList()));\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Error while processing gazetteer data\", e);", "originalCommit": "88f357102c5f89f5b129ad7e7cdb633387426b7e", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2Nzc1OQ==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451167759", "bodyText": "\u270f\ufe0f  Are these all expected to be used as keys? If so, why is SUGGEST_PLACE the only one suffixed as such?", "author": "Lambeaux", "createdAt": "2020-07-07T21:58:37Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.client.solrj.response.SolrPingResponse;\n+import org.apache.solr.client.solrj.response.SuggesterResponse;\n+import org.apache.solr.client.solrj.util.ClientUtils;\n+import org.apache.solr.common.SolrDocument;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntry;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryException;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryable;\n+import org.codice.ddf.spatial.geocoding.Suggestion;\n+import org.codice.ddf.spatial.geocoding.context.NearbyLocation;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.io.WKTReader;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GazetteerQueryOfflineSolr implements GeoEntryQueryable {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GazetteerQueryOfflineSolr.class);\n+\n+  private static final String CITY_SOLR_QUERY =\n+      GeoCodingConstants.CITY_FEATURE_CODES\n+          .stream()\n+          .map(fc -> String.format(\"ext.feature-code_txt:%s\", fc))\n+          .collect(Collectors.joining(\" OR \", \"(\", \")\"));\n+\n+  private static final ThreadLocal<WKTWriter> WKT_WRITER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTWriter::new);\n+\n+  private static final ThreadLocal<WKTReader> WKT_READER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTReader::new);\n+\n+  protected static final String SUGGEST_Q = \"suggest.q\";\n+  protected static final String SUGGEST_DICT = \"suggest.dictionary\";\n+  protected static final String SUGGEST_PLACE_KEY = \"suggestPlace\";", "originalCommit": "da7f3def8635d75cf1d73988ed479c2def44f589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkzNzk2MQ==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r453937961", "bodyText": "Ironically, SUGGEST_PLACE_KEY is the only one thats not a literal key. I called it a key because in my head it was like the value that was the target dictionary. I've revised the name to make more sense.", "author": "rzwiefel", "createdAt": "2020-07-13T21:16:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTE2Nzc1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxMDE0MA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451210140", "bodyText": "\u270f\ufe0f  I agree it's not worth making a constants class for these, but I would add a line comment briefly describing why the values are useful to share within this module. Something along the lines that the same calculations made here need to occur in the plugin as well.\nAlternatively, if they are similar enough, I would extract the operations into a new class and move these constants there, and make them private.", "author": "Lambeaux", "createdAt": "2020-07-08T00:06:06Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.client.solrj.response.SolrPingResponse;\n+import org.apache.solr.client.solrj.response.SuggesterResponse;\n+import org.apache.solr.client.solrj.util.ClientUtils;\n+import org.apache.solr.common.SolrDocument;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntry;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryException;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryable;\n+import org.codice.ddf.spatial.geocoding.Suggestion;\n+import org.codice.ddf.spatial.geocoding.context.NearbyLocation;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.io.WKTReader;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GazetteerQueryOfflineSolr implements GeoEntryQueryable {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GazetteerQueryOfflineSolr.class);\n+\n+  private static final String CITY_SOLR_QUERY =\n+      GeoCodingConstants.CITY_FEATURE_CODES\n+          .stream()\n+          .map(fc -> String.format(\"ext.feature-code_txt:%s\", fc))\n+          .collect(Collectors.joining(\" OR \", \"(\", \")\"));\n+\n+  private static final ThreadLocal<WKTWriter> WKT_WRITER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTWriter::new);\n+\n+  private static final ThreadLocal<WKTReader> WKT_READER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTReader::new);\n+\n+  protected static final String SUGGEST_Q = \"suggest.q\";\n+  protected static final String SUGGEST_DICT = \"suggest.dictionary\";\n+  protected static final String SUGGEST_PLACE_KEY = \"suggestPlace\";\n+\n+  public static final int MAX_RESULTS = 100;\n+  public static final double KM_PER_DEGREE = 111.139;", "originalCommit": "da7f3def8635d75cf1d73988ed479c2def44f589", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxNDY3OQ==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451214679", "bodyText": "\u2757 final - I didn't see this getting reassigned anywhere.", "author": "Lambeaux", "createdAt": "2020-07-08T00:23:49Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.client.solrj.response.SolrPingResponse;\n+import org.apache.solr.client.solrj.response.SuggesterResponse;\n+import org.apache.solr.client.solrj.util.ClientUtils;\n+import org.apache.solr.common.SolrDocument;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntry;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryException;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryable;\n+import org.codice.ddf.spatial.geocoding.Suggestion;\n+import org.codice.ddf.spatial.geocoding.context.NearbyLocation;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.io.WKTReader;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GazetteerQueryOfflineSolr implements GeoEntryQueryable {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GazetteerQueryOfflineSolr.class);\n+\n+  private static final String CITY_SOLR_QUERY =\n+      GeoCodingConstants.CITY_FEATURE_CODES\n+          .stream()\n+          .map(fc -> String.format(\"ext.feature-code_txt:%s\", fc))\n+          .collect(Collectors.joining(\" OR \", \"(\", \")\"));\n+\n+  private static final ThreadLocal<WKTWriter> WKT_WRITER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTWriter::new);\n+\n+  private static final ThreadLocal<WKTReader> WKT_READER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTReader::new);\n+\n+  protected static final String SUGGEST_Q = \"suggest.q\";\n+  protected static final String SUGGEST_DICT = \"suggest.dictionary\";\n+  protected static final String SUGGEST_PLACE_KEY = \"suggestPlace\";\n+\n+  public static final int MAX_RESULTS = 100;\n+  public static final double KM_PER_DEGREE = 111.139;\n+\n+  private SolrClientFactory clientFactory;", "originalCommit": "da7f3def8635d75cf1d73988ed479c2def44f589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTYyOTUzMQ==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451629531", "bodyText": "might not need to be a class variable. look like it is assigned and used in the constructor", "author": "lamhuy", "createdAt": "2020-07-08T15:23:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxNDY3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxNDY5Ng==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451214696", "bodyText": "\u2757 final - I didn't see this getting reassigned anywhere.", "author": "Lambeaux", "createdAt": "2020-07-08T00:23:54Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.client.solrj.response.SolrPingResponse;\n+import org.apache.solr.client.solrj.response.SuggesterResponse;\n+import org.apache.solr.client.solrj.util.ClientUtils;\n+import org.apache.solr.common.SolrDocument;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntry;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryException;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryable;\n+import org.codice.ddf.spatial.geocoding.Suggestion;\n+import org.codice.ddf.spatial.geocoding.context.NearbyLocation;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.io.WKTReader;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GazetteerQueryOfflineSolr implements GeoEntryQueryable {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GazetteerQueryOfflineSolr.class);\n+\n+  private static final String CITY_SOLR_QUERY =\n+      GeoCodingConstants.CITY_FEATURE_CODES\n+          .stream()\n+          .map(fc -> String.format(\"ext.feature-code_txt:%s\", fc))\n+          .collect(Collectors.joining(\" OR \", \"(\", \")\"));\n+\n+  private static final ThreadLocal<WKTWriter> WKT_WRITER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTWriter::new);\n+\n+  private static final ThreadLocal<WKTReader> WKT_READER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTReader::new);\n+\n+  protected static final String SUGGEST_Q = \"suggest.q\";\n+  protected static final String SUGGEST_DICT = \"suggest.dictionary\";\n+  protected static final String SUGGEST_PLACE_KEY = \"suggestPlace\";\n+\n+  public static final int MAX_RESULTS = 100;\n+  public static final double KM_PER_DEGREE = 111.139;\n+\n+  private SolrClientFactory clientFactory;\n+\n+  private SolrClient client;", "originalCommit": "da7f3def8635d75cf1d73988ed479c2def44f589", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxNzkyNw==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451217927", "bodyText": "\u2753 Can we use a method reference instead? There's a lot going on here. I think the following would be cleaner:\nexecutor.submit(this::pingSuggester);\n\nAlso there seems to be some room for more idiomatic Java IMHO:\nRetryPolicy retryPolicy = defaultRetryPolicy();\nSolrPingResponse ping = Failsafe.with(retryPolicy).onFailure(this:handleInitialError).get(() -> client.ping());\n...", "author": "Lambeaux", "createdAt": "2020-07-08T00:36:47Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.client.solrj.response.SolrPingResponse;\n+import org.apache.solr.client.solrj.response.SuggesterResponse;\n+import org.apache.solr.client.solrj.util.ClientUtils;\n+import org.apache.solr.common.SolrDocument;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntry;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryException;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryable;\n+import org.codice.ddf.spatial.geocoding.Suggestion;\n+import org.codice.ddf.spatial.geocoding.context.NearbyLocation;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.io.WKTReader;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GazetteerQueryOfflineSolr implements GeoEntryQueryable {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GazetteerQueryOfflineSolr.class);\n+\n+  private static final String CITY_SOLR_QUERY =\n+      GeoCodingConstants.CITY_FEATURE_CODES\n+          .stream()\n+          .map(fc -> String.format(\"ext.feature-code_txt:%s\", fc))\n+          .collect(Collectors.joining(\" OR \", \"(\", \")\"));\n+\n+  private static final ThreadLocal<WKTWriter> WKT_WRITER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTWriter::new);\n+\n+  private static final ThreadLocal<WKTReader> WKT_READER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTReader::new);\n+\n+  protected static final String SUGGEST_Q = \"suggest.q\";\n+  protected static final String SUGGEST_DICT = \"suggest.dictionary\";\n+  protected static final String SUGGEST_PLACE_KEY = \"suggestPlace\";\n+\n+  public static final int MAX_RESULTS = 100;\n+  public static final double KM_PER_DEGREE = 111.139;\n+\n+  private SolrClientFactory clientFactory;\n+\n+  private SolrClient client;\n+\n+  private final ExecutorService executor;\n+\n+  public GazetteerQueryOfflineSolr(\n+      SolrClientFactory clientFactory, ExecutorService startupBuilderExecutor) {\n+    this.clientFactory = clientFactory;\n+    this.client = clientFactory.newClient(OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME);\n+    this.executor = startupBuilderExecutor;\n+    executor.submit(", "originalCommit": "da7f3def8635d75cf1d73988ed479c2def44f589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk0MjMxMg==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r453942312", "bodyText": "I extracted the task to a method ref \ud83d\udc4c\nFor the second part, I think a fair bit has happened since original comment so i'll let you reassess.", "author": "rzwiefel", "createdAt": "2020-07-13T21:25:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxNzkyNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxODI3NQ==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451218275", "bodyText": "\u2753  If we need to refresh the bundle anyway in order to fix this issue, shouldn't we just let the exception propagate instead of logging manually? Let blueprint log it for us. The constructor would have to declare it throws the exception.\nIf we don't need to refresh the bundle and can gracefully recover from this, do we have a way to invoke this initialization code a subsequent time? Will it auto retry like the Solr client itself does?", "author": "Lambeaux", "createdAt": "2020-07-08T00:38:08Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.client.solrj.response.SolrPingResponse;\n+import org.apache.solr.client.solrj.response.SuggesterResponse;\n+import org.apache.solr.client.solrj.util.ClientUtils;\n+import org.apache.solr.common.SolrDocument;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntry;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryException;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryable;\n+import org.codice.ddf.spatial.geocoding.Suggestion;\n+import org.codice.ddf.spatial.geocoding.context.NearbyLocation;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.io.WKTReader;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GazetteerQueryOfflineSolr implements GeoEntryQueryable {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GazetteerQueryOfflineSolr.class);\n+\n+  private static final String CITY_SOLR_QUERY =\n+      GeoCodingConstants.CITY_FEATURE_CODES\n+          .stream()\n+          .map(fc -> String.format(\"ext.feature-code_txt:%s\", fc))\n+          .collect(Collectors.joining(\" OR \", \"(\", \")\"));\n+\n+  private static final ThreadLocal<WKTWriter> WKT_WRITER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTWriter::new);\n+\n+  private static final ThreadLocal<WKTReader> WKT_READER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTReader::new);\n+\n+  protected static final String SUGGEST_Q = \"suggest.q\";\n+  protected static final String SUGGEST_DICT = \"suggest.dictionary\";\n+  protected static final String SUGGEST_PLACE_KEY = \"suggestPlace\";\n+\n+  public static final int MAX_RESULTS = 100;\n+  public static final double KM_PER_DEGREE = 111.139;\n+\n+  private SolrClientFactory clientFactory;\n+\n+  private SolrClient client;\n+\n+  private final ExecutorService executor;\n+\n+  public GazetteerQueryOfflineSolr(\n+      SolrClientFactory clientFactory, ExecutorService startupBuilderExecutor) {\n+    this.clientFactory = clientFactory;\n+    this.client = clientFactory.newClient(OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME);\n+    this.executor = startupBuilderExecutor;\n+    executor.submit(\n+        () -> {\n+          RetryPolicy retryPolicy =\n+              new RetryPolicy()\n+                  .retryOn(Collections.singletonList(Exception.class))\n+                  .withMaxDuration(20, TimeUnit.SECONDS)\n+                  .withBackoff(100, 1_000, TimeUnit.MILLISECONDS);\n+          SolrPingResponse ping =\n+              Failsafe.with(retryPolicy)\n+                  .onFailure(\n+                      e ->\n+                          LOGGER.error(\n+                              \"Could not get solrclient to start initial suggester build for {} core. Please try to start a build manually with the `build-suggester-index` karaf command or by sending a request to solr with the property `suggest.build=true`\",", "originalCommit": "da7f3def8635d75cf1d73988ed479c2def44f589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk0NTAyMg==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r453945022", "bodyText": "This isn't actually a bundle breaking issue -- only building of the initial suggester. The bundle should continue on fine once the solr client connects and no restart would be necessary. So if we threw an exception and broke the bundle from starting it would have to manually be connected only at a time when solr was currently active. With the current way it will only not work while it can't connect to solr. Once connected it will resume working as expected.", "author": "rzwiefel", "createdAt": "2020-07-13T21:30:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxODI3NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczNTM3MQ==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r454735371", "bodyText": "Perfect \ud83d\udc4d  then let's leave it as-is.", "author": "Lambeaux", "createdAt": "2020-07-15T01:24:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxODI3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxODU3Mg==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451218572", "bodyText": "\u2753  See above comment - are these exceptions worth propagating instead of handling here?", "author": "Lambeaux", "createdAt": "2020-07-08T00:39:28Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.client.solrj.response.SolrPingResponse;\n+import org.apache.solr.client.solrj.response.SuggesterResponse;\n+import org.apache.solr.client.solrj.util.ClientUtils;\n+import org.apache.solr.common.SolrDocument;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntry;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryException;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryable;\n+import org.codice.ddf.spatial.geocoding.Suggestion;\n+import org.codice.ddf.spatial.geocoding.context.NearbyLocation;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.io.WKTReader;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GazetteerQueryOfflineSolr implements GeoEntryQueryable {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GazetteerQueryOfflineSolr.class);\n+\n+  private static final String CITY_SOLR_QUERY =\n+      GeoCodingConstants.CITY_FEATURE_CODES\n+          .stream()\n+          .map(fc -> String.format(\"ext.feature-code_txt:%s\", fc))\n+          .collect(Collectors.joining(\" OR \", \"(\", \")\"));\n+\n+  private static final ThreadLocal<WKTWriter> WKT_WRITER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTWriter::new);\n+\n+  private static final ThreadLocal<WKTReader> WKT_READER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTReader::new);\n+\n+  protected static final String SUGGEST_Q = \"suggest.q\";\n+  protected static final String SUGGEST_DICT = \"suggest.dictionary\";\n+  protected static final String SUGGEST_PLACE_KEY = \"suggestPlace\";\n+\n+  public static final int MAX_RESULTS = 100;\n+  public static final double KM_PER_DEGREE = 111.139;\n+\n+  private SolrClientFactory clientFactory;\n+\n+  private SolrClient client;\n+\n+  private final ExecutorService executor;\n+\n+  public GazetteerQueryOfflineSolr(\n+      SolrClientFactory clientFactory, ExecutorService startupBuilderExecutor) {\n+    this.clientFactory = clientFactory;\n+    this.client = clientFactory.newClient(OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME);\n+    this.executor = startupBuilderExecutor;\n+    executor.submit(\n+        () -> {\n+          RetryPolicy retryPolicy =\n+              new RetryPolicy()\n+                  .retryOn(Collections.singletonList(Exception.class))\n+                  .withMaxDuration(20, TimeUnit.SECONDS)\n+                  .withBackoff(100, 1_000, TimeUnit.MILLISECONDS);\n+          SolrPingResponse ping =\n+              Failsafe.with(retryPolicy)\n+                  .onFailure(\n+                      e ->\n+                          LOGGER.error(\n+                              \"Could not get solrclient to start initial suggester build for {} core. Please try to start a build manually with the `build-suggester-index` karaf command or by sending a request to solr with the property `suggest.build=true`\",\n+                              OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME,\n+                              e))\n+                  .get(() -> client.ping());\n+          SolrQuery query = new SolrQuery();\n+          query.setRequestHandler(\"/suggest\");\n+          query.setParam(\"suggest.build\", true);\n+          query.setParam(\"suggest.q\", \"GQOSInitialSuggesterBuild\");\n+          query.setParam(\"suggest.dictionary\", \"suggestPlace\");\n+          try {\n+            QueryResponse response = client.query(query, METHOD.POST);\n+            LOGGER.debug(\"Initial Suggester build response: {}\", response);\n+          } catch (SolrServerException | IOException e) {", "originalCommit": "da7f3def8635d75cf1d73988ed479c2def44f589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY0NjMyMw==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451646323", "bodyText": "Failsafe will not propagate exceptions.  You also have to be careful not to mis-configure the failsafe failure handling by making it too narrow.", "author": "pklinef", "createdAt": "2020-07-08T15:47:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxODU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkxMTI3NA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r453911274", "bodyText": "@pklinef @rzwiefel I'm talking specifically about letting blueprint handle the exception instead of us since we can't do anything more meaningful than log. I don't see the point of making the query logic harder to read with that kind of payoff. I think the DI container should handle default cases like this.\nSeems like we can propagate FailsafeException and it'll work fine.\nhttps://javadoc.io/doc/net.jodah/failsafe/1.1.1/net/jodah/failsafe/SyncFailsafe.html", "author": "Lambeaux", "createdAt": "2020-07-13T20:26:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxODU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkyNTU2OQ==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r453925569", "bodyText": "I just noticed this error handling is outside of Failsafe and is part of the executor submission.  We ignore the returned Future.  We would need to do a blocking call to get() on the returned future to get the ExecutionException.  We should not be blocking Blueprint from this constructor.  I am not sure how we could propagate this back to Bluepring without blocking.\nhttps://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html#get-long-java.util.concurrent.TimeUnit-", "author": "pklinef", "createdAt": "2020-07-13T20:52:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxODU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk0NjEwNg==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r453946106", "bodyText": "As mentioned Here, this is not actually bundle breaking -- it only builds the initial suggester. Once the client actually connects to solr then this bundle will function as expected. Since we also don't want to block blueprint i'll leave it as is. I did extend the timeout to give it a more blueprint-like period for waiting.", "author": "rzwiefel", "createdAt": "2020-07-13T21:33:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxODU3Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczNjQ3Nw==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r454736477", "bodyText": "I'll take a look at the revised code but if this is not a bundle-breaking or system-breaking process, but an expected and valid failure scenario, then how could the process be re-attempted without resorting to karaf-specific knowledge?\nWhen I look at the code I may end up answering my own question.", "author": "Lambeaux", "createdAt": "2020-07-15T01:28:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIxODU3Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyNTQ4OQ==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451225489", "bodyText": "\u2753 Am I seeing the cohesion correctly? Do the public constants, math calculations, and WKT operations all belong together in a separate thing?", "author": "Lambeaux", "createdAt": "2020-07-08T01:06:34Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.client.solrj.response.SolrPingResponse;\n+import org.apache.solr.client.solrj.response.SuggesterResponse;\n+import org.apache.solr.client.solrj.util.ClientUtils;\n+import org.apache.solr.common.SolrDocument;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntry;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryException;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryable;\n+import org.codice.ddf.spatial.geocoding.Suggestion;\n+import org.codice.ddf.spatial.geocoding.context.NearbyLocation;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.io.WKTReader;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GazetteerQueryOfflineSolr implements GeoEntryQueryable {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GazetteerQueryOfflineSolr.class);\n+\n+  private static final String CITY_SOLR_QUERY =\n+      GeoCodingConstants.CITY_FEATURE_CODES\n+          .stream()\n+          .map(fc -> String.format(\"ext.feature-code_txt:%s\", fc))\n+          .collect(Collectors.joining(\" OR \", \"(\", \")\"));\n+\n+  private static final ThreadLocal<WKTWriter> WKT_WRITER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTWriter::new);\n+\n+  private static final ThreadLocal<WKTReader> WKT_READER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTReader::new);\n+\n+  protected static final String SUGGEST_Q = \"suggest.q\";\n+  protected static final String SUGGEST_DICT = \"suggest.dictionary\";\n+  protected static final String SUGGEST_PLACE_KEY = \"suggestPlace\";\n+\n+  public static final int MAX_RESULTS = 100;\n+  public static final double KM_PER_DEGREE = 111.139;\n+\n+  private SolrClientFactory clientFactory;\n+\n+  private SolrClient client;\n+\n+  private final ExecutorService executor;\n+\n+  public GazetteerQueryOfflineSolr(\n+      SolrClientFactory clientFactory, ExecutorService startupBuilderExecutor) {\n+    this.clientFactory = clientFactory;\n+    this.client = clientFactory.newClient(OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME);\n+    this.executor = startupBuilderExecutor;\n+    executor.submit(\n+        () -> {\n+          RetryPolicy retryPolicy =\n+              new RetryPolicy()\n+                  .retryOn(Collections.singletonList(Exception.class))\n+                  .withMaxDuration(20, TimeUnit.SECONDS)\n+                  .withBackoff(100, 1_000, TimeUnit.MILLISECONDS);\n+          SolrPingResponse ping =\n+              Failsafe.with(retryPolicy)\n+                  .onFailure(\n+                      e ->\n+                          LOGGER.error(\n+                              \"Could not get solrclient to start initial suggester build for {} core. Please try to start a build manually with the `build-suggester-index` karaf command or by sending a request to solr with the property `suggest.build=true`\",\n+                              OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME,\n+                              e))\n+                  .get(() -> client.ping());\n+          SolrQuery query = new SolrQuery();\n+          query.setRequestHandler(\"/suggest\");\n+          query.setParam(\"suggest.build\", true);\n+          query.setParam(\"suggest.q\", \"GQOSInitialSuggesterBuild\");\n+          query.setParam(\"suggest.dictionary\", \"suggestPlace\");\n+          try {\n+            QueryResponse response = client.query(query, METHOD.POST);\n+            LOGGER.debug(\"Initial Suggester build response: {}\", response);\n+          } catch (SolrServerException | IOException e) {\n+            LOGGER.error(\n+                \"Error while trying to build initial suggester for {}\",\n+                OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME,\n+                e);\n+          }\n+        });\n+  }\n+\n+  @Override\n+  public List<GeoEntry> query(String queryString, int maxResults) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"title_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(queryString)));\n+    solrQuery.setRows(Math.min(maxResults, GazetteerQueryOfflineSolr.MAX_RESULTS));\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public GeoEntry queryById(String id) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"id_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(id)));\n+    solrQuery.setRows(1);\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .findFirst()\n+        .orElseThrow(() -> new GeoEntryQueryException(\"Could not find id\"));\n+  }\n+\n+  @Override\n+  public List<Suggestion> getSuggestedNames(String queryString, int maxResults)\n+      throws GeoEntryQueryException {\n+    SolrQuery solrQuery = new SolrQuery();\n+    solrQuery.setRequestHandler(\"/suggest\");\n+    solrQuery.setParam(SUGGEST_Q, ClientUtils.escapeQueryChars(queryString));\n+    solrQuery.setParam(SUGGEST_DICT, SUGGEST_PLACE_KEY);\n+    solrQuery.setParam(\"suggest.count\", Integer.toString(Math.min(maxResults, MAX_RESULTS)));\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Something went wrong when querying\", e);\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+\n+    return Optional.ofNullable(response)\n+        .map(QueryResponse::getSuggesterResponse)\n+        .map(SuggesterResponse::getSuggestions)\n+        .map(suggestionsPerDict -> suggestionsPerDict.get(SUGGEST_PLACE_KEY))\n+        .orElse(Collections.emptyList())\n+        .stream()\n+        .map(suggestion -> new SuggestionImpl(suggestion.getPayload(), suggestion.getTerm()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  public static class SuggestionImpl implements Suggestion {\n+    private final String id;\n+    private final String name;\n+\n+    public SuggestionImpl(String id, String name) {\n+      this.id = id;\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public String getId() {\n+      return id;\n+    }\n+\n+    @Override\n+    public String getName() {\n+      return name;\n+    }\n+  }\n+\n+  @Override\n+  public List<NearbyLocation> getNearestCities(String location, int radiusInKm, int maxResults)\n+      throws ParseException, GeoEntryQueryException {\n+    Geometry geometry;\n+    try {\n+      geometry = WKT_READER_THREAD_LOCAL.get().read(location);\n+    } catch (org.locationtech.jts.io.ParseException e) {\n+      throw new GeoEntryQueryException(\"Could not parse location\");\n+    }\n+    // conver km to rough degree measurement, approximately 111km per degree\n+    double distanceInDegrees = radiusInKm / KM_PER_DEGREE;\n+    final Geometry originalGeometry = geometry;\n+    Geometry bufferedGeo = originalGeometry.buffer(distanceInDegrees, 14);\n+    String wkt = WKT_WRITER_THREAD_LOCAL.get().write(bufferedGeo);\n+\n+    String q =\n+        String.format(\n+            \"location_geo_index:\\\"Intersects( %s ) AND %s\\\"\",\n+            ClientUtils.escapeQueryChars(wkt), CITY_SOLR_QUERY);\n+\n+    SolrQuery solrQuery = new SolrQuery(q);\n+    solrQuery.setRows(Math.min(maxResults, MAX_RESULTS));\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Error executing query for nearest cities\", e);\n+      throw new GeoEntryQueryException(\"Error executing query\", e);\n+    }\n+\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(result -> convert(result, originalGeometry))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private NearbyLocation convert(SolrDocument doc, Geometry originalLocation) {\n+    String location = getField(doc, \"location_geo\", String.class);\n+    String title =\n+        Optional.ofNullable(getField(doc, \"title_txt\", String.class))\n+            .filter(Objects::nonNull)\n+            .filter(s -> !\"\".equals(s))\n+            .orElse(\"NO TITLE\");\n+\n+    String cardinalDirection = \"\";\n+    double distance = 0;\n+    try {\n+      Geometry geo = WKT_READER_THREAD_LOCAL.get().read(location);", "originalCommit": "da7f3def8635d75cf1d73988ed479c2def44f589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk0ODg3Ng==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r453948876", "bodyText": "It could be extracted. But since its only 14 lines of calculation I'd rather opt to leave it in this class rather than introduce an entire other class. If you really want to see this change happen though lets hop on a call and do it together so you can help me see your vision of it \ud83d\ude04", "author": "rzwiefel", "createdAt": "2020-07-13T21:38:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyNTQ4OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyNzEyMA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451227120", "bodyText": "\u2753 Should we TRACE log the original Solr document and the result of geoEntryBuilder.build(), assuming they both toString() correctly?", "author": "Lambeaux", "createdAt": "2020-07-08T01:13:13Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.client.solrj.response.SolrPingResponse;\n+import org.apache.solr.client.solrj.response.SuggesterResponse;\n+import org.apache.solr.client.solrj.util.ClientUtils;\n+import org.apache.solr.common.SolrDocument;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntry;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryException;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryable;\n+import org.codice.ddf.spatial.geocoding.Suggestion;\n+import org.codice.ddf.spatial.geocoding.context.NearbyLocation;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.io.WKTReader;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GazetteerQueryOfflineSolr implements GeoEntryQueryable {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GazetteerQueryOfflineSolr.class);\n+\n+  private static final String CITY_SOLR_QUERY =\n+      GeoCodingConstants.CITY_FEATURE_CODES\n+          .stream()\n+          .map(fc -> String.format(\"ext.feature-code_txt:%s\", fc))\n+          .collect(Collectors.joining(\" OR \", \"(\", \")\"));\n+\n+  private static final ThreadLocal<WKTWriter> WKT_WRITER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTWriter::new);\n+\n+  private static final ThreadLocal<WKTReader> WKT_READER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTReader::new);\n+\n+  protected static final String SUGGEST_Q = \"suggest.q\";\n+  protected static final String SUGGEST_DICT = \"suggest.dictionary\";\n+  protected static final String SUGGEST_PLACE_KEY = \"suggestPlace\";\n+\n+  public static final int MAX_RESULTS = 100;\n+  public static final double KM_PER_DEGREE = 111.139;\n+\n+  private SolrClientFactory clientFactory;\n+\n+  private SolrClient client;\n+\n+  private final ExecutorService executor;\n+\n+  public GazetteerQueryOfflineSolr(\n+      SolrClientFactory clientFactory, ExecutorService startupBuilderExecutor) {\n+    this.clientFactory = clientFactory;\n+    this.client = clientFactory.newClient(OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME);\n+    this.executor = startupBuilderExecutor;\n+    executor.submit(\n+        () -> {\n+          RetryPolicy retryPolicy =\n+              new RetryPolicy()\n+                  .retryOn(Collections.singletonList(Exception.class))\n+                  .withMaxDuration(20, TimeUnit.SECONDS)\n+                  .withBackoff(100, 1_000, TimeUnit.MILLISECONDS);\n+          SolrPingResponse ping =\n+              Failsafe.with(retryPolicy)\n+                  .onFailure(\n+                      e ->\n+                          LOGGER.error(\n+                              \"Could not get solrclient to start initial suggester build for {} core. Please try to start a build manually with the `build-suggester-index` karaf command or by sending a request to solr with the property `suggest.build=true`\",\n+                              OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME,\n+                              e))\n+                  .get(() -> client.ping());\n+          SolrQuery query = new SolrQuery();\n+          query.setRequestHandler(\"/suggest\");\n+          query.setParam(\"suggest.build\", true);\n+          query.setParam(\"suggest.q\", \"GQOSInitialSuggesterBuild\");\n+          query.setParam(\"suggest.dictionary\", \"suggestPlace\");\n+          try {\n+            QueryResponse response = client.query(query, METHOD.POST);\n+            LOGGER.debug(\"Initial Suggester build response: {}\", response);\n+          } catch (SolrServerException | IOException e) {\n+            LOGGER.error(\n+                \"Error while trying to build initial suggester for {}\",\n+                OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME,\n+                e);\n+          }\n+        });\n+  }\n+\n+  @Override\n+  public List<GeoEntry> query(String queryString, int maxResults) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"title_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(queryString)));\n+    solrQuery.setRows(Math.min(maxResults, GazetteerQueryOfflineSolr.MAX_RESULTS));\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public GeoEntry queryById(String id) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"id_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(id)));\n+    solrQuery.setRows(1);\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .findFirst()\n+        .orElseThrow(() -> new GeoEntryQueryException(\"Could not find id\"));\n+  }\n+\n+  @Override\n+  public List<Suggestion> getSuggestedNames(String queryString, int maxResults)\n+      throws GeoEntryQueryException {\n+    SolrQuery solrQuery = new SolrQuery();\n+    solrQuery.setRequestHandler(\"/suggest\");\n+    solrQuery.setParam(SUGGEST_Q, ClientUtils.escapeQueryChars(queryString));\n+    solrQuery.setParam(SUGGEST_DICT, SUGGEST_PLACE_KEY);\n+    solrQuery.setParam(\"suggest.count\", Integer.toString(Math.min(maxResults, MAX_RESULTS)));\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Something went wrong when querying\", e);\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+\n+    return Optional.ofNullable(response)\n+        .map(QueryResponse::getSuggesterResponse)\n+        .map(SuggesterResponse::getSuggestions)\n+        .map(suggestionsPerDict -> suggestionsPerDict.get(SUGGEST_PLACE_KEY))\n+        .orElse(Collections.emptyList())\n+        .stream()\n+        .map(suggestion -> new SuggestionImpl(suggestion.getPayload(), suggestion.getTerm()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  public static class SuggestionImpl implements Suggestion {\n+    private final String id;\n+    private final String name;\n+\n+    public SuggestionImpl(String id, String name) {\n+      this.id = id;\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public String getId() {\n+      return id;\n+    }\n+\n+    @Override\n+    public String getName() {\n+      return name;\n+    }\n+  }\n+\n+  @Override\n+  public List<NearbyLocation> getNearestCities(String location, int radiusInKm, int maxResults)\n+      throws ParseException, GeoEntryQueryException {\n+    Geometry geometry;\n+    try {\n+      geometry = WKT_READER_THREAD_LOCAL.get().read(location);\n+    } catch (org.locationtech.jts.io.ParseException e) {\n+      throw new GeoEntryQueryException(\"Could not parse location\");\n+    }\n+    // conver km to rough degree measurement, approximately 111km per degree\n+    double distanceInDegrees = radiusInKm / KM_PER_DEGREE;\n+    final Geometry originalGeometry = geometry;\n+    Geometry bufferedGeo = originalGeometry.buffer(distanceInDegrees, 14);\n+    String wkt = WKT_WRITER_THREAD_LOCAL.get().write(bufferedGeo);\n+\n+    String q =\n+        String.format(\n+            \"location_geo_index:\\\"Intersects( %s ) AND %s\\\"\",\n+            ClientUtils.escapeQueryChars(wkt), CITY_SOLR_QUERY);\n+\n+    SolrQuery solrQuery = new SolrQuery(q);\n+    solrQuery.setRows(Math.min(maxResults, MAX_RESULTS));\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Error executing query for nearest cities\", e);\n+      throw new GeoEntryQueryException(\"Error executing query\", e);\n+    }\n+\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(result -> convert(result, originalGeometry))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private NearbyLocation convert(SolrDocument doc, Geometry originalLocation) {\n+    String location = getField(doc, \"location_geo\", String.class);\n+    String title =\n+        Optional.ofNullable(getField(doc, \"title_txt\", String.class))\n+            .filter(Objects::nonNull)\n+            .filter(s -> !\"\".equals(s))\n+            .orElse(\"NO TITLE\");\n+\n+    String cardinalDirection = \"\";\n+    double distance = 0;\n+    try {\n+      Geometry geo = WKT_READER_THREAD_LOCAL.get().read(location);\n+      cardinalDirection =\n+          bearingToCardinalDirection(getBearing(originalLocation.getCentroid(), geo.getCentroid()));\n+      // convert distance to KM\n+      distance = originalLocation.distance(geo.getCentroid()) * KM_PER_DEGREE;\n+    } catch (org.locationtech.jts.io.ParseException e) {\n+      LOGGER.debug(\"Could not parse location for item (object: {})\", doc.toString(), e);\n+    }\n+\n+    return new NearbyLocationImpl(title, cardinalDirection, distance);\n+  }\n+\n+  public static class NearbyLocationImpl implements NearbyLocation {\n+    private final String name;\n+    private final String cardinalDirection;\n+    private final double distance;\n+\n+    public NearbyLocationImpl(String name, String cardinalDirection, double distance) {\n+      this.name = name;\n+      this.cardinalDirection = cardinalDirection;\n+      this.distance = distance;\n+    }\n+\n+    @Override\n+    public String getName() {\n+      return name;\n+    }\n+\n+    @Override\n+    public String getCardinalDirection() {\n+      return cardinalDirection;\n+    }\n+\n+    @Override\n+    public double getDistance() {\n+      return distance;\n+    }\n+  }\n+  /**\n+   * Calculates the bearing from the start point to the end point (i.e., the <em>initial bearing\n+   * </em>) in degrees.\n+   *\n+   * @param startPoint the point from which to start\n+   * @param endPoint the point at which to end\n+   * @return the bearing from {@code startPoint} to {@code endPoint}, in degrees\n+   */\n+  private static double getBearing(final Point startPoint, final Point endPoint) {\n+    final double lat1 = startPoint.getY();\n+    final double lon1 = startPoint.getX();\n+\n+    final double lat2 = endPoint.getY();\n+    final double lon2 = endPoint.getX();\n+\n+    final double lonDiffRads = Math.toRadians(lon2 - lon1);\n+    final double lat1Rads = Math.toRadians(lat1);\n+    final double lat2Rads = Math.toRadians(lat2);\n+    final double y = Math.sin(lonDiffRads) * Math.cos(lat2Rads);\n+    final double x =\n+        Math.cos(lat1Rads) * Math.sin(lat2Rads)\n+            - Math.sin(lat1Rads) * Math.cos(lat2Rads) * Math.cos(lonDiffRads);\n+\n+    return (Math.toDegrees(Math.atan2(y, x)) + 360) % 360;\n+  }\n+\n+  /**\n+   * Takes a bearing in degrees and returns the corresponding cardinal direction as a string.\n+   *\n+   * @param bearing the bearing, in degrees\n+   * @return the cardinal direction corresponding to {@code bearing} (N, NE, E, SE, S, SW, W, NW)\n+   */\n+  private static String bearingToCardinalDirection(final double bearing) {\n+    final String[] directions = {\"N\", \"NE\", \"E\", \"SE\", \"S\", \"SW\", \"W\", \"NW\", \"N\"};\n+    return directions[(int) Math.round(bearing / 45)];\n+  }\n+\n+  @Override\n+  public Optional<String> getCountryCode(String wktLocation, int radius)\n+      throws GeoEntryQueryException, ParseException {\n+    String wkt;\n+    try {\n+      Point center = WKT_READER_THREAD_LOCAL.get().read(wktLocation).getCentroid();\n+      wkt = WKT_WRITER_THREAD_LOCAL.get().write(center.buffer(radius / KM_PER_DEGREE));\n+    } catch (org.locationtech.jts.io.ParseException e) {\n+      LOGGER.debug(\"Could not parse wkt: {}\", wktLocation, e);\n+      throw new GeoEntryQueryException(\"Could not parse wkt\", e);\n+    }\n+\n+    SolrQuery solrQuery =\n+        new SolrQuery(\n+            String.format(\n+                \"location_geo_index:\\\"Intersects( %s )\\\"\", ClientUtils.escapeQueryChars(wkt)));\n+    solrQuery.setRows(1);\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Could not query for country code ({})\", wktLocation, e);\n+      throw new GeoEntryQueryException(\"Error encountered when querying\", e);\n+    }\n+\n+    return response\n+        .getResults()\n+        .stream()\n+        .findFirst()\n+        .map(doc -> getField(doc, Location.COUNTRY_CODE + \"_txt\", String.class));\n+  }\n+\n+  private GeoEntry transformMetacardToGeoEntry(SolrDocument document) {\n+    GeoEntry.Builder geoEntryBuilder = new GeoEntry.Builder();\n+    String featureCode =\n+        getField(document, GeoEntryAttributes.FEATURE_CODE_ATTRIBUTE_NAME + \"_txt\", String.class);\n+\n+    if (StringUtils.isNotBlank(featureCode)) {\n+      geoEntryBuilder.featureCode(featureCode);\n+    }\n+\n+    String countryCode = getField(document, Location.COUNTRY_CODE + \"_txt\", String.class);\n+    if (StringUtils.isNotBlank(countryCode)) {\n+      geoEntryBuilder.countryCode(countryCode);\n+    }\n+\n+    String name = getField(document, Core.TITLE + \"_txt\", String.class);\n+    if (StringUtils.isNotBlank(name)) {\n+      geoEntryBuilder.name(name);\n+    }\n+\n+    Long population =\n+        getField(document, GeoEntryAttributes.POPULATION_ATTRIBUTE_NAME + \"_lng\", Long.class);\n+    if (population != null) {\n+      geoEntryBuilder.population(population);\n+    }\n+\n+    Integer sortValue =\n+        getField(document, GeoEntryAttributes.GAZETTEER_SORT_VALUE + \"_int\", Integer.class);\n+    if (sortValue != null) {\n+      geoEntryBuilder.gazetteerSort(sortValue);\n+    }\n+\n+    String location = getField(document, Core.LOCATION + \"_geo\", String.class);\n+    if (StringUtils.isNotBlank(location)) {\n+      try {\n+        Geometry geometry = WKT_READER_THREAD_LOCAL.get().read(location);\n+        Point coordinate = geometry.getCentroid();\n+        if (!coordinate.isEmpty()) {\n+          Double lat = coordinate.getY();\n+          Double lon = coordinate.getX();\n+          geoEntryBuilder.latitude(lat);\n+          geoEntryBuilder.longitude(lon);\n+        }\n+      } catch (org.locationtech.jts.io.ParseException e) {\n+        LOGGER.debug(\"GeoEntry metacard does not contain (readable) location attribute.\");\n+      }\n+    }\n+    return geoEntryBuilder.build();", "originalCommit": "da7f3def8635d75cf1d73988ed479c2def44f589", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyNzUwMQ==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451227501", "bodyText": "\u2753 Is it a valid assumption that all attributes will be multi-valued?", "author": "Lambeaux", "createdAt": "2020-07-08T01:14:54Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java", "diffHunk": "@@ -0,0 +1,426 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.client.solrj.response.SolrPingResponse;\n+import org.apache.solr.client.solrj.response.SuggesterResponse;\n+import org.apache.solr.client.solrj.util.ClientUtils;\n+import org.apache.solr.common.SolrDocument;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntry;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryException;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryable;\n+import org.codice.ddf.spatial.geocoding.Suggestion;\n+import org.codice.ddf.spatial.geocoding.context.NearbyLocation;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.io.WKTReader;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GazetteerQueryOfflineSolr implements GeoEntryQueryable {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GazetteerQueryOfflineSolr.class);\n+\n+  private static final String CITY_SOLR_QUERY =\n+      GeoCodingConstants.CITY_FEATURE_CODES\n+          .stream()\n+          .map(fc -> String.format(\"ext.feature-code_txt:%s\", fc))\n+          .collect(Collectors.joining(\" OR \", \"(\", \")\"));\n+\n+  private static final ThreadLocal<WKTWriter> WKT_WRITER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTWriter::new);\n+\n+  private static final ThreadLocal<WKTReader> WKT_READER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTReader::new);\n+\n+  protected static final String SUGGEST_Q = \"suggest.q\";\n+  protected static final String SUGGEST_DICT = \"suggest.dictionary\";\n+  protected static final String SUGGEST_PLACE_KEY = \"suggestPlace\";\n+\n+  public static final int MAX_RESULTS = 100;\n+  public static final double KM_PER_DEGREE = 111.139;\n+\n+  private SolrClientFactory clientFactory;\n+\n+  private SolrClient client;\n+\n+  private final ExecutorService executor;\n+\n+  public GazetteerQueryOfflineSolr(\n+      SolrClientFactory clientFactory, ExecutorService startupBuilderExecutor) {\n+    this.clientFactory = clientFactory;\n+    this.client = clientFactory.newClient(OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME);\n+    this.executor = startupBuilderExecutor;\n+    executor.submit(\n+        () -> {\n+          RetryPolicy retryPolicy =\n+              new RetryPolicy()\n+                  .retryOn(Collections.singletonList(Exception.class))\n+                  .withMaxDuration(20, TimeUnit.SECONDS)\n+                  .withBackoff(100, 1_000, TimeUnit.MILLISECONDS);\n+          SolrPingResponse ping =\n+              Failsafe.with(retryPolicy)\n+                  .onFailure(\n+                      e ->\n+                          LOGGER.error(\n+                              \"Could not get solrclient to start initial suggester build for {} core. Please try to start a build manually with the `build-suggester-index` karaf command or by sending a request to solr with the property `suggest.build=true`\",\n+                              OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME,\n+                              e))\n+                  .get(() -> client.ping());\n+          SolrQuery query = new SolrQuery();\n+          query.setRequestHandler(\"/suggest\");\n+          query.setParam(\"suggest.build\", true);\n+          query.setParam(\"suggest.q\", \"GQOSInitialSuggesterBuild\");\n+          query.setParam(\"suggest.dictionary\", \"suggestPlace\");\n+          try {\n+            QueryResponse response = client.query(query, METHOD.POST);\n+            LOGGER.debug(\"Initial Suggester build response: {}\", response);\n+          } catch (SolrServerException | IOException e) {\n+            LOGGER.error(\n+                \"Error while trying to build initial suggester for {}\",\n+                OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME,\n+                e);\n+          }\n+        });\n+  }\n+\n+  @Override\n+  public List<GeoEntry> query(String queryString, int maxResults) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"title_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(queryString)));\n+    solrQuery.setRows(Math.min(maxResults, GazetteerQueryOfflineSolr.MAX_RESULTS));\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public GeoEntry queryById(String id) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"id_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(id)));\n+    solrQuery.setRows(1);\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .findFirst()\n+        .orElseThrow(() -> new GeoEntryQueryException(\"Could not find id\"));\n+  }\n+\n+  @Override\n+  public List<Suggestion> getSuggestedNames(String queryString, int maxResults)\n+      throws GeoEntryQueryException {\n+    SolrQuery solrQuery = new SolrQuery();\n+    solrQuery.setRequestHandler(\"/suggest\");\n+    solrQuery.setParam(SUGGEST_Q, ClientUtils.escapeQueryChars(queryString));\n+    solrQuery.setParam(SUGGEST_DICT, SUGGEST_PLACE_KEY);\n+    solrQuery.setParam(\"suggest.count\", Integer.toString(Math.min(maxResults, MAX_RESULTS)));\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Something went wrong when querying\", e);\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+\n+    return Optional.ofNullable(response)\n+        .map(QueryResponse::getSuggesterResponse)\n+        .map(SuggesterResponse::getSuggestions)\n+        .map(suggestionsPerDict -> suggestionsPerDict.get(SUGGEST_PLACE_KEY))\n+        .orElse(Collections.emptyList())\n+        .stream()\n+        .map(suggestion -> new SuggestionImpl(suggestion.getPayload(), suggestion.getTerm()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  public static class SuggestionImpl implements Suggestion {\n+    private final String id;\n+    private final String name;\n+\n+    public SuggestionImpl(String id, String name) {\n+      this.id = id;\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public String getId() {\n+      return id;\n+    }\n+\n+    @Override\n+    public String getName() {\n+      return name;\n+    }\n+  }\n+\n+  @Override\n+  public List<NearbyLocation> getNearestCities(String location, int radiusInKm, int maxResults)\n+      throws ParseException, GeoEntryQueryException {\n+    Geometry geometry;\n+    try {\n+      geometry = WKT_READER_THREAD_LOCAL.get().read(location);\n+    } catch (org.locationtech.jts.io.ParseException e) {\n+      throw new GeoEntryQueryException(\"Could not parse location\");\n+    }\n+    // conver km to rough degree measurement, approximately 111km per degree\n+    double distanceInDegrees = radiusInKm / KM_PER_DEGREE;\n+    final Geometry originalGeometry = geometry;\n+    Geometry bufferedGeo = originalGeometry.buffer(distanceInDegrees, 14);\n+    String wkt = WKT_WRITER_THREAD_LOCAL.get().write(bufferedGeo);\n+\n+    String q =\n+        String.format(\n+            \"location_geo_index:\\\"Intersects( %s ) AND %s\\\"\",\n+            ClientUtils.escapeQueryChars(wkt), CITY_SOLR_QUERY);\n+\n+    SolrQuery solrQuery = new SolrQuery(q);\n+    solrQuery.setRows(Math.min(maxResults, MAX_RESULTS));\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Error executing query for nearest cities\", e);\n+      throw new GeoEntryQueryException(\"Error executing query\", e);\n+    }\n+\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(result -> convert(result, originalGeometry))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private NearbyLocation convert(SolrDocument doc, Geometry originalLocation) {\n+    String location = getField(doc, \"location_geo\", String.class);\n+    String title =\n+        Optional.ofNullable(getField(doc, \"title_txt\", String.class))\n+            .filter(Objects::nonNull)\n+            .filter(s -> !\"\".equals(s))\n+            .orElse(\"NO TITLE\");\n+\n+    String cardinalDirection = \"\";\n+    double distance = 0;\n+    try {\n+      Geometry geo = WKT_READER_THREAD_LOCAL.get().read(location);\n+      cardinalDirection =\n+          bearingToCardinalDirection(getBearing(originalLocation.getCentroid(), geo.getCentroid()));\n+      // convert distance to KM\n+      distance = originalLocation.distance(geo.getCentroid()) * KM_PER_DEGREE;\n+    } catch (org.locationtech.jts.io.ParseException e) {\n+      LOGGER.debug(\"Could not parse location for item (object: {})\", doc.toString(), e);\n+    }\n+\n+    return new NearbyLocationImpl(title, cardinalDirection, distance);\n+  }\n+\n+  public static class NearbyLocationImpl implements NearbyLocation {\n+    private final String name;\n+    private final String cardinalDirection;\n+    private final double distance;\n+\n+    public NearbyLocationImpl(String name, String cardinalDirection, double distance) {\n+      this.name = name;\n+      this.cardinalDirection = cardinalDirection;\n+      this.distance = distance;\n+    }\n+\n+    @Override\n+    public String getName() {\n+      return name;\n+    }\n+\n+    @Override\n+    public String getCardinalDirection() {\n+      return cardinalDirection;\n+    }\n+\n+    @Override\n+    public double getDistance() {\n+      return distance;\n+    }\n+  }\n+  /**\n+   * Calculates the bearing from the start point to the end point (i.e., the <em>initial bearing\n+   * </em>) in degrees.\n+   *\n+   * @param startPoint the point from which to start\n+   * @param endPoint the point at which to end\n+   * @return the bearing from {@code startPoint} to {@code endPoint}, in degrees\n+   */\n+  private static double getBearing(final Point startPoint, final Point endPoint) {\n+    final double lat1 = startPoint.getY();\n+    final double lon1 = startPoint.getX();\n+\n+    final double lat2 = endPoint.getY();\n+    final double lon2 = endPoint.getX();\n+\n+    final double lonDiffRads = Math.toRadians(lon2 - lon1);\n+    final double lat1Rads = Math.toRadians(lat1);\n+    final double lat2Rads = Math.toRadians(lat2);\n+    final double y = Math.sin(lonDiffRads) * Math.cos(lat2Rads);\n+    final double x =\n+        Math.cos(lat1Rads) * Math.sin(lat2Rads)\n+            - Math.sin(lat1Rads) * Math.cos(lat2Rads) * Math.cos(lonDiffRads);\n+\n+    return (Math.toDegrees(Math.atan2(y, x)) + 360) % 360;\n+  }\n+\n+  /**\n+   * Takes a bearing in degrees and returns the corresponding cardinal direction as a string.\n+   *\n+   * @param bearing the bearing, in degrees\n+   * @return the cardinal direction corresponding to {@code bearing} (N, NE, E, SE, S, SW, W, NW)\n+   */\n+  private static String bearingToCardinalDirection(final double bearing) {\n+    final String[] directions = {\"N\", \"NE\", \"E\", \"SE\", \"S\", \"SW\", \"W\", \"NW\", \"N\"};\n+    return directions[(int) Math.round(bearing / 45)];\n+  }\n+\n+  @Override\n+  public Optional<String> getCountryCode(String wktLocation, int radius)\n+      throws GeoEntryQueryException, ParseException {\n+    String wkt;\n+    try {\n+      Point center = WKT_READER_THREAD_LOCAL.get().read(wktLocation).getCentroid();\n+      wkt = WKT_WRITER_THREAD_LOCAL.get().write(center.buffer(radius / KM_PER_DEGREE));\n+    } catch (org.locationtech.jts.io.ParseException e) {\n+      LOGGER.debug(\"Could not parse wkt: {}\", wktLocation, e);\n+      throw new GeoEntryQueryException(\"Could not parse wkt\", e);\n+    }\n+\n+    SolrQuery solrQuery =\n+        new SolrQuery(\n+            String.format(\n+                \"location_geo_index:\\\"Intersects( %s )\\\"\", ClientUtils.escapeQueryChars(wkt)));\n+    solrQuery.setRows(1);\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Could not query for country code ({})\", wktLocation, e);\n+      throw new GeoEntryQueryException(\"Error encountered when querying\", e);\n+    }\n+\n+    return response\n+        .getResults()\n+        .stream()\n+        .findFirst()\n+        .map(doc -> getField(doc, Location.COUNTRY_CODE + \"_txt\", String.class));\n+  }\n+\n+  private GeoEntry transformMetacardToGeoEntry(SolrDocument document) {\n+    GeoEntry.Builder geoEntryBuilder = new GeoEntry.Builder();\n+    String featureCode =\n+        getField(document, GeoEntryAttributes.FEATURE_CODE_ATTRIBUTE_NAME + \"_txt\", String.class);\n+\n+    if (StringUtils.isNotBlank(featureCode)) {\n+      geoEntryBuilder.featureCode(featureCode);\n+    }\n+\n+    String countryCode = getField(document, Location.COUNTRY_CODE + \"_txt\", String.class);\n+    if (StringUtils.isNotBlank(countryCode)) {\n+      geoEntryBuilder.countryCode(countryCode);\n+    }\n+\n+    String name = getField(document, Core.TITLE + \"_txt\", String.class);\n+    if (StringUtils.isNotBlank(name)) {\n+      geoEntryBuilder.name(name);\n+    }\n+\n+    Long population =\n+        getField(document, GeoEntryAttributes.POPULATION_ATTRIBUTE_NAME + \"_lng\", Long.class);\n+    if (population != null) {\n+      geoEntryBuilder.population(population);\n+    }\n+\n+    Integer sortValue =\n+        getField(document, GeoEntryAttributes.GAZETTEER_SORT_VALUE + \"_int\", Integer.class);\n+    if (sortValue != null) {\n+      geoEntryBuilder.gazetteerSort(sortValue);\n+    }\n+\n+    String location = getField(document, Core.LOCATION + \"_geo\", String.class);\n+    if (StringUtils.isNotBlank(location)) {\n+      try {\n+        Geometry geometry = WKT_READER_THREAD_LOCAL.get().read(location);\n+        Point coordinate = geometry.getCentroid();\n+        if (!coordinate.isEmpty()) {\n+          Double lat = coordinate.getY();\n+          Double lon = coordinate.getX();\n+          geoEntryBuilder.latitude(lat);\n+          geoEntryBuilder.longitude(lon);\n+        }\n+      } catch (org.locationtech.jts.io.ParseException e) {\n+        LOGGER.debug(\"GeoEntry metacard does not contain (readable) location attribute.\");\n+      }\n+    }\n+    return geoEntryBuilder.build();\n+  }\n+\n+  private <T> T getField(SolrDocument document, String attribute, Class<T> clazz) {\n+    return Optional.of(document)\n+        .map(d -> d.get(attribute))\n+        .filter(List.class::isInstance)", "originalCommit": "da7f3def8635d75cf1d73988ed479c2def44f589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk1NTkzOA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r453955938", "bodyText": "At least in my testing, there was only one attribute that was not multivalued -- id_txt. I think this goes back to us not respecting the actual multivalued property of an attribute. Looks like the schema.xml confirms this, listing all our dynamic fields as multiValued.", "author": "rzwiefel", "createdAt": "2020-07-13T21:51:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyNzUwMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczNzI5OA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r454737298", "bodyText": "Okay as long as id_txt cases never flow through here, fine by me \ud83d\udc4d", "author": "Lambeaux", "createdAt": "2020-07-15T01:31:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyNzUwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyOTU5Ng==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451229596", "bodyText": "\u270f\ufe0f  Why is this public and why does it live in the plugin and not in the solr object? If you have public static constants in both classes then I would reconsider and pull them out into a constants class (or some other local abstraction).", "author": "Lambeaux", "createdAt": "2020-07-08T01:23:14Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/OfflineGazetteerPlugin.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import static ddf.catalog.Constants.SUGGESTION_BUILD_KEY;\n+\n+import ddf.catalog.data.Attribute;\n+import ddf.catalog.data.Metacard;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import ddf.catalog.operation.CreateResponse;\n+import ddf.catalog.operation.DeleteResponse;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.Update;\n+import ddf.catalog.operation.UpdateResponse;\n+import ddf.catalog.plugin.PluginExecutionException;\n+import ddf.catalog.plugin.PostIngestPlugin;\n+import ddf.catalog.plugin.PreQueryPlugin;\n+import ddf.catalog.plugin.StopProcessingException;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class OfflineGazetteerPlugin implements PostIngestPlugin, PreQueryPlugin {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(OfflineGazetteerPlugin.class);\n+  private static final String GAZETTEER_METACARD_TAG = \"gazetteer\";\n+  public static final String STANDALONE_GAZETTEER_CORE_NAME = \"standalone-solr-gazetteer\";", "originalCommit": "da7f3def8635d75cf1d73988ed479c2def44f589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk2NTc5Ng==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r453965796", "bodyText": "Added a gazetteer constants class \ud83d\udc4d", "author": "rzwiefel", "createdAt": "2020-07-13T22:05:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIyOTU5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMDM5MA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451230390", "bodyText": "\u2753 Is this done synchronously and if it's not how do we handle async failure since there are parallel paths where side effects occur? I'm referring to the persistence of the separate records in the separate cores in Solr.\nThis comment applies to all other calls to the Solr client in this class.", "author": "Lambeaux", "createdAt": "2020-07-08T01:26:12Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/OfflineGazetteerPlugin.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import static ddf.catalog.Constants.SUGGESTION_BUILD_KEY;\n+\n+import ddf.catalog.data.Attribute;\n+import ddf.catalog.data.Metacard;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import ddf.catalog.operation.CreateResponse;\n+import ddf.catalog.operation.DeleteResponse;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.Update;\n+import ddf.catalog.operation.UpdateResponse;\n+import ddf.catalog.plugin.PluginExecutionException;\n+import ddf.catalog.plugin.PostIngestPlugin;\n+import ddf.catalog.plugin.PreQueryPlugin;\n+import ddf.catalog.plugin.StopProcessingException;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class OfflineGazetteerPlugin implements PostIngestPlugin, PreQueryPlugin {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(OfflineGazetteerPlugin.class);\n+  private static final String GAZETTEER_METACARD_TAG = \"gazetteer\";\n+  public static final String STANDALONE_GAZETTEER_CORE_NAME = \"standalone-solr-gazetteer\";\n+\n+  private final SolrClientFactory clientFactory;\n+  private final SolrClient solrClient;\n+\n+  public OfflineGazetteerPlugin(SolrClientFactory clientFactory) {\n+    this.clientFactory = clientFactory;\n+    this.solrClient = clientFactory.newClient(STANDALONE_GAZETTEER_CORE_NAME);\n+  }\n+\n+  @Override\n+  public CreateResponse process(CreateResponse input) throws PluginExecutionException {\n+    List<Metacard> gazetteerMetacards =\n+        input\n+            .getCreatedMetacards()\n+            .stream()\n+            .filter(this::isGazetteerMetacard)\n+            .collect(Collectors.toList());\n+\n+    if (gazetteerMetacards.isEmpty()) {\n+      return input;\n+    }\n+\n+    try {\n+      solrClient.add(", "originalCommit": "da7f3def8635d75cf1d73988ed479c2def44f589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY1MzEyNw==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451653127", "bodyText": "All the calls I saw in this PR to the Solrj client should be synchronous.", "author": "pklinef", "createdAt": "2020-07-08T15:57:18Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMDM5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkxNTQyOQ==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r453915429", "bodyText": "\u2753 @pklinef @rzwiefel Okay so no async concerns but regarding the data itself, what if the first solr operation succeeds but the main catalog provider one fails? Can an admin go back in via CLI and delete things from the gazetteer solr core by ID? Or set of IDs? Or are those kinds of cases what the sync command is for?", "author": "Lambeaux", "createdAt": "2020-07-13T20:33:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMDM5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MzkyODE3NA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r453928174", "bodyText": "This is a PostIngestPlugin method so the Catalog provider has already succeeded by this point.  The worst case is that the add to the gazetteer collection would fail and would need to be added again using the sync command.  If something got into the gazetteer collection that should not be there then you would need to call the gazetteer removeall command before sync.", "author": "pklinef", "createdAt": "2020-07-13T20:57:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMDM5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk3Mzg4OQ==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r453973889", "bodyText": "Yeah even with ~70k records only takes 5-10 minutes to delete and resync all records. On a performant production system I'd guess you could make time on that as well.", "author": "rzwiefel", "createdAt": "2020-07-13T22:17:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMDM5MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDczNzcxMw==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r454737713", "bodyText": "Cool \ud83d\udc4d", "author": "Lambeaux", "createdAt": "2020-07-15T01:33:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMDM5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMTA5MA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451231090", "bodyText": "\u2753 Will this overwrite existing records with the same ID or does it behave immutably? I ask because this is a catalog update.", "author": "Lambeaux", "createdAt": "2020-07-08T01:29:00Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/OfflineGazetteerPlugin.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import static ddf.catalog.Constants.SUGGESTION_BUILD_KEY;\n+\n+import ddf.catalog.data.Attribute;\n+import ddf.catalog.data.Metacard;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import ddf.catalog.operation.CreateResponse;\n+import ddf.catalog.operation.DeleteResponse;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.Update;\n+import ddf.catalog.operation.UpdateResponse;\n+import ddf.catalog.plugin.PluginExecutionException;\n+import ddf.catalog.plugin.PostIngestPlugin;\n+import ddf.catalog.plugin.PreQueryPlugin;\n+import ddf.catalog.plugin.StopProcessingException;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class OfflineGazetteerPlugin implements PostIngestPlugin, PreQueryPlugin {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(OfflineGazetteerPlugin.class);\n+  private static final String GAZETTEER_METACARD_TAG = \"gazetteer\";\n+  public static final String STANDALONE_GAZETTEER_CORE_NAME = \"standalone-solr-gazetteer\";\n+\n+  private final SolrClientFactory clientFactory;\n+  private final SolrClient solrClient;\n+\n+  public OfflineGazetteerPlugin(SolrClientFactory clientFactory) {\n+    this.clientFactory = clientFactory;\n+    this.solrClient = clientFactory.newClient(STANDALONE_GAZETTEER_CORE_NAME);\n+  }\n+\n+  @Override\n+  public CreateResponse process(CreateResponse input) throws PluginExecutionException {\n+    List<Metacard> gazetteerMetacards =\n+        input\n+            .getCreatedMetacards()\n+            .stream()\n+            .filter(this::isGazetteerMetacard)\n+            .collect(Collectors.toList());\n+\n+    if (gazetteerMetacards.isEmpty()) {\n+      return input;\n+    }\n+\n+    try {\n+      solrClient.add(\n+          STANDALONE_GAZETTEER_CORE_NAME,\n+          gazetteerMetacards\n+              .stream()\n+              .map(OfflineGazetteerPlugin::convert)\n+              .collect(Collectors.toList()));\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Error while processing gazetteer data\", e);\n+      throw new PluginExecutionException(e);\n+    }\n+\n+    return input;\n+  }\n+\n+  @Override\n+  public UpdateResponse process(UpdateResponse input) throws PluginExecutionException {\n+    List<Metacard> gazetteerMetacards =\n+        input\n+            .getUpdatedMetacards()\n+            .stream()\n+            .map(Update::getNewMetacard)\n+            .filter(this::isGazetteerMetacard)\n+            .collect(Collectors.toList());\n+\n+    if (gazetteerMetacards.isEmpty()) {\n+      return input;\n+    }\n+\n+    try {\n+      solrClient.add(", "originalCommit": "da7f3def8635d75cf1d73988ed479c2def44f589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY1NDEwNQ==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451654105", "bodyText": "Solr add works like an upsert when not using document versions so it will add or update.", "author": "pklinef", "createdAt": "2020-07-08T15:58:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMTA5MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzMjIyMA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451232220", "bodyText": "\u2753 Using attribute and attr tells me nothing, how about attrName and attrVal instead?", "author": "Lambeaux", "createdAt": "2020-07-08T01:33:24Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/OfflineGazetteerPlugin.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import static ddf.catalog.Constants.SUGGESTION_BUILD_KEY;\n+\n+import ddf.catalog.data.Attribute;\n+import ddf.catalog.data.Metacard;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import ddf.catalog.operation.CreateResponse;\n+import ddf.catalog.operation.DeleteResponse;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.Update;\n+import ddf.catalog.operation.UpdateResponse;\n+import ddf.catalog.plugin.PluginExecutionException;\n+import ddf.catalog.plugin.PostIngestPlugin;\n+import ddf.catalog.plugin.PreQueryPlugin;\n+import ddf.catalog.plugin.StopProcessingException;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class OfflineGazetteerPlugin implements PostIngestPlugin, PreQueryPlugin {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(OfflineGazetteerPlugin.class);\n+  private static final String GAZETTEER_METACARD_TAG = \"gazetteer\";\n+  public static final String STANDALONE_GAZETTEER_CORE_NAME = \"standalone-solr-gazetteer\";\n+\n+  private final SolrClientFactory clientFactory;\n+  private final SolrClient solrClient;\n+\n+  public OfflineGazetteerPlugin(SolrClientFactory clientFactory) {\n+    this.clientFactory = clientFactory;\n+    this.solrClient = clientFactory.newClient(STANDALONE_GAZETTEER_CORE_NAME);\n+  }\n+\n+  @Override\n+  public CreateResponse process(CreateResponse input) throws PluginExecutionException {\n+    List<Metacard> gazetteerMetacards =\n+        input\n+            .getCreatedMetacards()\n+            .stream()\n+            .filter(this::isGazetteerMetacard)\n+            .collect(Collectors.toList());\n+\n+    if (gazetteerMetacards.isEmpty()) {\n+      return input;\n+    }\n+\n+    try {\n+      solrClient.add(\n+          STANDALONE_GAZETTEER_CORE_NAME,\n+          gazetteerMetacards\n+              .stream()\n+              .map(OfflineGazetteerPlugin::convert)\n+              .collect(Collectors.toList()));\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Error while processing gazetteer data\", e);\n+      throw new PluginExecutionException(e);\n+    }\n+\n+    return input;\n+  }\n+\n+  @Override\n+  public UpdateResponse process(UpdateResponse input) throws PluginExecutionException {\n+    List<Metacard> gazetteerMetacards =\n+        input\n+            .getUpdatedMetacards()\n+            .stream()\n+            .map(Update::getNewMetacard)\n+            .filter(this::isGazetteerMetacard)\n+            .collect(Collectors.toList());\n+\n+    if (gazetteerMetacards.isEmpty()) {\n+      return input;\n+    }\n+\n+    try {\n+      solrClient.add(\n+          STANDALONE_GAZETTEER_CORE_NAME,\n+          gazetteerMetacards\n+              .stream()\n+              .map(OfflineGazetteerPlugin::convert)\n+              .collect(Collectors.toList()));\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Error while processing gazetteer data\", e);\n+      throw new PluginExecutionException(e);\n+    }\n+    return input;\n+  }\n+\n+  @Override\n+  public DeleteResponse process(DeleteResponse input) throws PluginExecutionException {\n+    List<String> ids =\n+        input\n+            .getDeletedMetacards()\n+            .stream()\n+            .filter(this::isGazetteerMetacard)\n+            .map(Metacard::getId)\n+            .collect(Collectors.toList());\n+    if (ids.isEmpty()) {\n+      return input;\n+    }\n+\n+    try {\n+      solrClient.deleteById(ids);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Error while processing gazetteer data\", e);\n+      throw new PluginExecutionException(e);\n+    }\n+\n+    return input;\n+  }\n+\n+  protected static SolrInputDocument convert(Metacard metacard) {\n+    SolrInputDocument solrDoc = new SolrInputDocument();\n+    Consumer<String> getAttrAndAdd =\n+        (attribute) ->\n+            Optional.ofNullable(getStringAttribute(metacard, attribute))\n+                .ifPresent(attr -> solrDoc.addField(attribute + \"_txt\", attr));", "originalCommit": "da7f3def8635d75cf1d73988ed479c2def44f589", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzNDc3MA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451234770", "bodyText": "\u270f\ufe0f  Let's annotate with @Nullable", "author": "Lambeaux", "createdAt": "2020-07-08T01:43:21Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/OfflineGazetteerPlugin.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import static ddf.catalog.Constants.SUGGESTION_BUILD_KEY;\n+\n+import ddf.catalog.data.Attribute;\n+import ddf.catalog.data.Metacard;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import ddf.catalog.operation.CreateResponse;\n+import ddf.catalog.operation.DeleteResponse;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.Update;\n+import ddf.catalog.operation.UpdateResponse;\n+import ddf.catalog.plugin.PluginExecutionException;\n+import ddf.catalog.plugin.PostIngestPlugin;\n+import ddf.catalog.plugin.PreQueryPlugin;\n+import ddf.catalog.plugin.StopProcessingException;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class OfflineGazetteerPlugin implements PostIngestPlugin, PreQueryPlugin {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(OfflineGazetteerPlugin.class);\n+  private static final String GAZETTEER_METACARD_TAG = \"gazetteer\";\n+  public static final String STANDALONE_GAZETTEER_CORE_NAME = \"standalone-solr-gazetteer\";\n+\n+  private final SolrClientFactory clientFactory;\n+  private final SolrClient solrClient;\n+\n+  public OfflineGazetteerPlugin(SolrClientFactory clientFactory) {\n+    this.clientFactory = clientFactory;\n+    this.solrClient = clientFactory.newClient(STANDALONE_GAZETTEER_CORE_NAME);\n+  }\n+\n+  @Override\n+  public CreateResponse process(CreateResponse input) throws PluginExecutionException {\n+    List<Metacard> gazetteerMetacards =\n+        input\n+            .getCreatedMetacards()\n+            .stream()\n+            .filter(this::isGazetteerMetacard)\n+            .collect(Collectors.toList());\n+\n+    if (gazetteerMetacards.isEmpty()) {\n+      return input;\n+    }\n+\n+    try {\n+      solrClient.add(\n+          STANDALONE_GAZETTEER_CORE_NAME,\n+          gazetteerMetacards\n+              .stream()\n+              .map(OfflineGazetteerPlugin::convert)\n+              .collect(Collectors.toList()));\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Error while processing gazetteer data\", e);\n+      throw new PluginExecutionException(e);\n+    }\n+\n+    return input;\n+  }\n+\n+  @Override\n+  public UpdateResponse process(UpdateResponse input) throws PluginExecutionException {\n+    List<Metacard> gazetteerMetacards =\n+        input\n+            .getUpdatedMetacards()\n+            .stream()\n+            .map(Update::getNewMetacard)\n+            .filter(this::isGazetteerMetacard)\n+            .collect(Collectors.toList());\n+\n+    if (gazetteerMetacards.isEmpty()) {\n+      return input;\n+    }\n+\n+    try {\n+      solrClient.add(\n+          STANDALONE_GAZETTEER_CORE_NAME,\n+          gazetteerMetacards\n+              .stream()\n+              .map(OfflineGazetteerPlugin::convert)\n+              .collect(Collectors.toList()));\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Error while processing gazetteer data\", e);\n+      throw new PluginExecutionException(e);\n+    }\n+    return input;\n+  }\n+\n+  @Override\n+  public DeleteResponse process(DeleteResponse input) throws PluginExecutionException {\n+    List<String> ids =\n+        input\n+            .getDeletedMetacards()\n+            .stream()\n+            .filter(this::isGazetteerMetacard)\n+            .map(Metacard::getId)\n+            .collect(Collectors.toList());\n+    if (ids.isEmpty()) {\n+      return input;\n+    }\n+\n+    try {\n+      solrClient.deleteById(ids);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.debug(\"Error while processing gazetteer data\", e);\n+      throw new PluginExecutionException(e);\n+    }\n+\n+    return input;\n+  }\n+\n+  protected static SolrInputDocument convert(Metacard metacard) {\n+    SolrInputDocument solrDoc = new SolrInputDocument();\n+    Consumer<String> getAttrAndAdd =\n+        (attribute) ->\n+            Optional.ofNullable(getStringAttribute(metacard, attribute))\n+                .ifPresent(attr -> solrDoc.addField(attribute + \"_txt\", attr));\n+\n+    getAttrAndAdd.accept(Metacard.DESCRIPTION);\n+    getAttrAndAdd.accept(GeoEntryAttributes.FEATURE_CODE_ATTRIBUTE_NAME);\n+    getAttrAndAdd.accept(Core.TITLE);\n+    getAttrAndAdd.accept(Core.ID);\n+    getAttrAndAdd.accept(Location.COUNTRY_CODE);\n+\n+    Optional.of(metacard)\n+        .map(m -> getStringAttribute(m, Core.LOCATION))\n+        .ifPresent(v -> solrDoc.addField(Core.LOCATION + \"_geo\", v));\n+\n+    Optional.of(metacard)\n+        .map(m -> m.getAttribute(GeoEntryAttributes.POPULATION_ATTRIBUTE_NAME))\n+        .map(Attribute::getValue)\n+        .filter(Long.class::isInstance)\n+        .map(Long.class::cast)\n+        .ifPresent(v -> solrDoc.addField(GeoEntryAttributes.POPULATION_ATTRIBUTE_NAME + \"_lng\", v));\n+\n+    Optional.of(metacard)\n+        .map(m -> m.getAttribute(GeoEntryAttributes.GAZETTEER_SORT_VALUE))\n+        .map(Attribute::getValue)\n+        .filter(Integer.class::isInstance)\n+        .map(Integer.class::cast)\n+        .ifPresent(v -> solrDoc.addField(GeoEntryAttributes.GAZETTEER_SORT_VALUE + \"_int\", v));\n+\n+    return solrDoc;\n+  }\n+\n+  private static String getStringAttribute(Metacard metacard, String attributeName) {", "originalCommit": "da7f3def8635d75cf1d73988ed479c2def44f589", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzOTY5Ng==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451239696", "bodyText": "\u2753 I don't remember if Karaf supports constructor injection for commands. I think there are issues with it. I know we have tried to do it in the past but hit issues and had to resort to bundle context manipulation:\nhttps://github.com/codice/ddf-ui/blob/master/ui-backend/catalog-ui-search/src/main/java/org/codice/ddf/catalog/ui/forms/commands/SearchFormsManageCommand.java#L77\nhttps://github.com/codice/ddf-ui/blob/master/ui-backend/catalog-ui-search/src/main/java/org/codice/ddf/catalog/ui/forms/commands/SearchFormsLoaderCommand.java#L75\nThat being said do we need this setter?", "author": "Lambeaux", "createdAt": "2020-07-08T02:02:29Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/RemoveAllOfflineSolrGazetteerCommand.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.util.concurrent.TimeUnit;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.karaf.shell.api.action.Action;\n+import org.apache.karaf.shell.api.action.Command;\n+import org.apache.karaf.shell.api.action.Option;\n+import org.apache.karaf.shell.api.action.lifecycle.Reference;\n+import org.apache.karaf.shell.api.action.lifecycle.Service;\n+import org.apache.karaf.shell.api.console.Session;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.client.solrj.UnavailableSolrException;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Service\n+@Command(\n+  scope = \"offline-solr-gazetteer\",\n+  name = \"removeall\",\n+  description = \"Deletes all items in the offline solr gazetteer solr core\"\n+)\n+public class RemoveAllOfflineSolrGazetteerCommand implements Action {\n+  private static final Logger LOGGER =\n+      LoggerFactory.getLogger(RemoveAllOfflineSolrGazetteerCommand.class);\n+\n+  @Reference protected Session session;\n+\n+  @Reference private SolrClientFactory clientFactory;\n+\n+  @Option(\n+    name = \"--force\",\n+    aliases = {\"-f\"},\n+    description = \"Force the removal without a confirmation message.\"\n+  )\n+  boolean force = false;\n+\n+  private final RetryPolicy retryPolicy =\n+      new RetryPolicy()\n+          .retryOn(ImmutableList.of(UnavailableSolrException.class, SolrServerException.class))\n+          .withMaxDuration(5, TimeUnit.SECONDS)\n+          .withBackoff(25, 1_000, TimeUnit.MILLISECONDS);\n+\n+  @Override\n+  public Object execute() throws Exception {\n+    if (!force) {\n+      String answer =\n+          session\n+              .readLine(\n+                  \"Are you sure you want to remove all gazetteer entries inside of the offline solr gazetteer core?(y/n)\",\n+                  ' ')\n+              .toLowerCase();\n+      if (!(\"y\".equals(answer) || \"yes\".equals(answer))) {\n+        session.getConsole().println(\"Aborting.\");\n+        return null;\n+      }\n+    }\n+    try {\n+      SolrClient solrClient =\n+          clientFactory.newClient(OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME);\n+\n+      Failsafe.with(retryPolicy).get(() -> solrClient.deleteByQuery(\"*:*\"));\n+    } catch (Exception e) {\n+      LOGGER.info(\"Error while executing\", e);\n+      session.getConsole().println(\"Error while submitting remove all, exiting.\");\n+      throw e;\n+    }\n+    session.getConsole().println(\"Removeall submitted successfully.\");\n+    return null;\n+  }\n+\n+  public void setClientFactory(SolrClientFactory clientFactory) {", "originalCommit": "da7f3def8635d75cf1d73988ed479c2def44f589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk5NTEzMw==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r453995133", "bodyText": "Don't think we need the setter \ud83d\udc4d", "author": "rzwiefel", "createdAt": "2020-07-13T23:01:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzOTY5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzOTkxMw==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451239913", "bodyText": "\u270f\ufe0f   wrong class - should be SyncCatalogCommand.class", "author": "Lambeaux", "createdAt": "2020-07-08T02:03:18Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/SyncCatalogCommand.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import ddf.catalog.CatalogFramework;\n+import ddf.catalog.data.Result;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.filter.FilterBuilder;\n+import ddf.catalog.filter.impl.SortByImpl;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.impl.QueryImpl;\n+import ddf.catalog.operation.impl.QueryRequestImpl;\n+import ddf.catalog.util.impl.ResultIterable;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.karaf.shell.api.action.Action;\n+import org.apache.karaf.shell.api.action.Command;\n+import org.apache.karaf.shell.api.action.lifecycle.Reference;\n+import org.apache.karaf.shell.api.action.lifecycle.Service;\n+import org.apache.karaf.shell.api.console.Session;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.codice.ddf.security.Security;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.client.solrj.UnavailableSolrException;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.opengis.filter.sort.SortOrder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Service\n+@Command(\n+  scope = \"offline-solr-gazetteer\",\n+  name = \"synccatalog\",\n+  description = \"Syncs all catalog items to the offline solr gazetteer core\"\n+)\n+public class SyncCatalogCommand implements Action {\n+\n+  private static final Logger LOGGER =\n+      LoggerFactory.getLogger(RemoveAllOfflineSolrGazetteerCommand.class);", "originalCommit": "da7f3def8635d75cf1d73988ed479c2def44f589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY1ODkzNw==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451658937", "bodyText": "Good, I am not the only one who makes this mistake.  \ud83d\ude09", "author": "pklinef", "createdAt": "2020-07-08T16:06:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzOTkxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY4NjI2NA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451686264", "bodyText": "@pklinef when he caught this i immediately thought, \"You know, maybe we do do this on purpose.....\" \ud83d\ude02", "author": "rzwiefel", "createdAt": "2020-07-08T16:48:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzOTkxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY4ODE0Mg==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451688142", "bodyText": "Maybe it is time to figure out how to make an Intellij macro to do this for me instead of copy and paste.", "author": "pklinef", "createdAt": "2020-07-08T16:51:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzOTkxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcwMjQ3MQ==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451702471", "bodyText": "I actually had an intellij Live Template for this, but when i upgraded computers or something long ago I lost it. time to go do it again. I'll post here if/when i get it figured", "author": "rzwiefel", "createdAt": "2020-07-08T17:15:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzOTkxMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTcwNTM0MA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451705340", "bodyText": "@pklinef", "author": "rzwiefel", "createdAt": "2020-07-08T17:20:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTIzOTkxMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MTUzMg==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451241532", "bodyText": "\ud83d\udc4d  Yes. Absolutely.", "author": "Lambeaux", "createdAt": "2020-07-08T02:09:42Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/SyncCatalogCommand.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import ddf.catalog.CatalogFramework;\n+import ddf.catalog.data.Result;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.filter.FilterBuilder;\n+import ddf.catalog.filter.impl.SortByImpl;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.impl.QueryImpl;\n+import ddf.catalog.operation.impl.QueryRequestImpl;\n+import ddf.catalog.util.impl.ResultIterable;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.karaf.shell.api.action.Action;\n+import org.apache.karaf.shell.api.action.Command;\n+import org.apache.karaf.shell.api.action.lifecycle.Reference;\n+import org.apache.karaf.shell.api.action.lifecycle.Service;\n+import org.apache.karaf.shell.api.console.Session;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.codice.ddf.security.Security;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.client.solrj.UnavailableSolrException;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.opengis.filter.sort.SortOrder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Service\n+@Command(\n+  scope = \"offline-solr-gazetteer\",\n+  name = \"synccatalog\",\n+  description = \"Syncs all catalog items to the offline solr gazetteer core\"\n+)\n+public class SyncCatalogCommand implements Action {\n+\n+  private static final Logger LOGGER =\n+      LoggerFactory.getLogger(RemoveAllOfflineSolrGazetteerCommand.class);\n+  public static final int PARTITION_SIZE = 256;\n+\n+  @Reference private SolrClientFactory clientFactory;\n+\n+  @Reference private Session session;\n+\n+  @Reference private CatalogFramework catalogFramework;\n+  @Reference private FilterBuilder filterBuilder;\n+  @Reference private Security security;\n+\n+  private final RetryPolicy retryPolicy =\n+      new RetryPolicy()\n+          .retryOn(ImmutableList.of(UnavailableSolrException.class, SolrServerException.class))\n+          .withMaxDuration(5, TimeUnit.SECONDS)\n+          .withBackoff(50, 1_000, TimeUnit.MILLISECONDS);\n+\n+  @Override\n+  public Object execute() throws Exception {\n+    return security.runWithSubjectOrElevate(this::executeWithSubject);\n+  }\n+\n+  public Object executeWithSubject() throws Exception {\n+    SolrClient solrClient =\n+        clientFactory.newClient(OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME);\n+\n+    Failsafe.with(retryPolicy).get(() -> solrClient.ping());\n+\n+    Iterable<Result> iterable =\n+        ResultIterable.resultIterable(catalogFramework, getGazetteerFilter());\n+\n+    session.getConsole().println(\"Starting sync...\");\n+    long counter = 0;\n+    Instant start = Instant.now();\n+\n+    for (List<Result> results : Iterables.partition(iterable, PARTITION_SIZE)) {\n+      if (Thread.interrupted()) {", "originalCommit": "da7f3def8635d75cf1d73988ed479c2def44f589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY2NDQxNQ==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451664415", "bodyText": "I was not aware of this.\nhttps://github.com/apache/karaf/blob/cffa8250da16c9be9023ea5abeaddfc3bae4e746/shell/console/src/main/java/org/apache/karaf/shell/console/AbstractAction.java#L39-L49", "author": "pklinef", "createdAt": "2020-07-08T16:14:46Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MTUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2NDE4Nw==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451764187", "bodyText": "@pklinef Would you prefer using that built in method?", "author": "rzwiefel", "createdAt": "2020-07-08T19:04:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MTUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc2NjE0Ng==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451766146", "bodyText": "I do not have a strong preference but might as well use it just in case they add future fixes to it.  For example, what does the additional yield provide?", "author": "pklinef", "createdAt": "2020-07-08T19:08:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MTUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc3Nzk3NA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451777974", "bodyText": "(after looking into it while waiting for your response- ) I think i'm inclined to say the opposite. Particularly because of the yield. Most literature aligns with the javadoc that yield should rarely ever be used except in specific scenarios (coupled with thorough profiling and testing). Using it in a common utility method seems to go against those conditions. Let alone with i'm not really sure what yield would accomplish in this scenario. If something were polling (or some kind of busy wait loop) it might make more sense.", "author": "rzwiefel", "createdAt": "2020-07-08T19:30:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MTUzMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTc5MzcyNw==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451793727", "bodyText": "Hard to say since this is probably a thread running under JLine which handles console key events like crtl+c.\nI did see other examples in Karaf where they do not do the Thread.yield() and only do Thread.interrupted().\nI checked the commit but did not find any more details on why that method includes Thread.yield().\napache/karaf@220e260\nHere is the other example where they do not use Thread.yield().\nhttps://github.com/apache/karaf/blob/cffa8250da16c9be9023ea5abeaddfc3bae4e746/shell/core/src/main/java/org/apache/karaf/shell/impl/console/commands/Procedural.java#L566-L569\nLooks like JLine also does it both ways.  Same developers contributing to JLine and Karaf though so not surprising.\nhttps://github.com/search?q=org%3Ajline+Thread+isInterrupted&type=Code\nI also noticed they use Thread.currentThread().isInterrupted() but Thread.isInterrupted() does the same thing since Java 6.\nhttps://github.com/AdoptOpenJDK/openjdk-jdk8u/blob/master/jdk/src/share/classes/java/lang/Thread.java#L946-L948\nFound this article that gives some of the OS level details about what Thread.yield() does but it also concludes you should practically never use it.\nhttps://www.javamex.com/tutorials/threads/yield.shtml", "author": "pklinef", "createdAt": "2020-07-08T20:02:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTI0MTUzMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY0MTIxNA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451641214", "bodyText": "Should this be not public and be annotated as VisibleForTesting", "author": "lamhuy", "createdAt": "2020-07-08T15:39:59Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/RemoveAllOfflineSolrGazetteerCommand.java", "diffHunk": "@@ -0,0 +1,91 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import com.google.common.collect.ImmutableList;\n+import java.util.concurrent.TimeUnit;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.karaf.shell.api.action.Action;\n+import org.apache.karaf.shell.api.action.Command;\n+import org.apache.karaf.shell.api.action.Option;\n+import org.apache.karaf.shell.api.action.lifecycle.Reference;\n+import org.apache.karaf.shell.api.action.lifecycle.Service;\n+import org.apache.karaf.shell.api.console.Session;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.client.solrj.UnavailableSolrException;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Service\n+@Command(\n+  scope = \"offline-solr-gazetteer\",\n+  name = \"removeall\",\n+  description = \"Deletes all items in the offline solr gazetteer solr core\"\n+)\n+public class RemoveAllOfflineSolrGazetteerCommand implements Action {\n+  private static final Logger LOGGER =\n+      LoggerFactory.getLogger(RemoveAllOfflineSolrGazetteerCommand.class);\n+\n+  @Reference protected Session session;\n+\n+  @Reference private SolrClientFactory clientFactory;\n+\n+  @Option(\n+    name = \"--force\",\n+    aliases = {\"-f\"},\n+    description = \"Force the removal without a confirmation message.\"\n+  )\n+  boolean force = false;\n+\n+  private final RetryPolicy retryPolicy =\n+      new RetryPolicy()\n+          .retryOn(ImmutableList.of(UnavailableSolrException.class, SolrServerException.class))\n+          .withMaxDuration(5, TimeUnit.SECONDS)\n+          .withBackoff(25, 1_000, TimeUnit.MILLISECONDS);\n+\n+  @Override\n+  public Object execute() throws Exception {\n+    if (!force) {\n+      String answer =\n+          session\n+              .readLine(\n+                  \"Are you sure you want to remove all gazetteer entries inside of the offline solr gazetteer core?(y/n)\",\n+                  ' ')\n+              .toLowerCase();\n+      if (!(\"y\".equals(answer) || \"yes\".equals(answer))) {\n+        session.getConsole().println(\"Aborting.\");\n+        return null;\n+      }\n+    }\n+    try {\n+      SolrClient solrClient =\n+          clientFactory.newClient(OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME);\n+\n+      Failsafe.with(retryPolicy).get(() -> solrClient.deleteByQuery(\"*:*\"));\n+    } catch (Exception e) {\n+      LOGGER.info(\"Error while executing\", e);\n+      session.getConsole().println(\"Error while submitting remove all, exiting.\");\n+      throw e;\n+    }\n+    session.getConsole().println(\"Removeall submitted successfully.\");\n+    return null;\n+  }\n+\n+  public void setClientFactory(SolrClientFactory clientFactory) {", "originalCommit": "da7f3def8635d75cf1d73988ed479c2def44f589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk5ODAyOA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r453998028", "bodyText": "it was removed since not needed", "author": "rzwiefel", "createdAt": "2020-07-13T23:10:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY0MTIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY0ODM2Mg==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451648362", "bodyText": "would be nice to print some kind of progress bar. similar to this? https://github.com/codice/ddf/blob/master/catalog/core/catalog-core-commands/src/main/java/org/codice/ddf/commands/catalog/CommandSupport.java#L68", "author": "lamhuy", "createdAt": "2020-07-08T15:50:37Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/SyncCatalogCommand.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import ddf.catalog.CatalogFramework;\n+import ddf.catalog.data.Result;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.filter.FilterBuilder;\n+import ddf.catalog.filter.impl.SortByImpl;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.impl.QueryImpl;\n+import ddf.catalog.operation.impl.QueryRequestImpl;\n+import ddf.catalog.util.impl.ResultIterable;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.karaf.shell.api.action.Action;\n+import org.apache.karaf.shell.api.action.Command;\n+import org.apache.karaf.shell.api.action.lifecycle.Reference;\n+import org.apache.karaf.shell.api.action.lifecycle.Service;\n+import org.apache.karaf.shell.api.console.Session;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.codice.ddf.security.Security;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.client.solrj.UnavailableSolrException;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.opengis.filter.sort.SortOrder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Service\n+@Command(\n+  scope = \"offline-solr-gazetteer\",\n+  name = \"synccatalog\",\n+  description = \"Syncs all catalog items to the offline solr gazetteer core\"\n+)\n+public class SyncCatalogCommand implements Action {\n+\n+  private static final Logger LOGGER =\n+      LoggerFactory.getLogger(RemoveAllOfflineSolrGazetteerCommand.class);\n+  public static final int PARTITION_SIZE = 256;\n+\n+  @Reference private SolrClientFactory clientFactory;\n+\n+  @Reference private Session session;\n+\n+  @Reference private CatalogFramework catalogFramework;\n+  @Reference private FilterBuilder filterBuilder;\n+  @Reference private Security security;\n+\n+  private final RetryPolicy retryPolicy =\n+      new RetryPolicy()\n+          .retryOn(ImmutableList.of(UnavailableSolrException.class, SolrServerException.class))\n+          .withMaxDuration(5, TimeUnit.SECONDS)\n+          .withBackoff(50, 1_000, TimeUnit.MILLISECONDS);\n+\n+  @Override\n+  public Object execute() throws Exception {\n+    return security.runWithSubjectOrElevate(this::executeWithSubject);\n+  }\n+\n+  public Object executeWithSubject() throws Exception {\n+    SolrClient solrClient =\n+        clientFactory.newClient(OfflineGazetteerPlugin.STANDALONE_GAZETTEER_CORE_NAME);\n+\n+    Failsafe.with(retryPolicy).get(() -> solrClient.ping());\n+\n+    Iterable<Result> iterable =\n+        ResultIterable.resultIterable(catalogFramework, getGazetteerFilter());\n+\n+    session.getConsole().println(\"Starting sync...\");\n+    long counter = 0;\n+    Instant start = Instant.now();\n+\n+    for (List<Result> results : Iterables.partition(iterable, PARTITION_SIZE)) {\n+      if (Thread.interrupted()) {\n+        LOGGER.info(\"Catalog sync interrupted early, exiting\");\n+        session.getConsole().println(\"Catalog sync interrupted, exiting\");\n+        Thread.currentThread().interrupt();\n+        throw new InterruptedException();\n+      }\n+\n+      try {\n+        solrClient.add(\n+            results\n+                .stream()\n+                .map(Result::getMetacard)\n+                .map(OfflineGazetteerPlugin::convert)\n+                .collect(Collectors.toList()));\n+      } catch (SolrServerException | IOException e) {\n+        LOGGER.info(\"error while adding items to solr\", e);\n+        session.getConsole().printf(\"An error occured while syncing: %s\", e.getMessage());\n+        throw e;\n+      }\n+      counter += results.size();", "originalCommit": "da7f3def8635d75cf1d73988ed479c2def44f589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk5ODYyOA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r453998628", "bodyText": "It would be nice yes \ud83d\ude04 , but it would require doing extra queries to find out the total number of results. Unless you have strong opinions on having the progress bar i'll leave this as a possible follow on/ later task.", "author": "rzwiefel", "createdAt": "2020-07-13T23:12:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY0ODM2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY0OTIwOA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451649208", "bodyText": "\u270f\ufe0f   SyncCatalogCommand", "author": "lamhuy", "createdAt": "2020-07-08T15:51:46Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/SyncCatalogCommand.java", "diffHunk": "@@ -0,0 +1,135 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import com.google.common.collect.ImmutableList;\n+import com.google.common.collect.Iterables;\n+import ddf.catalog.CatalogFramework;\n+import ddf.catalog.data.Result;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.filter.FilterBuilder;\n+import ddf.catalog.filter.impl.SortByImpl;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.impl.QueryImpl;\n+import ddf.catalog.operation.impl.QueryRequestImpl;\n+import ddf.catalog.util.impl.ResultIterable;\n+import java.io.IOException;\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.karaf.shell.api.action.Action;\n+import org.apache.karaf.shell.api.action.Command;\n+import org.apache.karaf.shell.api.action.lifecycle.Reference;\n+import org.apache.karaf.shell.api.action.lifecycle.Service;\n+import org.apache.karaf.shell.api.console.Session;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.codice.ddf.security.Security;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.client.solrj.UnavailableSolrException;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.opengis.filter.sort.SortOrder;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+@Service\n+@Command(\n+  scope = \"offline-solr-gazetteer\",\n+  name = \"synccatalog\",\n+  description = \"Syncs all catalog items to the offline solr gazetteer core\"\n+)\n+public class SyncCatalogCommand implements Action {\n+\n+  private static final Logger LOGGER =\n+      LoggerFactory.getLogger(RemoveAllOfflineSolrGazetteerCommand.class);", "originalCommit": "da7f3def8635d75cf1d73988ed479c2def44f589", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY1MTc2Mw==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r451651763", "bodyText": "make this public or package level to be used here as well https://github.com/codice/ddf/pull/6153/files?file-filters%5B%5D=.java&file-filters%5B%5D=.xml#diff-ff075cf175bf24a6e17cb56229d23edfR128", "author": "lamhuy", "createdAt": "2020-07-08T15:55:23Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/OfflineGazetteerPlugin.java", "diffHunk": "@@ -0,0 +1,206 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import static ddf.catalog.Constants.SUGGESTION_BUILD_KEY;\n+\n+import ddf.catalog.data.Attribute;\n+import ddf.catalog.data.Metacard;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import ddf.catalog.operation.CreateResponse;\n+import ddf.catalog.operation.DeleteResponse;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.Update;\n+import ddf.catalog.operation.UpdateResponse;\n+import ddf.catalog.plugin.PluginExecutionException;\n+import ddf.catalog.plugin.PostIngestPlugin;\n+import ddf.catalog.plugin.PreQueryPlugin;\n+import ddf.catalog.plugin.StopProcessingException;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.util.List;\n+import java.util.Optional;\n+import java.util.function.Consumer;\n+import java.util.stream.Collectors;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.common.SolrInputDocument;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class OfflineGazetteerPlugin implements PostIngestPlugin, PreQueryPlugin {\n+  private static final Logger LOGGER = LoggerFactory.getLogger(OfflineGazetteerPlugin.class);\n+  private static final String GAZETTEER_METACARD_TAG = \"gazetteer\";", "originalCommit": "da7f3def8635d75cf1d73988ed479c2def44f589", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1Mzk5ODc4MQ==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r453998781", "bodyText": "Extracted most constants to a constant class", "author": "rzwiefel", "createdAt": "2020-07-13T23:12:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MTY1MTc2Mw=="}], "type": "inlineReview"}, {"oid": "f4467176b2793575eedef0d8ea716a082e6ff244", "url": "https://github.com/codice/ddf/commit/f4467176b2793575eedef0d8ea716a082e6ff244", "message": "Added Gazetteer Constants, new solrclient ping logic, other minor updates", "committedDate": "2020-07-13T23:16:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDAwMDgyMw==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r454000823", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                  // convert distance to KM", "author": "rzwiefel", "createdAt": "2020-07-13T23:18:56Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java", "diffHunk": "@@ -0,0 +1,466 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.NAMES;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_DICT;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_DICT_VALUE;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_Q;\n+\n+import com.google.common.collect.ImmutableMap;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.client.solrj.response.SuggesterResponse;\n+import org.apache.solr.client.solrj.util.ClientUtils;\n+import org.apache.solr.common.SolrDocument;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntry;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryException;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryable;\n+import org.codice.ddf.spatial.geocoding.Suggestion;\n+import org.codice.ddf.spatial.geocoding.context.NearbyLocation;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.io.WKTReader;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.locationtech.spatial4j.context.SpatialContext;\n+import org.locationtech.spatial4j.context.SpatialContextFactory;\n+import org.locationtech.spatial4j.context.jts.JtsSpatialContextFactory;\n+import org.locationtech.spatial4j.context.jts.ValidationRule;\n+import org.locationtech.spatial4j.exception.InvalidShapeException;\n+import org.locationtech.spatial4j.shape.Shape;\n+import org.locationtech.spatial4j.shape.jts.JtsGeometry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GazetteerQueryOfflineSolr implements GeoEntryQueryable {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GazetteerQueryOfflineSolr.class);\n+\n+  private static final String CITY_SOLR_QUERY =\n+      GeoCodingConstants.CITY_FEATURE_CODES\n+          .stream()\n+          .map(fc -> String.format(\"feature-code_txt:%s\", fc))\n+          .collect(Collectors.joining(\" OR \", \"(\", \")\"));\n+\n+  private static final int MAX_RESULTS = 100;\n+  private static final double KM_PER_DEGREE = 111.139;\n+\n+  private static final Map<String, String> SPATIAL_CONTEXT_ARGUMENTS =\n+      ImmutableMap.of(\n+          \"spatialContextFactory\",\n+          JtsSpatialContextFactory.class.getName(),\n+          \"validationRule\",\n+          ValidationRule.repairConvexHull.name());\n+\n+  private static final SpatialContext SPATIAL_CONTEXT =\n+      SpatialContextFactory.makeSpatialContext(SPATIAL_CONTEXT_ARGUMENTS, null);\n+\n+  private static final ThreadLocal<WKTWriter> WKT_WRITER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTWriter::new);\n+\n+  private static final ThreadLocal<WKTReader> WKT_READER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTReader::new);\n+\n+  private final SolrClient client;\n+\n+  public GazetteerQueryOfflineSolr(\n+      SolrClientFactory clientFactory, ExecutorService startupBuilderExecutor) {\n+\n+    this.client = clientFactory.newClient(GazetteerConstants.STANDALONE_GAZETTEER_CORE_NAME);\n+    startupBuilderExecutor.submit(this::pingAndInitializeSuggester);\n+  }\n+\n+  @Override\n+  public List<GeoEntry> query(String queryString, int maxResults) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"title_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(queryString)));\n+    solrQuery.setRows(Math.min(maxResults, GazetteerQueryOfflineSolr.MAX_RESULTS));\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public GeoEntry queryById(String id) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"id_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(id)));\n+    solrQuery.setRows(1);\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying by ID\", e);\n+    }\n+\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .findFirst()\n+        .orElseThrow(() -> new GeoEntryQueryException(\"Could not find id\"));\n+  }\n+\n+  @Override\n+  public List<Suggestion> getSuggestedNames(String queryString, int maxResults)\n+      throws GeoEntryQueryException {\n+    SolrQuery solrQuery = new SolrQuery();\n+    solrQuery.setRequestHandler(\"/suggest\");\n+    solrQuery.setParam(SUGGEST_Q, ClientUtils.escapeQueryChars(queryString));\n+    solrQuery.setParam(SUGGEST_DICT, SUGGEST_DICT_VALUE);\n+    solrQuery.setParam(\"suggest.count\", Integer.toString(Math.min(maxResults, MAX_RESULTS)));\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+\n+    return Optional.ofNullable(response)\n+        .map(QueryResponse::getSuggesterResponse)\n+        .map(SuggesterResponse::getSuggestions)\n+        .map(suggestionsPerDict -> suggestionsPerDict.get(SUGGEST_DICT_VALUE))\n+        .orElse(Collections.emptyList())\n+        .stream()\n+        .map(suggestion -> new SuggestionImpl(suggestion.getPayload(), suggestion.getTerm()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private void pingAndInitializeSuggester() {\n+    Failsafe.with(\n+            new RetryPolicy()\n+                .retryWhen(false)\n+                .withMaxDuration(5, TimeUnit.MINUTES)\n+                .withBackoff(100, 3_000, TimeUnit.MILLISECONDS))\n+        .onFailure(\n+            e ->\n+                LOGGER.error(\n+                    \"Could not get solrclient to start initial suggester build for {} core. Please try to start a build manually with the `build-suggester-index` karaf command or by sending a request to solr with the property `suggest.build=true`\",\n+                    GazetteerConstants.STANDALONE_GAZETTEER_CORE_NAME,\n+                    e))\n+        .get(() -> client.isAvailable());\n+\n+    SolrQuery query = new SolrQuery();\n+    query.setRequestHandler(\"/suggest\");\n+    query.setParam(\"suggest.build\", true);\n+    query.setParam(SUGGEST_Q, \"GQOSInitialSuggesterBuild\");\n+    query.setParam(SUGGEST_DICT, SUGGEST_DICT_VALUE);\n+    try {\n+      QueryResponse response = client.query(query, METHOD.POST);\n+      LOGGER.debug(\"Initial Suggester build response: {}\", response);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.error(\n+          \"Error while trying to build initial suggester for {}\",\n+          GazetteerConstants.STANDALONE_GAZETTEER_CORE_NAME,\n+          e);\n+    }\n+  }\n+\n+  public static final class SuggestionImpl implements Suggestion {\n+    private final String id;\n+    private final String name;\n+\n+    public SuggestionImpl(String id, String name) {\n+      this.id = id;\n+      this.name = name;\n+    }\n+\n+    @Override\n+    public String getId() {\n+      return id;\n+    }\n+\n+    @Override\n+    public String getName() {\n+      return name;\n+    }\n+  }\n+\n+  @Override\n+  public List<NearbyLocation> getNearestCities(String location, int radiusInKm, int maxResults)\n+      throws ParseException, GeoEntryQueryException {\n+    Geometry geometry;\n+    try {\n+      geometry = WKT_READER_THREAD_LOCAL.get().read(location);\n+    } catch (org.locationtech.jts.io.ParseException e) {\n+      throw new GeoEntryQueryException(\"Could not parse location\");\n+    }\n+    final Geometry originalGeometry = geometry;\n+    Geometry bufferedGeo = originalGeometry.buffer(convertKilometerToDegree(radiusInKm), 14);\n+    String wkt = WKT_WRITER_THREAD_LOCAL.get().write(bufferedGeo);\n+\n+    String q =\n+        String.format(\n+            \"location_geo_index:\\\"Intersects( %s ) AND %s\\\"\",\n+            ClientUtils.escapeQueryChars(wkt), CITY_SOLR_QUERY);\n+\n+    SolrQuery solrQuery = new SolrQuery(q);\n+    solrQuery.setRows(Math.min(maxResults, MAX_RESULTS));\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error executing query for nearest cities\", e);\n+    }\n+\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(result -> convert(result, originalGeometry))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private NearbyLocation convert(SolrDocument doc, Geometry originalLocation) {\n+    String location = getField(doc, \"location_geo\", String.class);\n+    String title =\n+        Optional.ofNullable(getField(doc, \"title_txt\", String.class))\n+            .filter(Objects::nonNull)\n+            .filter(s -> !s.isEmpty())\n+            .orElse(\"NO TITLE\");\n+\n+    String cardinalDirection = \"\";\n+    double distance = 0;\n+    try {\n+      Geometry geo = WKT_READER_THREAD_LOCAL.get().read(location);\n+      cardinalDirection =\n+          bearingToCardinalDirection(getBearing(originalLocation.getCentroid(), geo.getCentroid()));\n+      // convert distance to KM", "originalCommit": "f4467176b2793575eedef0d8ea716a082e6ff244", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcyMTM4Nw==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r454721387", "bodyText": "\u270f\ufe0f The fact that these field names match the catalog metacard attributes is now an incidental implementation detail of how the default suggestor is configured in the schema.  I would recommend removing the use of these attributes since these are not actually metacard attributes.", "author": "pklinef", "createdAt": "2020-07-15T00:32:56Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java", "diffHunk": "@@ -0,0 +1,465 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.NAMES;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_DICT;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_DICT_VALUE;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_Q;\n+\n+import com.google.common.collect.ImmutableMap;\n+import ddf.catalog.data.types.Core;", "originalCommit": "906d14a9baaa01702256cc849f605c48bf43f934", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcyMjA4OA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r454722088", "bodyText": "\u270f\ufe0f Really it is more of a Collection name than a Core name.", "author": "pklinef", "createdAt": "2020-07-15T00:35:21Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerConstants.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+\n+public class GazetteerConstants {\n+  /* Solr Requests */\n+  public static final String SUGGEST_Q = \"suggest.q\";\n+  public static final String SUGGEST_DICT = \"suggest.dictionary\";\n+  public static final String SUGGEST_DICT_VALUE = \"suggestPlace\";\n+\n+  /* Naming */\n+  public static final String GAZETTEER_METACARD_TAG = GeoCodingConstants.GAZETTEER_METACARD_TAG;\n+  public static final String STANDALONE_GAZETTEER_CORE_NAME = \"standalone-solr-gazetteer\";", "originalCommit": "906d14a9baaa01702256cc849f605c48bf43f934", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDcyMzE4Mw==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r454723183", "bodyText": "\u2757 It seems very odd to mention Solr in the name of a Solr collection name.  I am also not sure what standalone means in this context.\nI think we can name this collection just gazetteer now that we are not planning on doing the Solr collection routing any time soon.", "author": "pklinef", "createdAt": "2020-07-15T00:39:45Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerConstants.java", "diffHunk": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import com.google.common.collect.BiMap;\n+import com.google.common.collect.ImmutableBiMap;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+\n+public class GazetteerConstants {\n+  /* Solr Requests */\n+  public static final String SUGGEST_Q = \"suggest.q\";\n+  public static final String SUGGEST_DICT = \"suggest.dictionary\";\n+  public static final String SUGGEST_DICT_VALUE = \"suggestPlace\";\n+\n+  /* Naming */\n+  public static final String GAZETTEER_METACARD_TAG = GeoCodingConstants.GAZETTEER_METACARD_TAG;\n+  public static final String STANDALONE_GAZETTEER_CORE_NAME = \"standalone-solr-gazetteer\";", "originalCommit": "906d14a9baaa01702256cc849f605c48bf43f934", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc0NDg5Mw==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r454744893", "bodyText": "\u2753 I'm torn between making this a WARN log or leaving it as-is at ERROR. Here's why.\nI like to attach synchronous system validity to the bundle states. I do that because if a bundle successfully starts but something else failed, now there's more than one state in play and that fragmentation contributes to system complexity.\nThe system either started successfully or didn't. When shipping a system, external factors should impact synchronous start as little as possible. Are these exceptions indicative of a failed system start? Or is suggester initialization considered an optional start task?\nWhat are optional start tasks? Can they be skipped and the system should work fine out of the box? Do we have a way to iterate them besides logs, or the absence of logs?\nTakeaway: I'm not sure what to make of this because I'm pretty sure if this async task fails our system is not in a valid state, but if we booted successfully, I think it should have been.\nAlso note that we don't have a good way to track async startup tasks' pass/fail/in-progress states across the system short of logging. That's probably good enough for this PR but something we should consider going forward. It would help alleviate the previous fragmentation of \"am I in a good state\" that I mentioned earlier. It also gives an admin a point of synchronization so that, from their perspective, a \"successful start\" can be bounded back into their synchronous question - did my system start such that all default features will work correctly?\nCentralizing long-running start tasks can also get tied back into waitForReady or other mechanisms.", "author": "Lambeaux", "createdAt": "2020-07-15T01:59:30Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java", "diffHunk": "@@ -0,0 +1,465 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.NAMES;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_DICT;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_DICT_VALUE;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_Q;\n+\n+import com.google.common.collect.ImmutableMap;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.client.solrj.response.SuggesterResponse;\n+import org.apache.solr.client.solrj.util.ClientUtils;\n+import org.apache.solr.common.SolrDocument;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntry;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryException;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryable;\n+import org.codice.ddf.spatial.geocoding.Suggestion;\n+import org.codice.ddf.spatial.geocoding.context.NearbyLocation;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.io.WKTReader;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.locationtech.spatial4j.context.SpatialContext;\n+import org.locationtech.spatial4j.context.SpatialContextFactory;\n+import org.locationtech.spatial4j.context.jts.JtsSpatialContextFactory;\n+import org.locationtech.spatial4j.context.jts.ValidationRule;\n+import org.locationtech.spatial4j.exception.InvalidShapeException;\n+import org.locationtech.spatial4j.shape.Shape;\n+import org.locationtech.spatial4j.shape.jts.JtsGeometry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GazetteerQueryOfflineSolr implements GeoEntryQueryable {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GazetteerQueryOfflineSolr.class);\n+\n+  private static final String CITY_SOLR_QUERY =\n+      GeoCodingConstants.CITY_FEATURE_CODES\n+          .stream()\n+          .map(fc -> String.format(\"feature-code_txt:%s\", fc))\n+          .collect(Collectors.joining(\" OR \", \"(\", \")\"));\n+\n+  private static final int MAX_RESULTS = 100;\n+  private static final double KM_PER_DEGREE = 111.139;\n+\n+  private static final Map<String, String> SPATIAL_CONTEXT_ARGUMENTS =\n+      ImmutableMap.of(\n+          \"spatialContextFactory\",\n+          JtsSpatialContextFactory.class.getName(),\n+          \"validationRule\",\n+          ValidationRule.repairConvexHull.name());\n+\n+  private static final SpatialContext SPATIAL_CONTEXT =\n+      SpatialContextFactory.makeSpatialContext(SPATIAL_CONTEXT_ARGUMENTS, null);\n+\n+  private static final ThreadLocal<WKTWriter> WKT_WRITER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTWriter::new);\n+\n+  private static final ThreadLocal<WKTReader> WKT_READER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTReader::new);\n+\n+  private final SolrClient client;\n+\n+  public GazetteerQueryOfflineSolr(\n+      SolrClientFactory clientFactory, ExecutorService startupBuilderExecutor) {\n+\n+    this.client = clientFactory.newClient(GazetteerConstants.STANDALONE_GAZETTEER_CORE_NAME);\n+    startupBuilderExecutor.submit(this::pingAndInitializeSuggester);\n+  }\n+\n+  @Override\n+  public List<GeoEntry> query(String queryString, int maxResults) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"title_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(queryString)));\n+    solrQuery.setRows(Math.min(maxResults, GazetteerQueryOfflineSolr.MAX_RESULTS));\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public GeoEntry queryById(String id) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"id_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(id)));\n+    solrQuery.setRows(1);\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying by ID\", e);\n+    }\n+\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .findFirst()\n+        .orElseThrow(() -> new GeoEntryQueryException(\"Could not find id\"));\n+  }\n+\n+  @Override\n+  public List<Suggestion> getSuggestedNames(String queryString, int maxResults)\n+      throws GeoEntryQueryException {\n+    SolrQuery solrQuery = new SolrQuery();\n+    solrQuery.setRequestHandler(\"/suggest\");\n+    solrQuery.setParam(SUGGEST_Q, ClientUtils.escapeQueryChars(queryString));\n+    solrQuery.setParam(SUGGEST_DICT, SUGGEST_DICT_VALUE);\n+    solrQuery.setParam(\"suggest.count\", Integer.toString(Math.min(maxResults, MAX_RESULTS)));\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+\n+    return Optional.ofNullable(response)\n+        .map(QueryResponse::getSuggesterResponse)\n+        .map(SuggesterResponse::getSuggestions)\n+        .map(suggestionsPerDict -> suggestionsPerDict.get(SUGGEST_DICT_VALUE))\n+        .orElse(Collections.emptyList())\n+        .stream()\n+        .map(suggestion -> new SuggestionImpl(suggestion.getPayload(), suggestion.getTerm()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private void pingAndInitializeSuggester() {\n+    Failsafe.with(\n+            new RetryPolicy()\n+                .retryWhen(false)\n+                .withMaxDuration(5, TimeUnit.MINUTES)\n+                .withBackoff(100, 3_000, TimeUnit.MILLISECONDS))\n+        .onFailure(\n+            e ->\n+                LOGGER.error(\n+                    \"Could not get solrclient to start initial suggester build for {} core. Please try to start a build manually with the `build-suggester-index` karaf command or by sending a request to solr with the property `suggest.build=true`\",\n+                    GazetteerConstants.STANDALONE_GAZETTEER_CORE_NAME,\n+                    e))\n+        .get(() -> client.isAvailable());\n+\n+    SolrQuery query = new SolrQuery();\n+    query.setRequestHandler(\"/suggest\");\n+    query.setParam(\"suggest.build\", true);\n+    query.setParam(SUGGEST_Q, \"GQOSInitialSuggesterBuild\");\n+    query.setParam(SUGGEST_DICT, SUGGEST_DICT_VALUE);\n+    try {\n+      QueryResponse response = client.query(query, METHOD.POST);\n+      LOGGER.debug(\"Initial Suggester build response: {}\", response);\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.error(\n+          \"Error while trying to build initial suggester for {}\",\n+          GazetteerConstants.STANDALONE_GAZETTEER_CORE_NAME,\n+          e);\n+    }", "originalCommit": "906d14a9baaa01702256cc849f605c48bf43f934", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4MzAyMQ==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r456683021", "bodyText": "This code is now gone per here", "author": "rzwiefel", "createdAt": "2020-07-17T21:31:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc0NDg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc0NTgzNg==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r454745836", "bodyText": "\ud83d\udc4d   Okay we can build the index manually. Perfect.", "author": "Lambeaux", "createdAt": "2020-07-15T02:03:19Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java", "diffHunk": "@@ -0,0 +1,465 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.NAMES;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_DICT;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_DICT_VALUE;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_Q;\n+\n+import com.google.common.collect.ImmutableMap;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.client.solrj.response.SuggesterResponse;\n+import org.apache.solr.client.solrj.util.ClientUtils;\n+import org.apache.solr.common.SolrDocument;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntry;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryException;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryable;\n+import org.codice.ddf.spatial.geocoding.Suggestion;\n+import org.codice.ddf.spatial.geocoding.context.NearbyLocation;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.io.WKTReader;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.locationtech.spatial4j.context.SpatialContext;\n+import org.locationtech.spatial4j.context.SpatialContextFactory;\n+import org.locationtech.spatial4j.context.jts.JtsSpatialContextFactory;\n+import org.locationtech.spatial4j.context.jts.ValidationRule;\n+import org.locationtech.spatial4j.exception.InvalidShapeException;\n+import org.locationtech.spatial4j.shape.Shape;\n+import org.locationtech.spatial4j.shape.jts.JtsGeometry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GazetteerQueryOfflineSolr implements GeoEntryQueryable {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GazetteerQueryOfflineSolr.class);\n+\n+  private static final String CITY_SOLR_QUERY =\n+      GeoCodingConstants.CITY_FEATURE_CODES\n+          .stream()\n+          .map(fc -> String.format(\"feature-code_txt:%s\", fc))\n+          .collect(Collectors.joining(\" OR \", \"(\", \")\"));\n+\n+  private static final int MAX_RESULTS = 100;\n+  private static final double KM_PER_DEGREE = 111.139;\n+\n+  private static final Map<String, String> SPATIAL_CONTEXT_ARGUMENTS =\n+      ImmutableMap.of(\n+          \"spatialContextFactory\",\n+          JtsSpatialContextFactory.class.getName(),\n+          \"validationRule\",\n+          ValidationRule.repairConvexHull.name());\n+\n+  private static final SpatialContext SPATIAL_CONTEXT =\n+      SpatialContextFactory.makeSpatialContext(SPATIAL_CONTEXT_ARGUMENTS, null);\n+\n+  private static final ThreadLocal<WKTWriter> WKT_WRITER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTWriter::new);\n+\n+  private static final ThreadLocal<WKTReader> WKT_READER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTReader::new);\n+\n+  private final SolrClient client;\n+\n+  public GazetteerQueryOfflineSolr(\n+      SolrClientFactory clientFactory, ExecutorService startupBuilderExecutor) {\n+\n+    this.client = clientFactory.newClient(GazetteerConstants.STANDALONE_GAZETTEER_CORE_NAME);\n+    startupBuilderExecutor.submit(this::pingAndInitializeSuggester);\n+  }\n+\n+  @Override\n+  public List<GeoEntry> query(String queryString, int maxResults) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"title_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(queryString)));\n+    solrQuery.setRows(Math.min(maxResults, GazetteerQueryOfflineSolr.MAX_RESULTS));\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public GeoEntry queryById(String id) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"id_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(id)));\n+    solrQuery.setRows(1);\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying by ID\", e);\n+    }\n+\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .findFirst()\n+        .orElseThrow(() -> new GeoEntryQueryException(\"Could not find id\"));\n+  }\n+\n+  @Override\n+  public List<Suggestion> getSuggestedNames(String queryString, int maxResults)\n+      throws GeoEntryQueryException {\n+    SolrQuery solrQuery = new SolrQuery();\n+    solrQuery.setRequestHandler(\"/suggest\");\n+    solrQuery.setParam(SUGGEST_Q, ClientUtils.escapeQueryChars(queryString));\n+    solrQuery.setParam(SUGGEST_DICT, SUGGEST_DICT_VALUE);\n+    solrQuery.setParam(\"suggest.count\", Integer.toString(Math.min(maxResults, MAX_RESULTS)));\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+\n+    return Optional.ofNullable(response)\n+        .map(QueryResponse::getSuggesterResponse)\n+        .map(SuggesterResponse::getSuggestions)\n+        .map(suggestionsPerDict -> suggestionsPerDict.get(SUGGEST_DICT_VALUE))\n+        .orElse(Collections.emptyList())\n+        .stream()\n+        .map(suggestion -> new SuggestionImpl(suggestion.getPayload(), suggestion.getTerm()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private void pingAndInitializeSuggester() {\n+    Failsafe.with(\n+            new RetryPolicy()\n+                .retryWhen(false)\n+                .withMaxDuration(5, TimeUnit.MINUTES)\n+                .withBackoff(100, 3_000, TimeUnit.MILLISECONDS))\n+        .onFailure(\n+            e ->\n+                LOGGER.error(\n+                    \"Could not get solrclient to start initial suggester build for {} core. Please try to start a build manually with the `build-suggester-index` karaf command or by sending a request to solr with the property `suggest.build=true`\",", "originalCommit": "906d14a9baaa01702256cc849f605c48bf43f934", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc0NzIxMA==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r454747210", "bodyText": "\u2753 This is probably exhaustively fine which means when flakiness occurs, this failure will be a very rare sight. Would it be an improvement to use whenAvailable and an Initializer instead?\nhttps://github.com/codice/ddf/blob/master/platform/solr/solr-factory/src/main/java/org/codice/solr/client/solrj/SolrClient.java#L133\nDrawback there is that, if it turns out Solr isn't available for awhile, we will never log a \"timeout\" message claiming our \"initialization\" (if you include async tasks) didn't \"finish\" (it technically did because we booted up) unless we can provide a timeout. So I'm not sure.", "author": "Lambeaux", "createdAt": "2020-07-15T02:08:25Z", "path": "catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java", "diffHunk": "@@ -0,0 +1,465 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.solr.offlinegazetteer;\n+\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.NAMES;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_DICT;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_DICT_VALUE;\n+import static ddf.catalog.solr.offlinegazetteer.GazetteerConstants.SUGGEST_Q;\n+\n+import com.google.common.collect.ImmutableMap;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.data.types.Location;\n+import java.io.IOException;\n+import java.text.ParseException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.concurrent.ExecutorService;\n+import java.util.concurrent.TimeUnit;\n+import java.util.stream.Collectors;\n+import net.jodah.failsafe.Failsafe;\n+import net.jodah.failsafe.RetryPolicy;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.SolrRequest.METHOD;\n+import org.apache.solr.client.solrj.SolrServerException;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.client.solrj.response.SuggesterResponse;\n+import org.apache.solr.client.solrj.util.ClientUtils;\n+import org.apache.solr.common.SolrDocument;\n+import org.codice.ddf.spatial.geocoding.GeoCodingConstants;\n+import org.codice.ddf.spatial.geocoding.GeoEntry;\n+import org.codice.ddf.spatial.geocoding.GeoEntryAttributes;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryException;\n+import org.codice.ddf.spatial.geocoding.GeoEntryQueryable;\n+import org.codice.ddf.spatial.geocoding.Suggestion;\n+import org.codice.ddf.spatial.geocoding.context.NearbyLocation;\n+import org.codice.solr.client.solrj.SolrClient;\n+import org.codice.solr.factory.SolrClientFactory;\n+import org.locationtech.jts.geom.Geometry;\n+import org.locationtech.jts.geom.Point;\n+import org.locationtech.jts.io.WKTReader;\n+import org.locationtech.jts.io.WKTWriter;\n+import org.locationtech.spatial4j.context.SpatialContext;\n+import org.locationtech.spatial4j.context.SpatialContextFactory;\n+import org.locationtech.spatial4j.context.jts.JtsSpatialContextFactory;\n+import org.locationtech.spatial4j.context.jts.ValidationRule;\n+import org.locationtech.spatial4j.exception.InvalidShapeException;\n+import org.locationtech.spatial4j.shape.Shape;\n+import org.locationtech.spatial4j.shape.jts.JtsGeometry;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class GazetteerQueryOfflineSolr implements GeoEntryQueryable {\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(GazetteerQueryOfflineSolr.class);\n+\n+  private static final String CITY_SOLR_QUERY =\n+      GeoCodingConstants.CITY_FEATURE_CODES\n+          .stream()\n+          .map(fc -> String.format(\"feature-code_txt:%s\", fc))\n+          .collect(Collectors.joining(\" OR \", \"(\", \")\"));\n+\n+  private static final int MAX_RESULTS = 100;\n+  private static final double KM_PER_DEGREE = 111.139;\n+\n+  private static final Map<String, String> SPATIAL_CONTEXT_ARGUMENTS =\n+      ImmutableMap.of(\n+          \"spatialContextFactory\",\n+          JtsSpatialContextFactory.class.getName(),\n+          \"validationRule\",\n+          ValidationRule.repairConvexHull.name());\n+\n+  private static final SpatialContext SPATIAL_CONTEXT =\n+      SpatialContextFactory.makeSpatialContext(SPATIAL_CONTEXT_ARGUMENTS, null);\n+\n+  private static final ThreadLocal<WKTWriter> WKT_WRITER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTWriter::new);\n+\n+  private static final ThreadLocal<WKTReader> WKT_READER_THREAD_LOCAL =\n+      ThreadLocal.withInitial(WKTReader::new);\n+\n+  private final SolrClient client;\n+\n+  public GazetteerQueryOfflineSolr(\n+      SolrClientFactory clientFactory, ExecutorService startupBuilderExecutor) {\n+\n+    this.client = clientFactory.newClient(GazetteerConstants.STANDALONE_GAZETTEER_CORE_NAME);\n+    startupBuilderExecutor.submit(this::pingAndInitializeSuggester);\n+  }\n+\n+  @Override\n+  public List<GeoEntry> query(String queryString, int maxResults) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"title_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(queryString)));\n+    solrQuery.setRows(Math.min(maxResults, GazetteerQueryOfflineSolr.MAX_RESULTS));\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .collect(Collectors.toList());\n+  }\n+\n+  @Override\n+  public GeoEntry queryById(String id) throws GeoEntryQueryException {\n+    SolrQuery solrQuery =\n+        new SolrQuery(String.format(\"id_txt:\\\"%s\\\"\", ClientUtils.escapeQueryChars(id)));\n+    solrQuery.setRows(1);\n+\n+    QueryResponse response = null;\n+    try {\n+      response = client.query(solrQuery, METHOD.POST);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying by ID\", e);\n+    }\n+\n+    return response\n+        .getResults()\n+        .stream()\n+        .map(this::transformMetacardToGeoEntry)\n+        .findFirst()\n+        .orElseThrow(() -> new GeoEntryQueryException(\"Could not find id\"));\n+  }\n+\n+  @Override\n+  public List<Suggestion> getSuggestedNames(String queryString, int maxResults)\n+      throws GeoEntryQueryException {\n+    SolrQuery solrQuery = new SolrQuery();\n+    solrQuery.setRequestHandler(\"/suggest\");\n+    solrQuery.setParam(SUGGEST_Q, ClientUtils.escapeQueryChars(queryString));\n+    solrQuery.setParam(SUGGEST_DICT, SUGGEST_DICT_VALUE);\n+    solrQuery.setParam(\"suggest.count\", Integer.toString(Math.min(maxResults, MAX_RESULTS)));\n+\n+    QueryResponse response;\n+    try {\n+      response = client.query(solrQuery);\n+    } catch (SolrServerException | IOException e) {\n+      throw new GeoEntryQueryException(\"Error while querying\", e);\n+    }\n+\n+    return Optional.ofNullable(response)\n+        .map(QueryResponse::getSuggesterResponse)\n+        .map(SuggesterResponse::getSuggestions)\n+        .map(suggestionsPerDict -> suggestionsPerDict.get(SUGGEST_DICT_VALUE))\n+        .orElse(Collections.emptyList())\n+        .stream()\n+        .map(suggestion -> new SuggestionImpl(suggestion.getPayload(), suggestion.getTerm()))\n+        .collect(Collectors.toList());\n+  }\n+\n+  private void pingAndInitializeSuggester() {\n+    Failsafe.with(\n+            new RetryPolicy()\n+                .retryWhen(false)\n+                .withMaxDuration(5, TimeUnit.MINUTES)\n+                .withBackoff(100, 3_000, TimeUnit.MILLISECONDS))", "originalCommit": "906d14a9baaa01702256cc849f605c48bf43f934", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NjY4MjYwMg==", "url": "https://github.com/codice/ddf/pull/6153#discussion_r456682602", "bodyText": "So i just got rid of this code/complexity all together since we have a independant gazetteer suggester I'm building it on startup so this logic was not needed anymore \ud83d\ude04", "author": "rzwiefel", "createdAt": "2020-07-17T21:30:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1NDc0NzIxMA=="}], "type": "inlineReview"}, {"oid": "8bbcd74268f626a81e265ba562283cfa41708d07", "url": "https://github.com/codice/ddf/commit/8bbcd74268f626a81e265ba562283cfa41708d07", "message": "DDF-6152 Added standalone solr gazetteer", "committedDate": "2020-07-20T21:01:09Z", "type": "commit"}, {"oid": "63ebfda7fd66d9d326dfe57b9f5f1c8518a1f94c", "url": "https://github.com/codice/ddf/commit/63ebfda7fd66d9d326dfe57b9f5f1c8518a1f94c", "message": "Removed schema files and updated default, fixed retryPolicy threadsafety", "committedDate": "2020-07-20T21:01:09Z", "type": "commit"}, {"oid": "f1d366f93d4af5120c0ecae2e71dd9fb60280ba2", "url": "https://github.com/codice/ddf/commit/f1d366f93d4af5120c0ecae2e71dd9fb60280ba2", "message": "Added Gazetteer Constants, new solrclient ping logic, other minor updates", "committedDate": "2020-07-20T21:01:09Z", "type": "commit"}, {"oid": "13e8a0f5082c55bd3d71d2b140d1737f23d2b478", "url": "https://github.com/codice/ddf/commit/13e8a0f5082c55bd3d71d2b140d1737f23d2b478", "message": "Update catalog/solr/catalog-solr-offline-gazetteer/src/main/java/ddf/catalog/solr/offlinegazetteer/GazetteerQueryOfflineSolr.java", "committedDate": "2020-07-20T21:01:09Z", "type": "commit"}, {"oid": "276f7f7363de14fef57659175551b67c91dd8a50", "url": "https://github.com/codice/ddf/commit/276f7f7363de14fef57659175551b67c91dd8a50", "message": "Added tostring methods with correct formatting", "committedDate": "2020-07-20T21:01:09Z", "type": "commit"}, {"oid": "708dde3083807f084741693b181bff032fbe2ee6", "url": "https://github.com/codice/ddf/commit/708dde3083807f084741693b181bff032fbe2ee6", "message": "Added docs for standalone solr offline gazetteer", "committedDate": "2020-07-20T21:01:09Z", "type": "commit"}, {"oid": "1ec10a752f2780dcf91d25df1292cba1c85fc3dc", "url": "https://github.com/codice/ddf/commit/1ec10a752f2780dcf91d25df1292cba1c85fc3dc", "message": "docs phrasing updates", "committedDate": "2020-07-20T21:01:09Z", "type": "commit"}, {"oid": "4dcc6c81cbac0a31abbe0da03dfe5e84ac87847d", "url": "https://github.com/codice/ddf/commit/4dcc6c81cbac0a31abbe0da03dfe5e84ac87847d", "message": "Extracted Request Handler constant", "committedDate": "2020-07-20T21:01:09Z", "type": "commit"}, {"oid": "724215e39cd46ef3df1f151895d47fd3c3dbc5f8", "url": "https://github.com/codice/ddf/commit/724215e39cd46ef3df1f151895d47fd3c3dbc5f8", "message": "Extracted suggest dictionary constant", "committedDate": "2020-07-20T21:01:09Z", "type": "commit"}, {"oid": "a8d9d9c6ffc88a615488238493e0f1bc5082ba5b", "url": "https://github.com/codice/ddf/commit/a8d9d9c6ffc88a615488238493e0f1bc5082ba5b", "message": "Extracted suggest dict key", "committedDate": "2020-07-20T21:01:09Z", "type": "commit"}, {"oid": "58f361fbda47b70d0b405f544474fd3537716755", "url": "https://github.com/codice/ddf/commit/58f361fbda47b70d0b405f544474fd3537716755", "message": "Optimized constants to static imports", "committedDate": "2020-07-20T21:01:09Z", "type": "commit"}, {"oid": "e34b98a212cfcf21cb86d8fdb2b0f8214a35d551", "url": "https://github.com/codice/ddf/commit/e34b98a212cfcf21cb86d8fdb2b0f8214a35d551", "message": "extracted more constants and renamed some things", "committedDate": "2020-07-20T21:01:09Z", "type": "commit"}, {"oid": "b9562ecf9a4e44eb8f108671a0a94da4e2288ca3", "url": "https://github.com/codice/ddf/commit/b9562ecf9a4e44eb8f108671a0a94da4e2288ca3", "message": "Formatting fixes", "committedDate": "2020-07-20T21:01:09Z", "type": "commit"}, {"oid": "c31f993abd2bb79310b42a8a58e2ff1259545b66", "url": "https://github.com/codice/ddf/commit/c31f993abd2bb79310b42a8a58e2ff1259545b66", "message": "Initial Build Gazetteer Suggester Command", "committedDate": "2020-07-20T21:01:09Z", "type": "commit"}, {"oid": "4165b616115bef75344ea29f4ee66d7ea39f99ed", "url": "https://github.com/codice/ddf/commit/4165b616115bef75344ea29f4ee66d7ea39f99ed", "message": "updated error messages and trycatch", "committedDate": "2020-07-20T21:01:09Z", "type": "commit"}, {"oid": "c9d6ad15d22ff9ff9261ec5cd910deacefd14915", "url": "https://github.com/codice/ddf/commit/c9d6ad15d22ff9ff9261ec5cd910deacefd14915", "message": "Updated gazetteer collection name and value", "committedDate": "2020-07-20T21:01:09Z", "type": "commit"}, {"oid": "33595c3e282f70bddee0ee3cac9956a516cc027a", "url": "https://github.com/codice/ddf/commit/33595c3e282f70bddee0ee3cac9956a516cc027a", "message": "Added independant suggester config for gazetteer", "committedDate": "2020-07-20T21:01:09Z", "type": "commit"}, {"oid": "b6c2cb6bf5cee174d41efd82f5f3e58bb8ce649a", "url": "https://github.com/codice/ddf/commit/b6c2cb6bf5cee174d41efd82f5f3e58bb8ce649a", "message": "Finalized name/key migrations", "committedDate": "2020-07-20T21:01:09Z", "type": "commit"}, {"oid": "d1764e2bf8eab2cba2dee03bd65d3eda6fb1a2e1", "url": "https://github.com/codice/ddf/commit/d1764e2bf8eab2cba2dee03bd65d3eda6fb1a2e1", "message": "Docs updates", "committedDate": "2020-07-20T21:01:09Z", "type": "commit"}, {"oid": "339f18a15df1d2a66056497182185289555f175d", "url": "https://github.com/codice/ddf/commit/339f18a15df1d2a66056497182185289555f175d", "message": "Set gazetteer suggester to not build on startup", "committedDate": "2020-07-20T21:01:09Z", "type": "commit"}, {"oid": "339f18a15df1d2a66056497182185289555f175d", "url": "https://github.com/codice/ddf/commit/339f18a15df1d2a66056497182185289555f175d", "message": "Set gazetteer suggester to not build on startup", "committedDate": "2020-07-20T21:01:09Z", "type": "forcePushed"}, {"oid": "7a2de7c5b946ee027020bed71b0c8dadf4298d06", "url": "https://github.com/codice/ddf/commit/7a2de7c5b946ee027020bed71b0c8dadf4298d06", "message": "Eradicated all remaining references to core", "committedDate": "2020-07-20T21:09:43Z", "type": "commit"}, {"oid": "c575837f5cade78717f3f507f7e746d69d10e704", "url": "https://github.com/codice/ddf/commit/c575837f5cade78717f3f507f7e746d69d10e704", "message": "updates pom version", "committedDate": "2020-07-20T22:20:44Z", "type": "commit"}]}