{"pr_number": 6009, "pr_title": "DDF-6008 - Enable Solr Highlighting", "pr_createdAt": "2020-04-21T21:45:54Z", "pr_url": "https://github.com/codice/ddf/pull/6009", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU1MDYyMQ==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r412550621", "bodyText": "\u2753 Why do you convert to JSON here instead of keeping it a Java object?  If we leave it as a Java object, different transformers and endpoints avoid converting JSON back to Java if they want to serialize to a different format or to a different JSON schema.\nSee examples for other response properties from the Solr provider.  I think this response should be consistent with those response properties.\nhttps://github.com/codice/ddf/blob/73312d1/catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/SolrMetacardClientImpl.java#L283-L294", "author": "pklinef", "createdAt": "2020-04-21T23:04:22Z", "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/SolrMetacardClientImpl.java", "diffHunk": "@@ -311,6 +340,74 @@ private Boolean userSpellcheckIsOn(QueryRequest request) {\n     return userSpellcheckChoice;\n   }\n \n+  private Boolean userHighlightIsOn(QueryRequest request) {\n+    Boolean userHighlight = false;\n+    if (request.getProperties().get(HIGHLIGHT_KEY) != null) {\n+      userHighlight = (Boolean) request.getProperties().get(HIGHLIGHT_KEY);\n+    }\n+    return userHighlight;\n+  }\n+\n+  private void enableHighlighter(SolrQuery query) {\n+    query.setParam(SOLR_HIGHLIGHT_KEY, true);\n+    query.setParam(\"hl.fl\", \"*\");\n+    query.setParam(\"hl.simple.pre\", \"<b>\");\n+    query.setParam(\"hl.tag.pre\", \"<b>\");\n+    query.setParam(\"hl.simple.post\", \"</b>\");\n+    query.setParam(\"hl.tag.post\", \"</b>\");\n+    query.setParam(\"hl.requireFieldMatch\", true);\n+    query.setParam(\"hl.method\", \"unified\");\n+  }\n+\n+  private void extractHighlighing(QueryResponse response, Map<String, Serializable> responseProps) {\n+    Map<String, Map<String, List<String>>> highlights = response.getHighlighting();\n+    if (highlights == null) {\n+      return;\n+    }\n+    Map<String, Map<String, Set<String>>> resultsHighlights = new HashMap<>();\n+    for (String metacardId : highlights.keySet()) {\n+      Map<String, List<String>> fieldHighlight = highlights.get(metacardId);\n+      Map<String, Set<String>> consolidated = new HashMap<>();\n+      if (fieldHighlight != null && fieldHighlight.size() > 0) {\n+        for (Map.Entry<String, List<String>> entry : fieldHighlight.entrySet()) {\n+          String solrField = entry.getKey();\n+          String normalizedKey = resolver.resolveFieldName(solrField);\n+          if (isHighlightBlacklisted(normalizedKey) || isHighlightBlacklisted(solrField)) {\n+            continue;\n+          }\n+          Set<String> consolidatedSet = consolidated.get(normalizedKey);\n+          if (consolidatedSet == null) {\n+            consolidatedSet = new HashSet<>();\n+          }\n+          consolidatedSet.addAll(entry.getValue());\n+          if (!consolidatedSet.isEmpty()) {\n+            consolidated.put(normalizedKey, consolidatedSet);\n+          }\n+        }\n+      }\n+      if (!consolidated.isEmpty()) {\n+        resultsHighlights.put(metacardId, consolidated);\n+      }\n+    }\n+\n+    if (!resultsHighlights.isEmpty()) {\n+      try {\n+        responseProps.put(HIGHLIGHT_KEY, mapper.writeValueAsString(resultsHighlights));", "originalCommit": "9e71633a9a31ed06f0fa1fd54e172c51e5a07e6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzAxMTc1Ng==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r413011756", "bodyText": "This was a shortcut on my part since the data is a map of maps and not inherently serializable.  I can fix it to send back a custom Java object.", "author": "derekwilhelm", "createdAt": "2020-04-22T14:04:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU1MDYyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEwMzg5Ng==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r418103896", "bodyText": "I created new interfaces and impl objects that get passed back in the response properties rather than converting to JSON.  I used the facet query stuff for guidelines on where to add these interfaces and classes.", "author": "derekwilhelm", "createdAt": "2020-04-30T15:39:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU1MDYyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU1MzAxOQ==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r412553019", "bodyText": "\u270f\ufe0f I would also suggest hiding any fields that are not part of the metacard type fields.  That will hide fields like metacard_type_name_txt, metacard_type_obj, and metacard_source_txt.", "author": "pklinef", "createdAt": "2020-04-21T23:10:12Z", "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/SolrMetacardClientImpl.java", "diffHunk": "@@ -311,6 +340,74 @@ private Boolean userSpellcheckIsOn(QueryRequest request) {\n     return userSpellcheckChoice;\n   }\n \n+  private Boolean userHighlightIsOn(QueryRequest request) {\n+    Boolean userHighlight = false;\n+    if (request.getProperties().get(HIGHLIGHT_KEY) != null) {\n+      userHighlight = (Boolean) request.getProperties().get(HIGHLIGHT_KEY);\n+    }\n+    return userHighlight;\n+  }\n+\n+  private void enableHighlighter(SolrQuery query) {\n+    query.setParam(SOLR_HIGHLIGHT_KEY, true);\n+    query.setParam(\"hl.fl\", \"*\");\n+    query.setParam(\"hl.simple.pre\", \"<b>\");\n+    query.setParam(\"hl.tag.pre\", \"<b>\");\n+    query.setParam(\"hl.simple.post\", \"</b>\");\n+    query.setParam(\"hl.tag.post\", \"</b>\");\n+    query.setParam(\"hl.requireFieldMatch\", true);\n+    query.setParam(\"hl.method\", \"unified\");\n+  }\n+\n+  private void extractHighlighing(QueryResponse response, Map<String, Serializable> responseProps) {\n+    Map<String, Map<String, List<String>>> highlights = response.getHighlighting();\n+    if (highlights == null) {\n+      return;\n+    }\n+    Map<String, Map<String, Set<String>>> resultsHighlights = new HashMap<>();\n+    for (String metacardId : highlights.keySet()) {\n+      Map<String, List<String>> fieldHighlight = highlights.get(metacardId);\n+      Map<String, Set<String>> consolidated = new HashMap<>();\n+      if (fieldHighlight != null && fieldHighlight.size() > 0) {\n+        for (Map.Entry<String, List<String>> entry : fieldHighlight.entrySet()) {\n+          String solrField = entry.getKey();\n+          String normalizedKey = resolver.resolveFieldName(solrField);\n+          if (isHighlightBlacklisted(normalizedKey) || isHighlightBlacklisted(solrField)) {", "originalCommit": "9e71633a9a31ed06f0fa1fd54e172c51e5a07e6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjk5Njk3Ng==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r412996976", "bodyText": "The isHighlightBlacklisted method checks the DynamicSchemaResolver.isPrivateField() method as well so most of those are filtered out by that.  Oddly, metacard_source_txt is not in that list,, nor are the metadata fields.  I could add those to the private fields list in the resolver or to a different internal blacklist if that makes more sense.", "author": "derekwilhelm", "createdAt": "2020-04-22T13:46:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU1MzAxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzEwMTYwOA==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r413101608", "bodyText": "It looks like the metacard type fields are in that list.\nhttps://github.com/codice/ddf/blob/55ce87a/catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/DynamicSchemaResolver.java#L116-L117\nMetacard source isn't since it does not know about it.  The SolrCache in the standard framework adds that when using its composed SolrMetacardClient.\nhttps://github.com/codice/ddf/blob/55ce87a/catalog/core/catalog-core-standardframework/src/main/java/ddf/catalog/cache/solr/impl/SolrCache.java#L76-L83", "author": "pklinef", "createdAt": "2020-04-22T15:50:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU1MzAxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEwMjc1Nw==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r418102757", "bodyText": "I reworked this section a little to use the specific metacard type for the result being highlighted.", "author": "derekwilhelm", "createdAt": "2020-04-30T15:37:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU1MzAxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU1NDY5NQ==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r412554695", "bodyText": "\u270f\ufe0f See my comment about filtering out any field that is not part of the metacard type definition. I don't think you need these changes or the SchemaFields.java changes if you apply that change since metacard attributes should only contain - or . characters in their names. It looks like you only needed this change to filter out internal fields the Solr provider creates that uses only _ as separators.  But those fields should never be returned from the provider.", "author": "pklinef", "createdAt": "2020-04-21T23:14:10Z", "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/DynamicSchemaResolver.java", "diffHunk": "@@ -507,12 +507,18 @@ private Serializable getDocValue(String solrFieldName, Object docValue) {\n    * @return the original field name\n    */\n   String resolveFieldName(String solrFieldName) {\n-    int lastIndexOfUndercore = solrFieldName.lastIndexOf(FIRST_CHAR_OF_SUFFIX);\n-\n-    if (lastIndexOfUndercore != -1) {\n-      return solrFieldName.substring(0, lastIndexOfUndercore);\n+    String originalName = solrFieldName;\n+    boolean suffixExists = true;", "originalCommit": "9e71633a9a31ed06f0fa1fd54e172c51e5a07e6a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzAwODY4OQ==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r413008689", "bodyText": "The original code only assumes that there is one suffix added to a field name in Solr, but that is actually not true.  For text fields we add one or more others depending on the field use (tokenization, case sensitivity, phonetics).  From a highlighting perspective, I can get a hit on any of those other fields.  For example, let's say I get a highlight on the tokenized version of the title field.  The name of that field in Solr is title_txt_tokenized.  A call to this function in its original form would return title_txt, which is not the real, original field name.  Even worse, let's assume I get a highlight hit against the case sensitive version of the title field, which in Solr is title_txt_tokenized_has_case.  In this example I get returned the value title_txt_tokenized_has.  In the original use case of this function, it was pretty safe to assume that the _ character marked the suffix because it was really only ever called when a field only had one suffix (the assumed stored field for returning results).  Since highlights can occur against these other fields, I do need these changes.  Plus, this removes the assumptions about the field names and makes it more consistent with how the resolver actually generates all of the Solr field names.", "author": "derekwilhelm", "createdAt": "2020-04-22T14:00:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU1NDY5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzA5NTk1MA==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r413095950", "bodyText": "We would have to benchmark it to be sure either way so this might be premature optimization but my initial concern was that this method is called on every field of every metacard converted back from a Solr doc.\nAnother option would be not to care if the suffix is at the end.  Then you could pass over the suffix list once.  A slight optimization for that would be to find the index of the first underscore and use that as an offset when getting the indexOf of the suffix since we know all suffixes start with an underscore.", "author": "pklinef", "createdAt": "2020-04-22T15:43:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU1NDY5NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEwMTc4NA==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r418101784", "bodyText": "I mostly reverted this code but changed it so that it looks for the first index rather than the last.  Since this should only be called with real attribute names, it should take care of all of the permutations of the added suffixes.", "author": "derekwilhelm", "createdAt": "2020-04-30T15:36:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjU1NDY5NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEwODg1OQ==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r418108859", "bodyText": "\u270f\ufe0f We could protect from accidental mutation if we return an unmodifiable view of the list.\nhttps://docs.oracle.com/javase/8/docs/api/java/util/Collections.html#unmodifiableList-java.util.List-", "author": "pklinef", "createdAt": "2020-04-30T15:46:22Z", "path": "catalog/core/catalog-core-api-impl/src/main/java/ddf/catalog/operation/impl/ResultAttributeHighlightImpl.java", "diffHunk": "@@ -0,0 +1,45 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.operation.impl;\n+\n+import ddf.catalog.operation.ResultAttributeHighlight;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class ResultAttributeHighlightImpl implements ResultAttributeHighlight {\n+\n+  private String attributeName;\n+\n+  private List<String> highlights;\n+\n+  public ResultAttributeHighlightImpl(String attributeName) {\n+    this.attributeName = attributeName;\n+    highlights = new ArrayList<>();\n+  }\n+\n+  public ResultAttributeHighlightImpl(String attributeName, List<String> highlights) {\n+    this(attributeName);\n+    this.highlights.addAll(highlights);\n+  }\n+\n+  @Override\n+  public String getAttributeName() {\n+    return attributeName;\n+  }\n+\n+  @Override\n+  public List<String> getHighlights() {\n+    return highlights;", "originalCommit": "04c919c72c54c5a6c48bfcc66226933543206ca8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEwOTI3Mg==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r418109272", "bodyText": "\u270f\ufe0f Same comment about unmodifiableList", "author": "pklinef", "createdAt": "2020-04-30T15:46:59Z", "path": "catalog/core/catalog-core-api-impl/src/main/java/ddf/catalog/operation/impl/ResultHighlightImpl.java", "diffHunk": "@@ -0,0 +1,63 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.operation.impl;\n+\n+import ddf.catalog.operation.ResultAttributeHighlight;\n+import ddf.catalog.operation.ResultHighlight;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class ResultHighlightImpl implements ResultHighlight {\n+  private String resultId;\n+\n+  private List<ResultAttributeHighlight> attributeHighlights;\n+\n+  /**\n+   * Instantiates a ResultHighlightImpl representing the highlight information for a particular\n+   * query result. The attribute highlight data is available to add to or retrieve via the <code>\n+   * getAttributeHighlights</code> method. This constructor creates an empty attribute highlight\n+   * list, indicating that there are no highlights.\n+   *\n+   * @param resultId The ID of the result for which the contained highlights are for\n+   */\n+  public ResultHighlightImpl(String resultId) {\n+    this.resultId = resultId;\n+    attributeHighlights = new ArrayList<>();\n+  }\n+\n+  /**\n+   * Instantiates a ResultHighlightImpl representing the highlight information for a particular\n+   * query result. Any number of {@link ResultAttributeHighlight}s may be provided to indicate that\n+   * more than one attribute was matched in a query. Additional highlight data may be added to the\n+   * list by first requesting the list of highlights from the <code>getAttributeHighlights</code>\n+   * method.\n+   *\n+   * @param resultId The ID of the result for which the contained highlights are for\n+   * @param attributeHighlights The list of attribute highlights that apply to the result\n+   */\n+  public ResultHighlightImpl(String resultId, List<ResultAttributeHighlight> attributeHighlights) {\n+    this(resultId);\n+    this.attributeHighlights.addAll(attributeHighlights);\n+  }\n+\n+  @Override\n+  public String getResultId() {\n+    return resultId;\n+  }\n+\n+  @Override\n+  public List<ResultAttributeHighlight> getAttributeHighlights() {\n+    return attributeHighlights;", "originalCommit": "04c919c72c54c5a6c48bfcc66226933543206ca8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODExMzY1OQ==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r418113659", "bodyText": "\u270f\ufe0f It seems weird to me that this configuration is in the catalog API since this is related to Catalog Provider implementations which is independent of the catalog framework.  HistorianConfiguration makes a little more sense since you enable and disable it at the catalog framework level.  But I would think that highlight is enabled or disabled at the provider level.  Seems like highlighting is more of a provider concern than a catalog framework concern.  Unless you are thinking we would eventually do catalog framework level highlighting for all results being returned if none are provided by a source.", "author": "pklinef", "createdAt": "2020-04-30T15:53:11Z", "path": "catalog/core/catalog-core-api/src/main/java/ddf/catalog/configuration/SearchCapabilityConfiguration.java", "diffHunk": "@@ -0,0 +1,24 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.configuration;\n+\n+/**\n+ * Interface to determine what search capabilities are enabled.", "originalCommit": "04c919c72c54c5a6c48bfcc66226933543206ca8", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE3NDE1MQ==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r418174151", "bodyText": "I struggled with this for quite some time.  I originally had this as part of the provider instead because I agree that it makes more sense there.  However, if we want to support highlighting data from the cache I needed it somewhere else because having the configuration in the provider and used by the cache creates a dependency problem.  If the cache were not embedded inside the catalog framework, I would have done this differently.  I'm open to suggestions.", "author": "derekwilhelm", "createdAt": "2020-04-30T17:31:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODExMzY1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODE3Njg5Mw==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r418176893", "bodyText": "Perhaps the best answer is we don't support it in the cache right now and then add in that capability once the cache is extracted out of the catalog framework?", "author": "derekwilhelm", "createdAt": "2020-04-30T17:36:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODExMzY1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIwNzUxNQ==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r418207515", "bodyText": "The other reason this is here (now that I'm going through this again) is that the actual solr client code that needs this is in catalog-core-solr, not in the provider, and that code is utilized by both the solr provider and the framework.  I needed a common place to put the API that didn't cause dependency issues.  So, even if we don't enable this for the cache, I still need a solution to the dependency problem if it is not here in the api.", "author": "derekwilhelm", "createdAt": "2020-04-30T18:29:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODExMzY1OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODIyMDUzMA==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r418220530", "bodyText": "I like the idea of not supporting it in the cache for now.  Maybe we can get the cache extracted soon. But even if we did support it in the cache, I think the cache or at least the caching federation strategy has its own configuration we could add this to.", "author": "pklinef", "createdAt": "2020-04-30T18:53:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODExMzY1OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxODEyNDg1OQ==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r418124859", "bodyText": "\u270f\ufe0f I think you can combine these 5 lines if you use computeIfAbsent but what you have fine too.\nhttps://docs.oracle.com/javase/8/docs/api/java/util/Map.html#computeIfAbsent-K-java.util.function.Function-", "author": "pklinef", "createdAt": "2020-04-30T16:09:50Z", "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/SolrMetacardClientImpl.java", "diffHunk": "@@ -311,6 +350,107 @@ private Boolean userSpellcheckIsOn(QueryRequest request) {\n     return userSpellcheckChoice;\n   }\n \n+  private Boolean userHighlightIsOn(QueryRequest request) {\n+    Boolean userHighlight = false;\n+    if (request.getProperties().get(HIGHLIGHT_KEY) != null) {\n+      userHighlight = (Boolean) request.getProperties().get(HIGHLIGHT_KEY);\n+    } else if (searchCapabilityConfiguration != null) {\n+      userHighlight = searchCapabilityConfiguration.isHighlightingEnabled();\n+    }\n+    return userHighlight;\n+  }\n+\n+  private void enableHighlighter(SolrQuery query) {\n+    query.setParam(SOLR_HIGHLIGHT_KEY, true);\n+    query.setParam(\"hl.fl\", \"*\");\n+    query.setParam(\"hl.simple.pre\", \"<b>\");\n+    query.setParam(\"hl.tag.pre\", \"<b>\");\n+    query.setParam(\"hl.simple.post\", \"</b>\");\n+    query.setParam(\"hl.tag.post\", \"</b>\");\n+    query.setParam(\"hl.requireFieldMatch\", true);\n+    query.setParam(\"hl.method\", \"unified\");\n+  }\n+\n+  private void extractHighlighing(QueryResponse response, Map<String, Serializable> responseProps) {\n+    Map<String, Map<String, List<String>>> highlights = response.getHighlighting();\n+    if (highlights == null) {\n+      return;\n+    }\n+    List<ResultHighlight> resultsHighlights = new ArrayList<>();\n+    for (String metacardId : highlights.keySet()) {\n+\n+      Map<String, List<String>> fieldHighlight = highlights.get(metacardId);\n+      Map<String, Set<String>> consolidated = new HashMap<>();\n+      if (fieldHighlight != null && fieldHighlight.size() > 0) {\n+        for (Map.Entry<String, List<String>> entry : fieldHighlight.entrySet()) {\n+          String solrField = entry.getKey();\n+          String normalizedKey = resolver.resolveFieldName(solrField);\n+          if (isHighlightBlacklisted(normalizedKey)\n+              || isHighlightBlacklisted(solrField)\n+              || !isMetacardAttribute(normalizedKey, metacardId, response)) {\n+            continue;\n+          }\n+          Set<String> consolidatedSet = consolidated.get(normalizedKey);", "originalCommit": "04c919c72c54c5a6c48bfcc66226933543206ca8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2828f5ef708978950f7e1fcbf7c2641b151e0025", "url": "https://github.com/codice/ddf/commit/2828f5ef708978950f7e1fcbf7c2641b151e0025", "message": "DDF-6008 - Enable Solr Highlighting", "committedDate": "2020-05-04T23:37:08Z", "type": "commit"}, {"oid": "8fef88920ac1cd17aa3fe50f3ae31242530342db", "url": "https://github.com/codice/ddf/commit/8fef88920ac1cd17aa3fe50f3ae31242530342db", "message": "User metacardtype to aid blacklist", "committedDate": "2020-05-04T23:37:09Z", "type": "commit"}, {"oid": "3b5f8dd22560685c97c8ffdb93f0fcdbc32a58d3", "url": "https://github.com/codice/ddf/commit/3b5f8dd22560685c97c8ffdb93f0fcdbc32a58d3", "message": "Refactor highlight responses and add configuration", "committedDate": "2020-05-04T23:37:09Z", "type": "commit"}, {"oid": "6c7b0720c605aaa4eff26bc9f6a8da8b1dd9f1af", "url": "https://github.com/codice/ddf/commit/6c7b0720c605aaa4eff26bc9f6a8da8b1dd9f1af", "message": "Add unit test, rework configuration option", "committedDate": "2020-05-04T23:37:09Z", "type": "commit"}, {"oid": "1dd1f4106c855ad168dd81d8d3d51caea309e86f", "url": "https://github.com/codice/ddf/commit/1dd1f4106c855ad168dd81d8d3d51caea309e86f", "message": "Fix property access", "committedDate": "2020-05-04T23:37:09Z", "type": "commit"}, {"oid": "62457b042a2ffcc7b433a3d5d5ac220db6341e35", "url": "https://github.com/codice/ddf/commit/62457b042a2ffcc7b433a3d5d5ac220db6341e35", "message": "Turn off highlighting after test", "committedDate": "2020-05-04T23:37:09Z", "type": "commit"}, {"oid": "7ea1209dcc1aaa1f9338544466ac87e528d0e888", "url": "https://github.com/codice/ddf/commit/7ea1209dcc1aaa1f9338544466ac87e528d0e888", "message": "Revert DynamicSchemaResolver", "committedDate": "2020-05-05T16:18:09Z", "type": "commit"}, {"oid": "7ea1209dcc1aaa1f9338544466ac87e528d0e888", "url": "https://github.com/codice/ddf/commit/7ea1209dcc1aaa1f9338544466ac87e528d0e888", "message": "Revert DynamicSchemaResolver", "committedDate": "2020-05-05T16:18:09Z", "type": "forcePushed"}, {"oid": "25848a6a548d9481228f3cd571265a0938e10877", "url": "https://github.com/codice/ddf/commit/25848a6a548d9481228f3cd571265a0938e10877", "message": "Move highlight key out of SolrMetacardClientImpl", "committedDate": "2020-05-05T17:10:29Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzNTY2NA==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r420435664", "bodyText": "\u270f\ufe0f Highlighting is missing the t.", "author": "bellcc", "createdAt": "2020-05-05T22:08:04Z", "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/SolrMetacardClientImpl.java", "diffHunk": "@@ -311,6 +343,120 @@ private Boolean userSpellcheckIsOn(QueryRequest request) {\n     return userSpellcheckChoice;\n   }\n \n+  private Boolean userHighlightIsOn(QueryRequest request) {\n+    Boolean userHighlight;\n+    if (request.getProperties().get(QUERY_HIGHLIGHT_KEY) != null) {\n+      userHighlight = (Boolean) request.getProperties().get(QUERY_HIGHLIGHT_KEY);\n+    } else {\n+      userHighlight = isSystemHighlightingEnabled();\n+    }\n+    return userHighlight;\n+  }\n+\n+  protected boolean isSystemHighlightingEnabled() {\n+    return BooleanUtils.toBoolean(accessProperty(HIGHLIGHT_ENABLE_PROPERTY, \"false\"));\n+  }\n+\n+  private void enableHighlighter(SolrQuery query) {\n+    query.setParam(SOLR_HIGHLIGHT_KEY, true);\n+    query.setParam(\"hl.fl\", \"*\");\n+    query.setParam(\"hl.simple.pre\", \"<b>\");\n+    query.setParam(\"hl.tag.pre\", \"<b>\");\n+    query.setParam(\"hl.simple.post\", \"</b>\");\n+    query.setParam(\"hl.tag.post\", \"</b>\");\n+    query.setParam(\"hl.requireFieldMatch\", true);\n+    query.setParam(\"hl.method\", \"unified\");\n+  }\n+\n+  private void extractHighlighing(QueryResponse response, Map<String, Serializable> responseProps) {", "originalCommit": "25848a6a548d9481228f3cd571265a0938e10877", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzNzkwNQ==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r420437905", "bodyText": "Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n                int firstIndexOfUndercore = solrFieldName.indexOf(FIRST_CHAR_OF_SUFFIX);\n          \n          \n            \n                int firstIndexOfUnderscore = solrFieldName.indexOf(FIRST_CHAR_OF_SUFFIX);", "author": "stevenmalmgren", "createdAt": "2020-05-05T22:13:12Z", "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/SolrMetacardClientImpl.java", "diffHunk": "@@ -311,6 +343,120 @@ private Boolean userSpellcheckIsOn(QueryRequest request) {\n     return userSpellcheckChoice;\n   }\n \n+  private Boolean userHighlightIsOn(QueryRequest request) {\n+    Boolean userHighlight;\n+    if (request.getProperties().get(QUERY_HIGHLIGHT_KEY) != null) {\n+      userHighlight = (Boolean) request.getProperties().get(QUERY_HIGHLIGHT_KEY);\n+    } else {\n+      userHighlight = isSystemHighlightingEnabled();\n+    }\n+    return userHighlight;\n+  }\n+\n+  protected boolean isSystemHighlightingEnabled() {\n+    return BooleanUtils.toBoolean(accessProperty(HIGHLIGHT_ENABLE_PROPERTY, \"false\"));\n+  }\n+\n+  private void enableHighlighter(SolrQuery query) {\n+    query.setParam(SOLR_HIGHLIGHT_KEY, true);\n+    query.setParam(\"hl.fl\", \"*\");\n+    query.setParam(\"hl.simple.pre\", \"<b>\");\n+    query.setParam(\"hl.tag.pre\", \"<b>\");\n+    query.setParam(\"hl.simple.post\", \"</b>\");\n+    query.setParam(\"hl.tag.post\", \"</b>\");\n+    query.setParam(\"hl.requireFieldMatch\", true);\n+    query.setParam(\"hl.method\", \"unified\");\n+  }\n+\n+  private void extractHighlighing(QueryResponse response, Map<String, Serializable> responseProps) {\n+    Map<String, Map<String, List<String>>> highlights = response.getHighlighting();\n+    if (highlights == null) {\n+      return;\n+    }\n+    List<ResultHighlight> resultsHighlights = new ArrayList<>();\n+    for (String metacardId : highlights.keySet()) {\n+\n+      Map<String, List<String>> fieldHighlight = highlights.get(metacardId);\n+      Map<String, Set<String>> consolidated = new HashMap<>();\n+      if (fieldHighlight != null && fieldHighlight.size() > 0) {\n+        for (Map.Entry<String, List<String>> entry : fieldHighlight.entrySet()) {\n+          String solrField = entry.getKey();\n+          String normalizedKey = resolveHighlightFieldName(solrField);\n+          if (isHighlightBlacklisted(normalizedKey)\n+              || isHighlightBlacklisted(solrField)\n+              || !isMetacardAttribute(normalizedKey, metacardId, response)) {\n+            continue;\n+          }\n+          Set<String> consolidatedSet = consolidated.get(normalizedKey);\n+          if (consolidatedSet == null) {\n+            consolidatedSet = new HashSet<>();\n+          }\n+          consolidatedSet.addAll(entry.getValue());\n+          if (!consolidatedSet.isEmpty()) {\n+            consolidated.put(normalizedKey, consolidatedSet);\n+          }\n+        }\n+      }\n+      if (!consolidated.isEmpty()) {\n+        List<ResultAttributeHighlight> attributeHighlights = new ArrayList<>();\n+        for (Map.Entry<String, Set<String>> fieldEntry : consolidated.entrySet()) {\n+          attributeHighlights.add(\n+              new ResultAttributeHighlightImpl(\n+                  fieldEntry.getKey(), new ArrayList<>(fieldEntry.getValue())));\n+        }\n+        resultsHighlights.add(new ResultHighlightImpl(metacardId, attributeHighlights));\n+      }\n+    }\n+\n+    if (!resultsHighlights.isEmpty()) {\n+      responseProps.put(QUERY_HIGHLIGHT_KEY, (Serializable) resultsHighlights);\n+    }\n+  }\n+\n+  private String resolveHighlightFieldName(String solrFieldName) {\n+    int firstIndexOfUndercore = solrFieldName.indexOf(FIRST_CHAR_OF_SUFFIX);", "originalCommit": "25848a6a548d9481228f3cd571265a0938e10877", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQzODEyMQ==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r420438121", "bodyText": "\u270f\ufe0f typo here or maybe I'm misreading that.  \"for a particular ??\"", "author": "jlcsmith", "createdAt": "2020-05-05T22:13:47Z", "path": "catalog/core/catalog-core-api/src/main/java/ddf/catalog/operation/ResultHighlight.java", "diffHunk": "@@ -0,0 +1,26 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.operation;\n+\n+import java.util.List;\n+\n+/**\n+ * ResultHighlight represents a list of attributes that matched a given query for a particular as", "originalCommit": "25848a6a548d9481228f3cd571265a0938e10877", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "31541e2cb5a8e58804bfee6798c8c9b4272ac061", "url": "https://github.com/codice/ddf/commit/31541e2cb5a8e58804bfee6798c8c9b4272ac061", "message": "Fix typos", "committedDate": "2020-05-05T22:23:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5ODI0Ng==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r420498246", "bodyText": "\u2753 I wonder if instead of returning a string with the Solr implementation detail that the highlights are surrounded with <em> if we should return the string without the <em> and instead include start and stop position indexes.  Then clients can decide how to represent that data.", "author": "pklinef", "createdAt": "2020-05-06T01:22:33Z", "path": "catalog/core/catalog-core-api/src/main/java/ddf/catalog/operation/ResultAttributeHighlight.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.operation;\n+\n+import java.util.List;\n+\n+/**\n+ * ResultAttributeHighlight represents a specific attribute that matched a query and provides\n+ * indications of what the specific data the query matched on via a list of highlights. The\n+ * individual highlights are meant to be snippets of highlighted data from the attribute's value.\n+ */\n+public interface ResultAttributeHighlight {\n+  String getAttributeName();\n+\n+  List<String> getHighlights();", "originalCommit": "31541e2cb5a8e58804bfee6798c8c9b4272ac061", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTM2NDA4Nw==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r421364087", "bodyText": "I agree, returning indices would be cleaner than providing solr text snippets.  The tricky part is pulling the highlights out of the solr response to generate the proper highlight indexes.  However, I think I was able to get this worked out with my latest commits.", "author": "derekwilhelm", "createdAt": "2020-05-07T09:23:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMDQ5ODI0Ng=="}], "type": "inlineReview"}, {"oid": "7ec546a83fa60ee6592fd4f5a0d1ce0f1c5cde7d", "url": "https://github.com/codice/ddf/commit/7ec546a83fa60ee6592fd4f5a0d1ce0f1c5cde7d", "message": "Refactor to return indices instead of strings", "committedDate": "2020-05-07T05:17:58Z", "type": "commit"}, {"oid": "b6223e6fe8b37552bd7bba0cbe53d38f757f2a39", "url": "https://github.com/codice/ddf/commit/b6223e6fe8b37552bd7bba0cbe53d38f757f2a39", "message": "Fix edge cases, fix cache IDs", "committedDate": "2020-05-07T09:20:18Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTQ1NzExMg==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r421457112", "bodyText": "\u270f\ufe0f Isn't there a StringUtils.isNotBlank?", "author": "glenhein", "createdAt": "2020-05-07T12:15:07Z", "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/ResultHighlighter.java", "diffHunk": "@@ -255,25 +281,38 @@ private boolean isHighlightBlacklisted(String fieldName) {\n     return !blacklist.isEmpty() || resolver.isPrivateField(fieldName);\n   }\n \n-  private boolean isMetacardAttribute(String fieldName, String metacardId, QueryResponse response) {\n-    MetacardType type = getMetacardType(metacardId, response);\n+  private boolean isMetacardAttribute(String fieldName, String resultId, QueryResponse response) {\n+    MetacardType type = getMetacardType(resultId, response);\n     if (type != null) {\n       return type.getAttributeDescriptor(fieldName) != null;\n     }\n \n     return false;\n   }\n \n-  private Optional<SolrDocument> getResponseDocument(String metacardId, QueryResponse response) {\n+  private String getMetacardId(String resultId, QueryResponse response) {\n+    if (!StringUtils.isBlank(mappedMetacardIdField)) {", "originalCommit": "b6223e6fe8b37552bd7bba0cbe53d38f757f2a39", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTUwMTYwNg==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r421501606", "bodyText": "\u270f\ufe0f You could just call the other ctor", "author": "glenhein", "createdAt": "2020-05-07T13:26:17Z", "path": "catalog/core/catalog-core-api-impl/src/main/java/ddf/catalog/operation/impl/HighlightImpl.java", "diffHunk": "@@ -0,0 +1,82 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.operation.impl;\n+\n+import ddf.catalog.operation.Highlight;\n+import java.util.List;\n+\n+public class HighlightImpl implements Highlight {\n+\n+  private int valueIndex;\n+\n+  private int beginIndex;\n+\n+  private int endIndex;\n+\n+  public HighlightImpl() {}\n+\n+  public HighlightImpl(int beginIndex, int endIndex) {\n+    this.valueIndex = 0;", "originalCommit": "7ec546a83fa60ee6592fd4f5a0d1ce0f1c5cde7d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTU1MjM0Mg==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r421552342", "bodyText": "\u270f\ufe0f I wouldn't hold the PR up for this, but we should probably mark this as an experimental interface", "author": "jlcsmith", "createdAt": "2020-05-07T14:32:51Z", "path": "catalog/core/catalog-core-api/src/main/java/ddf/catalog/operation/Highlight.java", "diffHunk": "@@ -0,0 +1,27 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.operation;\n+\n+/**\n+ * A Highlight represents a specific range of characters in an attribute that matched a query. The\n+ * begin and end indices are referenced to the specific attribute value. The value index refers to\n+ * multi-valued fields and indicates which value the highlight applies to.\n+ */\n+public interface Highlight {", "originalCommit": "7ec546a83fa60ee6592fd4f5a0d1ce0f1c5cde7d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e6690b4807466385a0f7220c6974454a61006eb6", "url": "https://github.com/codice/ddf/commit/e6690b4807466385a0f7220c6974454a61006eb6", "message": "Mark as experimental and minor cleanup", "committedDate": "2020-05-07T16:09:47Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY1Njk4NQ==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r421656985", "bodyText": "\u2753 Static?", "author": "pklinef", "createdAt": "2020-05-07T17:02:55Z", "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/ResultHighlighter.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.source.solr;\n+\n+import static ddf.catalog.Constants.QUERY_HIGHLIGHT_KEY;\n+import static ddf.catalog.source.solr.DynamicSchemaResolver.FIRST_CHAR_OF_SUFFIX;\n+\n+import com.google.common.collect.Sets;\n+import ddf.catalog.data.MetacardCreationException;\n+import ddf.catalog.data.MetacardType;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.operation.Highlight;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.ResultAttributeHighlight;\n+import ddf.catalog.operation.ResultHighlight;\n+import ddf.catalog.operation.impl.HighlightImpl;\n+import ddf.catalog.operation.impl.ResultAttributeHighlightImpl;\n+import ddf.catalog.operation.impl.ResultHighlightImpl;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang.builder.EqualsBuilder;\n+import org.apache.commons.lang.builder.HashCodeBuilder;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.common.SolrDocument;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ResultHighlighter {\n+\n+  public static final String HIGHLIGHT_ENABLE_PROPERTY = \"solr.highlight.enabled\";\n+\n+  public static final String SOLR_HIGHLIGHT_BLACKLIST = \"solr.highlight.blacklist\";\n+\n+  public static final String SOLR_HIGHLIGHT_SNIPPETS = \"solr.highlight.snippets\";\n+\n+  public static final String SOLR_HIGHLIGHT_KEY = \"hl\";\n+\n+  private static final String HIGHLIGHT_PRE_TAG = \"<em>\";\n+\n+  private static final String HIGHLIGHT_POST_TAG = \"</em>\";\n+\n+  private static final Pattern HIGHLIGHT_PATTERN =\n+      Pattern.compile(\n+          HIGHLIGHT_PRE_TAG + \"(((?!\" + HIGHLIGHT_PRE_TAG + \").)*?)\" + HIGHLIGHT_POST_TAG);\n+\n+  private static final Pattern TAG_PATTERN =\n+      Pattern.compile(\"(\" + HIGHLIGHT_PRE_TAG + \"|\" + HIGHLIGHT_POST_TAG + \")\");\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ResultHighlighter.class);\n+\n+  private final Set<String> highlightBlacklist =\n+      Sets.newHashSet(System.getProperty(SOLR_HIGHLIGHT_BLACKLIST, \"\").split(\"\\\\s*,\\\\s*\"));\n+\n+  private int surroundingContextSize = 20;\n+\n+  private DynamicSchemaResolver resolver;\n+\n+  private String mappedMetacardIdField;\n+\n+  public ResultHighlighter(DynamicSchemaResolver resolver) {\n+    this.resolver = resolver;\n+  }\n+\n+  public void setMappedMetacardIdField(String mappedMetacardIdField) {\n+    this.mappedMetacardIdField = mappedMetacardIdField;\n+  }\n+\n+  public void processPreQuery(QueryRequest request, SolrQuery query) {\n+    if (userHighlightIsOn(request)) {\n+      enableHighlighter(query);\n+    }\n+  }\n+\n+  public void processPostQuery(QueryResponse response, Map<String, Serializable> responseProps) {\n+    extractHighlighting(response, responseProps);\n+  }\n+\n+  private Boolean userHighlightIsOn(QueryRequest request) {\n+    Boolean userHighlight;\n+    if (request.getProperties().get(QUERY_HIGHLIGHT_KEY) != null) {\n+      userHighlight = (Boolean) request.getProperties().get(QUERY_HIGHLIGHT_KEY);\n+    } else {\n+      userHighlight = isSystemHighlightingEnabled();\n+    }\n+    return userHighlight;\n+  }\n+\n+  protected boolean isSystemHighlightingEnabled() {\n+    return BooleanUtils.toBoolean(System.getProperty(HIGHLIGHT_ENABLE_PROPERTY, \"false\"));\n+  }\n+\n+  private String getSnippetSetting() {\n+    return System.getProperty(SOLR_HIGHLIGHT_SNIPPETS, \"20\");\n+  }\n+\n+  protected void enableHighlighter(SolrQuery query) {\n+    query.setParam(SOLR_HIGHLIGHT_KEY, true);\n+    query.setParam(\"hl.fl\", \"*\");\n+    query.setParam(\"hl.requireFieldMatch\", true);\n+    query.setParam(\"hl.method\", \"unified\");\n+    query.setParam(\"hl.preserveMulti\", true);\n+    query.setParam(\"hl.snippets\", getSnippetSetting());\n+  }\n+\n+  protected void extractHighlighting(\n+      QueryResponse response, Map<String, Serializable> responseProps) {\n+    Map<String, Map<String, List<String>>> highlights = response.getHighlighting();\n+    if (highlights == null) {\n+      return;\n+    }\n+    List<ResultHighlight> resultsHighlights = new ArrayList<>();\n+    for (String resultId : highlights.keySet()) {\n+\n+      Map<String, List<String>> fieldHighlight = highlights.get(resultId);\n+      Map<String, Set<Highlight>> consolidated = new HashMap<>();\n+      if (fieldHighlight != null && fieldHighlight.size() > 0) {\n+        for (Map.Entry<String, List<String>> entry : fieldHighlight.entrySet()) {\n+          String solrField = entry.getKey();\n+          String normalizedKey = resolveHighlightFieldName(solrField);\n+          if (isHighlightBlacklisted(normalizedKey)\n+              || isHighlightBlacklisted(solrField)\n+              || !isMetacardAttribute(normalizedKey, resultId, response)) {\n+            continue;\n+          }\n+          Set<Highlight> consolidatedSet = consolidated.get(normalizedKey);\n+          if (consolidatedSet == null) {\n+            consolidatedSet = new HashSet<>();\n+          }\n+          consolidatedSet.addAll(\n+              createHighlights(\n+                  entry.getValue(),\n+                  getAttributeValue(resultId, normalizedKey + SchemaFields.TEXT_SUFFIX, response)));\n+          if (!consolidatedSet.isEmpty()) {\n+            consolidated.put(normalizedKey, consolidatedSet);\n+          }\n+        }\n+      }\n+      if (!consolidated.isEmpty()) {\n+        List<ResultAttributeHighlight> attributeHighlights = new ArrayList<>();\n+        for (Map.Entry<String, Set<Highlight>> fieldEntry : consolidated.entrySet()) {\n+          attributeHighlights.add(\n+              new ResultAttributeHighlightImpl(\n+                  fieldEntry.getKey(), new ArrayList<>(fieldEntry.getValue())));\n+        }\n+\n+        resultsHighlights.add(\n+            new ResultHighlightImpl(getMetacardId(resultId, response), attributeHighlights));\n+      }\n+    }\n+\n+    if (!resultsHighlights.isEmpty()) {\n+      responseProps.put(QUERY_HIGHLIGHT_KEY, (Serializable) resultsHighlights);\n+    }\n+  }\n+\n+  private List<Highlight> createHighlights(\n+      List<String> highlightResults, Collection<Object> baseValues) {\n+    List<Highlight> highlights = new ArrayList<>();\n+    if (baseValues != null && !baseValues.isEmpty()) {\n+      List<HighlightContext> highlightedValues = new ArrayList<>();\n+      highlightResults\n+          .stream()\n+          .forEach(result -> highlightedValues.addAll(getHighlightedValues(result)));\n+\n+      int index = 0;\n+      for (Object value : baseValues) {\n+        if (value != null) {\n+          highlights.addAll(extractHighlights(value.toString(), highlightedValues, index));\n+        }\n+        index++;\n+      }\n+    }\n+    return highlights;\n+  }\n+\n+  private List<Highlight> extractHighlights(\n+      String text, List<HighlightContext> values, int valueIndex) {\n+    List<Highlight> highlights = new ArrayList<>();\n+    TagIndices sourceTagIndices = new TagIndices(text);\n+    for (HighlightContext context : values) {\n+      int index = -1;\n+      int length = context.highlightedToken.length();\n+      HighlightContext source = new HighlightContext();\n+      source.surroundingContext = text;\n+      source.tokenContextOffset = 0;\n+      source.resolveSurroundingContext(false);\n+      do {\n+        index = source.surroundingContext.indexOf(context.surroundingContext, index + 1);\n+        if (index > -1) {\n+          int beginIndex = index + context.tokenContextOffset;\n+          int endIndex = index + context.tokenContextOffset + length;\n+          if (sourceTagIndices.getStartTagIndices().contains(beginIndex) && !context.embeded) {\n+            continue;\n+          }\n+          int sourceHighlightOffset =\n+              sourceTagIndices.countStartBefore(beginIndex) * HIGHLIGHT_PRE_TAG.length()\n+                  + sourceTagIndices.countEndBefore(beginIndex) * HIGHLIGHT_POST_TAG.length();\n+          beginIndex += sourceHighlightOffset;\n+          endIndex += sourceHighlightOffset;\n+          highlights.add(new HighlightImpl(beginIndex, endIndex, valueIndex));\n+        }\n+      } while (index > -1);\n+    }\n+    return highlights;\n+  }\n+\n+  private List<HighlightContext> getHighlightedValues(String highlightedText) {\n+    List<HighlightContext> values = new ArrayList<>();\n+    Matcher matcher = HIGHLIGHT_PATTERN.matcher(highlightedText);\n+    while (matcher.find()) {\n+      String token = matcher.group(1);\n+      HighlightContext context = new HighlightContext();\n+      context.highlightedToken = token;\n+      context.surroundingContext = highlightedText;\n+      context.tokenContextOffset = matcher.start();\n+      context.embeded = isHighlightEmbeded(highlightedText, matcher.start());\n+      context.resolveSurroundingContext(true);\n+      values.add(context);\n+    }\n+\n+    return values;\n+  }\n+\n+  private boolean isHighlightEmbeded(String text, int highlightIndex) {\n+    if (highlightIndex - HIGHLIGHT_PRE_TAG.length() < 0) {\n+      return false;\n+    } else {\n+      return text.substring(highlightIndex - HIGHLIGHT_PRE_TAG.length(), highlightIndex)\n+          .equals(HIGHLIGHT_PRE_TAG);\n+    }\n+  }\n+\n+  private Collection<Object> getAttributeValue(\n+      String resultId, String fieldName, QueryResponse response) {\n+    Optional<SolrDocument> metacard = getResponseDocument(resultId, response);\n+    if (metacard.isPresent()) {\n+      return metacard.get().getFieldValues(fieldName);\n+    }\n+    return null;\n+  }\n+\n+  private String resolveHighlightFieldName(String solrFieldName) {\n+    int firstIndexOfSuffix = solrFieldName.indexOf(FIRST_CHAR_OF_SUFFIX);\n+\n+    if (firstIndexOfSuffix != -1) {\n+      return solrFieldName.substring(0, firstIndexOfSuffix);\n+    }\n+    return solrFieldName;\n+  }\n+\n+  private boolean isHighlightBlacklisted(String fieldName) {\n+    List<String> blacklist =\n+        highlightBlacklist\n+            .stream()\n+            .filter(item -> fieldName.matches(item))\n+            .collect(Collectors.toList());\n+    return !blacklist.isEmpty() || resolver.isPrivateField(fieldName);\n+  }\n+\n+  private boolean isMetacardAttribute(String fieldName, String resultId, QueryResponse response) {\n+    MetacardType type = getMetacardType(resultId, response);\n+    if (type != null) {\n+      return type.getAttributeDescriptor(fieldName) != null;\n+    }\n+\n+    return false;\n+  }\n+\n+  private String getMetacardId(String resultId, QueryResponse response) {\n+    if (StringUtils.isNotBlank(mappedMetacardIdField)) {\n+      Optional<SolrDocument> document = getResponseDocument(resultId, response);\n+      if (document.isPresent()) {\n+        Object val = document.get().getFirstValue(mappedMetacardIdField);\n+        if (val != null) {\n+          return val.toString();\n+        }\n+      }\n+    }\n+    return resultId;\n+  }\n+\n+  private Optional<SolrDocument> getResponseDocument(String resultId, QueryResponse response) {\n+    return response\n+        .getResults()\n+        .stream()\n+        .filter(doc -> resultId.equals(doc.getFirstValue(Core.ID + SchemaFields.TEXT_SUFFIX)))\n+        .findFirst();\n+  }\n+\n+  private MetacardType getMetacardType(String resultId, QueryResponse response) {\n+    Optional<SolrDocument> metacard = getResponseDocument(resultId, response);\n+    if (metacard.isPresent()) {\n+      try {\n+        return resolver.getMetacardType(metacard.get());\n+      } catch (MetacardCreationException mce) {\n+        LOGGER.debug(\"Unable to read metacard type\", mce);\n+      }\n+    }\n+    return null;\n+  }\n+\n+  class HighlightContext {", "originalCommit": "e6690b4807466385a0f7220c6974454a61006eb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY1NzI5MQ==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r421657291", "bodyText": "\u2753 Static?", "author": "pklinef", "createdAt": "2020-05-07T17:03:27Z", "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/ResultHighlighter.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.source.solr;\n+\n+import static ddf.catalog.Constants.QUERY_HIGHLIGHT_KEY;\n+import static ddf.catalog.source.solr.DynamicSchemaResolver.FIRST_CHAR_OF_SUFFIX;\n+\n+import com.google.common.collect.Sets;\n+import ddf.catalog.data.MetacardCreationException;\n+import ddf.catalog.data.MetacardType;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.operation.Highlight;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.ResultAttributeHighlight;\n+import ddf.catalog.operation.ResultHighlight;\n+import ddf.catalog.operation.impl.HighlightImpl;\n+import ddf.catalog.operation.impl.ResultAttributeHighlightImpl;\n+import ddf.catalog.operation.impl.ResultHighlightImpl;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang.builder.EqualsBuilder;\n+import org.apache.commons.lang.builder.HashCodeBuilder;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.common.SolrDocument;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ResultHighlighter {\n+\n+  public static final String HIGHLIGHT_ENABLE_PROPERTY = \"solr.highlight.enabled\";\n+\n+  public static final String SOLR_HIGHLIGHT_BLACKLIST = \"solr.highlight.blacklist\";\n+\n+  public static final String SOLR_HIGHLIGHT_SNIPPETS = \"solr.highlight.snippets\";\n+\n+  public static final String SOLR_HIGHLIGHT_KEY = \"hl\";\n+\n+  private static final String HIGHLIGHT_PRE_TAG = \"<em>\";\n+\n+  private static final String HIGHLIGHT_POST_TAG = \"</em>\";\n+\n+  private static final Pattern HIGHLIGHT_PATTERN =\n+      Pattern.compile(\n+          HIGHLIGHT_PRE_TAG + \"(((?!\" + HIGHLIGHT_PRE_TAG + \").)*?)\" + HIGHLIGHT_POST_TAG);\n+\n+  private static final Pattern TAG_PATTERN =\n+      Pattern.compile(\"(\" + HIGHLIGHT_PRE_TAG + \"|\" + HIGHLIGHT_POST_TAG + \")\");\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ResultHighlighter.class);\n+\n+  private final Set<String> highlightBlacklist =\n+      Sets.newHashSet(System.getProperty(SOLR_HIGHLIGHT_BLACKLIST, \"\").split(\"\\\\s*,\\\\s*\"));\n+\n+  private int surroundingContextSize = 20;\n+\n+  private DynamicSchemaResolver resolver;\n+\n+  private String mappedMetacardIdField;\n+\n+  public ResultHighlighter(DynamicSchemaResolver resolver) {\n+    this.resolver = resolver;\n+  }\n+\n+  public void setMappedMetacardIdField(String mappedMetacardIdField) {\n+    this.mappedMetacardIdField = mappedMetacardIdField;\n+  }\n+\n+  public void processPreQuery(QueryRequest request, SolrQuery query) {\n+    if (userHighlightIsOn(request)) {\n+      enableHighlighter(query);\n+    }\n+  }\n+\n+  public void processPostQuery(QueryResponse response, Map<String, Serializable> responseProps) {\n+    extractHighlighting(response, responseProps);\n+  }\n+\n+  private Boolean userHighlightIsOn(QueryRequest request) {\n+    Boolean userHighlight;\n+    if (request.getProperties().get(QUERY_HIGHLIGHT_KEY) != null) {\n+      userHighlight = (Boolean) request.getProperties().get(QUERY_HIGHLIGHT_KEY);\n+    } else {\n+      userHighlight = isSystemHighlightingEnabled();\n+    }\n+    return userHighlight;\n+  }\n+\n+  protected boolean isSystemHighlightingEnabled() {\n+    return BooleanUtils.toBoolean(System.getProperty(HIGHLIGHT_ENABLE_PROPERTY, \"false\"));\n+  }\n+\n+  private String getSnippetSetting() {\n+    return System.getProperty(SOLR_HIGHLIGHT_SNIPPETS, \"20\");\n+  }\n+\n+  protected void enableHighlighter(SolrQuery query) {\n+    query.setParam(SOLR_HIGHLIGHT_KEY, true);\n+    query.setParam(\"hl.fl\", \"*\");\n+    query.setParam(\"hl.requireFieldMatch\", true);\n+    query.setParam(\"hl.method\", \"unified\");\n+    query.setParam(\"hl.preserveMulti\", true);\n+    query.setParam(\"hl.snippets\", getSnippetSetting());\n+  }\n+\n+  protected void extractHighlighting(\n+      QueryResponse response, Map<String, Serializable> responseProps) {\n+    Map<String, Map<String, List<String>>> highlights = response.getHighlighting();\n+    if (highlights == null) {\n+      return;\n+    }\n+    List<ResultHighlight> resultsHighlights = new ArrayList<>();\n+    for (String resultId : highlights.keySet()) {\n+\n+      Map<String, List<String>> fieldHighlight = highlights.get(resultId);\n+      Map<String, Set<Highlight>> consolidated = new HashMap<>();\n+      if (fieldHighlight != null && fieldHighlight.size() > 0) {\n+        for (Map.Entry<String, List<String>> entry : fieldHighlight.entrySet()) {\n+          String solrField = entry.getKey();\n+          String normalizedKey = resolveHighlightFieldName(solrField);\n+          if (isHighlightBlacklisted(normalizedKey)\n+              || isHighlightBlacklisted(solrField)\n+              || !isMetacardAttribute(normalizedKey, resultId, response)) {\n+            continue;\n+          }\n+          Set<Highlight> consolidatedSet = consolidated.get(normalizedKey);\n+          if (consolidatedSet == null) {\n+            consolidatedSet = new HashSet<>();\n+          }\n+          consolidatedSet.addAll(\n+              createHighlights(\n+                  entry.getValue(),\n+                  getAttributeValue(resultId, normalizedKey + SchemaFields.TEXT_SUFFIX, response)));\n+          if (!consolidatedSet.isEmpty()) {\n+            consolidated.put(normalizedKey, consolidatedSet);\n+          }\n+        }\n+      }\n+      if (!consolidated.isEmpty()) {\n+        List<ResultAttributeHighlight> attributeHighlights = new ArrayList<>();\n+        for (Map.Entry<String, Set<Highlight>> fieldEntry : consolidated.entrySet()) {\n+          attributeHighlights.add(\n+              new ResultAttributeHighlightImpl(\n+                  fieldEntry.getKey(), new ArrayList<>(fieldEntry.getValue())));\n+        }\n+\n+        resultsHighlights.add(\n+            new ResultHighlightImpl(getMetacardId(resultId, response), attributeHighlights));\n+      }\n+    }\n+\n+    if (!resultsHighlights.isEmpty()) {\n+      responseProps.put(QUERY_HIGHLIGHT_KEY, (Serializable) resultsHighlights);\n+    }\n+  }\n+\n+  private List<Highlight> createHighlights(\n+      List<String> highlightResults, Collection<Object> baseValues) {\n+    List<Highlight> highlights = new ArrayList<>();\n+    if (baseValues != null && !baseValues.isEmpty()) {\n+      List<HighlightContext> highlightedValues = new ArrayList<>();\n+      highlightResults\n+          .stream()\n+          .forEach(result -> highlightedValues.addAll(getHighlightedValues(result)));\n+\n+      int index = 0;\n+      for (Object value : baseValues) {\n+        if (value != null) {\n+          highlights.addAll(extractHighlights(value.toString(), highlightedValues, index));\n+        }\n+        index++;\n+      }\n+    }\n+    return highlights;\n+  }\n+\n+  private List<Highlight> extractHighlights(\n+      String text, List<HighlightContext> values, int valueIndex) {\n+    List<Highlight> highlights = new ArrayList<>();\n+    TagIndices sourceTagIndices = new TagIndices(text);\n+    for (HighlightContext context : values) {\n+      int index = -1;\n+      int length = context.highlightedToken.length();\n+      HighlightContext source = new HighlightContext();\n+      source.surroundingContext = text;\n+      source.tokenContextOffset = 0;\n+      source.resolveSurroundingContext(false);\n+      do {\n+        index = source.surroundingContext.indexOf(context.surroundingContext, index + 1);\n+        if (index > -1) {\n+          int beginIndex = index + context.tokenContextOffset;\n+          int endIndex = index + context.tokenContextOffset + length;\n+          if (sourceTagIndices.getStartTagIndices().contains(beginIndex) && !context.embeded) {\n+            continue;\n+          }\n+          int sourceHighlightOffset =\n+              sourceTagIndices.countStartBefore(beginIndex) * HIGHLIGHT_PRE_TAG.length()\n+                  + sourceTagIndices.countEndBefore(beginIndex) * HIGHLIGHT_POST_TAG.length();\n+          beginIndex += sourceHighlightOffset;\n+          endIndex += sourceHighlightOffset;\n+          highlights.add(new HighlightImpl(beginIndex, endIndex, valueIndex));\n+        }\n+      } while (index > -1);\n+    }\n+    return highlights;\n+  }\n+\n+  private List<HighlightContext> getHighlightedValues(String highlightedText) {\n+    List<HighlightContext> values = new ArrayList<>();\n+    Matcher matcher = HIGHLIGHT_PATTERN.matcher(highlightedText);\n+    while (matcher.find()) {\n+      String token = matcher.group(1);\n+      HighlightContext context = new HighlightContext();\n+      context.highlightedToken = token;\n+      context.surroundingContext = highlightedText;\n+      context.tokenContextOffset = matcher.start();\n+      context.embeded = isHighlightEmbeded(highlightedText, matcher.start());\n+      context.resolveSurroundingContext(true);\n+      values.add(context);\n+    }\n+\n+    return values;\n+  }\n+\n+  private boolean isHighlightEmbeded(String text, int highlightIndex) {\n+    if (highlightIndex - HIGHLIGHT_PRE_TAG.length() < 0) {\n+      return false;\n+    } else {\n+      return text.substring(highlightIndex - HIGHLIGHT_PRE_TAG.length(), highlightIndex)\n+          .equals(HIGHLIGHT_PRE_TAG);\n+    }\n+  }\n+\n+  private Collection<Object> getAttributeValue(\n+      String resultId, String fieldName, QueryResponse response) {\n+    Optional<SolrDocument> metacard = getResponseDocument(resultId, response);\n+    if (metacard.isPresent()) {\n+      return metacard.get().getFieldValues(fieldName);\n+    }\n+    return null;\n+  }\n+\n+  private String resolveHighlightFieldName(String solrFieldName) {\n+    int firstIndexOfSuffix = solrFieldName.indexOf(FIRST_CHAR_OF_SUFFIX);\n+\n+    if (firstIndexOfSuffix != -1) {\n+      return solrFieldName.substring(0, firstIndexOfSuffix);\n+    }\n+    return solrFieldName;\n+  }\n+\n+  private boolean isHighlightBlacklisted(String fieldName) {\n+    List<String> blacklist =\n+        highlightBlacklist\n+            .stream()\n+            .filter(item -> fieldName.matches(item))\n+            .collect(Collectors.toList());\n+    return !blacklist.isEmpty() || resolver.isPrivateField(fieldName);\n+  }\n+\n+  private boolean isMetacardAttribute(String fieldName, String resultId, QueryResponse response) {\n+    MetacardType type = getMetacardType(resultId, response);\n+    if (type != null) {\n+      return type.getAttributeDescriptor(fieldName) != null;\n+    }\n+\n+    return false;\n+  }\n+\n+  private String getMetacardId(String resultId, QueryResponse response) {\n+    if (StringUtils.isNotBlank(mappedMetacardIdField)) {\n+      Optional<SolrDocument> document = getResponseDocument(resultId, response);\n+      if (document.isPresent()) {\n+        Object val = document.get().getFirstValue(mappedMetacardIdField);\n+        if (val != null) {\n+          return val.toString();\n+        }\n+      }\n+    }\n+    return resultId;\n+  }\n+\n+  private Optional<SolrDocument> getResponseDocument(String resultId, QueryResponse response) {\n+    return response\n+        .getResults()\n+        .stream()\n+        .filter(doc -> resultId.equals(doc.getFirstValue(Core.ID + SchemaFields.TEXT_SUFFIX)))\n+        .findFirst();\n+  }\n+\n+  private MetacardType getMetacardType(String resultId, QueryResponse response) {\n+    Optional<SolrDocument> metacard = getResponseDocument(resultId, response);\n+    if (metacard.isPresent()) {\n+      try {\n+        return resolver.getMetacardType(metacard.get());\n+      } catch (MetacardCreationException mce) {\n+        LOGGER.debug(\"Unable to read metacard type\", mce);\n+      }\n+    }\n+    return null;\n+  }\n+\n+  class HighlightContext {\n+    String highlightedToken;\n+    String surroundingContext;\n+    int tokenContextOffset;\n+    boolean embeded = false;\n+\n+    public void resolveSurroundingContext(boolean trimContext) {\n+      int index = -1;\n+      int adjustment = 0;\n+      do {\n+        index = surroundingContext.indexOf(HIGHLIGHT_PRE_TAG, index + 1);\n+        if (index != -1 && index < tokenContextOffset) {\n+          adjustment += HIGHLIGHT_PRE_TAG.length();\n+        }\n+      } while (index > -1);\n+\n+      do {\n+        index = surroundingContext.indexOf(HIGHLIGHT_POST_TAG, index + 1);\n+        if (index != -1 && index < tokenContextOffset) {\n+          adjustment += HIGHLIGHT_POST_TAG.length();\n+        }\n+      } while (index > -1);\n+      tokenContextOffset -= adjustment;\n+      surroundingContext = surroundingContext.replaceAll(HIGHLIGHT_PRE_TAG, \"\");\n+      surroundingContext = surroundingContext.replaceAll(HIGHLIGHT_POST_TAG, \"\");\n+\n+      if (trimContext) {\n+        if (surroundingContext.length() > surroundingContextSize * 2) {\n+          int trimStart = Math.max(0, tokenContextOffset - surroundingContextSize);\n+          int trimEnd =\n+              Math.min(surroundingContext.length(), tokenContextOffset + surroundingContextSize);\n+          surroundingContext = surroundingContext.substring(trimStart, trimEnd);\n+          tokenContextOffset -= trimStart;\n+        }\n+      }\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return new HashCodeBuilder(25, 49)\n+          .append(highlightedToken)\n+          .append(surroundingContext)\n+          .append(tokenContextOffset)\n+          .toHashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (this == o) {\n+        return true;\n+      }\n+\n+      if (o == null || getClass() != o.getClass()) {\n+        return false;\n+      }\n+\n+      HighlightContext context = (HighlightContext) o;\n+\n+      return new EqualsBuilder()\n+          .append(highlightedToken, context.highlightedToken)\n+          .append(surroundingContext, context.surroundingContext)\n+          .append(tokenContextOffset, context.tokenContextOffset)\n+          .isEquals();\n+    }\n+  }\n+\n+  class TagIndices {", "originalCommit": "e6690b4807466385a0f7220c6974454a61006eb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY1ODQ5Mw==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r421658493", "bodyText": "\u270f\ufe0f Could make unmodifiable to protect against accidental modification.", "author": "pklinef", "createdAt": "2020-05-07T17:05:30Z", "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/ResultHighlighter.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.source.solr;\n+\n+import static ddf.catalog.Constants.QUERY_HIGHLIGHT_KEY;\n+import static ddf.catalog.source.solr.DynamicSchemaResolver.FIRST_CHAR_OF_SUFFIX;\n+\n+import com.google.common.collect.Sets;\n+import ddf.catalog.data.MetacardCreationException;\n+import ddf.catalog.data.MetacardType;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.operation.Highlight;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.ResultAttributeHighlight;\n+import ddf.catalog.operation.ResultHighlight;\n+import ddf.catalog.operation.impl.HighlightImpl;\n+import ddf.catalog.operation.impl.ResultAttributeHighlightImpl;\n+import ddf.catalog.operation.impl.ResultHighlightImpl;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang.builder.EqualsBuilder;\n+import org.apache.commons.lang.builder.HashCodeBuilder;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.common.SolrDocument;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ResultHighlighter {\n+\n+  public static final String HIGHLIGHT_ENABLE_PROPERTY = \"solr.highlight.enabled\";\n+\n+  public static final String SOLR_HIGHLIGHT_BLACKLIST = \"solr.highlight.blacklist\";\n+\n+  public static final String SOLR_HIGHLIGHT_SNIPPETS = \"solr.highlight.snippets\";\n+\n+  public static final String SOLR_HIGHLIGHT_KEY = \"hl\";\n+\n+  private static final String HIGHLIGHT_PRE_TAG = \"<em>\";\n+\n+  private static final String HIGHLIGHT_POST_TAG = \"</em>\";\n+\n+  private static final Pattern HIGHLIGHT_PATTERN =\n+      Pattern.compile(\n+          HIGHLIGHT_PRE_TAG + \"(((?!\" + HIGHLIGHT_PRE_TAG + \").)*?)\" + HIGHLIGHT_POST_TAG);\n+\n+  private static final Pattern TAG_PATTERN =\n+      Pattern.compile(\"(\" + HIGHLIGHT_PRE_TAG + \"|\" + HIGHLIGHT_POST_TAG + \")\");\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ResultHighlighter.class);\n+\n+  private final Set<String> highlightBlacklist =\n+      Sets.newHashSet(System.getProperty(SOLR_HIGHLIGHT_BLACKLIST, \"\").split(\"\\\\s*,\\\\s*\"));", "originalCommit": "e6690b4807466385a0f7220c6974454a61006eb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY1ODc5Nw==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r421658797", "bodyText": "\u270f\ufe0f Make final?", "author": "pklinef", "createdAt": "2020-05-07T17:05:59Z", "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/ResultHighlighter.java", "diffHunk": "@@ -0,0 +1,428 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package ddf.catalog.source.solr;\n+\n+import static ddf.catalog.Constants.QUERY_HIGHLIGHT_KEY;\n+import static ddf.catalog.source.solr.DynamicSchemaResolver.FIRST_CHAR_OF_SUFFIX;\n+\n+import com.google.common.collect.Sets;\n+import ddf.catalog.data.MetacardCreationException;\n+import ddf.catalog.data.MetacardType;\n+import ddf.catalog.data.types.Core;\n+import ddf.catalog.operation.Highlight;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.ResultAttributeHighlight;\n+import ddf.catalog.operation.ResultHighlight;\n+import ddf.catalog.operation.impl.HighlightImpl;\n+import ddf.catalog.operation.impl.ResultAttributeHighlightImpl;\n+import ddf.catalog.operation.impl.ResultHighlightImpl;\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+import org.apache.commons.lang.builder.EqualsBuilder;\n+import org.apache.commons.lang.builder.HashCodeBuilder;\n+import org.apache.commons.lang3.BooleanUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.solr.client.solrj.SolrQuery;\n+import org.apache.solr.client.solrj.response.QueryResponse;\n+import org.apache.solr.common.SolrDocument;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class ResultHighlighter {\n+\n+  public static final String HIGHLIGHT_ENABLE_PROPERTY = \"solr.highlight.enabled\";\n+\n+  public static final String SOLR_HIGHLIGHT_BLACKLIST = \"solr.highlight.blacklist\";\n+\n+  public static final String SOLR_HIGHLIGHT_SNIPPETS = \"solr.highlight.snippets\";\n+\n+  public static final String SOLR_HIGHLIGHT_KEY = \"hl\";\n+\n+  private static final String HIGHLIGHT_PRE_TAG = \"<em>\";\n+\n+  private static final String HIGHLIGHT_POST_TAG = \"</em>\";\n+\n+  private static final Pattern HIGHLIGHT_PATTERN =\n+      Pattern.compile(\n+          HIGHLIGHT_PRE_TAG + \"(((?!\" + HIGHLIGHT_PRE_TAG + \").)*?)\" + HIGHLIGHT_POST_TAG);\n+\n+  private static final Pattern TAG_PATTERN =\n+      Pattern.compile(\"(\" + HIGHLIGHT_PRE_TAG + \"|\" + HIGHLIGHT_POST_TAG + \")\");\n+\n+  private static final Logger LOGGER = LoggerFactory.getLogger(ResultHighlighter.class);\n+\n+  private final Set<String> highlightBlacklist =\n+      Sets.newHashSet(System.getProperty(SOLR_HIGHLIGHT_BLACKLIST, \"\").split(\"\\\\s*,\\\\s*\"));\n+\n+  private int surroundingContextSize = 20;", "originalCommit": "e6690b4807466385a0f7220c6974454a61006eb6", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY1OTYxNQ==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r421659615", "bodyText": "\u270f\ufe0f I would suggest adding a unit test for XML fields and highlighting since we strip XML tags for the value that is indexed.", "author": "pklinef", "createdAt": "2020-05-07T17:07:28Z", "path": "catalog/core/catalog-core-solr/src/test/java/ddf/catalog/source/solr/SolrMetacardClientImplTest.java", "diffHunk": "@@ -204,14 +214,92 @@ public void testQuerySpellCheckOn() throws Exception {\n     verify(queryResponse, times(2)).getResults();\n   }\n \n+  @Test\n+  public void testHighlightOn() throws Exception {", "originalCommit": "e6690b4807466385a0f7220c6974454a61006eb6", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY2MjE0MQ==", "url": "https://github.com/codice/ddf/pull/6009#discussion_r421662141", "bodyText": "@vinamartin Did you test highlights on the metadata field by chance during your retest?", "author": "pklinef", "createdAt": "2020-05-07T17:11:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyMTY1OTYxNQ=="}], "type": "inlineReview"}, {"oid": "711a02da97eb5c4d4dfb80e2b8791a9a0d89bcb6", "url": "https://github.com/codice/ddf/commit/711a02da97eb5c4d4dfb80e2b8791a9a0d89bcb6", "message": "make inner classes static", "committedDate": "2020-05-07T17:35:31Z", "type": "commit"}]}