{"pr_number": 5941, "pr_title": "[2.20.x] DDF-5940 - Add anyText expansion whitelist / blacklist capability", "pr_createdAt": "2020-03-25T20:58:35Z", "pr_url": "https://github.com/codice/ddf/pull/5941", "timeline": [{"oid": "8c1c31408ec70029338ee84b6a3092292ede8884", "url": "https://github.com/codice/ddf/commit/8c1c31408ec70029338ee84b6a3092292ede8884", "message": "Add anyText expansion whitelist and blacklist", "committedDate": "2020-03-25T14:31:45Z", "type": "commit"}, {"oid": "aadd3a0e9b31d02d16535ee0b62fd58d8d1b5ab7", "url": "https://github.com/codice/ddf/commit/aadd3a0e9b31d02d16535ee0b62fd58d8d1b5ab7", "message": "Add whitelist/blacklist configuration to cache", "committedDate": "2020-03-25T19:37:38Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE3ODA3Mw==", "url": "https://github.com/codice/ddf/pull/5941#discussion_r398178073", "bodyText": "I would suggest updating this to allow a blacklist and a whitelist at the same time.  A common strategy for this is have the whitelist take precedence.  Then admins could filter out entire namespaces while letting a few parts of the namespace through the filter.\n\n  \n    \n      \n        Suggested change\n        \n          \n    \n\n        \n      \n    \n    \n      \n          \n            \n              private void filterAnyTextFieldCache() {\n          \n          \n            \n                Set<String> filteredList = new HashSet<>();\n          \n          \n            \n            \n          \n          \n            \n                ConfigurationStore config = ConfigurationStore.getInstance();\n          \n          \n            \n                List<String> anyTextFieldWhitelist = config.getAnyTextFieldWhitelist();\n          \n          \n            \n                List<String> anyTextFieldBlacklist = config.getAnyTextFieldBlacklist();\n          \n          \n            \n                if (!anyTextFieldWhitelist.isEmpty()) {\n          \n          \n            \n                  for (String whitelistField : anyTextFieldWhitelist) {\n          \n          \n            \n                    String whitelist;\n          \n          \n            \n                    if (!whitelistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n          \n          \n            \n                      whitelist = whitelistField + SchemaFields.TEXT_SUFFIX;\n          \n          \n            \n                    } else {\n          \n          \n            \n                      whitelist = whitelistField;\n          \n          \n            \n                    }\n          \n          \n            \n                    filteredList.addAll(\n          \n          \n            \n                        anyTextFieldsCache\n          \n          \n            \n                            .stream()\n          \n          \n            \n                            .filter(field -> field.matches(whitelist))\n          \n          \n            \n                            .collect(Collectors.toList()));\n          \n          \n            \n                  }\n          \n          \n            \n                } else if (!anyTextFieldBlacklist.isEmpty()) {\n          \n          \n            \n                  filteredList.addAll(anyTextFieldsCache);\n          \n          \n            \n                  for (String blacklistField : anyTextFieldBlacklist) {\n          \n          \n            \n                    String blacklist;\n          \n          \n            \n                    if (!blacklistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n          \n          \n            \n                      blacklist = blacklistField + SchemaFields.TEXT_SUFFIX;\n          \n          \n            \n                    } else {\n          \n          \n            \n                      blacklist = blacklistField;\n          \n          \n            \n                    }\n          \n          \n            \n                    filteredList.removeAll(\n          \n          \n            \n                        anyTextFieldsCache\n          \n          \n            \n                            .stream()\n          \n          \n            \n                            .filter(field -> field.matches(blacklist))\n          \n          \n            \n                            .collect(Collectors.toList()));\n          \n          \n            \n                  }\n          \n          \n            \n                } else {\n          \n          \n            \n                  filteredList.addAll(anyTextFieldsCache);\n          \n          \n            \n                }\n          \n          \n            \n              private void filterAnyTextFieldCache() {\n          \n          \n            \n                Set<String> filteredList = new HashSet<>();\n          \n          \n            \n            \n          \n          \n            \n                ConfigurationStore config = ConfigurationStore.getInstance();\n          \n          \n            \n                List<String> anyTextFieldWhitelist = config.getAnyTextFieldWhitelist();\n          \n          \n            \n                List<String> anyTextFieldBlacklist = config.getAnyTextFieldBlacklist();\n          \n          \n            \n                \n          \n          \n            \n                if (!anyTextFieldBlacklist.isEmpty()) {\n          \n          \n            \n                  filteredList.addAll(anyTextFieldsCache);\n          \n          \n            \n                  for (String blacklistField : anyTextFieldBlacklist) {\n          \n          \n            \n                    String blacklist;\n          \n          \n            \n                    if (!blacklistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n          \n          \n            \n                      blacklist = blacklistField + SchemaFields.TEXT_SUFFIX;\n          \n          \n            \n                    } else {\n          \n          \n            \n                      blacklist = blacklistField;\n          \n          \n            \n                    }\n          \n          \n            \n                    filteredList.removeAll(\n          \n          \n            \n                        anyTextFieldsCache\n          \n          \n            \n                            .stream()\n          \n          \n            \n                            .filter(field -> field.matches(blacklist))\n          \n          \n            \n                            .collect(Collectors.toList()));\n          \n          \n            \n                  }\n          \n          \n            \n                } \n          \n          \n            \n                if (!anyTextFieldWhitelist.isEmpty()) {\n          \n          \n            \n                  for (String whitelistField : anyTextFieldWhitelist) {\n          \n          \n            \n                    String whitelist;\n          \n          \n            \n                    if (!whitelistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n          \n          \n            \n                      whitelist = whitelistField + SchemaFields.TEXT_SUFFIX;\n          \n          \n            \n                    } else {\n          \n          \n            \n                      whitelist = whitelistField;\n          \n          \n            \n                    }\n          \n          \n            \n                    filteredList.addAll(\n          \n          \n            \n                        anyTextFieldsCache\n          \n          \n            \n                            .stream()\n          \n          \n            \n                            .filter(field -> field.matches(whitelist))\n          \n          \n            \n                            .collect(Collectors.toList()));\n          \n          \n            \n                  }\n          \n          \n            \n                } \n          \n          \n            \n                \n          \n          \n            \n                if (anyTextFieldWhitelist.isEmpty() && anyTextFieldBlacklist.isEmpty()) {\n          \n          \n            \n                  filteredList.addAll(anyTextFieldsCache);\n          \n          \n            \n                }", "author": "andrewkfiedler", "createdAt": "2020-03-25T21:22:36Z", "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/ConfigurationStore.java", "diffHunk": "@@ -83,4 +96,123 @@ public void setInMemory(boolean isInMemory) {\n   public void setForceAutoCommit(boolean forceAutoCommit) {\n     this.forceAutoCommit = forceAutoCommit;\n   }\n+\n+  public void setAnyTextFieldWhitelist(List<String> fieldWhitelist) {\n+    this.anyTextFieldWhitelist.clear();\n+    if (fieldWhitelist != null) {\n+      this.anyTextFieldWhitelist.addAll(fieldWhitelist);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public List<String> getAnyTextFieldWhitelist() {\n+    return new ArrayList<>(anyTextFieldWhitelist);\n+  }\n+\n+  public void addAnyTextWhitelistField(String whitelistField) {\n+    if (whitelistField != null) {\n+      this.anyTextFieldWhitelist.add(whitelistField);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextWhiteListField(String whitelistField) {\n+    this.anyTextFieldWhitelist.remove(whitelistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void setAnyTextFieldBlacklist(List<String> fieldBlacklist) {\n+    this.anyTextFieldBlacklist.clear();\n+    if (fieldBlacklist != null) {\n+      this.anyTextFieldBlacklist.addAll(fieldBlacklist);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public List<String> getAnyTextFieldBlacklist() {\n+    return new ArrayList<>(anyTextFieldBlacklist);\n+  }\n+\n+  public void addAnyTextBlacklistField(String blacklistField) {\n+    this.anyTextFieldBlacklist.add(blacklistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextBlacklistField(String blacklistField) {\n+    this.anyTextFieldBlacklist.remove(blacklistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void addAnyTextField(String anyTextField) {\n+    anyTextFieldsCache.add(anyTextField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextField(String anyTextField) {\n+    anyTextFieldsCache.remove(anyTextField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void clearAnyTextFieldCache() {\n+    anyTextFieldsCache.clear();\n+    filteredAnyTextFieldsCache.clear();\n+  }\n+\n+  public Set<String> getAnyTextFieldsCache() {\n+    return anyTextFieldsCache;\n+  }\n+\n+  public Set<String> getFilteredAnyTextFields() {\n+    return filteredAnyTextFieldsCache;\n+  }\n+\n+  private void filterAnyTextFieldCache() {\n+    Set<String> filteredList = new HashSet<>();\n+\n+    ConfigurationStore config = ConfigurationStore.getInstance();\n+    List<String> anyTextFieldWhitelist = config.getAnyTextFieldWhitelist();\n+    List<String> anyTextFieldBlacklist = config.getAnyTextFieldBlacklist();\n+    if (!anyTextFieldWhitelist.isEmpty()) {\n+      for (String whitelistField : anyTextFieldWhitelist) {\n+        String whitelist;\n+        if (!whitelistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n+          whitelist = whitelistField + SchemaFields.TEXT_SUFFIX;\n+        } else {\n+          whitelist = whitelistField;\n+        }\n+        filteredList.addAll(\n+            anyTextFieldsCache\n+                .stream()\n+                .filter(field -> field.matches(whitelist))\n+                .collect(Collectors.toList()));\n+      }\n+    } else if (!anyTextFieldBlacklist.isEmpty()) {\n+      filteredList.addAll(anyTextFieldsCache);\n+      for (String blacklistField : anyTextFieldBlacklist) {\n+        String blacklist;\n+        if (!blacklistField.endsWith(SchemaFields.TEXT_SUFFIX)) {\n+          blacklist = blacklistField + SchemaFields.TEXT_SUFFIX;\n+        } else {\n+          blacklist = blacklistField;\n+        }\n+        filteredList.removeAll(\n+            anyTextFieldsCache\n+                .stream()\n+                .filter(field -> field.matches(blacklist))\n+                .collect(Collectors.toList()));\n+      }\n+    } else {\n+      filteredList.addAll(anyTextFieldsCache);\n+    }", "originalCommit": "aadd3a0e9b31d02d16535ee0b62fd58d8d1b5ab7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODIxODE2Mw==", "url": "https://github.com/codice/ddf/pull/5941#discussion_r398218163", "bodyText": "Your solution would allow non-whitelisted fields to be added to the anyText expansion since it starts with the full list, removes any blacklisted items, and then re-adds any whitelisted items.   That is really an implementation of a blacklist exception.  Wouldn't that be confusing to an admin where they provide a whitelist but still see non-whitelisted fields as part of the queries?", "author": "derekwilhelm", "createdAt": "2020-03-25T22:50:10Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE3ODA3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODIyNjk2Mw==", "url": "https://github.com/codice/ddf/pull/5941#discussion_r398226963", "bodyText": "Yeah, that's the intention in my solution.  You start with the full list, blacklist things, then add things there are exceptions for.\nI don't think it's confusing, it's a common pattern when both a blacklist and a whitelist are allowed.\nI would argue the current behavior is confusing, since we allow both a blacklist and a whitelist to be defined (with no warnings), and then ultimately only use the whitelist.", "author": "andrewkfiedler", "createdAt": "2020-03-25T23:14:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE3ODA3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODIzMzY0MQ==", "url": "https://github.com/codice/ddf/pull/5941#discussion_r398233641", "bodyText": "If metatypes would allow me to force selecting only one of the lists at a time I would have done it for clarity.  I get your point.  Regardless of solution, it needs to identify to the user what the behavior is.  I will update it to allow both and add a comment to the whitelist description that will indicate it becomes a blacklist exception if both lists are provided instead of a pure whitelist.", "author": "derekwilhelm", "createdAt": "2020-03-25T23:34:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE3ODA3Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODI1NDcyNw==", "url": "https://github.com/codice/ddf/pull/5941#discussion_r398254727", "bodyText": "Sounds good.\nI feel you on the metatypes, they feel like crude tools when it comes to the reality of configurations.\nI might take a bit of time after we merge this into master to see if we can offer a special view in the new Admin UI for this configuration, might help ease the burden on admins.  I've been meaning to see if we can make a simple pattern for replacing the default configuration views.", "author": "andrewkfiedler", "createdAt": "2020-03-26T00:44:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODE3ODA3Mw=="}], "type": "inlineReview"}, {"oid": "e0281f9c3e17201dfa9a40fb245a2df45489d761", "url": "https://github.com/codice/ddf/commit/e0281f9c3e17201dfa9a40fb245a2df45489d761", "message": "Allow both blacklist and whitelist at the same time", "committedDate": "2020-03-25T23:57:56Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2MjMxMg==", "url": "https://github.com/codice/ddf/pull/5941#discussion_r398662312", "bodyText": "\u270f\ufe0f Ideally this ConfigurationStore would only have configuration as its responsibility.  I would recommend extracting the anyText field cache related fields, methods, and logic to a new class.", "author": "pklinef", "createdAt": "2020-03-26T15:26:31Z", "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/ConfigurationStore.java", "diffHunk": "@@ -83,4 +96,127 @@ public void setInMemory(boolean isInMemory) {\n   public void setForceAutoCommit(boolean forceAutoCommit) {\n     this.forceAutoCommit = forceAutoCommit;\n   }\n+\n+  public void setAnyTextFieldWhitelist(List<String> fieldWhitelist) {\n+    this.anyTextFieldWhitelist.clear();\n+    if (fieldWhitelist != null) {\n+      this.anyTextFieldWhitelist.addAll(fieldWhitelist);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public List<String> getAnyTextFieldWhitelist() {\n+    return new ArrayList<>(anyTextFieldWhitelist);\n+  }\n+\n+  public void addAnyTextWhitelistField(String whitelistField) {\n+    if (whitelistField != null) {\n+      this.anyTextFieldWhitelist.add(whitelistField);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextWhiteListField(String whitelistField) {\n+    this.anyTextFieldWhitelist.remove(whitelistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void setAnyTextFieldBlacklist(List<String> fieldBlacklist) {\n+    this.anyTextFieldBlacklist.clear();\n+    if (fieldBlacklist != null) {\n+      this.anyTextFieldBlacklist.addAll(fieldBlacklist);\n+    }\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public List<String> getAnyTextFieldBlacklist() {\n+    return new ArrayList<>(anyTextFieldBlacklist);\n+  }\n+\n+  public void addAnyTextBlacklistField(String blacklistField) {\n+    this.anyTextFieldBlacklist.add(blacklistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextBlacklistField(String blacklistField) {\n+    this.anyTextFieldBlacklist.remove(blacklistField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void addAnyTextField(String anyTextField) {\n+    anyTextFieldsCache.add(anyTextField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void removeAnyTextField(String anyTextField) {\n+    anyTextFieldsCache.remove(anyTextField);\n+\n+    filterAnyTextFieldCache();\n+  }\n+\n+  public void clearAnyTextFieldCache() {\n+    anyTextFieldsCache.clear();\n+    filteredAnyTextFieldsCache.clear();\n+  }\n+\n+  public Set<String> getAnyTextFieldsCache() {\n+    return anyTextFieldsCache;\n+  }\n+\n+  public Set<String> getFilteredAnyTextFields() {\n+    return filteredAnyTextFieldsCache;\n+  }\n+\n+  private void filterAnyTextFieldCache() {", "originalCommit": "e0281f9c3e17201dfa9a40fb245a2df45489d761", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODc3MDYwNQ==", "url": "https://github.com/codice/ddf/pull/5941#discussion_r398770605", "bodyText": "I would be good with this being fixed on the master branch.", "author": "pklinef", "createdAt": "2020-03-26T17:47:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5ODY2MjMxMg=="}], "type": "inlineReview"}, {"oid": "eaac250421ab15c6053104765b01b9f9bbc27281", "url": "https://github.com/codice/ddf/commit/eaac250421ab15c6053104765b01b9f9bbc27281", "message": "Update unit tests", "committedDate": "2020-03-26T16:40:14Z", "type": "commit"}]}