{"pr_number": 5997, "pr_title": "DDF-5802 Refactor to enable for split catalog", "pr_createdAt": "2020-04-16T14:03:36Z", "pr_url": "https://github.com/codice/ddf/pull/5997", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYzMDI3Mw==", "url": "https://github.com/codice/ddf/pull/5997#discussion_r409630273", "bodyText": "I think this is used downstream, is it necessary to remove?", "author": "bdeining", "createdAt": "2020-04-16T15:04:15Z", "path": "distribution/test/itests/test-itests-common/src/main/java/org/codice/ddf/itests/common/AbstractIntegrationTest.java", "diffHunk": "@@ -329,9 +326,6 @@ public String toString() {\n   public static final DynamicUrl SERVICE_ROOT =\n       new DynamicUrl(SECURE_ROOT, HTTPS_PORT, \"/services\");\n \n-  public static final DynamicUrl INSECURE_SERVICE_ROOT =", "originalCommit": "c296e9b5f5864410e5efcc770fe88e791d538a11", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTY1NzcxNA==", "url": "https://github.com/codice/ddf/pull/5997#discussion_r409657714", "bodyText": "if it is used downstream, should that variable be added to the extended class rather? i did a quick search and don't see its usage tho.", "author": "lamhuy", "createdAt": "2020-04-16T15:41:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwOTYzMDI3Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY3NDUyOA==", "url": "https://github.com/codice/ddf/pull/5997#discussion_r411674528", "bodyText": "\u2753 Do you need this method? The gazetteer in blueprint has update-strategy=\"container-managed\" which IIRC means only the setter gets invoked. If you had used component-managed then you would need both.", "author": "Lambeaux", "createdAt": "2020-04-20T20:36:23Z", "path": "catalog/spatial/geocoding/spatial-geocoding-offline-catalog/src/main/java/org/codice/ddf/spatial/geocoding/query/GazetteerQueryCatalog.java", "diffHunk": "@@ -358,4 +387,16 @@ private NearbyLocation transformMetacardToNearbyLocation(String location, Metaca\n     }\n     return Optional.empty();\n   }\n+\n+  public void refresh(Map<String, Object> properties) {", "originalCommit": "8db3c275eade0c7ede8154b5e85eab936cc9259a", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY5NjUyMQ==", "url": "https://github.com/codice/ddf/pull/5997#discussion_r411696521", "bodyText": "\u2753 Per my knowledge of Elasticsearch, an alias is just an alternate name you can use to refer to an index or group of indices in a REST request, but the database itself owns the alias definition as part of configuration. It seems Solr works in a similar fashion:\nhttps://lucene.apache.org/solr/guide/8_1/aliases.html\nThis is a lot more manageable than before, so I'm good with it \ud83d\udc4d but I'm still curious about the necessity for having our Solr client manage Alias creation. Can we not assume that we deployed Solr / Zookeeper with the correct configuration up front? Can we not simply reboot the system or refresh bundles between configuration updates?", "author": "Lambeaux", "createdAt": "2020-04-20T21:14:08Z", "path": "platform/solr/solr-factory-impl/src/main/java/org/codice/solr/factory/impl/SolrCloudClientFactory.java", "diffHunk": "@@ -64,47 +68,157 @@\n   private final int maximumShardsPerNode =\n       NumberUtils.toInt(System.getProperty(\"solr.cloud.maxShardPerNode\"), 2);\n \n+  private static final String ALIAS_PROP = \"alias\";\n+\n   @Override\n   public org.codice.solr.client.solrj.SolrClient newClient(String core) {\n+    return newClient(core, null);\n+  }\n+\n+  @Override\n+  public org.codice.solr.client.solrj.SolrClient newClient(\n+      String collection, Map<String, Object> properties) {\n+\n     String zookeeperHosts = System.getProperty(\"solr.cloud.zookeeper\");\n+    checkConfig(zookeeperHosts);\n \n-    if (StringUtils.isBlank(zookeeperHosts)) {\n-      LOGGER.warn(\n-          \"Cannot create SolrCloud client without Zookeeper host list system property [solr.cloud.zookeeper] being set.\");\n-      throw new IllegalStateException(\"system property 'solr.cloud.zookeeper' is not configured\");\n-    }\n     LOGGER.debug(\n-        \"Solr({}): Creating a SolrCloud client using Zookeeper hosts [{}]\", core, zookeeperHosts);\n+        \"Solr({}): Creating a Solr Cloud client with configuration using Zookeeper hosts [{}]\",\n+        collection,\n+        zookeeperHosts);\n+\n+    String alias = properties == null ? null : (String) properties.getOrDefault(ALIAS_PROP, null);\n+\n     return new SolrClientAdapter(\n-        core,\n+        collection,\n         () ->\n             AccessController.doPrivileged(\n                 (PrivilegedAction<SolrClient>)\n                     () -> {\n-                      return createSolrCloudClient(zookeeperHosts, core);\n+                      return createSolrCloudClient(zookeeperHosts, collection, alias);\n                     }));\n   }\n \n   @VisibleForTesting\n-  SolrClient createSolrCloudClient(String zookeeperHosts, String collection) {\n+  void addCollectionToAlias(String alias, String collection, CloudSolrClient client) {\n+    if (StringUtils.isBlank(alias) || StringUtils.isBlank(collection)) {\n+      return;\n+    }\n+    try {\n+      List<String> aliasedCollections = getCollectionsInAlias(client, alias);\n+      if (!aliasedCollections.contains(collection)) {\n+        List<String> collections = new ArrayList<>();\n+        collections.addAll(aliasedCollections);\n+        collections.add(collection);\n+        collections.addAll(getCollectionsNotInAlias(client, aliasedCollections, alias));\n+        createAlias(client, collections, alias);\n+      }\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.warn(\"Failed to update alias [{}]\", alias, e);\n+    }\n+  }\n+\n+  private List<String> getCollectionsInAlias(CloudSolrClient client, String alias)\n+      throws SolrServerException, IOException {\n+    CollectionAdminResponse aliasResponse =\n+        new CollectionAdminRequest.ListAliases().process(client);\n+\n+    if (aliasResponse != null) {\n+      Map<String, String> aliases = aliasResponse.getAliases();\n+      if (aliases != null && aliases.containsKey(alias)) {\n+        String[] collections = aliases.get(alias).split(\",\");\n+        return Arrays.asList(collections);\n+      }\n+    }\n+    return Collections.emptyList();\n+  }\n+\n+  /**\n+   * Find existing collections in case parallel operations are creating collections\n+   *\n+   * @param client\n+   * @param currentAliases\n+   * @param alias\n+   * @return\n+   * @throws SolrServerException\n+   * @throws IOException\n+   */\n+  private List<String> getCollectionsNotInAlias(\n+      CloudSolrClient client, List<String> currentAliases, String alias)\n+      throws SolrServerException, IOException {\n+    if (StringUtils.isNotBlank(alias)) {\n+      CollectionAdminResponse response = new CollectionAdminRequest.List().process(client);\n+      if (response.getResponse() != null) {\n+        List<String> collections = (List<String>) response.getResponse().get(\"collections\");\n+        return collections == null\n+            ? Collections.emptyList()\n+            : collections\n+                .stream()\n+                .filter(c -> c.startsWith(alias))\n+                .filter(c -> currentAliases.contains(c))\n+                .collect(Collectors.toList());\n+      }\n+    }\n+    return Collections.emptyList();\n+  }\n+\n+  private void createAlias(CloudSolrClient client, List<String> collections, String alias) {", "originalCommit": "8db3c275eade0c7ede8154b5e85eab936cc9259a", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjE4NzU4OQ==", "url": "https://github.com/codice/ddf/pull/5997#discussion_r412187589", "bodyText": "Your observation is correct. DDF does bear the responsibly to setup solr if it is not configured. But if Solr is already configured, by either manually or by previous DDF run, then the current or updated configuration won't have any impact.", "author": "lamhuy", "createdAt": "2020-04-21T13:32:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMTY5NjUyMQ=="}], "type": "inlineReview"}, {"oid": "c1d753cee33eea3aaaf68c83195d513f213ac639", "url": "https://github.com/codice/ddf/commit/c1d753cee33eea3aaaf68c83195d513f213ac639", "message": "DDF-5802 Refactor to enable DDF-5802", "committedDate": "2020-04-21T18:42:00Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMjQxNzkzOA==", "url": "https://github.com/codice/ddf/pull/5997#discussion_r412417938", "bodyText": "\u270f\ufe0f Add JavaDoc.  You can reference the existing method.", "author": "pklinef", "createdAt": "2020-04-21T19:06:29Z", "path": "platform/solr/solr-factory/src/main/java/org/codice/solr/factory/SolrClientFactory.java", "diffHunk": "@@ -30,5 +31,7 @@\n    * @return the newly created {@code SolrClient}\n    * @throws IllegalArgumentException if <code>core</code> is <code>null</code>\n    */\n-  public SolrClient newClient(String core);\n+  SolrClient newClient(String core);\n+\n+  SolrClient newClient(String collection, Map<String, Object> properties);", "originalCommit": "c14dbada9653d81529d033d8c2e2e845a3fb7ce3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "e5f3571c247d985ab230d91a8d3fb73cb18e4ea6", "url": "https://github.com/codice/ddf/commit/e5f3571c247d985ab230d91a8d3fb73cb18e4ea6", "message": "DDF-5802 Refactor to enable DDF-5802", "committedDate": "2020-04-21T19:18:55Z", "type": "forcePushed"}, {"oid": "d722e54261ec93909a983e315e64f4cd42761ba4", "url": "https://github.com/codice/ddf/commit/d722e54261ec93909a983e315e64f4cd42761ba4", "message": "DDF-5802 Refactor to enable DDF-5802", "committedDate": "2020-04-21T19:25:05Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI3MzE1Mg==", "url": "https://github.com/codice/ddf/pull/5997#discussion_r413273152", "bodyText": "\u270f\ufe0f if we are sure this will not be null you should be able to do if (doRealTimeGet) { since it will be autoboxed. Or if we worked with boolean primitive instead we wouldn't have to worry about the nullness at all.", "author": "rzwiefel", "createdAt": "2020-04-22T19:46:49Z", "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/SolrMetacardClientImpl.java", "diffHunk": "@@ -168,15 +171,66 @@ public SourceResponse query(QueryRequest request) throws UnsupportedQueryExcepti\n       return new QueryResponseImpl(request, new ArrayList<>(), true, 0L);\n     }\n \n+    long totalHits = 0;\n+    Map<String, Serializable> responseProps = new HashMap<>();\n+    List<Result> results = new ArrayList<>();\n+\n     SolrFilterDelegate solrFilterDelegate =\n         filterDelegateFactory.newInstance(resolver, request.getProperties());\n     SolrQuery query = getSolrQuery(request, solrFilterDelegate);\n \n-    Map<String, Serializable> responseProps = new HashMap<>();\n+    boolean isFacetedQuery = handleFacetRequest(query, request);\n+    query = handleSuggestionQuery(query, request);\n+    boolean userSpellcheckIsOn = userSpellcheckIsOn(request);\n+\n+    try {\n+      QueryResponse solrResponse;\n+      Boolean doRealTimeGet =\n+          (Boolean) request.getProperties().getOrDefault(DO_REALTIME_GET, false)\n+              || filterAdapter.adapt(request.getQuery(), new RealTimeGetDelegate());\n+\n+      if (BooleanUtils.isTrue(doRealTimeGet)) {", "originalCommit": "d722e54261ec93909a983e315e64f4cd42761ba4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI3NDYwNQ==", "url": "https://github.com/codice/ddf/pull/5997#discussion_r413274605", "bodyText": "\u270f\ufe0f Feels a little odd to pass this boolean into this method to have it do an if on it, we could just do this in the calling method and have one less boolean paramter to pass through", "author": "rzwiefel", "createdAt": "2020-04-22T19:48:39Z", "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/SolrMetacardClientImpl.java", "diffHunk": "@@ -215,92 +272,76 @@ public SourceResponse query(QueryRequest request) throws UnsupportedQueryExcepti\n       }\n     }\n \n-    long totalHits = 0;\n-    List<Result> results = new ArrayList<>();\n-\n-    Boolean userSpellcheckIsOn = userSpellcheckIsOn(request);\n-\n-    try {\n-      QueryResponse solrResponse;\n-      Boolean doRealTimeGet = filterAdapter.adapt(request.getQuery(), new RealTimeGetDelegate());\n+    return query;\n+  }\n \n-      if (doRealTimeGet) {\n-        LOGGER.debug(\"Performing real time query\");\n-        SolrQuery realTimeQuery = getRealTimeQuery(query, solrFilterDelegate.getIds());\n-        solrResponse = client.query(realTimeQuery, METHOD.POST);\n-      } else {\n-        query.setParam(\"spellcheck\", userSpellcheckIsOn);\n-        solrResponse = client.query(query, METHOD.POST);\n+  private void handleFacetResponse(\n+      QueryResponse solrResponse, Map<String, Serializable> responseProps, boolean isFacetedQuery) {\n+    if (isFacetedQuery) {", "originalCommit": "d722e54261ec93909a983e315e64f4cd42761ba4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI4MzE2Ng==", "url": "https://github.com/codice/ddf/pull/5997#discussion_r413283166", "bodyText": "\u270f\ufe0f Just an opinion, this might be a little less busy/complex if we just ensure that geocoderCollection is not null in the setter (by either erroring out if set to null or defaulting back to default value)  and then we wouldn't have to always check if the class field is null on every access.", "author": "rzwiefel", "createdAt": "2020-04-22T19:56:54Z", "path": "catalog/spatial/geocoding/spatial-geocoding-offline-catalog/src/main/java/org/codice/ddf/spatial/geocoding/query/GazetteerQueryCatalog.java", "diffHunk": "@@ -358,4 +387,8 @@ private NearbyLocation transformMetacardToNearbyLocation(String location, Metaca\n     }\n     return Optional.empty();\n   }\n+\n+  public void setGeocoderCollection(String geocoderCollection) {\n+    this.geocoderCollection = geocoderCollection;", "originalCommit": "d722e54261ec93909a983e315e64f4cd42761ba4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI4NTQ0Ng==", "url": "https://github.com/codice/ddf/pull/5997#discussion_r413285446", "bodyText": "\u2753 Is it okay that we're not doing anything with the properties parameter? Could it be deleted if it is not used?", "author": "rzwiefel", "createdAt": "2020-04-22T19:59:42Z", "path": "platform/solr/solr-factory-impl/src/main/java/org/codice/solr/factory/impl/HttpSolrClientFactory.java", "diffHunk": "@@ -139,6 +140,12 @@ private static boolean solrCoreExists(SolrClient client, String coreName)\n     return new SolrClientAdapter(core, () -> createSolrHttpClient(solrUrl, core, coreUrl));\n   }\n \n+  @Override\n+  public org.codice.solr.client.solrj.SolrClient newClient(\n+      String collection, Map<String, Object> properties) {\n+    return newClient(collection);", "originalCommit": "d722e54261ec93909a983e315e64f4cd42761ba4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzgxNTQzMw==", "url": "https://github.com/codice/ddf/pull/5997#discussion_r413815433", "bodyText": "yes, this is the deprecated class anyway. having this method just to satisfy the interface.", "author": "lamhuy", "createdAt": "2020-04-23T13:55:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI4NTQ0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI4ODU0OA==", "url": "https://github.com/codice/ddf/pull/5997#discussion_r413288548", "bodyText": "\u270f\ufe0f Just an opinion, firming up the null contracts with the properties parameter could clean up null checks like this and reduce it down to just the getOrDefault call.", "author": "rzwiefel", "createdAt": "2020-04-22T20:02:59Z", "path": "platform/solr/solr-factory-impl/src/main/java/org/codice/solr/factory/impl/SolrCloudClientFactory.java", "diffHunk": "@@ -64,47 +68,157 @@\n   private final int maximumShardsPerNode =\n       NumberUtils.toInt(System.getProperty(\"solr.cloud.maxShardPerNode\"), 2);\n \n+  private static final String ALIAS_PROP = \"alias\";\n+\n   @Override\n   public org.codice.solr.client.solrj.SolrClient newClient(String core) {\n+    return newClient(core, null);\n+  }\n+\n+  @Override\n+  public org.codice.solr.client.solrj.SolrClient newClient(\n+      String collection, Map<String, Object> properties) {\n+\n     String zookeeperHosts = System.getProperty(\"solr.cloud.zookeeper\");\n+    checkConfig(zookeeperHosts);\n \n-    if (StringUtils.isBlank(zookeeperHosts)) {\n-      LOGGER.warn(\n-          \"Cannot create SolrCloud client without Zookeeper host list system property [solr.cloud.zookeeper] being set.\");\n-      throw new IllegalStateException(\"system property 'solr.cloud.zookeeper' is not configured\");\n-    }\n     LOGGER.debug(\n-        \"Solr({}): Creating a SolrCloud client using Zookeeper hosts [{}]\", core, zookeeperHosts);\n+        \"Solr({}): Creating a Solr Cloud client with configuration using Zookeeper hosts [{}]\",\n+        collection,\n+        zookeeperHosts);\n+\n+    String alias = properties == null ? null : (String) properties.getOrDefault(ALIAS_PROP, null);", "originalCommit": "d722e54261ec93909a983e315e64f4cd42761ba4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI4OTk0Mw==", "url": "https://github.com/codice/ddf/pull/5997#discussion_r413289943", "bodyText": "\u2753 Just confirming, is silently returning (instead of throwing an exception) what we want here if the alias or collection is null?", "author": "rzwiefel", "createdAt": "2020-04-22T20:04:22Z", "path": "platform/solr/solr-factory-impl/src/main/java/org/codice/solr/factory/impl/SolrCloudClientFactory.java", "diffHunk": "@@ -64,47 +68,157 @@\n   private final int maximumShardsPerNode =\n       NumberUtils.toInt(System.getProperty(\"solr.cloud.maxShardPerNode\"), 2);\n \n+  private static final String ALIAS_PROP = \"alias\";\n+\n   @Override\n   public org.codice.solr.client.solrj.SolrClient newClient(String core) {\n+    return newClient(core, null);\n+  }\n+\n+  @Override\n+  public org.codice.solr.client.solrj.SolrClient newClient(\n+      String collection, Map<String, Object> properties) {\n+\n     String zookeeperHosts = System.getProperty(\"solr.cloud.zookeeper\");\n+    checkConfig(zookeeperHosts);\n \n-    if (StringUtils.isBlank(zookeeperHosts)) {\n-      LOGGER.warn(\n-          \"Cannot create SolrCloud client without Zookeeper host list system property [solr.cloud.zookeeper] being set.\");\n-      throw new IllegalStateException(\"system property 'solr.cloud.zookeeper' is not configured\");\n-    }\n     LOGGER.debug(\n-        \"Solr({}): Creating a SolrCloud client using Zookeeper hosts [{}]\", core, zookeeperHosts);\n+        \"Solr({}): Creating a Solr Cloud client with configuration using Zookeeper hosts [{}]\",\n+        collection,\n+        zookeeperHosts);\n+\n+    String alias = properties == null ? null : (String) properties.getOrDefault(ALIAS_PROP, null);\n+\n     return new SolrClientAdapter(\n-        core,\n+        collection,\n         () ->\n             AccessController.doPrivileged(\n                 (PrivilegedAction<SolrClient>)\n                     () -> {\n-                      return createSolrCloudClient(zookeeperHosts, core);\n+                      return createSolrCloudClient(zookeeperHosts, collection, alias);\n                     }));\n   }\n \n   @VisibleForTesting\n-  SolrClient createSolrCloudClient(String zookeeperHosts, String collection) {\n+  void addCollectionToAlias(String alias, String collection, CloudSolrClient client) {\n+    if (StringUtils.isBlank(alias) || StringUtils.isBlank(collection)) {\n+      return;", "originalCommit": "d722e54261ec93909a983e315e64f4cd42761ba4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzg3NTE4Nw==", "url": "https://github.com/codice/ddf/pull/5997#discussion_r413875187", "bodyText": "going to remove the null check here. https://github.com/lamhuy/ddf/blob/preSplit/platform/solr/solr-factory-impl/src/main/java/org/codice/solr/factory/impl/SolrCloudClientFactory.java#L212\nmaking this error benign. It just mean noop.", "author": "lamhuy", "createdAt": "2020-04-23T15:03:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI4OTk0Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzI5NDQ2NA==", "url": "https://github.com/codice/ddf/pull/5997#discussion_r413294464", "bodyText": "\u270f\ufe0f This would be a great place to use Optional if you prefer to have the null checks done for you, eg:\nreturn Optional.ofNullable(aliasResponse)\n    .map(CollectionAdminResponse::getAliases)\n    .map(a -> a.get(alias))\n    .map(ca -> ca.split(\",\")\n    .map(Arrays::asList)\n    .orElse(Collections.emptyList());", "author": "rzwiefel", "createdAt": "2020-04-22T20:11:36Z", "path": "platform/solr/solr-factory-impl/src/main/java/org/codice/solr/factory/impl/SolrCloudClientFactory.java", "diffHunk": "@@ -64,47 +68,157 @@\n   private final int maximumShardsPerNode =\n       NumberUtils.toInt(System.getProperty(\"solr.cloud.maxShardPerNode\"), 2);\n \n+  private static final String ALIAS_PROP = \"alias\";\n+\n   @Override\n   public org.codice.solr.client.solrj.SolrClient newClient(String core) {\n+    return newClient(core, null);\n+  }\n+\n+  @Override\n+  public org.codice.solr.client.solrj.SolrClient newClient(\n+      String collection, Map<String, Object> properties) {\n+\n     String zookeeperHosts = System.getProperty(\"solr.cloud.zookeeper\");\n+    checkConfig(zookeeperHosts);\n \n-    if (StringUtils.isBlank(zookeeperHosts)) {\n-      LOGGER.warn(\n-          \"Cannot create SolrCloud client without Zookeeper host list system property [solr.cloud.zookeeper] being set.\");\n-      throw new IllegalStateException(\"system property 'solr.cloud.zookeeper' is not configured\");\n-    }\n     LOGGER.debug(\n-        \"Solr({}): Creating a SolrCloud client using Zookeeper hosts [{}]\", core, zookeeperHosts);\n+        \"Solr({}): Creating a Solr Cloud client with configuration using Zookeeper hosts [{}]\",\n+        collection,\n+        zookeeperHosts);\n+\n+    String alias = properties == null ? null : (String) properties.getOrDefault(ALIAS_PROP, null);\n+\n     return new SolrClientAdapter(\n-        core,\n+        collection,\n         () ->\n             AccessController.doPrivileged(\n                 (PrivilegedAction<SolrClient>)\n                     () -> {\n-                      return createSolrCloudClient(zookeeperHosts, core);\n+                      return createSolrCloudClient(zookeeperHosts, collection, alias);\n                     }));\n   }\n \n   @VisibleForTesting\n-  SolrClient createSolrCloudClient(String zookeeperHosts, String collection) {\n+  void addCollectionToAlias(String alias, String collection, CloudSolrClient client) {\n+    if (StringUtils.isBlank(alias) || StringUtils.isBlank(collection)) {\n+      return;\n+    }\n+    try {\n+      List<String> aliasedCollections = getCollectionsInAlias(client, alias);\n+      if (!aliasedCollections.contains(collection)) {\n+        List<String> collections = new ArrayList<>();\n+        collections.addAll(aliasedCollections);\n+        collections.add(collection);\n+        collections.addAll(getCollectionsNotInAlias(client, aliasedCollections, alias));\n+        createAlias(client, collections, alias);\n+      }\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.warn(\"Failed to update alias [{}]\", alias, e);\n+    }\n+  }\n+\n+  private List<String> getCollectionsInAlias(CloudSolrClient client, String alias)\n+      throws SolrServerException, IOException {\n+    CollectionAdminResponse aliasResponse =\n+        new CollectionAdminRequest.ListAliases().process(client);\n+\n+    if (aliasResponse != null) {\n+      Map<String, String> aliases = aliasResponse.getAliases();\n+      if (aliases != null && aliases.containsKey(alias)) {\n+        String[] collections = aliases.get(alias).split(\",\");\n+        return Arrays.asList(collections);\n+      }\n+    }", "originalCommit": "d722e54261ec93909a983e315e64f4cd42761ba4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQxMzMwNDc0Mw==", "url": "https://github.com/codice/ddf/pull/5997#discussion_r413304743", "bodyText": "\u270f\ufe0f Bummer optionals and exceptions dont play well together or you could probably do more with this. But even the latter half could be Optionaled if you'd prefer\nreturn Optional.ofNullable(response)\n    .map(CollectionAdminResponse::getResponse)\n    .map(resp -> resp.get(\"collections\"))\n    .orElse(Collections.emptyList())\n    .stream()\n    .filter(c -> c.startsWith(alias))\n    .filter(c -> currentAliases.contains(c))\n    .collect(Collectors.toList());", "author": "rzwiefel", "createdAt": "2020-04-22T20:25:27Z", "path": "platform/solr/solr-factory-impl/src/main/java/org/codice/solr/factory/impl/SolrCloudClientFactory.java", "diffHunk": "@@ -64,47 +68,157 @@\n   private final int maximumShardsPerNode =\n       NumberUtils.toInt(System.getProperty(\"solr.cloud.maxShardPerNode\"), 2);\n \n+  private static final String ALIAS_PROP = \"alias\";\n+\n   @Override\n   public org.codice.solr.client.solrj.SolrClient newClient(String core) {\n+    return newClient(core, null);\n+  }\n+\n+  @Override\n+  public org.codice.solr.client.solrj.SolrClient newClient(\n+      String collection, Map<String, Object> properties) {\n+\n     String zookeeperHosts = System.getProperty(\"solr.cloud.zookeeper\");\n+    checkConfig(zookeeperHosts);\n \n-    if (StringUtils.isBlank(zookeeperHosts)) {\n-      LOGGER.warn(\n-          \"Cannot create SolrCloud client without Zookeeper host list system property [solr.cloud.zookeeper] being set.\");\n-      throw new IllegalStateException(\"system property 'solr.cloud.zookeeper' is not configured\");\n-    }\n     LOGGER.debug(\n-        \"Solr({}): Creating a SolrCloud client using Zookeeper hosts [{}]\", core, zookeeperHosts);\n+        \"Solr({}): Creating a Solr Cloud client with configuration using Zookeeper hosts [{}]\",\n+        collection,\n+        zookeeperHosts);\n+\n+    String alias = properties == null ? null : (String) properties.getOrDefault(ALIAS_PROP, null);\n+\n     return new SolrClientAdapter(\n-        core,\n+        collection,\n         () ->\n             AccessController.doPrivileged(\n                 (PrivilegedAction<SolrClient>)\n                     () -> {\n-                      return createSolrCloudClient(zookeeperHosts, core);\n+                      return createSolrCloudClient(zookeeperHosts, collection, alias);\n                     }));\n   }\n \n   @VisibleForTesting\n-  SolrClient createSolrCloudClient(String zookeeperHosts, String collection) {\n+  void addCollectionToAlias(String alias, String collection, CloudSolrClient client) {\n+    if (StringUtils.isBlank(alias) || StringUtils.isBlank(collection)) {\n+      return;\n+    }\n+    try {\n+      List<String> aliasedCollections = getCollectionsInAlias(client, alias);\n+      if (!aliasedCollections.contains(collection)) {\n+        List<String> collections = new ArrayList<>();\n+        collections.addAll(aliasedCollections);\n+        collections.add(collection);\n+        collections.addAll(getCollectionsNotInAlias(client, aliasedCollections, alias));\n+        createAlias(client, collections, alias);\n+      }\n+    } catch (SolrServerException | IOException e) {\n+      LOGGER.warn(\"Failed to update alias [{}]\", alias, e);\n+    }\n+  }\n+\n+  private List<String> getCollectionsInAlias(CloudSolrClient client, String alias)\n+      throws SolrServerException, IOException {\n+    CollectionAdminResponse aliasResponse =\n+        new CollectionAdminRequest.ListAliases().process(client);\n+\n+    if (aliasResponse != null) {\n+      Map<String, String> aliases = aliasResponse.getAliases();\n+      if (aliases != null && aliases.containsKey(alias)) {\n+        String[] collections = aliases.get(alias).split(\",\");\n+        return Arrays.asList(collections);\n+      }\n+    }\n+    return Collections.emptyList();\n+  }\n+\n+  /**\n+   * Find existing collections in case parallel operations are creating collections\n+   *\n+   * @param client\n+   * @param currentAliases\n+   * @param alias\n+   * @return\n+   * @throws SolrServerException\n+   * @throws IOException\n+   */\n+  private List<String> getCollectionsNotInAlias(\n+      CloudSolrClient client, List<String> currentAliases, String alias)\n+      throws SolrServerException, IOException {\n+    if (StringUtils.isNotBlank(alias)) {\n+      CollectionAdminResponse response = new CollectionAdminRequest.List().process(client);\n+      if (response.getResponse() != null) {\n+        List<String> collections = (List<String>) response.getResponse().get(\"collections\");\n+        return collections == null\n+            ? Collections.emptyList()\n+            : collections\n+                .stream()\n+                .filter(c -> c.startsWith(alias))\n+                .filter(c -> currentAliases.contains(c))\n+                .collect(Collectors.toList());", "originalCommit": "d722e54261ec93909a983e315e64f4cd42761ba4", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2ac6a152a64cb7c2690301777d111ca021e7b49b", "url": "https://github.com/codice/ddf/commit/2ac6a152a64cb7c2690301777d111ca021e7b49b", "message": "DDF-5802 remove new features", "committedDate": "2020-05-07T20:19:45Z", "type": "forcePushed"}, {"oid": "6d91e38e2b8f616c884929ee7098533531b6d3f5", "url": "https://github.com/codice/ddf/commit/6d91e38e2b8f616c884929ee7098533531b6d3f5", "message": "DDF-5802 Refactor to enable DDF-5802", "committedDate": "2020-05-11T15:31:28Z", "type": "commit"}, {"oid": "46c732024bc91146b01b0951e7364b8e747c70ae", "url": "https://github.com/codice/ddf/commit/46c732024bc91146b01b0951e7364b8e747c70ae", "message": "DDF-5802 address comments", "committedDate": "2020-05-11T15:31:29Z", "type": "commit"}, {"oid": "3ced11154afb1c4173e71710c58f2d2abf5014ed", "url": "https://github.com/codice/ddf/commit/3ced11154afb1c4173e71710c58f2d2abf5014ed", "message": "DDF-5802 clean up", "committedDate": "2020-05-11T15:34:35Z", "type": "forcePushed"}, {"oid": "848c89ca9d29e90c99823b09dc2e4073e5741e3e", "url": "https://github.com/codice/ddf/commit/848c89ca9d29e90c99823b09dc2e4073e5741e3e", "message": "DDF-5802 remove new features", "committedDate": "2020-05-11T22:10:24Z", "type": "commit"}, {"oid": "848c89ca9d29e90c99823b09dc2e4073e5741e3e", "url": "https://github.com/codice/ddf/commit/848c89ca9d29e90c99823b09dc2e4073e5741e3e", "message": "DDF-5802 remove new features", "committedDate": "2020-05-11T22:10:24Z", "type": "forcePushed"}]}