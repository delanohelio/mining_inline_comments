{"pr_number": 5963, "pr_title": "DDF-5962 Support querying quoted phrases with Solr", "pr_createdAt": "2020-04-03T00:40:53Z", "pr_url": "https://github.com/codice/ddf/pull/5963", "timeline": [{"oid": "f045749237445b2d3ab3ef0d544a775740efec9a", "url": "https://github.com/codice/ddf/commit/f045749237445b2d3ab3ef0d544a775740efec9a", "message": "DDF-5962 Support querying quoted phrases", "committedDate": "2020-04-03T00:30:08Z", "type": "commit"}, {"oid": "4ba5d099f82e4176e36f1a1bcaeb02d9293fb70c", "url": "https://github.com/codice/ddf/commit/4ba5d099f82e4176e36f1a1bcaeb02d9293fb70c", "message": "DDF-5962 Remove unsupported wildcards from PropertyIsEqualTo", "committedDate": "2020-04-03T00:30:09Z", "type": "commit"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2NDkwMw==", "url": "https://github.com/codice/ddf/pull/5963#discussion_r405864903", "bodyText": "So this only works if the whole thing is quoted.  What if I wanted to do a search where part of the search phrase was quoted?  For example: \"abc 123\" def \"ef gh\".  Couldn't we grab the quoted sections and escape the whitespace characters within the quotes?  Also, my example creates an interesting problem for this code because it actually does start and end with a quote", "author": "derekwilhelm", "createdAt": "2020-04-08T23:06:40Z", "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/SolrFilterDelegate.java", "diffHunk": "@@ -300,22 +300,34 @@ public SolrQuery propertyIsLike(String propertyName, String pattern, boolean isC\n \n     String searchPhrase = escapeSpecialCharacters(pattern);\n \n-    if (Metacard.ANY_TEXT.equals(propertyName) && SOLR_WILDCARD_CHAR.equals(searchPhrase)) {\n+    boolean isAnyText = Metacard.ANY_TEXT.equals(propertyName);\n+\n+    if (isAnyText && SOLR_WILDCARD_CHAR.equals(searchPhrase)) {\n       return new SolrQuery(\"*:*\");\n     }\n \n-    if (searchPhrase.contains(SOLR_WILDCARD_CHAR)\n-        || searchPhrase.contains(SOLR_SINGLE_WILDCARD_CHAR)) {\n+    boolean isWildcard =\n+        searchPhrase.contains(SOLR_WILDCARD_CHAR)\n+            || searchPhrase.contains(SOLR_SINGLE_WILDCARD_CHAR);\n+\n+    boolean isQuotedPhrase = pattern.startsWith(\"\\\"\") && pattern.endsWith(\"\\\"\");", "originalCommit": "4ba5d099f82e4176e36f1a1bcaeb02d9293fb70c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3NjA1NQ==", "url": "https://github.com/codice/ddf/pull/5963#discussion_r405876055", "bodyText": "I did not want to introduce a large, complex grammar to LIKE values.  I figured for those other use cases we can use the existing logical operators like AND and OR already available in filters.\nI went back and forth on if I should detect that kind of example by making sure there were only two double quotes.  I am hoping we can hide this detail from users and instead provide ways through the UI to create this type of query.  So ideally a user would never have to quote their own values.", "author": "pklinef", "createdAt": "2020-04-08T23:41:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2NDkwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg4NTY5Nw==", "url": "https://github.com/codice/ddf/pull/5963#discussion_r405885697", "bodyText": "Might also be possible to do a transform on the backend as a PreQuery plugin. I could see your query, \"abc 123\" def \"ef gh\", getting decomposed to something like \"abc 123\" def* AND *def \"ef gh\" if we wanted the Solr provider to meet you halfway, which still isn't perfect but might be good enough.\nEven less perfect would be a representation like \"abc 123\"* AND *def* AND *\"ef gh\" but it seems either way the Solr side needs to provide a little bit more flexibility.", "author": "Lambeaux", "createdAt": "2020-04-09T00:12:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2NDkwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg4NjgyNA==", "url": "https://github.com/codice/ddf/pull/5963#discussion_r405886824", "bodyText": "I would like to avoid adding the complexity of grammar parsing when we can get the same query from building it up at the filter level already.", "author": "pklinef", "createdAt": "2020-04-09T00:16:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2NDkwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg5NDEzNA==", "url": "https://github.com/codice/ddf/pull/5963#discussion_r405894134", "bodyText": "I agree. I don't think you need full grammar parsing at the Solr level.\nBut I also don't think you can fully decompose \"exact\" queries and get expected results because breaking a LIKE predicate apart at the logic level would involve adding wildcard symbols to reassemble semantic equivalence to the original LIKE pattern. And if you only detect starting with quotes and ending with quotes, then something like *text \"literal\" won't get interpreted correctly.\nCould the wildcardSolrQuery function get support for partial \"exactness\"?", "author": "Lambeaux", "createdAt": "2020-04-09T00:44:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2NDkwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTkwNTcxMw==", "url": "https://github.com/codice/ddf/pull/5963#discussion_r405905713", "bodyText": "Thinking about this more I might have incorrectly assumed that order matters for a PropertyIsLike predicate. I suspect @derekwilhelm's original query \"abc 123\" def \"ef gh\" could actually be \"abc 123\" AND def AND \"ef gh\" in which case the Solr layer would work as is.\nBut if term order matters within a PropertyIsLike, then these kinds of query transforms wouldn't work. Let me know if my reasoning is not correct.", "author": "Lambeaux", "createdAt": "2020-04-09T01:28:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2NDkwMw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNjI5MDQ5NQ==", "url": "https://github.com/codice/ddf/pull/5963#discussion_r406290495", "bodyText": "I'm fine leaving it the way that it is for now.  I was just wondering if there was an easy way to expand the capability to cover more cases.  We don't really handle the scenario I presented at a higher level unless someone specifically constructs an advanced search that way.  With the growing desire to do more direct logic within a text search this seemed like a good place to account for more cases.  However, it may be more appropriate to do that somewhere else.", "author": "derekwilhelm", "createdAt": "2020-04-09T15:31:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg2NDkwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3NzA4Mw==", "url": "https://github.com/codice/ddf/pull/5963#discussion_r405877083", "bodyText": "\u2753 Could the query returns for isQuotedPhrase and isWildcard now get moved to the earlier if block? Actually I think the logic could be simplified as separate blocks now:\nif (isQuotedPhrase) {\n... \nreturn new SolrQuery(...);\n}\n\nif (isWildcard) {\n...\nreturn new SolrQuery(...);\n}\n\n// Not an exact phrase\nsearchPhrase = QUOTE + searchPhrase + QUOTE;\n\nif (isCaseSensitive) {\n...\n}\nreturn new SolrQuery(...);\n\nI realize this might be a matter of preference, but the decreased nesting would help me consume this faster. Assuming I'm correct this is a valid refactor and I'm not missing something.", "author": "Lambeaux", "createdAt": "2020-04-08T23:45:13Z", "path": "catalog/core/catalog-core-solr/src/main/java/ddf/catalog/source/solr/SolrFilterDelegate.java", "diffHunk": "@@ -300,22 +300,34 @@ public SolrQuery propertyIsLike(String propertyName, String pattern, boolean isC\n \n     String searchPhrase = escapeSpecialCharacters(pattern);\n \n-    if (Metacard.ANY_TEXT.equals(propertyName) && SOLR_WILDCARD_CHAR.equals(searchPhrase)) {\n+    boolean isAnyText = Metacard.ANY_TEXT.equals(propertyName);\n+\n+    if (isAnyText && SOLR_WILDCARD_CHAR.equals(searchPhrase)) {\n       return new SolrQuery(\"*:*\");\n     }\n \n-    if (searchPhrase.contains(SOLR_WILDCARD_CHAR)\n-        || searchPhrase.contains(SOLR_SINGLE_WILDCARD_CHAR)) {\n+    boolean isWildcard =\n+        searchPhrase.contains(SOLR_WILDCARD_CHAR)\n+            || searchPhrase.contains(SOLR_SINGLE_WILDCARD_CHAR);\n+\n+    boolean isQuotedPhrase = pattern.startsWith(\"\\\"\") && pattern.endsWith(\"\\\"\");\n+\n+    if (isQuotedPhrase) {\n+      searchPhrase =\n+          searchPhrase.substring(2, searchPhrase.length() - 2).replaceAll(\"\\\\s\", \"\\\\\\\\ \");\n+      if (!isWildcard) {\n+        searchPhrase = SOLR_WILDCARD_CHAR + searchPhrase + SOLR_WILDCARD_CHAR;\n+      }\n+    } else if (isWildcard) {\n       searchPhrase = \"(\" + searchPhrase + \")\";\n     } else {\n       // Not an exact phrase\n       searchPhrase = QUOTE + searchPhrase + QUOTE;\n     }\n \n-    if (searchPhrase.contains(SOLR_WILDCARD_CHAR)\n-        || searchPhrase.contains(SOLR_SINGLE_WILDCARD_CHAR)\n-        || Metacard.ANY_TEXT.equals(propertyName)) {\n-\n+    if (isQuotedPhrase) {\n+      return new SolrQuery(wildcardSolrQuery(searchPhrase, propertyName, isCaseSensitive, true));\n+    } else if (isWildcard || isAnyText) {\n       return new SolrQuery(wildcardSolrQuery(searchPhrase, propertyName, isCaseSensitive, false));", "originalCommit": "4ba5d099f82e4176e36f1a1bcaeb02d9293fb70c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg4NTgxNA==", "url": "https://github.com/codice/ddf/pull/5963#discussion_r405885814", "bodyText": "I did try to do that but it did not work.  The exact phrase case is needed for anyText cases which have the same behavior as wildcard though wildcard cases are escaped differently.", "author": "pklinef", "createdAt": "2020-04-09T00:12:35Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3NzA4Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg4NjAzNw==", "url": "https://github.com/codice/ddf/pull/5963#discussion_r405886037", "bodyText": "I did unnested all the other cases I could.", "author": "pklinef", "createdAt": "2020-04-09T00:13:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQwNTg3NzA4Mw=="}], "type": "inlineReview"}]}