{"pr_number": 6419, "pr_title": "[2.26.x] DDF-4729 adds WFS 1.1.0 sorting", "pr_createdAt": "2020-11-11T21:34:45Z", "pr_url": "https://github.com/codice/ddf/pull/6419", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1MjQ5Nw==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r521652497", "bodyText": "Note: I thought it most appropriate to fail the query if the sort property can't be mapped.  GeoServer fails any query with a SortBy property that it doesn't know about.", "author": "jlcsmith", "createdAt": "2020-11-11T21:36:01Z", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/main/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSource.java", "diffHunk": "@@ -763,6 +775,30 @@ private GetFeatureType buildGetFeatureRequest(\n           if (areAnyFiltersSet(filter)) {\n             wfsQuery.setFilter(filter);\n           }\n+          if (!this.disableSorting) {\n+            if (query.getSortBy() != null) {\n+              SortByType sortByType = buildSortBy(filterDelegateEntry.getKey(), query.getSortBy());\n+              if (sortByType != null\n+                  && sortByType.getSortProperty() != null\n+                  && sortByType.getSortProperty().size() > 0) {\n+                LOGGER.debug(\n+                    \"Sorting using sort property [{}] and sort order [{}].\",\n+                    sortByType.getSortProperty().get(0).getPropertyName(),\n+                    sortByType.getSortProperty().get(0).getSortOrder());\n+                wfsQuery.setSortBy(sortByType);\n+              } else {\n+                throw new UnsupportedQueryException(", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1NDAxMw==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r521654013", "bodyText": "this was a small improvement I wanted to slip into this PR.  Empty string values shouldn't be considered invalid in a query.", "author": "jlcsmith", "createdAt": "2020-11-11T21:38:40Z", "path": "catalog/spatial/wfs/2.0.0/spatial-wfs-v2_0_0-source/src/main/java/org/codice/ddf/spatial/ogc/wfs/v2_0_0/catalog/source/WfsFilterDelegate.java", "diffHunk": "@@ -1172,9 +1172,7 @@ private TimeInstantType createTimeInstantType(String type, String date) {\n   }\n \n   private boolean isValidInputParameters(String propertyName, Object literal) {\n-    if (literal == null\n-        || StringUtils.isEmpty(propertyName)\n-        || StringUtils.isEmpty(literal.toString())) {\n+    if (literal == null || StringUtils.isEmpty(propertyName)) {", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1NDI5MQ==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r521654291", "bodyText": "this was a small improvement I wanted to slip into this PR. Empty string values shouldn't be considered invalid in a query.", "author": "jlcsmith", "createdAt": "2020-11-11T21:39:06Z", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/main/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsFilterDelegate.java", "diffHunk": "@@ -764,9 +764,7 @@ private FeatureIdType createFeatureIdFilter(final String id) {\n   }\n \n   private boolean isValidInputParameters(String propertyName, Object literal) {\n-    return !(literal == null\n-        || StringUtils.isEmpty(propertyName)\n-        || StringUtils.isEmpty(literal.toString()));\n+    return !(literal == null || StringUtils.isEmpty(propertyName));", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMxNTk1Mw==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522315953", "bodyText": "Consider adding a unit test for this change.", "author": "jrnorth", "createdAt": "2020-11-12T18:15:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMTY1NDI5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI3ODI5OA==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522278298", "bodyText": "\u270f\ufe0f Suggestion: wrap these lines in a LOGGER.isDebugEnabled check", "author": "SmithJosh", "createdAt": "2020-11-12T17:19:51Z", "path": "catalog/spatial/wfs/spatial-wfs-common/src/main/java/org/codice/ddf/spatial/ogc/wfs/catalog/common/AbstractWfsSource.java", "diffHunk": "@@ -58,4 +68,77 @@ public String getSslProtocol() {\n   public void setSslProtocol(String sslProtocol) {\n     this.sslProtocol = sslProtocol;\n   }\n+\n+  /**\n+   * If a MetacardMapper cannot be found or there is no mapping for the incomingPropertyName, return\n+   * null. This will cause a query to be constructed without an AbstractSortingClause.\n+   */\n+  protected String mapSortByPropertyName(\n+      QName featureType, String incomingPropertyName, List<MetacardMapper> metacardMapperList) {\n+    if (featureType == null || incomingPropertyName == null || metacardMapperList == null) {\n+      return null;\n+    }\n+    metacardMapperList.forEach(\n+        m -> {\n+          LOGGER.debug(\n+              \"Sorting: Mapper: featureType {}, mapped property for {} : {}\",\n+              m.getFeatureType(),\n+              incomingPropertyName,\n+              m.getFeatureProperty(incomingPropertyName));\n+        });", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI4OTc0Nw==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522289747", "bodyText": "\u270f\ufe0f These two conditionals can be combined to reduce nesting:\nif (!disableSorting && query.getSortBy() != null) {", "author": "jrnorth", "createdAt": "2020-11-12T17:35:03Z", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/main/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSource.java", "diffHunk": "@@ -763,6 +775,30 @@ private GetFeatureType buildGetFeatureRequest(\n           if (areAnyFiltersSet(filter)) {\n             wfsQuery.setFilter(filter);\n           }\n+          if (!this.disableSorting) {", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI5NDUxMA==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522294510", "bodyText": "\u270f\ufe0f I find these kinds of configurations easier to understand when they're stated in terms of whether something is enabled rather than disabled.", "author": "jrnorth", "createdAt": "2020-11-12T17:41:56Z", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/main/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSource.java", "diffHunk": "@@ -248,6 +254,9 @@\n \n   private static final String FEATURE_MEMBER_ELEMENT = \"featureMember\";\n \n+  private static final String DISABLE_SORTING = \"disableSorting\";", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjM4NzQ0NQ==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522387445", "bodyText": "I agree although I was trying to be consistent with the WFS 2.0 source config", "author": "jlcsmith", "createdAt": "2020-11-12T20:03:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI5NDUxMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjI5NzYwMw==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522297603", "bodyText": "\u270f\ufe0f Looks like this will fail checkstyle", "author": "jrnorth", "createdAt": "2020-11-12T17:46:47Z", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/main/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSource.java", "diffHunk": "@@ -1041,18 +1114,18 @@ private String handleClientException(Exception ce) {\n \n   private void logMessage(GetFeatureType getFeature) {\n     if (LOGGER.isDebugEnabled()) {\n-      try {\n-        StringWriter writer = new StringWriter();\n-        JAXBContext contextObj = JAXBContext.newInstance(GetFeatureType.class);\n+    try {", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMwNjExNg==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522306116", "bodyText": "\u270f\ufe0f All three: PROPERTY instead of PROEPRTY", "author": "jrnorth", "createdAt": "2020-11-12T17:59:52Z", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/test/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSourceTest.java", "diffHunk": "@@ -235,6 +239,12 @@\n \n   private static final String LITERAL = \"literal\";\n \n+  private static final String MOCK_TEMPORAL_SORT_PROEPRTY = \"myTemporalSortProperty\";", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMwODg4Mg==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522308882", "bodyText": "Don't need a captor for this test (or for any of the following tests that expect an exception).", "author": "jrnorth", "createdAt": "2020-11-12T18:04:10Z", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/test/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSourceTest.java", "diffHunk": "@@ -1371,6 +1389,210 @@ public void testQuerySendsHitsRequestBeforeResultsRequest() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testSortingNoSortBy() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    propertyIsLikeQuery.setPageSize(1);\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    final GetFeatureType getResults = captor.getAllValues().get(1);\n+    assertThat(getResults.getResultType(), is(ResultTypeType.RESULTS));\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+      final QueryType queryType = getFeatureType.getQuery().get(0);\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  /**\n+   * WFS 1.1.0 Sorting uses the following format: Valid sort orders are \"ASC\" and \"DESC\". Ref:\n+   * http://schemas.opengis.net/filter/1.1.0/sort.xsd <wfs:Query typeName=\"QName QName\">\n+   * <wfs:PropertyName>QName</wfs:PropertyName> <ogc:Filter> <ogc:Equals> <ogc:PropertyName/>\n+   * <gml:Point>... </gml:Point> </ogc:Equals> </ogc:Filter> <ogc:SortBy> <ogc:SortProperty>\n+   * <ogc:PropertyName>property</ogc:PropertyName> <ogc:SortOrder>ASC</ogc:SortOrder>\n+   * </ogc:SortProperty> </ogc:SortBy> </wfs:Query>\n+   */\n+  @Test\n+  public void testSortingSortOrderAscending() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROEPRTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingSortOrderDescending() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.DESCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROEPRTY, \"DESC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingDisabled() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(true);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, false, MOCK_TEMPORAL_SORT_PROEPRTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingNoSortMapping() throws Exception {\n+    // if sorting is enabled but there is no sort mapping, throw an UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\"Source WFS_ID does not support specified sort property title\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(null, null, null);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(false);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(\"title\", SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjQwMjczNA==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522402734", "bodyText": "looks like something I missed.  Cleaning it up", "author": "jlcsmith", "createdAt": "2020-11-12T20:25:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMwODg4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMxMTcyNA==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522311724", "bodyText": "distanceSortProperty", "author": "jrnorth", "createdAt": "2020-11-12T18:08:55Z", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/test/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSourceTest.java", "diffHunk": "@@ -1371,6 +1389,210 @@ public void testQuerySendsHitsRequestBeforeResultsRequest() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testSortingNoSortBy() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    propertyIsLikeQuery.setPageSize(1);\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    final GetFeatureType getResults = captor.getAllValues().get(1);\n+    assertThat(getResults.getResultType(), is(ResultTypeType.RESULTS));\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+      final QueryType queryType = getFeatureType.getQuery().get(0);\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  /**\n+   * WFS 1.1.0 Sorting uses the following format: Valid sort orders are \"ASC\" and \"DESC\". Ref:\n+   * http://schemas.opengis.net/filter/1.1.0/sort.xsd <wfs:Query typeName=\"QName QName\">\n+   * <wfs:PropertyName>QName</wfs:PropertyName> <ogc:Filter> <ogc:Equals> <ogc:PropertyName/>\n+   * <gml:Point>... </gml:Point> </ogc:Equals> </ogc:Filter> <ogc:SortBy> <ogc:SortProperty>\n+   * <ogc:PropertyName>property</ogc:PropertyName> <ogc:SortOrder>ASC</ogc:SortOrder>\n+   * </ogc:SortProperty> </ogc:SortBy> </wfs:Query>\n+   */\n+  @Test\n+  public void testSortingSortOrderAscending() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROEPRTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingSortOrderDescending() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.DESCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROEPRTY, \"DESC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingDisabled() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(true);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, false, MOCK_TEMPORAL_SORT_PROEPRTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingNoSortMapping() throws Exception {\n+    // if sorting is enabled but there is no sort mapping, throw an UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\"Source WFS_ID does not support specified sort property title\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(null, null, null);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(false);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(\"title\", SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortOrder() throws Exception {\n+    // if sort order is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order null\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, (String) null));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortProperty() throws Exception {\n+    // if sort property is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property null with sort order SortOrder[ASCENDING]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(null, \"ASC\"));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingBadSortOrder() throws Exception {\n+    // if sort order is invalid throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order SortOrder[foo]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, \"foo\"));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  private void assertFeature(\n+      GetFeatureType getFeatureType,\n+      boolean sortingEnabled,\n+      String sortProperty,\n+      String sortOrder) {\n+    assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+    final QueryType queryType = getFeatureType.getQuery().get(0);\n+    if (sortingEnabled) {\n+      assertThat(queryType.isSetSortBy(), is(true));\n+      assertThat(queryType.getSortBy().getSortProperty().size(), is(1));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getPropertyName().getContent().size(),\n+          is(1));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getPropertyName().getContent().get(0),\n+          is(sortProperty));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getSortOrder().value(), is(sortOrder));\n+    } else {\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  private void setupMapper(\n+      String temporalSortProperty, String relevanceSortProperty, String distanceSortProperty) {\n+    final MetacardMapperImpl metacardMapper = new MetacardMapperImpl();\n+    metacardMapper.setSortByTemporalFeatureProperty(temporalSortProperty);\n+    metacardMapper.setSortByDistanceFeatureProperty(relevanceSortProperty);", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMxMTgzMg==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522311832", "bodyText": "relevanceSortProperty", "author": "jrnorth", "createdAt": "2020-11-12T18:09:07Z", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/test/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSourceTest.java", "diffHunk": "@@ -1371,6 +1389,210 @@ public void testQuerySendsHitsRequestBeforeResultsRequest() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testSortingNoSortBy() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    propertyIsLikeQuery.setPageSize(1);\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    final GetFeatureType getResults = captor.getAllValues().get(1);\n+    assertThat(getResults.getResultType(), is(ResultTypeType.RESULTS));\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+      final QueryType queryType = getFeatureType.getQuery().get(0);\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  /**\n+   * WFS 1.1.0 Sorting uses the following format: Valid sort orders are \"ASC\" and \"DESC\". Ref:\n+   * http://schemas.opengis.net/filter/1.1.0/sort.xsd <wfs:Query typeName=\"QName QName\">\n+   * <wfs:PropertyName>QName</wfs:PropertyName> <ogc:Filter> <ogc:Equals> <ogc:PropertyName/>\n+   * <gml:Point>... </gml:Point> </ogc:Equals> </ogc:Filter> <ogc:SortBy> <ogc:SortProperty>\n+   * <ogc:PropertyName>property</ogc:PropertyName> <ogc:SortOrder>ASC</ogc:SortOrder>\n+   * </ogc:SortProperty> </ogc:SortBy> </wfs:Query>\n+   */\n+  @Test\n+  public void testSortingSortOrderAscending() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROEPRTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingSortOrderDescending() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.DESCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROEPRTY, \"DESC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingDisabled() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(true);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, false, MOCK_TEMPORAL_SORT_PROEPRTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingNoSortMapping() throws Exception {\n+    // if sorting is enabled but there is no sort mapping, throw an UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\"Source WFS_ID does not support specified sort property title\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(null, null, null);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(false);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(\"title\", SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortOrder() throws Exception {\n+    // if sort order is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order null\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, (String) null));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortProperty() throws Exception {\n+    // if sort property is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property null with sort order SortOrder[ASCENDING]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(null, \"ASC\"));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingBadSortOrder() throws Exception {\n+    // if sort order is invalid throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order SortOrder[foo]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, \"foo\"));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  private void assertFeature(\n+      GetFeatureType getFeatureType,\n+      boolean sortingEnabled,\n+      String sortProperty,\n+      String sortOrder) {\n+    assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+    final QueryType queryType = getFeatureType.getQuery().get(0);\n+    if (sortingEnabled) {\n+      assertThat(queryType.isSetSortBy(), is(true));\n+      assertThat(queryType.getSortBy().getSortProperty().size(), is(1));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getPropertyName().getContent().size(),\n+          is(1));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getPropertyName().getContent().get(0),\n+          is(sortProperty));\n+      assertThat(\n+          queryType.getSortBy().getSortProperty().get(0).getSortOrder().value(), is(sortOrder));\n+    } else {\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  private void setupMapper(\n+      String temporalSortProperty, String relevanceSortProperty, String distanceSortProperty) {\n+    final MetacardMapperImpl metacardMapper = new MetacardMapperImpl();\n+    metacardMapper.setSortByTemporalFeatureProperty(temporalSortProperty);\n+    metacardMapper.setSortByDistanceFeatureProperty(relevanceSortProperty);\n+    metacardMapper.setSortByRelevanceFeatureProperty(distanceSortProperty);", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMxNDQ4MA==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522314480", "bodyText": "\u270f\ufe0f Assertions on collection size should use the hasSize() matcher for more useful messages when the test fails.", "author": "jrnorth", "createdAt": "2020-11-12T18:12:57Z", "path": "catalog/spatial/wfs/1.1.0/spatial-wfs-v1_1_0-source/src/test/java/org/codice/ddf/spatial/ogc/wfs/v110/catalog/source/WfsSourceTest.java", "diffHunk": "@@ -1371,6 +1389,210 @@ public void testQuerySendsHitsRequestBeforeResultsRequest() throws Exception {\n     }\n   }\n \n+  @Test\n+  public void testSortingNoSortBy() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    propertyIsLikeQuery.setPageSize(1);\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    final GetFeatureType getResults = captor.getAllValues().get(1);\n+    assertThat(getResults.getResultType(), is(ResultTypeType.RESULTS));\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));\n+      final QueryType queryType = getFeatureType.getQuery().get(0);\n+      assertThat(queryType.isSetSortBy(), is(false));\n+    }\n+  }\n+\n+  /**\n+   * WFS 1.1.0 Sorting uses the following format: Valid sort orders are \"ASC\" and \"DESC\". Ref:\n+   * http://schemas.opengis.net/filter/1.1.0/sort.xsd <wfs:Query typeName=\"QName QName\">\n+   * <wfs:PropertyName>QName</wfs:PropertyName> <ogc:Filter> <ogc:Equals> <ogc:PropertyName/>\n+   * <gml:Point>... </gml:Point> </ogc:Equals> </ogc:Filter> <ogc:SortBy> <ogc:SortProperty>\n+   * <ogc:PropertyName>property</ogc:PropertyName> <ogc:SortOrder>ASC</ogc:SortOrder>\n+   * </ogc:SortProperty> </ogc:SortBy> </wfs:Query>\n+   */\n+  @Test\n+  public void testSortingSortOrderAscending() throws Exception {\n+    // Setup\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROEPRTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingSortOrderDescending() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.DESCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, true, MOCK_TEMPORAL_SORT_PROEPRTY, \"DESC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingDisabled() throws Exception {\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(true);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+    verify(mockWfs, times(2)).getFeature(captor.capture());\n+\n+    for (final GetFeatureType getFeatureType : captor.getAllValues()) {\n+      assertFeature(getFeatureType, false, MOCK_TEMPORAL_SORT_PROEPRTY, \"ASC\");\n+    }\n+  }\n+\n+  @Test\n+  public void testSortingNoSortMapping() throws Exception {\n+    // if sorting is enabled but there is no sort mapping, throw an UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\"Source WFS_ID does not support specified sort property title\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(null, null, null);\n+    source.setMetacardMappers(metacardMappers);\n+    source.setDisableSorting(false);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(\"title\", SortOrder.ASCENDING));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortOrder() throws Exception {\n+    // if sort order is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order null\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, (String) null));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingNoSortProperty() throws Exception {\n+    // if sort property is missing, throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property null with sort order SortOrder[ASCENDING]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(null, \"ASC\"));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  @Test\n+  public void testSortingBadSortOrder() throws Exception {\n+    // if sort order is invalid throw UnsupportedQueryException\n+    expectedEx.expect(UnsupportedQueryException.class);\n+    expectedEx.expectMessage(\n+        \"Source WFS_ID does not support specified sort property TEMPORAL with sort order SortOrder[foo]\");\n+\n+    mapSchemaToFeatures(ONE_TEXT_PROPERTY_SCHEMA_PERSON, ONE_FEATURE);\n+    setUpMocks(null, null, ONE_FEATURE, ONE_FEATURE);\n+    final QueryImpl propertyIsLikeQuery =\n+        new QueryImpl(builder.attribute(Metacard.ANY_TEXT).is().like().text(\"literal\"));\n+    setupMapper(\n+        MOCK_TEMPORAL_SORT_PROEPRTY, MOCK_RELEVANCE_SORT_PROEPRTY, MOCK_DISTANCE_SORT_PROEPRTY);\n+    source.setMetacardMappers(metacardMappers);\n+    propertyIsLikeQuery.setSortBy(new SortByImpl(Result.TEMPORAL, \"foo\"));\n+\n+    final ArgumentCaptor<GetFeatureType> captor = ArgumentCaptor.forClass(GetFeatureType.class);\n+    source.query(new QueryRequestImpl(propertyIsLikeQuery));\n+  }\n+\n+  private void assertFeature(\n+      GetFeatureType getFeatureType,\n+      boolean sortingEnabled,\n+      String sortProperty,\n+      String sortOrder) {\n+    assertThat(getFeatureType.getQuery().size(), is(ONE_FEATURE));", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMxNzYyMQ==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522317621", "bodyText": "\u270f\ufe0f proeprty -> property", "author": "jrnorth", "createdAt": "2020-11-12T18:18:05Z", "path": "catalog/spatial/wfs/spatial-wfs-common/src/main/java/org/codice/ddf/spatial/ogc/wfs/catalog/common/AbstractWfsSource.java", "diffHunk": "@@ -58,4 +68,77 @@ public String getSslProtocol() {\n   public void setSslProtocol(String sslProtocol) {\n     this.sslProtocol = sslProtocol;\n   }\n+\n+  /**\n+   * If a MetacardMapper cannot be found or there is no mapping for the incomingPropertyName, return\n+   * null. This will cause a query to be constructed without an AbstractSortingClause.\n+   */\n+  protected String mapSortByPropertyName(\n+      QName featureType, String incomingPropertyName, List<MetacardMapper> metacardMapperList) {\n+    if (featureType == null || incomingPropertyName == null || metacardMapperList == null) {\n+      return null;\n+    }\n+    metacardMapperList.forEach(\n+        m -> {\n+          LOGGER.debug(\n+              \"Sorting: Mapper: featureType {}, mapped property for {} : {}\",\n+              m.getFeatureType(),\n+              incomingPropertyName,\n+              m.getFeatureProperty(incomingPropertyName));\n+        });\n+    LOGGER.debug(\n+        \"Mapping sort proeprty: featureType {}, incomingPropertyName {}\",", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyMjQ0NQ==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522322445", "bodyText": "\u270f\ufe0f Looks like a switch statement would be appropriate here.", "author": "jrnorth", "createdAt": "2020-11-12T18:25:51Z", "path": "catalog/spatial/wfs/spatial-wfs-common/src/main/java/org/codice/ddf/spatial/ogc/wfs/catalog/common/AbstractWfsSource.java", "diffHunk": "@@ -58,4 +68,77 @@ public String getSslProtocol() {\n   public void setSslProtocol(String sslProtocol) {\n     this.sslProtocol = sslProtocol;\n   }\n+\n+  /**\n+   * If a MetacardMapper cannot be found or there is no mapping for the incomingPropertyName, return\n+   * null. This will cause a query to be constructed without an AbstractSortingClause.\n+   */\n+  protected String mapSortByPropertyName(\n+      QName featureType, String incomingPropertyName, List<MetacardMapper> metacardMapperList) {\n+    if (featureType == null || incomingPropertyName == null || metacardMapperList == null) {\n+      return null;\n+    }\n+    metacardMapperList.forEach(\n+        m -> {\n+          LOGGER.debug(\n+              \"Sorting: Mapper: featureType {}, mapped property for {} : {}\",\n+              m.getFeatureType(),\n+              incomingPropertyName,\n+              m.getFeatureProperty(incomingPropertyName));\n+        });\n+    LOGGER.debug(\n+        \"Mapping sort proeprty: featureType {}, incomingPropertyName {}\",\n+        featureType,\n+        incomingPropertyName);\n+    MetacardMapper metacardToFeaturePropertyMapper =\n+        lookupMetacardAttributeToFeaturePropertyMapper(featureType, metacardMapperList);\n+    String mappedPropertyName = null;\n+\n+    if (metacardToFeaturePropertyMapper != null) {\n+\n+      if (org.apache.commons.lang.StringUtils.equals(Result.TEMPORAL, incomingPropertyName)", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyMzc0MQ==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522323741", "bodyText": "\u270f\ufe0f mappedPropertyName = StringUtils.defaultIfBlank(metacardToFeaturePropertyMapper.getSortByTemporalFeatureProperty(), null);", "author": "jrnorth", "createdAt": "2020-11-12T18:27:55Z", "path": "catalog/spatial/wfs/spatial-wfs-common/src/main/java/org/codice/ddf/spatial/ogc/wfs/catalog/common/AbstractWfsSource.java", "diffHunk": "@@ -58,4 +68,77 @@ public String getSslProtocol() {\n   public void setSslProtocol(String sslProtocol) {\n     this.sslProtocol = sslProtocol;\n   }\n+\n+  /**\n+   * If a MetacardMapper cannot be found or there is no mapping for the incomingPropertyName, return\n+   * null. This will cause a query to be constructed without an AbstractSortingClause.\n+   */\n+  protected String mapSortByPropertyName(\n+      QName featureType, String incomingPropertyName, List<MetacardMapper> metacardMapperList) {\n+    if (featureType == null || incomingPropertyName == null || metacardMapperList == null) {\n+      return null;\n+    }\n+    metacardMapperList.forEach(\n+        m -> {\n+          LOGGER.debug(\n+              \"Sorting: Mapper: featureType {}, mapped property for {} : {}\",\n+              m.getFeatureType(),\n+              incomingPropertyName,\n+              m.getFeatureProperty(incomingPropertyName));\n+        });\n+    LOGGER.debug(\n+        \"Mapping sort proeprty: featureType {}, incomingPropertyName {}\",\n+        featureType,\n+        incomingPropertyName);\n+    MetacardMapper metacardToFeaturePropertyMapper =\n+        lookupMetacardAttributeToFeaturePropertyMapper(featureType, metacardMapperList);\n+    String mappedPropertyName = null;\n+\n+    if (metacardToFeaturePropertyMapper != null) {\n+\n+      if (org.apache.commons.lang.StringUtils.equals(Result.TEMPORAL, incomingPropertyName)\n+          || org.apache.commons.lang.StringUtils.equals(Metacard.EFFECTIVE, incomingPropertyName)) {\n+        mappedPropertyName =", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyMjMyNTAxNg==", "url": "https://github.com/codice/ddf/pull/6419#discussion_r522325016", "bodyText": "\u270f\ufe0f Same here. PROEPRTY -> PROPERTY", "author": "jrnorth", "createdAt": "2020-11-12T18:30:04Z", "path": "catalog/spatial/wfs/spatial-wfs-common/src/test/java/org/codice/ddf/spatial/ogc/wfs/catalog/common/AbstractWfsSourceTest.java", "diffHunk": "@@ -0,0 +1,154 @@\n+/**\n+ * Copyright (c) Codice Foundation\n+ *\n+ * <p>This is free software: you can redistribute it and/or modify it under the terms of the GNU\n+ * Lesser General Public License as published by the Free Software Foundation, either version 3 of\n+ * the License, or any later version.\n+ *\n+ * <p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY;\n+ * without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n+ * GNU Lesser General Public License for more details. A copy of the GNU Lesser General Public\n+ * License is distributed along with this program and can be found at\n+ * <http://www.gnu.org/licenses/lgpl.html>.\n+ */\n+package org.codice.ddf.spatial.ogc.wfs.catalog.common;\n+\n+import static org.hamcrest.MatcherAssert.assertThat;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.hamcrest.core.Is.is;\n+import static org.mockito.Mockito.doReturn;\n+import static org.mockito.Mockito.mock;\n+\n+import ddf.catalog.data.ContentType;\n+import ddf.catalog.data.Metacard;\n+import ddf.catalog.data.Result;\n+import ddf.catalog.operation.QueryRequest;\n+import ddf.catalog.operation.ResourceResponse;\n+import ddf.catalog.operation.SourceResponse;\n+import ddf.catalog.resource.ResourceNotFoundException;\n+import ddf.catalog.resource.ResourceNotSupportedException;\n+import ddf.catalog.source.SourceMonitor;\n+import ddf.catalog.source.UnsupportedQueryException;\n+import java.io.IOException;\n+import java.io.Serializable;\n+import java.net.URI;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import javax.xml.namespace.QName;\n+import org.codice.ddf.spatial.ogc.wfs.catalog.mapper.MetacardMapper;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class AbstractWfsSourceTest {\n+  private AbstractWfsSource wfsSource;\n+  private static final String FEATURE_NAME = \"SampleFeature\";\n+  private static final String TEMPORAL_SORT_PROEPRTY = \"myTemporalSortProperty\";", "originalCommit": "d0e56893db8e5fef87e92e61713c755dc02de99d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "4687ff34cf27dbbcb6d8ff36f62bc42cd27155f7", "url": "https://github.com/codice/ddf/commit/4687ff34cf27dbbcb6d8ff36f62bc42cd27155f7", "message": "DDF-4729 adds WFS 1.1.0 sorting\n\n- adds flag to enable/disable sorting\n- adds mapping of DDF sort attributes to WFS attributes", "committedDate": "2020-11-12T20:59:34Z", "type": "commit"}, {"oid": "823ec2c68199d5c3ea9de8084e13101a5e3cfa5f", "url": "https://github.com/codice/ddf/commit/823ec2c68199d5c3ea9de8084e13101a5e3cfa5f", "message": "code cleanup", "committedDate": "2020-11-12T20:59:34Z", "type": "commit"}, {"oid": "823ec2c68199d5c3ea9de8084e13101a5e3cfa5f", "url": "https://github.com/codice/ddf/commit/823ec2c68199d5c3ea9de8084e13101a5e3cfa5f", "message": "code cleanup", "committedDate": "2020-11-12T20:59:34Z", "type": "forcePushed"}]}