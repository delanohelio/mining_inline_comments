{"pr_number": 9475, "pr_title": "CB 9241 Create load balancer for data lake HA", "pr_createdAt": "2020-11-18T23:14:21Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/9475", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNjc3NzQyOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r526777428", "bodyText": "Nit: remove unnecessary space after metadata().", "author": "lajosrodek", "createdAt": "2020-11-19T11:07:56Z", "path": "cloud-reactor/src/main/java/com/sequenceiq/cloudbreak/cloud/handler/CollectLoadBalancerMetadataHandler.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package com.sequenceiq.cloudbreak.cloud.handler;\n+\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.cloud.CloudConnector;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.event.loadbalancer.CollectLoadBalancerMetadataRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.loadbalancer.CollectLoadBalancerMetadataResult;\n+import com.sequenceiq.cloudbreak.cloud.init.CloudPlatformConnectors;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudLoadBalancerMetadata;\n+\n+import reactor.bus.Event;\n+import reactor.bus.EventBus;\n+\n+@Component\n+public class CollectLoadBalancerMetadataHandler implements CloudPlatformEventHandler<CollectLoadBalancerMetadataRequest> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CollectLoadBalancerMetadataHandler.class);\n+\n+    @Inject\n+    private CloudPlatformConnectors cloudPlatformConnectors;\n+\n+    @Inject\n+    private EventBus eventBus;\n+\n+    @Override\n+    public Class<CollectLoadBalancerMetadataRequest> type() {\n+        return CollectLoadBalancerMetadataRequest.class;\n+    }\n+\n+    @Override\n+    public void accept(Event<CollectLoadBalancerMetadataRequest> collectLBMetadataRequestEvent) {\n+        LOGGER.debug(\"Received event: {}\", collectLBMetadataRequestEvent);\n+        CollectLoadBalancerMetadataRequest request = collectLBMetadataRequestEvent.getData();\n+        try {\n+            CloudConnector<Object> connector = cloudPlatformConnectors.get(request.getCloudContext().getPlatformVariant());\n+            AuthenticatedContext ac = connector.authentication().authenticate(request.getCloudContext(), request.getCloudCredential());\n+\n+            List<CloudLoadBalancerMetadata> loadBalancerStatuses = connector.metadata() .collectLoadBalancer(ac, request.getGatewayGroupNames());", "originalCommit": "de55a4bb1b4971dd8f935faf64cd1e01685b9bb1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2MjQ3OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527162479", "bodyText": "Could do a instanceGroups.stream().filter(group -> InstanceGroupType.Gateway.equals(group.getInstanceGroupType).findAny().orElse(null);", "author": "frozenwizard", "createdAt": "2020-11-19T20:01:27Z", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/Stack.java", "diffHunk": "@@ -574,6 +579,15 @@ public InstanceMetaData getPrimaryGatewayInstance() {\n         return metaData.orElse(null);\n     }\n \n+    public InstanceGroup getGatewayGroup() {\n+        for (InstanceGroup instanceGroup : instanceGroups) {", "originalCommit": "5e43c56ce52d7d662196ebae07c6db60206b53a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIyMjYyMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527222622", "bodyText": "This method was from a pretty early implementation, and I realized it's no longer being called, so it'll be removed in the most recent commit.", "author": "hreeve-cloudera", "createdAt": "2020-11-19T21:45:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2MjQ3OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2MzYwNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527163607", "bodyText": "probably want to do a fetch type of lazy", "author": "frozenwizard", "createdAt": "2020-11-19T20:03:32Z", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/instance/InstanceGroup.java", "diffHunk": "@@ -70,6 +73,9 @@\n \n     private int initialNodeCount;\n \n+    @ManyToMany(mappedBy = \"instanceGroups\", fetch = FetchType.EAGER)", "originalCommit": "5e43c56ce52d7d662196ebae07c6db60206b53a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzMjg2NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527232865", "bodyText": "T'was I who was lazy. I'll change this and add a manual fetch instead.", "author": "hreeve-cloudera", "createdAt": "2020-11-19T22:04:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2MzYwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NDYwNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527164605", "bodyText": "could we just initialize targetgroups = new HashSet<>() at the top of the file?", "author": "frozenwizard", "createdAt": "2020-11-19T20:05:18Z", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/instance/InstanceGroup.java", "diffHunk": "@@ -208,6 +214,21 @@ public void setCloudIdentityType(CloudIdentityType cloudIdentityType) {\n         attributes = new Json(attributeMap);\n     }\n \n+    public Set<TargetGroup> getTargetGroups() {\n+        return targetGroups;\n+    }\n+\n+    public void setTargetGroups(Set<TargetGroup> targetGroups) {\n+        this.targetGroups = targetGroups;\n+    }\n+\n+    public void addTargetGroup(TargetGroup targetGroup) {\n+        if (targetGroups == null) {", "originalCommit": "5e43c56ce52d7d662196ebae07c6db60206b53a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NTM5MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527165391", "bodyText": "Do we need to make this a abstract class and subtype a awsloadbalancer from it so we can later support azure's loadbalancing?", "author": "frozenwizard", "createdAt": "2020-11-19T20:06:53Z", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/LoadBalancer.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.sequenceiq.cloudbreak.domain.stack.loadbalancer;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.OneToMany;\n+import javax.persistence.SequenceGenerator;\n+\n+import com.sequenceiq.cloudbreak.domain.ProvisionEntity;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+\n+@Entity\n+public class LoadBalancer implements ProvisionEntity  {", "originalCommit": "5e43c56ce52d7d662196ebae07c6db60206b53a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNTUwNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527235504", "bodyText": "This is a database entity, so I don't think we should mess with it. It's also in a different module and serves a different purpose (used in an internal stack model vs. the cloud based model) than AwsLoadBalancer. I get what you're saying about having an abstract class we can implement for both cloud platforms. But the AwsLoadBalancer was explicitly modeled to mimic the relationship between load balancers, listeners, and target groups in AWS. Since I don't yet know what the Azure model will look like, I'd rather wait until we have more information about that to see what makes sense to abstract out.", "author": "hreeve-cloudera", "createdAt": "2020-11-19T22:09:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NTM5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NzIzOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527167238", "bodyText": "Is there a jira for this one or is it a later commit in this pr?", "author": "frozenwizard", "createdAt": "2020-11-19T20:10:24Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -335,6 +344,40 @@ private void validateStackAuthentication(StackV4Request source) {\n         return convertedSet;\n     }\n \n+    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n+        Set<LoadBalancer> loadBalancers = new HashSet<>();\n+        Set<TargetGroup> targetGroups = new HashSet<>();\n+        // TODO expand this to data hubs\n+        if (StackType.DATALAKE.equals(source.getType())) {\n+            LOGGER.info(\"Setting up load balancers for stack {}\", source.getName());\n+            Set<String> knoxGatewayGroupNames = loadBalancerConfigService.getKnoxGatewayGroups(stack);\n+            Set<InstanceGroup> knoxGatewayGroups = stack.getInstanceGroups().stream()\n+                .filter(ig -> knoxGatewayGroupNames.contains(ig.getGroupName()))\n+                .collect(Collectors.toSet());\n+            if (!knoxGatewayGroups.isEmpty()) {\n+                LOGGER.info(\"Knox gateway instance found; enabling Knox load balancer configuration.\");\n+                TargetGroup targetGroup = new TargetGroup();\n+                targetGroup.setType(TargetGroupType.KNOX.name());\n+                targetGroup.setInstanceGroups(knoxGatewayGroups);\n+                targetGroups.add(targetGroup);\n+                knoxGatewayGroups.forEach(ig -> ig.addTargetGroup(targetGroup));\n+            }\n+            // TODO create target group for CM instances", "originalCommit": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNjU1MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527236550", "bodyText": "Yes, Bryce is working on figuring out the configuration for CM target groups in CB-9368. I'll put that JIRA in the comment.", "author": "hreeve-cloudera", "createdAt": "2020-11-19T22:11:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NzIzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NzY4Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527167683", "bodyText": "Assuming later commit has this in there?", "author": "frozenwizard", "createdAt": "2020-11-19T20:11:12Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -335,6 +344,40 @@ private void validateStackAuthentication(StackV4Request source) {\n         return convertedSet;\n     }\n \n+    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n+        Set<LoadBalancer> loadBalancers = new HashSet<>();\n+        Set<TargetGroup> targetGroups = new HashSet<>();\n+        // TODO expand this to data hubs\n+        if (StackType.DATALAKE.equals(source.getType())) {\n+            LOGGER.info(\"Setting up load balancers for stack {}\", source.getName());\n+            Set<String> knoxGatewayGroupNames = loadBalancerConfigService.getKnoxGatewayGroups(stack);\n+            Set<InstanceGroup> knoxGatewayGroups = stack.getInstanceGroups().stream()\n+                .filter(ig -> knoxGatewayGroupNames.contains(ig.getGroupName()))\n+                .collect(Collectors.toSet());\n+            if (!knoxGatewayGroups.isEmpty()) {\n+                LOGGER.info(\"Knox gateway instance found; enabling Knox load balancer configuration.\");\n+                TargetGroup targetGroup = new TargetGroup();\n+                targetGroup.setType(TargetGroupType.KNOX.name());\n+                targetGroup.setInstanceGroups(knoxGatewayGroups);\n+                targetGroups.add(targetGroup);\n+                knoxGatewayGroups.forEach(ig -> ig.addTargetGroup(targetGroup));\n+            }\n+            // TODO create target group for CM instances\n+        }\n+\n+        if (!targetGroups.isEmpty()) {\n+            LoadBalancer loadBalancer = new LoadBalancer();\n+            loadBalancer.setStack(stack);\n+            // TODO actually figure out the type we need here", "originalCommit": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNjc1NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527236755", "bodyText": "This is going to be more work than I originally anticipated, so I opened CB-9900 about it. I'll update the comment.", "author": "hreeve-cloudera", "createdAt": "2020-11-19T22:12:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2NzY4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2OTMzNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527169335", "bodyText": "Should this be in an entitlement?", "author": "frozenwizard", "createdAt": "2020-11-19T20:14:12Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -335,6 +344,40 @@ private void validateStackAuthentication(StackV4Request source) {\n         return convertedSet;\n     }\n \n+    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n+        Set<LoadBalancer> loadBalancers = new HashSet<>();", "originalCommit": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNTcxMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527235713", "bodyText": "Yep, the entitlement's coming in the next commit.", "author": "hreeve-cloudera", "createdAt": "2020-11-19T22:09:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE2OTMzNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE3NzgwNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527177804", "bodyText": "What happens if cluster is null?", "author": "frozenwizard", "createdAt": "2020-11-19T20:29:27Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {", "originalCommit": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIzNzQ3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527237474", "bodyText": "Then we don't have a way to check the cluster blueprint, so we don't do anything here and hit the next if that triggers if groupNames is still empty.", "author": "hreeve-cloudera", "createdAt": "2020-11-19T22:13:38Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE3NzgwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4MTYwMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527181602", "bodyText": "More descriptive variable name please.\nAlso i feel like you could just do String s = stack.getname()+\"-\"+ENDPOING_SUFFIX;  and if public +=\"-\"+PUBLIC_SUFFIX.", "author": "frozenwizard", "createdAt": "2020-11-19T20:35:45Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> components = cmTemplateProcessor.getServiceComponentsByHostGroup();\n+            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");\n+            groupNames = components.entrySet().stream()\n+                .filter(e -> e.getValue().stream().anyMatch(c -> KnoxRoles.KNOX_GATEWAY.equals(c.getComponent())))\n+                .map(Map.Entry::getKey)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"Knox gateway is not explicitly defined; searching for CM gateway hosts\");\n+            groupNames = stack.getInstanceGroups().stream()\n+                .filter(i -> InstanceGroupType.isGateway(i.getInstanceGroupType()))\n+                .map(InstanceGroup::getGroupName)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"No Knox gateway instance groups found\");\n+        }\n+        return groupNames;\n+    }\n+\n+    public String generateLoadBalancerEndpoint(Stack stack, LoadBalancerType type) {\n+        List<String> s = Arrays.asList(stack.getName(), ENDPOINT_SUFFIX);", "originalCommit": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0MTIwMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527241203", "bodyText": "Intellij fusses at you if you append strings with \"+\", but I've changed it to a StringBuilder.", "author": "hreeve-cloudera", "createdAt": "2020-11-19T22:17:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4MTYwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4MjQ4MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527182480", "bodyText": "CM?", "author": "frozenwizard", "createdAt": "2020-11-19T20:37:07Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> components = cmTemplateProcessor.getServiceComponentsByHostGroup();\n+            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");\n+            groupNames = components.entrySet().stream()\n+                .filter(e -> e.getValue().stream().anyMatch(c -> KnoxRoles.KNOX_GATEWAY.equals(c.getComponent())))\n+                .map(Map.Entry::getKey)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"Knox gateway is not explicitly defined; searching for CM gateway hosts\");\n+            groupNames = stack.getInstanceGroups().stream()\n+                .filter(i -> InstanceGroupType.isGateway(i.getInstanceGroupType()))\n+                .map(InstanceGroup::getGroupName)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"No Knox gateway instance groups found\");\n+        }\n+        return groupNames;\n+    }\n+\n+    public String generateLoadBalancerEndpoint(Stack stack, LoadBalancerType type) {\n+        List<String> s = Arrays.asList(stack.getName(), ENDPOINT_SUFFIX);\n+        if (LoadBalancerType.PUBLIC.equals(type)) {\n+            s.add(PUBLIC_SUFFIX);\n+        }\n+        return String.join(\"-\", s);\n+    }\n+\n+    public Set<Integer> getPortsForTargetGroup(TargetGroup targetGroup) {\n+        switch (targetGroup.getType()) {\n+            case \"KNOX\":", "originalCommit": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0MTY4OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527241689", "bodyText": "Yep, that's why it's a switch statement, so we can add the CM case when it's ready.", "author": "hreeve-cloudera", "createdAt": "2020-11-19T22:18:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4MjQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4NzgzMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527187833", "bodyText": "Could do a Optional.ofNullable(context.loadBalncers).orElse(new ArrayList());", "author": "frozenwizard", "createdAt": "2020-11-19T20:47:17Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/CloudFormationTemplateBuilder.java", "diffHunk": "@@ -91,6 +92,7 @@ public String build(ModelContext context) {\n         model.put(\"outboundInternetTraffic\", context.outboundInternetTraffic);\n         model.put(\"vpcCidrs\", context.vpcCidrs);\n         model.put(\"prefixListIds\", context.prefixListIds);\n+        model.put(\"loadBalancers\", context.loadBalancers == null ? new ArrayList<>() : context.loadBalancers);", "originalCommit": "2ed3b72c53f6bf1676d0a131295045c8dd203b4f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4OTkwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527189909", "bodyText": "there's a findFirst() you can use instead.", "author": "frozenwizard", "createdAt": "2020-11-19T20:51:10Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "diffHunk": "@@ -171,9 +164,128 @@\n \n         awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, stack, regionName, credentialView);\n \n+        updateCloudformationWithLoadBalancer(ac, stack, resourceNotifier, modelContext, instances);\n+\n         return awsResourceConnector.check(ac, instances);\n     }\n \n+    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier) {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonEC2Client amazonEC2Client = awsClient.createAccess(credentialView, regionName);\n+        Network network = stack.getNetwork();\n+        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n+        boolean mapPublicIpOnLaunch = awsNetworkService.isMapPublicOnLaunch(awsNetworkView, amazonEC2Client);\n+\n+        boolean existingVPC = awsNetworkView.isExistingVPC();\n+        boolean existingSubnet = awsNetworkView.isExistingSubnet();\n+\n+        String cidr = network.getSubnet().getCidr();\n+        String subnet = isNoCIDRProvided(existingVPC, existingSubnet, cidr) ? awsNetworkService.findNonOverLappingCIDR(ac, stack) : cidr;\n+        AwsInstanceProfileView awsInstanceProfileView = new AwsInstanceProfileView(stack);\n+        ModelContext modelContext = new ModelContext()\n+            .withAuthenticatedContext(ac)\n+            .withStack(stack)\n+            .withExistingVpc(existingVPC)\n+            .withExistingIGW(awsNetworkView.isExistingIGW())\n+            .withExistingSubnetCidr(existingSubnet ? awsNetworkService.getExistingSubnetCidr(ac, stack) : null)\n+            .withExistinVpcCidr(awsNetworkService.getVpcCidrs(ac, stack))\n+            .withExistingSubnetIds(existingSubnet ? awsNetworkView.getSubnetList() : null)\n+            .mapPublicIpOnLaunch(mapPublicIpOnLaunch)\n+            .withEnableInstanceProfile(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withInstanceProfileAvailable(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withTemplate(stack.getTemplate())\n+            .withDefaultSubnet(subnet)\n+            .withOutboundInternetTraffic(network.getOutboundInternetTraffic())\n+            .withVpcCidrs(network.getNetworkCidrs())\n+            .withPrefixListIds(getPrefixListIds(amazonEC2Client, regionName, network.getOutboundInternetTraffic()))\n+            .withEncryptedAMIByGroupName(encryptedImageCopyService.createEncryptedImages(ac, stack, resourceNotifier));\n+\n+        return modelContext;\n+    }\n+\n+    private void updateCloudformationWithLoadBalancer(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier,\n+            ModelContext modelContext, List<CloudResource> instances) {\n+\n+        if (stack.getLoadBalancers().isPresent() && !stack.getLoadBalancers().get().isEmpty()) {\n+            if (modelContext == null) {\n+                modelContext = buildDefaultModelContext(ac, stack, resourceNotifier);\n+            }\n+\n+            List<AwsLoadBalancer> awsLoadBalancers = new ArrayList<>();\n+            List<CloudLoadBalancer> cloudLoadBalancers = stack.getLoadBalancers().get();\n+            for (CloudLoadBalancer cloudLoadBalancer : cloudLoadBalancers) {\n+                awsLoadBalancers.add(convert(cloudLoadBalancer, stack, instances));\n+            }\n+\n+            modelContext.withLoadBalancers(awsLoadBalancers);\n+            ListStackResourcesResult result = updateCloudFormationStack(ac, stack, modelContext);\n+\n+            for (AwsLoadBalancer loadBalancer : awsLoadBalancers) {\n+                for (AwsListener listener : loadBalancer.getListeners()) {\n+                    for (AwsTargetGroup targetGroup : listener.getTargetGroups()) {\n+                        StackResourceSummary targetGroupSummary = result.getStackResourceSummaries().stream()\n+                            .filter(stackResourceSummary -> targetGroup.getName().equals(stackResourceSummary.getLogicalResourceId()))\n+                            .collect(Collectors.toList())\n+                            .get(0);", "originalCommit": "2ed3b72c53f6bf1676d0a131295045c8dd203b4f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4OTk1Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527189957", "bodyText": "findFirst()", "author": "frozenwizard", "createdAt": "2020-11-19T20:51:16Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "diffHunk": "@@ -171,9 +164,128 @@\n \n         awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, stack, regionName, credentialView);\n \n+        updateCloudformationWithLoadBalancer(ac, stack, resourceNotifier, modelContext, instances);\n+\n         return awsResourceConnector.check(ac, instances);\n     }\n \n+    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier) {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonEC2Client amazonEC2Client = awsClient.createAccess(credentialView, regionName);\n+        Network network = stack.getNetwork();\n+        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n+        boolean mapPublicIpOnLaunch = awsNetworkService.isMapPublicOnLaunch(awsNetworkView, amazonEC2Client);\n+\n+        boolean existingVPC = awsNetworkView.isExistingVPC();\n+        boolean existingSubnet = awsNetworkView.isExistingSubnet();\n+\n+        String cidr = network.getSubnet().getCidr();\n+        String subnet = isNoCIDRProvided(existingVPC, existingSubnet, cidr) ? awsNetworkService.findNonOverLappingCIDR(ac, stack) : cidr;\n+        AwsInstanceProfileView awsInstanceProfileView = new AwsInstanceProfileView(stack);\n+        ModelContext modelContext = new ModelContext()\n+            .withAuthenticatedContext(ac)\n+            .withStack(stack)\n+            .withExistingVpc(existingVPC)\n+            .withExistingIGW(awsNetworkView.isExistingIGW())\n+            .withExistingSubnetCidr(existingSubnet ? awsNetworkService.getExistingSubnetCidr(ac, stack) : null)\n+            .withExistinVpcCidr(awsNetworkService.getVpcCidrs(ac, stack))\n+            .withExistingSubnetIds(existingSubnet ? awsNetworkView.getSubnetList() : null)\n+            .mapPublicIpOnLaunch(mapPublicIpOnLaunch)\n+            .withEnableInstanceProfile(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withInstanceProfileAvailable(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withTemplate(stack.getTemplate())\n+            .withDefaultSubnet(subnet)\n+            .withOutboundInternetTraffic(network.getOutboundInternetTraffic())\n+            .withVpcCidrs(network.getNetworkCidrs())\n+            .withPrefixListIds(getPrefixListIds(amazonEC2Client, regionName, network.getOutboundInternetTraffic()))\n+            .withEncryptedAMIByGroupName(encryptedImageCopyService.createEncryptedImages(ac, stack, resourceNotifier));\n+\n+        return modelContext;\n+    }\n+\n+    private void updateCloudformationWithLoadBalancer(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier,\n+            ModelContext modelContext, List<CloudResource> instances) {\n+\n+        if (stack.getLoadBalancers().isPresent() && !stack.getLoadBalancers().get().isEmpty()) {\n+            if (modelContext == null) {\n+                modelContext = buildDefaultModelContext(ac, stack, resourceNotifier);\n+            }\n+\n+            List<AwsLoadBalancer> awsLoadBalancers = new ArrayList<>();\n+            List<CloudLoadBalancer> cloudLoadBalancers = stack.getLoadBalancers().get();\n+            for (CloudLoadBalancer cloudLoadBalancer : cloudLoadBalancers) {\n+                awsLoadBalancers.add(convert(cloudLoadBalancer, stack, instances));\n+            }\n+\n+            modelContext.withLoadBalancers(awsLoadBalancers);\n+            ListStackResourcesResult result = updateCloudFormationStack(ac, stack, modelContext);\n+\n+            for (AwsLoadBalancer loadBalancer : awsLoadBalancers) {\n+                for (AwsListener listener : loadBalancer.getListeners()) {\n+                    for (AwsTargetGroup targetGroup : listener.getTargetGroups()) {\n+                        StackResourceSummary targetGroupSummary = result.getStackResourceSummaries().stream()\n+                            .filter(stackResourceSummary -> targetGroup.getName().equals(stackResourceSummary.getLogicalResourceId()))\n+                            .collect(Collectors.toList())\n+                            .get(0);\n+                        targetGroup.setArn(targetGroupSummary.getPhysicalResourceId());\n+                    }\n+                }\n+                StackResourceSummary loadBalancerSummary = result.getStackResourceSummaries().stream()\n+                    .filter(stackResourceSummary -> loadBalancer.getName().equals(stackResourceSummary.getLogicalResourceId()))", "originalCommit": "2ed3b72c53f6bf1676d0a131295045c8dd203b4f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5MTQ4MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527191480", "bodyText": "huh?  capatilize into lower case?", "author": "frozenwizard", "createdAt": "2020-11-19T20:54:07Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsTargetGroup.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class AwsTargetGroup {\n+\n+    private static final String TARGET_GROUP_NAME_PREFIX = \"TargetGroupPort\";\n+\n+    private final int port;\n+\n+    private final String name;\n+\n+    private final int order;\n+\n+    private final List<String> instanceIds;\n+\n+    private String arn;\n+\n+    public AwsTargetGroup(int port, AwsLoadBalancerScheme scheme, int order, List<String> instanceIds) {\n+        this.port = port;\n+        this.order = order;\n+        this.instanceIds = instanceIds;\n+        name = getTargetGroupName(port, scheme);\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public String getArn() {\n+        return arn;\n+    }\n+\n+    public void setArn(String arn) {\n+        this.arn = arn;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public int getOrder() {\n+        return order;\n+    }\n+\n+    public List<String> getInstanceIds() {\n+        return instanceIds;\n+    }\n+\n+    private static String getTargetGroupName(int port, AwsLoadBalancerScheme scheme) {\n+        return TARGET_GROUP_NAME_PREFIX + port +\n+            StringUtils.capitalize(scheme.name().toLowerCase());", "originalCommit": "2ed3b72c53f6bf1676d0a131295045c8dd203b4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0NTEyNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527245127", "bodyText": "Technically lowercase into capitalize, so PRIVATE becomes Private. I couldn't find a more elegant way to do it. There's no real reason to be this nitpicky about the capitalization, I just think it looks better to have LoadBalancerPrivate instead of LoadBalancerprivate or LoadBalancerPRIVATE.", "author": "hreeve-cloudera", "createdAt": "2020-11-19T22:25:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5MTQ4MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5MjcwOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527192708", "bodyText": "jira?", "author": "frozenwizard", "createdAt": "2020-11-19T20:56:17Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java", "diffHunk": "@@ -171,4 +176,30 @@ private void addKnownInstance(CloudInstance cloudInstance, Multimap<String, Inst\n                 .flatMap(reservation -> reservation.getInstances().stream())\n                 .collect(Collectors.toList());\n     }\n+\n+    @Override\n+    public List<CloudLoadBalancerMetadata> collectLoadBalancer(AuthenticatedContext ac, List<String> gatewayGroupNames) {\n+        LOGGER.debug(\"Collect AWS load balanacer metadata, for cluster {}\", ac.getCloudContext().getName());\n+\n+        String region = ac.getCloudContext().getLocation().getRegion().value();\n+\n+        List<CloudLoadBalancerMetadata> cloudLoadBalancerMetadata = new ArrayList<>();\n+        try {\n+            for (String groupName : gatewayGroupNames) {\n+                String loadBalancerName = AwsLoadBalancer.getLoadBalancerName(AwsLoadBalancerScheme.PRIVATE);\n+                LoadBalancer loadBalancer = cloudFormationStackUtil.getLoadBalancerByLogicalId(ac, loadBalancerName, region);\n+                cloudLoadBalancerMetadata.add(new CloudLoadBalancerMetadata(\n+                    groupName,\n+                    LoadBalancerType.PRIVATE,\n+                    loadBalancer.getDNSName(),\n+                    loadBalancer.getCanonicalHostedZoneId(),\n+                    null\n+                ));\n+                // TODO public endpoints", "originalCommit": "de55a4bb1b4971dd8f935faf64cd1e01685b9bb1", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzI0MjM4OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527242388", "bodyText": "Old comment. Deleted it and changed LoadBalancerType.PRIVATE to LoadBalancerType.valueOf(type), which should handle either case.", "author": "hreeve-cloudera", "createdAt": "2020-11-19T22:19:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5MjcwOA=="}], "type": "inlineReview"}, {"oid": "6d89db90bbc4014d490a9f57fa21920c583a753c", "url": "https://github.com/hortonworks/cloudbreak/commit/6d89db90bbc4014d490a9f57fa21920c583a753c", "message": "Puts load balancer creation logic behind new CDP_LOAD_BALANCER entitlement.\nFixes a bug from earlier commit that was hit when trying to do a collected\nload balancer metadata action on a data lake with no load balancer. Initial\nreview changes.", "committedDate": "2020-11-20T00:16:55Z", "type": "forcePushed"}, {"oid": "9135c5e07472800ad49f077d0c2a90995404f308", "url": "https://github.com/hortonworks/cloudbreak/commit/9135c5e07472800ad49f077d0c2a90995404f308", "message": "Puts load balancer creation logic behind new CDP_LOAD_BALANCER entitlement.\nFixes a bug from earlier commit that was hit when trying to do a collected\nload balancer metadata action on a data lake with no load balancer. Initial\nreview changes.", "committedDate": "2020-11-20T16:25:43Z", "type": "forcePushed"}, {"oid": "13ceaf192fc8588e41c803e6764c650de33d9d8d", "url": "https://github.com/hortonworks/cloudbreak/commit/13ceaf192fc8588e41c803e6764c650de33d9d8d", "message": "Puts load balancer creation logic behind new CDP_LOAD_BALANCER entitlement.\nFixes a bug from earlier commit that was hit when trying to do a collected\nload balancer metadata action on a data lake with no load balancer. Initial\nreview changes.", "committedDate": "2020-11-20T16:59:43Z", "type": "forcePushed"}, {"oid": "a90cb7616434e79f07beb3b2521875754c0f15b0", "url": "https://github.com/hortonworks/cloudbreak/commit/a90cb7616434e79f07beb3b2521875754c0f15b0", "message": "Puts load balancer creation logic behind new CDP_LOAD_BALANCER entitlement.\nFixes a bug from earlier commit that was hit when trying to do a collected\nload balancer metadata action on a data lake with no load balancer. Initial\nreview changes.", "committedDate": "2020-11-20T22:27:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4MjMzNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527182336", "bodyText": "question: I see that we're typing ProvisionEntity in lots of places, but I don't see anywhere that it's used to narrow a type or provide for multiple implementations. It looks like it's just an extension of Serializable -- is that the case?", "author": "brycederriso", "createdAt": "2020-11-19T20:36:53Z", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/TargetGroup.java", "diffHunk": "@@ -0,0 +1,55 @@\n+package com.sequenceiq.cloudbreak.domain.stack.loadbalancer;\n+\n+import com.sequenceiq.cloudbreak.domain.ProvisionEntity;\n+import java.util.Set;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToMany;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.SequenceGenerator;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+\n+@Entity\n+public class TargetGroup implements ProvisionEntity {", "originalCommit": "5e43c56ce52d7d662196ebae07c6db60206b53a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyMTQ1Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r528021453", "bodyText": "Yes. There's some check in the code that makes sure all database entity classes are serializable, and that's done through the ProvisionEntity interface. I don't know if that has something to do with JPA or is a CB requirement, but the build won't work without it.", "author": "hreeve-cloudera", "createdAt": "2020-11-20T23:22:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4MjMzNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4NTEwNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527185104", "bodyText": "suggestion: LoadBalancerPersistenceService maybe? I'm not generally a huge fan of the @Service ...Service pattern of naming.\nI think it's clearer to indicate that this deals with the persistence aspects of Load balancer entities.", "author": "brycederriso", "createdAt": "2020-11-19T20:42:17Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/stack/LoadBalancerService.java", "diffHunk": "@@ -0,0 +1,29 @@\n+package com.sequenceiq.cloudbreak.service.stack;\n+\n+import java.util.Set;\n+\n+import javax.inject.Inject;\n+\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.LoadBalancer;\n+import com.sequenceiq.cloudbreak.repository.LoadBalancerRepository;\n+\n+@Service\n+public class LoadBalancerService {", "originalCommit": "5e43c56ce52d7d662196ebae07c6db60206b53a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyODU4Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r528028587", "bodyText": "I'm fine with that. But so you know there a lot of @Service ...Service class names in this part of the code. :)", "author": "hreeve-cloudera", "createdAt": "2020-11-20T23:49:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE4NTEwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5OTY2NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527199665", "bodyText": "suggestion: Consider using an empty List here instead of null.\nI'd prefer the semantics of an empty List<CloudLoadBalancer> over Optional<List<CloudLoadBalancer> as well.\nI'd only expect that to throw a wrench in maybe serialization? Are there other reasons you chose Optional over an empty list?", "author": "brycederriso", "createdAt": "2020-11-19T21:08:56Z", "path": "cloud-api/src/main/java/com/sequenceiq/cloudbreak/cloud/model/CloudStack.java", "diffHunk": "@@ -33,8 +33,16 @@\n \n     private final Optional<SpiFileSystem> fileSystem;\n \n+    private final Optional<List<CloudLoadBalancer>> loadBalancers;\n+\n     public CloudStack(Collection<Group> groups, Network network, Image image, Map<String, String> parameters, Map<String, String> tags, String template,\n             InstanceAuthentication instanceAuthentication, String loginUserName, String publicKey, SpiFileSystem fileSystem) {\n+        this(groups, network, image, parameters, tags, template, instanceAuthentication, loginUserName, publicKey, fileSystem, null);", "originalCommit": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNzUyMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r528027523", "bodyText": "Serialization should be fine. I've been working on these changes for about a month, and I think the optional choice was made here when I thought there would only be a single load balancer, and I just never updated it when I changed that to a list. But that makes sense, and I'll change it to empty list.", "author": "hreeve-cloudera", "createdAt": "2020-11-20T23:44:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzE5OTY2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyNzIwMDIzOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r527200238", "bodyText": "praise: Thank you for not making these just String constants!\nLove me some enums.", "author": "brycederriso", "createdAt": "2020-11-19T21:09:51Z", "path": "common-model/src/main/java/com/sequenceiq/common/api/type/LoadBalancerType.java", "diffHunk": "@@ -0,0 +1,6 @@\n+package com.sequenceiq.common.api.type;\n+\n+public enum LoadBalancerType {", "originalCommit": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwMjYxNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r528002614", "bodyText": "question: The body of this if is adding knox TargetGroups to the targetGroups set if the stack we're working with is a Datalake?\nIf possible, I think it would be clearer to move the knoxGatewayGroups out of the if block and do an else:\n    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n        Set<LoadBalancer> loadBalancers = new HashSet<>();\n        Set<TargetGroup> targetGroups = new HashSet<>();\n        // TODO expand this to data hubs\n\n        Set<String> knoxGatewayGroupNames = loadBalancerConfigService.getKnoxGatewayGroups(stack);\n        Set<InstanceGroup> knoxGatewayGroups = stack.getInstanceGroups().stream()\n                .filter(ig -> knoxGatewayGroupNames.contains(ig.getGroupName()))\n                .collect(Collectors.toSet());\n\n        if (StackType.DATALAKE.equals(source.getType()) && !knoxGatewayGroups.isEmpty()) {\n            LOGGER.info(\"Setting up load balancers for stack {}\", source.getName());\n            LOGGER.info(\"Knox gateway instance found; enabling Knox load balancer configuration.\");\n            TargetGroup targetGroup = new TargetGroup();\n            targetGroup.setType(TargetGroupType.KNOX.name());\n            targetGroup.setInstanceGroups(knoxGatewayGroups);\n            targetGroups.add(targetGroup);\n            // TODO create target group for CM instances\n        } else {\n            LoadBalancer loadBalancer = new LoadBalancer();\n            loadBalancer.setStack(stack);\n            // TODO actually figure out the type we need here\n            loadBalancer.setType(LoadBalancerType.PRIVATE.name());\n            loadBalancer.setTargetGroups(targetGroups);\n            targetGroups.forEach(tg -> tg.setLoadBalancer(loadBalancer));\n            loadBalancers.add(loadBalancer);\n        }\n\n        return loadBalancers;\n    }", "author": "brycederriso", "createdAt": "2020-11-20T22:23:11Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/converter/v4/stacks/StackV4RequestToStackConverter.java", "diffHunk": "@@ -335,6 +344,40 @@ private void validateStackAuthentication(StackV4Request source) {\n         return convertedSet;\n     }\n \n+    private Set<LoadBalancer> createLoadBalancers(StackV4Request source, Stack stack) {\n+        Set<LoadBalancer> loadBalancers = new HashSet<>();\n+        Set<TargetGroup> targetGroups = new HashSet<>();\n+        // TODO expand this to data hubs\n+        if (StackType.DATALAKE.equals(source.getType())) {\n+            LOGGER.info(\"Setting up load balancers for stack {}\", source.getName());", "originalCommit": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNzQ1NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r528027455", "bodyText": "My intention was to limit the stack types that could have load balancers at all to only data lakes. If it's any other kind of stack we shouldn't add anything to the target groups at all. So having an else at all is anathema to that. It's a gatekeeping if.\nThe way target groups work is they're just a type of traffic and the instance groups that traffic is forwarded to. In the else you're creating target groups, but not setting either of those properties. Which is basically saying to the load balancer, \"I want you to forward traffic, but I'm not going to tell you what traffic to forward or where it's going.\" Which is making me realize I should really mark those fields as non-null so we know they need to be set.\nWith that in mind, do you have any suggestions on how to clarify it?", "author": "hreeve-cloudera", "createdAt": "2020-11-20T23:44:37Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAwMjYxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAxNDYwNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r528014606", "bodyText": "suggestion: I'd generally prefer not to double nest streams like this, but I'm not sure it's avoidable here.\nYou could extract a function hostGroupContainsKnoxGateway that contains the e -> e.getValue().stream().anyMatch(c -> KnoxRoles.KNOX_GATEWAY.equals(c.getComponent())) portion and then do:\n            groupNames = components.entrySet().stream()\n                .filter(hostGroupContainsKnoxGateway)\n                .map(Map.Entry::getKey)\n                .collect(Collectors.toSet());\nBut, barring that, consider expanding the lambda function parameters e and c into what they they actually represent -- entry and serviceComponent I think.", "author": "brycederriso", "createdAt": "2020-11-20T22:58:58Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,80 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> components = cmTemplateProcessor.getServiceComponentsByHostGroup();\n+            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");\n+            groupNames = components.entrySet().stream()\n+                .filter(e -> e.getValue().stream().anyMatch(c -> KnoxRoles.KNOX_GATEWAY.equals(c.getComponent())))", "originalCommit": "f2bf0c1f201d9b486f2da3f6f2f3cef16ad9c26d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAyNzQwMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r528027400", "bodyText": "I can do a separate function to make it more readable.", "author": "hreeve-cloudera", "createdAt": "2020-11-20T23:44:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyODAxNDYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUyOTIwMzc0Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r529203743", "bodyText": "do you want to also rename the variable name to match the remaining refactoring.", "author": "enis", "createdAt": "2020-11-24T04:59:51Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/stack/flow/MetadataSetupService.java", "diffHunk": "@@ -54,7 +54,7 @@\n     private InstanceMetaDataService instanceMetaDataService;\n \n     @Inject\n-    private LoadBalancerService loadBalancerMetadataService;\n+    private LoadBalancerPersistenceService loadBalancerMetadataService;", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwMzY4Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530003686", "bodyText": "Just linking https://github.infra.cloudera.com/thunderhead/thunderhead/pull/2780 for other reviewers.", "author": "enis", "createdAt": "2020-11-24T23:29:23Z", "path": "auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/model/Entitlement.java", "diffHunk": "@@ -33,5 +33,6 @@\n     DATAHUB_AZURE_AUTOSCALING,\n     CDP_CB_DATABASE_WIRE_ENCRYPTION,\n     CDP_ENABLE_DISTROX_INSTANCE_TYPES,\n-    CDP_SHOW_CLI;\n+    CDP_SHOW_CLI,\n+    CDP_DL_LOAD_BALANCER;", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwODI4Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530008286", "bodyText": "AWS load balancers bind to 1 ip per subnet for better cross-AZ availability. I think you should make this a List instead.", "author": "enis", "createdAt": "2020-11-24T23:34:15Z", "path": "cloud-api/src/main/java/com/sequenceiq/cloudbreak/cloud/model/CloudLoadBalancerMetadata.java", "diffHunk": "@@ -0,0 +1,37 @@\n+package com.sequenceiq.cloudbreak.cloud.model;\n+\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+public class CloudLoadBalancerMetadata {\n+\n+    private final LoadBalancerType type;\n+\n+    private final String cloudDns;\n+\n+    private final String hostedZoneId;\n+\n+    private final String ip;", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY3ODgwMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532678801", "bodyText": "The ip field isn't used for AWS load balancers at all. We instead use the dns and hostedZoneId. I put this here because my understanding is that Azure LBs use IPs, so we'll need an ip field eventually. But if it needs to be a list we'll update it when the Azure work is being done.", "author": "hreeve-cloudera", "createdAt": "2020-11-30T15:24:45Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAwODI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxMTk4OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530011988", "bodyText": "I do not see these two methods being used.", "author": "enis", "createdAt": "2020-11-24T23:38:07Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsClient.java", "diffHunk": "@@ -170,6 +172,23 @@ public AmazonCloudFormationRetryClient createCloudFormationRetryClient(AmazonClo\n         return new AmazonCloudFormationRetryClient(amazonCloudFormationClient, retry);\n     }\n \n+    public AmazonElasticLoadBalancingClient createElasticLoadBalancingClient(AwsCredentialView awsCredential, String regionName) {\n+        AmazonElasticLoadBalancingClient client = isRoleAssumeRequired(awsCredential) ?\n+            new AmazonElasticLoadBalancingClient(createAwsSessionCredentialProvider(awsCredential), getDefaultClientConfiguration()) :\n+            new AmazonElasticLoadBalancingClient(createAwsCredentials(awsCredential), getDefaultClientConfiguration());\n+        client.setRegion(RegionUtils.getRegion(regionName));\n+        client.addRequestHandler(new AwsTracingRequestHandler(tracer));\n+        return client;\n+    }\n+\n+    public AmazonElbV2RetryClient createElbV2RetryClient(AwsCredentialView awsCredential, String regionName) {", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxMjA3Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530012076", "bodyText": "same here.", "author": "enis", "createdAt": "2020-11-24T23:38:13Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsClient.java", "diffHunk": "@@ -170,6 +172,23 @@ public AmazonCloudFormationRetryClient createCloudFormationRetryClient(AmazonClo\n         return new AmazonCloudFormationRetryClient(amazonCloudFormationClient, retry);\n     }\n \n+    public AmazonElasticLoadBalancingClient createElasticLoadBalancingClient(AwsCredentialView awsCredential, String regionName) {\n+        AmazonElasticLoadBalancingClient client = isRoleAssumeRequired(awsCredential) ?\n+            new AmazonElasticLoadBalancingClient(createAwsSessionCredentialProvider(awsCredential), getDefaultClientConfiguration()) :\n+            new AmazonElasticLoadBalancingClient(createAwsCredentials(awsCredential), getDefaultClientConfiguration());\n+        client.setRegion(RegionUtils.getRegion(regionName));\n+        client.addRequestHandler(new AwsTracingRequestHandler(tracer));\n+        return client;\n+    }\n+\n+    public AmazonElbV2RetryClient createElbV2RetryClient(AwsCredentialView awsCredential, String regionName) {\n+        return new AmazonElbV2RetryClient(createElasticLoadBalancingClient(awsCredential, regionName), retry);\n+    }\n+\n+    public AmazonElbV2RetryClient createElbV2RetryClient(AmazonElasticLoadBalancingClient amazonElasticLoadBalancingClient) {", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxNjA3MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530016070", "bodyText": "AWS and Azure calls these \"Internal\" load balancers rather than public / private. In AWS, they are called \"internet-facing\".\nLoadBalancerType in AWS is a selection between \"ELB\", \"NLB\", or \"ALB\" versus the internal vs internet-facing is called \"load balancer scheme\". See https://docs.aws.amazon.com/elasticloadbalancing/latest/userguide/how-elastic-load-balancing-works.html.\nWe do not necessarily need to follow the same naming, but just a sugestion if we want to be consistent with the cloud providers.", "author": "enis", "createdAt": "2020-11-24T23:44:17Z", "path": "common-model/src/main/java/com/sequenceiq/common/api/type/LoadBalancerType.java", "diffHunk": "@@ -0,0 +1,6 @@\n+package com.sequenceiq.common.api.type;\n+\n+public enum LoadBalancerType {\n+    PUBLIC,\n+    PRIVATE", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY4MTg3OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532681878", "bodyText": "The purpose of this module is to provide a cloud provider agnostic modeling of the cloud resources. So I don't feel any particular need to follow the cloud provide convention super closely. Especially since I only know the AWS convention, so following that might just mean we're contradicting the Azure convention.\nI am considering changing these to INTERNAL and EXTERNAL, but I'm going to think about that and make the change later if necessary.", "author": "hreeve-cloudera", "createdAt": "2020-11-30T15:28:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxNjA3MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxNjYzNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530016634", "bodyText": "nit: typo in balanacer", "author": "enis", "createdAt": "2020-11-24T23:45:45Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java", "diffHunk": "@@ -171,4 +176,28 @@ private void addKnownInstance(CloudInstance cloudInstance, Multimap<String, Inst\n                 .flatMap(reservation -> reservation.getInstances().stream())\n                 .collect(Collectors.toList());\n     }\n+\n+    @Override\n+    public List<CloudLoadBalancerMetadata> collectLoadBalancer(AuthenticatedContext ac, List<String> loadBalancerTypes) {\n+        LOGGER.debug(\"Collect AWS load balanacer metadata, for cluster {}\", ac.getCloudContext().getName());", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxNzM5MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530017391", "bodyText": "we do not have access to the ip at this point?", "author": "enis", "createdAt": "2020-11-24T23:48:06Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsMetadataCollector.java", "diffHunk": "@@ -171,4 +176,28 @@ private void addKnownInstance(CloudInstance cloudInstance, Multimap<String, Inst\n                 .flatMap(reservation -> reservation.getInstances().stream())\n                 .collect(Collectors.toList());\n     }\n+\n+    @Override\n+    public List<CloudLoadBalancerMetadata> collectLoadBalancer(AuthenticatedContext ac, List<String> loadBalancerTypes) {\n+        LOGGER.debug(\"Collect AWS load balanacer metadata, for cluster {}\", ac.getCloudContext().getName());\n+\n+        String region = ac.getCloudContext().getLocation().getRegion().value();\n+\n+        List<CloudLoadBalancerMetadata> cloudLoadBalancerMetadata = new ArrayList<>();\n+        try {\n+            for (String type : loadBalancerTypes) {\n+                String loadBalancerName = AwsLoadBalancer.getLoadBalancerName(AwsLoadBalancerScheme.valueOf(type));\n+                LoadBalancer loadBalancer = cloudFormationStackUtil.getLoadBalancerByLogicalId(ac, loadBalancerName, region);\n+                cloudLoadBalancerMetadata.add(new CloudLoadBalancerMetadata(\n+                    LoadBalancerType.valueOf(type),\n+                    loadBalancer.getDNSName(),\n+                    loadBalancer.getCanonicalHostedZoneId(),\n+                    null", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY4MzA5MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532683091", "bodyText": "No. For AWS load balancers we use the cloud DNS name and hostedZoneId, not the IP address.", "author": "hreeve-cloudera", "createdAt": "2020-11-30T15:30:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxNzM5MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAxOTk2OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530019968", "bodyText": "Do you want to rename subnet to newSubnetCidr to match the one in getStackParameters. I am assuming that this is the CIDR for the subnet.", "author": "enis", "createdAt": "2020-11-24T23:55:56Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsStackRequestHelper.java", "diffHunk": "@@ -86,6 +87,20 @@ public DeleteStackRequest createDeleteStackRequest(String cFStackName) {\n                 .withStackName(cFStackName);\n     }\n \n+    public UpdateStackRequest createUpdateStackRequest(AuthenticatedContext ac, CloudStack stack, String cFStackName, String subnet, String cfTemplate) {\n+        return new UpdateStackRequest()\n+            .withStackName(cFStackName)\n+            .withTemplateBody(cfTemplate)\n+            .withTags(awsTaggingService.prepareCloudformationTags(ac, stack.getTags()))\n+            .withCapabilities(CAPABILITY_IAM)\n+            .withParameters(getStackParameters(ac, stack, cFStackName, subnet));", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMDIxNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530020214", "bodyText": "This overloads the function defined above. I suggest moving it to be just below that, and changing that function definition to call this with subnet = null", "author": "enis", "createdAt": "2020-11-24T23:56:48Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/AwsStackRequestHelper.java", "diffHunk": "@@ -86,6 +87,20 @@ public DeleteStackRequest createDeleteStackRequest(String cFStackName) {\n                 .withStackName(cFStackName);\n     }\n \n+    public UpdateStackRequest createUpdateStackRequest(AuthenticatedContext ac, CloudStack stack, String cFStackName, String subnet, String cfTemplate) {", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjgzMzQ2MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532833461", "bodyText": "I took a closer look and realized we didn't need two different methods, so I've removed this one and am using the other createUpdateStackRequest method.", "author": "hreeve-cloudera", "createdAt": "2020-11-30T19:09:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMDIxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMTQ2Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530021462", "bodyText": "should be named describeLoadBalancers()", "author": "enis", "createdAt": "2020-11-25T00:00:37Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/client/AmazonElbV2RetryClient.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.client;\n+\n+import com.amazonaws.services.elasticloadbalancingv2.AmazonElasticLoadBalancingClient;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeLoadBalancersRequest;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeLoadBalancersResult;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeTargetGroupsRequest;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeTargetGroupsResult;\n+import com.sequenceiq.cloudbreak.service.Retry;\n+\n+public class AmazonElbV2RetryClient extends AmazonRetryClient {\n+\n+    private final AmazonElasticLoadBalancingClient client;\n+\n+    private final Retry retry;\n+\n+    public AmazonElbV2RetryClient(AmazonElasticLoadBalancingClient client, Retry retry) {\n+        this.client = client;\n+        this.retry = retry;\n+    }\n+\n+    public DescribeLoadBalancersResult describeLoadBalancer(DescribeLoadBalancersRequest request) {", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY4NzE0Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532687143", "bodyText": "Looking at this class made me realize I'm not actually using it anymore, so I'm deleting it.", "author": "hreeve-cloudera", "createdAt": "2020-11-30T15:35:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMTQ2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyMTU1NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530021554", "bodyText": "Should be named describeTargetGroups()", "author": "enis", "createdAt": "2020-11-25T00:00:59Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/client/AmazonElbV2RetryClient.java", "diffHunk": "@@ -0,0 +1,28 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.client;\n+\n+import com.amazonaws.services.elasticloadbalancingv2.AmazonElasticLoadBalancingClient;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeLoadBalancersRequest;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeLoadBalancersResult;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeTargetGroupsRequest;\n+import com.amazonaws.services.elasticloadbalancingv2.model.DescribeTargetGroupsResult;\n+import com.sequenceiq.cloudbreak.service.Retry;\n+\n+public class AmazonElbV2RetryClient extends AmazonRetryClient {\n+\n+    private final AmazonElasticLoadBalancingClient client;\n+\n+    private final Retry retry;\n+\n+    public AmazonElbV2RetryClient(AmazonElasticLoadBalancingClient client, Retry retry) {\n+        this.client = client;\n+        this.retry = retry;\n+    }\n+\n+    public DescribeLoadBalancersResult describeLoadBalancer(DescribeLoadBalancersRequest request) {\n+        return retry.testWith2SecDelayMax15Times(() -> mapThrottlingError(() -> client.describeLoadBalancers(request)));\n+    }\n+\n+    public DescribeTargetGroupsResult describeLoadBalancer(DescribeTargetGroupsRequest request) {", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyNjg2Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530026867", "bodyText": "some of these exist already in the scope  in the above call to this function. Maybe you can look at sending these to the function rather than recreating.", "author": "enis", "createdAt": "2020-11-25T00:17:11Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "diffHunk": "@@ -171,9 +165,132 @@\n \n         awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, stack, regionName, credentialView);\n \n+        updateCloudformationWithLoadBalancer(ac, stack, resourceNotifier, modelContext, instances);\n+\n         return awsResourceConnector.check(ac, instances);\n     }\n \n+    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier) {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonEC2Client amazonEC2Client = awsClient.createAccess(credentialView, regionName);", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyNzExNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530027114", "bodyText": "nit: rename to updateCloudformationWithLoadBalancers()?", "author": "enis", "createdAt": "2020-11-25T00:17:56Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "diffHunk": "@@ -171,9 +165,132 @@\n \n         awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, stack, regionName, credentialView);\n \n+        updateCloudformationWithLoadBalancer(ac, stack, resourceNotifier, modelContext, instances);\n+\n         return awsResourceConnector.check(ac, instances);\n     }\n \n+    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier) {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonEC2Client amazonEC2Client = awsClient.createAccess(credentialView, regionName);\n+        Network network = stack.getNetwork();\n+        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n+        boolean mapPublicIpOnLaunch = awsNetworkService.isMapPublicOnLaunch(awsNetworkView, amazonEC2Client);\n+\n+        boolean existingVPC = awsNetworkView.isExistingVPC();\n+        boolean existingSubnet = awsNetworkView.isExistingSubnet();\n+\n+        String cidr = network.getSubnet().getCidr();\n+        String subnet = isNoCIDRProvided(existingVPC, existingSubnet, cidr) ? awsNetworkService.findNonOverLappingCIDR(ac, stack) : cidr;\n+        AwsInstanceProfileView awsInstanceProfileView = new AwsInstanceProfileView(stack);\n+        ModelContext modelContext = new ModelContext()\n+            .withAuthenticatedContext(ac)\n+            .withStack(stack)\n+            .withExistingVpc(existingVPC)\n+            .withExistingIGW(awsNetworkView.isExistingIGW())\n+            .withExistingSubnetCidr(existingSubnet ? awsNetworkService.getExistingSubnetCidr(ac, stack) : null)\n+            .withExistinVpcCidr(awsNetworkService.getVpcCidrs(ac, stack))\n+            .withExistingSubnetIds(existingSubnet ? awsNetworkView.getSubnetList() : null)\n+            .mapPublicIpOnLaunch(mapPublicIpOnLaunch)\n+            .withEnableInstanceProfile(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withInstanceProfileAvailable(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withTemplate(stack.getTemplate())\n+            .withDefaultSubnet(subnet)\n+            .withOutboundInternetTraffic(network.getOutboundInternetTraffic())\n+            .withVpcCidrs(network.getNetworkCidrs())\n+            .withPrefixListIds(getPrefixListIds(amazonEC2Client, regionName, network.getOutboundInternetTraffic()))\n+            .withEncryptedAMIByGroupName(encryptedImageCopyService.createEncryptedImages(ac, stack, resourceNotifier));\n+\n+        return modelContext;\n+    }\n+\n+    private void updateCloudformationWithLoadBalancer(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier,", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyOTUzOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530029538", "bodyText": "Is this logic mimicing an existing behaviour? maybe you can make a comment here about what CIDR we chose and how.", "author": "enis", "createdAt": "2020-11-25T00:25:20Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsLaunchService.java", "diffHunk": "@@ -171,9 +165,132 @@\n \n         awsCloudWatchService.addCloudWatchAlarmsForSystemFailures(instances, stack, regionName, credentialView);\n \n+        updateCloudformationWithLoadBalancer(ac, stack, resourceNotifier, modelContext, instances);\n+\n         return awsResourceConnector.check(ac, instances);\n     }\n \n+    private ModelContext buildDefaultModelContext(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier) {\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonEC2Client amazonEC2Client = awsClient.createAccess(credentialView, regionName);\n+        Network network = stack.getNetwork();\n+        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n+        boolean mapPublicIpOnLaunch = awsNetworkService.isMapPublicOnLaunch(awsNetworkView, amazonEC2Client);\n+\n+        boolean existingVPC = awsNetworkView.isExistingVPC();\n+        boolean existingSubnet = awsNetworkView.isExistingSubnet();\n+\n+        String cidr = network.getSubnet().getCidr();\n+        String subnet = isNoCIDRProvided(existingVPC, existingSubnet, cidr) ? awsNetworkService.findNonOverLappingCIDR(ac, stack) : cidr;\n+        AwsInstanceProfileView awsInstanceProfileView = new AwsInstanceProfileView(stack);\n+        ModelContext modelContext = new ModelContext()\n+            .withAuthenticatedContext(ac)\n+            .withStack(stack)\n+            .withExistingVpc(existingVPC)\n+            .withExistingIGW(awsNetworkView.isExistingIGW())\n+            .withExistingSubnetCidr(existingSubnet ? awsNetworkService.getExistingSubnetCidr(ac, stack) : null)\n+            .withExistinVpcCidr(awsNetworkService.getVpcCidrs(ac, stack))\n+            .withExistingSubnetIds(existingSubnet ? awsNetworkView.getSubnetList() : null)\n+            .mapPublicIpOnLaunch(mapPublicIpOnLaunch)\n+            .withEnableInstanceProfile(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withInstanceProfileAvailable(awsInstanceProfileView.isInstanceProfileAvailable())\n+            .withTemplate(stack.getTemplate())\n+            .withDefaultSubnet(subnet)\n+            .withOutboundInternetTraffic(network.getOutboundInternetTraffic())\n+            .withVpcCidrs(network.getNetworkCidrs())\n+            .withPrefixListIds(getPrefixListIds(amazonEC2Client, regionName, network.getOutboundInternetTraffic()))\n+            .withEncryptedAMIByGroupName(encryptedImageCopyService.createEncryptedImages(ac, stack, resourceNotifier));\n+\n+        return modelContext;\n+    }\n+\n+    private void updateCloudformationWithLoadBalancer(AuthenticatedContext ac, CloudStack stack, PersistenceNotifier resourceNotifier,\n+            ModelContext modelContext, List<CloudResource> instances) {\n+\n+        List<CloudLoadBalancer> cloudLoadBalancers = stack.getLoadBalancers();\n+        if (!cloudLoadBalancers.isEmpty()) {\n+            if (modelContext == null) {\n+                modelContext = buildDefaultModelContext(ac, stack, resourceNotifier);\n+            }\n+\n+            List<AwsLoadBalancer> awsLoadBalancers = new ArrayList<>();\n+            for (CloudLoadBalancer cloudLoadBalancer : cloudLoadBalancers) {\n+                awsLoadBalancers.add(convert(cloudLoadBalancer, stack, instances));\n+            }\n+\n+            modelContext.withLoadBalancers(awsLoadBalancers);\n+            ListStackResourcesResult result = updateCloudFormationStack(ac, stack, modelContext);\n+\n+            for (AwsLoadBalancer loadBalancer : awsLoadBalancers) {\n+                for (AwsListener listener : loadBalancer.getListeners()) {\n+                    for (AwsTargetGroup targetGroup : listener.getTargetGroups()) {\n+                        Optional<StackResourceSummary> targetGroupSummary = result.getStackResourceSummaries().stream()\n+                            .filter(stackResourceSummary -> targetGroup.getName().equals(stackResourceSummary.getLogicalResourceId()))\n+                            .findFirst();\n+                        if (targetGroupSummary.isEmpty()) {\n+                            throw new CloudConnectorException(\"Could not create load balancer listeners: target group not found.\");\n+                        }\n+                        targetGroup.setArn(targetGroupSummary.get().getPhysicalResourceId());\n+                    }\n+                }\n+                Optional<StackResourceSummary> loadBalancerSummary = result.getStackResourceSummaries().stream()\n+                    .filter(stackResourceSummary -> loadBalancer.getName().equals(stackResourceSummary.getLogicalResourceId()))\n+                    .findFirst();\n+                if (loadBalancerSummary.isEmpty()) {\n+                    throw new CloudConnectorException(\"Could not create load balancer listeners: load balancer not found.\");\n+                }\n+                loadBalancer.setArn(loadBalancerSummary.get().getPhysicalResourceId());\n+                loadBalancer.canCreateListeners();\n+            }\n+\n+            updateCloudFormationStack(ac, stack, modelContext);\n+        }\n+    }\n+\n+    private AwsLoadBalancer convert(CloudLoadBalancer cloudLoadBalancer, CloudStack stack, List<CloudResource> instances) {\n+        int order = 1;\n+        List<AwsListener> awsListeners = new ArrayList<>();\n+        AwsLoadBalancerScheme scheme = AwsLoadBalancerScheme.valueOf(cloudLoadBalancer.getType().name());\n+        for (Map.Entry<Integer, Set<Group>> entry : cloudLoadBalancer.getPortToTargetGroupMapping().entrySet()) {\n+            List<CloudResource> lbTargetInstances = instances.stream()\n+                .filter(instance -> entry.getValue().stream().anyMatch(tg -> tg.getName().equals(instance.getGroup())))\n+                .collect(Collectors.toList());\n+            List<String> instanceIds = lbTargetInstances.stream().map(CloudResource::getInstanceId).collect(Collectors.toList());\n+\n+            AwsTargetGroup targetGroup = new AwsTargetGroup(entry.getKey(), scheme, order++, instanceIds);\n+            awsListeners.add(new AwsListener(entry.getKey(), Collections.singletonList(targetGroup), scheme));\n+        }\n+        return new AwsLoadBalancer(scheme, awsListeners);\n+    }\n+\n+    private ListStackResourcesResult updateCloudFormationStack(AuthenticatedContext ac, CloudStack stack, ModelContext modelContext) {\n+        String cFStackName = cfStackUtil.getCfStackName(ac);\n+        AwsCredentialView credentialView = new AwsCredentialView(ac.getCloudCredential());\n+        String regionName = ac.getCloudContext().getLocation().getRegion().value();\n+        AmazonCloudFormationRetryClient cfRetryClient = awsClient.createCloudFormationRetryClient(credentialView, regionName);\n+        Network network = stack.getNetwork();\n+        AwsNetworkView awsNetworkView = new AwsNetworkView(network);\n+        boolean existingVPC = awsNetworkView.isExistingVPC();\n+        boolean existingSubnet = awsNetworkView.isExistingSubnet();\n+        String cidr = network.getSubnet().getCidr();\n+        String subnet = isNoCIDRProvided(existingVPC, existingSubnet, cidr) ? awsNetworkService.findNonOverLappingCIDR(ac, stack) : cidr;", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY5MzIwNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532693204", "bodyText": "This is the logic that already existed, just moved to a new method. Since I didn't wrote it myself I'm not exactly sure how the logic of it works.", "author": "hreeve-cloudera", "createdAt": "2020-11-30T15:43:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAyOTUzOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMDQyMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530030421", "bodyText": "isStackDeleted is also using waiters and retry / polling logic. Are we using double layer of retry intentionally?", "author": "enis", "createdAt": "2020-11-25T00:27:28Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsTerminateService.java", "diffHunk": "@@ -112,12 +112,9 @@ private void waitAndDeleteCloudformationStack(AuthenticatedContext ac, CloudStac\n         resumeAutoScalingPolicies(ac, stack);\n         LOGGER.debug(\"Delete cloudformation stack from resources\");\n         DeleteStackRequest deleteStackRequest = new DeleteStackRequest().withStackName(cFStackName);\n-        cfRetryClient.deleteStack(deleteStackRequest);\n-        Waiter<DescribeStacksRequest> stackDeleteCompleteWaiter = amazonCloudFormationClient.waiters().stackDeleteComplete();\n         try {\n-            WaiterParameters<DescribeStacksRequest> describeStacksRequestWaiterParameters = new WaiterParameters<>(describeStacksRequest)\n-                    .withPollingStrategy(getBackoffCancellablePollingStrategy(null));\n-            stackDeleteCompleteWaiter.run(describeStacksRequestWaiterParameters);\n+            retryService.testWith2SecDelayMax5Times(() -> isStackDeleted(cfRetryClient, amazonCloudFormationClient,", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjY5NjYxNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532696617", "bodyText": "It was intentional, yes. There are two things being retried. The cfRetryClient.deleteStack method is retrying the initiation of the request; if the initial request is rejected or fails immediately, it will retry up to 15 time to initiate it again. However, once it's successfully initiated, that retry is complete and there's nothing left to do. The purpose of the isStackDeleted method is to check the final state of the deletion, and allow us to retry if the final state is a failure. So one retry checks initialization state, and one checks the final state.", "author": "hreeve-cloudera", "createdAt": "2020-11-30T15:47:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMDQyMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM4OTQ3OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r535389479", "bodyText": "Talked this out with Tamas and added additional logging messages to make the logic of this section more cler.", "author": "hreeve-cloudera", "createdAt": "2020-12-03T16:33:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMDQyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMDg4OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530030888", "bodyText": "great.", "author": "enis", "createdAt": "2020-11-25T00:28:57Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsListener.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class AwsListener {\n+\n+    private static final String LISTENER_NAME_PREFIX = \"ListenerPort\";\n+\n+    private final int port;\n+\n+    private final List<AwsTargetGroup> targetGroups;\n+\n+    private final String name;\n+\n+    public AwsListener(int port, List<AwsTargetGroup> targetGroups, AwsLoadBalancerScheme scheme) {\n+        this.port = port;\n+        this.targetGroups = targetGroups;\n+        this.name = getListenerName(port, scheme);\n+    }\n+\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    public List<AwsTargetGroup> getTargetGroups() {\n+        return targetGroups;\n+    }\n+\n+    public boolean areTargetGroupArnsSet() {\n+        return targetGroups.stream().noneMatch(t -> t.getArn() == null || t.getArn().isEmpty());\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    private static String getListenerName(int port, AwsLoadBalancerScheme scheme) {\n+        return LISTENER_NAME_PREFIX + port +", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMTEwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530031109", "bodyText": "nit: shouldCreateListeners()", "author": "enis", "createdAt": "2020-11-25T00:29:35Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class AwsLoadBalancer {\n+\n+    private static final String LOAD_BALANCER_NAME_PREFIX = \"LoadBalancer\";\n+\n+    private final AwsLoadBalancerScheme scheme;\n+\n+    private final String awsScheme;\n+\n+    private final List<AwsListener> listeners;\n+\n+    private final String name;\n+\n+    private String arn;\n+\n+    private boolean createListeners;\n+\n+    public AwsLoadBalancer(AwsLoadBalancerScheme scheme, List<AwsListener> listeners) {\n+        this.scheme = scheme;\n+        this.awsScheme = scheme.awsScheme();\n+        this.listeners = listeners;\n+        this.name = getLoadBalancerName(scheme);\n+        this.createListeners = false;\n+    }\n+\n+    public AwsLoadBalancerScheme getScheme() {\n+        return scheme;\n+    }\n+\n+    public List<AwsListener> getListeners() {\n+        return listeners;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public String getArn() {\n+        return arn;\n+    }\n+\n+    public void setArn(String arn) {\n+        this.arn = arn;\n+    }\n+\n+    public String getAwsScheme() {\n+        return awsScheme;\n+    }\n+\n+    public boolean isCreateListeners() {", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjcwMTI0MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532701240", "bodyText": "I can't actually change this getter name, because the template files fetch the class members using standardized getter names. If you use anything else, it can't fetch the value properly and the template won't be filled out.\nHowever, I did change it from createListeners to listenerConfigSet, so the method name sounds nicer.", "author": "hreeve-cloudera", "createdAt": "2020-11-30T15:53:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMTEwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMTM2NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530031364", "bodyText": "This does not seem to be used.", "author": "enis", "createdAt": "2020-11-25T00:30:22Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancer.java", "diffHunk": "@@ -0,0 +1,73 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n+\n+import java.util.List;\n+\n+import org.apache.commons.lang3.StringUtils;\n+\n+public class AwsLoadBalancer {\n+\n+    private static final String LOAD_BALANCER_NAME_PREFIX = \"LoadBalancer\";\n+\n+    private final AwsLoadBalancerScheme scheme;\n+\n+    private final String awsScheme;\n+\n+    private final List<AwsListener> listeners;\n+\n+    private final String name;\n+\n+    private String arn;\n+\n+    private boolean createListeners;", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjcwMjczNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532702734", "bodyText": "It's used by the template files. See https://github.com/hortonworks/cloudbreak/pull/9475/files#diff-5b1a3ad86915b768282779a97322c280afd84febb377b395e1d274fbdebef237R288", "author": "hreeve-cloudera", "createdAt": "2020-11-30T15:55:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMTM2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMTU5Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530031593", "bodyText": "I think this should match AWS's terminology.\nINTERNET_FACING(\"internet-facing\")\nINTERNAL(\"internal\")", "author": "enis", "createdAt": "2020-11-25T00:31:03Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/loadbalancer/AwsLoadBalancerScheme.java", "diffHunk": "@@ -0,0 +1,16 @@\n+package com.sequenceiq.cloudbreak.cloud.aws.loadbalancer;\n+\n+public enum AwsLoadBalancerScheme {\n+    PUBLIC(\"internet-facing\"),", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjcwNDA0Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532704046", "bodyText": "The purpose of using PUBLIC/PRIVATE here is so we can convert between the LoadBalalncerType class and this class. You can see this use in AwsLaunchService:\nAwsLoadBalancerScheme scheme = AwsLoadBalancerScheme.valueOf(cloudLoadBalancer.getType().name());", "author": "hreeve-cloudera", "createdAt": "2020-11-30T15:57:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDAzMTU5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0MjQ5MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530042490", "bodyText": "maybe debug level?", "author": "enis", "createdAt": "2020-11-25T01:05:51Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> componentByHostGroup = cmTemplateProcessor.getServiceComponentsByHostGroup();\n+            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0Mjk4Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530042982", "bodyText": "I think the convention we should use is to follow AWS terminology. internet-facing load balancers do not have an \"external\" suffix, but internal load balancers have and \"-internal\" suffix.", "author": "enis", "createdAt": "2020-11-25T01:07:33Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjcwODA4Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532708083", "bodyText": "I'm going to copy this comment to CB-9900. External subnets aren't going to be incorporated until that's done, so we can look at the naming then.", "author": "hreeve-cloudera", "createdAt": "2020-11-30T16:02:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0Mjk4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0MzE3NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r530043175", "bodyText": "is this the full stack name, or just the shortened one?", "author": "enis", "createdAt": "2020-11-25T01:08:16Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> componentByHostGroup = cmTemplateProcessor.getServiceComponentsByHostGroup();\n+            LOGGER.info(\"Checking if Knox gateway is explicitly defined\");\n+            groupNames = componentByHostGroup.entrySet().stream()\n+                .filter(entry -> isKnoxGatewayDefinedInServices(entry.getValue()))\n+                .map(Map.Entry::getKey)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"Knox gateway is not explicitly defined; searching for CM gateway hosts\");\n+            groupNames = stack.getInstanceGroups().stream()\n+                .filter(i -> InstanceGroupType.isGateway(i.getInstanceGroupType()))\n+                .map(InstanceGroup::getGroupName)\n+                .collect(Collectors.toSet());\n+        }\n+\n+        if (groupNames.isEmpty()) {\n+            LOGGER.info(\"No Knox gateway instance groups found\");\n+        }\n+        return groupNames;\n+    }\n+\n+    private boolean isKnoxGatewayDefinedInServices(Set<ServiceComponent> serviceComponents) {\n+        return serviceComponents.stream()\n+            .anyMatch(serviceComponent -> KnoxRoles.KNOX_GATEWAY.equals(serviceComponent.getComponent()));\n+    }\n+\n+    public String generateLoadBalancerEndpoint(Stack stack, LoadBalancerType type) {\n+        StringBuilder name = new StringBuilder()\n+            .append(stack.getName())", "originalCommit": "e19d80b459db1f5f36788bd56bc824be5253f860", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMjcwOTgwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r532709809", "bodyText": "The shortened one. So if I name my datalake hreeve-cloudbreak-dl, that would be the stack name here, and the endpoint would be hreeve-cloudbreak-dl-gateway.", "author": "hreeve-cloudera", "createdAt": "2020-11-30T16:04:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzMDA0MzE3NQ=="}], "type": "inlineReview"}, {"oid": "d9d43318f7d259946ff4c23f16bb184a1ea58424", "url": "https://github.com/hortonworks/cloudbreak/commit/d9d43318f7d259946ff4c23f16bb184a1ea58424", "message": "Additional review comments and rebase.", "committedDate": "2020-11-30T19:12:39Z", "type": "forcePushed"}, {"oid": "38ef8055c8d7bdf17068665196206f3622b9a3bd", "url": "https://github.com/hortonworks/cloudbreak/commit/38ef8055c8d7bdf17068665196206f3622b9a3bd", "message": "Additional review comments and rebase.", "committedDate": "2020-11-30T20:37:55Z", "type": "forcePushed"}, {"oid": "91252020ce85e0bf097c4fcba5073697e46aa7e7", "url": "https://github.com/hortonworks/cloudbreak/commit/91252020ce85e0bf097c4fcba5073697e46aa7e7", "message": "Defaulting mock entitlement to false and rebasing from master.", "committedDate": "2020-12-02T16:35:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ5NTY5Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534495696", "bodyText": "This method should not be created as getGatewayInstanceMetadata or getPrimaryGatewayInstance could be used to do the same and I checked in IDEA it hasn't even used anywhere on this branch.", "author": "biharitomi", "createdAt": "2020-12-02T21:33:35Z", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/Stack.java", "diffHunk": "@@ -574,6 +579,15 @@ public InstanceMetaData getPrimaryGatewayInstance() {\n         return metaData.orElse(null);\n     }\n \n+    public InstanceGroup getGatewayGroup() {", "originalCommit": "91252020ce85e0bf097c4fcba5073697e46aa7e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTM5MTM3Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r535391372", "bodyText": "This method has been deleted. Thanks for the catch!", "author": "hreeve-cloudera", "createdAt": "2020-12-03T16:36:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDQ5NTY5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwMTE2MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534501161", "bodyText": "The TargetGroupType enum could be used here and the values of the field would be more straightforward. CB has an enum converter logic which handles the conversion from enum to string and vice versa.\nAn example could be: com.sequenceiq.environment.parameters.dao.converter.CredentialTypeConverter", "author": "biharitomi", "createdAt": "2020-12-02T21:43:49Z", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/TargetGroup.java", "diffHunk": "@@ -0,0 +1,59 @@\n+package com.sequenceiq.cloudbreak.domain.stack.loadbalancer;\n+\n+import com.sequenceiq.cloudbreak.domain.ProvisionEntity;\n+import java.util.Set;\n+\n+import javax.persistence.Entity;\n+import javax.persistence.FetchType;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToMany;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.SequenceGenerator;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+\n+@Entity\n+public class TargetGroup implements ProvisionEntity {\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.AUTO, generator = \"targetgroup_generator\")\n+    @SequenceGenerator(name = \"targetgroup_generator\", sequenceName = \"targetgroup_id_seq\", allocationSize = 1)\n+    private Long id;\n+\n+    private String type;", "originalCommit": "91252020ce85e0bf097c4fcba5073697e46aa7e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ1OTM2Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r535459367", "bodyText": "Done", "author": "hreeve-cloudera", "createdAt": "2020-12-03T18:01:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwMTE2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwMTcwNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534501704", "bodyText": "The LoadBalancerType enum could be used here and the values of the field would be more straightforward. CB has an enum converter logic which handles the conversion from enum to string and vice versa.\nAn example could be: com.sequenceiq.environment.parameters.dao.converter.CredentialTypeConverter", "author": "biharitomi", "createdAt": "2020-12-02T21:44:45Z", "path": "core-model/src/main/java/com/sequenceiq/cloudbreak/domain/stack/loadbalancer/LoadBalancer.java", "diffHunk": "@@ -0,0 +1,111 @@\n+package com.sequenceiq.cloudbreak.domain.stack.loadbalancer;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import javax.persistence.CascadeType;\n+import javax.persistence.Entity;\n+import javax.persistence.GeneratedValue;\n+import javax.persistence.GenerationType;\n+import javax.persistence.Id;\n+import javax.persistence.ManyToOne;\n+import javax.persistence.OneToMany;\n+import javax.persistence.SequenceGenerator;\n+\n+import com.sequenceiq.cloudbreak.domain.ProvisionEntity;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+\n+@Entity\n+public class LoadBalancer implements ProvisionEntity  {\n+    @Id\n+    @GeneratedValue(strategy = GenerationType.AUTO, generator = \"loadbalancer_generator\")\n+    @SequenceGenerator(name = \"loadbalancer_generator\", sequenceName = \"loadbalancer_id_seq\", allocationSize = 1)\n+    private Long id;\n+\n+    @ManyToOne\n+    private Stack stack;\n+\n+    private String dns;\n+\n+    private String hostedZoneId;\n+\n+    private String ip;\n+\n+    private String type;", "originalCommit": "91252020ce85e0bf097c4fcba5073697e46aa7e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ1OTI5NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r535459295", "bodyText": "Done", "author": "hreeve-cloudera", "createdAt": "2020-12-03T18:01:13Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwMTcwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwOTI4Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534509286", "bodyText": "Instead of this call and the next lambda filter the com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor#getHostGroupsWithComponent method could be used.", "author": "biharitomi", "createdAt": "2020-12-02T21:58:31Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/LoadBalancerConfigService.java", "diffHunk": "@@ -0,0 +1,86 @@\n+package com.sequenceiq.cloudbreak.service;\n+\n+import com.sequenceiq.cloudbreak.domain.stack.loadbalancer.TargetGroup;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cmtemplate.CmTemplateProcessor;\n+import com.sequenceiq.cloudbreak.cmtemplate.configproviders.knox.KnoxRoles;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.stack.cluster.Cluster;\n+import com.sequenceiq.cloudbreak.domain.stack.instance.InstanceGroup;\n+import com.sequenceiq.cloudbreak.template.model.ServiceComponent;\n+import com.sequenceiq.common.api.type.InstanceGroupType;\n+import com.sequenceiq.common.api.type.LoadBalancerType;\n+\n+@Service\n+public class LoadBalancerConfigService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(LoadBalancerConfigService.class);\n+\n+    private static final String ENDPOINT_SUFFIX = \"gateway\";\n+\n+    private static final String PUBLIC_SUFFIX = \"external\";\n+\n+    private static final Set<Integer> DEFAULT_KNOX_PORTS = Set.of(443);\n+\n+    public Set<String> getKnoxGatewayGroups(Stack stack) {\n+        LOGGER.info(\"Fetching list of instance groups with Knox gateway installed\");\n+        Set<String> groupNames = new HashSet<>();\n+        Cluster cluster = stack.getCluster();\n+        if (cluster != null) {\n+            CmTemplateProcessor cmTemplateProcessor = new CmTemplateProcessor(cluster.getBlueprint().getBlueprintText());\n+            Map<String, Set<ServiceComponent>> componentByHostGroup = cmTemplateProcessor.getServiceComponentsByHostGroup();", "originalCommit": "91252020ce85e0bf097c4fcba5073697e46aa7e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ1OTIxNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r535459215", "bodyText": "Well that's much easier. :)", "author": "hreeve-cloudera", "createdAt": "2020-12-03T18:01:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUwOTI4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxMDk0OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534510948", "bodyText": "Using if-else instead of if-continue?", "author": "biharitomi", "createdAt": "2020-12-02T22:01:13Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/publicendpoint/GatewayPublicEndpointManagementService.java", "diffHunk": "@@ -92,6 +101,41 @@ public String updateDnsEntry(Stack stack, String gatewayIp) {\n         return null;\n     }\n \n+    public void updateDnsEntryForLoadBalancers(Stack stack) {\n+        Set<LoadBalancer> loadBalancers = loadBalancerPersistenceService.findByStackId(stack.getId());\n+        if (loadBalancers.isEmpty()) {\n+            LOGGER.info(\"No load balancers in stack {}\", stack.getId());\n+            return;\n+        }\n+\n+        LOGGER.info(\"Update load balancer DNS entries\");\n+        String userCrn = ThreadBasedUserCrnProvider.getUserCrn();\n+        String accountId = ThreadBasedUserCrnProvider.getAccountId();\n+        DetailedEnvironmentResponse environment = environmentClientService.getByCrn(stack.getEnvironmentCrn());\n+\n+        for (LoadBalancer loadBalancer : loadBalancers) {\n+            Optional<String> endpoint = Optional.ofNullable(loadBalancer.getEndpoint());\n+            if (endpoint.isEmpty()) {\n+                LOGGER.error(\"No endpoint set for load balancer. Can't register domain.\");\n+                continue;", "originalCommit": "91252020ce85e0bf097c4fcba5073697e46aa7e7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNTQ1OTExNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r535459114", "bodyText": "Done", "author": "hreeve-cloudera", "createdAt": "2020-12-03T18:00:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxMDk0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNDUxMjM2NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9475#discussion_r534512365", "bodyText": "No, https://github.com/hortonworks/cloudbreak/pull/9475/files#diff-7d0c14c28466a6ed89a04d3cc0a6c5973f30325dab017a4093173af0145e77dbR35 will do the job.", "author": "biharitomi", "createdAt": "2020-12-02T22:04:01Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/publicendpoint/dns/BaseDnsEntryService.java", "diffHunk": "@@ -101,6 +101,7 @@\n         String accountId = ThreadBasedUserCrnProvider.getAccountId();\n         DetailedEnvironmentResponse environment = environmentClientService.getByCrn(environmentCrn);\n \n+        // TODO do we need to deregister the load balancer DNS here as well?", "originalCommit": "91252020ce85e0bf097c4fcba5073697e46aa7e7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "33c06d91cb3afbb6440f9ed6f05df310b6d8abc6", "url": "https://github.com/hortonworks/cloudbreak/commit/33c06d91cb3afbb6440f9ed6f05df310b6d8abc6", "message": "CB-9241 Create an AWS load balancer in front of Knox on the data lake\n\nThis change adds a load balancer to the data lake that sits in front of Knox.\nIt is configured automatically during data lake creation for AWS environments.\nThis functionality is currently behind the CDP_DATA_LAKE_LOAD_BALANCER\nentitlement.\n\nThe load balancer is modeled in CB by having a series of targetGroups, which\ninclude the type of target (in this commit, only KNOX targets are supported),\nthe port to route data to, and links to the instance groups where the service\nruns. The load balancer will receive traffic on the defined port, and route it\nto the same port on the appropriate instances. The load balancer is created\nautomatically in front of all data lake that have a Knox gateway. If PEM is\nenabled, it is given a DNS entry under the endpoint \"<datalake name>-gateway\".\n\nThis change was tested with unit tests, and by running the Cloudbreak service\nlocally and verifying: 1) the LB is created in AWS, 2) the LB is configured\nwith the appropriate instance information, and 3) accessing the LB endpoint\ncorrectly routes the traffic to Knox.", "committedDate": "2020-12-03T17:49:16Z", "type": "commit"}, {"oid": "33c06d91cb3afbb6440f9ed6f05df310b6d8abc6", "url": "https://github.com/hortonworks/cloudbreak/commit/33c06d91cb3afbb6440f9ed6f05df310b6d8abc6", "message": "CB-9241 Create an AWS load balancer in front of Knox on the data lake\n\nThis change adds a load balancer to the data lake that sits in front of Knox.\nIt is configured automatically during data lake creation for AWS environments.\nThis functionality is currently behind the CDP_DATA_LAKE_LOAD_BALANCER\nentitlement.\n\nThe load balancer is modeled in CB by having a series of targetGroups, which\ninclude the type of target (in this commit, only KNOX targets are supported),\nthe port to route data to, and links to the instance groups where the service\nruns. The load balancer will receive traffic on the defined port, and route it\nto the same port on the appropriate instances. The load balancer is created\nautomatically in front of all data lake that have a Knox gateway. If PEM is\nenabled, it is given a DNS entry under the endpoint \"<datalake name>-gateway\".\n\nThis change was tested with unit tests, and by running the Cloudbreak service\nlocally and verifying: 1) the LB is created in AWS, 2) the LB is configured\nwith the appropriate instance information, and 3) accessing the LB endpoint\ncorrectly routes the traffic to Knox.", "committedDate": "2020-12-03T17:49:16Z", "type": "forcePushed"}]}