{"pr_number": 9593, "pr_title": "CB-9943: Extend the Data Hub CDH runtime upgrade process with upgrading the non-CDH services to a new version what we burned into the new image.", "pr_createdAt": "2020-12-07T16:38:07Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/9593", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY2NzA2Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r537667063", "bodyText": "We should call the method argument to services as well. We're mixing the product and services variables and it's hard to track.", "author": "keyki", "createdAt": "2020-12-07T16:58:03Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -170,47 +174,114 @@ public void cleanupCluster(Telemetry telemetry) throws CloudbreakException {\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n-            ClusterComponent stackComponent = getStackComponent(components);\n-\n-            ClouderaManagerProduct stackProduct = stackComponent.getAttributes().get(ClouderaManagerProduct.class);\n-            String stackProductVersion = stackProduct.getVersion();\n-            String stackProductParcel = stackProduct.getParcel();\n-            String product = com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name();\n-\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n-            ParcelsResourceApi parcelsResourceApi = clouderaManagerApiFactory.getParcelsResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n             MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n-            startClouderaManager(stack, apiClient);\n+            startClouderaManager();\n             checkParcelApiAvailability();\n-            setParcelRepo(stackProductParcel, clouderaManagerResourceApi);\n+\n+            Set<ClouderaManagerProduct> services = getServices(components);\n+            ClouderaManagerProduct cdhService = getCdhService(services);\n+            setParcelRepo(services, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n-            downloadParcel(stackProductVersion, parcelResourceApi, product);\n-            distributeParcel(stackProductVersion, parcelResourceApi, product);\n             if (patchUpgrade) {\n-                activateParcel(stackProductVersion, parcelResourceApi, product);\n+                installServices(services, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n-                callUpgradeCdhCommand(stackProductVersion, clustersResourceApi);\n+                upgradeNonCdhServices(services, cdhService.getName(), parcelResourceApi);\n+                upgradeCdh(clustersResourceApi, parcelResourceApi, cdhService);\n                 restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n             }\n-            clouderaManagerParcelService.removeUnusedParcelVersions(apiClient, parcelsResourceApi, parcelResourceApi, stack, product, stackProductVersion);\n+            removeUnusedParcels(components);\n             configService.enableKnoxAutorestartIfCmVersionAtLeast(CLOUDERAMANAGER_VERSION_7_1_0, apiClient, stack.getName());\n-        } catch (ApiException | IOException e) {\n+        } catch (ApiException e) {\n             LOGGER.info(\"Could not upgrade Cloudera Runtime services\", e);\n             throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n         }\n     }\n \n-    private ClusterComponent getStackComponent(Set<ClusterComponent> components) {\n+    private void upgradeCdh(ClustersResourceApi clustersResourceApi, ParcelResourceApi parcelResourceApi, ClouderaManagerProduct cdhService)\n+            throws ApiException, CloudbreakException {\n+        downloadParcel(Collections.singleton(cdhService), parcelResourceApi);\n+        distributeParcel(Collections.singleton(cdhService), parcelResourceApi);\n+        callUpgradeCdhCommand(cdhService, clustersResourceApi);\n+    }\n+\n+    private Set<ClouderaManagerProduct> getServices(Set<ClusterComponent> components) {\n         return components.stream()\n-                .filter(clusterComponent -> clusterComponent.getName().equals(com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name()))\n+                .filter(clusterComponent -> ComponentType.CDH_PRODUCT_DETAILS.equals(clusterComponent.getComponentType()))\n+                .map(this::getClouderaManagerProduct)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private void upgradeNonCdhServices(Set<ClouderaManagerProduct> services, String cdhServiceName, ParcelResourceApi parcelResourceApi)\n+            throws CloudbreakException, ApiException {\n+        Set<ClouderaManagerProduct> nonCdhServices = getNonCdhServices(services, cdhServiceName);\n+        installServices(nonCdhServices, parcelResourceApi);\n+    }\n+\n+    private void installServices(Set<ClouderaManagerProduct> products, ParcelResourceApi parcelResourceApi) throws ApiException, CloudbreakException {\n+        downloadParcel(products, parcelResourceApi);\n+        distributeParcel(products, parcelResourceApi);\n+        activateParcel(products, parcelResourceApi);\n+    }\n+\n+    private ClouderaManagerProduct getCdhService(Set<ClouderaManagerProduct> products) {\n+        return products.stream()\n+                .filter(product -> product.getName().equals(com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name()))\n                 .findFirst()\n                 .orElseThrow(() -> new NotFoundException(\"Runtime component not found!\"));\n     }\n \n+    private Set<ClouderaManagerProduct> getNonCdhServices(Set<ClouderaManagerProduct> products, String cdhProductName) {\n+        return products.stream()\n+                .filter(product -> !product.getName().equals(cdhProductName))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private ClouderaManagerProduct getClouderaManagerProduct(ClusterComponent clusterComponent) {\n+        try {\n+            return clusterComponent.getAttributes().get(ClouderaManagerProduct.class);\n+        } catch (IOException e) {\n+            LOGGER.info(\"Could not upgrade Cloudera Runtime services\", e);\n+            throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n+        }\n+    }\n+\n+    private void checkParcelApiAvailability() throws CloudbreakException {\n+        clouderaManagerParcelManagementService.checkParcelApiAvailability(stack, apiClient);\n+    }\n+\n+    private void setParcelRepo(Set<ClouderaManagerProduct> products, ClouderaManagerResourceApi clouderaManagerResourceApi) throws ApiException {", "originalCommit": "6e65c94a334a79f9aa677bba37f1b15188ef4b51", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY3MDc3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r537670774", "bodyText": "This line can be moved to the else branch as it's only used there.", "author": "keyki", "createdAt": "2020-12-07T17:02:45Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -170,47 +174,114 @@ public void cleanupCluster(Telemetry telemetry) throws CloudbreakException {\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n-            ClusterComponent stackComponent = getStackComponent(components);\n-\n-            ClouderaManagerProduct stackProduct = stackComponent.getAttributes().get(ClouderaManagerProduct.class);\n-            String stackProductVersion = stackProduct.getVersion();\n-            String stackProductParcel = stackProduct.getParcel();\n-            String product = com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name();\n-\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n-            ParcelsResourceApi parcelsResourceApi = clouderaManagerApiFactory.getParcelsResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n             MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n-            startClouderaManager(stack, apiClient);\n+            startClouderaManager();\n             checkParcelApiAvailability();\n-            setParcelRepo(stackProductParcel, clouderaManagerResourceApi);\n+\n+            Set<ClouderaManagerProduct> services = getServices(components);\n+            ClouderaManagerProduct cdhService = getCdhService(services);", "originalCommit": "6e65c94a334a79f9aa677bba37f1b15188ef4b51", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY3Nzg2MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r537677860", "bodyText": "We should figure out a better method name. Maybe downloadAndActivateParcels ?", "author": "keyki", "createdAt": "2020-12-07T17:12:11Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -170,47 +174,114 @@ public void cleanupCluster(Telemetry telemetry) throws CloudbreakException {\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n-            ClusterComponent stackComponent = getStackComponent(components);\n-\n-            ClouderaManagerProduct stackProduct = stackComponent.getAttributes().get(ClouderaManagerProduct.class);\n-            String stackProductVersion = stackProduct.getVersion();\n-            String stackProductParcel = stackProduct.getParcel();\n-            String product = com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name();\n-\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n-            ParcelsResourceApi parcelsResourceApi = clouderaManagerApiFactory.getParcelsResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n             MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n-            startClouderaManager(stack, apiClient);\n+            startClouderaManager();\n             checkParcelApiAvailability();\n-            setParcelRepo(stackProductParcel, clouderaManagerResourceApi);\n+\n+            Set<ClouderaManagerProduct> services = getServices(components);\n+            ClouderaManagerProduct cdhService = getCdhService(services);\n+            setParcelRepo(services, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n-            downloadParcel(stackProductVersion, parcelResourceApi, product);\n-            distributeParcel(stackProductVersion, parcelResourceApi, product);\n             if (patchUpgrade) {\n-                activateParcel(stackProductVersion, parcelResourceApi, product);\n+                installServices(services, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n-                callUpgradeCdhCommand(stackProductVersion, clustersResourceApi);\n+                upgradeNonCdhServices(services, cdhService.getName(), parcelResourceApi);\n+                upgradeCdh(clustersResourceApi, parcelResourceApi, cdhService);\n                 restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n             }\n-            clouderaManagerParcelService.removeUnusedParcelVersions(apiClient, parcelsResourceApi, parcelResourceApi, stack, product, stackProductVersion);\n+            removeUnusedParcels(components);\n             configService.enableKnoxAutorestartIfCmVersionAtLeast(CLOUDERAMANAGER_VERSION_7_1_0, apiClient, stack.getName());\n-        } catch (ApiException | IOException e) {\n+        } catch (ApiException e) {\n             LOGGER.info(\"Could not upgrade Cloudera Runtime services\", e);\n             throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n         }\n     }\n \n-    private ClusterComponent getStackComponent(Set<ClusterComponent> components) {\n+    private void upgradeCdh(ClustersResourceApi clustersResourceApi, ParcelResourceApi parcelResourceApi, ClouderaManagerProduct cdhService)\n+            throws ApiException, CloudbreakException {\n+        downloadParcel(Collections.singleton(cdhService), parcelResourceApi);\n+        distributeParcel(Collections.singleton(cdhService), parcelResourceApi);\n+        callUpgradeCdhCommand(cdhService, clustersResourceApi);\n+    }\n+\n+    private Set<ClouderaManagerProduct> getServices(Set<ClusterComponent> components) {\n         return components.stream()\n-                .filter(clusterComponent -> clusterComponent.getName().equals(com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name()))\n+                .filter(clusterComponent -> ComponentType.CDH_PRODUCT_DETAILS.equals(clusterComponent.getComponentType()))\n+                .map(this::getClouderaManagerProduct)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private void upgradeNonCdhServices(Set<ClouderaManagerProduct> services, String cdhServiceName, ParcelResourceApi parcelResourceApi)\n+            throws CloudbreakException, ApiException {\n+        Set<ClouderaManagerProduct> nonCdhServices = getNonCdhServices(services, cdhServiceName);\n+        installServices(nonCdhServices, parcelResourceApi);\n+    }\n+\n+    private void installServices(Set<ClouderaManagerProduct> products, ParcelResourceApi parcelResourceApi) throws ApiException, CloudbreakException {", "originalCommit": "6e65c94a334a79f9aa677bba37f1b15188ef4b51", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY3ODM5MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r537678390", "bodyText": "Similarly use services instead of products.", "author": "keyki", "createdAt": "2020-12-07T17:12:54Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -170,47 +174,114 @@ public void cleanupCluster(Telemetry telemetry) throws CloudbreakException {\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n-            ClusterComponent stackComponent = getStackComponent(components);\n-\n-            ClouderaManagerProduct stackProduct = stackComponent.getAttributes().get(ClouderaManagerProduct.class);\n-            String stackProductVersion = stackProduct.getVersion();\n-            String stackProductParcel = stackProduct.getParcel();\n-            String product = com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name();\n-\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n-            ParcelsResourceApi parcelsResourceApi = clouderaManagerApiFactory.getParcelsResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n             MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n-            startClouderaManager(stack, apiClient);\n+            startClouderaManager();\n             checkParcelApiAvailability();\n-            setParcelRepo(stackProductParcel, clouderaManagerResourceApi);\n+\n+            Set<ClouderaManagerProduct> services = getServices(components);\n+            ClouderaManagerProduct cdhService = getCdhService(services);\n+            setParcelRepo(services, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n-            downloadParcel(stackProductVersion, parcelResourceApi, product);\n-            distributeParcel(stackProductVersion, parcelResourceApi, product);\n             if (patchUpgrade) {\n-                activateParcel(stackProductVersion, parcelResourceApi, product);\n+                installServices(services, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n-                callUpgradeCdhCommand(stackProductVersion, clustersResourceApi);\n+                upgradeNonCdhServices(services, cdhService.getName(), parcelResourceApi);\n+                upgradeCdh(clustersResourceApi, parcelResourceApi, cdhService);\n                 restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n             }\n-            clouderaManagerParcelService.removeUnusedParcelVersions(apiClient, parcelsResourceApi, parcelResourceApi, stack, product, stackProductVersion);\n+            removeUnusedParcels(components);\n             configService.enableKnoxAutorestartIfCmVersionAtLeast(CLOUDERAMANAGER_VERSION_7_1_0, apiClient, stack.getName());\n-        } catch (ApiException | IOException e) {\n+        } catch (ApiException e) {\n             LOGGER.info(\"Could not upgrade Cloudera Runtime services\", e);\n             throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n         }\n     }\n \n-    private ClusterComponent getStackComponent(Set<ClusterComponent> components) {\n+    private void upgradeCdh(ClustersResourceApi clustersResourceApi, ParcelResourceApi parcelResourceApi, ClouderaManagerProduct cdhService)\n+            throws ApiException, CloudbreakException {\n+        downloadParcel(Collections.singleton(cdhService), parcelResourceApi);\n+        distributeParcel(Collections.singleton(cdhService), parcelResourceApi);\n+        callUpgradeCdhCommand(cdhService, clustersResourceApi);\n+    }\n+\n+    private Set<ClouderaManagerProduct> getServices(Set<ClusterComponent> components) {\n         return components.stream()\n-                .filter(clusterComponent -> clusterComponent.getName().equals(com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name()))\n+                .filter(clusterComponent -> ComponentType.CDH_PRODUCT_DETAILS.equals(clusterComponent.getComponentType()))\n+                .map(this::getClouderaManagerProduct)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private void upgradeNonCdhServices(Set<ClouderaManagerProduct> services, String cdhServiceName, ParcelResourceApi parcelResourceApi)\n+            throws CloudbreakException, ApiException {\n+        Set<ClouderaManagerProduct> nonCdhServices = getNonCdhServices(services, cdhServiceName);\n+        installServices(nonCdhServices, parcelResourceApi);\n+    }\n+\n+    private void installServices(Set<ClouderaManagerProduct> products, ParcelResourceApi parcelResourceApi) throws ApiException, CloudbreakException {", "originalCommit": "6e65c94a334a79f9aa677bba37f1b15188ef4b51", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY3OTQzMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r537679430", "bodyText": "services", "author": "keyki", "createdAt": "2020-12-07T17:14:24Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -170,47 +174,114 @@ public void cleanupCluster(Telemetry telemetry) throws CloudbreakException {\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n-            ClusterComponent stackComponent = getStackComponent(components);\n-\n-            ClouderaManagerProduct stackProduct = stackComponent.getAttributes().get(ClouderaManagerProduct.class);\n-            String stackProductVersion = stackProduct.getVersion();\n-            String stackProductParcel = stackProduct.getParcel();\n-            String product = com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name();\n-\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n-            ParcelsResourceApi parcelsResourceApi = clouderaManagerApiFactory.getParcelsResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n             MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n-            startClouderaManager(stack, apiClient);\n+            startClouderaManager();\n             checkParcelApiAvailability();\n-            setParcelRepo(stackProductParcel, clouderaManagerResourceApi);\n+\n+            Set<ClouderaManagerProduct> services = getServices(components);\n+            ClouderaManagerProduct cdhService = getCdhService(services);\n+            setParcelRepo(services, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n-            downloadParcel(stackProductVersion, parcelResourceApi, product);\n-            distributeParcel(stackProductVersion, parcelResourceApi, product);\n             if (patchUpgrade) {\n-                activateParcel(stackProductVersion, parcelResourceApi, product);\n+                installServices(services, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n-                callUpgradeCdhCommand(stackProductVersion, clustersResourceApi);\n+                upgradeNonCdhServices(services, cdhService.getName(), parcelResourceApi);\n+                upgradeCdh(clustersResourceApi, parcelResourceApi, cdhService);\n                 restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n             }\n-            clouderaManagerParcelService.removeUnusedParcelVersions(apiClient, parcelsResourceApi, parcelResourceApi, stack, product, stackProductVersion);\n+            removeUnusedParcels(components);\n             configService.enableKnoxAutorestartIfCmVersionAtLeast(CLOUDERAMANAGER_VERSION_7_1_0, apiClient, stack.getName());\n-        } catch (ApiException | IOException e) {\n+        } catch (ApiException e) {\n             LOGGER.info(\"Could not upgrade Cloudera Runtime services\", e);\n             throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n         }\n     }\n \n-    private ClusterComponent getStackComponent(Set<ClusterComponent> components) {\n+    private void upgradeCdh(ClustersResourceApi clustersResourceApi, ParcelResourceApi parcelResourceApi, ClouderaManagerProduct cdhService)\n+            throws ApiException, CloudbreakException {\n+        downloadParcel(Collections.singleton(cdhService), parcelResourceApi);\n+        distributeParcel(Collections.singleton(cdhService), parcelResourceApi);\n+        callUpgradeCdhCommand(cdhService, clustersResourceApi);\n+    }\n+\n+    private Set<ClouderaManagerProduct> getServices(Set<ClusterComponent> components) {\n         return components.stream()\n-                .filter(clusterComponent -> clusterComponent.getName().equals(com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name()))\n+                .filter(clusterComponent -> ComponentType.CDH_PRODUCT_DETAILS.equals(clusterComponent.getComponentType()))\n+                .map(this::getClouderaManagerProduct)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private void upgradeNonCdhServices(Set<ClouderaManagerProduct> services, String cdhServiceName, ParcelResourceApi parcelResourceApi)\n+            throws CloudbreakException, ApiException {\n+        Set<ClouderaManagerProduct> nonCdhServices = getNonCdhServices(services, cdhServiceName);\n+        installServices(nonCdhServices, parcelResourceApi);\n+    }\n+\n+    private void installServices(Set<ClouderaManagerProduct> products, ParcelResourceApi parcelResourceApi) throws ApiException, CloudbreakException {\n+        downloadParcel(products, parcelResourceApi);\n+        distributeParcel(products, parcelResourceApi);\n+        activateParcel(products, parcelResourceApi);\n+    }\n+\n+    private ClouderaManagerProduct getCdhService(Set<ClouderaManagerProduct> products) {", "originalCommit": "6e65c94a334a79f9aa677bba37f1b15188ef4b51", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY3OTUxMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r537679511", "bodyText": "services", "author": "keyki", "createdAt": "2020-12-07T17:14:32Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -170,47 +174,114 @@ public void cleanupCluster(Telemetry telemetry) throws CloudbreakException {\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n-            ClusterComponent stackComponent = getStackComponent(components);\n-\n-            ClouderaManagerProduct stackProduct = stackComponent.getAttributes().get(ClouderaManagerProduct.class);\n-            String stackProductVersion = stackProduct.getVersion();\n-            String stackProductParcel = stackProduct.getParcel();\n-            String product = com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name();\n-\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n-            ParcelsResourceApi parcelsResourceApi = clouderaManagerApiFactory.getParcelsResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n             MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n-            startClouderaManager(stack, apiClient);\n+            startClouderaManager();\n             checkParcelApiAvailability();\n-            setParcelRepo(stackProductParcel, clouderaManagerResourceApi);\n+\n+            Set<ClouderaManagerProduct> services = getServices(components);\n+            ClouderaManagerProduct cdhService = getCdhService(services);\n+            setParcelRepo(services, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n-            downloadParcel(stackProductVersion, parcelResourceApi, product);\n-            distributeParcel(stackProductVersion, parcelResourceApi, product);\n             if (patchUpgrade) {\n-                activateParcel(stackProductVersion, parcelResourceApi, product);\n+                installServices(services, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n-                callUpgradeCdhCommand(stackProductVersion, clustersResourceApi);\n+                upgradeNonCdhServices(services, cdhService.getName(), parcelResourceApi);\n+                upgradeCdh(clustersResourceApi, parcelResourceApi, cdhService);\n                 restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n             }\n-            clouderaManagerParcelService.removeUnusedParcelVersions(apiClient, parcelsResourceApi, parcelResourceApi, stack, product, stackProductVersion);\n+            removeUnusedParcels(components);\n             configService.enableKnoxAutorestartIfCmVersionAtLeast(CLOUDERAMANAGER_VERSION_7_1_0, apiClient, stack.getName());\n-        } catch (ApiException | IOException e) {\n+        } catch (ApiException e) {\n             LOGGER.info(\"Could not upgrade Cloudera Runtime services\", e);\n             throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n         }\n     }\n \n-    private ClusterComponent getStackComponent(Set<ClusterComponent> components) {\n+    private void upgradeCdh(ClustersResourceApi clustersResourceApi, ParcelResourceApi parcelResourceApi, ClouderaManagerProduct cdhService)\n+            throws ApiException, CloudbreakException {\n+        downloadParcel(Collections.singleton(cdhService), parcelResourceApi);\n+        distributeParcel(Collections.singleton(cdhService), parcelResourceApi);\n+        callUpgradeCdhCommand(cdhService, clustersResourceApi);\n+    }\n+\n+    private Set<ClouderaManagerProduct> getServices(Set<ClusterComponent> components) {\n         return components.stream()\n-                .filter(clusterComponent -> clusterComponent.getName().equals(com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name()))\n+                .filter(clusterComponent -> ComponentType.CDH_PRODUCT_DETAILS.equals(clusterComponent.getComponentType()))\n+                .map(this::getClouderaManagerProduct)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private void upgradeNonCdhServices(Set<ClouderaManagerProduct> services, String cdhServiceName, ParcelResourceApi parcelResourceApi)\n+            throws CloudbreakException, ApiException {\n+        Set<ClouderaManagerProduct> nonCdhServices = getNonCdhServices(services, cdhServiceName);\n+        installServices(nonCdhServices, parcelResourceApi);\n+    }\n+\n+    private void installServices(Set<ClouderaManagerProduct> products, ParcelResourceApi parcelResourceApi) throws ApiException, CloudbreakException {\n+        downloadParcel(products, parcelResourceApi);\n+        distributeParcel(products, parcelResourceApi);\n+        activateParcel(products, parcelResourceApi);\n+    }\n+\n+    private ClouderaManagerProduct getCdhService(Set<ClouderaManagerProduct> products) {\n+        return products.stream()\n+                .filter(product -> product.getName().equals(com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name()))\n                 .findFirst()\n                 .orElseThrow(() -> new NotFoundException(\"Runtime component not found!\"));\n     }\n \n+    private Set<ClouderaManagerProduct> getNonCdhServices(Set<ClouderaManagerProduct> products, String cdhProductName) {", "originalCommit": "6e65c94a334a79f9aa677bba37f1b15188ef4b51", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzY4MDQxMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r537680412", "bodyText": "services", "author": "keyki", "createdAt": "2020-12-07T17:15:39Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -170,47 +174,114 @@ public void cleanupCluster(Telemetry telemetry) throws CloudbreakException {\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n-            ClusterComponent stackComponent = getStackComponent(components);\n-\n-            ClouderaManagerProduct stackProduct = stackComponent.getAttributes().get(ClouderaManagerProduct.class);\n-            String stackProductVersion = stackProduct.getVersion();\n-            String stackProductParcel = stackProduct.getParcel();\n-            String product = com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name();\n-\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n-            ParcelsResourceApi parcelsResourceApi = clouderaManagerApiFactory.getParcelsResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n             MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n-            startClouderaManager(stack, apiClient);\n+            startClouderaManager();\n             checkParcelApiAvailability();\n-            setParcelRepo(stackProductParcel, clouderaManagerResourceApi);\n+\n+            Set<ClouderaManagerProduct> services = getServices(components);\n+            ClouderaManagerProduct cdhService = getCdhService(services);\n+            setParcelRepo(services, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n-            downloadParcel(stackProductVersion, parcelResourceApi, product);\n-            distributeParcel(stackProductVersion, parcelResourceApi, product);\n             if (patchUpgrade) {\n-                activateParcel(stackProductVersion, parcelResourceApi, product);\n+                installServices(services, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n-                callUpgradeCdhCommand(stackProductVersion, clustersResourceApi);\n+                upgradeNonCdhServices(services, cdhService.getName(), parcelResourceApi);\n+                upgradeCdh(clustersResourceApi, parcelResourceApi, cdhService);\n                 restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n             }\n-            clouderaManagerParcelService.removeUnusedParcelVersions(apiClient, parcelsResourceApi, parcelResourceApi, stack, product, stackProductVersion);\n+            removeUnusedParcels(components);\n             configService.enableKnoxAutorestartIfCmVersionAtLeast(CLOUDERAMANAGER_VERSION_7_1_0, apiClient, stack.getName());\n-        } catch (ApiException | IOException e) {\n+        } catch (ApiException e) {\n             LOGGER.info(\"Could not upgrade Cloudera Runtime services\", e);\n             throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n         }\n     }\n \n-    private ClusterComponent getStackComponent(Set<ClusterComponent> components) {\n+    private void upgradeCdh(ClustersResourceApi clustersResourceApi, ParcelResourceApi parcelResourceApi, ClouderaManagerProduct cdhService)\n+            throws ApiException, CloudbreakException {\n+        downloadParcel(Collections.singleton(cdhService), parcelResourceApi);\n+        distributeParcel(Collections.singleton(cdhService), parcelResourceApi);\n+        callUpgradeCdhCommand(cdhService, clustersResourceApi);\n+    }\n+\n+    private Set<ClouderaManagerProduct> getServices(Set<ClusterComponent> components) {\n         return components.stream()\n-                .filter(clusterComponent -> clusterComponent.getName().equals(com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name()))\n+                .filter(clusterComponent -> ComponentType.CDH_PRODUCT_DETAILS.equals(clusterComponent.getComponentType()))\n+                .map(this::getClouderaManagerProduct)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private void upgradeNonCdhServices(Set<ClouderaManagerProduct> services, String cdhServiceName, ParcelResourceApi parcelResourceApi)\n+            throws CloudbreakException, ApiException {\n+        Set<ClouderaManagerProduct> nonCdhServices = getNonCdhServices(services, cdhServiceName);\n+        installServices(nonCdhServices, parcelResourceApi);\n+    }\n+\n+    private void installServices(Set<ClouderaManagerProduct> products, ParcelResourceApi parcelResourceApi) throws ApiException, CloudbreakException {\n+        downloadParcel(products, parcelResourceApi);\n+        distributeParcel(products, parcelResourceApi);\n+        activateParcel(products, parcelResourceApi);\n+    }\n+\n+    private ClouderaManagerProduct getCdhService(Set<ClouderaManagerProduct> products) {\n+        return products.stream()\n+                .filter(product -> product.getName().equals(com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name()))\n                 .findFirst()\n                 .orElseThrow(() -> new NotFoundException(\"Runtime component not found!\"));\n     }\n \n+    private Set<ClouderaManagerProduct> getNonCdhServices(Set<ClouderaManagerProduct> products, String cdhProductName) {\n+        return products.stream()\n+                .filter(product -> !product.getName().equals(cdhProductName))\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private ClouderaManagerProduct getClouderaManagerProduct(ClusterComponent clusterComponent) {\n+        try {\n+            return clusterComponent.getAttributes().get(ClouderaManagerProduct.class);\n+        } catch (IOException e) {\n+            LOGGER.info(\"Could not upgrade Cloudera Runtime services\", e);\n+            throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n+        }\n+    }\n+\n+    private void checkParcelApiAvailability() throws CloudbreakException {\n+        clouderaManagerParcelManagementService.checkParcelApiAvailability(stack, apiClient);\n+    }\n+\n+    private void setParcelRepo(Set<ClouderaManagerProduct> products, ClouderaManagerResourceApi clouderaManagerResourceApi) throws ApiException {", "originalCommit": "6e65c94a334a79f9aa677bba37f1b15188ef4b51", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgyNjE1Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r537826152", "bodyText": "What does this list contain on a Data Lake?", "author": "keyki", "createdAt": "2020-12-07T20:55:33Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -170,47 +174,114 @@ public void cleanupCluster(Telemetry telemetry) throws CloudbreakException {\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n-            ClusterComponent stackComponent = getStackComponent(components);\n-\n-            ClouderaManagerProduct stackProduct = stackComponent.getAttributes().get(ClouderaManagerProduct.class);\n-            String stackProductVersion = stackProduct.getVersion();\n-            String stackProductParcel = stackProduct.getParcel();\n-            String product = com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name();\n-\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n-            ParcelsResourceApi parcelsResourceApi = clouderaManagerApiFactory.getParcelsResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n             MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n-            startClouderaManager(stack, apiClient);\n+            startClouderaManager();\n             checkParcelApiAvailability();\n-            setParcelRepo(stackProductParcel, clouderaManagerResourceApi);\n+\n+            Set<ClouderaManagerProduct> services = getServices(components);", "originalCommit": "6e65c94a334a79f9aa677bba37f1b15188ef4b51", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODIwNTc3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r538205774", "bodyText": "Discussed offline.", "author": "keyki", "createdAt": "2020-12-08T10:09:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgyNjE1Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzNzgyNjU2OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r537826568", "bodyText": "We need to skip this part for a DL completely.", "author": "keyki", "createdAt": "2020-12-07T20:56:17Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -170,47 +174,114 @@ public void cleanupCluster(Telemetry telemetry) throws CloudbreakException {\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n-            ClusterComponent stackComponent = getStackComponent(components);\n-\n-            ClouderaManagerProduct stackProduct = stackComponent.getAttributes().get(ClouderaManagerProduct.class);\n-            String stackProductVersion = stackProduct.getVersion();\n-            String stackProductParcel = stackProduct.getParcel();\n-            String product = com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name();\n-\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n-            ParcelsResourceApi parcelsResourceApi = clouderaManagerApiFactory.getParcelsResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n             MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n-            startClouderaManager(stack, apiClient);\n+            startClouderaManager();\n             checkParcelApiAvailability();\n-            setParcelRepo(stackProductParcel, clouderaManagerResourceApi);\n+\n+            Set<ClouderaManagerProduct> services = getServices(components);\n+            ClouderaManagerProduct cdhService = getCdhService(services);\n+            setParcelRepo(services, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n-            downloadParcel(stackProductVersion, parcelResourceApi, product);\n-            distributeParcel(stackProductVersion, parcelResourceApi, product);\n             if (patchUpgrade) {\n-                activateParcel(stackProductVersion, parcelResourceApi, product);\n+                installServices(services, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n-                callUpgradeCdhCommand(stackProductVersion, clustersResourceApi);\n+                upgradeNonCdhServices(services, cdhService.getName(), parcelResourceApi);", "originalCommit": "6e65c94a334a79f9aa677bba37f1b15188ef4b51", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "176893e061c21dd44a353a348bce4af3755e8033", "url": "https://github.com/hortonworks/cloudbreak/commit/176893e061c21dd44a353a348bce4af3755e8033", "message": "CB-9943: Extend the Data Hub CDH runtime upgrade process with upgrading the non-CDH services to a new version what we burned into the new image.", "committedDate": "2020-12-08T07:04:14Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODEwNzU3OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r538107578", "bodyText": "We should use services instead of products in these methods.", "author": "keyki", "createdAt": "2020-12-08T07:45:20Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerParcelManagementService.java", "diffHunk": "@@ -0,0 +1,114 @@\n+package com.sequenceiq.cloudbreak.cm;\n+\n+import static com.sequenceiq.cloudbreak.polling.PollingResult.isExited;\n+import static com.sequenceiq.cloudbreak.polling.PollingResult.isTimeout;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.cloudera.api.swagger.ClouderaManagerResourceApi;\n+import com.cloudera.api.swagger.ParcelResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiConfig;\n+import com.cloudera.api.swagger.model.ApiConfigList;\n+import com.sequenceiq.cloudbreak.cloud.model.ClouderaManagerProduct;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.CancellationException;\n+import com.sequenceiq.cloudbreak.cm.model.ParcelResource;\n+import com.sequenceiq.cloudbreak.cm.polling.ClouderaManagerPollingServiceProvider;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.polling.PollingResult;\n+import com.sequenceiq.cloudbreak.service.CloudbreakException;\n+\n+@Service\n+class ClouderaManagerParcelManagementService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerParcelManagementService.class);\n+\n+    @Inject\n+    private ClouderaManagerPollingServiceProvider clouderaManagerPollingServiceProvider;\n+\n+    void setParcelRepo(Set<ClouderaManagerProduct> products, ClouderaManagerResourceApi clouderaManagerResourceApi) throws ApiException {\n+        Set<String> stackProductParcels = products.stream()\n+                .map(ClouderaManagerProduct::getParcel)\n+                .collect(Collectors.toSet());\n+        LOGGER.info(\"Setting parcel repo to {}\", stackProductParcels);\n+        ApiConfigList apiConfigList = new ApiConfigList()\n+                .addItemsItem(new ApiConfig()\n+                        .name(\"remote_parcel_repo_urls\")\n+                        .value(String.join(\",\", stackProductParcels)));\n+        clouderaManagerResourceApi.updateConfig(\"Updated configurations.\", apiConfigList);\n+    }\n+\n+    void refreshParcelRepos(ClouderaManagerResourceApi clouderaManagerResourceApi, Stack stack, ApiClient apiClient) {\n+        try {\n+            ApiCommand apiCommand = clouderaManagerResourceApi.refreshParcelRepos();\n+            clouderaManagerPollingServiceProvider.startPollingCmParcelRepositoryRefresh(stack, apiClient, apiCommand.getId());\n+        } catch (ApiException e) {\n+            LOGGER.info(\"Unable to refresh parcel repo\", e);\n+            throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n+        }\n+    }\n+\n+    void downloadParcel(Set<ClouderaManagerProduct> products, ParcelResourceApi parcelResourceApi, Stack stack, ApiClient apiClient)", "originalCommit": "176893e061c21dd44a353a348bce4af3755e8033", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "63da714d3f5763b900212c30eff8b488d40eddc3", "url": "https://github.com/hortonworks/cloudbreak/commit/63da714d3f5763b900212c30eff8b488d40eddc3", "message": "CB-9943: Extend the Data Hub CDH runtime upgrade process with upgrading the non-CDH services to a new version what we burned into the new image.", "committedDate": "2020-12-08T07:58:46Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODExNjk1MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r538116951", "bodyText": "Unfortunately, using the components is not going to work now. In the case of Data Lake, it will try to re-activate all parcels that are on the images and that doesn't work.", "author": "keyki", "createdAt": "2020-12-08T08:02:38Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -170,47 +174,114 @@ public void cleanupCluster(Telemetry telemetry) throws CloudbreakException {\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n-            ClusterComponent stackComponent = getStackComponent(components);\n-\n-            ClouderaManagerProduct stackProduct = stackComponent.getAttributes().get(ClouderaManagerProduct.class);\n-            String stackProductVersion = stackProduct.getVersion();\n-            String stackProductParcel = stackProduct.getParcel();\n-            String product = com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name();\n-\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n-            ParcelsResourceApi parcelsResourceApi = clouderaManagerApiFactory.getParcelsResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n             MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n-            startClouderaManager(stack, apiClient);\n+            startClouderaManager();\n             checkParcelApiAvailability();\n-            setParcelRepo(stackProductParcel, clouderaManagerResourceApi);\n+\n+            Set<ClouderaManagerProduct> services = getServices(components);", "originalCommit": "63da714d3f5763b900212c30eff8b488d40eddc3", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c6b677a4017dcf37718e1aa75814bb48a2b98054", "url": "https://github.com/hortonworks/cloudbreak/commit/c6b677a4017dcf37718e1aa75814bb48a2b98054", "message": "CB-9943: Extend the Data Hub CDH runtime upgrade process with upgrading the non-CDH services to a new version what we burned into the new image.", "committedDate": "2020-12-08T13:55:24Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQyODk3MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r538428971", "bodyText": "Can you extend these with log messages? An else branch can be introduced to log that we're skipping non-cdh based activaten. On the other case we can log what are the parcel names that we are going to activate.", "author": "keyki", "createdAt": "2020-12-08T14:24:21Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -170,47 +174,125 @@ public void cleanupCluster(Telemetry telemetry) throws CloudbreakException {\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n-            ClusterComponent stackComponent = getStackComponent(components);\n-\n-            ClouderaManagerProduct stackProduct = stackComponent.getAttributes().get(ClouderaManagerProduct.class);\n-            String stackProductVersion = stackProduct.getVersion();\n-            String stackProductParcel = stackProduct.getParcel();\n-            String product = com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name();\n-\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n-            ParcelsResourceApi parcelsResourceApi = clouderaManagerApiFactory.getParcelsResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n-            MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n-            startClouderaManager(stack, apiClient);\n+            startClouderaManager();\n             checkParcelApiAvailability();\n-            setParcelRepo(stackProductParcel, clouderaManagerResourceApi);\n+\n+            Set<ClouderaManagerProduct> products = getProducts(components);\n+            setParcelRepo(products, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n-            downloadParcel(stackProductVersion, parcelResourceApi, product);\n-            distributeParcel(stackProductVersion, parcelResourceApi, product);\n             if (patchUpgrade) {\n-                activateParcel(stackProductVersion, parcelResourceApi, product);\n+                downloadAndActivateParcels(products, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n-                callUpgradeCdhCommand(stackProductVersion, clustersResourceApi);\n-                restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n+                ClouderaManagerProduct cdhProduct = getCdhProducts(products);\n+                upgradeNonCdhProducts(products, cdhProduct.getName(), parcelResourceApi);\n+                upgradeCdh(clustersResourceApi, parcelResourceApi, cdhProduct);\n+                restartStaleServices(clustersResourceApi);\n             }\n-            clouderaManagerParcelService.removeUnusedParcelVersions(apiClient, parcelsResourceApi, parcelResourceApi, stack, product, stackProductVersion);\n+            removeUnusedParcelVersions(parcelResourceApi, products);\n             configService.enableKnoxAutorestartIfCmVersionAtLeast(CLOUDERAMANAGER_VERSION_7_1_0, apiClient, stack.getName());\n-        } catch (ApiException | IOException e) {\n+        } catch (ApiException e) {\n             LOGGER.info(\"Could not upgrade Cloudera Runtime services\", e);\n             throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n         }\n     }\n \n-    private ClusterComponent getStackComponent(Set<ClusterComponent> components) {\n+    private void upgradeCdh(ClustersResourceApi clustersResourceApi, ParcelResourceApi parcelResourceApi, ClouderaManagerProduct cdhService)\n+            throws ApiException, CloudbreakException {\n+        downloadParcels(Collections.singleton(cdhService), parcelResourceApi);\n+        distributeParcels(Collections.singleton(cdhService), parcelResourceApi);\n+        callUpgradeCdhCommand(cdhService, clustersResourceApi);\n+    }\n+\n+    private Set<ClouderaManagerProduct> getProducts(Set<ClusterComponent> components) {\n         return components.stream()\n-                .filter(clusterComponent -> clusterComponent.getName().equals(com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name()))\n+                .filter(clusterComponent -> ComponentType.CDH_PRODUCT_DETAILS.equals(clusterComponent.getComponentType()))\n+                .map(this::getClouderaManagerProduct)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private void upgradeNonCdhProducts(Set<ClouderaManagerProduct> services, String cdhServiceName, ParcelResourceApi parcelResourceApi)\n+            throws CloudbreakException, ApiException {\n+        Set<ClouderaManagerProduct> nonCdhServices = getNonCdhProducts(services, cdhServiceName);\n+        if (!nonCdhServices.isEmpty()) {", "originalCommit": "c6b677a4017dcf37718e1aa75814bb48a2b98054", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQyOTE1Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r538429153", "bodyText": "services -> products", "author": "keyki", "createdAt": "2020-12-08T14:24:30Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerModificationService.java", "diffHunk": "@@ -170,47 +174,125 @@ public void cleanupCluster(Telemetry telemetry) throws CloudbreakException {\n     @Override\n     public void upgradeClusterRuntime(Set<ClusterComponent> components, boolean patchUpgrade) throws CloudbreakException {\n         try {\n-            ClusterComponent stackComponent = getStackComponent(components);\n-\n-            ClouderaManagerProduct stackProduct = stackComponent.getAttributes().get(ClouderaManagerProduct.class);\n-            String stackProductVersion = stackProduct.getVersion();\n-            String stackProductParcel = stackProduct.getParcel();\n-            String product = com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name();\n-\n             ClustersResourceApi clustersResourceApi = clouderaManagerApiFactory.getClustersResourceApi(apiClient);\n-            ParcelsResourceApi parcelsResourceApi = clouderaManagerApiFactory.getParcelsResourceApi(apiClient);\n             ParcelResourceApi parcelResourceApi = clouderaManagerApiFactory.getParcelResourceApi(apiClient);\n-            MgmtServiceResourceApi mgmtServiceResourceApi = clouderaManagerApiFactory.getMgmtServiceResourceApi(apiClient);\n             ClouderaManagerResourceApi clouderaManagerResourceApi = clouderaManagerApiFactory.getClouderaManagerResourceApi(apiClient);\n \n-            startClouderaManager(stack, apiClient);\n+            startClouderaManager();\n             checkParcelApiAvailability();\n-            setParcelRepo(stackProductParcel, clouderaManagerResourceApi);\n+\n+            Set<ClouderaManagerProduct> products = getProducts(components);\n+            setParcelRepo(products, clouderaManagerResourceApi);\n             refreshParcelRepos(clouderaManagerResourceApi);\n-            downloadParcel(stackProductVersion, parcelResourceApi, product);\n-            distributeParcel(stackProductVersion, parcelResourceApi, product);\n             if (patchUpgrade) {\n-                activateParcel(stackProductVersion, parcelResourceApi, product);\n+                downloadAndActivateParcels(products, parcelResourceApi);\n                 restartServices(clustersResourceApi);\n             } else {\n-                callUpgradeCdhCommand(stackProductVersion, clustersResourceApi);\n-                restartStaleServices(mgmtServiceResourceApi, clustersResourceApi);\n+                ClouderaManagerProduct cdhProduct = getCdhProducts(products);\n+                upgradeNonCdhProducts(products, cdhProduct.getName(), parcelResourceApi);\n+                upgradeCdh(clustersResourceApi, parcelResourceApi, cdhProduct);\n+                restartStaleServices(clustersResourceApi);\n             }\n-            clouderaManagerParcelService.removeUnusedParcelVersions(apiClient, parcelsResourceApi, parcelResourceApi, stack, product, stackProductVersion);\n+            removeUnusedParcelVersions(parcelResourceApi, products);\n             configService.enableKnoxAutorestartIfCmVersionAtLeast(CLOUDERAMANAGER_VERSION_7_1_0, apiClient, stack.getName());\n-        } catch (ApiException | IOException e) {\n+        } catch (ApiException e) {\n             LOGGER.info(\"Could not upgrade Cloudera Runtime services\", e);\n             throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n         }\n     }\n \n-    private ClusterComponent getStackComponent(Set<ClusterComponent> components) {\n+    private void upgradeCdh(ClustersResourceApi clustersResourceApi, ParcelResourceApi parcelResourceApi, ClouderaManagerProduct cdhService)\n+            throws ApiException, CloudbreakException {\n+        downloadParcels(Collections.singleton(cdhService), parcelResourceApi);\n+        distributeParcels(Collections.singleton(cdhService), parcelResourceApi);\n+        callUpgradeCdhCommand(cdhService, clustersResourceApi);\n+    }\n+\n+    private Set<ClouderaManagerProduct> getProducts(Set<ClusterComponent> components) {\n         return components.stream()\n-                .filter(clusterComponent -> clusterComponent.getName().equals(com.sequenceiq.cloudbreak.cloud.model.component.StackType.CDH.name()))\n+                .filter(clusterComponent -> ComponentType.CDH_PRODUCT_DETAILS.equals(clusterComponent.getComponentType()))\n+                .map(this::getClouderaManagerProduct)\n+                .collect(Collectors.toSet());\n+    }\n+\n+    private void upgradeNonCdhProducts(Set<ClouderaManagerProduct> services, String cdhServiceName, ParcelResourceApi parcelResourceApi)", "originalCommit": "c6b677a4017dcf37718e1aa75814bb48a2b98054", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzODQ1NzU3Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r538457577", "bodyText": "Can you please add a log message that we're skipping the CSD update because it's a Data Lake", "author": "keyki", "createdAt": "2020-12-08T14:51:17Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/cluster/ClusterManagerUpgradeService.java", "diffHunk": "@@ -98,12 +99,19 @@ private void startClusterServices(Stack stack) throws CloudbreakException {\n         clusterApiConnectors.getConnector(stack).startCluster();\n     }\n \n-    private SaltConfig createSaltConfig(Cluster cluster) {\n+    private SaltConfig createSaltConfig(Long stackId, StackType stackType, Cluster cluster) {\n         Map<String, SaltPillarProperties> servicePillar = new HashMap<>();\n         ClouderaManagerRepo clouderaManagerRepo = clusterComponentConfigProvider.getClouderaManagerRepoDetails(cluster.getId());\n-        Optional<String> license = clusterHostServiceRunner.decoratePillarWithClouderaManagerLicense(cluster.getStack().getId(), servicePillar);\n+        Optional<String> license = clusterHostServiceRunner.decoratePillarWithClouderaManagerLicense(stackId, servicePillar);\n         clusterHostServiceRunner.decoratePillarWithClouderaManagerRepo(clouderaManagerRepo, servicePillar, license);\n         clusterHostServiceRunner.decoratePillarWithClouderaManagerSettings(servicePillar, clouderaManagerRepo);\n+        decorateWorkloadClusterPillarWithCsdDownloader(stackType, cluster, servicePillar);\n         return new SaltConfig(servicePillar);\n     }\n+\n+    private void decorateWorkloadClusterPillarWithCsdDownloader(StackType stackType, Cluster cluster, Map<String, SaltPillarProperties> servicePillar) {\n+        if (StackType.WORKLOAD.equals(stackType)) {", "originalCommit": "c6b677a4017dcf37718e1aa75814bb48a2b98054", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "3dd2e3743b309a7d2b9ee6625d9824d692de3d5a", "url": "https://github.com/hortonworks/cloudbreak/commit/3dd2e3743b309a7d2b9ee6625d9824d692de3d5a", "message": "CB-9943: Extend the Data Hub CDH runtime upgrade process with upgrading the non-CDH services.\n\nIn this commit we've introduced some changes in connection with Data Hub upgrade:\n- CSD downloading: To upgrade a non-CDH service may require the same version of the CSD what the new version is. By default the old CSD files are already present in the image, therefore we need to download the new ones. This process is handled by a shell script that we add to the host at the beginning of the upgrade process.\n  In the case of Data Lake upgrade, we don't need to download the new CSD files because we're not upgrading the non-CDH services.\n\n- Upgrading the non-CDH services (Spark, Nifi, etc...) has a different flow than the regular CDH runtime upgrade. We need to download, distribute, and activate the new parcels, then restart the affected services. There is no upgrade command to call.\n  After the non-CDH services have been upgraded the flow continues with upgrading the CDH runtime. This whole process does not affect to the Data Lake upgrade flow. We just upgrade only the CDH version like before.", "committedDate": "2020-12-09T13:16:35Z", "type": "forcePushed"}, {"oid": "ea33bf51fad282def4ee059698c8eb1fabda08da", "url": "https://github.com/hortonworks/cloudbreak/commit/ea33bf51fad282def4ee059698c8eb1fabda08da", "message": "CB-9943: Extend the Data Hub CDH runtime upgrade process with upgrading the non-CDH services.\n\nIn this commit we've introduced some changes in connection with Data Hub upgrade:\n- CSD downloading: To upgrade a non-CDH service may require the same version of the CSD what the new version is. By default the old CSD files are already present in the image, therefore we need to download the new ones. This process is handled by a shell script that we add to the host at the beginning of the upgrade process.\n  In the case of Data Lake upgrade, we don't need to download the new CSD files because we're not upgrading the non-CDH services.\n\n- Upgrading the non-CDH services (Spark, Nifi, etc...) has a different flow than the regular CDH runtime upgrade. We need to download, distribute, and activate the new parcels, then restart the affected services. There is no upgrade command to call.\n  After the non-CDH services have been upgraded the flow continues with upgrading the CDH runtime. This whole process does not affect to the Data Lake upgrade flow. We just upgrade only the CDH version like before.", "committedDate": "2020-12-09T14:06:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4ODEwMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r539388101", "bodyText": "Can you please cover this part with a unit test to make sure we don't update the CSDs in the case of Data Lake. If we break this then the complete Data Lake upgrade will be broken as the CSDs are not downloadable outside of Cloudera.", "author": "keyki", "createdAt": "2020-12-09T15:11:35Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/cluster/ClusterManagerUpgradeService.java", "diffHunk": "@@ -98,12 +99,21 @@ private void startClusterServices(Stack stack) throws CloudbreakException {\n         clusterApiConnectors.getConnector(stack).startCluster();\n     }\n \n-    private SaltConfig createSaltConfig(Cluster cluster) {\n+    private SaltConfig createSaltConfig(Long stackId, StackType stackType, Cluster cluster) {\n         Map<String, SaltPillarProperties> servicePillar = new HashMap<>();\n         ClouderaManagerRepo clouderaManagerRepo = clusterComponentConfigProvider.getClouderaManagerRepoDetails(cluster.getId());\n-        Optional<String> license = clusterHostServiceRunner.decoratePillarWithClouderaManagerLicense(cluster.getStack().getId(), servicePillar);\n+        Optional<String> license = clusterHostServiceRunner.decoratePillarWithClouderaManagerLicense(stackId, servicePillar);\n         clusterHostServiceRunner.decoratePillarWithClouderaManagerRepo(clouderaManagerRepo, servicePillar, license);\n         clusterHostServiceRunner.decoratePillarWithClouderaManagerSettings(servicePillar, clouderaManagerRepo);\n+        decorateWorkloadClusterPillarWithCsdDownloader(stackType, cluster, servicePillar);\n         return new SaltConfig(servicePillar);\n     }\n+\n+    private void decorateWorkloadClusterPillarWithCsdDownloader(StackType stackType, Cluster cluster, Map<String, SaltPillarProperties> servicePillar) {\n+        if (StackType.WORKLOAD.equals(stackType)) {", "originalCommit": "ea33bf51fad282def4ee059698c8eb1fabda08da", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTQxMTYyOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r539411628", "bodyText": "Also, this could be improved that only update the CSDs if needed and those CSDs that are needed. But this does not need to be part of this PR.  (Filed a jira for this one CB-10265)", "author": "keyki", "createdAt": "2020-12-09T15:38:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUzOTM4ODEwMQ=="}], "type": "inlineReview"}, {"oid": "dec7e013ca68fa7597188952d5bb435ffea70d9d", "url": "https://github.com/hortonworks/cloudbreak/commit/dec7e013ca68fa7597188952d5bb435ffea70d9d", "message": "CB-9943: Extend the Data Hub CDH runtime upgrade process with upgrading the non-CDH services.\n\nIn this commit we've introduced some changes in connection with Data Hub upgrade:\n- CSD downloading: To upgrade a non-CDH service may require the same version of the CSD what the new version is. By default the old CSD files are already present in the image, therefore we need to download the new ones. This process is handled by a shell script that we add to the host at the beginning of the upgrade process.\n  In the case of Data Lake upgrade, we don't need to download the new CSD files because we're not upgrading the non-CDH services.\n\n- Upgrading the non-CDH services (Spark, Nifi, etc...) has a different flow than the regular CDH runtime upgrade. We need to download, distribute, and activate the new parcels, then restart the affected services. There is no upgrade command to call.\n  After the non-CDH services have been upgraded the flow continues with upgrading the CDH runtime. This whole process does not affect to the Data Lake upgrade flow. We just upgrade only the CDH version like before.", "committedDate": "2020-12-09T17:03:35Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA1ODY4NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r540058684", "bodyText": "this part is duplicated a few times, message maybe different a bit, but that could be a parameter", "author": "lacikaaa", "createdAt": "2020-12-10T10:36:26Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerParcelManagementService.java", "diffHunk": "@@ -0,0 +1,115 @@\n+package com.sequenceiq.cloudbreak.cm;\n+\n+import static com.sequenceiq.cloudbreak.polling.PollingResult.isExited;\n+import static com.sequenceiq.cloudbreak.polling.PollingResult.isTimeout;\n+\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.cloudera.api.swagger.ClouderaManagerResourceApi;\n+import com.cloudera.api.swagger.ParcelResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiConfig;\n+import com.cloudera.api.swagger.model.ApiConfigList;\n+import com.sequenceiq.cloudbreak.cloud.model.ClouderaManagerProduct;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.CancellationException;\n+import com.sequenceiq.cloudbreak.cm.model.ParcelResource;\n+import com.sequenceiq.cloudbreak.cm.polling.ClouderaManagerPollingServiceProvider;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.polling.PollingResult;\n+import com.sequenceiq.cloudbreak.service.CloudbreakException;\n+\n+@Service\n+class ClouderaManagerParcelManagementService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerParcelManagementService.class);\n+\n+    @Inject\n+    private ClouderaManagerPollingServiceProvider clouderaManagerPollingServiceProvider;\n+\n+    void setParcelRepos(Set<ClouderaManagerProduct> products, ClouderaManagerResourceApi clouderaManagerResourceApi) throws ApiException {\n+        Set<String> stackProductParcels = products.stream()\n+                .map(ClouderaManagerProduct::getParcel)\n+                .collect(Collectors.toSet());\n+        LOGGER.info(\"Setting parcel repo to {}\", stackProductParcels);\n+        ApiConfigList apiConfigList = new ApiConfigList()\n+                .addItemsItem(new ApiConfig()\n+                        .name(\"remote_parcel_repo_urls\")\n+                        .value(String.join(\",\", stackProductParcels)));\n+        clouderaManagerResourceApi.updateConfig(\"Updated configurations.\", apiConfigList);\n+    }\n+\n+    void refreshParcelRepos(ClouderaManagerResourceApi clouderaManagerResourceApi, Stack stack, ApiClient apiClient) {\n+        try {\n+            LOGGER.info(\"Refreshing parcel repos.\");\n+            ApiCommand apiCommand = clouderaManagerResourceApi.refreshParcelRepos();\n+            clouderaManagerPollingServiceProvider.startPollingCmParcelRepositoryRefresh(stack, apiClient, apiCommand.getId());\n+        } catch (ApiException e) {\n+            LOGGER.info(\"Unable to refresh parcel repo\", e);\n+            throw new ClouderaManagerOperationFailedException(e.getMessage(), e);\n+        }\n+    }\n+\n+    void downloadParcels(Set<ClouderaManagerProduct> products, ParcelResourceApi parcelResourceApi, Stack stack, ApiClient apiClient)\n+            throws ApiException, CloudbreakException {\n+        for (ClouderaManagerProduct product : products) {\n+            LOGGER.info(\"Downloading {} parcel.\", product.getName());\n+            ApiCommand apiCommand = parcelResourceApi.startDownloadCommand(stack.getName(), product.getName(), product.getVersion());\n+            PollingResult pollingResult = clouderaManagerPollingServiceProvider.startPollingCdpRuntimeParcelDownload(\n+                    stack, apiClient, apiCommand.getId(), new ParcelResource(stack.getName(), product.getName(), product.getVersion()));\n+            if (isExited(pollingResult)) {\n+                throw new CancellationException(\"Cluster was terminated while waiting for CDP Runtime Parcel to be downloaded\");\n+            } else if (isTimeout(pollingResult)) {\n+                throw new CloudbreakException(\"Timeout during the updated CDP Runtime Parcel download.\");\n+            }", "originalCommit": "dec7e013ca68fa7597188952d5bb435ffea70d9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA1OTkzOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r540059939", "bodyText": "it's kinda the same here, duplicating the same 5 lines, maybe it should be moved some util like thing or a component", "author": "lacikaaa", "createdAt": "2020-12-10T10:38:16Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerUpgradeService.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package com.sequenceiq.cloudbreak.cm;\n+\n+import static com.sequenceiq.cloudbreak.polling.PollingResult.isExited;\n+import static com.sequenceiq.cloudbreak.polling.PollingResult.isTimeout;\n+\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.cloudera.api.swagger.ClustersResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiCdhUpgradeArgs;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiCommandList;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.CancellationException;\n+import com.sequenceiq.cloudbreak.cm.polling.ClouderaManagerPollingServiceProvider;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.polling.PollingResult;\n+import com.sequenceiq.cloudbreak.service.CloudbreakException;\n+\n+@Service\n+class ClouderaManagerUpgradeService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerUpgradeService.class);\n+\n+    private static final String SUMMARY = \"SUMMARY\";\n+\n+    @Inject\n+    private ClouderaManagerPollingServiceProvider clouderaManagerPollingServiceProvider;\n+\n+    void callUpgradeCdhCommand(String stackProductVersion, ClustersResourceApi clustersResourceApi, Stack stack, ApiClient apiClient)\n+            throws ApiException, CloudbreakException {\n+        LOGGER.info(\"Upgrading the CDP Runtime...\");\n+        Optional<ApiCommand> optionalUpgradeCommand = findUpgradeApiCommand(clustersResourceApi, stack);\n+        try {\n+            ApiCommand upgradeCommand;\n+            if (optionalUpgradeCommand.isPresent()) {\n+                upgradeCommand = optionalUpgradeCommand.get();\n+                LOGGER.debug(\"Upgrade of CDP Runtime is already running with id: [{}]\", upgradeCommand.getId());\n+            } else {\n+                ApiCdhUpgradeArgs upgradeArgs = new ApiCdhUpgradeArgs();\n+                upgradeArgs.setCdhParcelVersion(stackProductVersion);\n+                upgradeCommand = clustersResourceApi.upgradeCdhCommand(stack.getName(), upgradeArgs);\n+            }\n+            PollingResult pollingResult = clouderaManagerPollingServiceProvider.startPollingCdpRuntimeUpgrade(stack, apiClient, upgradeCommand.getId());\n+            if (isExited(pollingResult)) {\n+                throw new CancellationException(\"Cluster was terminated while waiting for CDP Runtime to be upgraded\");\n+            } else if (isTimeout(pollingResult)) {\n+                throw new CloudbreakException(\"Timeout during CDP Runtime upgrade.\");\n+            }", "originalCommit": "dec7e013ca68fa7597188952d5bb435ffea70d9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU0MDA2MDg0MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9593#discussion_r540060840", "bodyText": "null check for response body?", "author": "lacikaaa", "createdAt": "2020-12-10T10:39:33Z", "path": "cluster-cm/src/main/java/com/sequenceiq/cloudbreak/cm/ClouderaManagerUpgradeService.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package com.sequenceiq.cloudbreak.cm;\n+\n+import static com.sequenceiq.cloudbreak.polling.PollingResult.isExited;\n+import static com.sequenceiq.cloudbreak.polling.PollingResult.isTimeout;\n+\n+import java.util.Optional;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.cloudera.api.swagger.ClustersResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiCdhUpgradeArgs;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiCommandList;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.CancellationException;\n+import com.sequenceiq.cloudbreak.cm.polling.ClouderaManagerPollingServiceProvider;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.polling.PollingResult;\n+import com.sequenceiq.cloudbreak.service.CloudbreakException;\n+\n+@Service\n+class ClouderaManagerUpgradeService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerUpgradeService.class);\n+\n+    private static final String SUMMARY = \"SUMMARY\";\n+\n+    @Inject\n+    private ClouderaManagerPollingServiceProvider clouderaManagerPollingServiceProvider;\n+\n+    void callUpgradeCdhCommand(String stackProductVersion, ClustersResourceApi clustersResourceApi, Stack stack, ApiClient apiClient)\n+            throws ApiException, CloudbreakException {\n+        LOGGER.info(\"Upgrading the CDP Runtime...\");\n+        Optional<ApiCommand> optionalUpgradeCommand = findUpgradeApiCommand(clustersResourceApi, stack);\n+        try {\n+            ApiCommand upgradeCommand;\n+            if (optionalUpgradeCommand.isPresent()) {\n+                upgradeCommand = optionalUpgradeCommand.get();\n+                LOGGER.debug(\"Upgrade of CDP Runtime is already running with id: [{}]\", upgradeCommand.getId());\n+            } else {\n+                ApiCdhUpgradeArgs upgradeArgs = new ApiCdhUpgradeArgs();\n+                upgradeArgs.setCdhParcelVersion(stackProductVersion);\n+                upgradeCommand = clustersResourceApi.upgradeCdhCommand(stack.getName(), upgradeArgs);\n+            }\n+            PollingResult pollingResult = clouderaManagerPollingServiceProvider.startPollingCdpRuntimeUpgrade(stack, apiClient, upgradeCommand.getId());\n+            if (isExited(pollingResult)) {\n+                throw new CancellationException(\"Cluster was terminated while waiting for CDP Runtime to be upgraded\");\n+            } else if (isTimeout(pollingResult)) {\n+                throw new CloudbreakException(\"Timeout during CDP Runtime upgrade.\");\n+            }\n+        } catch (ApiException ex) {\n+            if (ex.getResponseBody().contains(\"Cannot upgrade because the version is already CDH\")) {", "originalCommit": "dec7e013ca68fa7597188952d5bb435ffea70d9d", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "28319cc0f8cb174591627f8857853484f31208cd", "url": "https://github.com/hortonworks/cloudbreak/commit/28319cc0f8cb174591627f8857853484f31208cd", "message": "CB-9943: Extend the Data Hub CDH runtime upgrade process with upgrading the non-CDH services.\n\nIn this commit we've introduced some changes in connection with Data Hub upgrade:\n- CSD downloading: To upgrade a non-CDH service may require the same version of the CSD what the new version is. By default the old CSD files are already present in the image, therefore we need to download the new ones. This process is handled by a shell script that we add to the host at the beginning of the upgrade process.\n  In the case of Data Lake upgrade, we don't need to download the new CSD files because we're not upgrading the non-CDH services.\n\n- Upgrading the non-CDH services (Spark, Nifi, etc...) has a different flow than the regular CDH runtime upgrade. We need to download, distribute, and activate the new parcels, then restart the affected services. There is no upgrade command to call.\n  After the non-CDH services have been upgraded the flow continues with upgrading the CDH runtime. This whole process does not affect to the Data Lake upgrade flow. We just upgrade only the CDH version like before.", "committedDate": "2020-12-10T16:59:43Z", "type": "commit"}, {"oid": "28319cc0f8cb174591627f8857853484f31208cd", "url": "https://github.com/hortonworks/cloudbreak/commit/28319cc0f8cb174591627f8857853484f31208cd", "message": "CB-9943: Extend the Data Hub CDH runtime upgrade process with upgrading the non-CDH services.\n\nIn this commit we've introduced some changes in connection with Data Hub upgrade:\n- CSD downloading: To upgrade a non-CDH service may require the same version of the CSD what the new version is. By default the old CSD files are already present in the image, therefore we need to download the new ones. This process is handled by a shell script that we add to the host at the beginning of the upgrade process.\n  In the case of Data Lake upgrade, we don't need to download the new CSD files because we're not upgrading the non-CDH services.\n\n- Upgrading the non-CDH services (Spark, Nifi, etc...) has a different flow than the regular CDH runtime upgrade. We need to download, distribute, and activate the new parcels, then restart the affected services. There is no upgrade command to call.\n  After the non-CDH services have been upgraded the flow continues with upgrading the CDH runtime. This whole process does not affect to the Data Lake upgrade flow. We just upgrade only the CDH version like before.", "committedDate": "2020-12-10T16:59:43Z", "type": "forcePushed"}]}