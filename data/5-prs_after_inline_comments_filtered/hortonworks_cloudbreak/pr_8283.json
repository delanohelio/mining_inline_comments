{"pr_number": 8283, "pr_title": "CB-5945 Enforce authz annotation on specific fields of request object", "pr_createdAt": "2020-06-15T16:06:58Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/8283", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4ODYzMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8283#discussion_r440288633", "bodyText": "is it possible to replace these with stream methods?", "author": "horadla23", "createdAt": "2020-06-15T16:11:05Z", "path": "authorization-common/src/test/java/com/sequenceiq/authorization/EnforceAuthorizationLogicsUtil.java", "diffHunk": "@@ -62,18 +124,239 @@ public static void testIfControllerClassHasAuthorizationAnnotation() {\n         Set<String> controllersWithoutAnnotation = Sets.difference(controllersClasses, Sets.union(authorizationResourceClasses, disabledAuthorizationClasses));\n \n         assertTrue(\"These controllers are missing @AuthorizationResource annotation: \" + Joiner.on(\",\").join(controllersWithoutAnnotation),\n-                controllersWithoutAnnotation.size() == 0);\n+                controllersWithoutAnnotation.isEmpty());\n     }\n \n     public static void testIfControllerMethodsHaveProperAuthorizationAnnotation() {\n         Set<Class<?>> authorizationResourceClasses = REFLECTIONS.getTypesAnnotatedWith(AuthorizationResource.class);\n-        Set<String> methodsWithoutAnnotation = Sets.newHashSet();\n-        authorizationResourceClasses.stream().forEach(authzClass -> Arrays.stream(authzClass.getDeclaredMethods())\n-            .filter(method -> Modifier.isPublic(method.getModifiers()) && !AuthorizationAnnotationUtils.getPossibleMethodAnnotations().stream()\n-                    .filter(annotation -> method.isAnnotationPresent(annotation)).findAny().isPresent())\n-            .forEach(method -> methodsWithoutAnnotation.add(authzClass.getSimpleName() + \"#\" + method.getName())));\n-\n-        assertTrue(\"These controller methods are missing any authorization related annotation: \"\n-                        + Joiner.on(\",\").join(methodsWithoutAnnotation), methodsWithoutAnnotation.size() == 0);\n+        List<String> validationErrors = authorizationResourceClasses\n+                .stream()\n+                .map(Class::getDeclaredMethods)\n+                .flatMap(Arrays::stream)\n+                .filter(method -> Modifier.isPublic(method.getModifiers()))\n+                .map(EnforceAuthorizationLogicsUtil::validateMethod)\n+                .flatMap(Collection::stream)\n+                .collect(toList());\n+        assertTrue(Joiner.on(System.lineSeparator()).join(validationErrors), validationErrors.isEmpty());\n+    }\n+\n+    private static List<String> validateMethod(Method method) {\n+        List<Class<? extends Annotation>> annotations = AuthorizationAnnotationUtils\n+                .getPossibleMethodAnnotations()\n+                .stream()\n+                .filter(method::isAnnotationPresent)\n+                .collect(toList());\n+        if (annotations.isEmpty()) {\n+            return List.of(invalid(method, \"Missing aithz annotation.\"));\n+        } else {\n+            return annotations\n+                    .stream()\n+                    .map(annotation -> METHOD_VALIDATORS.getOrDefault(annotation, unknownAnnotation(annotation)).apply(method))\n+                    .filter(Optional::isPresent)\n+                    .map(Optional::get)\n+                    .map(Object::toString)\n+                    .collect(toList());\n+        }\n+    }\n+\n+    private static String invalid(Method method, String reason) {\n+        return methodToString(method) + \": \" + reason;\n+    }\n+\n+    private static Function<Method, Optional<String>> noRestriction() {\n+        return method -> Optional.empty();\n+    }\n+\n+    private static Function<Method, Optional<String>> unknownAnnotation(Class<? extends Annotation> annotation) {\n+        return method -> Optional.of(invalid(method, \"No validation rule specified for \" + annotation));\n+    }\n+\n+    private static String methodToString(Method method) {\n+        return method.getDeclaringClass().getSimpleName() + '#' + method.getName();\n+    }\n+\n+    private static Function<Method, Optional<String>> hasParamWhere(Class<? extends Annotation> annotation,\n+            Function<Pair<Method, Class<?>>, Optional<String>> typeValidator) {\n+        return method -> {\n+            List<Optional<String>> validations = new ArrayList<>();\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation)) {\n+                    validations.add(typeValidator.apply(Pair.of(method, parameter.getType())));\n+                }\n+            }\n+            String errorMessageCommon = \" method param with @\" + annotation.getSimpleName() + \" annotation\";\n+            if (validations.isEmpty()) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (validations.size() > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return validations.get(0);\n+            }\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> stringParam(Class<? extends Annotation> annotation) {\n+        return hasParam(annotation, String.class);\n+    }\n+\n+    private static Function<Method, Optional<String>> hasParam(Class<? extends Annotation> annotation, Class<?> type) {\n+        return method -> {\n+            int count = 0;\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation) && type.equals(parameter.getType())) {\n+                    count++;\n+                }\n+            }\n+            String errorMessageCommon = \" method parameter with @\" + annotation.getSimpleName() + \" annotation and type \" + type.getSimpleName();\n+            if (count == 0) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (count > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return Optional.empty();\n+            }\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> noParamsWith(Class<? extends Annotation>... annotations) {\n+        return method -> {\n+            for (Parameter parameter : method.getParameters()) {\n+                for (Class<? extends Annotation> annotation : annotations) {\n+                    if (parameter.isAnnotationPresent(annotation)) {\n+                        Optional.of(invalid(method, '@' + annotation.getSimpleName() + \" annotation is not allowed here\"));\n+                    }\n+                }\n+            }", "originalCommit": "6ad0d8b96f5be7152950c53c4bd806c4e6fa78fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5NzIzNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8283#discussion_r440297234", "bodyText": "yes", "author": "foldik", "createdAt": "2020-06-15T16:24:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4ODYzMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4ODc5Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8283#discussion_r440288796", "bodyText": "same here", "author": "horadla23", "createdAt": "2020-06-15T16:11:18Z", "path": "authorization-common/src/test/java/com/sequenceiq/authorization/EnforceAuthorizationLogicsUtil.java", "diffHunk": "@@ -62,18 +124,239 @@ public static void testIfControllerClassHasAuthorizationAnnotation() {\n         Set<String> controllersWithoutAnnotation = Sets.difference(controllersClasses, Sets.union(authorizationResourceClasses, disabledAuthorizationClasses));\n \n         assertTrue(\"These controllers are missing @AuthorizationResource annotation: \" + Joiner.on(\",\").join(controllersWithoutAnnotation),\n-                controllersWithoutAnnotation.size() == 0);\n+                controllersWithoutAnnotation.isEmpty());\n     }\n \n     public static void testIfControllerMethodsHaveProperAuthorizationAnnotation() {\n         Set<Class<?>> authorizationResourceClasses = REFLECTIONS.getTypesAnnotatedWith(AuthorizationResource.class);\n-        Set<String> methodsWithoutAnnotation = Sets.newHashSet();\n-        authorizationResourceClasses.stream().forEach(authzClass -> Arrays.stream(authzClass.getDeclaredMethods())\n-            .filter(method -> Modifier.isPublic(method.getModifiers()) && !AuthorizationAnnotationUtils.getPossibleMethodAnnotations().stream()\n-                    .filter(annotation -> method.isAnnotationPresent(annotation)).findAny().isPresent())\n-            .forEach(method -> methodsWithoutAnnotation.add(authzClass.getSimpleName() + \"#\" + method.getName())));\n-\n-        assertTrue(\"These controller methods are missing any authorization related annotation: \"\n-                        + Joiner.on(\",\").join(methodsWithoutAnnotation), methodsWithoutAnnotation.size() == 0);\n+        List<String> validationErrors = authorizationResourceClasses\n+                .stream()\n+                .map(Class::getDeclaredMethods)\n+                .flatMap(Arrays::stream)\n+                .filter(method -> Modifier.isPublic(method.getModifiers()))\n+                .map(EnforceAuthorizationLogicsUtil::validateMethod)\n+                .flatMap(Collection::stream)\n+                .collect(toList());\n+        assertTrue(Joiner.on(System.lineSeparator()).join(validationErrors), validationErrors.isEmpty());\n+    }\n+\n+    private static List<String> validateMethod(Method method) {\n+        List<Class<? extends Annotation>> annotations = AuthorizationAnnotationUtils\n+                .getPossibleMethodAnnotations()\n+                .stream()\n+                .filter(method::isAnnotationPresent)\n+                .collect(toList());\n+        if (annotations.isEmpty()) {\n+            return List.of(invalid(method, \"Missing aithz annotation.\"));\n+        } else {\n+            return annotations\n+                    .stream()\n+                    .map(annotation -> METHOD_VALIDATORS.getOrDefault(annotation, unknownAnnotation(annotation)).apply(method))\n+                    .filter(Optional::isPresent)\n+                    .map(Optional::get)\n+                    .map(Object::toString)\n+                    .collect(toList());\n+        }\n+    }\n+\n+    private static String invalid(Method method, String reason) {\n+        return methodToString(method) + \": \" + reason;\n+    }\n+\n+    private static Function<Method, Optional<String>> noRestriction() {\n+        return method -> Optional.empty();\n+    }\n+\n+    private static Function<Method, Optional<String>> unknownAnnotation(Class<? extends Annotation> annotation) {\n+        return method -> Optional.of(invalid(method, \"No validation rule specified for \" + annotation));\n+    }\n+\n+    private static String methodToString(Method method) {\n+        return method.getDeclaringClass().getSimpleName() + '#' + method.getName();\n+    }\n+\n+    private static Function<Method, Optional<String>> hasParamWhere(Class<? extends Annotation> annotation,\n+            Function<Pair<Method, Class<?>>, Optional<String>> typeValidator) {\n+        return method -> {\n+            List<Optional<String>> validations = new ArrayList<>();\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation)) {\n+                    validations.add(typeValidator.apply(Pair.of(method, parameter.getType())));\n+                }\n+            }\n+            String errorMessageCommon = \" method param with @\" + annotation.getSimpleName() + \" annotation\";\n+            if (validations.isEmpty()) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (validations.size() > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return validations.get(0);\n+            }\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> stringParam(Class<? extends Annotation> annotation) {\n+        return hasParam(annotation, String.class);\n+    }\n+\n+    private static Function<Method, Optional<String>> hasParam(Class<? extends Annotation> annotation, Class<?> type) {\n+        return method -> {\n+            int count = 0;\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation) && type.equals(parameter.getType())) {\n+                    count++;\n+                }\n+            }\n+            String errorMessageCommon = \" method parameter with @\" + annotation.getSimpleName() + \" annotation and type \" + type.getSimpleName();\n+            if (count == 0) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (count > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return Optional.empty();\n+            }\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> noParamsWith(Class<? extends Annotation>... annotations) {\n+        return method -> {\n+            for (Parameter parameter : method.getParameters()) {\n+                for (Class<? extends Annotation> annotation : annotations) {\n+                    if (parameter.isAnnotationPresent(annotation)) {\n+                        Optional.of(invalid(method, '@' + annotation.getSimpleName() + \" annotation is not allowed here\"));\n+                    }\n+                }\n+            }\n+            return Optional.empty();\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> anyCollectionFrom(Class<? extends Annotation> annotation, Generic... genericTypes) {\n+        return method -> {\n+            int count = 0;\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation)) {\n+                    for (Generic generic : genericTypes) {\n+                        if (generic.wrapperType.isAssignableFrom(parameter.getType())) {\n+                            Type[] actualTypeArguments = ((ParameterizedType) parameter.getParameterizedType()).getActualTypeArguments();\n+                            if (actualTypeArguments.length == 1 && actualTypeArguments[0].equals(generic.genericType)) {\n+                                count++;\n+                            }\n+                        }\n+                    }\n+                }\n+            }", "originalCommit": "6ad0d8b96f5be7152950c53c4bd806c4e6fa78fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5NzI5NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8283#discussion_r440297294", "bodyText": "yes", "author": "foldik", "createdAt": "2020-06-15T16:24:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI4ODc5Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5MTYxOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8283#discussion_r440291619", "bodyText": "can we extract this into different class with more specific name?", "author": "horadla23", "createdAt": "2020-06-15T16:15:46Z", "path": "authorization-common/src/test/java/com/sequenceiq/authorization/EnforceAuthorizationLogicsUtil.java", "diffHunk": "@@ -62,18 +124,239 @@ public static void testIfControllerClassHasAuthorizationAnnotation() {\n         Set<String> controllersWithoutAnnotation = Sets.difference(controllersClasses, Sets.union(authorizationResourceClasses, disabledAuthorizationClasses));\n \n         assertTrue(\"These controllers are missing @AuthorizationResource annotation: \" + Joiner.on(\",\").join(controllersWithoutAnnotation),\n-                controllersWithoutAnnotation.size() == 0);\n+                controllersWithoutAnnotation.isEmpty());\n     }\n \n     public static void testIfControllerMethodsHaveProperAuthorizationAnnotation() {\n         Set<Class<?>> authorizationResourceClasses = REFLECTIONS.getTypesAnnotatedWith(AuthorizationResource.class);\n-        Set<String> methodsWithoutAnnotation = Sets.newHashSet();\n-        authorizationResourceClasses.stream().forEach(authzClass -> Arrays.stream(authzClass.getDeclaredMethods())\n-            .filter(method -> Modifier.isPublic(method.getModifiers()) && !AuthorizationAnnotationUtils.getPossibleMethodAnnotations().stream()\n-                    .filter(annotation -> method.isAnnotationPresent(annotation)).findAny().isPresent())\n-            .forEach(method -> methodsWithoutAnnotation.add(authzClass.getSimpleName() + \"#\" + method.getName())));\n-\n-        assertTrue(\"These controller methods are missing any authorization related annotation: \"\n-                        + Joiner.on(\",\").join(methodsWithoutAnnotation), methodsWithoutAnnotation.size() == 0);\n+        List<String> validationErrors = authorizationResourceClasses\n+                .stream()\n+                .map(Class::getDeclaredMethods)\n+                .flatMap(Arrays::stream)\n+                .filter(method -> Modifier.isPublic(method.getModifiers()))\n+                .map(EnforceAuthorizationLogicsUtil::validateMethod)\n+                .flatMap(Collection::stream)\n+                .collect(toList());\n+        assertTrue(Joiner.on(System.lineSeparator()).join(validationErrors), validationErrors.isEmpty());\n+    }\n+\n+    private static List<String> validateMethod(Method method) {\n+        List<Class<? extends Annotation>> annotations = AuthorizationAnnotationUtils\n+                .getPossibleMethodAnnotations()\n+                .stream()\n+                .filter(method::isAnnotationPresent)\n+                .collect(toList());\n+        if (annotations.isEmpty()) {\n+            return List.of(invalid(method, \"Missing aithz annotation.\"));\n+        } else {\n+            return annotations\n+                    .stream()\n+                    .map(annotation -> METHOD_VALIDATORS.getOrDefault(annotation, unknownAnnotation(annotation)).apply(method))\n+                    .filter(Optional::isPresent)\n+                    .map(Optional::get)\n+                    .map(Object::toString)\n+                    .collect(toList());\n+        }\n+    }\n+\n+    private static String invalid(Method method, String reason) {\n+        return methodToString(method) + \": \" + reason;\n+    }\n+\n+    private static Function<Method, Optional<String>> noRestriction() {\n+        return method -> Optional.empty();\n+    }\n+\n+    private static Function<Method, Optional<String>> unknownAnnotation(Class<? extends Annotation> annotation) {\n+        return method -> Optional.of(invalid(method, \"No validation rule specified for \" + annotation));\n+    }\n+\n+    private static String methodToString(Method method) {\n+        return method.getDeclaringClass().getSimpleName() + '#' + method.getName();\n+    }\n+\n+    private static Function<Method, Optional<String>> hasParamWhere(Class<? extends Annotation> annotation,\n+            Function<Pair<Method, Class<?>>, Optional<String>> typeValidator) {\n+        return method -> {\n+            List<Optional<String>> validations = new ArrayList<>();\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation)) {\n+                    validations.add(typeValidator.apply(Pair.of(method, parameter.getType())));\n+                }\n+            }\n+            String errorMessageCommon = \" method param with @\" + annotation.getSimpleName() + \" annotation\";\n+            if (validations.isEmpty()) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (validations.size() > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return validations.get(0);\n+            }\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> stringParam(Class<? extends Annotation> annotation) {\n+        return hasParam(annotation, String.class);\n+    }\n+\n+    private static Function<Method, Optional<String>> hasParam(Class<? extends Annotation> annotation, Class<?> type) {\n+        return method -> {\n+            int count = 0;\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation) && type.equals(parameter.getType())) {\n+                    count++;\n+                }\n+            }\n+            String errorMessageCommon = \" method parameter with @\" + annotation.getSimpleName() + \" annotation and type \" + type.getSimpleName();\n+            if (count == 0) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (count > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return Optional.empty();\n+            }\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> noParamsWith(Class<? extends Annotation>... annotations) {\n+        return method -> {\n+            for (Parameter parameter : method.getParameters()) {\n+                for (Class<? extends Annotation> annotation : annotations) {\n+                    if (parameter.isAnnotationPresent(annotation)) {\n+                        Optional.of(invalid(method, '@' + annotation.getSimpleName() + \" annotation is not allowed here\"));\n+                    }\n+                }\n+            }\n+            return Optional.empty();\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> anyCollectionFrom(Class<? extends Annotation> annotation, Generic... genericTypes) {\n+        return method -> {\n+            int count = 0;\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation)) {\n+                    for (Generic generic : genericTypes) {\n+                        if (generic.wrapperType.isAssignableFrom(parameter.getType())) {\n+                            Type[] actualTypeArguments = ((ParameterizedType) parameter.getParameterizedType()).getActualTypeArguments();\n+                            if (actualTypeArguments.length == 1 && actualTypeArguments[0].equals(generic.genericType)) {\n+                                count++;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            String errorMessageCommon = \" method parameter with @\" + annotation.getSimpleName() + \" annotation and type from \" +\n+                    Arrays.stream(genericTypes)\n+                            .map(Generic::toString)\n+                            .collect(Collectors.joining(\",\", \"[\", \"]\"));\n+            if (count == 0) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (count > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return Optional.empty();\n+            }\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> returnsAnyOf(Generic... genericTypes) {\n+        return method -> {\n+            int count = 0;\n+            for (Generic generic : genericTypes) {\n+                if (generic.wrapperType.isAssignableFrom(method.getReturnType())) {\n+                    Type[] actualTypeArguments;\n+                    if (method.getReturnType().getSuperclass() == null) {\n+                        actualTypeArguments = ((ParameterizedType) method.getGenericReturnType()).getActualTypeArguments();\n+                    } else {\n+                        actualTypeArguments = ((ParameterizedType) method.getReturnType().getGenericSuperclass()).getActualTypeArguments();\n+                    }\n+                    if (actualTypeArguments.length == 1 && generic.genericType.isAssignableFrom((Class<?>) actualTypeArguments[0])) {\n+                        count++;\n+                    }\n+                }\n+            }\n+            String errorMessage = \"Return \" + method.getReturnType().getSimpleName() + \" type is not one of\" +\n+                    Arrays.stream(genericTypes)\n+                            .map(Generic::toString)\n+                            .collect(Collectors.joining(\",\", \"[\", \"]\"));\n+            if (count != 1) {\n+                return Optional.of(invalid(method, errorMessage));\n+            } else {\n+                return Optional.empty();\n+            }\n+        };\n+    }\n+\n+    private static Function<Pair<Method, Class<?>>, Optional<String>> resourceObject() {\n+        return ctx -> {\n+            Method method = ctx.getKey();\n+            Class<?> type = ctx.getValue();\n+            boolean hasValidField = false;\n+            for (Field field : FieldUtils.getFieldsWithAnnotation(type, ResourceObjectField.class)) {\n+                ResourceObjectField annotation = field.getAnnotation(ResourceObjectField.class);\n+                if (Set.of(CRN, NAME).contains(annotation.variableType())) {\n+                    if (String.class.equals(field.getType())) {\n+                        hasValidField = true;\n+                    } else {\n+                        return Optional.of(invalid(method, field.getName()\n+                                + \" @\" + ResourceObjectField.class + \" must be a String in \" + type.getSimpleName()));\n+                    }\n+                } else if (Set.of(CRN_LIST, NAME_LIST).contains(annotation.variableType())) {\n+                    if (isOneOf(field, list(String.class), set(String.class))) {\n+                        hasValidField = true;\n+                    } else {\n+                        return Optional.of(invalid(method, field.getName()\n+                                + \" @\" + ResourceObjectField.class + \" must be a Set<String> or List<String> in \" + type.getSimpleName()));\n+                    }\n+                }\n+            }\n+            if (hasValidField) {\n+                return Optional.empty();\n+            } else {\n+                return Optional.of(invalid(method, \"Missing @\" + ResourceObjectField.class + \" annotaion in \" + type.getSimpleName()));\n+            }\n+        };\n+    }\n+\n+    private static boolean isOneOf(Field field, Generic... genericTypes) {\n+        for (Generic generic : genericTypes) {\n+            if (generic.wrapperType.isAssignableFrom(field.getType())) {\n+                Type[] actualTypeArguments = ((ParameterizedType) field.getGenericType()).getActualTypeArguments();\n+                if (actualTypeArguments.length == 1 && actualTypeArguments[0].equals(generic.genericType)) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public static class Generic {", "originalCommit": "6ad0d8b96f5be7152950c53c4bd806c4e6fa78fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5NzQzMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8283#discussion_r440297430", "bodyText": "yep", "author": "foldik", "createdAt": "2020-06-15T16:25:08Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5MTYxOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5MjI1MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8283#discussion_r440292251", "bodyText": "as I see this code block appears twice in the class, please extract it", "author": "horadla23", "createdAt": "2020-06-15T16:16:43Z", "path": "authorization-common/src/test/java/com/sequenceiq/authorization/EnforceAuthorizationLogicsUtil.java", "diffHunk": "@@ -62,18 +124,239 @@ public static void testIfControllerClassHasAuthorizationAnnotation() {\n         Set<String> controllersWithoutAnnotation = Sets.difference(controllersClasses, Sets.union(authorizationResourceClasses, disabledAuthorizationClasses));\n \n         assertTrue(\"These controllers are missing @AuthorizationResource annotation: \" + Joiner.on(\",\").join(controllersWithoutAnnotation),\n-                controllersWithoutAnnotation.size() == 0);\n+                controllersWithoutAnnotation.isEmpty());\n     }\n \n     public static void testIfControllerMethodsHaveProperAuthorizationAnnotation() {\n         Set<Class<?>> authorizationResourceClasses = REFLECTIONS.getTypesAnnotatedWith(AuthorizationResource.class);\n-        Set<String> methodsWithoutAnnotation = Sets.newHashSet();\n-        authorizationResourceClasses.stream().forEach(authzClass -> Arrays.stream(authzClass.getDeclaredMethods())\n-            .filter(method -> Modifier.isPublic(method.getModifiers()) && !AuthorizationAnnotationUtils.getPossibleMethodAnnotations().stream()\n-                    .filter(annotation -> method.isAnnotationPresent(annotation)).findAny().isPresent())\n-            .forEach(method -> methodsWithoutAnnotation.add(authzClass.getSimpleName() + \"#\" + method.getName())));\n-\n-        assertTrue(\"These controller methods are missing any authorization related annotation: \"\n-                        + Joiner.on(\",\").join(methodsWithoutAnnotation), methodsWithoutAnnotation.size() == 0);\n+        List<String> validationErrors = authorizationResourceClasses\n+                .stream()\n+                .map(Class::getDeclaredMethods)\n+                .flatMap(Arrays::stream)\n+                .filter(method -> Modifier.isPublic(method.getModifiers()))\n+                .map(EnforceAuthorizationLogicsUtil::validateMethod)\n+                .flatMap(Collection::stream)\n+                .collect(toList());\n+        assertTrue(Joiner.on(System.lineSeparator()).join(validationErrors), validationErrors.isEmpty());\n+    }\n+\n+    private static List<String> validateMethod(Method method) {\n+        List<Class<? extends Annotation>> annotations = AuthorizationAnnotationUtils\n+                .getPossibleMethodAnnotations()\n+                .stream()\n+                .filter(method::isAnnotationPresent)\n+                .collect(toList());\n+        if (annotations.isEmpty()) {\n+            return List.of(invalid(method, \"Missing aithz annotation.\"));\n+        } else {\n+            return annotations\n+                    .stream()\n+                    .map(annotation -> METHOD_VALIDATORS.getOrDefault(annotation, unknownAnnotation(annotation)).apply(method))\n+                    .filter(Optional::isPresent)\n+                    .map(Optional::get)\n+                    .map(Object::toString)\n+                    .collect(toList());\n+        }\n+    }\n+\n+    private static String invalid(Method method, String reason) {\n+        return methodToString(method) + \": \" + reason;\n+    }\n+\n+    private static Function<Method, Optional<String>> noRestriction() {\n+        return method -> Optional.empty();\n+    }\n+\n+    private static Function<Method, Optional<String>> unknownAnnotation(Class<? extends Annotation> annotation) {\n+        return method -> Optional.of(invalid(method, \"No validation rule specified for \" + annotation));\n+    }\n+\n+    private static String methodToString(Method method) {\n+        return method.getDeclaringClass().getSimpleName() + '#' + method.getName();\n+    }\n+\n+    private static Function<Method, Optional<String>> hasParamWhere(Class<? extends Annotation> annotation,\n+            Function<Pair<Method, Class<?>>, Optional<String>> typeValidator) {\n+        return method -> {\n+            List<Optional<String>> validations = new ArrayList<>();\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation)) {\n+                    validations.add(typeValidator.apply(Pair.of(method, parameter.getType())));\n+                }\n+            }\n+            String errorMessageCommon = \" method param with @\" + annotation.getSimpleName() + \" annotation\";\n+            if (validations.isEmpty()) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (validations.size() > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return validations.get(0);\n+            }\n+        };\n+    }\n+\n+    private static Function<Method, Optional<String>> stringParam(Class<? extends Annotation> annotation) {\n+        return hasParam(annotation, String.class);\n+    }\n+\n+    private static Function<Method, Optional<String>> hasParam(Class<? extends Annotation> annotation, Class<?> type) {\n+        return method -> {\n+            int count = 0;\n+            for (Parameter parameter : method.getParameters()) {\n+                if (parameter.isAnnotationPresent(annotation) && type.equals(parameter.getType())) {\n+                    count++;\n+                }\n+            }\n+            String errorMessageCommon = \" method parameter with @\" + annotation.getSimpleName() + \" annotation and type \" + type.getSimpleName();\n+            if (count == 0) {\n+                return Optional.of(invalid(method, \"Misssing\" + errorMessageCommon));\n+            } else if (count > 1) {\n+                return Optional.of(invalid(method, \"Multiple\" + errorMessageCommon));\n+            } else {\n+                return Optional.empty();\n+            }", "originalCommit": "6ad0d8b96f5be7152950c53c4bd806c4e6fa78fc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5NzUwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8283#discussion_r440297509", "bodyText": "ok", "author": "foldik", "createdAt": "2020-06-15T16:25:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MDI5MjI1MQ=="}], "type": "inlineReview"}, {"oid": "6d36aaf1ea5ee8a78e16b0a2eddb06b26c43f1ef", "url": "https://github.com/hortonworks/cloudbreak/commit/6d36aaf1ea5ee8a78e16b0a2eddb06b26c43f1ef", "message": "CB-5945 Enforce authz annotation on specific fields of request object (unit test)", "committedDate": "2020-06-15T17:49:30Z", "type": "forcePushed"}, {"oid": "c4a591fd54089feba789bb539a76029519a6c832", "url": "https://github.com/hortonworks/cloudbreak/commit/c4a591fd54089feba789bb539a76029519a6c832", "message": "CB-5945 Enforce authz annotation on specific fields of request object (unit test)", "committedDate": "2020-06-15T18:52:30Z", "type": "commit"}, {"oid": "c4a591fd54089feba789bb539a76029519a6c832", "url": "https://github.com/hortonworks/cloudbreak/commit/c4a591fd54089feba789bb539a76029519a6c832", "message": "CB-5945 Enforce authz annotation on specific fields of request object (unit test)", "committedDate": "2020-06-15T18:52:30Z", "type": "forcePushed"}]}