{"pr_number": 8188, "pr_title": "DISTX-399 DataHub Autoscaling", "pr_createdAt": "2020-06-01T18:30:56Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/8188", "timeline": [{"oid": "f681883d1c0c19cfa91ecdd5ef869c12f8a0ebd4", "url": "https://github.com/hortonworks/cloudbreak/commit/f681883d1c0c19cfa91ecdd5ef869c12f8a0ebd4", "message": "DISTX-399 DataHub Autoscaling\n\n1.  Introduce DistroXAutoscale Endpoint for DataHub Autoscaling.\n2.  Disable unused AlertEndpoint.\n3.  Introduce Entitlements validation for DataHub Autoscaling.\n4.  Introduce YarnBased Autoscaling Evaluator and Monitor.\n5.  Introduce RemovableCluster Monitor to track and remove CB deleted clusters.\n6.  Introduce DistroXAutoscale endpoint tests.", "committedDate": "2020-06-02T07:29:54Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg4NDE5Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r434884197", "bodyText": "May have asked this earlier; is this annotation required?", "author": "sidseth", "createdAt": "2020-06-03T22:06:00Z", "path": "autoscale/src/test/java/com/sequenceiq/periscope/modul/rejected/RejectedThreadContext.java", "diffHunk": "@@ -59,6 +60,7 @@\n     @MockBean({Clock.class, ClusterService.class, CloudbreakClientConfiguration.class,\n             MetricUtils.class, InternalCrnBuilder.class, FailedNodeRepository.class})\n     @EnableAsync\n+    @Profile(\"devtest\")", "originalCommit": "f681883d1c0c19cfa91ecdd5ef869c12f8a0ebd4", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTA2NTcyNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435065725", "bodyText": "Nested SpringConfig in RejectedThreadContext is basically a TestContext.  Without the profile filter this would result in duplicate  bean definition for periscopeListeningScheduledExecutorService and fails integration endpoint tests which run tests against embedded tomcat and embedded db. Earlier there wasn't any service integration tests hence the missing annotation did not cause any issue.", "author": "smaniraju", "createdAt": "2020-06-04T08:01:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDg4NDE5Nw=="}], "type": "inlineReview"}, {"oid": "d8ee7e1c27320672da427a3b05c3bc5396700d34", "url": "https://github.com/hortonworks/cloudbreak/commit/d8ee7e1c27320672da427a3b05c3bc5396700d34", "message": "DISTX-399 DataHub Autoscaling\n\n1.  Introduce DistroXAutoscale Endpoint for DataHub Autoscaling.\n2.  Disable unused AlertEndpoint.\n3.  Introduce Entitlements validation for DataHub Autoscaling.\n4.  Introduce YarnBased Autoscaling Evaluator and Monitor.\n5.  Introduce RemovableCluster Monitor to track and remove CB deleted clusters.\n6.  Introduce DistroXAutoscale endpoint tests.", "committedDate": "2020-06-04T07:20:07Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NjcyOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435186729", "bodyText": "our url patter is separated by _, please change to autoscale_config and the other URL as well", "author": "topolyai5", "createdAt": "2020-06-04T11:35:28Z", "path": "autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/v1/DistroXAutoScaleClusterV1Endpoint.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package com.sequenceiq.periscope.api.endpoint.v1;\n+\n+import static com.sequenceiq.periscope.doc.ApiDescription.CLUSTERS_DESCRIPTION;\n+\n+import java.util.List;\n+\n+import javax.validation.Valid;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import com.sequenceiq.periscope.api.endpoint.validator.ValidDistroXAutoscaleRequest;\n+import com.sequenceiq.periscope.api.model.AutoscaleClusterState;\n+import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterRequest;\n+import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterResponse;\n+import com.sequenceiq.periscope.doc.ApiDescription;\n+import com.sequenceiq.periscope.doc.ApiDescription.ClusterOpDescription;\n+import com.sequenceiq.periscope.doc.ApiDescription.DistroXClusterNotes;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+\n+@Path(\"/v1/distrox\")\n+@Consumes(MediaType.APPLICATION_JSON)\n+@Api(value = \"/v1/distrox\", description = CLUSTERS_DESCRIPTION, protocols = \"http,https\", consumes = MediaType.APPLICATION_JSON)\n+public interface DistroXAutoScaleClusterV1Endpoint {\n+\n+    @GET\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_GET_ALL, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    List<DistroXAutoscaleClusterResponse> getClusters();\n+\n+    @GET\n+    @Path(\"crn/{crn}\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_GET, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    DistroXAutoscaleClusterResponse getClusterByCrn(@PathParam(\"crn\") String clusterCrn);\n+\n+    @GET\n+    @Path(\"name/{name}\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_GET, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    DistroXAutoscaleClusterResponse getClusterByName(@PathParam(\"name\") String clusterName);\n+\n+    @POST\n+    @Path(\"crn/{crn}/autoscaleconfig\")", "originalCommit": "d8ee7e1c27320672da427a3b05c3bc5396700d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0Njg3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435746874", "bodyText": "ok", "author": "smaniraju", "createdAt": "2020-06-05T07:46:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NjcyOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NzM4Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435187386", "bodyText": "separate by _", "author": "topolyai5", "createdAt": "2020-06-04T11:36:43Z", "path": "autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/v1/DistroXAutoScaleClusterV1Endpoint.java", "diffHunk": "@@ -0,0 +1,87 @@\n+package com.sequenceiq.periscope.api.endpoint.v1;\n+\n+import static com.sequenceiq.periscope.doc.ApiDescription.CLUSTERS_DESCRIPTION;\n+\n+import java.util.List;\n+\n+import javax.validation.Valid;\n+import javax.ws.rs.Consumes;\n+import javax.ws.rs.DELETE;\n+import javax.ws.rs.GET;\n+import javax.ws.rs.POST;\n+import javax.ws.rs.Path;\n+import javax.ws.rs.PathParam;\n+import javax.ws.rs.Produces;\n+import javax.ws.rs.core.MediaType;\n+\n+import com.sequenceiq.periscope.api.endpoint.validator.ValidDistroXAutoscaleRequest;\n+import com.sequenceiq.periscope.api.model.AutoscaleClusterState;\n+import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterRequest;\n+import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterResponse;\n+import com.sequenceiq.periscope.doc.ApiDescription;\n+import com.sequenceiq.periscope.doc.ApiDescription.ClusterOpDescription;\n+import com.sequenceiq.periscope.doc.ApiDescription.DistroXClusterNotes;\n+\n+import io.swagger.annotations.Api;\n+import io.swagger.annotations.ApiOperation;\n+\n+@Path(\"/v1/distrox\")\n+@Consumes(MediaType.APPLICATION_JSON)\n+@Api(value = \"/v1/distrox\", description = CLUSTERS_DESCRIPTION, protocols = \"http,https\", consumes = MediaType.APPLICATION_JSON)\n+public interface DistroXAutoScaleClusterV1Endpoint {\n+\n+    @GET\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_GET_ALL, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    List<DistroXAutoscaleClusterResponse> getClusters();\n+\n+    @GET\n+    @Path(\"crn/{crn}\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_GET, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    DistroXAutoscaleClusterResponse getClusterByCrn(@PathParam(\"crn\") String clusterCrn);\n+\n+    @GET\n+    @Path(\"name/{name}\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_GET, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    DistroXAutoscaleClusterResponse getClusterByName(@PathParam(\"name\") String clusterName);\n+\n+    @POST\n+    @Path(\"crn/{crn}/autoscaleconfig\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = ClusterOpDescription.CLUSTER_UPDATE_AUTOSCALE_CONFIG, produces = MediaType.APPLICATION_JSON, notes = DistroXClusterNotes.NOTES)\n+    DistroXAutoscaleClusterResponse updateAutoscaleConfigByClusterCrn(@PathParam(\"crn\") String clusterCrn,\n+            @ValidDistroXAutoscaleRequest @Valid DistroXAutoscaleClusterRequest autoscaleClusterRequest);\n+\n+    @POST\n+    @Path(\"name/{name}/autoscaleconfig\")", "originalCommit": "d8ee7e1c27320672da427a3b05c3bc5396700d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0Njk0MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435746940", "bodyText": "ok", "author": "smaniraju", "createdAt": "2020-06-05T07:46:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE4NzM4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MDA0Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435190046", "bodyText": "why do you use fully qualified name?", "author": "topolyai5", "createdAt": "2020-06-04T11:42:02Z", "path": "autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/validator/DistroXAutoscaleRequestValidator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package com.sequenceiq.periscope.api.endpoint.validator;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.validation.ConstraintValidator;\n+import javax.validation.ConstraintValidatorContext;\n+\n+import com.sequenceiq.periscope.api.model.AdjustmentType;\n+import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterRequest;\n+\n+public class DistroXAutoscaleRequestValidator\n+        implements ConstraintValidator<ValidDistroXAutoscaleRequest, DistroXAutoscaleClusterRequest> {\n+\n+    @Override\n+    public boolean isValid(DistroXAutoscaleClusterRequest request, ConstraintValidatorContext context) {\n+\n+        if (!request.getLoadAlertRequests().isEmpty() &&\n+                !request.getTimeAlertRequests().isEmpty()) {\n+            String message = String.format(\"Cluster can be configured with only one type of autoscaling policies.\");\n+            com.sequenceiq.cloudbreak.validation.ValidatorUtil.addConstraintViolation(context, message, \"autoscalingPolicy\")\n+                    .disableDefaultConstraintViolation();\n+            return false;\n+        }\n+\n+        if (!request.getLoadAlertRequests().isEmpty()) {\n+            return isValidLoadAlertRequests(request, context);\n+        }\n+\n+        return true;\n+    }\n+\n+    private Boolean isValidLoadAlertRequests(DistroXAutoscaleClusterRequest request, ConstraintValidatorContext context) {\n+        Set<String> distinctLoadBasedHostGroups = new HashSet<>();\n+        Set<AdjustmentType> distinctLoadBasedAdjustmentTypes = new HashSet<>();\n+\n+        if (request.getLoadAlertRequests().size() > 1) {\n+            String message = String.format(\"LoadBased autoscaling currently supports a single HostGroup in a Cluster.\");\n+            com.sequenceiq.cloudbreak.validation.ValidatorUtil.addConstraintViolation(context, message, \"loadAlertRequests\")", "originalCommit": "d8ee7e1c27320672da427a3b05c3bc5396700d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0NzYxNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435747615", "bodyText": "fixed", "author": "smaniraju", "createdAt": "2020-06-05T07:48:01Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MDA0Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MDc2Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435190762", "bodyText": "you can do this in the same map", "author": "topolyai5", "createdAt": "2020-06-04T11:43:25Z", "path": "autoscale-api/src/main/java/com/sequenceiq/periscope/api/endpoint/validator/DistroXAutoscaleRequestValidator.java", "diffHunk": "@@ -0,0 +1,74 @@\n+package com.sequenceiq.periscope.api.endpoint.validator;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.validation.ConstraintValidator;\n+import javax.validation.ConstraintValidatorContext;\n+\n+import com.sequenceiq.periscope.api.model.AdjustmentType;\n+import com.sequenceiq.periscope.api.model.DistroXAutoscaleClusterRequest;\n+\n+public class DistroXAutoscaleRequestValidator\n+        implements ConstraintValidator<ValidDistroXAutoscaleRequest, DistroXAutoscaleClusterRequest> {\n+\n+    @Override\n+    public boolean isValid(DistroXAutoscaleClusterRequest request, ConstraintValidatorContext context) {\n+\n+        if (!request.getLoadAlertRequests().isEmpty() &&\n+                !request.getTimeAlertRequests().isEmpty()) {\n+            String message = String.format(\"Cluster can be configured with only one type of autoscaling policies.\");\n+            com.sequenceiq.cloudbreak.validation.ValidatorUtil.addConstraintViolation(context, message, \"autoscalingPolicy\")\n+                    .disableDefaultConstraintViolation();\n+            return false;\n+        }\n+\n+        if (!request.getLoadAlertRequests().isEmpty()) {\n+            return isValidLoadAlertRequests(request, context);\n+        }\n+\n+        return true;\n+    }\n+\n+    private Boolean isValidLoadAlertRequests(DistroXAutoscaleClusterRequest request, ConstraintValidatorContext context) {\n+        Set<String> distinctLoadBasedHostGroups = new HashSet<>();\n+        Set<AdjustmentType> distinctLoadBasedAdjustmentTypes = new HashSet<>();\n+\n+        if (request.getLoadAlertRequests().size() > 1) {\n+            String message = String.format(\"LoadBased autoscaling currently supports a single HostGroup in a Cluster.\");\n+            com.sequenceiq.cloudbreak.validation.ValidatorUtil.addConstraintViolation(context, message, \"loadAlertRequests\")\n+                    .disableDefaultConstraintViolation();\n+            return false;\n+        }\n+\n+        Set<String> duplicateHostGroups =\n+                request.getLoadAlertRequests().stream()\n+                        .map(loadAlertRequest -> loadAlertRequest.getScalingPolicy())\n+                        .map(scalingPolicyRequest -> {\n+                            distinctLoadBasedAdjustmentTypes.add(scalingPolicyRequest.getAdjustmentType());\n+                            return scalingPolicyRequest;\n+                        })\n+                        .map(scalingPolicyRequest -> scalingPolicyRequest.getHostGroup())", "originalCommit": "d8ee7e1c27320672da427a3b05c3bc5396700d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0Nzc1MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435747750", "bodyText": "ok", "author": "smaniraju", "createdAt": "2020-06-05T07:48:16Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTE5MDc2Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4MTQ5Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435281493", "bodyText": "You can use the DefaultEnumConverter", "author": "topolyai5", "createdAt": "2020-06-04T14:01:34Z", "path": "autoscale/src/main/java/com/sequenceiq/periscope/converter/db/StackTypeAttributeConverter.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package com.sequenceiq.periscope.converter.db;\n+\n+import javax.persistence.AttributeConverter;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.StackType;\n+\n+public class StackTypeAttributeConverter implements AttributeConverter<StackType, String> {", "originalCommit": "d8ee7e1c27320672da427a3b05c3bc5396700d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0ODc3OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435748779", "bodyText": "ok", "author": "smaniraju", "createdAt": "2020-06-05T07:49:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4MTQ5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4NDMwMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435284303", "bodyText": "why not null?", "author": "topolyai5", "createdAt": "2020-06-04T14:05:06Z", "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/evaluator/load/YarnLoadEvaluator.java", "diffHunk": "@@ -0,0 +1,172 @@\n+package com.sequenceiq.periscope.monitor.evaluator.load;\n+\n+import static com.sequenceiq.periscope.monitor.evaluator.ScalingConstants.DEFAULT_MAX_SCALE_UP_STEP_SIZE;\n+\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import javax.annotation.Nonnull;\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Scope;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.StackV4Response;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.periscope.domain.Cluster;\n+import com.sequenceiq.periscope.domain.LoadAlert;\n+import com.sequenceiq.periscope.domain.LoadAlertConfiguration;\n+import com.sequenceiq.periscope.model.yarn.YarnScalingServiceV1Response;\n+import com.sequenceiq.periscope.model.yarn.YarnScalingServiceV1Response.DecommissionCandidate;\n+import com.sequenceiq.periscope.model.yarn.YarnScalingServiceV1Response.NewNodeManagerCandidates;\n+import com.sequenceiq.periscope.monitor.client.YarnMetricsClient;\n+import com.sequenceiq.periscope.monitor.context.ClusterIdEvaluatorContext;\n+import com.sequenceiq.periscope.monitor.context.EvaluatorContext;\n+import com.sequenceiq.periscope.monitor.evaluator.EvaluatorExecutor;\n+import com.sequenceiq.periscope.monitor.evaluator.EventPublisher;\n+import com.sequenceiq.periscope.monitor.event.ScalingEvent;\n+import com.sequenceiq.periscope.monitor.event.UpdateFailedEvent;\n+import com.sequenceiq.periscope.monitor.handler.CloudbreakCommunicator;\n+import com.sequenceiq.periscope.repository.LoadAlertRepository;\n+import com.sequenceiq.periscope.service.ClusterService;\n+import com.sequenceiq.periscope.utils.StackResponseUtils;\n+\n+@Component(\"YarnLoadEvaluator\")\n+@Scope(\"prototype\")\n+public class YarnLoadEvaluator extends EvaluatorExecutor {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(YarnLoadEvaluator.class);\n+\n+    private static final String EVALUATOR_NAME = YarnLoadEvaluator.class.getName();\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private LoadAlertRepository alertRepository;\n+\n+    @Inject\n+    private EventPublisher eventPublisher;\n+\n+    @Inject\n+    private YarnMetricsClient yarnMetricsClient;\n+\n+    @Inject\n+    private StackResponseUtils stackResponseUtils;\n+\n+    @Inject\n+    private CloudbreakCommunicator cloudbreakCommunicator;\n+\n+    private long clusterId;\n+\n+    private Cluster cluster;\n+\n+    private LoadAlert loadAlert;\n+\n+    private LoadAlertConfiguration loadAlertConfiguration;\n+\n+    private String policyHostGroup;\n+\n+    @Nonnull\n+    @Override\n+    public EvaluatorContext getContext() {\n+        return new ClusterIdEvaluatorContext(clusterId);\n+    }\n+\n+    @Override\n+    public void setContext(EvaluatorContext context) {\n+        clusterId = (long) context.getData();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return EVALUATOR_NAME;\n+    }\n+\n+    @Override\n+    protected void execute() {\n+        long start = System.currentTimeMillis();\n+        String stackCrn = \"NotInitialized\";", "originalCommit": "d8ee7e1c27320672da427a3b05c3bc5396700d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0ODg4NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435748885", "bodyText": "ok", "author": "smaniraju", "createdAt": "2020-06-05T07:50:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4NDMwMw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4NTcwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435285709", "bodyText": "can you break up smaller functions?", "author": "topolyai5", "createdAt": "2020-06-04T14:06:52Z", "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/evaluator/load/YarnLoadEvaluator.java", "diffHunk": "@@ -0,0 +1,172 @@\n+package com.sequenceiq.periscope.monitor.evaluator.load;\n+\n+import static com.sequenceiq.periscope.monitor.evaluator.ScalingConstants.DEFAULT_MAX_SCALE_UP_STEP_SIZE;\n+\n+import java.util.Comparator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import javax.annotation.Nonnull;\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Scope;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.response.StackV4Response;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.periscope.domain.Cluster;\n+import com.sequenceiq.periscope.domain.LoadAlert;\n+import com.sequenceiq.periscope.domain.LoadAlertConfiguration;\n+import com.sequenceiq.periscope.model.yarn.YarnScalingServiceV1Response;\n+import com.sequenceiq.periscope.model.yarn.YarnScalingServiceV1Response.DecommissionCandidate;\n+import com.sequenceiq.periscope.model.yarn.YarnScalingServiceV1Response.NewNodeManagerCandidates;\n+import com.sequenceiq.periscope.monitor.client.YarnMetricsClient;\n+import com.sequenceiq.periscope.monitor.context.ClusterIdEvaluatorContext;\n+import com.sequenceiq.periscope.monitor.context.EvaluatorContext;\n+import com.sequenceiq.periscope.monitor.evaluator.EvaluatorExecutor;\n+import com.sequenceiq.periscope.monitor.evaluator.EventPublisher;\n+import com.sequenceiq.periscope.monitor.event.ScalingEvent;\n+import com.sequenceiq.periscope.monitor.event.UpdateFailedEvent;\n+import com.sequenceiq.periscope.monitor.handler.CloudbreakCommunicator;\n+import com.sequenceiq.periscope.repository.LoadAlertRepository;\n+import com.sequenceiq.periscope.service.ClusterService;\n+import com.sequenceiq.periscope.utils.StackResponseUtils;\n+\n+@Component(\"YarnLoadEvaluator\")\n+@Scope(\"prototype\")\n+public class YarnLoadEvaluator extends EvaluatorExecutor {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(YarnLoadEvaluator.class);\n+\n+    private static final String EVALUATOR_NAME = YarnLoadEvaluator.class.getName();\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private LoadAlertRepository alertRepository;\n+\n+    @Inject\n+    private EventPublisher eventPublisher;\n+\n+    @Inject\n+    private YarnMetricsClient yarnMetricsClient;\n+\n+    @Inject\n+    private StackResponseUtils stackResponseUtils;\n+\n+    @Inject\n+    private CloudbreakCommunicator cloudbreakCommunicator;\n+\n+    private long clusterId;\n+\n+    private Cluster cluster;\n+\n+    private LoadAlert loadAlert;\n+\n+    private LoadAlertConfiguration loadAlertConfiguration;\n+\n+    private String policyHostGroup;\n+\n+    @Nonnull\n+    @Override\n+    public EvaluatorContext getContext() {\n+        return new ClusterIdEvaluatorContext(clusterId);\n+    }\n+\n+    @Override\n+    public void setContext(EvaluatorContext context) {\n+        clusterId = (long) context.getData();\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return EVALUATOR_NAME;\n+    }\n+\n+    @Override\n+    protected void execute() {\n+        long start = System.currentTimeMillis();\n+        String stackCrn = \"NotInitialized\";\n+        try {\n+            MDCBuilder.buildMdcContext(cluster);\n+            cluster = clusterService.findById(clusterId);\n+            stackCrn = cluster.getStackCrn();\n+            loadAlert = cluster.getLoadAlerts().stream().findFirst().get();\n+            loadAlertConfiguration = loadAlert.getLoadAlertConfiguration();\n+            policyHostGroup = loadAlert.getScalingPolicy().getHostGroup();\n+\n+            if (isCoolDownTimeElapsed(cluster.getStackCrn(), loadAlertConfiguration.getCoolDownMillis(),\n+                    cluster.getLastScalingActivity())) {\n+                pollYarnMetricsAndScaleCluster();\n+            }\n+        } catch (Exception ex) {\n+            LOGGER.info(\"Failed to process load alert for Cluster {}, exception {}\", stackCrn, ex);\n+            eventPublisher.publishEvent(new UpdateFailedEvent(clusterId));\n+        } finally {\n+            LOGGER.debug(\"Finished loadEvaluator for cluster {} in {} ms\", stackCrn, System.currentTimeMillis() - start);\n+        }\n+    }\n+\n+    protected void pollYarnMetricsAndScaleCluster() throws Exception {", "originalCommit": "d8ee7e1c27320672da427a3b05c3bc5396700d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc0OTEwNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435749104", "bodyText": "done", "author": "smaniraju", "createdAt": "2020-06-05T07:50:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4NTcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4ODY2OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435288669", "bodyText": "can you create a list with the suspended statuses and check whether contains or not?", "author": "topolyai5", "createdAt": "2020-06-04T14:10:51Z", "path": "autoscale/src/main/java/com/sequenceiq/periscope/monitor/handler/UpdateFailedHandler.java", "diffHunk": "@@ -43,57 +41,53 @@\n     @Inject\n     private CloudbreakCommunicator cloudbreakCommunicator;\n \n-    @Inject\n-    private FailedNodeRepository failedNodeRepository;\n-\n     private final Map<Long, Integer> updateFailures = new ConcurrentHashMap<>();\n \n     @Override\n     public void onApplicationEvent(UpdateFailedEvent event) {\n         long autoscaleClusterId = event.getClusterId();\n-        LOGGER.debug(\"Cluster {} failed\", autoscaleClusterId);\n         Cluster cluster = clusterService.findById(autoscaleClusterId);\n         if (cluster == null) {\n             return;\n         }\n         MDCBuilder.buildMdcContext(cluster);\n+        LOGGER.debug(\"Analysing Cluster Status '{}' \", cluster.getStackCrn());\n         StackV4Response stackResponse = getStackById(cluster.getStackCrn());\n-        if (stackResponse == null) {\n-            LOGGER.debug(\"Suspending cluster {}\", autoscaleClusterId);\n+        String stackStatus = getStackStatus(stackResponse);\n+        if (stackResponse == null || stackStatus.startsWith(STOPPED_STATUSES_PREFIX)) {", "originalCommit": "d8ee7e1c27320672da427a3b05c3bc5396700d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1MDU5Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435750593", "bodyText": "Agree, replaced functionality to use inbuilt Status::isAvailable and also abstracted CBCluster state sync functionality out of UpdateFailedHandler since there was overlap functionality here in tracking failures and syncing cluster status. Also split the unit-tests to separate cluster sync and update failure tracking.", "author": "smaniraju", "createdAt": "2020-06-05T07:53:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4ODY2OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI5MDg2NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435290864", "bodyText": "It much better: ClusterPertain findByUserCrn(String userCrn) and should be work", "author": "topolyai5", "createdAt": "2020-06-04T14:13:49Z", "path": "autoscale/src/main/java/com/sequenceiq/periscope/repository/ClusterPertainRepository.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package com.sequenceiq.periscope.repository;\n+\n+import java.util.List;\n+\n+import org.springframework.data.domain.PageRequest;\n+import org.springframework.data.domain.Pageable;\n+import org.springframework.data.repository.CrudRepository;\n+import org.springframework.data.repository.query.Param;\n+\n+import com.sequenceiq.cloudbreak.workspace.repository.EntityType;\n+import com.sequenceiq.periscope.domain.ClusterPertain;\n+\n+@EntityType(entityClass = ClusterPertain.class)\n+public interface ClusterPertainRepository extends CrudRepository<ClusterPertain, Long> {\n+    List<ClusterPertain> findByUserCrn(@Param(\"userCrn\") String userCrn, Pageable page);\n+\n+    default List<ClusterPertain> findByUserCrn(String userCrn) {", "originalCommit": "d8ee7e1c27320672da427a3b05c3bc5396700d34", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc1MTI0NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8188#discussion_r435751244", "bodyText": "agree updated existing cluster->clusterpertain mapping to support ManyToOne and api to ClusterPertain findByUserCrn(String userCrn)", "author": "smaniraju", "createdAt": "2020-06-05T07:54:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI5MDg2NA=="}], "type": "inlineReview"}, {"oid": "e1fbe69660e0bef471e0c0ffa198d32e7f3058c3", "url": "https://github.com/hortonworks/cloudbreak/commit/e1fbe69660e0bef471e0c0ffa198d32e7f3058c3", "message": "DISTX-399 DataHub Autoscaling\n\n1.  Introduce DistroXAutoscale Endpoint for DataHub Autoscaling.\n2.  Disable unused AlertEndpoint.\n3.  Introduce Entitlements validation for DataHub Autoscaling.\n4.  Introduce YarnBased Autoscaling Evaluator and Monitor.\n5.  Introduce RemovableCluster Monitor to track and remove CB deleted clusters.\n6.  Introduce DistroXAutoscale endpoint tests.", "committedDate": "2020-06-05T07:56:08Z", "type": "commit"}, {"oid": "e1fbe69660e0bef471e0c0ffa198d32e7f3058c3", "url": "https://github.com/hortonworks/cloudbreak/commit/e1fbe69660e0bef471e0c0ffa198d32e7f3058c3", "message": "DISTX-399 DataHub Autoscaling\n\n1.  Introduce DistroXAutoscale Endpoint for DataHub Autoscaling.\n2.  Disable unused AlertEndpoint.\n3.  Introduce Entitlements validation for DataHub Autoscaling.\n4.  Introduce YarnBased Autoscaling Evaluator and Monitor.\n5.  Introduce RemovableCluster Monitor to track and remove CB deleted clusters.\n6.  Introduce DistroXAutoscale endpoint tests.", "committedDate": "2020-06-05T07:56:08Z", "type": "forcePushed"}]}