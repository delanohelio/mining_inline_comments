{"pr_number": 9657, "pr_title": "CB-9926: Add retries to the legacy health check's ping", "pr_createdAt": "2020-12-15T21:10:04Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/9657", "timeline": [{"oid": "67415cf6033ff1f022130ba513deda35890ab058", "url": "https://github.com/hortonworks/cloudbreak/commit/67415cf6033ff1f022130ba513deda35890ab058", "message": "CB-9926: Add retries to the legacy health check's ping\n\nAdd retries to the legacy health check's ping.", "committedDate": "2020-12-16T03:08:28Z", "type": "forcePushed"}, {"oid": "94d1a817196a3c01fde99b3c6aba778a723a7bb9", "url": "https://github.com/hortonworks/cloudbreak/commit/94d1a817196a3c01fde99b3c6aba778a723a7bb9", "message": "CB-10403: Fix legacy FreeIPA health check to use the result flag\n\nFix legacy FreeIPA health check to use the result flag in all cases.", "committedDate": "2020-12-16T22:41:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3NTEwNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9657#discussion_r551475107", "bodyText": "found variable is not necessary.  use  (!nodeMatcher.find()) should be good enough.", "author": "christmasferret", "createdAt": "2021-01-04T17:59:34Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/FreeIpaInstanceHealthDetailsService.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package com.sequenceiq.freeipa.service.stack;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.core.Response;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.retry.annotation.Retryable;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.health.NodeHealthDetails;\n+import com.sequenceiq.freeipa.client.FreeIpaClient;\n+import com.sequenceiq.freeipa.client.FreeIpaClientException;\n+import com.sequenceiq.freeipa.client.FreeIpaHealthCheckClient;\n+import com.sequenceiq.freeipa.client.FreeIpaHealthCheckClientFactory;\n+import com.sequenceiq.freeipa.client.RetryableFreeIpaClientException;\n+import com.sequenceiq.freeipa.client.healthcheckmodel.CheckResult;\n+import com.sequenceiq.freeipa.client.model.RPCMessage;\n+import com.sequenceiq.freeipa.client.model.RPCResponse;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.service.freeipa.FreeIpaClientFactory;\n+import com.sequenceiq.freeipa.util.HealthCheckAvailabilityChecker;\n+\n+@Service\n+public class FreeIpaInstanceHealthDetailsService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FreeIpaInstanceHealthDetailsService.class);\n+\n+    private static final String EXTERNAL_COMMAND_OUTPUT = \"ExternalCommandOutput\";\n+\n+    private static final String STATUS_OK = \"OK\";\n+\n+    private static final int STATUS_GROUP = 2;\n+\n+    private static final String MESSAGE_UNAVAILABLE = \"Message Unavailable\";\n+\n+    private static final Pattern RESULT_PATTERN = Pattern.compile(\"(ecure port|: TCP) \\\\([0-9]*\\\\): (.*)\");\n+\n+    private static final Pattern NEW_NODE_PATTERN = Pattern.compile(\"Check connection from master to remote replica '(.[^\\']*)\");\n+\n+    @Inject\n+    private FreeIpaClientFactory freeIpaClientFactory;\n+\n+    @Inject\n+    private HealthCheckAvailabilityChecker healthCheckAvailabilityChecker;\n+\n+    @Inject\n+    private FreeIpaHealthCheckClientFactory freeIpaHealthCheckClientFactory;\n+\n+    @Retryable(RetryableFreeIpaClientException.class)\n+    public NodeHealthDetails getInstanceHealthDetails(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        if (healthCheckAvailabilityChecker.isCdpFreeIpaHeathAgentAvailable(stack)) {\n+            RPCResponse<CheckResult> rpcResponse = freeIpaHealthCheck(stack, instance);\n+            return parseMessages(rpcResponse, instance);\n+        } else {\n+            RPCResponse<Boolean> rpcResponse = legacyFreeIpaHealthCheck(stack, instance);\n+            return legacyParseMessages(rpcResponse, instance);\n+        }\n+    }\n+\n+    @Retryable(RetryableFreeIpaClientException.class)\n+    public RPCResponse<Boolean> checkFreeIpaHealth(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        RPCResponse<Boolean> result;\n+        if (healthCheckAvailabilityChecker.isCdpFreeIpaHeathAgentAvailable(stack)) {\n+            result = toBooleanRpcResponse(freeIpaHealthCheck(stack, instance));\n+        } else {\n+            result = legacyFreeIpaHealthCheck(stack, instance);\n+        }\n+        return result;\n+    }\n+\n+    private RPCResponse<CheckResult> freeIpaHealthCheck(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        try (FreeIpaHealthCheckClient client = freeIpaHealthCheckClientFactory.getClient(stack, instance)) {\n+            return client.nodeHealth();\n+        } catch (FreeIpaClientException e) {\n+            throw new RetryableFreeIpaClientException(\"Error during healthcheck\", e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"FreeIPA health check failed\", e);\n+            throw new RetryableFreeIpaClientException(\"FreeIPA health check failed\", e);\n+        }\n+    }\n+\n+    private RPCResponse<Boolean> legacyFreeIpaHealthCheck(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStackForLegacyHealthCheck(stack, instance.getDiscoveryFQDN());\n+        return freeIpaClient.serverConnCheck(freeIpaClient.getHostname(), instance.getDiscoveryFQDN());\n+    }\n+\n+    private RPCResponse<Boolean> toBooleanRpcResponse(RPCResponse<CheckResult> nodeHealth) {\n+        RPCResponse<Boolean> response = new RPCResponse<>();\n+        response.setSummary(nodeHealth.getSummary());\n+        response.setResult(isHealthCheckPassing(nodeHealth));\n+        response.setCount(nodeHealth.getCount());\n+        response.setTruncated(nodeHealth.getTruncated());\n+        response.setMessages(nodeHealth.getMessages());\n+        response.setCompleted(nodeHealth.getCompleted());\n+        response.setFailed(nodeHealth.getFailed());\n+        response.setValue(nodeHealth.getValue());\n+        return response;\n+    }\n+\n+    private NodeHealthDetails parseMessages(RPCResponse<CheckResult> rpcResponse, InstanceMetaData instanceMetaData) {\n+        NodeHealthDetails nodeResponse = new NodeHealthDetails();\n+        nodeResponse.setName(instanceMetaData.getDiscoveryFQDN());\n+        nodeResponse.setInstanceId(instanceMetaData.getInstanceId());\n+        if (isHealthCheckPassing(rpcResponse)) {\n+            nodeResponse.setStatus(InstanceStatus.CREATED);\n+        } else {\n+            nodeResponse.setStatus(InstanceStatus.UNHEALTHY);\n+            nodeResponse.setIssues(rpcResponse.getMessages().stream().map(RPCMessage::getMessage).collect(Collectors.toList()));\n+        }\n+        return nodeResponse;\n+    }\n+\n+    private NodeHealthDetails legacyParseMessages(RPCResponse<Boolean> rpcResponse, InstanceMetaData instanceMetaData) {\n+        String precedingMessage = MESSAGE_UNAVAILABLE;\n+        NodeHealthDetails nodeResponse = new NodeHealthDetails();\n+        nodeResponse.setStatus(rpcResponse.getResult() ? InstanceStatus.CREATED : InstanceStatus.UNHEALTHY);\n+        nodeResponse.setName(instanceMetaData.getDiscoveryFQDN());\n+        nodeResponse.setInstanceId(instanceMetaData.getInstanceId());\n+        boolean found = false;\n+        for (RPCMessage message : rpcResponse.getMessages()) {\n+            Matcher nodeMatcher = NEW_NODE_PATTERN.matcher(message.getMessage());\n+            if (nodeMatcher.find()) {\n+                found = true;\n+            }\n+            if (!found) {", "originalCommit": "94d1a817196a3c01fde99b3c6aba778a723a7bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUwMzU0OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9657#discussion_r551503548", "bodyText": "found tracks the state over multiple messages. The match should only occur on the first line of multiline output. If it doesn't appear in the first line as expected then the messages are logged.", "author": "jamisonbennett", "createdAt": "2021-01-04T18:56:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3NTEwNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3NTk3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9657#discussion_r551475974", "bodyText": "precedingMessage = message.getMessage(); will have no effect here as mutating string will not change the string in nodeResponse above. Could append the message before addIssue()", "author": "christmasferret", "createdAt": "2021-01-04T18:01:13Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/FreeIpaInstanceHealthDetailsService.java", "diffHunk": "@@ -0,0 +1,161 @@\n+package com.sequenceiq.freeipa.service.stack;\n+\n+import java.util.Objects;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+import javax.ws.rs.core.Response;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.retry.annotation.Retryable;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.health.NodeHealthDetails;\n+import com.sequenceiq.freeipa.client.FreeIpaClient;\n+import com.sequenceiq.freeipa.client.FreeIpaClientException;\n+import com.sequenceiq.freeipa.client.FreeIpaHealthCheckClient;\n+import com.sequenceiq.freeipa.client.FreeIpaHealthCheckClientFactory;\n+import com.sequenceiq.freeipa.client.RetryableFreeIpaClientException;\n+import com.sequenceiq.freeipa.client.healthcheckmodel.CheckResult;\n+import com.sequenceiq.freeipa.client.model.RPCMessage;\n+import com.sequenceiq.freeipa.client.model.RPCResponse;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.service.freeipa.FreeIpaClientFactory;\n+import com.sequenceiq.freeipa.util.HealthCheckAvailabilityChecker;\n+\n+@Service\n+public class FreeIpaInstanceHealthDetailsService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FreeIpaInstanceHealthDetailsService.class);\n+\n+    private static final String EXTERNAL_COMMAND_OUTPUT = \"ExternalCommandOutput\";\n+\n+    private static final String STATUS_OK = \"OK\";\n+\n+    private static final int STATUS_GROUP = 2;\n+\n+    private static final String MESSAGE_UNAVAILABLE = \"Message Unavailable\";\n+\n+    private static final Pattern RESULT_PATTERN = Pattern.compile(\"(ecure port|: TCP) \\\\([0-9]*\\\\): (.*)\");\n+\n+    private static final Pattern NEW_NODE_PATTERN = Pattern.compile(\"Check connection from master to remote replica '(.[^\\']*)\");\n+\n+    @Inject\n+    private FreeIpaClientFactory freeIpaClientFactory;\n+\n+    @Inject\n+    private HealthCheckAvailabilityChecker healthCheckAvailabilityChecker;\n+\n+    @Inject\n+    private FreeIpaHealthCheckClientFactory freeIpaHealthCheckClientFactory;\n+\n+    @Retryable(RetryableFreeIpaClientException.class)\n+    public NodeHealthDetails getInstanceHealthDetails(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        if (healthCheckAvailabilityChecker.isCdpFreeIpaHeathAgentAvailable(stack)) {\n+            RPCResponse<CheckResult> rpcResponse = freeIpaHealthCheck(stack, instance);\n+            return parseMessages(rpcResponse, instance);\n+        } else {\n+            RPCResponse<Boolean> rpcResponse = legacyFreeIpaHealthCheck(stack, instance);\n+            return legacyParseMessages(rpcResponse, instance);\n+        }\n+    }\n+\n+    @Retryable(RetryableFreeIpaClientException.class)\n+    public RPCResponse<Boolean> checkFreeIpaHealth(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        RPCResponse<Boolean> result;\n+        if (healthCheckAvailabilityChecker.isCdpFreeIpaHeathAgentAvailable(stack)) {\n+            result = toBooleanRpcResponse(freeIpaHealthCheck(stack, instance));\n+        } else {\n+            result = legacyFreeIpaHealthCheck(stack, instance);\n+        }\n+        return result;\n+    }\n+\n+    private RPCResponse<CheckResult> freeIpaHealthCheck(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        try (FreeIpaHealthCheckClient client = freeIpaHealthCheckClientFactory.getClient(stack, instance)) {\n+            return client.nodeHealth();\n+        } catch (FreeIpaClientException e) {\n+            throw new RetryableFreeIpaClientException(\"Error during healthcheck\", e);\n+        } catch (Exception e) {\n+            LOGGER.error(\"FreeIPA health check failed\", e);\n+            throw new RetryableFreeIpaClientException(\"FreeIPA health check failed\", e);\n+        }\n+    }\n+\n+    private RPCResponse<Boolean> legacyFreeIpaHealthCheck(Stack stack, InstanceMetaData instance) throws FreeIpaClientException {\n+        FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStackForLegacyHealthCheck(stack, instance.getDiscoveryFQDN());\n+        return freeIpaClient.serverConnCheck(freeIpaClient.getHostname(), instance.getDiscoveryFQDN());\n+    }\n+\n+    private RPCResponse<Boolean> toBooleanRpcResponse(RPCResponse<CheckResult> nodeHealth) {\n+        RPCResponse<Boolean> response = new RPCResponse<>();\n+        response.setSummary(nodeHealth.getSummary());\n+        response.setResult(isHealthCheckPassing(nodeHealth));\n+        response.setCount(nodeHealth.getCount());\n+        response.setTruncated(nodeHealth.getTruncated());\n+        response.setMessages(nodeHealth.getMessages());\n+        response.setCompleted(nodeHealth.getCompleted());\n+        response.setFailed(nodeHealth.getFailed());\n+        response.setValue(nodeHealth.getValue());\n+        return response;\n+    }\n+\n+    private NodeHealthDetails parseMessages(RPCResponse<CheckResult> rpcResponse, InstanceMetaData instanceMetaData) {\n+        NodeHealthDetails nodeResponse = new NodeHealthDetails();\n+        nodeResponse.setName(instanceMetaData.getDiscoveryFQDN());\n+        nodeResponse.setInstanceId(instanceMetaData.getInstanceId());\n+        if (isHealthCheckPassing(rpcResponse)) {\n+            nodeResponse.setStatus(InstanceStatus.CREATED);\n+        } else {\n+            nodeResponse.setStatus(InstanceStatus.UNHEALTHY);\n+            nodeResponse.setIssues(rpcResponse.getMessages().stream().map(RPCMessage::getMessage).collect(Collectors.toList()));\n+        }\n+        return nodeResponse;\n+    }\n+\n+    private NodeHealthDetails legacyParseMessages(RPCResponse<Boolean> rpcResponse, InstanceMetaData instanceMetaData) {\n+        String precedingMessage = MESSAGE_UNAVAILABLE;\n+        NodeHealthDetails nodeResponse = new NodeHealthDetails();\n+        nodeResponse.setStatus(rpcResponse.getResult() ? InstanceStatus.CREATED : InstanceStatus.UNHEALTHY);\n+        nodeResponse.setName(instanceMetaData.getDiscoveryFQDN());\n+        nodeResponse.setInstanceId(instanceMetaData.getInstanceId());\n+        boolean found = false;\n+        for (RPCMessage message : rpcResponse.getMessages()) {\n+            Matcher nodeMatcher = NEW_NODE_PATTERN.matcher(message.getMessage());\n+            if (nodeMatcher.find()) {\n+                found = true;\n+            }\n+            if (!found) {\n+                LOGGER.info(\"No node for message: {}\" + message.getMessage());\n+            } else {\n+                // When parsing the messages, if there's an error, the error\n+                // appears in the preceding message.\n+                if (EXTERNAL_COMMAND_OUTPUT.equals(message.getName())) {\n+                    Matcher matcher = RESULT_PATTERN.matcher(message.getMessage());\n+                    if (matcher.find()) {\n+                        if (!STATUS_OK.equals(matcher.group(STATUS_GROUP))) {\n+                            nodeResponse.addIssue(precedingMessage);\n+                        }\n+                    }\n+                    precedingMessage = message.getMessage();\n+                }", "originalCommit": "94d1a817196a3c01fde99b3c6aba778a723a7bb9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTUwNDkxNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9657#discussion_r551504914", "bodyText": "// When parsing the messages, if there's an error, the error\n// appears in the preceding message.\n\nAssigning precedingMessage will have an effect in the case that there is an error match as it will have the actual error message from the prior message.", "author": "jamisonbennett", "createdAt": "2021-01-04T18:58:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTQ3NTk3NA=="}], "type": "inlineReview"}, {"oid": "8146ced3b0ef6a1c0c0e8092e44dd50107b61175", "url": "https://github.com/hortonworks/cloudbreak/commit/8146ced3b0ef6a1c0c0e8092e44dd50107b61175", "message": "CB-10455: Fix logic which treated unreahcable FreeIPA as reachable\n\nFixed incorrect logic which treated FreeIPA is being reachable when it\nwas unreachable and cluster proxy was used. In this case cluster proxy\nreturns 502 which was incorrectly treated as a successful connection.\n\nAlthough it would become unreachable for other reasons (e.g. the 3\nminute health check), the health API would report incorrect results\nfor up to 3 minutes. There were also misleading logs which stated\nFreeIPA was reachable.\n\nThis was manually tested with a local cloudbreak cluster.", "committedDate": "2021-01-04T22:11:47Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxMzA1Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9657#discussion_r551613053", "bodyText": "It is strange that the catch clause after this is LOGGER.debug. Might be LOGGER.error()\ncatch (Exception e) {\nString msg = \"Ping failed\";\nLOGGER.debug(msg, e);", "author": "christmasferret", "createdAt": "2021-01-04T22:44:18Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/client/FreeIpaClientBuilder.java", "diffHunk": "@@ -169,7 +166,7 @@ public FreeIpaClient build(boolean withPing) throws URISyntaxException, IOExcept\n                 additionalHeaders.forEach(request::addHeader);\n                 additionalHeadersStickySessionFirstRpc.forEach(request::addHeader);\n                 try (CloseableHttpResponse response = client.execute(request)) {\n-                    if (UNAVIALLBE_PING_HTTP_RESPONSES.contains(response.getStatusLine().getStatusCode())) {\n+                    if (isUnreachableHttpStatus(response.getStatusLine().getStatusCode())) {", "originalCommit": "8146ced3b0ef6a1c0c0e8092e44dd50107b61175", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTY2OTU5MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9657#discussion_r551669590", "bodyText": "I will break this part out into a separate PR.", "author": "jamisonbennett", "createdAt": "2021-01-05T01:44:25Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDU1MTYxMzA1Mw=="}], "type": "inlineReview"}, {"oid": "af76d4b533099401209ecd3ed66373c009397715", "url": "https://github.com/hortonworks/cloudbreak/commit/af76d4b533099401209ecd3ed66373c009397715", "message": "CB-9926: Add retries to the legacy health check's ping\n\nAdd retries to the legacy health check's ping.\n\nRefactor the health checks to allow it to be retry on each instance of\nFreeIPA.", "committedDate": "2021-01-05T01:42:01Z", "type": "forcePushed"}, {"oid": "3957e5f0e3a7ec997aa10a4c5741f1a67361269e", "url": "https://github.com/hortonworks/cloudbreak/commit/3957e5f0e3a7ec997aa10a4c5741f1a67361269e", "message": "CB-10311 Remove asm dependencies", "committedDate": "2021-01-05T13:15:50Z", "type": "forcePushed"}, {"oid": "c4949413902975b3a05e857f8fe0afc02554a62d", "url": "https://github.com/hortonworks/cloudbreak/commit/c4949413902975b3a05e857f8fe0afc02554a62d", "message": "CB-9926: Add retries to the legacy health check's ping\n\nAdd retries to the legacy health check's ping.\n\nRefactor the health checks to allow it to be retry on each instance of\nFreeIPA.", "committedDate": "2021-01-05T16:19:45Z", "type": "commit"}]}