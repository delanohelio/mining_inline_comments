{"pr_number": 8230, "pr_title": "CDPCP-1941. Sync Azure OID Mappings as part of user sync", "pr_createdAt": "2020-06-08T09:21:23Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/8230", "timeline": [{"oid": "722dc440221c51fa0c7b99786b35a68302b336b7", "url": "https://github.com/hortonworks/cloudbreak/commit/722dc440221c51fa0c7b99786b35a68302b336b7", "message": "CDPCP-1941. Add unit tests related OID mapping sync", "committedDate": "2020-06-16T19:46:38Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ0ODIxNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442448217", "bodyText": "nit: I think a better name would be RangerCloudIdentityService", "author": "handavid", "createdAt": "2020-06-18T19:19:11Z", "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/CloudIdentityRangerSyncService.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.sequenceiq.datalake.entity.SdxCluster;\n+import com.sequenceiq.datalake.service.sdx.SdxService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Service\n+public class CloudIdentityRangerSyncService {", "originalCommit": "722dc440221c51fa0c7b99786b35a68302b336b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ1MDMzNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442450336", "bodyText": "it looks like you want to do this by env crn instead of cluster crn. You should change the path and the parameter name. see getByEnvCrn method above for comparison.", "author": "handavid", "createdAt": "2020-06-18T19:23:24Z", "path": "datalake-api/src/main/java/com/sequenceiq/sdx/api/endpoint/SdxEndpoint.java", "diffHunk": "@@ -165,4 +166,10 @@ SdxClusterResponse create(@ValidStackNameFormat @ValidStackNameLength @PathParam\n     @ApiOperation(value = \"list advertised datalake versions\", produces = MediaType.APPLICATION_JSON, nickname = \"advertisedruntimes\")\n     List<AdvertisedRuntime> advertisedRuntimes();\n \n+    @POST\n+    @Path(\"/crn/{crn}/ranger_cloud_identity_mapping\")", "originalCommit": "722dc440221c51fa0c7b99786b35a68302b336b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ1NDEyMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442454121", "bodyText": "why is this the only API that needs retrying?", "author": "handavid", "createdAt": "2020-06-18T19:30:40Z", "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/ClouderaManagerRangerUtil.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.ClustersResourceApi;\n+import com.cloudera.api.swagger.RoleCommandsResourceApi;\n+import com.cloudera.api.swagger.RolesResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiBulkCommandList;\n+import com.cloudera.api.swagger.model.ApiClusterList;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiConfig;\n+import com.cloudera.api.swagger.model.ApiConfigList;\n+import com.cloudera.api.swagger.model.ApiRole;\n+import com.cloudera.api.swagger.model.ApiRoleNameList;\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Joiner.MapJoiner;\n+import com.google.common.collect.ImmutableSortedMap;\n+import com.google.common.collect.Iterables;\n+import com.sequenceiq.cloudbreak.cm.client.retry.ClouderaManagerApiFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.retry.RetryException;\n+import org.springframework.retry.annotation.Backoff;\n+import org.springframework.retry.annotation.Retryable;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public class ClouderaManagerRangerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerRangerUtil.class);\n+\n+    private static final String RANGER_SERVICE_NAME = \"ranger\";\n+\n+    private static final String RANGER_USER_SYNC_ROLE_TYPE = \"RANGER_USERSYNC\";\n+\n+    private static final String AZURE_USER_MAPPING = \"ranger_usersync_azure_user_mapping\";\n+\n+    private static final String AZURE_GROUP_MAPPING = \"ranger_usersync_azure_group_mapping\";\n+\n+    private static final MapJoiner CLOUD_IDENTITY_CONFIG_MAP_JOINER =\n+            Joiner.on(\";\").withKeyValueSeparator(\"=\");\n+\n+    @Inject\n+    private ClouderaManagerProxiedClientFactory clouderaManagerProxiedClientFactory;\n+\n+    @Inject\n+    private ClouderaManagerApiFactory clouderaManagerApiFactory;\n+\n+    private String getClusterName(ApiClient client) throws ApiException {\n+        ClustersResourceApi clustersResource = clouderaManagerApiFactory.getClustersResourceApi(client);\n+        ApiClusterList clusterList = clustersResource.readClusters(null, null);\n+        return Iterables.getOnlyElement(clusterList.getItems()).getName();\n+    }\n+\n+    private String getRangerUserSyncRoleName(ApiClient client, String clusterName) throws ApiException {\n+        RolesResourceApi rolesResourceApi = clouderaManagerApiFactory.getRolesResourceApi(client);\n+        List<ApiRole> apiRoleList =  rolesResourceApi.readRoles(clusterName, RANGER_SERVICE_NAME, null, null)\n+                .getItems()\n+                .stream()\n+                .filter(apiRole -> apiRole.getType().equals(RANGER_USER_SYNC_ROLE_TYPE))\n+                .collect(Collectors.toList());\n+        return Iterables.getOnlyElement(apiRoleList).getName();\n+    }\n+\n+    private ApiConfig newCloudIdentityConfig(String configName, Map<String, String> configValues) {\n+        // NOTE: We sort the configs first. This isn't really necessary but is more consistent.\n+        ImmutableSortedMap<String, String> configValuesSorted = ImmutableSortedMap.copyOf(configValues);\n+        ApiConfig config = new ApiConfig();\n+        config.setName(configName);\n+        config.setValue(CLOUD_IDENTITY_CONFIG_MAP_JOINER.join(configValuesSorted));\n+        return config;\n+    }\n+\n+    @Retryable(value = RetryException.class, maxAttempts = 5, backoff = @Backoff(delay = 500))", "originalCommit": "722dc440221c51fa0c7b99786b35a68302b336b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk4MzU4MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r445983580", "bodyText": "Refresh specifically might need retrying because another refresh is occurring. Though I've found that there is automatic retry of failed api calls, so I don' think a retry here is necessary anymore. I've removed it.", "author": "aarman-cloudera", "createdAt": "2020-06-26T06:01:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ1NDEyMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2NDAzOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442464039", "bodyText": "The AzureObjectId belongs in the UmsUsersState, not the UsersState because it's information that is provided by the UMS with no matching information from the FreeIPA side. We use equality to compare the FmsUser and FmsGroup models generated by the UMS against those generated by FreeIPA. Adding in asymmetric information will break the equality and the state difference calculation.\nsee how we handle workload credentials instead. I think that you can pass the List into the handleUser method and store it there. This will also let you only store OIDs for users that have access to the environment instead of all users.", "author": "handavid", "createdAt": "2020-06-18T19:47:27Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java", "diffHunk": "@@ -217,11 +219,26 @@ private void addMemberToInternalTrackingGroup(UsersState.Builder usersStateBuild\n         usersStateBuilder.addMemberToGroup(UserSyncConstants.CDP_USERSYNC_INTERNAL_GROUP, username);\n     }\n \n+    private Optional<String> getOptionalAzureObjectId(List<CloudIdentity> cloudIdentities) {\n+        List<CloudIdentity> azureCloudIdentities = cloudIdentities.stream()\n+                .filter(cloudIdentity -> cloudIdentity.getCloudIdentityDomain().hasAzureCloudIdentityDomain())\n+                .collect(Collectors.toList());\n+        if (azureCloudIdentities.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        if (azureCloudIdentities.size() > 1) {\n+            throw new IllegalStateException(String.format(\"List contains multiple azure cloud identities = %s\", cloudIdentities));\n+        }\n+        String azureObjectId = Iterables.getOnlyElement(azureCloudIdentities).getCloudIdentityName().getAzureCloudIdentityName().getObjectId();\n+        return Optional.of(azureObjectId);\n+    }\n+\n     private FmsUser umsUserToUser(User umsUser) {\n         FmsUser fmsUser = new FmsUser();\n         fmsUser.withName(umsUser.getWorkloadUsername());\n         fmsUser.withFirstName(getOrDefault(umsUser.getFirstName(), \"None\"));\n         fmsUser.withLastName(getOrDefault(umsUser.getLastName(), \"None\"));\n+        fmsUser.withAzureObjectId(getOptionalAzureObjectId(umsUser.getCloudIdentitiesList()));", "originalCommit": "722dc440221c51fa0c7b99786b35a68302b336b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk4Mzg3OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r445983879", "bodyText": "Thanks, I've moved cloud identify information into the UmsUserState.", "author": "aarman-cloudera", "createdAt": "2020-06-26T06:02:26Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2NDAzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2NjEyNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442466127", "bodyText": "FmsGroups suffer the same issue as FmsUsers.\nyou'll need to calculate the group mapping somewhere around line 71 and add it into the UmsUsersState somewhere around line 78", "author": "handavid", "createdAt": "2020-06-18T19:51:35Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java", "diffHunk": "@@ -241,12 +258,14 @@ private FmsUser umsMachineUserToUser(MachineUser umsMachineUser) {\n         // TODO what should the appropriate first and last name be for machine users?\n         fmsUser.withFirstName(\"Machine\");\n         fmsUser.withLastName(\"User\");\n+        fmsUser.withAzureObjectId(getOptionalAzureObjectId(umsMachineUser.getCloudIdentitiesList()));\n         return fmsUser;\n     }\n \n     private FmsGroup umsGroupToGroup(Group umsGroup) {\n         FmsGroup fmsGroup = new FmsGroup();\n         fmsGroup.withName(umsGroup.getGroupName());\n+        fmsGroup.withAzureObjectId(getOptionalAzureObjectId(umsGroup.getCloudIdentitiesList()));", "originalCommit": "722dc440221c51fa0c7b99786b35a68302b336b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2Njg3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442466874", "bodyText": "These maps should just be stored in the UmsUsersState directly.", "author": "handavid", "createdAt": "2020-06-18T19:53:02Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "diffHunk": "@@ -274,6 +290,30 @@ private SyncStatusDetail internalSynchronizeStack(Stack stack, UmsUsersState ums\n         }\n     }\n \n+    private void syncAzureObjectIds(Stack stack, UmsUsersState umsUsersState, BiConsumer<String, String> warnings) {\n+        String envCrn = stack.getEnvironmentCrn();\n+        LOGGER.info(\"Syncing Azure Object IDs for environment {}\", envCrn);\n+\n+        UsersState userState = umsUsersState.getUsersState();\n+        Map<String, String> usersToAzureObjectIdMap = userState.getUsers().stream()", "originalCommit": "722dc440221c51fa0c7b99786b35a68302b336b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2NzgwNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442467806", "bodyText": "see comment on UmsUsersStateProvider for why we can't store this info in this model", "author": "handavid", "createdAt": "2020-06-18T19:54:45Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/model/FmsGroup.java", "diffHunk": "@@ -1,20 +1,32 @@\n package com.sequenceiq.freeipa.service.freeipa.user.model;\n \n import java.util.Objects;\n+import java.util.Optional;\n \n public class FmsGroup {\n \n     private String name;\n \n+    private Optional<String> azureObjectId = Optional.empty();", "originalCommit": "722dc440221c51fa0c7b99786b35a68302b336b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjQ2Nzg5MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442467891", "bodyText": "see comment on UmsUsersStateProvider for why we can't store this info in this model", "author": "handavid", "createdAt": "2020-06-18T19:54:54Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/model/FmsUser.java", "diffHunk": "@@ -10,6 +11,8 @@\n \n     private String lastName;\n \n+    private Optional<String> azureObjectId = Optional.empty();", "originalCommit": "722dc440221c51fa0c7b99786b35a68302b336b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxNjcyNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442716726", "bodyText": "Maybe you could include the cluster-cm module and move all the CM related code there and use it from Data Lake.", "author": "keyki", "createdAt": "2020-06-19T08:54:04Z", "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/ClouderaManagerRangerUtil.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.ClustersResourceApi;\n+import com.cloudera.api.swagger.RoleCommandsResourceApi;\n+import com.cloudera.api.swagger.RolesResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiBulkCommandList;\n+import com.cloudera.api.swagger.model.ApiClusterList;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiConfig;\n+import com.cloudera.api.swagger.model.ApiConfigList;\n+import com.cloudera.api.swagger.model.ApiRole;\n+import com.cloudera.api.swagger.model.ApiRoleNameList;\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Joiner.MapJoiner;\n+import com.google.common.collect.ImmutableSortedMap;\n+import com.google.common.collect.Iterables;\n+import com.sequenceiq.cloudbreak.cm.client.retry.ClouderaManagerApiFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.retry.RetryException;\n+import org.springframework.retry.annotation.Backoff;\n+import org.springframework.retry.annotation.Retryable;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public class ClouderaManagerRangerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerRangerUtil.class);\n+\n+    private static final String RANGER_SERVICE_NAME = \"ranger\";", "originalCommit": "722dc440221c51fa0c7b99786b35a68302b336b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk4ODcwOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r445988708", "bodyText": "Do you mind if we look at this in a follow up task? Moving the logic into cluster-cm is straight forward, but pulling in cluster-cm as dependency seems problematic. I ran into dependency conflicts (hibernate, CachingConfig) as well as it requiring additional dependencies (I think it required bringing an implementation of CloudbreakEventService). The  refactoring required might be beyond the scope of this task. I can file a ticket to see if the CM portion can be easily be moved into cluster-cm and client-cm.", "author": "aarman-cloudera", "createdAt": "2020-06-26T06:18:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcxNjcyNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyMjg1Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442722857", "bodyText": "instead of logging when empty we should log sdxclusters we will sync, so the if won't be necessary", "author": "lacikaaa", "createdAt": "2020-06-19T09:08:08Z", "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/CloudIdentityRangerSyncService.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.sequenceiq.datalake.entity.SdxCluster;\n+import com.sequenceiq.datalake.service.sdx.SdxService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Service\n+public class CloudIdentityRangerSyncService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CloudIdentityRangerSyncService.class);\n+\n+    @Inject\n+    private ClouderaManagerRangerUtil clouderaManagerRangerUtil;\n+\n+    @Inject\n+    private SdxService sdxService;\n+\n+    public void setAzureCloudIdentityMapping(String environmentCrn, Map<String, String> azureUserMapping, Map<String, String> azureGroupMapping) {\n+        LOGGER.info(\"Setting Azure cloud id mappings for environment = {}\", environmentCrn);\n+        List<SdxCluster> sdxClusters = sdxService.listSdxByEnvCrn(environmentCrn);\n+        if (sdxClusters.isEmpty()) {\n+            LOGGER.info(\"Environment has no datalake clusters to sync\");\n+        }", "originalCommit": "722dc440221c51fa0c7b99786b35a68302b336b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyMzExMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442723112", "bodyText": "I think you should use a more specific exception here, and might log it", "author": "lacikaaa", "createdAt": "2020-06-19T09:08:38Z", "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/CloudIdentityRangerSyncService.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.sequenceiq.datalake.entity.SdxCluster;\n+import com.sequenceiq.datalake.service.sdx.SdxService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Service\n+public class CloudIdentityRangerSyncService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CloudIdentityRangerSyncService.class);\n+\n+    @Inject\n+    private ClouderaManagerRangerUtil clouderaManagerRangerUtil;\n+\n+    @Inject\n+    private SdxService sdxService;\n+\n+    public void setAzureCloudIdentityMapping(String environmentCrn, Map<String, String> azureUserMapping, Map<String, String> azureGroupMapping) {\n+        LOGGER.info(\"Setting Azure cloud id mappings for environment = {}\", environmentCrn);\n+        List<SdxCluster> sdxClusters = sdxService.listSdxByEnvCrn(environmentCrn);\n+        if (sdxClusters.isEmpty()) {\n+            LOGGER.info(\"Environment has no datalake clusters to sync\");\n+        }\n+        sdxClusters.forEach(sdxCluster -> {\n+            String stackCrn = sdxCluster.getStackCrn();\n+            LOGGER.info(\"Updating azure cloud id mappings for datalake stack crn = {}, environment = {}\", stackCrn, environmentCrn);\n+            try {\n+                clouderaManagerRangerUtil.setAzureCloudIdentityMapping(stackCrn, azureUserMapping, azureGroupMapping);\n+            } catch (ApiException e) {\n+                throw new RuntimeException(\"Encountered api exception\", e);", "originalCommit": "722dc440221c51fa0c7b99786b35a68302b336b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk4ODk4OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r445988988", "bodyText": "I've added a new exception type.", "author": "aarman-cloudera", "createdAt": "2020-06-26T06:19:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyMzExMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyMzUxOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442723519", "bodyText": "could be refaactored into a separate method", "author": "lacikaaa", "createdAt": "2020-06-19T09:09:26Z", "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/CloudIdentityRangerSyncService.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.sequenceiq.datalake.entity.SdxCluster;\n+import com.sequenceiq.datalake.service.sdx.SdxService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+\n+@Service\n+public class CloudIdentityRangerSyncService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CloudIdentityRangerSyncService.class);\n+\n+    @Inject\n+    private ClouderaManagerRangerUtil clouderaManagerRangerUtil;\n+\n+    @Inject\n+    private SdxService sdxService;\n+\n+    public void setAzureCloudIdentityMapping(String environmentCrn, Map<String, String> azureUserMapping, Map<String, String> azureGroupMapping) {\n+        LOGGER.info(\"Setting Azure cloud id mappings for environment = {}\", environmentCrn);\n+        List<SdxCluster> sdxClusters = sdxService.listSdxByEnvCrn(environmentCrn);\n+        if (sdxClusters.isEmpty()) {\n+            LOGGER.info(\"Environment has no datalake clusters to sync\");\n+        }\n+        sdxClusters.forEach(sdxCluster -> {\n+            String stackCrn = sdxCluster.getStackCrn();\n+            LOGGER.info(\"Updating azure cloud id mappings for datalake stack crn = {}, environment = {}\", stackCrn, environmentCrn);\n+            try {\n+                clouderaManagerRangerUtil.setAzureCloudIdentityMapping(stackCrn, azureUserMapping, azureGroupMapping);\n+            } catch (ApiException e) {\n+                throw new RuntimeException(\"Encountered api exception\", e);\n+            }\n+        });", "originalCommit": "722dc440221c51fa0c7b99786b35a68302b336b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNTM3Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442725377", "bodyText": "why 20sec? I think we use 1 min in CB for this", "author": "lacikaaa", "createdAt": "2020-06-19T09:13:22Z", "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/ClouderaManagerProxiedClientFactory.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.client.ApiClient;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Component\n+public class ClouderaManagerProxiedClientFactory {\n+\n+    private static final String API_VERSION_32 = \"v32\";\n+\n+    private static final int CM_READ_TIMEOUT_MS =  60 * 1000;\n+\n+    private static final int CM_CONNECT_TIMEOUT_MS = 20 * 1000;", "originalCommit": "722dc440221c51fa0c7b99786b35a68302b336b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczNTUyOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442735528", "bodyText": "The cm module have these already configured to use proxy and direct connections, I think that should be used instead of creating new CM related code in other modules.", "author": "keyki", "createdAt": "2020-06-19T09:34:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNTM3Nw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk5MTY5Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r445991696", "bodyText": "I think we used 20 seconds in thunderhead repo. I've updated this to 60 sec. As mentioned in previous comment, I think it makes sense to move the logic into other modules as a separate ticket.", "author": "aarman-cloudera", "createdAt": "2020-06-26T06:28:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNTM3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNTU2NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442725564", "bodyText": "why this version? in CB we use 31 or 40. I think this should be in sync", "author": "lacikaaa", "createdAt": "2020-06-19T09:13:48Z", "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/ClouderaManagerProxiedClientFactory.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.client.ApiClient;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Component\n+public class ClouderaManagerProxiedClientFactory {\n+\n+    private static final String API_VERSION_32 = \"v32\";", "originalCommit": "722dc440221c51fa0c7b99786b35a68302b336b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk5MTc0OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r445991749", "bodyText": "Updated to 31", "author": "aarman-cloudera", "createdAt": "2020-06-26T06:28:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNTU2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNjY2MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442726661", "bodyText": "altogether it would be nice if you could use https://github.com/hortonworks/cloudbreak/blob/master/client-cm/src/main/java/com/sequenceiq/cloudbreak/cm/client/ClouderaManagerApiClientProvider.java instead of this class", "author": "lacikaaa", "createdAt": "2020-06-19T09:16:03Z", "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/ClouderaManagerProxiedClientFactory.java", "diffHunk": "@@ -0,0 +1,32 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.client.ApiClient;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.concurrent.TimeUnit;\n+\n+@Component\n+public class ClouderaManagerProxiedClientFactory {", "originalCommit": "722dc440221c51fa0c7b99786b35a68302b336b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk5NzMzMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r445997330", "bodyText": "As mentioned in previous comment, can we look into this as a separate ticket.", "author": "aarman-cloudera", "createdAt": "2020-06-26T06:44:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNjY2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyNzg2NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442727865", "bodyText": "please don't use in middle of method return", "author": "lacikaaa", "createdAt": "2020-06-19T09:18:43Z", "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/ClouderaManagerRangerUtil.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.ClustersResourceApi;\n+import com.cloudera.api.swagger.RoleCommandsResourceApi;\n+import com.cloudera.api.swagger.RolesResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiBulkCommandList;\n+import com.cloudera.api.swagger.model.ApiClusterList;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiConfig;\n+import com.cloudera.api.swagger.model.ApiConfigList;\n+import com.cloudera.api.swagger.model.ApiRole;\n+import com.cloudera.api.swagger.model.ApiRoleNameList;\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Joiner.MapJoiner;\n+import com.google.common.collect.ImmutableSortedMap;\n+import com.google.common.collect.Iterables;\n+import com.sequenceiq.cloudbreak.cm.client.retry.ClouderaManagerApiFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.retry.RetryException;\n+import org.springframework.retry.annotation.Backoff;\n+import org.springframework.retry.annotation.Retryable;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public class ClouderaManagerRangerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerRangerUtil.class);\n+\n+    private static final String RANGER_SERVICE_NAME = \"ranger\";\n+\n+    private static final String RANGER_USER_SYNC_ROLE_TYPE = \"RANGER_USERSYNC\";\n+\n+    private static final String AZURE_USER_MAPPING = \"ranger_usersync_azure_user_mapping\";\n+\n+    private static final String AZURE_GROUP_MAPPING = \"ranger_usersync_azure_group_mapping\";\n+\n+    private static final MapJoiner CLOUD_IDENTITY_CONFIG_MAP_JOINER =\n+            Joiner.on(\";\").withKeyValueSeparator(\"=\");\n+\n+    @Inject\n+    private ClouderaManagerProxiedClientFactory clouderaManagerProxiedClientFactory;\n+\n+    @Inject\n+    private ClouderaManagerApiFactory clouderaManagerApiFactory;\n+\n+    private String getClusterName(ApiClient client) throws ApiException {\n+        ClustersResourceApi clustersResource = clouderaManagerApiFactory.getClustersResourceApi(client);\n+        ApiClusterList clusterList = clustersResource.readClusters(null, null);\n+        return Iterables.getOnlyElement(clusterList.getItems()).getName();\n+    }\n+\n+    private String getRangerUserSyncRoleName(ApiClient client, String clusterName) throws ApiException {\n+        RolesResourceApi rolesResourceApi = clouderaManagerApiFactory.getRolesResourceApi(client);\n+        List<ApiRole> apiRoleList =  rolesResourceApi.readRoles(clusterName, RANGER_SERVICE_NAME, null, null)\n+                .getItems()\n+                .stream()\n+                .filter(apiRole -> apiRole.getType().equals(RANGER_USER_SYNC_ROLE_TYPE))\n+                .collect(Collectors.toList());\n+        return Iterables.getOnlyElement(apiRoleList).getName();\n+    }\n+\n+    private ApiConfig newCloudIdentityConfig(String configName, Map<String, String> configValues) {\n+        // NOTE: We sort the configs first. This isn't really necessary but is more consistent.\n+        ImmutableSortedMap<String, String> configValuesSorted = ImmutableSortedMap.copyOf(configValues);\n+        ApiConfig config = new ApiConfig();\n+        config.setName(configName);\n+        config.setValue(CLOUD_IDENTITY_CONFIG_MAP_JOINER.join(configValuesSorted));\n+        return config;\n+    }\n+\n+    @Retryable(value = RetryException.class, maxAttempts = 5, backoff = @Backoff(delay = 500))\n+    public void triggerRoleRefresh(ApiClient client, String clusterName, String serviceName, String roleName) {\n+        LOGGER.info(\"Attempting to trigger role refresh on clusterName = {}, serviceName = {}, roleName = {}\", clusterName, serviceName, roleName);\n+        ApiRoleNameList roleNameList = new ApiRoleNameList();\n+        roleNameList.addItemsItem(roleName);\n+        RoleCommandsResourceApi roleCommandsResourceApi = clouderaManagerApiFactory.getRoleCommandsResourceApi(client);\n+        try {\n+            ApiBulkCommandList bulkResponse = roleCommandsResourceApi.refreshCommand(clusterName, serviceName, roleNameList);\n+            ApiCommand response = Iterables.getOnlyElement(bulkResponse.getItems());\n+            LOGGER.info(\"ApiCommand response for role refresh = {}\", response);\n+            if (response != null && (response.getActive() || response.getSuccess())) {\n+                LOGGER.info(\"Successfully triggered role refresh\");\n+            } else {\n+                throw new RetryException(\"Role refresh was not successfully trigerred\");\n+            }\n+        } catch (ApiException e) {\n+            throw new RetryException(\"Encountered ApiException on role refresh\", e);\n+        }\n+    }\n+\n+    private boolean supportsCloudIdMapping(RolesResourceApi rolesResourceApi, String clusterName, String rangerUserSyncRole) throws ApiException {\n+        ApiConfigList configList = rolesResourceApi.readRoleConfig(clusterName, RANGER_SERVICE_NAME, rangerUserSyncRole, \"full\");\n+        return configList.getItems().stream().map(ApiConfig::getName).anyMatch(configName -> configName.equals(AZURE_USER_MAPPING));\n+    }\n+\n+    public void setAzureCloudIdentityMapping(String stackCrn, Map<String, String> azureUserMapping, Map<String, String> azureGroupMapping) throws ApiException {\n+        // NOTE: The necessary configs changed here are only available in CM7.2-1\n+        // TODO Skip setting role and trigerring refresh if the configs haven't changed\n+        ApiClient client = clouderaManagerProxiedClientFactory.getProxiedClouderaManagerClient(stackCrn);\n+        String clusterName = getClusterName(client);\n+        String rangerUserSyncRoleName = getRangerUserSyncRoleName(client, clusterName);\n+        RolesResourceApi rolesResourceApi = clouderaManagerApiFactory.getRolesResourceApi(client);\n+        if (!supportsCloudIdMapping(rolesResourceApi, clusterName, rangerUserSyncRoleName)) {\n+            LOGGER.info(\"This version of CM does not support cloud identity mapping. Skipping.\");\n+            return;\n+        }", "originalCommit": "722dc440221c51fa0c7b99786b35a68302b336b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyODk1MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442728950", "bodyText": "isn't already there a general solution for this @horadla23 ?", "author": "lacikaaa", "createdAt": "2020-06-19T09:20:58Z", "path": "datalake/src/main/java/com/sequenceiq/datalake/controller/sdx/SdxController.java", "diffHunk": "@@ -239,4 +248,19 @@ public FlowIdentifier stopByCrn(@ResourceCrn String crn) {\n         return cdpConfigService.getAdvertisedRuntimes();\n     }\n \n+    // custom authorization check\n+    @Override\n+    @DisableCheckPermissions\n+    public void setRangerCloudIdentityMapping(String envCrn, SetRangerCloudIdentityMappingRequest request) {\n+        checkIsInternalActor();", "originalCommit": "722dc440221c51fa0c7b99786b35a68302b336b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ0OTczNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447449737", "bodyText": "there is, last week we introduced @InternalOnly annotation, that should be used here instead of @DisabledCheckPermissions (I need to update authz readme)", "author": "horadla23", "createdAt": "2020-06-30T06:51:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyODk1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ1MTU5OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447451599", "bodyText": "and @InternalOnly will guarantee that the method can be called only by internal actor", "author": "horadla23", "createdAt": "2020-06-30T06:55:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyODk1MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQ4Nzg4Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447487886", "bodyText": "Thanks, I've switched the new annotation.", "author": "aarman-cloudera", "createdAt": "2020-06-30T08:00:09Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyODk1MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyOTA0Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442729042", "bodyText": "unnecessary comment", "author": "lacikaaa", "createdAt": "2020-06-19T09:21:10Z", "path": "datalake/src/main/java/com/sequenceiq/datalake/controller/sdx/SdxController.java", "diffHunk": "@@ -239,4 +248,19 @@ public FlowIdentifier stopByCrn(@ResourceCrn String crn) {\n         return cdpConfigService.getAdvertisedRuntimes();\n     }\n \n+    // custom authorization check", "originalCommit": "722dc440221c51fa0c7b99786b35a68302b336b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjcyOTU0MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442729541", "bodyText": "this might be debug if we really need it", "author": "lacikaaa", "createdAt": "2020-06-19T09:22:15Z", "path": "datalake/src/main/java/com/sequenceiq/datalake/service/sdx/SdxService.java", "diffHunk": "@@ -509,6 +509,12 @@ private void setTagsSafe(SdxClusterRequest sdxClusterRequest, SdxCluster sdxClus\n         return sdxClusterRepository.findByAccountIdAndEnvCrnAndDeletedIsNull(accountIdFromCrn, envCrn);\n     }\n \n+    public List<SdxCluster> listSdxByEnvCrn(String envCrn) {\n+        LOGGER.info(\"Listing SDX clusters by environment crn {}\", envCrn);", "originalCommit": "722dc440221c51fa0c7b99786b35a68302b336b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczMDIwNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442730204", "bodyText": "I think some annotations are missing here, like ignore unknown etc", "author": "lacikaaa", "createdAt": "2020-06-19T09:23:35Z", "path": "datalake-api/src/main/java/com/sequenceiq/sdx/api/model/SetRangerCloudIdentityMappingRequest.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package com.sequenceiq.sdx.api.model;\n+\n+import java.util.Map;\n+\n+public class SetRangerCloudIdentityMappingRequest {", "originalCommit": "722dc440221c51fa0c7b99786b35a68302b336b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NTk5MjA4Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r445992082", "bodyText": "For now both of these fields are required. I think once we add support for other cloud providers we might want to loosen that requirement.", "author": "aarman-cloudera", "createdAt": "2020-06-26T06:29:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczMDIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5MDY1MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447590651", "bodyText": "@ApiModel\n@JsonIgnoreProperties(ignoreUnknown = true)`\n\nmissing", "author": "lacikaaa", "createdAt": "2020-06-30T10:47:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczMDIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5NTUxNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447595517", "bodyText": "implement toString please", "author": "lacikaaa", "createdAt": "2020-06-30T10:56:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczMDIwNA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkyMjY0Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447922646", "bodyText": "Thanks! (I don't think I saw similar annotations in the other sdx requets)", "author": "aarman-cloudera", "createdAt": "2020-06-30T19:18:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczMDIwNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczMjMxMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442732311", "bodyText": "this could be private", "author": "lacikaaa", "createdAt": "2020-06-19T09:27:49Z", "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/ClouderaManagerRangerUtil.java", "diffHunk": "@@ -0,0 +1,124 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.ClustersResourceApi;\n+import com.cloudera.api.swagger.RoleCommandsResourceApi;\n+import com.cloudera.api.swagger.RolesResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiBulkCommandList;\n+import com.cloudera.api.swagger.model.ApiClusterList;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiConfig;\n+import com.cloudera.api.swagger.model.ApiConfigList;\n+import com.cloudera.api.swagger.model.ApiRole;\n+import com.cloudera.api.swagger.model.ApiRoleNameList;\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Joiner.MapJoiner;\n+import com.google.common.collect.ImmutableSortedMap;\n+import com.google.common.collect.Iterables;\n+import com.sequenceiq.cloudbreak.cm.client.retry.ClouderaManagerApiFactory;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.retry.RetryException;\n+import org.springframework.retry.annotation.Backoff;\n+import org.springframework.retry.annotation.Retryable;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public class ClouderaManagerRangerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerRangerUtil.class);\n+\n+    private static final String RANGER_SERVICE_NAME = \"ranger\";\n+\n+    private static final String RANGER_USER_SYNC_ROLE_TYPE = \"RANGER_USERSYNC\";\n+\n+    private static final String AZURE_USER_MAPPING = \"ranger_usersync_azure_user_mapping\";\n+\n+    private static final String AZURE_GROUP_MAPPING = \"ranger_usersync_azure_group_mapping\";\n+\n+    private static final MapJoiner CLOUD_IDENTITY_CONFIG_MAP_JOINER =\n+            Joiner.on(\";\").withKeyValueSeparator(\"=\");\n+\n+    @Inject\n+    private ClouderaManagerProxiedClientFactory clouderaManagerProxiedClientFactory;\n+\n+    @Inject\n+    private ClouderaManagerApiFactory clouderaManagerApiFactory;\n+\n+    private String getClusterName(ApiClient client) throws ApiException {\n+        ClustersResourceApi clustersResource = clouderaManagerApiFactory.getClustersResourceApi(client);\n+        ApiClusterList clusterList = clustersResource.readClusters(null, null);\n+        return Iterables.getOnlyElement(clusterList.getItems()).getName();\n+    }\n+\n+    private String getRangerUserSyncRoleName(ApiClient client, String clusterName) throws ApiException {\n+        RolesResourceApi rolesResourceApi = clouderaManagerApiFactory.getRolesResourceApi(client);\n+        List<ApiRole> apiRoleList =  rolesResourceApi.readRoles(clusterName, RANGER_SERVICE_NAME, null, null)\n+                .getItems()\n+                .stream()\n+                .filter(apiRole -> apiRole.getType().equals(RANGER_USER_SYNC_ROLE_TYPE))\n+                .collect(Collectors.toList());\n+        return Iterables.getOnlyElement(apiRoleList).getName();\n+    }\n+\n+    private ApiConfig newCloudIdentityConfig(String configName, Map<String, String> configValues) {\n+        // NOTE: We sort the configs first. This isn't really necessary but is more consistent.\n+        ImmutableSortedMap<String, String> configValuesSorted = ImmutableSortedMap.copyOf(configValues);\n+        ApiConfig config = new ApiConfig();\n+        config.setName(configName);\n+        config.setValue(CLOUD_IDENTITY_CONFIG_MAP_JOINER.join(configValuesSorted));\n+        return config;\n+    }\n+\n+    @Retryable(value = RetryException.class, maxAttempts = 5, backoff = @Backoff(delay = 500))\n+    public void triggerRoleRefresh(ApiClient client, String clusterName, String serviceName, String roleName) {", "originalCommit": "722dc440221c51fa0c7b99786b35a68302b336b7", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU3NzQ1OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447577458", "bodyText": "this is still valid", "author": "lacikaaa", "createdAt": "2020-06-30T10:23:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczMjMxMQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkyODgyOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447928829", "bodyText": "Sorry thought I made it private, fixed now.", "author": "aarman-cloudera", "createdAt": "2020-06-30T19:29:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczMjMxMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0MjczMzE4Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r442733187", "bodyText": "this should go into an else branch, maybe into a separate method", "author": "lacikaaa", "createdAt": "2020-06-19T09:29:32Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java", "diffHunk": "@@ -217,11 +219,26 @@ private void addMemberToInternalTrackingGroup(UsersState.Builder usersStateBuild\n         usersStateBuilder.addMemberToGroup(UserSyncConstants.CDP_USERSYNC_INTERNAL_GROUP, username);\n     }\n \n+    private Optional<String> getOptionalAzureObjectId(List<CloudIdentity> cloudIdentities) {\n+        List<CloudIdentity> azureCloudIdentities = cloudIdentities.stream()\n+                .filter(cloudIdentity -> cloudIdentity.getCloudIdentityDomain().hasAzureCloudIdentityDomain())\n+                .collect(Collectors.toList());\n+        if (azureCloudIdentities.isEmpty()) {\n+            return Optional.empty();\n+        }\n+        if (azureCloudIdentities.size() > 1) {\n+            throw new IllegalStateException(String.format(\"List contains multiple azure cloud identities = %s\", cloudIdentities));\n+        }\n+        String azureObjectId = Iterables.getOnlyElement(azureCloudIdentities).getCloudIdentityName().getAzureCloudIdentityName().getObjectId();\n+        return Optional.of(azureObjectId);", "originalCommit": "722dc440221c51fa0c7b99786b35a68302b336b7", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "67db630a9def3f4f0155d2b0762dfd92b7fb7860", "url": "https://github.com/hortonworks/cloudbreak/commit/67db630a9def3f4f0155d2b0762dfd92b7fb7860", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm", "committedDate": "2020-06-25T22:10:40Z", "type": "forcePushed"}, {"oid": "9d86ae37218d381e44e22608bba2b1df5eb670af", "url": "https://github.com/hortonworks/cloudbreak/commit/9d86ae37218d381e44e22608bba2b1df5eb670af", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm", "committedDate": "2020-06-26T06:25:32Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI1MDMyOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r446250329", "bodyText": "See the path on line 68. it looks like\n/envcrn/{envCrn}\nThis should match to distinguish between the resource crn and the environment crn", "author": "handavid", "createdAt": "2020-06-26T15:22:39Z", "path": "datalake-api/src/main/java/com/sequenceiq/sdx/api/endpoint/SdxEndpoint.java", "diffHunk": "@@ -165,4 +166,10 @@ SdxClusterResponse create(@ValidStackNameFormat @ValidStackNameLength @PathParam\n     @ApiOperation(value = \"list advertised datalake versions\", produces = MediaType.APPLICATION_JSON, nickname = \"advertisedruntimes\")\n     List<AdvertisedRuntime> advertisedRuntimes();\n \n+    @POST\n+    @Path(\"/crn/{envCrn}/ranger_cloud_identity_mapping\")", "originalCommit": "9d86ae37218d381e44e22608bba2b1df5eb670af", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI1ODIxMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r446258212", "bodyText": "this adds cloud identities for all users, regardless of if they have access to the environment. Is this desirable? I would think that you would only care about users that have access to the environment. Imagine if an account has 1000 user but the environment only has 100. You would be syncing the other 900 users cloud identities.\nYou can filter this map by the users that are in the umsUsersState.getUserState().getUsers()", "author": "handavid", "createdAt": "2020-06-26T15:36:19Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "diffHunk": "@@ -274,6 +292,51 @@ private SyncStatusDetail internalSynchronizeStack(Stack stack, UmsUsersState ums\n         }\n     }\n \n+    private Optional<String> getOptionalAzureObjectId(List<CloudIdentity> cloudIdentities) {\n+        List<CloudIdentity> azureCloudIdentities = cloudIdentities.stream()\n+                .filter(cloudIdentity -> cloudIdentity.getCloudIdentityDomain().hasAzureCloudIdentityDomain())\n+                .collect(Collectors.toList());\n+        if (azureCloudIdentities.isEmpty()) {\n+            return Optional.empty();\n+        } else if (azureCloudIdentities.size() > 1) {\n+            throw new IllegalStateException(String.format(\"List contains multiple azure cloud identities = %s\", cloudIdentities));\n+        } else {\n+            String azureObjectId = Iterables.getOnlyElement(azureCloudIdentities).getCloudIdentityName().getAzureCloudIdentityName().getObjectId();\n+            return Optional.of(azureObjectId);\n+        }\n+    }\n+\n+    private Map<String, String> getAzureObjectIdMap(Map<String, List<CloudIdentity>> cloudIdentityMapping) {\n+        ImmutableMap.Builder<String, String> azureObjectIdMap = ImmutableMap.builder();\n+        cloudIdentityMapping.forEach((key, cloudIdentities) -> {\n+            Optional<String> azureObjectId = getOptionalAzureObjectId(cloudIdentities);\n+            if (azureObjectId.isPresent()) {\n+                azureObjectIdMap.put(key, azureObjectId.get());\n+            }\n+        });\n+        return azureObjectIdMap.build();\n+    }\n+\n+    private void syncAzureObjectIds(Stack stack, UmsUsersState umsUsersState, BiConsumer<String, String> warnings) {\n+        String envCrn = stack.getEnvironmentCrn();\n+        LOGGER.info(\"Syncing Azure Object IDs for environment {}\", envCrn);\n+\n+        Map<String, String> userToAzureObjectIdMap = getAzureObjectIdMap(umsUsersState.getUserToCloudIdentityMap());", "originalCommit": "9d86ae37218d381e44e22608bba2b1df5eb670af", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjgyMjQ5MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r446822490", "bodyText": "Good point, I've added the filtering part. Also I've moved most of this logic out of UserSyncService and into CloudIdentitySyncService.", "author": "aarman-cloudera", "createdAt": "2020-06-29T07:24:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NjI1ODIxMg=="}], "type": "inlineReview"}, {"oid": "1288746411788c6258036c271f5fe679d60f61bc", "url": "https://github.com/hortonworks/cloudbreak/commit/1288746411788c6258036c271f5fe679d60f61bc", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm", "committedDate": "2020-06-29T07:21:04Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEwNjgyMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447106821", "bodyText": "nit: if you reverse the order of conditions and inline the entitlement check here, then we can skip the entitlement check if it's not a full sync.", "author": "handavid", "createdAt": "2020-06-29T16:40:40Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserSyncService.java", "diffHunk": "@@ -283,6 +290,12 @@ private SyncStatusDetail internalSynchronizeStack(Stack stack, UmsUsersState ums\n                 workloadCredentialService.setWorkloadCredentials(freeIpaClient, umsUsersState.getUsersWorkloadCredentialMap(), warnings::put);\n             }\n \n+            boolean hasCloudIdentityEntitlement = entitlementService.cloudIdentityMappingEnabled(INTERNAL_ACTOR_CRN, stack.getAccountId());\n+            // TODO For now we only sync cloud ids during full sync. We should eventually allow more granular syncs (actor level and group level sync).\n+            if (hasCloudIdentityEntitlement && fullSync) {", "originalCommit": "1288746411788c6258036c271f5fe679d60f61bc", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzQxNjA5NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447416094", "bodyText": "nice one", "author": "aarman-cloudera", "createdAt": "2020-06-30T05:20:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzEwNjgyMQ=="}], "type": "inlineReview"}, {"oid": "c629b1ea476e88ad4e4b71afea36b46616a23d2e", "url": "https://github.com/hortonworks/cloudbreak/commit/c629b1ea476e88ad4e4b71afea36b46616a23d2e", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm", "committedDate": "2020-06-30T05:19:25Z", "type": "forcePushed"}, {"oid": "d840e6cf1a31933420365a228d672675691fa93c", "url": "https://github.com/hortonworks/cloudbreak/commit/d840e6cf1a31933420365a228d672675691fa93c", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm", "committedDate": "2020-06-30T07:57:19Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU3ODI1MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447578250", "bodyText": "usually method with boolean return value start with is. eg: isCloudIdMappingSupported", "author": "lacikaaa", "createdAt": "2020-06-30T10:24:36Z", "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/ClouderaManagerRangerUtil.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.ClustersResourceApi;\n+import com.cloudera.api.swagger.RoleCommandsResourceApi;\n+import com.cloudera.api.swagger.RolesResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiBulkCommandList;\n+import com.cloudera.api.swagger.model.ApiClusterList;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiConfig;\n+import com.cloudera.api.swagger.model.ApiConfigList;\n+import com.cloudera.api.swagger.model.ApiRole;\n+import com.cloudera.api.swagger.model.ApiRoleNameList;\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Joiner.MapJoiner;\n+import com.google.common.collect.ImmutableSortedMap;\n+import com.google.common.collect.Iterables;\n+\n+import com.sequenceiq.cloudbreak.cm.client.retry.ClouderaManagerApiFactory;\n+import com.sequenceiq.datalake.controller.exception.RangerCloudIdentitySyncException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public class ClouderaManagerRangerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerRangerUtil.class);\n+\n+    private static final String RANGER_SERVICE_NAME = \"ranger\";\n+\n+    private static final String RANGER_USER_SYNC_ROLE_TYPE = \"RANGER_USERSYNC\";\n+\n+    private static final String AZURE_USER_MAPPING = \"ranger_usersync_azure_user_mapping\";\n+\n+    private static final String AZURE_GROUP_MAPPING = \"ranger_usersync_azure_group_mapping\";\n+\n+    private static final MapJoiner CLOUD_IDENTITY_CONFIG_MAP_JOINER =\n+            Joiner.on(\";\").withKeyValueSeparator(\"=\");\n+\n+    @Inject\n+    private ClouderaManagerProxiedClientFactory clouderaManagerProxiedClientFactory;\n+\n+    @Inject\n+    private ClouderaManagerApiFactory clouderaManagerApiFactory;\n+\n+    private String getClusterName(ApiClient client) throws ApiException {\n+        ClustersResourceApi clustersResource = clouderaManagerApiFactory.getClustersResourceApi(client);\n+        ApiClusterList clusterList = clustersResource.readClusters(null, null);\n+        return Iterables.getOnlyElement(clusterList.getItems()).getName();\n+    }\n+\n+    private String getRangerUserSyncRoleName(ApiClient client, String clusterName) throws ApiException {\n+        RolesResourceApi rolesResourceApi = clouderaManagerApiFactory.getRolesResourceApi(client);\n+        List<ApiRole> apiRoleList =  rolesResourceApi.readRoles(clusterName, RANGER_SERVICE_NAME, null, null)\n+                .getItems()\n+                .stream()\n+                .filter(apiRole -> apiRole.getType().equals(RANGER_USER_SYNC_ROLE_TYPE))\n+                .collect(Collectors.toList());\n+        return Iterables.getOnlyElement(apiRoleList).getName();\n+    }\n+\n+    private ApiConfig newCloudIdentityConfig(String configName, Map<String, String> configValues) {\n+        // NOTE: We sort the configs first. This isn't really necessary but is more consistent.\n+        ImmutableSortedMap<String, String> configValuesSorted = ImmutableSortedMap.copyOf(configValues);\n+        ApiConfig config = new ApiConfig();\n+        config.setName(configName);\n+        config.setValue(CLOUD_IDENTITY_CONFIG_MAP_JOINER.join(configValuesSorted));\n+        return config;\n+    }\n+\n+    public void triggerRoleRefresh(ApiClient client, String clusterName, String serviceName, String roleName) {\n+        LOGGER.info(\"Attempting to trigger role refresh on clusterName = {}, serviceName = {}, roleName = {}\", clusterName, serviceName, roleName);\n+        ApiRoleNameList roleNameList = new ApiRoleNameList();\n+        roleNameList.addItemsItem(roleName);\n+        RoleCommandsResourceApi roleCommandsResourceApi = clouderaManagerApiFactory.getRoleCommandsResourceApi(client);\n+        try {\n+            ApiBulkCommandList bulkResponse = roleCommandsResourceApi.refreshCommand(clusterName, serviceName, roleNameList);\n+            ApiCommand response = Iterables.getOnlyElement(bulkResponse.getItems());\n+            LOGGER.info(\"ApiCommand response for role refresh = {}\", response);\n+            if (response != null && (response.getActive() || response.getSuccess())) {\n+                LOGGER.info(\"Successfully triggered role refresh\");\n+            } else {\n+                LOGGER.debug(\"Failed to trigger role refresh\");\n+                throw new RangerCloudIdentitySyncException(\"Role refresh was not successfully trigerred\");\n+            }\n+        } catch (ApiException e) {\n+            throw new RangerCloudIdentitySyncException(\"Encountered ApiException on role refresh\", e);\n+        }\n+    }\n+\n+    private boolean supportsCloudIdMapping(RolesResourceApi rolesResourceApi, String clusterName, String rangerUserSyncRole) throws ApiException {", "originalCommit": "d840e6cf1a31933420365a228d672675691fa93c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4MTM4Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447581382", "bodyText": "this looks like a synchronous call to me, so DL service will wait until it's finished. But if I check the chain it looks like to me, this whole call from freeipa is synchronous, so freeipa will also hang until this returns. I don't think this is a good idea. Somewhere it should bbe converted to async. Most probably around RangerCloudIdentityService#setAzureCloudIdentityMapping", "author": "lacikaaa", "createdAt": "2020-06-30T10:30:14Z", "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/ClouderaManagerRangerUtil.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.ClustersResourceApi;\n+import com.cloudera.api.swagger.RoleCommandsResourceApi;\n+import com.cloudera.api.swagger.RolesResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiBulkCommandList;\n+import com.cloudera.api.swagger.model.ApiClusterList;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiConfig;\n+import com.cloudera.api.swagger.model.ApiConfigList;\n+import com.cloudera.api.swagger.model.ApiRole;\n+import com.cloudera.api.swagger.model.ApiRoleNameList;\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Joiner.MapJoiner;\n+import com.google.common.collect.ImmutableSortedMap;\n+import com.google.common.collect.Iterables;\n+\n+import com.sequenceiq.cloudbreak.cm.client.retry.ClouderaManagerApiFactory;\n+import com.sequenceiq.datalake.controller.exception.RangerCloudIdentitySyncException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public class ClouderaManagerRangerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerRangerUtil.class);\n+\n+    private static final String RANGER_SERVICE_NAME = \"ranger\";\n+\n+    private static final String RANGER_USER_SYNC_ROLE_TYPE = \"RANGER_USERSYNC\";\n+\n+    private static final String AZURE_USER_MAPPING = \"ranger_usersync_azure_user_mapping\";\n+\n+    private static final String AZURE_GROUP_MAPPING = \"ranger_usersync_azure_group_mapping\";\n+\n+    private static final MapJoiner CLOUD_IDENTITY_CONFIG_MAP_JOINER =\n+            Joiner.on(\";\").withKeyValueSeparator(\"=\");\n+\n+    @Inject\n+    private ClouderaManagerProxiedClientFactory clouderaManagerProxiedClientFactory;\n+\n+    @Inject\n+    private ClouderaManagerApiFactory clouderaManagerApiFactory;\n+\n+    private String getClusterName(ApiClient client) throws ApiException {\n+        ClustersResourceApi clustersResource = clouderaManagerApiFactory.getClustersResourceApi(client);\n+        ApiClusterList clusterList = clustersResource.readClusters(null, null);\n+        return Iterables.getOnlyElement(clusterList.getItems()).getName();\n+    }\n+\n+    private String getRangerUserSyncRoleName(ApiClient client, String clusterName) throws ApiException {\n+        RolesResourceApi rolesResourceApi = clouderaManagerApiFactory.getRolesResourceApi(client);\n+        List<ApiRole> apiRoleList =  rolesResourceApi.readRoles(clusterName, RANGER_SERVICE_NAME, null, null)\n+                .getItems()\n+                .stream()\n+                .filter(apiRole -> apiRole.getType().equals(RANGER_USER_SYNC_ROLE_TYPE))\n+                .collect(Collectors.toList());\n+        return Iterables.getOnlyElement(apiRoleList).getName();\n+    }\n+\n+    private ApiConfig newCloudIdentityConfig(String configName, Map<String, String> configValues) {\n+        // NOTE: We sort the configs first. This isn't really necessary but is more consistent.\n+        ImmutableSortedMap<String, String> configValuesSorted = ImmutableSortedMap.copyOf(configValues);\n+        ApiConfig config = new ApiConfig();\n+        config.setName(configName);\n+        config.setValue(CLOUD_IDENTITY_CONFIG_MAP_JOINER.join(configValuesSorted));\n+        return config;\n+    }\n+\n+    public void triggerRoleRefresh(ApiClient client, String clusterName, String serviceName, String roleName) {\n+        LOGGER.info(\"Attempting to trigger role refresh on clusterName = {}, serviceName = {}, roleName = {}\", clusterName, serviceName, roleName);\n+        ApiRoleNameList roleNameList = new ApiRoleNameList();\n+        roleNameList.addItemsItem(roleName);\n+        RoleCommandsResourceApi roleCommandsResourceApi = clouderaManagerApiFactory.getRoleCommandsResourceApi(client);\n+        try {\n+            ApiBulkCommandList bulkResponse = roleCommandsResourceApi.refreshCommand(clusterName, serviceName, roleNameList);", "originalCommit": "d840e6cf1a31933420365a228d672675691fa93c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY3MDI4Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447670283", "bodyText": "Good point, it might be better to do role refresh in a flow.", "author": "sodre90", "createdAt": "2020-06-30T13:12:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4MTM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzkyODU5Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447928596", "bodyText": "This just triggers role refresh, it doesn't wait around for the role refresh to succeed, so fms won't hang. I somewhat described this in the commit description. So in a follow up commit we'll want to take the ApiCommand response and poll the status of the command. So the async part will come in a follow up commit (I've discussed with Mark and David and we weren't considering using flow, but maybe we should).", "author": "aarman-cloudera", "createdAt": "2020-06-30T19:29:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4MTM4Mg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk0OTE5OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447949198", "bodyText": "The actual activity is tracked in CM. I don't think we even need a poller in the datalake service and can just let the FMS poll the datalake service. We can add a poller if we have a use-case where the datalake service needs to push the completion status to another service.", "author": "handavid", "createdAt": "2020-06-30T20:08:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4MTM4Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4MjI2MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447582261", "bodyText": "should be reversed: RANGER_USER_SYNC_ROLE_TYPE.equals(apiRole.getType())", "author": "lacikaaa", "createdAt": "2020-06-30T10:31:57Z", "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/ClouderaManagerRangerUtil.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.ClustersResourceApi;\n+import com.cloudera.api.swagger.RoleCommandsResourceApi;\n+import com.cloudera.api.swagger.RolesResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiBulkCommandList;\n+import com.cloudera.api.swagger.model.ApiClusterList;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiConfig;\n+import com.cloudera.api.swagger.model.ApiConfigList;\n+import com.cloudera.api.swagger.model.ApiRole;\n+import com.cloudera.api.swagger.model.ApiRoleNameList;\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Joiner.MapJoiner;\n+import com.google.common.collect.ImmutableSortedMap;\n+import com.google.common.collect.Iterables;\n+\n+import com.sequenceiq.cloudbreak.cm.client.retry.ClouderaManagerApiFactory;\n+import com.sequenceiq.datalake.controller.exception.RangerCloudIdentitySyncException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public class ClouderaManagerRangerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerRangerUtil.class);\n+\n+    private static final String RANGER_SERVICE_NAME = \"ranger\";\n+\n+    private static final String RANGER_USER_SYNC_ROLE_TYPE = \"RANGER_USERSYNC\";\n+\n+    private static final String AZURE_USER_MAPPING = \"ranger_usersync_azure_user_mapping\";\n+\n+    private static final String AZURE_GROUP_MAPPING = \"ranger_usersync_azure_group_mapping\";\n+\n+    private static final MapJoiner CLOUD_IDENTITY_CONFIG_MAP_JOINER =\n+            Joiner.on(\";\").withKeyValueSeparator(\"=\");\n+\n+    @Inject\n+    private ClouderaManagerProxiedClientFactory clouderaManagerProxiedClientFactory;\n+\n+    @Inject\n+    private ClouderaManagerApiFactory clouderaManagerApiFactory;\n+\n+    private String getClusterName(ApiClient client) throws ApiException {\n+        ClustersResourceApi clustersResource = clouderaManagerApiFactory.getClustersResourceApi(client);\n+        ApiClusterList clusterList = clustersResource.readClusters(null, null);\n+        return Iterables.getOnlyElement(clusterList.getItems()).getName();\n+    }\n+\n+    private String getRangerUserSyncRoleName(ApiClient client, String clusterName) throws ApiException {\n+        RolesResourceApi rolesResourceApi = clouderaManagerApiFactory.getRolesResourceApi(client);\n+        List<ApiRole> apiRoleList =  rolesResourceApi.readRoles(clusterName, RANGER_SERVICE_NAME, null, null)\n+                .getItems()\n+                .stream()\n+                .filter(apiRole -> apiRole.getType().equals(RANGER_USER_SYNC_ROLE_TYPE))", "originalCommit": "d840e6cf1a31933420365a228d672675691fa93c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4NDQyMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447584420", "bodyText": "log would be nice here", "author": "lacikaaa", "createdAt": "2020-06-30T10:35:53Z", "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/ClouderaManagerRangerUtil.java", "diffHunk": "@@ -0,0 +1,123 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.ClustersResourceApi;\n+import com.cloudera.api.swagger.RoleCommandsResourceApi;\n+import com.cloudera.api.swagger.RolesResourceApi;\n+import com.cloudera.api.swagger.client.ApiClient;\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.cloudera.api.swagger.model.ApiBulkCommandList;\n+import com.cloudera.api.swagger.model.ApiClusterList;\n+import com.cloudera.api.swagger.model.ApiCommand;\n+import com.cloudera.api.swagger.model.ApiConfig;\n+import com.cloudera.api.swagger.model.ApiConfigList;\n+import com.cloudera.api.swagger.model.ApiRole;\n+import com.cloudera.api.swagger.model.ApiRoleNameList;\n+import com.google.common.base.Joiner;\n+import com.google.common.base.Joiner.MapJoiner;\n+import com.google.common.collect.ImmutableSortedMap;\n+import com.google.common.collect.Iterables;\n+\n+import com.sequenceiq.cloudbreak.cm.client.retry.ClouderaManagerApiFactory;\n+import com.sequenceiq.datalake.controller.exception.RangerCloudIdentitySyncException;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public class ClouderaManagerRangerUtil {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(ClouderaManagerRangerUtil.class);\n+\n+    private static final String RANGER_SERVICE_NAME = \"ranger\";\n+\n+    private static final String RANGER_USER_SYNC_ROLE_TYPE = \"RANGER_USERSYNC\";\n+\n+    private static final String AZURE_USER_MAPPING = \"ranger_usersync_azure_user_mapping\";\n+\n+    private static final String AZURE_GROUP_MAPPING = \"ranger_usersync_azure_group_mapping\";\n+\n+    private static final MapJoiner CLOUD_IDENTITY_CONFIG_MAP_JOINER =\n+            Joiner.on(\";\").withKeyValueSeparator(\"=\");\n+\n+    @Inject\n+    private ClouderaManagerProxiedClientFactory clouderaManagerProxiedClientFactory;\n+\n+    @Inject\n+    private ClouderaManagerApiFactory clouderaManagerApiFactory;\n+\n+    private String getClusterName(ApiClient client) throws ApiException {\n+        ClustersResourceApi clustersResource = clouderaManagerApiFactory.getClustersResourceApi(client);\n+        ApiClusterList clusterList = clustersResource.readClusters(null, null);\n+        return Iterables.getOnlyElement(clusterList.getItems()).getName();\n+    }\n+\n+    private String getRangerUserSyncRoleName(ApiClient client, String clusterName) throws ApiException {\n+        RolesResourceApi rolesResourceApi = clouderaManagerApiFactory.getRolesResourceApi(client);\n+        List<ApiRole> apiRoleList =  rolesResourceApi.readRoles(clusterName, RANGER_SERVICE_NAME, null, null)\n+                .getItems()\n+                .stream()\n+                .filter(apiRole -> apiRole.getType().equals(RANGER_USER_SYNC_ROLE_TYPE))\n+                .collect(Collectors.toList());\n+        return Iterables.getOnlyElement(apiRoleList).getName();\n+    }\n+\n+    private ApiConfig newCloudIdentityConfig(String configName, Map<String, String> configValues) {\n+        // NOTE: We sort the configs first. This isn't really necessary but is more consistent.\n+        ImmutableSortedMap<String, String> configValuesSorted = ImmutableSortedMap.copyOf(configValues);\n+        ApiConfig config = new ApiConfig();\n+        config.setName(configName);\n+        config.setValue(CLOUD_IDENTITY_CONFIG_MAP_JOINER.join(configValuesSorted));\n+        return config;\n+    }\n+\n+    public void triggerRoleRefresh(ApiClient client, String clusterName, String serviceName, String roleName) {\n+        LOGGER.info(\"Attempting to trigger role refresh on clusterName = {}, serviceName = {}, roleName = {}\", clusterName, serviceName, roleName);\n+        ApiRoleNameList roleNameList = new ApiRoleNameList();\n+        roleNameList.addItemsItem(roleName);\n+        RoleCommandsResourceApi roleCommandsResourceApi = clouderaManagerApiFactory.getRoleCommandsResourceApi(client);\n+        try {\n+            ApiBulkCommandList bulkResponse = roleCommandsResourceApi.refreshCommand(clusterName, serviceName, roleNameList);\n+            ApiCommand response = Iterables.getOnlyElement(bulkResponse.getItems());\n+            LOGGER.info(\"ApiCommand response for role refresh = {}\", response);\n+            if (response != null && (response.getActive() || response.getSuccess())) {\n+                LOGGER.info(\"Successfully triggered role refresh\");\n+            } else {\n+                LOGGER.debug(\"Failed to trigger role refresh\");\n+                throw new RangerCloudIdentitySyncException(\"Role refresh was not successfully trigerred\");\n+            }\n+        } catch (ApiException e) {\n+            throw new RangerCloudIdentitySyncException(\"Encountered ApiException on role refresh\", e);", "originalCommit": "d840e6cf1a31933420365a228d672675691fa93c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4NDU5MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447584590", "bodyText": "log would be nice here", "author": "lacikaaa", "createdAt": "2020-06-30T10:36:14Z", "path": "datalake/src/main/java/com/sequenceiq/datalake/cm/RangerCloudIdentityService.java", "diffHunk": "@@ -0,0 +1,43 @@\n+package com.sequenceiq.datalake.cm;\n+\n+import com.cloudera.api.swagger.client.ApiException;\n+import com.sequenceiq.datalake.controller.exception.RangerCloudIdentitySyncException;\n+import com.sequenceiq.datalake.entity.SdxCluster;\n+import com.sequenceiq.datalake.service.sdx.SdxService;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+@Service\n+public class RangerCloudIdentityService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RangerCloudIdentityService.class);\n+\n+    @Inject\n+    private ClouderaManagerRangerUtil clouderaManagerRangerUtil;\n+\n+    @Inject\n+    private SdxService sdxService;\n+\n+    private void setAzureCloudIdentityMapping(SdxCluster sdxCluster, Map<String, String> azureUserMapping, Map<String, String> azureGroupMapping) {\n+        String stackCrn = sdxCluster.getStackCrn();\n+        LOGGER.info(\"Updating azure cloud id mappings for datalake stack crn = {}\", stackCrn);\n+        try {\n+            clouderaManagerRangerUtil.setAzureCloudIdentityMapping(stackCrn, azureUserMapping, azureGroupMapping);\n+        } catch (ApiException e) {\n+            throw new RangerCloudIdentitySyncException(\"Encountered api exception\", e);", "originalCommit": "d840e6cf1a31933420365a228d672675691fa93c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4NTg4NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447585884", "bodyText": "there is no exception mapper for this. is it on purpose?", "author": "lacikaaa", "createdAt": "2020-06-30T10:38:41Z", "path": "datalake/src/main/java/com/sequenceiq/datalake/controller/exception/RangerCloudIdentitySyncException.java", "diffHunk": "@@ -0,0 +1,12 @@\n+package com.sequenceiq.datalake.controller.exception;\n+\n+public class RangerCloudIdentitySyncException extends RuntimeException {", "originalCommit": "d840e6cf1a31933420365a228d672675691fa93c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDExNDA5MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r450114090", "bodyText": "So the semantics of the exception might change once we add polling of the refresh command in follow on commit. So I think we can hold off on an exception mapper until then.", "author": "aarman-cloudera", "createdAt": "2020-07-06T09:56:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU4NTg4NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5MTAwMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447591001", "bodyText": "@NotNull is missing for both fields based on your comment", "author": "lacikaaa", "createdAt": "2020-06-30T10:48:12Z", "path": "datalake-api/src/main/java/com/sequenceiq/sdx/api/model/SetRangerCloudIdentityMappingRequest.java", "diffHunk": "@@ -0,0 +1,27 @@\n+package com.sequenceiq.sdx.api.model;\n+\n+import java.util.Map;\n+\n+public class SetRangerCloudIdentityMappingRequest {\n+\n+    private Map<String, String> azureUserMapping;\n+\n+    private Map<String, String> azureGroupMapping;", "originalCommit": "d840e6cf1a31933420365a228d672675691fa93c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5MTEzNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447591137", "bodyText": "@ValidCrn for envCrn and @NotNull and @Valid for SetRangerCloudIdentityMappingRequest", "author": "lacikaaa", "createdAt": "2020-06-30T10:48:29Z", "path": "datalake-api/src/main/java/com/sequenceiq/sdx/api/endpoint/SdxEndpoint.java", "diffHunk": "@@ -196,4 +197,11 @@ SdxDatabaseBackupStatusResponse getBackupDatabaseStatusByName(@PathParam(\"name\")\n     @ApiOperation(value = \"Get the status of datalake database restore operation\", produces = MediaType.APPLICATION_JSON, nickname = \"restoreDatabaseStatus\")\n     SdxDatabaseRestoreStatusResponse getRestoreDatabaseStatusByName(@PathParam(\"name\") String name,\n             @QueryParam(\"operationId\") String operationId);\n+\n+    @POST\n+    @Path(\"/envcrn/{envCrn}/ranger_cloud_identity_mapping\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = \"set ranger cloud identity mapping\", produces = MediaType.APPLICATION_JSON, nickname = \"setRangerCloudIdentityMapping\")\n+    void setRangerCloudIdentityMapping(@PathParam(\"envCrn\") String envCrn, SetRangerCloudIdentityMappingRequest request);", "originalCommit": "d840e6cf1a31933420365a228d672675691fa93c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5NTA2Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447595066", "bodyText": "log before this would be nice", "author": "lacikaaa", "createdAt": "2020-06-30T10:55:53Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/CloudIdentitySyncService.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.CloudIdentity;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Iterables;\n+import com.sequenceiq.cloudbreak.common.mappable.CloudPlatform;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.FmsUser;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UmsUsersState;\n+import com.sequenceiq.sdx.api.endpoint.SdxEndpoint;\n+import com.sequenceiq.sdx.api.model.SetRangerCloudIdentityMappingRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+\n+@Service\n+public class CloudIdentitySyncService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CloudIdentitySyncService.class);\n+\n+    @Inject\n+    private SdxEndpoint sdxEndpoint;\n+\n+    public void syncCloudIdentites(Stack stack, UmsUsersState umsUsersState, BiConsumer<String, String> warnings) {\n+        if (CloudPlatform.AZURE.equalsIgnoreCase(stack.getCloudPlatform())) {", "originalCommit": "d840e6cf1a31933420365a228d672675691fa93c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5NTI5NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447595295", "bodyText": "we should log here with the request", "author": "lacikaaa", "createdAt": "2020-06-30T10:56:22Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/CloudIdentitySyncService.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.CloudIdentity;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Iterables;\n+import com.sequenceiq.cloudbreak.common.mappable.CloudPlatform;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.FmsUser;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UmsUsersState;\n+import com.sequenceiq.sdx.api.endpoint.SdxEndpoint;\n+import com.sequenceiq.sdx.api.model.SetRangerCloudIdentityMappingRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+\n+@Service\n+public class CloudIdentitySyncService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CloudIdentitySyncService.class);\n+\n+    @Inject\n+    private SdxEndpoint sdxEndpoint;\n+\n+    public void syncCloudIdentites(Stack stack, UmsUsersState umsUsersState, BiConsumer<String, String> warnings) {\n+        if (CloudPlatform.AZURE.equalsIgnoreCase(stack.getCloudPlatform())) {\n+            syncAzureObjectIds(stack, umsUsersState, warnings);\n+        }\n+    }\n+\n+    private void syncAzureObjectIds(Stack stack, UmsUsersState umsUsersState, BiConsumer<String, String> warnings) {\n+        String envCrn = stack.getEnvironmentCrn();\n+        LOGGER.info(\"Syncing Azure Object IDs for environment {}\", envCrn);\n+\n+        Map<String, List<CloudIdentity>> userCloudIdentites = getUserCloudIdentitiesToSync(umsUsersState);\n+\n+        Map<String, String> userToAzureObjectIdMap = getAzureObjectIdMap(userCloudIdentites);\n+        Map<String, String> groupToAzureObjectIdMap = getAzureObjectIdMap(umsUsersState.getGroupToCloudIdentityMap());\n+\n+        SetRangerCloudIdentityMappingRequest setRangerCloudIdentityMappingRequest = new SetRangerCloudIdentityMappingRequest();\n+        setRangerCloudIdentityMappingRequest.setAzureUserMapping(userToAzureObjectIdMap);\n+        setRangerCloudIdentityMappingRequest.setAzureGroupMapping(groupToAzureObjectIdMap);\n+        try {\n+            // TODO The SDX endpoint currently sets the config and triggers refresh. The SDX endpoint should also be updated\n+            //      to allow polling the status of the refresh.\n+            sdxEndpoint.setRangerCloudIdentityMapping(envCrn, setRangerCloudIdentityMappingRequest);", "originalCommit": "d840e6cf1a31933420365a228d672675691fa93c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzU5ODczOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447598739", "bodyText": "some log here and in getOptionalAzureObjectId might be useful to investigate if something is not as desired", "author": "lacikaaa", "createdAt": "2020-06-30T11:03:19Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/CloudIdentitySyncService.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.CloudIdentity;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Iterables;\n+import com.sequenceiq.cloudbreak.common.mappable.CloudPlatform;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.FmsUser;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UmsUsersState;\n+import com.sequenceiq.sdx.api.endpoint.SdxEndpoint;\n+import com.sequenceiq.sdx.api.model.SetRangerCloudIdentityMappingRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+\n+@Service\n+public class CloudIdentitySyncService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CloudIdentitySyncService.class);\n+\n+    @Inject\n+    private SdxEndpoint sdxEndpoint;\n+\n+    public void syncCloudIdentites(Stack stack, UmsUsersState umsUsersState, BiConsumer<String, String> warnings) {\n+        if (CloudPlatform.AZURE.equalsIgnoreCase(stack.getCloudPlatform())) {\n+            syncAzureObjectIds(stack, umsUsersState, warnings);\n+        }\n+    }\n+\n+    private void syncAzureObjectIds(Stack stack, UmsUsersState umsUsersState, BiConsumer<String, String> warnings) {\n+        String envCrn = stack.getEnvironmentCrn();\n+        LOGGER.info(\"Syncing Azure Object IDs for environment {}\", envCrn);\n+\n+        Map<String, List<CloudIdentity>> userCloudIdentites = getUserCloudIdentitiesToSync(umsUsersState);\n+\n+        Map<String, String> userToAzureObjectIdMap = getAzureObjectIdMap(userCloudIdentites);\n+        Map<String, String> groupToAzureObjectIdMap = getAzureObjectIdMap(umsUsersState.getGroupToCloudIdentityMap());\n+\n+        SetRangerCloudIdentityMappingRequest setRangerCloudIdentityMappingRequest = new SetRangerCloudIdentityMappingRequest();\n+        setRangerCloudIdentityMappingRequest.setAzureUserMapping(userToAzureObjectIdMap);\n+        setRangerCloudIdentityMappingRequest.setAzureGroupMapping(groupToAzureObjectIdMap);\n+        try {\n+            // TODO The SDX endpoint currently sets the config and triggers refresh. The SDX endpoint should also be updated\n+            //      to allow polling the status of the refresh.\n+            sdxEndpoint.setRangerCloudIdentityMapping(envCrn, setRangerCloudIdentityMappingRequest);\n+        } catch (Exception e) {\n+            LOGGER.warn(\"Failed to set cloud identity mapping for environment {}\", envCrn, e);\n+            warnings.accept(envCrn, \"Failed to set cloud identity mapping\");\n+        }\n+    }\n+\n+    private Map<String, String> getAzureObjectIdMap(Map<String, List<CloudIdentity>> cloudIdentityMapping) {", "originalCommit": "d840e6cf1a31933420365a228d672675691fa93c", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwMDIzNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447600237", "bodyText": "shouldn't we handle this exception somewhere? or is it ok if UserSyncService#internalSynchronizeStack handles it?\ncc @handavid", "author": "lacikaaa", "createdAt": "2020-06-30T11:06:29Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/CloudIdentitySyncService.java", "diffHunk": "@@ -0,0 +1,99 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.CloudIdentity;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.common.collect.Iterables;\n+import com.sequenceiq.cloudbreak.common.mappable.CloudPlatform;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.FmsUser;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UmsUsersState;\n+import com.sequenceiq.sdx.api.endpoint.SdxEndpoint;\n+import com.sequenceiq.sdx.api.model.SetRangerCloudIdentityMappingRequest;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.BiConsumer;\n+import java.util.stream.Collectors;\n+\n+@Service\n+public class CloudIdentitySyncService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(CloudIdentitySyncService.class);\n+\n+    @Inject\n+    private SdxEndpoint sdxEndpoint;\n+\n+    public void syncCloudIdentites(Stack stack, UmsUsersState umsUsersState, BiConsumer<String, String> warnings) {\n+        if (CloudPlatform.AZURE.equalsIgnoreCase(stack.getCloudPlatform())) {\n+            syncAzureObjectIds(stack, umsUsersState, warnings);\n+        }\n+    }\n+\n+    private void syncAzureObjectIds(Stack stack, UmsUsersState umsUsersState, BiConsumer<String, String> warnings) {\n+        String envCrn = stack.getEnvironmentCrn();\n+        LOGGER.info(\"Syncing Azure Object IDs for environment {}\", envCrn);\n+\n+        Map<String, List<CloudIdentity>> userCloudIdentites = getUserCloudIdentitiesToSync(umsUsersState);\n+\n+        Map<String, String> userToAzureObjectIdMap = getAzureObjectIdMap(userCloudIdentites);\n+        Map<String, String> groupToAzureObjectIdMap = getAzureObjectIdMap(umsUsersState.getGroupToCloudIdentityMap());\n+\n+        SetRangerCloudIdentityMappingRequest setRangerCloudIdentityMappingRequest = new SetRangerCloudIdentityMappingRequest();\n+        setRangerCloudIdentityMappingRequest.setAzureUserMapping(userToAzureObjectIdMap);\n+        setRangerCloudIdentityMappingRequest.setAzureGroupMapping(groupToAzureObjectIdMap);\n+        try {\n+            // TODO The SDX endpoint currently sets the config and triggers refresh. The SDX endpoint should also be updated\n+            //      to allow polling the status of the refresh.\n+            sdxEndpoint.setRangerCloudIdentityMapping(envCrn, setRangerCloudIdentityMappingRequest);\n+        } catch (Exception e) {\n+            LOGGER.warn(\"Failed to set cloud identity mapping for environment {}\", envCrn, e);\n+            warnings.accept(envCrn, \"Failed to set cloud identity mapping\");\n+        }\n+    }\n+\n+    private Map<String, String> getAzureObjectIdMap(Map<String, List<CloudIdentity>> cloudIdentityMapping) {\n+        ImmutableMap.Builder<String, String> azureObjectIdMap = ImmutableMap.builder();\n+        cloudIdentityMapping.forEach((key, cloudIdentities) -> {\n+            Optional<String> azureObjectId = getOptionalAzureObjectId(cloudIdentities);\n+            if (azureObjectId.isPresent()) {\n+                azureObjectIdMap.put(key, azureObjectId.get());\n+            }\n+        });\n+        return azureObjectIdMap.build();\n+    }\n+\n+    private Optional<String> getOptionalAzureObjectId(List<CloudIdentity> cloudIdentities) {\n+        List<CloudIdentity> azureCloudIdentities = cloudIdentities.stream()\n+                .filter(cloudIdentity -> cloudIdentity.getCloudIdentityDomain().hasAzureCloudIdentityDomain())\n+                .collect(Collectors.toList());\n+        if (azureCloudIdentities.isEmpty()) {\n+            return Optional.empty();\n+        } else if (azureCloudIdentities.size() > 1) {\n+            throw new IllegalStateException(String.format(\"List contains multiple azure cloud identities = %s\", cloudIdentities));", "originalCommit": "d840e6cf1a31933420365a228d672675691fa93c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk1MTc2OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447951769", "bodyText": "good point. I think we can expand the try block up on line 50 to start on line 42 instead. That will catch this exception and register a warning.", "author": "handavid", "createdAt": "2020-06-30T20:14:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwMDIzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk2MzkzMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447963931", "bodyText": "I don't think we need to fail super cleanly in this situation. This is a very unexpected scenario.", "author": "aarman-cloudera", "createdAt": "2020-06-30T20:37:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwMDIzNw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0Nzk4NTAzNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r447985035", "bodyText": "That said, I've taken David's advice.", "author": "aarman-cloudera", "createdAt": "2020-06-30T21:18:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzYwMDIzNw=="}], "type": "inlineReview"}, {"oid": "4c0bbac5b448e56b93dc0053beadf0261e05dc33", "url": "https://github.com/hortonworks/cloudbreak/commit/4c0bbac5b448e56b93dc0053beadf0261e05dc33", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm", "committedDate": "2020-06-30T21:05:50Z", "type": "forcePushed"}, {"oid": "eac154cbbdaaf9a5d4e58a85f475d173ac61f966", "url": "https://github.com/hortonworks/cloudbreak/commit/eac154cbbdaaf9a5d4e58a85f475d173ac61f966", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm", "committedDate": "2020-06-30T21:12:23Z", "type": "forcePushed"}, {"oid": "bc83bee2b7db2c76baa646bda439d57e05466af8", "url": "https://github.com/hortonworks/cloudbreak/commit/bc83bee2b7db2c76baa646bda439d57e05466af8", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm", "committedDate": "2020-07-06T07:53:57Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ1MDA4ODk3Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8230#discussion_r450088976", "bodyText": "I think we should have an env var to enable and disable the entitlement. See a couple of lines above.", "author": "keyki", "createdAt": "2020-07-06T09:12:09Z", "path": "mock-caas/src/main/java/com/sequenceiq/caas/grpc/service/auth/MockUserManagementService.java", "diffHunk": "@@ -531,6 +533,7 @@ public void getAccount(GetAccountRequest request, StreamObserver<GetAccountRespo\n                                 .setWorkloadSubdomain(ACCOUNT_SUBDOMAIN)\n                                 .addEntitlements(createEntitlement(CDP_AZURE))\n                                 .addEntitlements(createEntitlement(CDP_AUTOMATIC_USERSYNC_POLLER))\n+                                .addEntitlements(createEntitlement(CDP_CLOUD_IDENTITY_MAPPING))", "originalCommit": "bc83bee2b7db2c76baa646bda439d57e05466af8", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "81806b0e47838eaf821878c8b317faaa98cc1ef5", "url": "https://github.com/hortonworks/cloudbreak/commit/81806b0e47838eaf821878c8b317faaa98cc1ef5", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm", "committedDate": "2020-07-06T09:23:43Z", "type": "forcePushed"}, {"oid": "3162c470c012022d99c8071f0f68237d28c15cdc", "url": "https://github.com/hortonworks/cloudbreak/commit/3162c470c012022d99c8071f0f68237d28c15cdc", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm", "committedDate": "2020-07-06T09:58:21Z", "type": "forcePushed"}, {"oid": "33ce081ce1e5eddbdfeaef5bf841ca03c4c13cd2", "url": "https://github.com/hortonworks/cloudbreak/commit/33ce081ce1e5eddbdfeaef5bf841ca03c4c13cd2", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm", "committedDate": "2020-07-06T19:27:45Z", "type": "commit"}, {"oid": "33ce081ce1e5eddbdfeaef5bf841ca03c4c13cd2", "url": "https://github.com/hortonworks/cloudbreak/commit/33ce081ce1e5eddbdfeaef5bf841ca03c4c13cd2", "message": "CDPCP-1941. Sync azure object id mapping during user sync\n\nAzure cloud identity information (Azure OID mapping) are now synced from\nUMS into all appropriate datalake instances. At high level the\nimplementation is:\n\n- SDX service has a new endpoint that allows setting azure ranger\nconfigs (azure user and group mappings). The SDX service will make the\nnecessary CM api call (through cluster proxy) to set the config and\ntrigger a role refresh.\n\n- The FMS user sync service will pull the Azure Object IDs (cloud\nidentity mapping) from UMS and call the new SDX endpoint to set the\nconfigs.\n\nFollow on work items include:\n- Poll the status of the refresh after trigerring it\n- Individual user level and group level sync of OIDs\n- Moving some of the CM logic into cluster-cm and client-cm", "committedDate": "2020-07-06T19:27:45Z", "type": "forcePushed"}]}