{"pr_number": 8081, "pr_title": "CB-7096: Add downscaling FreeIPA for recovery of non-CRL master nodes", "pr_createdAt": "2020-05-17T13:23:54Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/8081", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA2Njk2MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r428066960", "bodyText": "I think this should be pushed down a bit. The only place we expect this is when we collect the health, but if we want to retry we might handle it in FreeIpaHealthDetailsService", "author": "lacikaaa", "createdAt": "2020-05-20T14:39:41Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/controller/FreeIpaV1Controller.java", "diffHunk": "@@ -194,6 +199,17 @@ public void rebootInstances(@Valid RebootInstancesRequest request) {\n         rebootInstancesService.rebootInstances(accountId, request);\n     }\n \n+    @Override\n+    @CheckPermissionByAccount(action = AuthorizationResourceAction.ENVIRONMENT_WRITE)\n+    @Retryable(value = RetryableFreeIpaClientException.class,", "originalCommit": "7c1663628f245cb9484f35ca82b4d0e8d4bc93a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODMzMDgyMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r428330822", "bodyText": "I agree the only place that it matters is in the health checks. I would rather not push it down because otherwise, in the future I think it may lead to multilevel retries. I suspect the health service is going to be called by code that we either don't want to retry or that we don't want to retry at two levels.", "author": "jamisonbennett", "createdAt": "2020-05-20T21:56:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA2Njk2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwNDMxOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r433904318", "bodyText": "I would say, we shouldn't retry this at all. The use-case would be here that the user push a button on the UI or issue a CLI command to initiate repair, and if it fails then he can retry manually. No reason to keep retrying in the background and keep the user waiting. What do you think?", "author": "lacikaaa", "createdAt": "2020-06-02T14:06:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA2Njk2MA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDY4MzMyNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r434683327", "bodyText": "ok, I removed the retry here and also in the reboot since its basically the same situation.", "author": "jamisonbennett", "createdAt": "2020-06-03T16:05:05Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA2Njk2MA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA2ODQ0MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r428068441", "bodyText": "missing an underscore before EVENT", "author": "lacikaaa", "createdAt": "2020-05-20T14:41:33Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/downscale/DownscaleFlowEvent.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package com.sequenceiq.freeipa.flow.freeipa.downscale;\n+\n+import com.sequenceiq.cloudbreak.cloud.event.resource.RemoveInstanceResult;\n+import com.sequenceiq.flow.core.FlowEvent;\n+import com.sequenceiq.flow.event.EventSelectorUtil;\n+import com.sequenceiq.freeipa.flow.freeipa.cleanup.event.cert.RevokeCertsResponse;\n+import com.sequenceiq.freeipa.flow.freeipa.cleanup.event.dns.RemoveDnsResponse;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.DownscaleFailureEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.removehosts.RemoveHostsFromOrchestrationSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.removeserver.RemoveServersResponse;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.stoptelemetry.StopTelemetryResponse;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationFailed;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationSuccess;\n+\n+public enum DownscaleFlowEvent implements FlowEvent {\n+    DOWNSCALE_EVENT(\"DOWNSCALE_EVENT\"),\n+    STARTING_DOWNSCALE_FINISHED_EVENT(\"STARTING_DOWNSCALE_FINISHED_EVENT\"),\n+    CLUSTERPROXY_REGISTRATION_FINISHED_EVENT(EventSelectorUtil.selector(ClusterProxyUpdateRegistrationSuccess.class)),\n+    CLUSTERPROXY_REGISTRATION_FAILED_EVENT(EventSelectorUtil.selector(ClusterProxyUpdateRegistrationFailed.class)),\n+    STOP_TELEMETRY_FINISHED_EVENT(EventSelectorUtil.selector(StopTelemetryResponse.class)),\n+    REMOVE_INSTANCES_FINISHED_EVENT(EventSelectorUtil.selector(RemoveInstanceResult.class)),\n+    REMOVE_INSTANCES_FAILED_EVENT(EventSelectorUtil.failureSelector(RemoveInstanceResult.class)),\n+    REMOVE_SERVERS_FINISHED_EVENT(EventSelectorUtil.selector(RemoveServersResponse.class)),\n+    REMOVE_SERVERS_FAILED_EVENT(EventSelectorUtil.failureSelector(RemoveServersResponse.class)),\n+    REVOKE_CERTS_FINISHED_EVENT(EventSelectorUtil.selector(RevokeCertsResponse.class)),\n+    REVOKE_CERTS_FAILED_EVENT(EventSelectorUtil.failureSelector(RevokeCertsResponse.class)),\n+    REMOVE_DNS_ENTRIES_FINISHED_EVENT(EventSelectorUtil.selector(RemoveDnsResponse.class)),\n+    REMOVE_DNS_FAILED_EVENT(EventSelectorUtil.failureSelector(RemoveDnsResponse.class)),\n+    UPDATE_METADATA_FINISHED_EVENT(\"UPDATE_METADATA_FINISHED_EVENT\"),\n+    REMOVE_HOSTS_FROM_ORCHESTRATION_FINISHED_EVENT(EventSelectorUtil.selector(RemoveHostsFromOrchestrationSuccess.class)),\n+    REMOVE_HOSTS_FROM_ORCHESTRATION_FAILED_EVENT(EventSelectorUtil.selector(DownscaleFailureEvent.class)),\n+    DOWNSCALE_FINISHED_EVENT(\"DOWNSCALE_FINISHED_EVENT\"),\n+    FINALIZED_EVENT(\"DOWNSCALE_FINALIZEDEVENT\"),", "originalCommit": "7c1663628f245cb9484f35ca82b4d0e8d4bc93a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA4MDI5NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r428080294", "bodyText": "I think you misused a bit this variables. It should be used like, if you know you need something later or multiple times in the following state, then you put it here, and get it later. So you should know when to set it, in which state/action. Trying to set it in every action, as you do it with adding this logic to context building, makes it loosing it's purpose. Also if you won't do this in every \"step\", only when you have to, we could avoid using instanceof.", "author": "lacikaaa", "createdAt": "2020-05-20T14:56:15Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/downscale/action/AbstractDownscaleAction.java", "diffHunk": "@@ -0,0 +1,138 @@\n+package com.sequenceiq.freeipa.flow.freeipa.downscale.action;\n+\n+import static com.sequenceiq.cloudbreak.cloud.model.Location.location;\n+import static com.sequenceiq.cloudbreak.cloud.model.Region.region;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.springframework.statemachine.StateContext;\n+\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudCredential;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n+import com.sequenceiq.cloudbreak.cloud.model.Location;\n+import com.sequenceiq.cloudbreak.common.event.Payload;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.flow.core.FlowParameters;\n+import com.sequenceiq.freeipa.converter.cloud.CredentialToCloudCredentialConverter;\n+import com.sequenceiq.freeipa.converter.cloud.StackToCloudStackConverter;\n+import com.sequenceiq.freeipa.entity.FreeIpa;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.DownscaleFlowEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.DownscaleState;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.FreeIpaDownscaleContext;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.DownscaleEvent;\n+import com.sequenceiq.freeipa.flow.stack.AbstractStackAction;\n+import com.sequenceiq.freeipa.flow.stack.StackFailureEvent;\n+import com.sequenceiq.freeipa.service.CredentialService;\n+import com.sequenceiq.freeipa.service.freeipa.FreeIpaService;\n+import com.sequenceiq.freeipa.service.stack.StackService;\n+\n+public abstract class AbstractDownscaleAction<P extends Payload> extends AbstractStackAction<DownscaleState, DownscaleFlowEvent, FreeIpaDownscaleContext, P> {\n+\n+    protected static final String INSTANCE_IDS = \"INSTANCE_IDS\";\n+\n+    protected static final String OPERATION_ID = \"OPERATION_ID\";\n+\n+    protected static final String HOSTS = \"DOWNSCALE_HOSTS\";\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private StackToCloudStackConverter cloudStackConverter;\n+\n+    @Inject\n+    private CredentialToCloudCredentialConverter credentialConverter;\n+\n+    @Inject\n+    private CredentialService credentialService;\n+\n+    @Inject\n+    private FreeIpaService freeIpaService;\n+\n+    protected AbstractDownscaleAction(Class<P> payloadClass) {\n+        super(payloadClass);\n+    }\n+\n+    @Override\n+    protected FreeIpaDownscaleContext createFlowContext(FlowParameters flowParameters, StateContext<DownscaleState, DownscaleFlowEvent> stateContext,\n+            P payload) {\n+        Stack stack = stackService.getByIdWithListsInTransaction(payload.getResourceId());\n+        MDCBuilder.buildMdcContext(stack);\n+        Location location = location(region(stack.getRegion()));\n+        CloudContext cloudContext = new CloudContext(stack.getId(), stack.getName(), stack.getCloudPlatform(), stack.getCloudPlatform(),\n+                location, stack.getOwner(), stack.getOwner(), stack.getAccountId());\n+        CloudCredential cloudCredential = credentialConverter.convert(credentialService.getCredentialByEnvCrn(stack.getEnvironmentCrn()));\n+        CloudStack cloudStack = cloudStackConverter.convert(stack);\n+        Map<Object, Object> variables = stateContext.getExtendedState().getVariables();\n+        List<String> instanceIds = extractInstanceIds(payload, variables);\n+        String operationId = extractOperationId(payload, variables);", "originalCommit": "7c1663628f245cb9484f35ca82b4d0e8d4bc93a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA4NDczNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r428084737", "bodyText": "like here, the AbstractDownscaleAction could have a method for getting the instanceIds from the variables, and not put it in the context, because now we have the same info available in 2 places", "author": "lacikaaa", "createdAt": "2020-05-20T15:01:31Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/downscale/action/FreeIpaDownscaleActions.java", "diffHunk": "@@ -0,0 +1,331 @@\n+package com.sequenceiq.freeipa.flow.freeipa.downscale.action;\n+\n+import static com.sequenceiq.freeipa.flow.freeipa.downscale.DownscaleFlowEvent.DOWNSCALE_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.downscale.DownscaleFlowEvent.FAIL_HANDLED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.downscale.DownscaleFlowEvent.STARTING_DOWNSCALE_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.downscale.DownscaleFlowEvent.UPDATE_METADATA_FINISHED_EVENT;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.StateContext;\n+import org.springframework.statemachine.action.Action;\n+\n+import com.sequenceiq.cloudbreak.cloud.event.resource.RemoveInstanceRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.resource.RemoveInstanceResult;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudInstance;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.flow.core.Flow;\n+import com.sequenceiq.flow.core.FlowParameters;\n+import com.sequenceiq.flow.core.PayloadConverter;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.DetailedStackStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.FailureDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.SuccessDetails;\n+import com.sequenceiq.freeipa.converter.cloud.InstanceMetaDataToCloudInstanceConverter;\n+import com.sequenceiq.freeipa.converter.cloud.ResourceToCloudResourceConverter;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.freeipa.cleanup.CleanupEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.cleanup.event.cert.RevokeCertsRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.cleanup.event.cert.RevokeCertsResponse;\n+import com.sequenceiq.freeipa.flow.freeipa.cleanup.event.dns.RemoveDnsRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.cleanup.event.dns.RemoveDnsResponse;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.DownscaleFlowEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.DownscaleState;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.FreeIpaDownscaleContext;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.FreeIpaDownscaleFailureContext;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.DownscaleEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.DownscaleFailureEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.removehosts.RemoveHostsFromOrchestrationRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.removehosts.RemoveHostsFromOrchestrationSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.removeserver.RemoveServersRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.removeserver.RemoveServersResponse;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.stoptelemetry.StopTelemetryRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.stoptelemetry.StopTelemetryResponse;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.failure.ClusterProxyUpdateRegistrationFailedToDownscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.failure.RemoveDnsResponseToDownscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.failure.RemoveHostsResponseToDownscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.failure.RemoveInstanceResultToDownscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.failure.RevokeCertsResponseToDownscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationSuccess;\n+import com.sequenceiq.freeipa.flow.stack.AbstractStackAction;\n+import com.sequenceiq.freeipa.flow.stack.StackEvent;\n+import com.sequenceiq.freeipa.flow.stack.termination.action.TerminationService;\n+import com.sequenceiq.freeipa.service.operation.OperationService;\n+import com.sequenceiq.freeipa.service.resource.ResourceService;\n+import com.sequenceiq.freeipa.service.stack.StackService;\n+import com.sequenceiq.freeipa.service.stack.StackUpdater;\n+\n+@Configuration\n+public class FreeIpaDownscaleActions {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FreeIpaDownscaleActions.class);\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    @Inject\n+    private InstanceMetaDataToCloudInstanceConverter instanceConverter;\n+\n+    @Inject\n+    private ResourceService resourceService;\n+\n+    @Inject\n+    private ResourceToCloudResourceConverter resourceConverter;\n+\n+    @Inject\n+    private TerminationService terminationService;\n+\n+    @Bean(name = \"STARTING_DOWNSCALE_STATE\")\n+    public Action<?, ?> startingDownscaleAction() {\n+        return new AbstractDownscaleAction<>(DownscaleEvent.class) {\n+            @Override\n+            protected void doExecute(FreeIpaDownscaleContext context, DownscaleEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                List<String> instanceIds = context.getInstanceIds();\n+                LOGGER.info(\"Starting downscale of stack {} instances [{}]\", stack.getId(), instanceIds);\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.DOWNSCALE_IN_PROGRESS, \"Starting downscale\");\n+                sendEvent(context, STARTING_DOWNSCALE_FINISHED_EVENT.selector(), new StackEvent(stack.getId()));\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"DOWNSCALE_CLUSTERPROXY_REGISTRATION_STATE\")\n+    public Action<?, ?> downscaleClusterProxyRegistrationAction() {\n+        return new AbstractDownscaleAction<>(StackEvent.class) {\n+            @Override\n+            protected void doExecute(FreeIpaDownscaleContext context, StackEvent payload, Map<Object, Object> variables) throws Exception {\n+                Stack stack = context.getStack();\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.DOWNSCALE_IN_PROGRESS, \"Updating cluster proxy registration.\");\n+                List<String> instanceIdsToRegister = stack.getNotDeletedInstanceMetaDataList().stream()\n+                        .map(InstanceMetaData::getInstanceId)\n+                        .filter(instanceId -> !context.getInstanceIds().contains(instanceId))", "originalCommit": "7c1663628f245cb9484f35ca82b4d0e8d4bc93a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyODA4NTM0NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r428085345", "bodyText": "I would just simply get the instanceIds from the event, and put into the variables here", "author": "lacikaaa", "createdAt": "2020-05-20T15:02:22Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/downscale/action/FreeIpaDownscaleActions.java", "diffHunk": "@@ -0,0 +1,331 @@\n+package com.sequenceiq.freeipa.flow.freeipa.downscale.action;\n+\n+import static com.sequenceiq.freeipa.flow.freeipa.downscale.DownscaleFlowEvent.DOWNSCALE_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.downscale.DownscaleFlowEvent.FAIL_HANDLED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.downscale.DownscaleFlowEvent.STARTING_DOWNSCALE_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.downscale.DownscaleFlowEvent.UPDATE_METADATA_FINISHED_EVENT;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.StateContext;\n+import org.springframework.statemachine.action.Action;\n+\n+import com.sequenceiq.cloudbreak.cloud.event.resource.RemoveInstanceRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.resource.RemoveInstanceResult;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudInstance;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.flow.core.Flow;\n+import com.sequenceiq.flow.core.FlowParameters;\n+import com.sequenceiq.flow.core.PayloadConverter;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.DetailedStackStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.FailureDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.SuccessDetails;\n+import com.sequenceiq.freeipa.converter.cloud.InstanceMetaDataToCloudInstanceConverter;\n+import com.sequenceiq.freeipa.converter.cloud.ResourceToCloudResourceConverter;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.freeipa.cleanup.CleanupEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.cleanup.event.cert.RevokeCertsRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.cleanup.event.cert.RevokeCertsResponse;\n+import com.sequenceiq.freeipa.flow.freeipa.cleanup.event.dns.RemoveDnsRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.cleanup.event.dns.RemoveDnsResponse;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.DownscaleFlowEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.DownscaleState;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.FreeIpaDownscaleContext;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.FreeIpaDownscaleFailureContext;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.DownscaleEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.DownscaleFailureEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.removehosts.RemoveHostsFromOrchestrationRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.removehosts.RemoveHostsFromOrchestrationSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.removeserver.RemoveServersRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.removeserver.RemoveServersResponse;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.stoptelemetry.StopTelemetryRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.stoptelemetry.StopTelemetryResponse;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.failure.ClusterProxyUpdateRegistrationFailedToDownscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.failure.RemoveDnsResponseToDownscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.failure.RemoveHostsResponseToDownscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.failure.RemoveInstanceResultToDownscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.failure.RevokeCertsResponseToDownscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationSuccess;\n+import com.sequenceiq.freeipa.flow.stack.AbstractStackAction;\n+import com.sequenceiq.freeipa.flow.stack.StackEvent;\n+import com.sequenceiq.freeipa.flow.stack.termination.action.TerminationService;\n+import com.sequenceiq.freeipa.service.operation.OperationService;\n+import com.sequenceiq.freeipa.service.resource.ResourceService;\n+import com.sequenceiq.freeipa.service.stack.StackService;\n+import com.sequenceiq.freeipa.service.stack.StackUpdater;\n+\n+@Configuration\n+public class FreeIpaDownscaleActions {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FreeIpaDownscaleActions.class);\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    @Inject\n+    private InstanceMetaDataToCloudInstanceConverter instanceConverter;\n+\n+    @Inject\n+    private ResourceService resourceService;\n+\n+    @Inject\n+    private ResourceToCloudResourceConverter resourceConverter;\n+\n+    @Inject\n+    private TerminationService terminationService;\n+\n+    @Bean(name = \"STARTING_DOWNSCALE_STATE\")\n+    public Action<?, ?> startingDownscaleAction() {\n+        return new AbstractDownscaleAction<>(DownscaleEvent.class) {\n+            @Override\n+            protected void doExecute(FreeIpaDownscaleContext context, DownscaleEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                List<String> instanceIds = context.getInstanceIds();", "originalCommit": "7c1663628f245cb9484f35ca82b4d0e8d4bc93a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "c1f68f47be43e7b0ae94c883332c33ad133ff152", "url": "https://github.com/hortonworks/cloudbreak/commit/c1f68f47be43e7b0ae94c883332c33ad133ff152", "message": "CB-7096: Add downscaling FreeIPA for recovery of non-CRL master nodes\n\nWhen an non-CRL master fails, the recovery should perform a downscale.\nThe process includes:\n  * Updating cluster proxy registration so that it does not include\n    the node\n  * Attempting to gracefully stop telemetry on the node\n  * Terminating the cloud provider instance\n  * Removing the server from FreeIPA replication agreements and hosts\n  * Revoking the host's certificate\n  * Removing the DNS entries including A records, PTR records, SRV\n    records, and PTR records\n  * Remove the instance from salt orchestration including both salt\n    masters and salt minions\n  * Update the metadata for the instance and stack\n\nThis will not clean up the /etc/hosts file which will still include\nreferences to downscaled freeipa instances. If it were to clean up the\n/etc/hosts file using the hosts.absent salt rule then the instance\nstill would need a list of all the failed hosts on the node. It\ndoesn't seem particularly problematic to keep the old hosts in the\nfile.\n\nThis was tested with the added tests and it was also tested manually\nby downscaling a 2 node FreeIPA cluster to 1 node. The primary gateway\nwas the CA master & CRL master and that node was kept.", "committedDate": "2020-05-20T21:46:34Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMDk5OTIwNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r430999207", "bodyText": "nit: instead of forEach and put you could use collect and Collectors.toMap\nalso this stream could be extracted to a method", "author": "lacikaaa", "createdAt": "2020-05-27T09:56:45Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/downscale/handler/RemoveHostsHandler.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package com.sequenceiq.freeipa.flow.freeipa.downscale.handler;\n+\n+import static com.sequenceiq.cloudbreak.polling.PollingResult.SUCCESS;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.orchestrator.exception.CloudbreakOrchestratorException;\n+import com.sequenceiq.cloudbreak.orchestrator.host.HostOrchestrator;\n+import com.sequenceiq.cloudbreak.orchestrator.model.GatewayConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.model.Node;\n+import com.sequenceiq.cloudbreak.polling.PollingResult;\n+import com.sequenceiq.cloudbreak.service.CloudbreakException;\n+import com.sequenceiq.flow.event.EventSelectorUtil;\n+import com.sequenceiq.flow.reactor.api.handler.EventHandler;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.DownscaleFailureEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.removehosts.RemoveHostsFromOrchestrationRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.removehosts.RemoveHostsFromOrchestrationSuccess;\n+import com.sequenceiq.freeipa.orchestrator.StackBasedExitCriteriaModel;\n+import com.sequenceiq.freeipa.service.BootstrapService;\n+import com.sequenceiq.freeipa.service.GatewayConfigService;\n+import com.sequenceiq.freeipa.service.stack.StackService;\n+\n+import reactor.bus.Event;\n+import reactor.bus.EventBus;\n+\n+@Component\n+public class RemoveHostsHandler implements EventHandler<RemoveHostsFromOrchestrationRequest> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RemoveHostsHandler.class);\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private HostOrchestrator hostOrchestrator;\n+\n+    @Inject\n+    private GatewayConfigService gatewayConfigService;\n+\n+    @Inject\n+    private EventBus eventBus;\n+\n+    @Inject\n+    private BootstrapService bootstrapService;\n+\n+    @Override\n+    public String selector() {\n+        return EventSelectorUtil.selector(RemoveHostsFromOrchestrationRequest.class);\n+    }\n+\n+    @Override\n+    public void accept(Event<RemoveHostsFromOrchestrationRequest> removeHostsRequestEvent) {\n+        RemoveHostsFromOrchestrationRequest request = removeHostsRequestEvent.getData();\n+        Set<String> hostNames = request.getHosts();\n+        Selectable result;\n+        try {\n+            Stack stack = stackService.getByIdWithListsInTransaction(request.getResourceId());\n+            PollingResult orchestratorRemovalPollingResult =\n+                    removeHostsFromOrchestrator(stack, new ArrayList<>(hostNames));\n+            if (!PollingResult.isSuccess(orchestratorRemovalPollingResult)) {\n+                LOGGER.warn(\"Can not remove hosts from orchestrator: {}\", hostNames);\n+            }\n+            // rebootstrap to update the minion's multi-master configuration\n+            List<String> remainingInstanceIds = stack.getNotDeletedInstanceMetaDataList().stream()\n+                    .filter(metadata -> Objects.nonNull(metadata.getDiscoveryFQDN()))\n+                    .filter(metadata -> !hostNames.contains(metadata.getDiscoveryFQDN()))\n+                    .map(InstanceMetaData::getInstanceId)\n+                    .collect(Collectors.toList());\n+            bootstrapService.bootstrap(stack.getId(), remainingInstanceIds);\n+            result = new RemoveHostsFromOrchestrationSuccess(request.getResourceId());\n+        } catch (Exception e) {\n+            LOGGER.error(\"Failed to remove hosts from orchestration\", e);\n+            result = new DownscaleFailureEvent(request.getResourceId(), \"Removing host from orchestration\", Set.of(), Map.of(), e);\n+        }\n+        eventBus.notify(result.selector(), new Event<>(removeHostsRequestEvent.getHeaders(), result));\n+    }\n+\n+    private PollingResult removeHostsFromOrchestrator(Stack stack, List<String> hostNames) throws CloudbreakException {\n+        LOGGER.debug(\"Remove hosts from orchestrator: [{}]\", hostNames);\n+        try {\n+            Map<String, String> removeNodePrivateIPsByFQDN = new HashMap<>();\n+            stack.getAllInstanceMetaDataList().stream()\n+                    .filter(instanceMetaData -> Objects.nonNull(instanceMetaData.getDiscoveryFQDN()))\n+                    .filter(instanceMetaData ->\n+                            hostNames.stream()\n+                                    .anyMatch(hn -> hn.equals(instanceMetaData.getDiscoveryFQDN())))\n+                    .forEach(instanceMetaData -> removeNodePrivateIPsByFQDN.put(instanceMetaData.getDiscoveryFQDN(), instanceMetaData.getPrivateIp()));", "originalCommit": "c1f68f47be43e7b0ae94c883332c33ad133ff152", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAwMjQwOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r431002408", "bodyText": "could you add logging before this line?", "author": "lacikaaa", "createdAt": "2020-05-27T10:02:28Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/downscale/handler/RemoveHostsHandler.java", "diffHunk": "@@ -0,0 +1,117 @@\n+package com.sequenceiq.freeipa.flow.freeipa.downscale.handler;\n+\n+import static com.sequenceiq.cloudbreak.polling.PollingResult.SUCCESS;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.common.event.Selectable;\n+import com.sequenceiq.cloudbreak.orchestrator.exception.CloudbreakOrchestratorException;\n+import com.sequenceiq.cloudbreak.orchestrator.host.HostOrchestrator;\n+import com.sequenceiq.cloudbreak.orchestrator.model.GatewayConfig;\n+import com.sequenceiq.cloudbreak.orchestrator.model.Node;\n+import com.sequenceiq.cloudbreak.polling.PollingResult;\n+import com.sequenceiq.cloudbreak.service.CloudbreakException;\n+import com.sequenceiq.flow.event.EventSelectorUtil;\n+import com.sequenceiq.flow.reactor.api.handler.EventHandler;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.DownscaleFailureEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.removehosts.RemoveHostsFromOrchestrationRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.removehosts.RemoveHostsFromOrchestrationSuccess;\n+import com.sequenceiq.freeipa.orchestrator.StackBasedExitCriteriaModel;\n+import com.sequenceiq.freeipa.service.BootstrapService;\n+import com.sequenceiq.freeipa.service.GatewayConfigService;\n+import com.sequenceiq.freeipa.service.stack.StackService;\n+\n+import reactor.bus.Event;\n+import reactor.bus.EventBus;\n+\n+@Component\n+public class RemoveHostsHandler implements EventHandler<RemoveHostsFromOrchestrationRequest> {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RemoveHostsHandler.class);\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private HostOrchestrator hostOrchestrator;\n+\n+    @Inject\n+    private GatewayConfigService gatewayConfigService;\n+\n+    @Inject\n+    private EventBus eventBus;\n+\n+    @Inject\n+    private BootstrapService bootstrapService;\n+\n+    @Override\n+    public String selector() {\n+        return EventSelectorUtil.selector(RemoveHostsFromOrchestrationRequest.class);\n+    }\n+\n+    @Override\n+    public void accept(Event<RemoveHostsFromOrchestrationRequest> removeHostsRequestEvent) {\n+        RemoveHostsFromOrchestrationRequest request = removeHostsRequestEvent.getData();\n+        Set<String> hostNames = request.getHosts();\n+        Selectable result;\n+        try {\n+            Stack stack = stackService.getByIdWithListsInTransaction(request.getResourceId());\n+            PollingResult orchestratorRemovalPollingResult =\n+                    removeHostsFromOrchestrator(stack, new ArrayList<>(hostNames));\n+            if (!PollingResult.isSuccess(orchestratorRemovalPollingResult)) {\n+                LOGGER.warn(\"Can not remove hosts from orchestrator: {}\", hostNames);\n+            }\n+            // rebootstrap to update the minion's multi-master configuration\n+            List<String> remainingInstanceIds = stack.getNotDeletedInstanceMetaDataList().stream()\n+                    .filter(metadata -> Objects.nonNull(metadata.getDiscoveryFQDN()))\n+                    .filter(metadata -> !hostNames.contains(metadata.getDiscoveryFQDN()))\n+                    .map(InstanceMetaData::getInstanceId)\n+                    .collect(Collectors.toList());\n+            bootstrapService.bootstrap(stack.getId(), remainingInstanceIds);\n+            result = new RemoveHostsFromOrchestrationSuccess(request.getResourceId());\n+        } catch (Exception e) {\n+            LOGGER.error(\"Failed to remove hosts from orchestration\", e);\n+            result = new DownscaleFailureEvent(request.getResourceId(), \"Removing host from orchestration\", Set.of(), Map.of(), e);\n+        }\n+        eventBus.notify(result.selector(), new Event<>(removeHostsRequestEvent.getHeaders(), result));\n+    }\n+\n+    private PollingResult removeHostsFromOrchestrator(Stack stack, List<String> hostNames) throws CloudbreakException {\n+        LOGGER.debug(\"Remove hosts from orchestrator: [{}]\", hostNames);\n+        try {\n+            Map<String, String> removeNodePrivateIPsByFQDN = new HashMap<>();\n+            stack.getAllInstanceMetaDataList().stream()\n+                    .filter(instanceMetaData -> Objects.nonNull(instanceMetaData.getDiscoveryFQDN()))\n+                    .filter(instanceMetaData ->\n+                            hostNames.stream()\n+                                    .anyMatch(hn -> hn.equals(instanceMetaData.getDiscoveryFQDN())))\n+                    .forEach(instanceMetaData -> removeNodePrivateIPsByFQDN.put(instanceMetaData.getDiscoveryFQDN(), instanceMetaData.getPrivateIp()));\n+            Set<InstanceMetaData> remainingInstanceMetaDatas = stack.getNotDeletedInstanceMetaDataList().stream()\n+                    .filter(instanceMetaData -> !removeNodePrivateIPsByFQDN.containsValue(instanceMetaData.getPrivateIp()))\n+                    .collect(Collectors.toSet());\n+            Set<Node> remainingNodes = remainingInstanceMetaDatas.stream()\n+                    .map(im -> new Node(im.getPrivateIp(), im.getPublicIp(), im.getInstanceId(),\n+                            im.getInstanceGroup().getTemplate().getInstanceType(), im.getDiscoveryFQDN(), im.getInstanceGroup().getGroupName()))\n+                    .collect(Collectors.toSet());\n+            List<GatewayConfig> remainingGatewayConfigs = gatewayConfigService.getGatewayConfigs(stack, remainingInstanceMetaDatas);\n+            hostOrchestrator.tearDown(remainingGatewayConfigs, removeNodePrivateIPsByFQDN, remainingNodes, new StackBasedExitCriteriaModel(stack.getId()));", "originalCommit": "c1f68f47be43e7b0ae94c883332c33ad133ff152", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAwOTc4Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r431009787", "bodyText": "I think it's worth to refactor the body of the for (DnsZoneList dnsZone : freeIpaClient.findAllDnsZone()) { and introduce 1 or 2 new methods", "author": "lacikaaa", "createdAt": "2020-05-27T10:15:53Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/dns/DnsRecordService.java", "diffHunk": "@@ -48,6 +48,18 @@ public void deleteDnsRecordByFqdn(String environmentCrn, String accountId,  List\n                 LOGGER.info(\"Delete DNS record [{}] in zone [{}]\", dnsRecord, dnsZone);\n                 freeIpaClient.deleteDnsRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname());\n             }\n+            Set<DnsRecord> srvRecordsToDelete = allDnsRecordInZone.stream()\n+                    .filter(record -> fqdns.stream().anyMatch(fqdn -> record.isHostRelatedSrvRecord(fqdn)))\n+                    .collect(Collectors.toSet());\n+            for (DnsRecord dnsRecord : srvRecordsToDelete) {\n+                for (String fqdn : fqdns) {\n+                    List<String> srvRecords = dnsRecord.getHostRelatedSrvRecords(fqdn);\n+                    if (!srvRecords.isEmpty()) {\n+                        LOGGER.info(\"Delete DNS SRV record [{}] for [{}] in zone [{}]\", dnsRecord.getIdnsname(), fqdn, dnsZone);\n+                        freeIpaClient.deleteDnsSrvRecord(dnsRecord.getIdnsname(), dnsZone.getIdnsname(), srvRecords);\n+                    }\n+                }\n+            }", "originalCommit": "c1f68f47be43e7b0ae94c883332c33ad133ff152", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMDc5OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r431010798", "bodyText": "not reboot, repair", "author": "lacikaaa", "createdAt": "2020-05-27T10:17:46Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/RepairInstancesService.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package com.sequenceiq.freeipa.service.stack;\n+\n+import static com.sequenceiq.freeipa.flow.freeipa.downscale.DownscaleFlowEvent.DOWNSCALE_EVENT;\n+import static java.util.function.Predicate.not;\n+\n+import java.text.MessageFormat;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.health.NodeHealthDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.repair.RepairInstancesRequest;\n+import com.sequenceiq.freeipa.api.v1.operation.model.OperationType;\n+import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n+import com.sequenceiq.freeipa.controller.exception.NotFoundException;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Operation;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.DownscaleEvent;\n+import com.sequenceiq.freeipa.service.freeipa.flow.FreeIpaFlowManager;\n+import com.sequenceiq.freeipa.service.operation.OperationService;\n+\n+@Service\n+public class RepairInstancesService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RepairInstancesService.class);\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private FreeIpaFlowManager flowManager;\n+\n+    @Inject\n+    private FreeIpaHealthDetailsService healthDetailsService;\n+\n+    @Inject\n+    private OperationService operationService;\n+\n+    private Map<String, InstanceStatus> getInstanceHealthMap(String accountId, RepairInstancesRequest request) {\n+        return healthDetailsService.getHealthDetails(request.getEnvironmentCrn(), accountId).getNodeHealthDetails().stream()\n+                .collect(Collectors.toMap(NodeHealthDetails::getInstanceId, NodeHealthDetails::getStatus));\n+    }\n+\n+    private Collection<String> getValidInstanceIds(Collection<String> allInstances, Collection<String> instanceIds) {\n+        if (instanceIds == null || instanceIds.isEmpty()) {\n+            return allInstances;\n+        } else {\n+            Collection<String> validInstanceIds = instanceIds.stream()\n+                    .filter(allInstances::contains)\n+                    .collect(Collectors.toSet());\n+            if (validInstanceIds.size() != instanceIds.size()) {\n+                String badIds = instanceIds.stream()\n+                        .filter(not(allInstances::contains)).collect(Collectors.joining(\",\"));\n+                String msg = MessageFormat.format(\"Invalid instanceIds in request {0}.\", badIds);\n+                LOGGER.error(msg);\n+                throw new BadRequestException(msg);\n+            }\n+            return validInstanceIds;\n+        }\n+    }\n+\n+    private Map<String, InstanceMetaData> getInstancesToRepair(Map<String, InstanceMetaData> allInstances,\n+            String accountId, RepairInstancesRequest request) {\n+        Collection<String> validInstanceIds = getValidInstanceIds(allInstances.keySet(), request.getInstanceIds());\n+        Map<String, InstanceStatus> healthMap =\n+                request.isForceRepair() ? Collections.emptyMap() : getInstanceHealthMap(accountId, request);\n+\n+        Map<String, InstanceMetaData> instancesToRepair = validInstanceIds.stream()\n+                .filter(instanceId -> request.isForceRepair() || (healthMap.get(instanceId) != null && !healthMap.get(instanceId).isAvailable()))\n+                .collect(Collectors.toMap(Function.identity(), instanceId -> allInstances.get(instanceId)));\n+        if (instancesToRepair.keySet().size() != validInstanceIds.size()) {\n+            LOGGER.info(\"Not repairing instances {} because force repair was not selected.\", validInstanceIds.stream()\n+                    .filter(instance -> !instancesToRepair.keySet().contains(instance)).collect(Collectors.joining(\",\")));\n+        }\n+        return instancesToRepair;\n+    }\n+\n+    private Map<String, InstanceMetaData> getAllInstancesFromStack(Stack stack) {\n+        return stack.getInstanceGroups().stream()\n+                .flatMap(instanceGroup -> instanceGroup.getInstanceMetaData().stream())\n+                .collect(Collectors.toMap(InstanceMetaData::getInstanceId, Function.identity()));\n+    }\n+\n+    /**\n+     * If no instance passed in request, repair all bad instances\n+     * If instances passed in request, repair all valid passed bad instances\n+     * If force and instances passed in request, repair all valid passed instances\n+     * If force and no instances passed in request, repair all instances\n+     * @param accountId - The account id for the instance to reboot.", "originalCommit": "c1f68f47be43e7b0ae94c883332c33ad133ff152", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMTIzOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r431011238", "bodyText": "isEmpty instead of > 0", "author": "lacikaaa", "createdAt": "2020-05-27T10:18:37Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/RepairInstancesService.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package com.sequenceiq.freeipa.service.stack;\n+\n+import static com.sequenceiq.freeipa.flow.freeipa.downscale.DownscaleFlowEvent.DOWNSCALE_EVENT;\n+import static java.util.function.Predicate.not;\n+\n+import java.text.MessageFormat;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.health.NodeHealthDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.repair.RepairInstancesRequest;\n+import com.sequenceiq.freeipa.api.v1.operation.model.OperationType;\n+import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n+import com.sequenceiq.freeipa.controller.exception.NotFoundException;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Operation;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.DownscaleEvent;\n+import com.sequenceiq.freeipa.service.freeipa.flow.FreeIpaFlowManager;\n+import com.sequenceiq.freeipa.service.operation.OperationService;\n+\n+@Service\n+public class RepairInstancesService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(RepairInstancesService.class);\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private FreeIpaFlowManager flowManager;\n+\n+    @Inject\n+    private FreeIpaHealthDetailsService healthDetailsService;\n+\n+    @Inject\n+    private OperationService operationService;\n+\n+    private Map<String, InstanceStatus> getInstanceHealthMap(String accountId, RepairInstancesRequest request) {\n+        return healthDetailsService.getHealthDetails(request.getEnvironmentCrn(), accountId).getNodeHealthDetails().stream()\n+                .collect(Collectors.toMap(NodeHealthDetails::getInstanceId, NodeHealthDetails::getStatus));\n+    }\n+\n+    private Collection<String> getValidInstanceIds(Collection<String> allInstances, Collection<String> instanceIds) {\n+        if (instanceIds == null || instanceIds.isEmpty()) {\n+            return allInstances;\n+        } else {\n+            Collection<String> validInstanceIds = instanceIds.stream()\n+                    .filter(allInstances::contains)\n+                    .collect(Collectors.toSet());\n+            if (validInstanceIds.size() != instanceIds.size()) {\n+                String badIds = instanceIds.stream()\n+                        .filter(not(allInstances::contains)).collect(Collectors.joining(\",\"));\n+                String msg = MessageFormat.format(\"Invalid instanceIds in request {0}.\", badIds);\n+                LOGGER.error(msg);\n+                throw new BadRequestException(msg);\n+            }\n+            return validInstanceIds;\n+        }\n+    }\n+\n+    private Map<String, InstanceMetaData> getInstancesToRepair(Map<String, InstanceMetaData> allInstances,\n+            String accountId, RepairInstancesRequest request) {\n+        Collection<String> validInstanceIds = getValidInstanceIds(allInstances.keySet(), request.getInstanceIds());\n+        Map<String, InstanceStatus> healthMap =\n+                request.isForceRepair() ? Collections.emptyMap() : getInstanceHealthMap(accountId, request);\n+\n+        Map<String, InstanceMetaData> instancesToRepair = validInstanceIds.stream()\n+                .filter(instanceId -> request.isForceRepair() || (healthMap.get(instanceId) != null && !healthMap.get(instanceId).isAvailable()))\n+                .collect(Collectors.toMap(Function.identity(), instanceId -> allInstances.get(instanceId)));\n+        if (instancesToRepair.keySet().size() != validInstanceIds.size()) {\n+            LOGGER.info(\"Not repairing instances {} because force repair was not selected.\", validInstanceIds.stream()\n+                    .filter(instance -> !instancesToRepair.keySet().contains(instance)).collect(Collectors.joining(\",\")));\n+        }\n+        return instancesToRepair;\n+    }\n+\n+    private Map<String, InstanceMetaData> getAllInstancesFromStack(Stack stack) {\n+        return stack.getInstanceGroups().stream()\n+                .flatMap(instanceGroup -> instanceGroup.getInstanceMetaData().stream())\n+                .collect(Collectors.toMap(InstanceMetaData::getInstanceId, Function.identity()));\n+    }\n+\n+    /**\n+     * If no instance passed in request, repair all bad instances\n+     * If instances passed in request, repair all valid passed bad instances\n+     * If force and instances passed in request, repair all valid passed instances\n+     * If force and no instances passed in request, repair all instances\n+     * @param accountId - The account id for the instance to reboot.\n+     * @param request - A RepairInstanceRequest containing request parameters.\n+     */\n+    public void repairInstances(String accountId, RepairInstancesRequest request) {\n+        Stack stack = stackService.getByEnvironmentCrnAndAccountIdWithLists(request.getEnvironmentCrn(), accountId);\n+        MDCBuilder.buildMdcContext(stack);\n+        Map<String, InstanceMetaData> allInstancesByInstanceId = getAllInstancesFromStack(stack);\n+        Map<String, InstanceMetaData> instancesToRepair = getInstancesToRepair(allInstancesByInstanceId, accountId, request);\n+\n+        if (instancesToRepair.keySet().size() > 0) {", "originalCommit": "c1f68f47be43e7b0ae94c883332c33ad133ff152", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMjIwNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r431012206", "bodyText": "this is very similar to RebootInstancesService. could you refactor so the common part is in a common class?", "author": "lacikaaa", "createdAt": "2020-05-27T10:20:29Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/RepairInstancesService.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package com.sequenceiq.freeipa.service.stack;\n+\n+import static com.sequenceiq.freeipa.flow.freeipa.downscale.DownscaleFlowEvent.DOWNSCALE_EVENT;\n+import static java.util.function.Predicate.not;\n+\n+import java.text.MessageFormat;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.instance.InstanceStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.health.NodeHealthDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.repair.RepairInstancesRequest;\n+import com.sequenceiq.freeipa.api.v1.operation.model.OperationType;\n+import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n+import com.sequenceiq.freeipa.controller.exception.NotFoundException;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Operation;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.event.DownscaleEvent;\n+import com.sequenceiq.freeipa.service.freeipa.flow.FreeIpaFlowManager;\n+import com.sequenceiq.freeipa.service.operation.OperationService;\n+\n+@Service\n+public class RepairInstancesService {", "originalCommit": "c1f68f47be43e7b0ae94c883332c33ad133ff152", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjE5MjIwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r432192209", "bodyText": "Since reboot is a part of repair and at the higher level API it is just called repair, I moved the RebootInstancesService into RepairInstanceService. But I kept the FreeIPA REST APIs as reboot and repair.", "author": "jamisonbennett", "createdAt": "2020-05-29T00:18:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAxMjIwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAyMTc2MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r431021761", "bodyText": "@oleewere could you check this part as the target from gateways moved to all nodes. also switched from private IPs to hostnames when targeting", "author": "lacikaaa", "createdAt": "2020-05-27T10:37:52Z", "path": "orchestrator-salt/src/main/java/com/sequenceiq/cloudbreak/orchestrator/salt/SaltOrchestrator.java", "diffHunk": "@@ -231,10 +234,10 @@ public void installAndStartMonitoring(List<GatewayConfig> allGateway, Set<Node>\n     public void stopTelemetryAgent(List<GatewayConfig> allGateway, Set<Node> nodes, ExitCriteriaModel exitModel)\n             throws CloudbreakOrchestratorFailedException {\n         GatewayConfig primaryGateway = getPrimaryGatewayConfig(allGateway);\n-        Set<String> gatewayTargets = getGatewayPrivateIps(allGateway);\n+        Set<String> targetHostnames = nodes.stream().map(Node::getHostname).collect(Collectors.toSet());\n         try (SaltConnector sc = createSaltConnector(primaryGateway)) {\n-            StateAllRunner stateAllJobRunner = new StateAllRunner(gatewayTargets, nodes, \"fluent.agent-stop\");\n-            OrchestratorBootstrap saltJobIdTracker = new SaltJobIdTracker(sc, stateAllJobRunner);\n+            StateRunner stateRunner = new StateRunner(targetHostnames, nodes, FLUENT_AGENT_STOP);\n+            OrchestratorBootstrap saltJobIdTracker = new SaltJobIdTracker(sc, stateRunner);", "originalCommit": "c1f68f47be43e7b0ae94c883332c33ad133ff152", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMTAyNDI0Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r431024247", "bodyText": "shouldn't this return with either a flowid or an operation id?", "author": "lacikaaa", "createdAt": "2020-05-27T10:42:45Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/stack/FreeIpaV1Endpoint.java", "diffHunk": "@@ -84,6 +85,13 @@\n             nickname = \"rebootV1\")\n     void rebootInstances(@Valid RebootInstancesRequest request);\n \n+    @POST\n+    @Path(\"repair\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = FreeIpaOperationDescriptions.REPAIR, produces = MediaType.APPLICATION_JSON, notes = FreeIpaNotes.FREEIPA_NOTES,\n+            nickname = \"repairV1\")\n+    void repairInstances(@Valid RepairInstancesRequest request) throws Exception;", "originalCommit": "c1f68f47be43e7b0ae94c883332c33ad133ff152", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2d282b05f61a881b81a87d21f5338980926ee1cb", "url": "https://github.com/hortonworks/cloudbreak/commit/2d282b05f61a881b81a87d21f5338980926ee1cb", "message": "CB-7096: Add downscaling FreeIPA for recovery of non-CRL master nodes\n\nWhen an non-CRL master fails, the recovery should perform a downscale.\nThe process includes:\n  * Updating cluster proxy registration so that it does not include\n    the node\n  * Attempting to gracefully stop telemetry on the node\n  * Terminating the cloud provider instance\n  * Removing the server from FreeIPA replication agreements and hosts\n  * Revoking the host's certificate\n  * Removing the DNS entries including A records, PTR records, SRV\n    records, and PTR records\n  * Remove the instance from salt orchestration including both salt\n    masters and salt minions\n  * Update the metadata for the instance and stack\n\nThis will not clean up the /etc/hosts file which will still include\nreferences to downscaled freeipa instances. If it were to clean up the\n/etc/hosts file using the hosts.absent salt rule then the instance\nstill would need a list of all the failed hosts on the node. It\ndoesn't seem particularly problematic to keep the old hosts in the\nfile.\n\nThis was tested with the added tests and it was also tested manually\nby downscaling a 2 node FreeIPA cluster to 1 node. The primary gateway\nwas the CA master & CRL master and that node was kept.", "committedDate": "2020-05-29T00:15:08Z", "type": "forcePushed"}, {"oid": "47e45925109d812760604c0f8ba24a0db55a6808", "url": "https://github.com/hortonworks/cloudbreak/commit/47e45925109d812760604c0f8ba24a0db55a6808", "message": "CB-7096: Add downscaling FreeIPA for recovery of non-CRL master nodes\n\nWhen an non-CRL master fails, the recovery should perform a downscale.\nThe process includes:\n  * Updating cluster proxy registration so that it does not include\n    the node\n  * Attempting to gracefully stop telemetry on the node\n  * Terminating the cloud provider instance\n  * Removing the server from FreeIPA replication agreements and hosts\n  * Revoking the host's certificate\n  * Removing the DNS entries including A records, PTR records, SRV\n    records, and PTR records\n  * Remove the instance from salt orchestration including both salt\n    masters and salt minions\n  * Update the metadata for the instance and stack\n\nThis will not clean up the /etc/hosts file which will still include\nreferences to downscaled freeipa instances. If it were to clean up the\n/etc/hosts file using the hosts.absent salt rule then the instance\nstill would need a list of all the failed hosts on the node. It\ndoesn't seem particularly problematic to keep the old hosts in the\nfile.\n\nThis was tested with the added tests and it was also tested manually\nby downscaling a 2 node FreeIPA cluster to 1 node. The primary gateway\nwas the CA master & CRL master and that node was kept.", "committedDate": "2020-05-29T21:30:28Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg5MjA4MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r433892081", "bodyText": "this would affect clusters (DH/DL) and not just FreeIPA if I'm not mistaken. So even if a cluster doesn't have cloudwatch enabled we will try to delete them. Does it have any performance impact on larger clusters?", "author": "lacikaaa", "createdAt": "2020-06-02T13:52:49Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsDownscaleService.java", "diffHunk": "@@ -67,17 +71,22 @@\n                 instanceIds.add(vm.getInstanceId());\n             }\n \n+            AwsCredentialView credentialView = new AwsCredentialView(auth.getCloudCredential());\n+            AuthenticatedContextView authenticatedContextView = new AuthenticatedContextView(auth);\n+            String regionName = authenticatedContextView.getRegion();\n+            awsCloudWatchService.deleteCloudWatchAlarmsForSystemFailures(stack, regionName, credentialView, instanceIds);", "originalCommit": "47e45925109d812760604c0f8ba24a0db55a6808", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzMDU5Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r434630596", "bodyText": "deleteCloudWatchAlarmsForSystemFailures() should only perform actions for FreeIPA because only FreeIPA management service sets CLOUDWATCH_CREATE_PARAMETER.\n        String isCreate = stack.getParameters().get(CLOUDWATCH_CREATE_PARAMETER);\n        if (isCreate != null && isCreate.equals(Boolean.TRUE.toString())) {", "author": "jamisonbennett", "createdAt": "2020-06-03T14:55:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg5MjA4MQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4MDQ5MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r435280490", "bodyText": "ok I missed this isCreate", "author": "lacikaaa", "createdAt": "2020-06-04T14:00:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg5MjA4MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg5MzU4Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r433893586", "bodyText": "why don't we send all AlarmNames in one request? If we will do this for clusters, potentially with tens of nodes we could save a lot of requests", "author": "lacikaaa", "createdAt": "2020-06-02T13:54:44Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsCloudWatchService.java", "diffHunk": "@@ -71,20 +72,41 @@ public void addCloudWatchAlarmsForSystemFailures(List<CloudResource> instances,\n     }\n \n     public void deleteCloudWatchAlarmsForSystemFailures(CloudStack stack, String regionName, AwsCredentialView credentialView) {\n-        List<CloudInstance> instances = stack.getGroups().stream()\n-                .flatMap(group -> group.getInstances().stream()).collect(Collectors.toList());\n+        List<String> instanceIds = stack.getGroups().stream()\n+                .flatMap(group -> group.getInstances().stream())\n+                .map(CloudInstance::getInstanceId)\n+                .collect(Collectors.toList());\n+        deleteCloudWatchAlarmsForSystemFailures(stack, regionName, credentialView, instanceIds);\n+    }\n+\n+    public void deleteCloudWatchAlarmsForSystemFailures(CloudStack stack, String regionName, AwsCredentialView credentialView, List<String> instanceIds) {\n         String isCreate = stack.getParameters().get(CLOUDWATCH_CREATE_PARAMETER);\n         if (isCreate != null && isCreate.equals(Boolean.TRUE.toString())) {\n-            instances.stream().forEach(instance -> {\n-                try {\n-                    DeleteAlarmsRequest deleteAlarmsRequest = new DeleteAlarmsRequest().withAlarmNames(instance.getInstanceId() + alarmSuffix);\n-                    AmazonCloudWatchClient amazonCloudWatchClient = awsClient.createCloudWatchClient(credentialView, regionName);\n-                    amazonCloudWatchClient.deleteAlarms(deleteAlarmsRequest);\n-                    LOGGER.debug(\"Deleted cloudwatch alarm.-\", instance.getInstanceId());\n-                } catch (AmazonCloudWatchException acwe) {\n-                    LOGGER.error(\"Unable to delete cloudwatch alarm for instanceId {}: {}\", instance.getInstanceId(), acwe.getLocalizedMessage());\n-                }\n-            });\n+            List<String> instanceIdsFromStack = stack.getGroups().stream()\n+                    .flatMap(group -> group.getInstances().stream())\n+                    .map(CloudInstance::getInstanceId)\n+                    .collect(Collectors.toList());\n+            List<String> instanceIdsNotInStack = instanceIds.stream()\n+                    .filter(instanceId -> !instanceIdsFromStack.contains(instanceId))\n+                    .collect(Collectors.toList());\n+            if (!instanceIdsNotInStack.isEmpty()) {\n+                LOGGER.error(\"Instance IDs [{}] are not part of stack {}\", instanceIdsFromStack, stack);\n+                throw new CloudConnectorException(\"Unable to delete cloud watch alarms for system failure because instances ID are not a part of the stack.\");\n+            }\n+            deleteCloudWatchAlarmsForSystemFailures(regionName, credentialView, instanceIds);\n         }\n     }\n+\n+    private void deleteCloudWatchAlarmsForSystemFailures(String regionName, AwsCredentialView credentialView, List<String> instanceIds) {\n+        instanceIds.stream().forEach(instanceId -> {\n+            try {\n+                DeleteAlarmsRequest deleteAlarmsRequest = new DeleteAlarmsRequest().withAlarmNames(instanceId + alarmSuffix);", "originalCommit": "47e45925109d812760604c0f8ba24a0db55a6808", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNDYzNzY4NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r434637685", "bodyText": "Although it is possible to request up to 100 alarms to be deleted, \"In the event of an error, no alarms are deleted.\" - https://docs.aws.amazon.com/AmazonCloudWatch/latest/APIReference/API_DeleteAlarms.html\nWe could do something where we partition the list into sets of 100 and try to delete them (but this is not needed in the case of FreeIPA). If there is a failure then we could fall back to this implementation, that way we ensure all alarms that can be deleted are deleted. If the alarm deletion was used by datahub, then this should be done. But its currently only enabled for FreeIPA. With FreeIPA management service, there should be at most 3 instances in a delete request since there is a 4 node max. But in most cases, I suspect we will rarely get to cases where 4 nodes are used and 3 of them have failed. I am not sure the complexity is worth it here.", "author": "jamisonbennett", "createdAt": "2020-06-03T15:04:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg5MzU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI4NTE3Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r435285176", "bodyText": "so for FreeIPA this is not an issue, but my fear is if we might introduce this for clusters for some reason, we won't check if it scales well. So my suggestion here is to make bulk delete, and partition it by a 100.\nAlso the current way is not too idempotent as if we have to retry this state and like half of the alarm delete it will fail when we try to delete a non existing one.\nSo we should use describeAlarms or similar to fetch which exists and try to delete them. Also we might want to fail deletion if we can't delete them, because we will leave trash behind.", "author": "lacikaaa", "createdAt": "2020-06-04T14:06:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg5MzU4Ng=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTQ3ODc4NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r435478784", "bodyText": "I created CB-7340 for this.", "author": "jamisonbennett", "createdAt": "2020-06-04T18:49:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg5MzU4Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzg5NjY3OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r433896679", "bodyText": "instead of suppressing the warning could you refactor the method so it won't break the rule?", "author": "lacikaaa", "createdAt": "2020-06-02T13:58:47Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/AzureResourceConnector.java", "diffHunk": "@@ -296,15 +293,18 @@ private void handleArmTemplate(List<CloudResourceStatus> result, AzureClient cli\n         return resp;\n     }\n \n+    @SuppressWarnings(\"checkstyle:CyclomaticComplexity\")", "originalCommit": "47e45925109d812760604c0f8ba24a0db55a6808", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzkwOTgxOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r433909819", "bodyText": "this method is already in Stack.class", "author": "lacikaaa", "createdAt": "2020-06-02T14:13:33Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/downscale/action/AbstractDownscaleAction.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package com.sequenceiq.freeipa.flow.freeipa.downscale.action;\n+\n+import static com.sequenceiq.cloudbreak.cloud.model.Location.location;\n+import static com.sequenceiq.cloudbreak.cloud.model.Region.region;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.springframework.statemachine.StateContext;\n+\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudCredential;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudInstance;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n+import com.sequenceiq.cloudbreak.cloud.model.Location;\n+import com.sequenceiq.cloudbreak.common.event.Payload;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.flow.core.FlowParameters;\n+import com.sequenceiq.freeipa.converter.cloud.CredentialToCloudCredentialConverter;\n+import com.sequenceiq.freeipa.converter.cloud.InstanceMetaDataToCloudInstanceConverter;\n+import com.sequenceiq.freeipa.converter.cloud.ResourceToCloudResourceConverter;\n+import com.sequenceiq.freeipa.converter.cloud.StackToCloudStackConverter;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.DownscaleFlowEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.DownscaleState;\n+import com.sequenceiq.freeipa.flow.stack.AbstractStackAction;\n+import com.sequenceiq.freeipa.flow.stack.StackContext;\n+import com.sequenceiq.freeipa.flow.stack.StackFailureEvent;\n+import com.sequenceiq.freeipa.service.CredentialService;\n+import com.sequenceiq.freeipa.service.resource.ResourceService;\n+import com.sequenceiq.freeipa.service.stack.StackService;\n+\n+public abstract class AbstractDownscaleAction<P extends Payload> extends AbstractStackAction<DownscaleState, DownscaleFlowEvent, StackContext, P> {\n+\n+    protected static final String INSTANCE_IDS = \"INSTANCE_IDS\";\n+\n+    protected static final String OPERATION_ID = \"OPERATION_ID\";\n+\n+    protected static final String HOSTS = \"DOWNSCALE_HOSTS\";\n+\n+    @Inject\n+    private StackService stackService;\n+\n+    @Inject\n+    private StackToCloudStackConverter cloudStackConverter;\n+\n+    @Inject\n+    private CredentialToCloudCredentialConverter credentialConverter;\n+\n+    @Inject\n+    private CredentialService credentialService;\n+\n+    @Inject\n+    private ResourceService resourceService;\n+\n+    @Inject\n+    private ResourceToCloudResourceConverter resourceConverter;\n+\n+    @Inject\n+    private InstanceMetaDataToCloudInstanceConverter instanceConverter;\n+\n+    protected AbstractDownscaleAction(Class<P> payloadClass) {\n+        super(payloadClass);\n+    }\n+\n+    @Override\n+    protected StackContext createFlowContext(FlowParameters flowParameters, StateContext<DownscaleState, DownscaleFlowEvent> stateContext,\n+            P payload) {\n+        Stack stack = stackService.getByIdWithListsInTransaction(payload.getResourceId());\n+        MDCBuilder.buildMdcContext(stack);\n+        Location location = location(region(stack.getRegion()));\n+        CloudContext cloudContext = new CloudContext(stack.getId(), stack.getName(), stack.getCloudPlatform(), stack.getCloudPlatform(),\n+                location, stack.getOwner(), stack.getOwner(), stack.getAccountId());\n+        CloudCredential cloudCredential = credentialConverter.convert(credentialService.getCredentialByEnvCrn(stack.getEnvironmentCrn()));\n+        CloudStack cloudStack = cloudStackConverter.convert(stack);\n+        return new StackContext(flowParameters, stack, cloudContext, cloudCredential, cloudStack);\n+    }\n+\n+    @Override\n+    protected Object getFailurePayload(P payload, Optional<StackContext> flowContext, Exception ex) {\n+        return new StackFailureEvent(payload.getResourceId(), ex);\n+    }\n+\n+    protected void setInstanceIds(Map<Object, Object> variables, List<String> instanceIds) {\n+        variables.put(INSTANCE_IDS, instanceIds);\n+    }\n+\n+    protected List<String> getInstanceIds(Map<Object, Object> variables) {\n+        return (List<String>) variables.get(INSTANCE_IDS);\n+    }\n+\n+    protected void setOperationId(Map<Object, Object> variables, String operationId) {\n+        variables.put(OPERATION_ID, operationId);\n+    }\n+\n+    protected String getOperationId(Map<Object, Object> variables) {\n+        return (String) variables.get(OPERATION_ID);\n+    }\n+\n+    protected void setHosts(Map<Object, Object> variables, List<String> hosts) {\n+        variables.put(HOSTS, hosts);\n+    }\n+\n+    protected List<String> getHosts(Map<Object, Object> variables) {\n+        return (List<String>) variables.get(HOSTS);\n+    }\n+\n+    protected List<InstanceMetaData> getInstanceMetadataFromStack(Stack stack, List<String> instanceIds) {\n+        return getAllInstancesFromStack(stack).stream()\n+                .filter(instanceMetaData -> instanceIds.contains(instanceMetaData.getInstanceId()))\n+                .collect(Collectors.toList());\n+    }\n+\n+    private List<InstanceMetaData> getAllInstancesFromStack(Stack stack) {", "originalCommit": "47e45925109d812760604c0f8ba24a0db55a6808", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8458cb676c94a3dd08fa2e7bd673bdbecff7476e", "url": "https://github.com/hortonworks/cloudbreak/commit/8458cb676c94a3dd08fa2e7bd673bdbecff7476e", "message": "CB-7096: Add downscaling FreeIPA for recovery of non-CRL master nodes\n\nWhen an non-CRL master fails, the recovery should perform a downscale.\nThe process includes:\n  * Updating cluster proxy registration so that it does not include\n    the node\n  * Attempting to gracefully stop telemetry on the node\n  * Terminating the cloud provider instance\n  * Removing the server from FreeIPA replication agreements and hosts\n  * Revoking the host's certificate\n  * Removing the DNS entries including A records, PTR records, SRV\n    records, and PTR records\n  * Remove the instance from salt orchestration including both salt\n    masters and salt minions\n  * Update the metadata for the instance and stack\n\nThis will not clean up the /etc/hosts file which will still include\nreferences to downscaled freeipa instances. If it were to clean up the\n/etc/hosts file using the hosts.absent salt rule then the instance\nstill would need a list of all the failed hosts on the node. It\ndoesn't seem particularly problematic to keep the old hosts in the\nfile.\n\nThis was tested with the added tests and it was also tested manually\nby downscaling a 2 node FreeIPA cluster to 1 node. The primary gateway\nwas the CA master & CRL master and that node was kept.", "committedDate": "2020-06-03T16:03:41Z", "type": "forcePushed"}, {"oid": "64c0776c5b4fd570504767a362d58cfc53c051b1", "url": "https://github.com/hortonworks/cloudbreak/commit/64c0776c5b4fd570504767a362d58cfc53c051b1", "message": "CB-7096: Add downscaling FreeIPA for recovery of non-CRL master nodes\n\nWhen an non-CRL master fails, the recovery should perform a downscale.\nThe process includes:\n  * Updating cluster proxy registration so that it does not include\n    the node\n  * Attempting to gracefully stop telemetry on the node\n  * Terminating the cloud provider instance\n  * Removing the server from FreeIPA replication agreements and hosts\n  * Revoking the host's certificate\n  * Removing the DNS entries including A records, PTR records, SRV\n    records, and PTR records\n  * Remove the instance from salt orchestration including both salt\n    masters and salt minions\n  * Update the metadata for the instance and stack\n\nThis will not clean up the /etc/hosts file which will still include\nreferences to downscaled freeipa instances. If it were to clean up the\n/etc/hosts file using the hosts.absent salt rule then the instance\nstill would need a list of all the failed hosts on the node. It\ndoesn't seem particularly problematic to keep the old hosts in the\nfile.\n\nThis was tested with the added tests and it was also tested manually\nby downscaling a 2 node FreeIPA cluster to 1 node. The primary gateway\nwas the CA master & CRL master and that node was kept.", "committedDate": "2020-06-03T16:57:37Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTI5MjY0NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r435292645", "bodyText": "this could be: Boolean.TRUE.toString().equals(isCreate)", "author": "lacikaaa", "createdAt": "2020-06-04T14:16:12Z", "path": "cloud-aws/src/main/java/com/sequenceiq/cloudbreak/cloud/aws/connector/resource/AwsCloudWatchService.java", "diffHunk": "@@ -71,20 +72,41 @@ public void addCloudWatchAlarmsForSystemFailures(List<CloudResource> instances,\n     }\n \n     public void deleteCloudWatchAlarmsForSystemFailures(CloudStack stack, String regionName, AwsCredentialView credentialView) {\n-        List<CloudInstance> instances = stack.getGroups().stream()\n-                .flatMap(group -> group.getInstances().stream()).collect(Collectors.toList());\n+        List<String> instanceIds = stack.getGroups().stream()\n+                .flatMap(group -> group.getInstances().stream())\n+                .map(CloudInstance::getInstanceId)\n+                .collect(Collectors.toList());\n+        deleteCloudWatchAlarmsForSystemFailures(stack, regionName, credentialView, instanceIds);\n+    }\n+\n+    public void deleteCloudWatchAlarmsForSystemFailures(CloudStack stack, String regionName, AwsCredentialView credentialView, List<String> instanceIds) {\n         String isCreate = stack.getParameters().get(CLOUDWATCH_CREATE_PARAMETER);\n         if (isCreate != null && isCreate.equals(Boolean.TRUE.toString())) {", "originalCommit": "64c0776c5b4fd570504767a362d58cfc53c051b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTMyNzI5Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8081#discussion_r435327296", "bodyText": "so it's a bit misleading, I would expect here to have a collection of disks returned.\ninstead we add 1 item to a map. so I think this should be renamed, like addAttachedDiskStorageForRemoval, or refactor to return the name and call sth like findAttachedDiskStorageName", "author": "lacikaaa", "createdAt": "2020-06-04T15:00:47Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/AzureResourceConnector.java", "diffHunk": "@@ -346,6 +340,16 @@ private void checkTemplateDeployment(List<CloudResourceStatus> result, AzureClie\n         return resourcesToRemove;\n     }\n \n+    private void collectAttachedDisks(Map<String, Object> resourcesToRemove, AuthenticatedContext ac, CloudStack stack, AzureCredentialView azureCredentialView,", "originalCommit": "64c0776c5b4fd570504767a362d58cfc53c051b1", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "cf8b337cc1d1b4ce57e379b83d5558b7f68b87ba", "url": "https://github.com/hortonworks/cloudbreak/commit/cf8b337cc1d1b4ce57e379b83d5558b7f68b87ba", "message": "CB-7096: Add downscaling FreeIPA for recovery of non-CRL master nodes\n\nWhen an non-CRL master fails, the recovery should perform a downscale.\nThe process includes:\n  * Updating cluster proxy registration so that it does not include\n    the node\n  * Attempting to gracefully stop telemetry on the node\n  * Terminating the cloud provider instance\n  * Removing the server from FreeIPA replication agreements and hosts\n  * Revoking the host's certificate\n  * Removing the DNS entries including A records, PTR records, SRV\n    records, and PTR records\n  * Remove the instance from salt orchestration including both salt\n    masters and salt minions\n  * Update the metadata for the instance and stack\n\nThis will not clean up the /etc/hosts file which will still include\nreferences to downscaled freeipa instances. If it were to clean up the\n/etc/hosts file using the hosts.absent salt rule then the instance\nstill would need a list of all the failed hosts on the node. It\ndoesn't seem particularly problematic to keep the old hosts in the\nfile.\n\nThis was tested with the added tests and it was also tested manually\nby downscaling a 2 node FreeIPA cluster to 1 node. The primary gateway\nwas the CA master & CRL master and that node was kept.", "committedDate": "2020-06-04T18:43:55Z", "type": "commit"}, {"oid": "cf8b337cc1d1b4ce57e379b83d5558b7f68b87ba", "url": "https://github.com/hortonworks/cloudbreak/commit/cf8b337cc1d1b4ce57e379b83d5558b7f68b87ba", "message": "CB-7096: Add downscaling FreeIPA for recovery of non-CRL master nodes\n\nWhen an non-CRL master fails, the recovery should perform a downscale.\nThe process includes:\n  * Updating cluster proxy registration so that it does not include\n    the node\n  * Attempting to gracefully stop telemetry on the node\n  * Terminating the cloud provider instance\n  * Removing the server from FreeIPA replication agreements and hosts\n  * Revoking the host's certificate\n  * Removing the DNS entries including A records, PTR records, SRV\n    records, and PTR records\n  * Remove the instance from salt orchestration including both salt\n    masters and salt minions\n  * Update the metadata for the instance and stack\n\nThis will not clean up the /etc/hosts file which will still include\nreferences to downscaled freeipa instances. If it were to clean up the\n/etc/hosts file using the hosts.absent salt rule then the instance\nstill would need a list of all the failed hosts on the node. It\ndoesn't seem particularly problematic to keep the old hosts in the\nfile.\n\nThis was tested with the added tests and it was also tested manually\nby downscaling a 2 node FreeIPA cluster to 1 node. The primary gateway\nwas the CA master & CRL master and that node was kept.", "committedDate": "2020-06-04T18:43:55Z", "type": "forcePushed"}]}