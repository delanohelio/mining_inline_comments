{"pr_number": 8460, "pr_title": "fix paralel image copy", "pr_createdAt": "2020-06-30T11:59:58Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/8460", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY2NzQ1NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8460#discussion_r447667455", "bodyText": "pls use @service for services", "author": "pdarvasi", "createdAt": "2020-06-30T13:07:59Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/AzureStorageAccountService.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.sequenceiq.cloudbreak.cloud.azure;\n+\n+import static com.sequenceiq.cloudbreak.cloud.azure.AzureDiskType.LOCALLY_REDUNDANT;\n+import static com.sequenceiq.cloudbreak.cloud.azure.AzureStorage.IMAGES_CONTAINER;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.microsoft.azure.CloudException;\n+import com.microsoft.azure.management.storage.StorageAccount;\n+import com.sequenceiq.cloudbreak.cloud.azure.client.AzureClient;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.AzurePollTaskFactory;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.storageaccount.StorageAccountCheckerContext;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.SyncPollingScheduler;\n+import com.sequenceiq.cloudbreak.cloud.task.PollTask;\n+\n+@Component", "originalCommit": "418307affc909e0c029dfbddd99783385439ac84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY3MDk5Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8460#discussion_r447670996", "bodyText": "pls. use a separate method for this or rename this one to indicate that it is doing this, too", "author": "pdarvasi", "createdAt": "2020-06-30T13:13:20Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/AzureStorageAccountService.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.sequenceiq.cloudbreak.cloud.azure;\n+\n+import static com.sequenceiq.cloudbreak.cloud.azure.AzureDiskType.LOCALLY_REDUNDANT;\n+import static com.sequenceiq.cloudbreak.cloud.azure.AzureStorage.IMAGES_CONTAINER;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.microsoft.azure.CloudException;\n+import com.microsoft.azure.management.storage.StorageAccount;\n+import com.sequenceiq.cloudbreak.cloud.azure.client.AzureClient;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.AzurePollTaskFactory;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.storageaccount.StorageAccountCheckerContext;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.SyncPollingScheduler;\n+import com.sequenceiq.cloudbreak.cloud.task.PollTask;\n+\n+@Component\n+public class AzureStorageAccountService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AzureStorageAccountService.class);\n+\n+    private static final int STORAGE_ACCOUNT_CREATION_CHECKING_INTERVAL = 1000;\n+\n+    private static final int STORAGE_ACCOUNT_CREATION_CHECKING_MAX_ATTEMPT = 30;\n+\n+    @Inject\n+    private AzurePollTaskFactory azurePollTaskFactory;\n+\n+    @Inject\n+    private SyncPollingScheduler syncPollingScheduler;\n+\n+    @Inject\n+    private AzureStorage armStorage;\n+\n+    public void createStorageAccount(AuthenticatedContext ac, AzureClient client, String resourceGroup, String storageName, String region, CloudStack stack) {\n+        StorageAccount storageAccount = client.getStorageAccountByGroup(resourceGroup, storageName);\n+        if (storageAccount == null) {\n+            try {\n+                LOGGER.info(\"Creating storage account: {}\", storageName);\n+                armStorage.createStorage(client, storageName, LOCALLY_REDUNDANT, resourceGroup, region, isEncryptionNeeded(stack), stack.getTags());\n+                pollStorageAccountCreation(ac, new StorageAccountCheckerContext(client, resourceGroup, storageName));\n+                LOGGER.info(\"Creating container: {} in storage storage account: {}\", IMAGES_CONTAINER, storageName);\n+                client.createContainerInStorage(resourceGroup, storageName, IMAGES_CONTAINER);", "originalCommit": "418307affc909e0c029dfbddd99783385439ac84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY3MzU0Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8460#discussion_r447673543", "bodyText": "This causes the deployment to fail, don't we want to rethrow or retry?", "author": "pdarvasi", "createdAt": "2020-06-30T13:17:15Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/AzureStorageAccountService.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.sequenceiq.cloudbreak.cloud.azure;\n+\n+import static com.sequenceiq.cloudbreak.cloud.azure.AzureDiskType.LOCALLY_REDUNDANT;\n+import static com.sequenceiq.cloudbreak.cloud.azure.AzureStorage.IMAGES_CONTAINER;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.microsoft.azure.CloudException;\n+import com.microsoft.azure.management.storage.StorageAccount;\n+import com.sequenceiq.cloudbreak.cloud.azure.client.AzureClient;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.AzurePollTaskFactory;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.storageaccount.StorageAccountCheckerContext;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.SyncPollingScheduler;\n+import com.sequenceiq.cloudbreak.cloud.task.PollTask;\n+\n+@Component\n+public class AzureStorageAccountService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AzureStorageAccountService.class);\n+\n+    private static final int STORAGE_ACCOUNT_CREATION_CHECKING_INTERVAL = 1000;\n+\n+    private static final int STORAGE_ACCOUNT_CREATION_CHECKING_MAX_ATTEMPT = 30;\n+\n+    @Inject\n+    private AzurePollTaskFactory azurePollTaskFactory;\n+\n+    @Inject\n+    private SyncPollingScheduler syncPollingScheduler;\n+\n+    @Inject\n+    private AzureStorage armStorage;\n+\n+    public void createStorageAccount(AuthenticatedContext ac, AzureClient client, String resourceGroup, String storageName, String region, CloudStack stack) {\n+        StorageAccount storageAccount = client.getStorageAccountByGroup(resourceGroup, storageName);\n+        if (storageAccount == null) {\n+            try {\n+                LOGGER.info(\"Creating storage account: {}\", storageName);\n+                armStorage.createStorage(client, storageName, LOCALLY_REDUNDANT, resourceGroup, region, isEncryptionNeeded(stack), stack.getTags());\n+                pollStorageAccountCreation(ac, new StorageAccountCheckerContext(client, resourceGroup, storageName));\n+                LOGGER.info(\"Creating container: {} in storage storage account: {}\", IMAGES_CONTAINER, storageName);\n+                client.createContainerInStorage(resourceGroup, storageName, IMAGES_CONTAINER);\n+            } catch (CloudException e) {\n+                LOGGER.warn(\"Error during storage account creation: {}.\", storageName, e);", "originalCommit": "418307affc909e0c029dfbddd99783385439ac84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY3NTQ0NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8460#discussion_r447675445", "bodyText": "Do we want to tolerate only 1 failure?", "author": "pdarvasi", "createdAt": "2020-06-30T13:19:59Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/AzureStorageAccountService.java", "diffHunk": "@@ -0,0 +1,71 @@\n+package com.sequenceiq.cloudbreak.cloud.azure;\n+\n+import static com.sequenceiq.cloudbreak.cloud.azure.AzureDiskType.LOCALLY_REDUNDANT;\n+import static com.sequenceiq.cloudbreak.cloud.azure.AzureStorage.IMAGES_CONTAINER;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.microsoft.azure.CloudException;\n+import com.microsoft.azure.management.storage.StorageAccount;\n+import com.sequenceiq.cloudbreak.cloud.azure.client.AzureClient;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.AzurePollTaskFactory;\n+import com.sequenceiq.cloudbreak.cloud.azure.task.storageaccount.StorageAccountCheckerContext;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.SyncPollingScheduler;\n+import com.sequenceiq.cloudbreak.cloud.task.PollTask;\n+\n+@Component\n+public class AzureStorageAccountService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AzureStorageAccountService.class);\n+\n+    private static final int STORAGE_ACCOUNT_CREATION_CHECKING_INTERVAL = 1000;\n+\n+    private static final int STORAGE_ACCOUNT_CREATION_CHECKING_MAX_ATTEMPT = 30;\n+\n+    @Inject\n+    private AzurePollTaskFactory azurePollTaskFactory;\n+\n+    @Inject\n+    private SyncPollingScheduler syncPollingScheduler;\n+\n+    @Inject\n+    private AzureStorage armStorage;\n+\n+    public void createStorageAccount(AuthenticatedContext ac, AzureClient client, String resourceGroup, String storageName, String region, CloudStack stack) {\n+        StorageAccount storageAccount = client.getStorageAccountByGroup(resourceGroup, storageName);\n+        if (storageAccount == null) {\n+            try {\n+                LOGGER.info(\"Creating storage account: {}\", storageName);\n+                armStorage.createStorage(client, storageName, LOCALLY_REDUNDANT, resourceGroup, region, isEncryptionNeeded(stack), stack.getTags());\n+                pollStorageAccountCreation(ac, new StorageAccountCheckerContext(client, resourceGroup, storageName));\n+                LOGGER.info(\"Creating container: {} in storage storage account: {}\", IMAGES_CONTAINER, storageName);\n+                client.createContainerInStorage(resourceGroup, storageName, IMAGES_CONTAINER);\n+            } catch (CloudException e) {\n+                LOGGER.warn(\"Error during storage account creation: {}.\", storageName, e);\n+            }\n+        } else {\n+            LOGGER.info(\"Storage account {} already exist in resource group {}\", storageName, resourceGroup);\n+        }\n+    }\n+\n+    private void pollStorageAccountCreation(AuthenticatedContext ac, StorageAccountCheckerContext checkerContext) {\n+        PollTask<Boolean> storageAccountCreationStatusCheckerTask = azurePollTaskFactory.storageAccountCheckerTask(ac, checkerContext);\n+        try {\n+            LOGGER.info(\"Start polling storage account creation: {}\", checkerContext.getStorageAccountName());\n+            syncPollingScheduler.schedule(storageAccountCreationStatusCheckerTask, STORAGE_ACCOUNT_CREATION_CHECKING_INTERVAL,\n+                    STORAGE_ACCOUNT_CREATION_CHECKING_MAX_ATTEMPT, 1);", "originalCommit": "418307affc909e0c029dfbddd99783385439ac84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY3NjUzMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8460#discussion_r447676533", "bodyText": "pls use @service for services", "author": "pdarvasi", "createdAt": "2020-06-30T13:21:30Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageSetupService.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.image;\n+\n+import static com.sequenceiq.cloudbreak.cloud.azure.AzureStorage.IMAGES_CONTAINER;\n+\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+import org.springframework.util.StringUtils;\n+\n+import com.microsoft.azure.storage.blob.CopyState;\n+import com.microsoft.azure.storage.blob.CopyStatus;\n+import com.microsoft.azure.storage.blob.ListBlobItem;\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureResourceGroupMetadataProvider;\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureStorage;\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureStorageAccountService;\n+import com.sequenceiq.cloudbreak.cloud.azure.client.AzureClient;\n+import com.sequenceiq.cloudbreak.cloud.azure.view.AzureCredentialView;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.exception.CloudConnectorException;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n+import com.sequenceiq.cloudbreak.cloud.model.Image;\n+import com.sequenceiq.common.api.type.ImageStatus;\n+import com.sequenceiq.common.api.type.ImageStatusResult;\n+\n+@Component", "originalCommit": "418307affc909e0c029dfbddd99783385439ac84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY3ODA5NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8460#discussion_r447678094", "bodyText": "pls. log this", "author": "pdarvasi", "createdAt": "2020-06-30T13:23:38Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageSetupService.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.image;\n+\n+import static com.sequenceiq.cloudbreak.cloud.azure.AzureStorage.IMAGES_CONTAINER;\n+\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+import org.springframework.util.StringUtils;\n+\n+import com.microsoft.azure.storage.blob.CopyState;\n+import com.microsoft.azure.storage.blob.CopyStatus;\n+import com.microsoft.azure.storage.blob.ListBlobItem;\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureResourceGroupMetadataProvider;\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureStorage;\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureStorageAccountService;\n+import com.sequenceiq.cloudbreak.cloud.azure.client.AzureClient;\n+import com.sequenceiq.cloudbreak.cloud.azure.view.AzureCredentialView;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.exception.CloudConnectorException;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n+import com.sequenceiq.cloudbreak.cloud.model.Image;\n+import com.sequenceiq.common.api.type.ImageStatus;\n+import com.sequenceiq.common.api.type.ImageStatusResult;\n+\n+@Component\n+public class AzureImageSetupService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AzureImageSetupService.class);\n+\n+    @Inject\n+    private AzureStorage armStorage;\n+\n+    @Inject\n+    private AzureResourceGroupMetadataProvider azureResourceGroupMetadataProvider;\n+\n+    @Inject\n+    private AzureStorageAccountService azureStorageAccountService;\n+\n+    public ImageStatusResult checkImageStatus(AuthenticatedContext ac, CloudStack stack, Image image) {\n+        String imageResourceGroupName = azureResourceGroupMetadataProvider.getImageResourceGroupName(ac.getCloudContext(), stack);\n+        AzureClient client = ac.getParameter(AzureClient.class);\n+\n+        AzureCredentialView acv = new AzureCredentialView(ac.getCloudCredential());\n+        String imageStorageName = armStorage.getImageStorageName(acv, ac.getCloudContext(), stack);\n+        try {\n+            CopyState copyState = client.getCopyStatus(imageResourceGroupName, imageStorageName, IMAGES_CONTAINER, image.getImageName());\n+            if (CopyStatus.SUCCESS.equals(copyState.getStatus())) {\n+                if (StringUtils.isEmpty(armStorage.getCustomImageId(client, ac, stack))) {\n+                    return new ImageStatusResult(ImageStatus.CREATE_FAILED, ImageStatusResult.COMPLETED);", "originalCommit": "418307affc909e0c029dfbddd99783385439ac84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY3ODkyOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8460#discussion_r447678929", "bodyText": "pls log this", "author": "pdarvasi", "createdAt": "2020-06-30T13:24:48Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageSetupService.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.image;\n+\n+import static com.sequenceiq.cloudbreak.cloud.azure.AzureStorage.IMAGES_CONTAINER;\n+\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+import org.springframework.util.StringUtils;\n+\n+import com.microsoft.azure.storage.blob.CopyState;\n+import com.microsoft.azure.storage.blob.CopyStatus;\n+import com.microsoft.azure.storage.blob.ListBlobItem;\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureResourceGroupMetadataProvider;\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureStorage;\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureStorageAccountService;\n+import com.sequenceiq.cloudbreak.cloud.azure.client.AzureClient;\n+import com.sequenceiq.cloudbreak.cloud.azure.view.AzureCredentialView;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.exception.CloudConnectorException;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n+import com.sequenceiq.cloudbreak.cloud.model.Image;\n+import com.sequenceiq.common.api.type.ImageStatus;\n+import com.sequenceiq.common.api.type.ImageStatusResult;\n+\n+@Component\n+public class AzureImageSetupService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AzureImageSetupService.class);\n+\n+    @Inject\n+    private AzureStorage armStorage;\n+\n+    @Inject\n+    private AzureResourceGroupMetadataProvider azureResourceGroupMetadataProvider;\n+\n+    @Inject\n+    private AzureStorageAccountService azureStorageAccountService;\n+\n+    public ImageStatusResult checkImageStatus(AuthenticatedContext ac, CloudStack stack, Image image) {\n+        String imageResourceGroupName = azureResourceGroupMetadataProvider.getImageResourceGroupName(ac.getCloudContext(), stack);\n+        AzureClient client = ac.getParameter(AzureClient.class);\n+\n+        AzureCredentialView acv = new AzureCredentialView(ac.getCloudCredential());\n+        String imageStorageName = armStorage.getImageStorageName(acv, ac.getCloudContext(), stack);\n+        try {\n+            CopyState copyState = client.getCopyStatus(imageResourceGroupName, imageStorageName, IMAGES_CONTAINER, image.getImageName());\n+            if (CopyStatus.SUCCESS.equals(copyState.getStatus())) {\n+                if (StringUtils.isEmpty(armStorage.getCustomImageId(client, ac, stack))) {\n+                    return new ImageStatusResult(ImageStatus.CREATE_FAILED, ImageStatusResult.COMPLETED);\n+                }\n+                return new ImageStatusResult(ImageStatus.CREATE_FINISHED, ImageStatusResult.COMPLETED);\n+            } else if (CopyStatus.ABORTED.equals(copyState.getStatus()) || CopyStatus.INVALID.equals(copyState.getStatus())) {\n+                return new ImageStatusResult(ImageStatus.CREATE_FAILED, 0);", "originalCommit": "418307affc909e0c029dfbddd99783385439ac84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY4MTYwMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8460#discussion_r447681602", "bodyText": "pls log the \"else\" cause of this if", "author": "pdarvasi", "createdAt": "2020-06-30T13:28:21Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageSetupService.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.image;\n+\n+import static com.sequenceiq.cloudbreak.cloud.azure.AzureStorage.IMAGES_CONTAINER;\n+\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+import org.springframework.util.StringUtils;\n+\n+import com.microsoft.azure.storage.blob.CopyState;\n+import com.microsoft.azure.storage.blob.CopyStatus;\n+import com.microsoft.azure.storage.blob.ListBlobItem;\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureResourceGroupMetadataProvider;\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureStorage;\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureStorageAccountService;\n+import com.sequenceiq.cloudbreak.cloud.azure.client.AzureClient;\n+import com.sequenceiq.cloudbreak.cloud.azure.view.AzureCredentialView;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.exception.CloudConnectorException;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n+import com.sequenceiq.cloudbreak.cloud.model.Image;\n+import com.sequenceiq.common.api.type.ImageStatus;\n+import com.sequenceiq.common.api.type.ImageStatusResult;\n+\n+@Component\n+public class AzureImageSetupService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AzureImageSetupService.class);\n+\n+    @Inject\n+    private AzureStorage armStorage;\n+\n+    @Inject\n+    private AzureResourceGroupMetadataProvider azureResourceGroupMetadataProvider;\n+\n+    @Inject\n+    private AzureStorageAccountService azureStorageAccountService;\n+\n+    public ImageStatusResult checkImageStatus(AuthenticatedContext ac, CloudStack stack, Image image) {\n+        String imageResourceGroupName = azureResourceGroupMetadataProvider.getImageResourceGroupName(ac.getCloudContext(), stack);\n+        AzureClient client = ac.getParameter(AzureClient.class);\n+\n+        AzureCredentialView acv = new AzureCredentialView(ac.getCloudCredential());\n+        String imageStorageName = armStorage.getImageStorageName(acv, ac.getCloudContext(), stack);\n+        try {\n+            CopyState copyState = client.getCopyStatus(imageResourceGroupName, imageStorageName, IMAGES_CONTAINER, image.getImageName());\n+            if (CopyStatus.SUCCESS.equals(copyState.getStatus())) {\n+                if (StringUtils.isEmpty(armStorage.getCustomImageId(client, ac, stack))) {\n+                    return new ImageStatusResult(ImageStatus.CREATE_FAILED, ImageStatusResult.COMPLETED);\n+                }\n+                return new ImageStatusResult(ImageStatus.CREATE_FINISHED, ImageStatusResult.COMPLETED);\n+            } else if (CopyStatus.ABORTED.equals(copyState.getStatus()) || CopyStatus.INVALID.equals(copyState.getStatus())) {\n+                return new ImageStatusResult(ImageStatus.CREATE_FAILED, 0);\n+            } else {\n+                int percentage = (int) (((double) copyState.getBytesCopied() * ImageStatusResult.COMPLETED) / copyState.getTotalBytes());\n+                LOGGER.info(\"CopyStatus, Total:{} / Pending:{} bytes, {}%\", copyState.getTotalBytes(), copyState.getBytesCopied(), percentage);\n+                return new ImageStatusResult(ImageStatus.IN_PROGRESS, percentage);\n+            }\n+        } catch (RuntimeException ex) {\n+            String msg = String.format(\"Failed to check the status of the image in resource group '%s', image storage name '%s'\",\n+                    imageResourceGroupName, imageStorageName);\n+            LOGGER.warn(msg, ex);\n+            return new ImageStatusResult(ImageStatus.IN_PROGRESS, ImageStatusResult.HALF);\n+        }\n+    }\n+\n+    public void copyVhdImageIfNecessary(AuthenticatedContext ac, CloudStack stack, Image image, String region, AzureClient client) {\n+        CloudContext cloudContext = ac.getCloudContext();\n+        String resourceGroupName = azureResourceGroupMetadataProvider.getResourceGroupName(cloudContext, stack);\n+        String imageStorageName = armStorage.getImageStorageName(new AzureCredentialView(ac.getCloudCredential()), cloudContext, stack);\n+        String imageResourceGroupName = azureResourceGroupMetadataProvider.getImageResourceGroupName(cloudContext, stack);\n+\n+        createResourceGroupIfNotExists(client, resourceGroupName, region, stack);\n+        createResourceGroupIfNotExists(client, imageResourceGroupName, region, stack);\n+        azureStorageAccountService.createStorageAccount(ac, client, imageResourceGroupName, imageStorageName, region, stack);\n+        if (!storageContainsImage(client, imageResourceGroupName, imageStorageName, image.getImageName())) {", "originalCommit": "418307affc909e0c029dfbddd99783385439ac84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ0NzY4MzI0MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8460#discussion_r447683241", "bodyText": "you can use getNameFromConnectionString for the image, too", "author": "pdarvasi", "createdAt": "2020-06-30T13:30:18Z", "path": "cloud-azure/src/main/java/com/sequenceiq/cloudbreak/cloud/azure/image/AzureImageSetupService.java", "diffHunk": "@@ -0,0 +1,112 @@\n+package com.sequenceiq.cloudbreak.cloud.azure.image;\n+\n+import static com.sequenceiq.cloudbreak.cloud.azure.AzureStorage.IMAGES_CONTAINER;\n+\n+import java.util.List;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+import org.springframework.util.StringUtils;\n+\n+import com.microsoft.azure.storage.blob.CopyState;\n+import com.microsoft.azure.storage.blob.CopyStatus;\n+import com.microsoft.azure.storage.blob.ListBlobItem;\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureResourceGroupMetadataProvider;\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureStorage;\n+import com.sequenceiq.cloudbreak.cloud.azure.AzureStorageAccountService;\n+import com.sequenceiq.cloudbreak.cloud.azure.client.AzureClient;\n+import com.sequenceiq.cloudbreak.cloud.azure.view.AzureCredentialView;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.exception.CloudConnectorException;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n+import com.sequenceiq.cloudbreak.cloud.model.Image;\n+import com.sequenceiq.common.api.type.ImageStatus;\n+import com.sequenceiq.common.api.type.ImageStatusResult;\n+\n+@Component\n+public class AzureImageSetupService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AzureImageSetupService.class);\n+\n+    @Inject\n+    private AzureStorage armStorage;\n+\n+    @Inject\n+    private AzureResourceGroupMetadataProvider azureResourceGroupMetadataProvider;\n+\n+    @Inject\n+    private AzureStorageAccountService azureStorageAccountService;\n+\n+    public ImageStatusResult checkImageStatus(AuthenticatedContext ac, CloudStack stack, Image image) {\n+        String imageResourceGroupName = azureResourceGroupMetadataProvider.getImageResourceGroupName(ac.getCloudContext(), stack);\n+        AzureClient client = ac.getParameter(AzureClient.class);\n+\n+        AzureCredentialView acv = new AzureCredentialView(ac.getCloudCredential());\n+        String imageStorageName = armStorage.getImageStorageName(acv, ac.getCloudContext(), stack);\n+        try {\n+            CopyState copyState = client.getCopyStatus(imageResourceGroupName, imageStorageName, IMAGES_CONTAINER, image.getImageName());\n+            if (CopyStatus.SUCCESS.equals(copyState.getStatus())) {\n+                if (StringUtils.isEmpty(armStorage.getCustomImageId(client, ac, stack))) {\n+                    return new ImageStatusResult(ImageStatus.CREATE_FAILED, ImageStatusResult.COMPLETED);\n+                }\n+                return new ImageStatusResult(ImageStatus.CREATE_FINISHED, ImageStatusResult.COMPLETED);\n+            } else if (CopyStatus.ABORTED.equals(copyState.getStatus()) || CopyStatus.INVALID.equals(copyState.getStatus())) {\n+                return new ImageStatusResult(ImageStatus.CREATE_FAILED, 0);\n+            } else {\n+                int percentage = (int) (((double) copyState.getBytesCopied() * ImageStatusResult.COMPLETED) / copyState.getTotalBytes());\n+                LOGGER.info(\"CopyStatus, Total:{} / Pending:{} bytes, {}%\", copyState.getTotalBytes(), copyState.getBytesCopied(), percentage);\n+                return new ImageStatusResult(ImageStatus.IN_PROGRESS, percentage);\n+            }\n+        } catch (RuntimeException ex) {\n+            String msg = String.format(\"Failed to check the status of the image in resource group '%s', image storage name '%s'\",\n+                    imageResourceGroupName, imageStorageName);\n+            LOGGER.warn(msg, ex);\n+            return new ImageStatusResult(ImageStatus.IN_PROGRESS, ImageStatusResult.HALF);\n+        }\n+    }\n+\n+    public void copyVhdImageIfNecessary(AuthenticatedContext ac, CloudStack stack, Image image, String region, AzureClient client) {\n+        CloudContext cloudContext = ac.getCloudContext();\n+        String resourceGroupName = azureResourceGroupMetadataProvider.getResourceGroupName(cloudContext, stack);\n+        String imageStorageName = armStorage.getImageStorageName(new AzureCredentialView(ac.getCloudCredential()), cloudContext, stack);\n+        String imageResourceGroupName = azureResourceGroupMetadataProvider.getImageResourceGroupName(cloudContext, stack);\n+\n+        createResourceGroupIfNotExists(client, resourceGroupName, region, stack);\n+        createResourceGroupIfNotExists(client, imageResourceGroupName, region, stack);\n+        azureStorageAccountService.createStorageAccount(ac, client, imageResourceGroupName, imageStorageName, region, stack);\n+        if (!storageContainsImage(client, imageResourceGroupName, imageStorageName, image.getImageName())) {\n+            try {\n+                LOGGER.info(\"Starting to copy image: {}, into storage account: {}\", image.getImageName(), imageStorageName);\n+                client.copyImageBlobInStorageContainer(imageResourceGroupName, imageStorageName, IMAGES_CONTAINER, image.getImageName());\n+            } catch (CloudConnectorException e) {\n+                LOGGER.warn(\"Something happened during start image copy.\", e);\n+            }\n+        }\n+    }\n+\n+    private boolean storageContainsImage(AzureClient client, String resourceGroupName, String storageName, String image) {\n+        List<ListBlobItem> listBlobItems = client.listBlobInStorage(resourceGroupName, storageName, IMAGES_CONTAINER);\n+        for (ListBlobItem listBlobItem : listBlobItems) {\n+            if (getNameFromConnectionString(listBlobItem.getUri().getPath()).equals(image.split(\"/\")[image.split(\"/\").length - 1])) {", "originalCommit": "418307affc909e0c029dfbddd99783385439ac84", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "6f7e1289e1919c7f281a0a4aa1eb1dbaa73def1a", "url": "https://github.com/hortonworks/cloudbreak/commit/6f7e1289e1919c7f281a0a4aa1eb1dbaa73def1a", "message": "fix paralel image copy", "committedDate": "2020-06-30T15:00:19Z", "type": "commit"}, {"oid": "6f7e1289e1919c7f281a0a4aa1eb1dbaa73def1a", "url": "https://github.com/hortonworks/cloudbreak/commit/6f7e1289e1919c7f281a0a4aa1eb1dbaa73def1a", "message": "fix paralel image copy", "committedDate": "2020-06-30T15:00:19Z", "type": "forcePushed"}]}