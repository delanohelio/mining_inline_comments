{"pr_number": 9010, "pr_title": "CDPCP-2990. User sync uses bulk UMS api ", "pr_createdAt": "2020-09-14T20:44:42Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/9010", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3MzgzNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r488273837", "bodyText": "This doc string isn't correct.", "author": "aarman-cloudera", "createdAt": "2020-09-14T22:37:38Z", "path": "auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/GrpcUmsClient.java", "diffHunk": "@@ -779,6 +781,24 @@ public GetEventGenerationIdsResponse getEventGenerationIds(String actorCrn, Stri\n         }\n     }\n \n+    /**\n+     * Retrieves user sync state model from UMS.\n+     *\n+     * @param accountId        the account Id\n+     * @param requestId        an optional request Id\n+     * @param rightsChecksList list of mapping from resources to lists of rights to check. Lists are used to\n+     *                         preserve order.\n+     * @return the user associated with this user CRN", "originalCommit": "2099a2d2e3fd0f709bc491ac167110d297567c84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc4Nzg2MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r488787861", "bodyText": "fixed", "author": "handavid", "createdAt": "2020-09-15T16:07:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3MzgzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3NDUyMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r488274522", "bodyText": "List<Pair<String, List<String>>> is a bit hard to read, maybe turn this into\nList<RightsCheck> (adding a new RightsCheck class)?", "author": "aarman-cloudera", "createdAt": "2020-09-14T22:38:32Z", "path": "auth-connector/src/main/java/com/sequenceiq/cloudbreak/auth/altus/UmsClient.java", "diffHunk": "@@ -783,4 +787,29 @@ public String getIdentityProviderMetadataXml(String requestId, String accountId)\n         }\n         return assignee.build();\n     }\n+\n+    /**\n+     * Retrieves user sync state model from the UMS.\n+     *\n+     * @param requestId          the request ID for the request\n+     * @param accountId          the account ID\n+     * @param rightsChecksList   list of mapping from resources to lists of rights to check. Lists are used to\n+     *                           preserve order.\n+     * @return the user sync state model\n+     */\n+    public GetUserSyncStateModelResponse getUserSyncStateModel(\n+            String requestId, String accountId, List<Pair<String, List<String>>> rightsChecksList) {", "originalCommit": "2099a2d2e3fd0f709bc491ac167110d297567c84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODgwNTIzNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r488805236", "bodyText": "We already have some UserManagementProto classes in the GrpcUmsClient. I'll just expose the RightsCheck class all the way out.", "author": "handavid", "createdAt": "2020-09-15T16:34:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3NDUyMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3NjE2Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r488276163", "bodyText": "nit: Any reason getUmsUsersStateMapBulk and getUmsUsersStateMap needs to\nreturn a Builder instead of the built UmsUserState?", "author": "aarman-cloudera", "createdAt": "2020-09-14T22:40:37Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java", "diffHunk": "@@ -54,92 +77,232 @@\n     @Inject\n     private UmsRightProvider umsRightProvider;\n \n-    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(String accountId, String actorCrn, Set<String> environmentCrns,\n-        Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n+    @Inject\n+    private EntitlementService entitlementService;\n+\n+    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(\n+            String accountId, String actorCrn, Collection<String> environmentCrns,\n+            Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n         try {\n             LOGGER.debug(\"Getting UMS state for environments {} with requestId {}\", environmentCrns, requestIdOptional);\n \n-            Map<String, UmsUsersState> envUsersStateMap = new HashMap<>();\n-\n             boolean fullSync = userCrns.isEmpty() && machineUserCrns.isEmpty();\n \n-            List<User> users = getUsers(actorCrn, accountId, requestIdOptional, fullSync, userCrns);\n-\n-            List<MachineUser> machineUsers = getMachineUsers(actorCrn, accountId, requestIdOptional, fullSync, machineUserCrns);\n-\n-            Map<String, FmsGroup> crnToFmsGroup = grpcUmsClient.listGroups(actorCrn, accountId, List.of(), requestIdOptional).stream()\n-                    .collect(Collectors.toMap(Group::getCrn, this::umsGroupToGroup));\n-\n-            Map<WorkloadAdministrationGroup, FmsGroup> wags = grpcUmsClient.listWorkloadAdministrationGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional)\n-                    .stream()\n-                    .collect(Collectors.toMap(wag -> wag, wag -> nameToGroup(wag.getWorkloadAdministrationGroupName())));\n-            environmentCrns.forEach(environmentCrn -> {\n-                UmsUsersState.Builder umsUsersStateBuilder = new UmsUsersState.Builder()\n-                        .setWorkloadAdministrationGroups(wags.values());\n-\n-                UsersState.Builder usersStateBuilder = new UsersState.Builder();\n-                Set<String> wagNamesForOtherEnvironments = new HashSet<>();\n-\n-                crnToFmsGroup.values().forEach(usersStateBuilder::addGroup);\n-\n-                // Only add workload admin groups that belong to this environment.\n-                // At the same time, build a set of workload admin groups that are\n-                // associated with other environments so we can filter these out in\n-                // the per-user group listing in handleUser.\n-                wags.entrySet().forEach(wagEntry -> {\n-                    WorkloadAdministrationGroup wag = wagEntry.getKey();\n-                    String groupName = wag.getWorkloadAdministrationGroupName();\n-                    if (wag.getResource().equalsIgnoreCase(environmentCrn)) {\n-                        usersStateBuilder.addGroup(wagEntry.getValue());\n-                    } else {\n-                        Crn resourceCrn = getCrn(wag);\n-                        if (resourceCrn != null && resourceCrn.getService() == Crn.Service.ENVIRONMENTS\n-                                && resourceCrn.getResourceType() == ResourceType.ENVIRONMENT) {\n-                            wagNamesForOtherEnvironments.add(groupName);\n-                        }\n-                    }\n-                });\n+            Map<String, UmsUsersState.Builder> envUsersStateMap;", "originalCommit": "2099a2d2e3fd0f709bc491ac167110d297567c84", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODc4ODE3Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r488788177", "bodyText": "nope. fixed", "author": "handavid", "createdAt": "2020-09-15T16:08:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODI3NjE2Mw=="}], "type": "inlineReview"}, {"oid": "73d6dc30ed172b314b02349317c6ab811980703c", "url": "https://github.com/hortonworks/cloudbreak/commit/73d6dc30ed172b314b02349317c6ab811980703c", "message": "CDPCP-2990. User sync uses bulk UMS api\n\nThe UMS introduced an API that returns the user sync state\nfrom the UMS in one request. This is used to avoid the many\nnetwork roundtrips when the FMS builds the state through\nindividual UMS requests.\n\nChanges include:\n- Bulk of the changes are to the UmsUsersStateProvider. This has been refactored\n  to support using either the bulk api or individual apis for full sync. This\n  behavior is protected by an entitlement.\n- Unit tests were added to ensure that both codepaths yield the same results\n- usermanagement.proto and ums client classes  updated to include the new API\n- mock user management service updated to the changes in the GetRightsRequest\n- EventGenerationId code updated to use the shared model instead of the\n  individual fields\n- Fixed typo in CloudIdentitySyncService methods and tests", "committedDate": "2020-09-17T22:24:16Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkzMDM2MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r490930361", "bodyText": "please remove static", "author": "lacikaaa", "createdAt": "2020-09-18T12:57:29Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/EnvironmentAccessChecker.java", "diffHunk": "@@ -74,4 +67,18 @@ public EnvironmentAccessRights hasAccess(String memberCrn, Optional<String> requ\n \n         }\n     }\n+\n+    @VisibleForTesting\n+    static List<RightCheck> createRightCheck(UmsRightProvider umsRightProvider, String environmentCrn) {", "originalCommit": "73d6dc30ed172b314b02349317c6ab811980703c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MDc2Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492160763", "bodyText": "refactored into separate class", "author": "handavid", "createdAt": "2020-09-21T15:40:22Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkzMDM2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkzNjAyOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r490936028", "bodyText": "please refactor this class:\n\ninstead of static use @Component annotation and @Inject where you use it\nslice into 3 separate class for: FmsUser, FmsGroup and WorkloadCredential so each would have it's own responsibility", "author": "lacikaaa", "createdAt": "2020-09-18T13:07:12Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/model/Conversions.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.model;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+\n+import java.time.Instant;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+public class Conversions {", "originalCommit": "73d6dc30ed172b314b02349317c6ab811980703c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MDgzNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492160835", "bodyText": "done", "author": "handavid", "createdAt": "2020-09-21T15:40:30Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkzNjAyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkzNjYwNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r490936606", "bodyText": "this could be replaced with StringUtils.defaultIfBlank(final T str, final T defaultStr) from apache commons lang3", "author": "lacikaaa", "createdAt": "2020-09-18T13:08:12Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/model/Conversions.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.model;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.base.Strings;\n+\n+import java.time.Instant;\n+import java.util.Optional;\n+\n+import static com.google.common.base.Preconditions.checkArgument;\n+\n+public class Conversions {\n+\n+    @VisibleForTesting\n+    static final String NONE_STRING = \"None\";\n+\n+    private Conversions() {\n+    }\n+\n+    public static FmsUser toFmsUser(UserManagementProto.User umsUser) {\n+        return createFmsUser(umsUser.getWorkloadUsername(),\n+                umsUser.getFirstName(),\n+                umsUser.getLastName());\n+    }\n+\n+    public static FmsUser toFmsUser(UserManagementProto.MachineUser umsMachineUser) {\n+        // Machine users don't have a first and last name.\n+        // Store the machine user name and id instead.\n+        return createFmsUser(umsMachineUser.getWorkloadUsername(),\n+                umsMachineUser.getMachineUserName(),\n+                umsMachineUser.getMachineUserId());\n+    }\n+\n+    public static FmsUser toFmsUser(\n+            UserManagementProto.UserSyncActorDetails actorDetails) {\n+        return createFmsUser(actorDetails.getWorkloadUsername(),\n+                actorDetails.getFirstName(),\n+                actorDetails.getLastName());\n+    }\n+\n+    private static FmsUser createFmsUser(String workloadUsername, String firstName, String lastName) {\n+        checkArgument(!Strings.isNullOrEmpty(workloadUsername));\n+        FmsUser fmsUser = new FmsUser();\n+        fmsUser.withName(workloadUsername);\n+        fmsUser.withFirstName(orDefault(firstName, NONE_STRING));\n+        fmsUser.withLastName(orDefault(lastName, NONE_STRING));\n+        return fmsUser;\n+    }\n+\n+    public static FmsGroup umsGroupToGroup(UserManagementProto.Group umsGroup) {\n+        return nameToGroup(umsGroup.getGroupName());\n+    }\n+\n+    public static FmsGroup nameToGroup(String name) {\n+        checkArgument(!Strings.isNullOrEmpty(name));\n+        FmsGroup fmsGroup = new FmsGroup();\n+        fmsGroup.withName(name);\n+        return fmsGroup;\n+    }\n+\n+    private static String orDefault(String value, String other) {\n+        return (value == null || value.isBlank()) ? other : value;\n+    }", "originalCommit": "73d6dc30ed172b314b02349317c6ab811980703c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE1MzY0MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r491153641", "bodyText": "done", "author": "handavid", "createdAt": "2020-09-18T19:38:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDkzNjYwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk0MzE4Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r490943183", "bodyText": "why not stream environmentCrnList and collect the result into a map in the end?", "author": "lacikaaa", "createdAt": "2020-09-18T13:19:10Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java", "diffHunk": "@@ -54,92 +77,233 @@\n     @Inject\n     private UmsRightProvider umsRightProvider;\n \n-    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(String accountId, String actorCrn, Set<String> environmentCrns,\n-        Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n+    @Inject\n+    private EntitlementService entitlementService;\n+\n+    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(\n+            String accountId, String actorCrn, Collection<String> environmentCrns,\n+            Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n         try {\n             LOGGER.debug(\"Getting UMS state for environments {} with requestId {}\", environmentCrns, requestIdOptional);\n \n-            Map<String, UmsUsersState> envUsersStateMap = new HashMap<>();\n-\n             boolean fullSync = userCrns.isEmpty() && machineUserCrns.isEmpty();\n \n-            List<User> users = getUsers(actorCrn, accountId, requestIdOptional, fullSync, userCrns);\n-\n-            List<MachineUser> machineUsers = getMachineUsers(actorCrn, accountId, requestIdOptional, fullSync, machineUserCrns);\n-\n-            Map<String, FmsGroup> crnToFmsGroup = grpcUmsClient.listGroups(actorCrn, accountId, List.of(), requestIdOptional).stream()\n-                    .collect(Collectors.toMap(Group::getCrn, this::umsGroupToGroup));\n-\n-            Map<WorkloadAdministrationGroup, FmsGroup> wags = grpcUmsClient.listWorkloadAdministrationGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional)\n-                    .stream()\n-                    .collect(Collectors.toMap(wag -> wag, wag -> nameToGroup(wag.getWorkloadAdministrationGroupName())));\n-            environmentCrns.forEach(environmentCrn -> {\n-                UmsUsersState.Builder umsUsersStateBuilder = new UmsUsersState.Builder()\n-                        .setWorkloadAdministrationGroups(wags.values());\n-\n-                UsersState.Builder usersStateBuilder = new UsersState.Builder();\n-                Set<String> wagNamesForOtherEnvironments = new HashSet<>();\n-\n-                crnToFmsGroup.values().forEach(usersStateBuilder::addGroup);\n-\n-                // Only add workload admin groups that belong to this environment.\n-                // At the same time, build a set of workload admin groups that are\n-                // associated with other environments so we can filter these out in\n-                // the per-user group listing in handleUser.\n-                wags.entrySet().forEach(wagEntry -> {\n-                    WorkloadAdministrationGroup wag = wagEntry.getKey();\n-                    String groupName = wag.getWorkloadAdministrationGroupName();\n-                    if (wag.getResource().equalsIgnoreCase(environmentCrn)) {\n-                        usersStateBuilder.addGroup(wagEntry.getValue());\n-                    } else {\n-                        Crn resourceCrn = getCrn(wag);\n-                        if (resourceCrn != null && resourceCrn.getService() == Crn.Service.ENVIRONMENTS\n-                                && resourceCrn.getResourceType() == ResourceType.ENVIRONMENT) {\n-                            wagNamesForOtherEnvironments.add(groupName);\n-                        }\n-                    }\n-                });\n+            Map<String, UmsUsersState> envUsersStateMap;\n+            if (fullSync && entitlementService.umsUserSyncModelGenerationEnabled(INTERNAL_ACTOR_CRN, accountId)) {\n+                envUsersStateMap = getUmsUsersStateMapBulk(accountId, environmentCrns, requestIdOptional);\n+            } else {\n+                envUsersStateMap = getUmsUsersStateMap(\n+                        accountId, actorCrn,\n+                        environmentCrns, userCrns, machineUserCrns,\n+                        requestIdOptional, fullSync);\n+            }\n \n-                // Add internal usersync group for each environment\n-                usersStateBuilder.addGroup(nameToGroup(UserSyncConstants.CDP_USERSYNC_INTERNAL_GROUP));\n+            return envUsersStateMap;\n+        } catch (RuntimeException e) {\n+            throw new UmsOperationException(String.format(\"Error during UMS operation: '%s'\", e.getLocalizedMessage()), e);\n+        }\n+    }\n \n-                EnvironmentAccessChecker environmentAccessChecker = createEnvironmentAccessChecker(environmentCrn);\n+    @VisibleForTesting\n+    Map<String, UmsUsersState> getUmsUsersStateMapBulk(\n+            String accountId, Collection<String> environmentCrns, Optional<String> requestIdOptional) {\n+\n+        List<String> environmentCrnList = List.copyOf(environmentCrns);\n+        GetUserSyncStateModelResponse userSyncStateModel = grpcUmsClient.getUserSyncStateModel(\n+                INTERNAL_ACTOR_CRN,\n+                accountId,\n+                generateRightsChecksForEnvironments(environmentCrnList),\n+                requestIdOptional);\n+\n+        Map<String, FmsGroup> groups = convertGroupsToFmsGroups(userSyncStateModel.getGroupList());\n+        Map<WorkloadAdministrationGroup, FmsGroup> wags =\n+                convertWagsToFmsGroups(userSyncStateModel.getWorkloadAdministrationGroupList());\n+        List<String> requestedWorkloadUsernames = userSyncStateModel.getActorList().stream()\n+                .map(UserManagementProto.UserSyncActor::getActorDetails)\n+                .map(UserManagementProto.UserSyncActorDetails::getWorkloadUsername)\n+                .collect(Collectors.toList());\n+\n+        Map<String, UmsUsersState> umsUsersStateMap = Maps.newHashMap();\n+        IntStream.range(0, environmentCrnList.size())\n+                .forEach(environmentIndex -> {", "originalCommit": "73d6dc30ed172b314b02349317c6ab811980703c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTE1MzM3Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r491153376", "bodyText": "I need the index in the environmentCrnList to associate the RightsCheckResults to the correct environment. The bulk request includes a list of rights checks so we can potentially obtain the state for multiple environments at once. Using lists reduces the size of the response compared to using a map of environmentcrn to RightsCheckResults for each actor (i.e., omitting 1000s of the same environment crn string)", "author": "handavid", "createdAt": "2020-09-18T19:37:23Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk0MzE4Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4NDg1NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r490984854", "bodyText": "could you break this up into smaller ones? maybe move them to a separate class", "author": "lacikaaa", "createdAt": "2020-09-18T14:22:22Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java", "diffHunk": "@@ -54,92 +77,233 @@\n     @Inject\n     private UmsRightProvider umsRightProvider;\n \n-    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(String accountId, String actorCrn, Set<String> environmentCrns,\n-        Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n+    @Inject\n+    private EntitlementService entitlementService;\n+\n+    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(\n+            String accountId, String actorCrn, Collection<String> environmentCrns,\n+            Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n         try {\n             LOGGER.debug(\"Getting UMS state for environments {} with requestId {}\", environmentCrns, requestIdOptional);\n \n-            Map<String, UmsUsersState> envUsersStateMap = new HashMap<>();\n-\n             boolean fullSync = userCrns.isEmpty() && machineUserCrns.isEmpty();\n \n-            List<User> users = getUsers(actorCrn, accountId, requestIdOptional, fullSync, userCrns);\n-\n-            List<MachineUser> machineUsers = getMachineUsers(actorCrn, accountId, requestIdOptional, fullSync, machineUserCrns);\n-\n-            Map<String, FmsGroup> crnToFmsGroup = grpcUmsClient.listGroups(actorCrn, accountId, List.of(), requestIdOptional).stream()\n-                    .collect(Collectors.toMap(Group::getCrn, this::umsGroupToGroup));\n-\n-            Map<WorkloadAdministrationGroup, FmsGroup> wags = grpcUmsClient.listWorkloadAdministrationGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional)\n-                    .stream()\n-                    .collect(Collectors.toMap(wag -> wag, wag -> nameToGroup(wag.getWorkloadAdministrationGroupName())));\n-            environmentCrns.forEach(environmentCrn -> {\n-                UmsUsersState.Builder umsUsersStateBuilder = new UmsUsersState.Builder()\n-                        .setWorkloadAdministrationGroups(wags.values());\n-\n-                UsersState.Builder usersStateBuilder = new UsersState.Builder();\n-                Set<String> wagNamesForOtherEnvironments = new HashSet<>();\n-\n-                crnToFmsGroup.values().forEach(usersStateBuilder::addGroup);\n-\n-                // Only add workload admin groups that belong to this environment.\n-                // At the same time, build a set of workload admin groups that are\n-                // associated with other environments so we can filter these out in\n-                // the per-user group listing in handleUser.\n-                wags.entrySet().forEach(wagEntry -> {\n-                    WorkloadAdministrationGroup wag = wagEntry.getKey();\n-                    String groupName = wag.getWorkloadAdministrationGroupName();\n-                    if (wag.getResource().equalsIgnoreCase(environmentCrn)) {\n-                        usersStateBuilder.addGroup(wagEntry.getValue());\n-                    } else {\n-                        Crn resourceCrn = getCrn(wag);\n-                        if (resourceCrn != null && resourceCrn.getService() == Crn.Service.ENVIRONMENTS\n-                                && resourceCrn.getResourceType() == ResourceType.ENVIRONMENT) {\n-                            wagNamesForOtherEnvironments.add(groupName);\n-                        }\n-                    }\n-                });\n+            Map<String, UmsUsersState> envUsersStateMap;\n+            if (fullSync && entitlementService.umsUserSyncModelGenerationEnabled(INTERNAL_ACTOR_CRN, accountId)) {\n+                envUsersStateMap = getUmsUsersStateMapBulk(accountId, environmentCrns, requestIdOptional);\n+            } else {\n+                envUsersStateMap = getUmsUsersStateMap(\n+                        accountId, actorCrn,\n+                        environmentCrns, userCrns, machineUserCrns,\n+                        requestIdOptional, fullSync);\n+            }\n \n-                // Add internal usersync group for each environment\n-                usersStateBuilder.addGroup(nameToGroup(UserSyncConstants.CDP_USERSYNC_INTERNAL_GROUP));\n+            return envUsersStateMap;\n+        } catch (RuntimeException e) {\n+            throw new UmsOperationException(String.format(\"Error during UMS operation: '%s'\", e.getLocalizedMessage()), e);\n+        }\n+    }\n \n-                EnvironmentAccessChecker environmentAccessChecker = createEnvironmentAccessChecker(environmentCrn);\n+    @VisibleForTesting\n+    Map<String, UmsUsersState> getUmsUsersStateMapBulk(", "originalCommit": "73d6dc30ed172b314b02349317c6ab811980703c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MjA0Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492162046", "bodyText": "done.\nI created the UmsUsersStateProviderDispatcher that directs the request to either the bulk or default implementations. Common functionality is moved to a Base class and an ActorHandler was pulled out to a separate class.", "author": "handavid", "createdAt": "2020-09-21T15:42:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MDk4NDg1NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAxNTQyMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r491015423", "bodyText": "I have to say this class is getting more and more complex, the methods are getting more complex and bigger. It's pretty hard to understand and review it actually. I would like to kindly ask you to refactor this before/while putting these new bulk sync logic into it.\neg this actorHandler might be a separate class as it has a try-catch, which invokes a method with 10 parameters, 3 of them are lambdas", "author": "lacikaaa", "createdAt": "2020-09-18T15:09:58Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UmsUsersStateProvider.java", "diffHunk": "@@ -54,92 +77,233 @@\n     @Inject\n     private UmsRightProvider umsRightProvider;\n \n-    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(String accountId, String actorCrn, Set<String> environmentCrns,\n-        Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n+    @Inject\n+    private EntitlementService entitlementService;\n+\n+    public Map<String, UmsUsersState> getEnvToUmsUsersStateMap(\n+            String accountId, String actorCrn, Collection<String> environmentCrns,\n+            Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional) {\n         try {\n             LOGGER.debug(\"Getting UMS state for environments {} with requestId {}\", environmentCrns, requestIdOptional);\n \n-            Map<String, UmsUsersState> envUsersStateMap = new HashMap<>();\n-\n             boolean fullSync = userCrns.isEmpty() && machineUserCrns.isEmpty();\n \n-            List<User> users = getUsers(actorCrn, accountId, requestIdOptional, fullSync, userCrns);\n-\n-            List<MachineUser> machineUsers = getMachineUsers(actorCrn, accountId, requestIdOptional, fullSync, machineUserCrns);\n-\n-            Map<String, FmsGroup> crnToFmsGroup = grpcUmsClient.listGroups(actorCrn, accountId, List.of(), requestIdOptional).stream()\n-                    .collect(Collectors.toMap(Group::getCrn, this::umsGroupToGroup));\n-\n-            Map<WorkloadAdministrationGroup, FmsGroup> wags = grpcUmsClient.listWorkloadAdministrationGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional)\n-                    .stream()\n-                    .collect(Collectors.toMap(wag -> wag, wag -> nameToGroup(wag.getWorkloadAdministrationGroupName())));\n-            environmentCrns.forEach(environmentCrn -> {\n-                UmsUsersState.Builder umsUsersStateBuilder = new UmsUsersState.Builder()\n-                        .setWorkloadAdministrationGroups(wags.values());\n-\n-                UsersState.Builder usersStateBuilder = new UsersState.Builder();\n-                Set<String> wagNamesForOtherEnvironments = new HashSet<>();\n-\n-                crnToFmsGroup.values().forEach(usersStateBuilder::addGroup);\n-\n-                // Only add workload admin groups that belong to this environment.\n-                // At the same time, build a set of workload admin groups that are\n-                // associated with other environments so we can filter these out in\n-                // the per-user group listing in handleUser.\n-                wags.entrySet().forEach(wagEntry -> {\n-                    WorkloadAdministrationGroup wag = wagEntry.getKey();\n-                    String groupName = wag.getWorkloadAdministrationGroupName();\n-                    if (wag.getResource().equalsIgnoreCase(environmentCrn)) {\n-                        usersStateBuilder.addGroup(wagEntry.getValue());\n-                    } else {\n-                        Crn resourceCrn = getCrn(wag);\n-                        if (resourceCrn != null && resourceCrn.getService() == Crn.Service.ENVIRONMENTS\n-                                && resourceCrn.getResourceType() == ResourceType.ENVIRONMENT) {\n-                            wagNamesForOtherEnvironments.add(groupName);\n-                        }\n-                    }\n-                });\n+            Map<String, UmsUsersState> envUsersStateMap;\n+            if (fullSync && entitlementService.umsUserSyncModelGenerationEnabled(INTERNAL_ACTOR_CRN, accountId)) {\n+                envUsersStateMap = getUmsUsersStateMapBulk(accountId, environmentCrns, requestIdOptional);\n+            } else {\n+                envUsersStateMap = getUmsUsersStateMap(\n+                        accountId, actorCrn,\n+                        environmentCrns, userCrns, machineUserCrns,\n+                        requestIdOptional, fullSync);\n+            }\n \n-                // Add internal usersync group for each environment\n-                usersStateBuilder.addGroup(nameToGroup(UserSyncConstants.CDP_USERSYNC_INTERNAL_GROUP));\n+            return envUsersStateMap;\n+        } catch (RuntimeException e) {\n+            throw new UmsOperationException(String.format(\"Error during UMS operation: '%s'\", e.getLocalizedMessage()), e);\n+        }\n+    }\n \n-                EnvironmentAccessChecker environmentAccessChecker = createEnvironmentAccessChecker(environmentCrn);\n+    @VisibleForTesting\n+    Map<String, UmsUsersState> getUmsUsersStateMapBulk(\n+            String accountId, Collection<String> environmentCrns, Optional<String> requestIdOptional) {\n+\n+        List<String> environmentCrnList = List.copyOf(environmentCrns);\n+        GetUserSyncStateModelResponse userSyncStateModel = grpcUmsClient.getUserSyncStateModel(\n+                INTERNAL_ACTOR_CRN,\n+                accountId,\n+                generateRightsChecksForEnvironments(environmentCrnList),\n+                requestIdOptional);\n+\n+        Map<String, FmsGroup> groups = convertGroupsToFmsGroups(userSyncStateModel.getGroupList());\n+        Map<WorkloadAdministrationGroup, FmsGroup> wags =\n+                convertWagsToFmsGroups(userSyncStateModel.getWorkloadAdministrationGroupList());\n+        List<String> requestedWorkloadUsernames = userSyncStateModel.getActorList().stream()\n+                .map(UserManagementProto.UserSyncActor::getActorDetails)\n+                .map(UserManagementProto.UserSyncActorDetails::getWorkloadUsername)\n+                .collect(Collectors.toList());\n+\n+        Map<String, UmsUsersState> umsUsersStateMap = Maps.newHashMap();\n+        IntStream.range(0, environmentCrnList.size())\n+                .forEach(environmentIndex -> {\n+                    String environmentCrn = environmentCrnList.get(environmentIndex);\n+                    UmsUsersState.Builder umsUsersStateBuilder = UmsUsersState.newBuilder()\n+                            .setWorkloadAdministrationGroups(wags.values());\n+                    UsersState.Builder usersStateBuilder = UsersState.newBuilder();\n+                    addRequestedWorkloadUsernames(umsUsersStateBuilder, requestedWorkloadUsernames);\n+                    addGroupsToUsersStateBuilder(usersStateBuilder, groups.values());\n+                    Set<String> wagNamesForOtherEnvironments =\n+                            addWagsToUsersStateBuilder(usersStateBuilder, wags, environmentCrn);\n+                    addActorsToUmsUsersStateBuilder(\n+                            umsUsersStateBuilder,\n+                            usersStateBuilder,\n+                            environmentIndex,\n+                            userSyncStateModel,\n+                            groups,\n+                            wagNamesForOtherEnvironments);\n+                    addServicePrinciplesCloudIdentities(\n+                            accountId, environmentCrn, umsUsersStateBuilder, requestIdOptional);\n+                    umsUsersStateBuilder.setUsersState(usersStateBuilder.build());\n+                    umsUsersStateMap.put(environmentCrn, umsUsersStateBuilder.build());\n+                });\n+        return umsUsersStateMap;\n+    }\n \n-                users.forEach(u -> {\n-                    FmsUser fmsUser = umsUserToUser(u);\n-                    // add workload username for each user. This will be helpful in getting users from IPA.\n-                    umsUsersStateBuilder.addRequestedWorkloadUsers(fmsUser);\n+    @VisibleForTesting\n+    Map<String, UmsUsersState> getUmsUsersStateMap(\n+            String accountId, String actorCrn, Collection<String> environmentCrns,\n+            Set<String> userCrns, Set<String> machineUserCrns, Optional<String> requestIdOptional,\n+            boolean fullSync) {\n+        List<User> users = getUsers(actorCrn, accountId, requestIdOptional, fullSync, userCrns);\n+        List<MachineUser> machineUsers = getMachineUsers(actorCrn, accountId, requestIdOptional, fullSync, machineUserCrns);\n+\n+        Map<String, FmsGroup> crnToFmsGroup = convertGroupsToFmsGroups(\n+                grpcUmsClient.listAllGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional));\n+        Map<WorkloadAdministrationGroup, FmsGroup> wags = convertWagsToFmsGroups(\n+                grpcUmsClient.listWorkloadAdministrationGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional));\n+        List<String> requestedWorkloadUsernames = Streams.concat(\n+                users.stream().map(User::getWorkloadUsername),\n+                machineUsers.stream().map(MachineUser::getWorkloadUsername))\n+                .collect(Collectors.toList());\n+\n+        Map<String, UmsUsersState> umsUsersStateMap = new HashMap<>();\n+        environmentCrns.forEach(environmentCrn -> {\n+            UmsUsersState.Builder umsUsersStateBuilder = new UmsUsersState.Builder()\n+                    .setWorkloadAdministrationGroups(wags.values());\n+            UsersState.Builder usersStateBuilder = new UsersState.Builder();\n+            addRequestedWorkloadUsernames(umsUsersStateBuilder, requestedWorkloadUsernames);\n+            addGroupsToUsersStateBuilder(usersStateBuilder, crnToFmsGroup.values());\n+            Set<String> wagNamesForOtherEnvironments =\n+                    addWagsToUsersStateBuilder(usersStateBuilder, wags, environmentCrn);\n+\n+            EnvironmentAccessChecker environmentAccessChecker = createEnvironmentAccessChecker(environmentCrn);\n+            TriConsumer<String, FmsUser, List<CloudIdentity>> actorHandler =", "originalCommit": "73d6dc30ed172b314b02349317c6ab811980703c", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjE2MzU0Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492163546", "bodyText": "refactored.\nI pulled out the common functionality between the bulk and default implementations into an ActorHandler and this TriConsumer to a separate method", "author": "handavid", "createdAt": "2020-09-21T15:44:24Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MTAxNTQyMw=="}], "type": "inlineReview"}, {"oid": "c69be1a0dfc5f764318a0d2250bfbe145b4162c9", "url": "https://github.com/hortonworks/cloudbreak/commit/c69be1a0dfc5f764318a0d2250bfbe145b4162c9", "message": "refactored ums users state provider into smaller pieces", "committedDate": "2020-09-21T15:32:59Z", "type": "forcePushed"}, {"oid": "4dff6ce4c28f7723eb8f4e50e4fcede872847d06", "url": "https://github.com/hortonworks/cloudbreak/commit/4dff6ce4c28f7723eb8f4e50e4fcede872847d06", "message": "refactored ums users state provider into smaller pieces", "committedDate": "2020-09-21T16:13:07Z", "type": "forcePushed"}, {"oid": "0927c027c9a1887a66f65822e2ea1c20c82a461d", "url": "https://github.com/hortonworks/cloudbreak/commit/0927c027c9a1887a66f65822e2ea1c20c82a461d", "message": "CDPCP-2990. User sync uses bulk UMS api\n\nThe UMS introduced an API that returns the user sync state\nfrom the UMS in one request. This is used to avoid the many\nnetwork roundtrips when the FMS builds the state through\nindividual UMS requests.\n\nChanges include:\n- Bulk of the changes are to the UmsUsersStateProvider. This has been refactored\n  to support using either the bulk api or individual apis for full sync. This\n  behavior is protected by an entitlement. The class has also been divided into\n  smaller, more focused classes.\n- Unit tests were added to ensure that both codepaths yield the same results\n- usermanagement.proto and ums client classes  updated to include the new API\n- mock user management service updated to the changes in the GetRightsRequest\n- EventGenerationId code updated to use the shared model instead of the\n  individual fields\n- Fixed typo in CloudIdentitySyncService methods and tests", "committedDate": "2020-09-22T05:51:02Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgwODg2NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492808865", "bodyText": "so there is a EnvironmentRightChecksFactory, and I'm a bit confused at first blink which is which and why.", "author": "lacikaaa", "createdAt": "2020-09-22T15:03:10Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/EnvironmentsRightsChecksFactory.java", "diffHunk": "@@ -0,0 +1,20 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.ums;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n+import com.sequenceiq.freeipa.service.freeipa.user.UserSyncConstants;\n+import org.springframework.stereotype.Component;\n+\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public class EnvironmentsRightsChecksFactory {", "originalCommit": "0927c027c9a1887a66f65822e2ea1c20c82a461d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg1NjAwNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492856007", "bodyText": "The two providers use different mechanisms to determine rights.\nThe default provider uses the RightChecks model to call the authorization service.\nthe bulk provider uses the RightsChecks model to call the user management service.\nIt's unfortunate that the two are not the same, and even more unfortunate that they are so similarly named.\nI can rename these classes to better indicate the auth vs ums difference.", "author": "handavid", "createdAt": "2020-09-22T16:02:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgwODg2NQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkwNjYyNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492906624", "bodyText": "renamed to AuthorizationRightChecksFactory and UmsRightsChecksFactory", "author": "handavid", "createdAt": "2020-09-22T17:20:50Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgwODg2NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyMTk3Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492821977", "bodyText": "I don't think you need inject on constructor", "author": "lacikaaa", "createdAt": "2020-09-22T15:17:52Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/BulkUmsUsersStateProvider.java", "diffHunk": "@@ -0,0 +1,137 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.ums;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n+import com.google.common.collect.Maps;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.freeipa.service.freeipa.user.conversion.FmsGroupConverter;\n+import com.sequenceiq.freeipa.service.freeipa.user.conversion.FmsUserConverter;\n+import com.sequenceiq.freeipa.service.freeipa.user.conversion.WorkloadCredentialConverter;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.EnvironmentAccessRights;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.FmsGroup;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UmsUsersState;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UsersState;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.WorkloadCredential;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+import java.util.stream.IntStream;\n+\n+import static com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider.INTERNAL_ACTOR_CRN;\n+\n+@Component\n+public class BulkUmsUsersStateProvider extends BaseUmsUsersStateProvider {\n+    @Inject\n+    private GrpcUmsClient grpcUmsClient;\n+\n+    @Inject\n+    private EnvironmentsRightsChecksFactory environmentsRightsChecksFactory;\n+\n+    @Inject\n+    private FmsUserConverter fmsUserConverter;\n+\n+    @Inject\n+    private WorkloadCredentialConverter workloadCredentialConverter;\n+\n+    @Inject", "originalCommit": "0927c027c9a1887a66f65822e2ea1c20c82a461d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg1NjMwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492856309", "bodyText": "ok. I'll try to inject directly into the base class.", "author": "handavid", "createdAt": "2020-09-22T16:02:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyMTk3Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyMjYxNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492822616", "bodyText": "same here", "author": "lacikaaa", "createdAt": "2020-09-22T15:18:44Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/DefaultUmsUsersStateProvider.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.ums;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.freeipa.service.freeipa.user.conversion.FmsGroupConverter;\n+import com.sequenceiq.freeipa.service.freeipa.user.conversion.FmsUserConverter;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.FmsGroup;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.FmsUser;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UmsUsersState;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UsersState;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.WorkloadCredential;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import org.apache.logging.log4j.util.TriConsumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider.INTERNAL_ACTOR_CRN;\n+import static java.util.Objects.requireNonNull;\n+\n+@Component\n+public class DefaultUmsUsersStateProvider extends BaseUmsUsersStateProvider {\n+    @VisibleForTesting\n+    static final boolean INCLUDE_INTERNAL_MACHINE_USERS = true;\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultUmsUsersStateProvider.class);\n+\n+    @Inject\n+    private GrpcUmsClient grpcUmsClient;\n+\n+    @Inject\n+    private EnvironmentAccessCheckerFactory environmentAccessCheckerFactory;\n+\n+    @Inject\n+    private UmsCredentialProvider umsCredentialProvider;\n+\n+    @Inject\n+    private FmsUserConverter fmsUserConverter;\n+\n+    @Inject", "originalCommit": "0927c027c9a1887a66f65822e2ea1c20c82a461d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkwNjczMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492906732", "bodyText": "done", "author": "handavid", "createdAt": "2020-09-22T17:20:58Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyMjYxNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyMzgxOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492823819", "bodyText": "it's a bit strange to depend on something from a logging library which is not log related", "author": "lacikaaa", "createdAt": "2020-09-22T15:20:15Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/ums/DefaultUmsUsersStateProvider.java", "diffHunk": "@@ -0,0 +1,175 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.ums;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto;\n+import com.google.common.annotations.VisibleForTesting;\n+import com.google.common.collect.Streams;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.freeipa.service.freeipa.user.conversion.FmsGroupConverter;\n+import com.sequenceiq.freeipa.service.freeipa.user.conversion.FmsUserConverter;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.FmsGroup;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.FmsUser;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UmsUsersState;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.UsersState;\n+import com.sequenceiq.freeipa.service.freeipa.user.model.WorkloadCredential;\n+import io.grpc.Status;\n+import io.grpc.StatusRuntimeException;\n+import org.apache.logging.log4j.util.TriConsumer;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.Collection;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.function.Supplier;\n+import java.util.stream.Collectors;\n+\n+import static com.sequenceiq.cloudbreak.auth.ThreadBasedUserCrnProvider.INTERNAL_ACTOR_CRN;\n+import static java.util.Objects.requireNonNull;\n+\n+@Component\n+public class DefaultUmsUsersStateProvider extends BaseUmsUsersStateProvider {\n+    @VisibleForTesting\n+    static final boolean INCLUDE_INTERNAL_MACHINE_USERS = true;\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultUmsUsersStateProvider.class);\n+\n+    @Inject\n+    private GrpcUmsClient grpcUmsClient;\n+\n+    @Inject\n+    private EnvironmentAccessCheckerFactory environmentAccessCheckerFactory;\n+\n+    @Inject\n+    private UmsCredentialProvider umsCredentialProvider;\n+\n+    @Inject\n+    private FmsUserConverter fmsUserConverter;\n+\n+    @Inject\n+    public DefaultUmsUsersStateProvider(FmsGroupConverter fmsGroupConverter) {\n+        super(fmsGroupConverter);\n+    }\n+\n+    public Map<String, UmsUsersState> get(\n+            String accountId, String actorCrn,\n+            Collection<String> environmentCrns, Set<String> userCrns, Set<String> machineUserCrns,\n+            Optional<String> requestIdOptional, boolean fullSync) {\n+        List<UserManagementProto.User> users = getUsers(actorCrn, accountId, requestIdOptional, fullSync, userCrns);\n+        List<UserManagementProto.MachineUser> machineUsers =\n+                getMachineUsers(actorCrn, accountId, requestIdOptional, fullSync, machineUserCrns);\n+\n+        Map<String, FmsGroup> crnToFmsGroup = convertGroupsToFmsGroups(\n+                grpcUmsClient.listAllGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional));\n+        Map<UserManagementProto.WorkloadAdministrationGroup, FmsGroup> wags = convertWagsToFmsGroups(\n+                grpcUmsClient.listWorkloadAdministrationGroups(INTERNAL_ACTOR_CRN, accountId, requestIdOptional));\n+        List<String> requestedWorkloadUsernames = Streams.concat(\n+                users.stream().map(UserManagementProto.User::getWorkloadUsername),\n+                machineUsers.stream().map(UserManagementProto.MachineUser::getWorkloadUsername))\n+                .collect(Collectors.toList());\n+\n+        Map<String, UmsUsersState> umsUsersStateMap = new HashMap<>();\n+        environmentCrns.forEach(environmentCrn -> {\n+            UmsUsersState.Builder umsUsersStateBuilder = new UmsUsersState.Builder()\n+                    .setWorkloadAdministrationGroups(wags.values());\n+            UsersState.Builder usersStateBuilder = new UsersState.Builder();\n+\n+            addRequestedWorkloadUsernames(umsUsersStateBuilder, requestedWorkloadUsernames);\n+            addGroupsToUsersStateBuilder(usersStateBuilder, crnToFmsGroup.values());\n+            Set<String> wagNamesForOtherEnvironments =\n+                    addWagsToUsersStateBuilder(usersStateBuilder, wags, environmentCrn);\n+\n+            ActorHandler actorHandler = ActorHandler.newBuilder()\n+                    .withFmsGroupConverter(getFmsGroupConverter())\n+                    .withUmsUsersStateBuilder(umsUsersStateBuilder)\n+                    .withUsersStateBuilder(usersStateBuilder)\n+                    .withCrnToFmsGroup(crnToFmsGroup)\n+                    .withWagNamesForOtherEnvironments(wagNamesForOtherEnvironments)\n+                    .build();\n+            EnvironmentAccessChecker environmentAccessChecker = createEnvironmentAccessChecker(environmentCrn);\n+            TriConsumer<String, FmsUser, List<UserManagementProto.CloudIdentity>> actorConsumer =\n+                    createActorConsumer(accountId, environmentAccessChecker, actorHandler, requestIdOptional);\n+            users.forEach(u -> actorConsumer.accept(u.getCrn(), fmsUserConverter.toFmsUser(u), u.getCloudIdentitiesList()));\n+            machineUsers.forEach(mu -> actorConsumer.accept(mu.getCrn(), fmsUserConverter.toFmsUser(mu), mu.getCloudIdentitiesList()));\n+\n+            addServicePrincipalsCloudIdentities(\n+                    umsUsersStateBuilder,\n+                    grpcUmsClient.listServicePrincipalCloudIdentities(\n+                            INTERNAL_ACTOR_CRN, accountId, environmentCrn, requestIdOptional));\n+\n+            umsUsersStateBuilder.setUsersState(usersStateBuilder.build());\n+            umsUsersStateMap.put(environmentCrn, umsUsersStateBuilder.build());\n+        });\n+        return umsUsersStateMap;\n+    }\n+\n+    private TriConsumer<String, FmsUser, List<UserManagementProto.CloudIdentity>> createActorConsumer(", "originalCommit": "0927c027c9a1887a66f65822e2ea1c20c82a461d", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5Mjg1NjczOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492856738", "bodyText": "I'll look for a replacement", "author": "handavid", "createdAt": "2020-09-22T16:03:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyMzgxOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjkwODEzMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/9010#discussion_r492908132", "bodyText": "moved this into a addActorsToUmsUsersStateBuilder method to match the Bulk provider.\nI had this TriConsumer so that I could apply the same consumer to both the user and machine users. I switched it around and concat the users and machine users streams so I don't have to save the lambda.", "author": "handavid", "createdAt": "2020-09-22T17:23:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ5MjgyMzgxOQ=="}], "type": "inlineReview"}, {"oid": "ec901f5240fce7cf22f5b20421fab4616dee6a69", "url": "https://github.com/hortonworks/cloudbreak/commit/ec901f5240fce7cf22f5b20421fab4616dee6a69", "message": "CDPCP-2990. User sync uses bulk UMS api\n\nThe UMS introduced an API that returns the user sync state\nfrom the UMS in one request. This is used to avoid the many\nnetwork roundtrips when the FMS builds the state through\nindividual UMS requests.\n\nChanges include:\n- Bulk of the changes are to the UmsUsersStateProvider. This has been refactored\n  to support using either the bulk api or individual apis for full sync. This\n  behavior is protected by an entitlement. The class has also been divided into\n  smaller, more focused classes.\n- Unit tests were added to ensure that both codepaths yield the same results\n- usermanagement.proto and ums client classes  updated to include the new API\n- mock user management service updated to the changes in the GetRightsRequest\n- EventGenerationId code updated to use the shared model instead of the\n  individual fields\n- Fixed typo in CloudIdentitySyncService methods and tests", "committedDate": "2020-09-22T17:02:58Z", "type": "commit"}, {"oid": "ec901f5240fce7cf22f5b20421fab4616dee6a69", "url": "https://github.com/hortonworks/cloudbreak/commit/ec901f5240fce7cf22f5b20421fab4616dee6a69", "message": "CDPCP-2990. User sync uses bulk UMS api\n\nThe UMS introduced an API that returns the user sync state\nfrom the UMS in one request. This is used to avoid the many\nnetwork roundtrips when the FMS builds the state through\nindividual UMS requests.\n\nChanges include:\n- Bulk of the changes are to the UmsUsersStateProvider. This has been refactored\n  to support using either the bulk api or individual apis for full sync. This\n  behavior is protected by an entitlement. The class has also been divided into\n  smaller, more focused classes.\n- Unit tests were added to ensure that both codepaths yield the same results\n- usermanagement.proto and ums client classes  updated to include the new API\n- mock user management service updated to the changes in the GetRightsRequest\n- EventGenerationId code updated to use the shared model instead of the\n  individual fields\n- Fixed typo in CloudIdentitySyncService methods and tests", "committedDate": "2020-09-22T17:02:58Z", "type": "forcePushed"}]}