{"pr_number": 7345, "pr_title": "CDPCP-1291. Add support for retrieving a keytab in FMS", "pr_createdAt": "2020-02-20T21:34:01Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/7345", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUwMDg5Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r383500893", "bodyText": "I'm not too fond of the location of this file. I'd prefer it to reside closer to the service that will actually use it.", "author": "handavid", "createdAt": "2020-02-24T20:38:22Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package com.sequenceiq.freeipa.util;", "originalCommit": "1b1ddcca9b04cd7dc79dfc5bfb4e9b2dd0f32856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcyNTEyMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r383725120", "bodyText": "this definitely smells, please look for a better place", "author": "lacikaaa", "createdAt": "2020-02-25T08:34:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUwMDg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDE2NDI1NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r384164254", "bodyText": "Ah sure let me find a better place (I've placed it here because KrbKeySetEncoder is here which plays an analogous role). I think we want to expose this as part of UserV1Endpoint and maybe add a UserKeytabGenService.", "author": "aarman-cloudera", "createdAt": "2020-02-25T22:26:15Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUwMDg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDQxODY5MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r384418690", "bodyText": "that class is in a wrong package also IMHO", "author": "lacikaaa", "createdAt": "2020-02-26T10:56:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUwMDg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDcyODk4Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r384728987", "bodyText": "I gree that KrbKeySetEncoder is also in the wrong spot. I suggest com.sequenceiq.freeipa.service.freeipa.user.krb or com.sequenceiq.freeipa.service.freeipa.user.util", "author": "handavid", "createdAt": "2020-02-26T19:54:28Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUwMDg5Mw=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc2NzUwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r384767509", "bodyText": "Thanks, I'll move both of them.", "author": "aarman-cloudera", "createdAt": "2020-02-26T21:10:55Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzUwMDg5Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU4OTg4Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r383589886", "bodyText": "verify/assert parameters?", "author": "giladwolff", "createdAt": "2020-02-25T00:14:04Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package com.sequenceiq.freeipa.util;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.common.service.Clock;\n+import org.apache.directory.server.kerberos.shared.keytab.KeytabEncoder;\n+import org.apache.directory.server.kerberos.shared.keytab.KeytabEntry;\n+import org.apache.directory.shared.kerberos.KerberosTime;\n+import org.apache.directory.shared.kerberos.codec.types.EncryptionType;\n+import org.apache.directory.shared.kerberos.components.EncryptionKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public final class KrbKeytabGenerator {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KrbKeytabGenerator.class);\n+\n+    private static final int PRINCIPAL_TYPE_1 = 1;\n+\n+    private static final byte[] KEYTAB_VERSION_0X502 = { (byte) 0x05, (byte) 0x02 };\n+\n+    private static final byte KEY_VERSION_NUMBER_ZERO = 0;\n+\n+    @Inject\n+    private Clock clock;\n+\n+    private KeytabEntry toKeytabEntry(String user, String realm, ActorKerberosKey actorKerberosKey) {\n+        String principalName = user + '@' + realm;", "originalCommit": "1b1ddcca9b04cd7dc79dfc5bfb4e9b2dd0f32856", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MDEyOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r383590128", "bodyText": "This is the kvno? Add a comment?", "author": "giladwolff", "createdAt": "2020-02-25T00:14:55Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package com.sequenceiq.freeipa.util;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.common.service.Clock;\n+import org.apache.directory.server.kerberos.shared.keytab.KeytabEncoder;\n+import org.apache.directory.server.kerberos.shared.keytab.KeytabEntry;\n+import org.apache.directory.shared.kerberos.KerberosTime;\n+import org.apache.directory.shared.kerberos.codec.types.EncryptionType;\n+import org.apache.directory.shared.kerberos.components.EncryptionKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public final class KrbKeytabGenerator {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KrbKeytabGenerator.class);\n+\n+    private static final int PRINCIPAL_TYPE_1 = 1;\n+\n+    private static final byte[] KEYTAB_VERSION_0X502 = { (byte) 0x05, (byte) 0x02 };\n+\n+    private static final byte KEY_VERSION_NUMBER_ZERO = 0;", "originalCommit": "1b1ddcca9b04cd7dc79dfc5bfb4e9b2dd0f32856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3Njg4Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r384776887", "bodyText": "Added", "author": "aarman-cloudera", "createdAt": "2020-02-26T21:28:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MDEyOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MDE5Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r383590192", "bodyText": "What is this principal type?", "author": "giladwolff", "createdAt": "2020-02-25T00:15:09Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package com.sequenceiq.freeipa.util;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.common.service.Clock;\n+import org.apache.directory.server.kerberos.shared.keytab.KeytabEncoder;\n+import org.apache.directory.server.kerberos.shared.keytab.KeytabEntry;\n+import org.apache.directory.shared.kerberos.KerberosTime;\n+import org.apache.directory.shared.kerberos.codec.types.EncryptionType;\n+import org.apache.directory.shared.kerberos.components.EncryptionKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public final class KrbKeytabGenerator {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KrbKeytabGenerator.class);\n+\n+    private static final int PRINCIPAL_TYPE_1 = 1;", "originalCommit": "1b1ddcca9b04cd7dc79dfc5bfb4e9b2dd0f32856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MTk2Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r384771966", "bodyText": "This is goes away in my upcoming change that uses kerby-util package. Internally it will still set a name type of 1 meaning NT-PRINCIPAL, which is what we want I believe.\nI'm not sure how important this field is either ways, as per https://tools.ietf.org/html/rfc4120\n\"The name-type SHOULD be treated only as a hint to interpreting the meaning of a name.  It is not significant when checking for equivalence. Principal names that differ only in the name-type identify the same principal.\"", "author": "aarman-cloudera", "createdAt": "2020-02-26T21:18:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MDE5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MDM5NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r383590395", "bodyText": "verify/assert parameters?", "author": "giladwolff", "createdAt": "2020-02-25T00:15:36Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package com.sequenceiq.freeipa.util;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.common.service.Clock;\n+import org.apache.directory.server.kerberos.shared.keytab.KeytabEncoder;\n+import org.apache.directory.server.kerberos.shared.keytab.KeytabEntry;\n+import org.apache.directory.shared.kerberos.KerberosTime;\n+import org.apache.directory.shared.kerberos.codec.types.EncryptionType;\n+import org.apache.directory.shared.kerberos.components.EncryptionKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public final class KrbKeytabGenerator {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KrbKeytabGenerator.class);\n+\n+    private static final int PRINCIPAL_TYPE_1 = 1;\n+\n+    private static final byte[] KEYTAB_VERSION_0X502 = { (byte) 0x05, (byte) 0x02 };\n+\n+    private static final byte KEY_VERSION_NUMBER_ZERO = 0;\n+\n+    @Inject\n+    private Clock clock;\n+\n+    private KeytabEntry toKeytabEntry(String user, String realm, ActorKerberosKey actorKerberosKey) {\n+        String principalName = user + '@' + realm;\n+\n+        EncryptionType encryptionType = EncryptionType.getTypeByValue(actorKerberosKey.getKeyType());\n+        byte[] key = Base64.getDecoder().decode(actorKerberosKey.getKeyValue());\n+        EncryptionKey encryptionKey = new EncryptionKey(encryptionType, key);\n+\n+        KerberosTime time = new KerberosTime(clock.getCurrentTimeMillis());\n+\n+        return new KeytabEntry(principalName, PRINCIPAL_TYPE_1, time, KEY_VERSION_NUMBER_ZERO, encryptionKey);\n+    }\n+\n+    public String generateKeytabBase64(String workloadUserName, String realm, List<ActorKerberosKey> actorKerberosKeys) {\n+        LOGGER.info(\"Generating keytab for workloadUserName = {} with realm = {}\", workloadUserName, realm);", "originalCommit": "1b1ddcca9b04cd7dc79dfc5bfb4e9b2dd0f32856", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MjAxNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r383592015", "bodyText": "Are there any meaningful tests you want to bring from apache.directory?", "author": "giladwolff", "createdAt": "2020-02-25T00:21:08Z", "path": "freeipa/src/test/java/com/sequenceiq/freeipa/util/KrbKeyTabGeneratorTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package com.sequenceiq.freeipa.util;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.common.service.Clock;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)", "originalCommit": "1b1ddcca9b04cd7dc79dfc5bfb4e9b2dd0f32856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MjgwMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r384772803", "bodyText": "No longer needed.", "author": "aarman-cloudera", "createdAt": "2020-02-26T21:20:31Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MjAxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MjMwMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r383592302", "bodyText": "So what is the apache license? Can we copy the code and use it/modify it as long as we have the copyright statement?", "author": "giladwolff", "createdAt": "2020-02-25T00:22:02Z", "path": "freeipa/src/main/java/org/apache/directory/shared/kerberos/components/EncryptionKey.java", "diffHunk": "@@ -0,0 +1,330 @@\n+/*\n+ *  Licensed to the Apache Software Foundation (ASF) under one\n+ *  or more contributor license agreements.  See the NOTICE file\n+ *  distributed with this work for additional information\n+ *  regarding copyright ownership.  The ASF licenses this file\n+ *  to you under the Apache License, Version 2.0 (the", "originalCommit": "1b1ddcca9b04cd7dc79dfc5bfb4e9b2dd0f32856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MjYzOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r383592638", "bodyText": "I think I answered my own question by doing a git grep on thunderhead git repo. I think it's fine.", "author": "giladwolff", "createdAt": "2020-02-25T00:23:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MjMwMg=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3MzM4Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r384773383", "bodyText": "Cool. I think all we need to do is just include the original license, and if we've modified the code we just put some Cloudera modification header.", "author": "aarman-cloudera", "createdAt": "2020-02-26T21:21:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzU5MjMwMg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcyNTIxOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r383725218", "bodyText": "where is this class used?", "author": "lacikaaa", "createdAt": "2020-02-25T08:34:24Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package com.sequenceiq.freeipa.util;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.common.service.Clock;\n+import org.apache.directory.server.kerberos.shared.keytab.KeytabEncoder;\n+import org.apache.directory.server.kerberos.shared.keytab.KeytabEntry;\n+import org.apache.directory.shared.kerberos.KerberosTime;\n+import org.apache.directory.shared.kerberos.codec.types.EncryptionType;\n+import org.apache.directory.shared.kerberos.components.EncryptionKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public final class KrbKeytabGenerator {", "originalCommit": "1b1ddcca9b04cd7dc79dfc5bfb4e9b2dd0f32856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3Mzc4Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r384773783", "bodyText": "The functionality will be exposed as a public endpoint in a follow-on commit.", "author": "aarman-cloudera", "createdAt": "2020-02-26T21:22:20Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcyNTIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcyNTcwMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r383725701", "bodyText": "these variables need more meaningful name, or if it's really necessary add comments please", "author": "lacikaaa", "createdAt": "2020-02-25T08:35:24Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/util/KrbKeytabGenerator.java", "diffHunk": "@@ -0,0 +1,54 @@\n+package com.sequenceiq.freeipa.util;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.common.service.Clock;\n+import org.apache.directory.server.kerberos.shared.keytab.KeytabEncoder;\n+import org.apache.directory.server.kerberos.shared.keytab.KeytabEntry;\n+import org.apache.directory.shared.kerberos.KerberosTime;\n+import org.apache.directory.shared.kerberos.codec.types.EncryptionType;\n+import org.apache.directory.shared.kerberos.components.EncryptionKey;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+@Component\n+public final class KrbKeytabGenerator {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KrbKeytabGenerator.class);\n+\n+    private static final int PRINCIPAL_TYPE_1 = 1;\n+\n+    private static final byte[] KEYTAB_VERSION_0X502 = { (byte) 0x05, (byte) 0x02 };\n+\n+    private static final byte KEY_VERSION_NUMBER_ZERO = 0;", "originalCommit": "1b1ddcca9b04cd7dc79dfc5bfb4e9b2dd0f32856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3NDM3OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r384774379", "bodyText": "Next commit gets rid of some of these variables (internally they still get these values). I've added a comment about key version number.", "author": "aarman-cloudera", "createdAt": "2020-02-26T21:23:32Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzcyNTcwMQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzczOTQ0NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r383739444", "bodyText": "it looks like to me there is only 1 happy path tested. Are you sure there isn't anything which can go wrong here? Like a parameter is wrong", "author": "lacikaaa", "createdAt": "2020-02-25T09:02:08Z", "path": "freeipa/src/test/java/com/sequenceiq/freeipa/util/KrbKeyTabGeneratorTest.java", "diffHunk": "@@ -0,0 +1,56 @@\n+package com.sequenceiq.freeipa.util;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.common.service.Clock;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class KrbKeyTabGeneratorTest {\n+\n+    private static final long MOCK_TIME = 1576171731141L;\n+\n+    @InjectMocks\n+    KrbKeytabGenerator underTest;\n+\n+    @Mock\n+    private Clock clock;\n+\n+    @Test\n+    void testGenerateKeytabBase64() {", "originalCommit": "1b1ddcca9b04cd7dc79dfc5bfb4e9b2dd0f32856", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NDc3NDk4OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r384774989", "bodyText": "I think there's some more validation (i.e. has to be a valid workload user) we can add, but it might be at a higher level.", "author": "aarman-cloudera", "createdAt": "2020-02-26T21:24:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4MzczOTQ0NA=="}], "type": "inlineReview"}, {"oid": "aff2bd274d662265b21fcb38d535f03b3930f67e", "url": "https://github.com/hortonworks/cloudbreak/commit/aff2bd274d662265b21fcb38d535f03b3930f67e", "message": "CDPCP-1522. Add support for generating keytab from actor kerberos key\n\nA KrbKeytabGenerator class has been added that allows generating\na kerberos keytab by using the keys within ActorKerberosKey's.\nThis pulls in kerb-utils dependency from the Apache Kerby project\nwhich contains the classes needed to encode the principal and\nkeys into the keytab format. In addition KrbKeySetEncoder which\ndoes something similar has been moved under the same package.\n\nThis functionality of this class will be exposed as an api endpoint\nin a follow-on commit.", "committedDate": "2020-02-26T21:04:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNDg3NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r385004875", "bodyText": "Not a big deal, but could you drop krb in favor of kerberos? I think the package should be user.kerberos and the class name UserKeytabGenerator. This would reflect more of it's purpose in my opinion.", "author": "lacikaaa", "createdAt": "2020-02-27T09:29:29Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/krb/KrbKeytabGenerator.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.krb;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.common.service.Clock;\n+import org.apache.kerby.kerberos.kerb.keytab.Keytab;\n+import org.apache.kerby.kerberos.kerb.keytab.KeytabEntry;\n+import org.apache.kerby.kerberos.kerb.type.KerberosTime;\n+import org.apache.kerby.kerberos.kerb.type.base.EncryptionKey;\n+import org.apache.kerby.kerberos.kerb.type.base.EncryptionType;\n+import org.apache.kerby.kerberos.kerb.type.base.PrincipalName;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Kerberos keytab generator - This class is repsonsible for generating a keytab using existing keys\n+ * belonging to an actor in User Management Service.\n+ */\n+@Component\n+public final class KrbKeytabGenerator {", "originalCommit": "aff2bd274d662265b21fcb38d535f03b3930f67e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3ODI1Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r385978257", "bodyText": "Done.", "author": "aarman-cloudera", "createdAt": "2020-02-29T00:17:59Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNDg3NQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNjMzNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r385006334", "bodyText": "I see one try without catch, so my concern is if something goes wrong in this code, maybe we would like to convert it to a custom exception a propagate it upwards in that format. What do you think about it?", "author": "lacikaaa", "createdAt": "2020-02-27T09:32:04Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/krb/KrbKeytabGenerator.java", "diffHunk": "@@ -0,0 +1,70 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.krb;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.common.service.Clock;\n+import org.apache.kerby.kerberos.kerb.keytab.Keytab;\n+import org.apache.kerby.kerberos.kerb.keytab.KeytabEntry;\n+import org.apache.kerby.kerberos.kerb.type.KerberosTime;\n+import org.apache.kerby.kerberos.kerb.type.base.EncryptionKey;\n+import org.apache.kerby.kerberos.kerb.type.base.EncryptionType;\n+import org.apache.kerby.kerberos.kerb.type.base.PrincipalName;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Kerberos keytab generator - This class is repsonsible for generating a keytab using existing keys\n+ * belonging to an actor in User Management Service.\n+ */\n+@Component\n+public final class KrbKeytabGenerator {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(KrbKeytabGenerator.class);\n+\n+    // For the key version number (kvno) in the keytab entries, we use a value of 0. Based on\n+    // expirementiation we've found that for user principles, keytab entries with kvno of zero\n+    // works fine, regardless of what the actual key versions are set in the KDC / Directory Server.\n+    private static final int KEY_VERSION_NUMBER_ZERO = 0;\n+\n+    @Inject\n+    private Clock clock;\n+\n+    private KeytabEntry toKeytabEntry(String user, String realm, ActorKerberosKey actorKerberosKey) {\n+        requireNonNull(user, \"user must not be null\");\n+        requireNonNull(realm, \"realm must not be null\");\n+        requireNonNull(actorKerberosKey, \"actorKerberosKey must not be null\");\n+\n+        PrincipalName principalName = new PrincipalName(user + '@' + realm);\n+\n+        EncryptionType encryptionType = EncryptionType.fromValue(actorKerberosKey.getKeyType());\n+        byte[] key = Base64.getDecoder().decode(actorKerberosKey.getKeyValue());\n+        EncryptionKey encryptionKey = new EncryptionKey(encryptionType, key);\n+\n+        KerberosTime time = new KerberosTime(clock.getCurrentTimeMillis());\n+\n+        return new KeytabEntry(principalName, time, KEY_VERSION_NUMBER_ZERO, encryptionKey);\n+    }\n+\n+    public String generateKeytabBase64(String username, String realm, List<ActorKerberosKey> actorKerberosKeys) throws IOException {", "originalCommit": "aff2bd274d662265b21fcb38d535f03b3930f67e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3ODIwNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r385978206", "bodyText": "That catch for this would be an IOException. I highly doubt we hit the exception here since it's not actually doing file / network IO. I have added a check for this in the service that calls this function, see updated PR.", "author": "aarman-cloudera", "createdAt": "2020-02-29T00:17:39Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwNjMzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwODAzOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r385008038", "bodyText": "I think we need test for those non null checks at least.\nCould you come up with any scenario where other part of the code breaks? I mean a lot static calls are used so this is not easy to test, but what if ActorKerberosKey holds wrong value, or the username holds the whole principal. I think we should cover some unhappy path here.", "author": "lacikaaa", "createdAt": "2020-02-27T09:35:08Z", "path": "freeipa/src/test/java/com/sequenceiq/freeipa/service/freeipa/user/krb/KrbKeyTabGeneratorTest.java", "diffHunk": "@@ -0,0 +1,57 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.krb;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.common.service.Clock;\n+import org.junit.jupiter.api.Test;\n+import org.junit.jupiter.api.extension.ExtendWith;\n+import org.mockito.InjectMocks;\n+import org.mockito.Mock;\n+import org.mockito.junit.jupiter.MockitoExtension;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+import static org.junit.jupiter.api.Assertions.assertEquals;\n+import static org.mockito.Mockito.when;\n+\n+@ExtendWith(MockitoExtension.class)\n+public class KrbKeyTabGeneratorTest {", "originalCommit": "aff2bd274d662265b21fcb38d535f03b3930f67e", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk3ODQ0Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r385978447", "bodyText": "Added some null tests and a test for empty key list. As for the other unhappy paths, I don't think it's worth testing at this layer. A user won't provide any of these inputs directly. We pull the keys and username off of UMS and the realm will be pulled from kerberos config. I've updated the PR with the actual service that uses this component. Please see updated PR.", "author": "aarman-cloudera", "createdAt": "2020-02-29T00:19:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTAwODAzOA=="}], "type": "inlineReview"}, {"oid": "a754e4a9b0330ce3840214f1babed1e87c1de9a9", "url": "https://github.com/hortonworks/cloudbreak/commit/a754e4a9b0330ce3840214f1babed1e87c1de9a9", "message": "CDPCP-1539. Expose api endpoint to retrieve / generate keys for an actor\n\nThis exposes a new endpoint in FreeIPA service to retrieve a keytab\nfor an actor under an environment.", "committedDate": "2020-02-29T00:11:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NTk4NjM4NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r385986384", "bodyText": "'the calling has' -> 'the calling user has'", "author": "aarman-cloudera", "createdAt": "2020-02-29T01:13:50Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java", "diffHunk": "@@ -98,6 +102,19 @@ public SyncOperationStatus getSyncOperationStatus(@NotNull String operationId) {\n                 operationService.getOperationForAccountIdAndOperationId(accountId, operationId));\n     }\n \n+    @Override\n+    public String getKeytab(@NotNull String environmentCrn, String targetUserCrn) {\n+        String callerUserCrn = checkUserCrn();\n+        LOGGER.debug(\"getKeytab() request for environmentCrn={}, callerUserCrn={}, targetUserCrn={}\", environmentCrn, callerUserCrn, targetUserCrn);\n+        // TODO For now, we ignore the optional targetUserCrn and only allow retrieving keytab for the calling user. When\n+        //      we later enable this, we need to make sure that the calling has the necessary authorization / right to get", "originalCommit": "a754e4a9b0330ce3840214f1babed1e87c1de9a9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2MzcwOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r386863709", "bodyText": "I think this should be in KerberosMgmtV1Endpoint. What do you think @handavid ?", "author": "lacikaaa", "createdAt": "2020-03-03T08:33:33Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/user/UserV1Endpoint.java", "diffHunk": "@@ -52,4 +52,11 @@\n     @ApiOperation(value = UserOperationDescriptions.SYNC_OPERATION_STATUS, notes = UserNotes.USER_NOTES, produces = MediaType.APPLICATION_JSON,\n             nickname = \"getSyncOperationStatusV1\")\n     SyncOperationStatus getSyncOperationStatus(@NotNull @QueryParam(\"operationId\") String operationId);\n+\n+    @GET\n+    @Path(\"getKeytab\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = UserOperationDescriptions.GET_KEYTAB, notes = UserNotes.USER_NOTES, produces = MediaType.APPLICATION_JSON,\n+            nickname = \"getKeytabV1\")\n+    String getKeytab(@NotNull @QueryParam(\"environment\") String environment, @QueryParam(\"user\") String user);", "originalCommit": "a754e4a9b0330ce3840214f1babed1e87c1de9a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NjkwMDY3OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r386900679", "bodyText": "@jamisonbennett", "author": "lacikaaa", "createdAt": "2020-03-03T09:41:49Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2MzcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxMzYwMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r387313600", "bodyText": "Since this endpoint is tied to user in ums, I think this place is fine too. Happy to change if I'm outvoted though :)", "author": "aarman-cloudera", "createdAt": "2020-03-03T21:47:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2MzcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYwMzM4Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388603382", "bodyText": "Thanks for making these contributions, I have a couple of thoughts on this which you may have already considered. Sorry for the lengthy comment.\nFirst, its cool how this is an HTTP get. It looks like you have lots of logic that creates a keytab without using the public FreeIPA API to retrieve the keytab. I am quite intrigued at how you were able to do this. I think the public FreeIPA get keytab API for user principals updates the KVNO every time. \ud83d\ude04\nAs an aside, avoiding incrementing the KVNO for users is one of the features the TGT generator provides. The TGT generator creates service principals for users. For example, principal myuser/cluster1.cloudera.site@CLOUDERA.SITE will be used rather than myuser@CLOUDERA.SITE. In both cases, the principal will be mapped hadoop user myuser. This was done because only service principals could be retrieved without invalidating prior keytabs. I am not sure if this is something that would be useful to know more about but reach out to me if it is and I can provide you with the design documentation.\nSecond, although this only is able to retrieve the keytab for a specific user, I think the KerberosMgmtV1Endpoint is a more logical location for the code. That endpoint already handles keytabs for service principals and host principals. At some point, we may have a need for user principals.\nThrid, I think the other keytab API calls returned a vault path with the principal and the keytab. Vault should probably be used. The data in vault was base64 encoded.", "author": "jamisonbennett", "createdAt": "2020-03-05T22:26:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2MzcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcwODkxOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388708918", "bodyText": "I'll defer to Jamison here regarding keytab generation. Based on his comments, I think that this API probably belongs next to the other keytab APIs", "author": "handavid", "createdAt": "2020-03-06T04:33:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2MzcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTQ2NDQ3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r389464474", "bodyText": "We do not use the public FreeIPA APIs. We have the password hashes in the control plane and we just package them in a keytab format. We use kvno 0 which works with an arbitrary kvno in the kdc. Asif did a POC before sending this out.", "author": "giladwolff", "createdAt": "2020-03-09T05:02:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2MzcwOQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwMzk1OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r390003959", "bodyText": "Thanks for looking Jamison. I've moved it to KerberosMgmtV1Endpoint As mentioned this work is heavily tied with 'syncing password hash' feature that others have worked on in the past. Some more details about this approach can be found on the design doc here:\nhttps://docs.google.com/document/d/1-M9-WD0SGBNMsnJbZtXTMmrh0EHRG8tGVYUlIR64byg\nCan we use a string and not a vault path, for now at least? This will be exposed as a public endpoint in environments2 api service in thunderhead and we don't have vault integration there yet. I can file jira to look into it, but I'd rather do it as a follow up.", "author": "aarman-cloudera", "createdAt": "2020-03-09T22:50:29Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2MzcwOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2NTY5MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r386865690", "bodyText": "We might take of that targetUserCrn from the API and add it when we support it, as it won't be a breaking change. If we keep this way I think we should not throw an exception when target and caller crn are the same.", "author": "lacikaaa", "createdAt": "2020-03-03T08:37:51Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java", "diffHunk": "@@ -98,6 +102,19 @@ public SyncOperationStatus getSyncOperationStatus(@NotNull String operationId) {\n                 operationService.getOperationForAccountIdAndOperationId(accountId, operationId));\n     }\n \n+    @Override\n+    public String getKeytab(@NotNull String environmentCrn, String targetUserCrn) {\n+        String callerUserCrn = checkUserCrn();\n+        LOGGER.debug(\"getKeytab() request for environmentCrn={}, callerUserCrn={}, targetUserCrn={}\", environmentCrn, callerUserCrn, targetUserCrn);\n+        // TODO For now, we ignore the optional targetUserCrn and only allow retrieving keytab for the calling user. When\n+        //      we later enable this, we need to make sure that the calling has the necessary authorization / right to get\n+        //      keytab for another user.\n+        if (targetUserCrn != null) {\n+            throw new BadRequestException(\"Retrieving a keytab for another user is not yet supported\");\n+        }", "originalCommit": "a754e4a9b0330ce3840214f1babed1e87c1de9a9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4NzMxMjQ4NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r387312484", "bodyText": "Good point, I've updated to not throw when target is same.", "author": "aarman-cloudera", "createdAt": "2020-03-03T21:45:33Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4Njg2NTY5MA=="}], "type": "inlineReview"}, {"oid": "00189074cc3555868cda818d9d3e1a80764ceab8", "url": "https://github.com/hortonworks/cloudbreak/commit/00189074cc3555868cda818d9d3e1a80764ceab8", "message": "CDPCP-1539. Expose api endpoint to retrieve / generate keys for an actor\n\nThis exposes a new endpoint in FreeIPA service to retrieve a keytab\nfor an actor under an environment.", "committedDate": "2020-03-03T21:42:16Z", "type": "forcePushed"}, {"oid": "96f885d6c58bf64599edb274845fd2f2ea4b2de0", "url": "https://github.com/hortonworks/cloudbreak/commit/96f885d6c58bf64599edb274845fd2f2ea4b2de0", "message": "CDPCP-1539. Expose api endpoint to retrieve / generate keys for an actor\n\nThis exposes a new endpoint in FreeIPA service to retrieve a keytab\nfor an actor under an environment.", "committedDate": "2020-03-04T00:06:48Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYwMzg0Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388603847", "bodyText": "You should also probably mention that the data is base64 encoded and that is is a vault path (assuming you make the vault change).", "author": "jamisonbennett", "createdAt": "2020-03-05T22:27:30Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/user/doc/UserOperationDescriptions.java", "diffHunk": "@@ -5,6 +5,7 @@\n     public static final String SYNC_ALL = \"Synchronizes Groups and Users to the FreeIPA servers\";\n     public static final String SET_PASSWORD = \"Sets the user's password in the FreeIPA servers\";\n     public static final String SYNC_OPERATION_STATUS = \"Gets the status of a sync operation\";\n+    public static final String GET_KEYTAB = \"Gets a keytab as a base64 encoded string for a User under a specified Environment\";", "originalCommit": "96f885d6c58bf64599edb274845fd2f2ea4b2de0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwNDMyMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r390004322", "bodyText": "As mentioned, I'd like to not go with vault path for now and just return the base64 string directly.", "author": "aarman-cloudera", "createdAt": "2020-03-09T22:51:42Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYwMzg0Nw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYwNTEzMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388605130", "bodyText": "nit: \"yet\" is probably not needed.", "author": "jamisonbennett", "createdAt": "2020-03-05T22:30:53Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java", "diffHunk": "@@ -107,6 +111,19 @@ public SyncOperationStatus getSyncOperationStatus(@NotNull String operationId) {\n                 operationService.getOperationForAccountIdAndOperationId(accountId, operationId));\n     }\n \n+    @Override\n+    public String getKeytab(@NotNull String environmentCrn, String targetUserCrn) {\n+        String callerUserCrn = checkUserCrn();\n+        LOGGER.debug(\"getKeytab() request for environmentCrn={}, callerUserCrn={}, targetUserCrn={}\", environmentCrn, callerUserCrn, targetUserCrn);\n+        // TODO For now, we ignore the optional targetUserCrn and only allow retrieving keytab for the calling user. When\n+        //      we later enable this, we need to make sure that the calling user has the necessary authorization / right to get\n+        //      keytab for another user.\n+        if (targetUserCrn != null && !callerUserCrn.equals(targetUserCrn)) {\n+            throw new BadRequestException(\"Retrieving a keytab for another user is not yet supported\");", "originalCommit": "96f885d6c58bf64599edb274845fd2f2ea4b2de0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYwNTQ3OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388605478", "bodyText": "I am glad to see you using the IAM service here rather than FREEIPA. I had to make a similar correction today \ud83d\ude04", "author": "jamisonbennett", "createdAt": "2020-03-05T22:31:51Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserKeytabService.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.GetActorWorkloadCredentialsResponse;\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.cloudbreak.auth.security.InternalCrnBuilder;\n+import com.sequenceiq.cloudbreak.logger.MDCUtils;\n+import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n+import com.sequenceiq.freeipa.kerberos.KerberosConfig;\n+import com.sequenceiq.freeipa.kerberos.KerberosConfigRepository;\n+import com.sequenceiq.freeipa.service.freeipa.user.kerberos.UserKeytabGenerator;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static com.sequenceiq.freeipa.controller.exception.NotFoundException.notFound;\n+\n+@Service\n+public class UserKeytabService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(UserKeytabService.class);\n+\n+    private static final String IAM_INTERNAL_ACTOR_CRN = new InternalCrnBuilder(Crn.Service.IAM).getInternalCrnForServiceAsString();", "originalCommit": "96f885d6c58bf64599edb274845fd2f2ea4b2de0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcwOTkwNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388709905", "bodyText": "we had a talk ;)", "author": "handavid", "createdAt": "2020-03-06T04:39:00Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYwNTQ3OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYxNzM2NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388617364", "bodyText": "This is interesting that the value of 0 always works.\nAt one point, I had tested the kvno and every time the public FreeIPA API was called to get a user keytab, the KVNO incremented and the old keytab would stop working. Maybe the first KVNO that is issued by the public FreeIPA API is 1 and thus 0 can still be treated specially. You might want to double check this to ensure the user's keytab can't be invalidated (although I suppose we are not calling that API today so maybe its a don't care).\nI believe that at one point @toddlipcon worked on a way to get user keytabs without invalidating them. Is this the same process? I am pretty curious about this.", "author": "jamisonbennett", "createdAt": "2020-03-05T23:02:52Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/kerberos/UserKeytabGenerator.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package com.sequenceiq.freeipa.service.freeipa.user.kerberos;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.common.service.Clock;\n+import org.apache.kerby.kerberos.kerb.keytab.Keytab;\n+import org.apache.kerby.kerberos.kerb.keytab.KeytabEntry;\n+import org.apache.kerby.kerberos.kerb.type.KerberosTime;\n+import org.apache.kerby.kerberos.kerb.type.base.EncryptionKey;\n+import org.apache.kerby.kerberos.kerb.type.base.EncryptionType;\n+import org.apache.kerby.kerberos.kerb.type.base.PrincipalName;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import javax.inject.Inject;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.util.Base64;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static java.util.Objects.requireNonNull;\n+\n+/**\n+ * Kerberos keytab generator - This class is repsonsible for generating a keytab using existing keys\n+ * belonging to an actor in User Management Service.\n+ */\n+@Component\n+public class UserKeytabGenerator {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(UserKeytabGenerator.class);\n+\n+    // For the key version number (kvno) in the keytab entries, we use a value of 0. Based on\n+    // expirementiation we've found that for user principles, keytab entries with kvno of zero\n+    // works fine, regardless of what the actual key versions are set in the KDC / Directory Server.", "originalCommit": "96f885d6c58bf64599edb274845fd2f2ea4b2de0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4OTA2MDYzNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r389060635", "bodyText": "I think you might have already gotten the answer elsewhere, but yea, this builds on work that Gilad (I think) did in the UMS which can produce keytabs for users. That work, in turn, builds on the stuff we worked on a few months back where the UMS stores the hashed password and kerberos principal keys for users locally for password sync purposes. Given that the UMS has the kerberos principal keys, it's just a file formatting exercise to embed those keys into a keytab file, with no FreeIPA instance in the loop at all. (in fact this API should work even if there is no environment created)", "author": "toddlipcon", "createdAt": "2020-03-06T18:10:06Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYxNzM2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwNTgzNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r390005837", "bodyText": "Just a bit more info, my original comment on kvno = 0 here maybe a bit misleading. As per my testing, the key version number didn't matter and I don't think 0 is special. Setting this to an arbitrary number like 42 would probably still work (though a bulk of my testing was using kvno = 0).\nUsing FreeIPA API is get keytab for user principles, generates new keys and updates the KDC with the new keys and increments the key version number (even if you use the same password; new random salts get used, resulting in different keys). So the older keytab getting invalidated is due to keys not matching and nothing to do with key version numbers. As Todd mentioned since we have keys already in UMS we use those as the basis for the keytab.\nAnother thing to note, based on above; any keytab a user gets using this api will still get invalidated if the user were to later call ipa-getkeytab directly (but would start working again after user sync occurs). So we should discourage any user from using this ipa-getkeytab or trying to get the keytab by other means outside the api we provide.", "author": "aarman-cloudera", "createdAt": "2020-03-09T22:56:34Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYxNzM2NA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAwNjg3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r390006874", "bodyText": "Also, this API still requires an environment, because we need the realm inside the keytab. In order to generate the keytab, we perform a lookup of the realm based on environment.", "author": "aarman-cloudera", "createdAt": "2020-03-09T22:59:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODYxNzM2NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcwOTAzMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388709030", "bodyText": "if the query params are CRNs, then let's include CRN in the names. e.g., environmentCrn", "author": "handavid", "createdAt": "2020-03-06T04:33:57Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/user/UserV1Endpoint.java", "diffHunk": "@@ -52,4 +52,11 @@\n     @ApiOperation(value = UserOperationDescriptions.SYNC_OPERATION_STATUS, notes = UserNotes.USER_NOTES, produces = MediaType.APPLICATION_JSON,\n             nickname = \"getSyncOperationStatusV1\")\n     SyncOperationStatus getSyncOperationStatus(@NotNull @QueryParam(\"operationId\") String operationId);\n+\n+    @GET\n+    @Path(\"getKeytab\")\n+    @Produces(MediaType.APPLICATION_JSON)\n+    @ApiOperation(value = UserOperationDescriptions.GET_KEYTAB, notes = UserNotes.USER_NOTES, produces = MediaType.APPLICATION_JSON,\n+            nickname = \"getKeytabV1\")\n+    String getKeytab(@NotNull @QueryParam(\"environment\") String environment, @QueryParam(\"user\") String user);", "originalCommit": "96f885d6c58bf64599edb274845fd2f2ea4b2de0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcwOTc5Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388709792", "bodyText": "based on the expected future use-case, we should require the targetUserCrn field. i.e., mark it @NotNull.\nAs a design principle, we do not want to pull request arguments out of the actor or other metadata. All required information should be in the request itself. (yes, a bunch of the other APIs violate this but I'll fix this in the v2 API)\ncan we rename callerUserCrn to actorCrn?\nwe can keep the actorCrn.equals(targetUserCrn) check as a faux authorization check for now.", "author": "handavid", "createdAt": "2020-03-06T04:38:28Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java", "diffHunk": "@@ -107,6 +111,19 @@ public SyncOperationStatus getSyncOperationStatus(@NotNull String operationId) {\n                 operationService.getOperationForAccountIdAndOperationId(accountId, operationId));\n     }\n \n+    @Override\n+    public String getKeytab(@NotNull String environmentCrn, String targetUserCrn) {", "originalCommit": "96f885d6c58bf64599edb274845fd2f2ea4b2de0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMTE5Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r390011192", "bodyText": "Done. I've also renamed to actorCrn (I wonder if we should rename ThreadBasedUserCrnProvider -> ThreadBasedActorrCrnProvider).", "author": "aarman-cloudera", "createdAt": "2020-03-09T23:13:02Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcwOTc5Mg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxMDQ0Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388710447", "bodyText": "call this with the targetUserCrn rather than the actorCrn. The actorCrn will be available to other code in through the ThreadBasedUserCrnProvider (I think I remembered that correctly)", "author": "handavid", "createdAt": "2020-03-06T04:42:10Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/controller/UserV1Controller.java", "diffHunk": "@@ -107,6 +111,19 @@ public SyncOperationStatus getSyncOperationStatus(@NotNull String operationId) {\n                 operationService.getOperationForAccountIdAndOperationId(accountId, operationId));\n     }\n \n+    @Override\n+    public String getKeytab(@NotNull String environmentCrn, String targetUserCrn) {\n+        String callerUserCrn = checkUserCrn();\n+        LOGGER.debug(\"getKeytab() request for environmentCrn={}, callerUserCrn={}, targetUserCrn={}\", environmentCrn, callerUserCrn, targetUserCrn);\n+        // TODO For now, we ignore the optional targetUserCrn and only allow retrieving keytab for the calling user. When\n+        //      we later enable this, we need to make sure that the calling user has the necessary authorization / right to get\n+        //      keytab for another user.\n+        if (targetUserCrn != null && !callerUserCrn.equals(targetUserCrn)) {\n+            throw new BadRequestException(\"Retrieving a keytab for another user is not yet supported\");\n+        }\n+        return userKeytabService.getKeytabBase64(callerUserCrn, environmentCrn);", "originalCommit": "96f885d6c58bf64599edb274845fd2f2ea4b2de0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxMDc2OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388710768", "bodyText": "Crn.safeFromString instead of Objects.requireNonNull", "author": "handavid", "createdAt": "2020-03-06T04:43:52Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserKeytabService.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.GetActorWorkloadCredentialsResponse;\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.cloudbreak.auth.security.InternalCrnBuilder;\n+import com.sequenceiq.cloudbreak.logger.MDCUtils;\n+import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n+import com.sequenceiq.freeipa.kerberos.KerberosConfig;\n+import com.sequenceiq.freeipa.kerberos.KerberosConfigRepository;\n+import com.sequenceiq.freeipa.service.freeipa.user.kerberos.UserKeytabGenerator;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static com.sequenceiq.freeipa.controller.exception.NotFoundException.notFound;\n+\n+@Service\n+public class UserKeytabService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(UserKeytabService.class);\n+\n+    private static final String IAM_INTERNAL_ACTOR_CRN = new InternalCrnBuilder(Crn.Service.IAM).getInternalCrnForServiceAsString();\n+\n+    @Inject\n+    private KerberosConfigRepository kerberosConfigRepository;\n+\n+    @Inject\n+    private GrpcUmsClient grpcUmsClient;\n+\n+    @Inject\n+    private UserKeytabGenerator userKeytabGenerator;\n+\n+    private String getKerberosRealm(String accountId, String environmentCrn) {\n+        KerberosConfig krbConfig =  kerberosConfigRepository\n+                .findByAccountIdAndEnvironmentCrnAndClusterNameIsNull(accountId, environmentCrn)\n+                .orElseThrow(notFound(\"KerberosConfig for environment\", environmentCrn));\n+        return krbConfig.getRealm();\n+    }\n+\n+    private void validateSameAccount(String userAccountId, String environmentCrn) {\n+        String environmentCrnAccountId = Objects.requireNonNull(Crn.fromString(environmentCrn)).getAccountId();", "originalCommit": "96f885d6c58bf64599edb274845fd2f2ea4b2de0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxMDgxMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388710813", "bodyText": "Crn.safeFromString instead of Objects.requireNonNull", "author": "handavid", "createdAt": "2020-03-06T04:44:09Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserKeytabService.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.GetActorWorkloadCredentialsResponse;\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.cloudbreak.auth.security.InternalCrnBuilder;\n+import com.sequenceiq.cloudbreak.logger.MDCUtils;\n+import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n+import com.sequenceiq.freeipa.kerberos.KerberosConfig;\n+import com.sequenceiq.freeipa.kerberos.KerberosConfigRepository;\n+import com.sequenceiq.freeipa.service.freeipa.user.kerberos.UserKeytabGenerator;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static com.sequenceiq.freeipa.controller.exception.NotFoundException.notFound;\n+\n+@Service\n+public class UserKeytabService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(UserKeytabService.class);\n+\n+    private static final String IAM_INTERNAL_ACTOR_CRN = new InternalCrnBuilder(Crn.Service.IAM).getInternalCrnForServiceAsString();\n+\n+    @Inject\n+    private KerberosConfigRepository kerberosConfigRepository;\n+\n+    @Inject\n+    private GrpcUmsClient grpcUmsClient;\n+\n+    @Inject\n+    private UserKeytabGenerator userKeytabGenerator;\n+\n+    private String getKerberosRealm(String accountId, String environmentCrn) {\n+        KerberosConfig krbConfig =  kerberosConfigRepository\n+                .findByAccountIdAndEnvironmentCrnAndClusterNameIsNull(accountId, environmentCrn)\n+                .orElseThrow(notFound(\"KerberosConfig for environment\", environmentCrn));\n+        return krbConfig.getRealm();\n+    }\n+\n+    private void validateSameAccount(String userAccountId, String environmentCrn) {\n+        String environmentCrnAccountId = Objects.requireNonNull(Crn.fromString(environmentCrn)).getAccountId();\n+        if (!environmentCrnAccountId.equals(userAccountId)) {\n+            throw new BadRequestException(\"User and Environment must be in the same account\");\n+        }\n+    }\n+\n+    public String getKeytabBase64(String userCrn, String environmentCrn) {\n+        String userAccountId = Objects.requireNonNull(Crn.fromString(userCrn)).getAccountId();", "originalCommit": "96f885d6c58bf64599edb274845fd2f2ea4b2de0", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxMTE0OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388711148", "bodyText": "can you throw a more meaningful exception? perhaps make a custom exception so that we can map it to a response code in the api layer", "author": "handavid", "createdAt": "2020-03-06T04:46:03Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/UserKeytabService.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package com.sequenceiq.freeipa.service.freeipa.user;\n+\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.GetActorWorkloadCredentialsResponse;\n+import com.cloudera.thunderhead.service.usermanagement.UserManagementProto.ActorKerberosKey;\n+import com.sequenceiq.cloudbreak.auth.altus.Crn;\n+import com.sequenceiq.cloudbreak.auth.altus.GrpcUmsClient;\n+import com.sequenceiq.cloudbreak.auth.security.InternalCrnBuilder;\n+import com.sequenceiq.cloudbreak.logger.MDCUtils;\n+import com.sequenceiq.freeipa.controller.exception.BadRequestException;\n+import com.sequenceiq.freeipa.kerberos.KerberosConfig;\n+import com.sequenceiq.freeipa.kerberos.KerberosConfigRepository;\n+import com.sequenceiq.freeipa.service.freeipa.user.kerberos.UserKeytabGenerator;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import javax.inject.Inject;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static com.sequenceiq.freeipa.controller.exception.NotFoundException.notFound;\n+\n+@Service\n+public class UserKeytabService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(UserKeytabService.class);\n+\n+    private static final String IAM_INTERNAL_ACTOR_CRN = new InternalCrnBuilder(Crn.Service.IAM).getInternalCrnForServiceAsString();\n+\n+    @Inject\n+    private KerberosConfigRepository kerberosConfigRepository;\n+\n+    @Inject\n+    private GrpcUmsClient grpcUmsClient;\n+\n+    @Inject\n+    private UserKeytabGenerator userKeytabGenerator;\n+\n+    private String getKerberosRealm(String accountId, String environmentCrn) {\n+        KerberosConfig krbConfig =  kerberosConfigRepository\n+                .findByAccountIdAndEnvironmentCrnAndClusterNameIsNull(accountId, environmentCrn)\n+                .orElseThrow(notFound(\"KerberosConfig for environment\", environmentCrn));\n+        return krbConfig.getRealm();\n+    }\n+\n+    private void validateSameAccount(String userAccountId, String environmentCrn) {\n+        String environmentCrnAccountId = Objects.requireNonNull(Crn.fromString(environmentCrn)).getAccountId();\n+        if (!environmentCrnAccountId.equals(userAccountId)) {\n+            throw new BadRequestException(\"User and Environment must be in the same account\");\n+        }\n+    }\n+\n+    public String getKeytabBase64(String userCrn, String environmentCrn) {\n+        String userAccountId = Objects.requireNonNull(Crn.fromString(userCrn)).getAccountId();\n+        validateSameAccount(userAccountId, environmentCrn);\n+\n+        String realm = getKerberosRealm(userAccountId, environmentCrn);\n+\n+        GetActorWorkloadCredentialsResponse getActorWorkloadCredentialsResponse =\n+                grpcUmsClient.getActorWorkloadCredentials(IAM_INTERNAL_ACTOR_CRN, userCrn, MDCUtils.getRequestId());\n+        String workloadUsername = getActorWorkloadCredentialsResponse.getWorkloadUsername();\n+        List<ActorKerberosKey> actorKerberosKeys = getActorWorkloadCredentialsResponse.getKerberosKeysList();\n+\n+        try {\n+            return userKeytabGenerator.generateKeytabBase64(workloadUsername, realm, actorKerberosKeys);\n+        } catch (IOException e) {\n+            throw new RuntimeException(\"Failed to generate keytab\", e);", "originalCommit": "96f885d6c58bf64599edb274845fd2f2ea4b2de0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMzM3Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r390013377", "bodyText": "I've moved the exception handling into UserKeytabGenerator. I don't see how the IOException will ever trigger since we're passing our own ByteArrayOutputStream rather than doing file i/o. So I don't think a custom exception here is warranted.", "author": "aarman-cloudera", "createdAt": "2020-03-09T23:19:43Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxMTE0OA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxMTI2Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r388711267", "bodyText": "thank you!", "author": "handavid", "createdAt": "2020-03-06T04:46:36Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/user/kerberos/KrbKeySetEncoder.java", "diffHunk": "@@ -1,4 +1,4 @@\n-package com.sequenceiq.freeipa.util;\n+package com.sequenceiq.freeipa.service.freeipa.user.kerberos;", "originalCommit": "96f885d6c58bf64599edb274845fd2f2ea4b2de0", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM5MDAxMzQzMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/7345#discussion_r390013431", "bodyText": "np! :)", "author": "aarman-cloudera", "createdAt": "2020-03-09T23:19:56Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDM4ODcxMTI2Nw=="}], "type": "inlineReview"}, {"oid": "42d1ab972808c5f68f25f3c330850c3e23f4e1f4", "url": "https://github.com/hortonworks/cloudbreak/commit/42d1ab972808c5f68f25f3c330850c3e23f4e1f4", "message": "CDPCP-1522. Add support for generating keytab from actor kerberos key\n\nA UserKeytabGenerator class has been added that allows generating\na kerberos keytab by using the keys within ActorKerberosKey's.\nThis pulls in kerb-utils dependency from the Apache Kerby project\nwhich contains the classes needed to encode the principal and\nkeys into the keytab format. In addition KrbKeySetEncoder which\ndoes something similar has been moved under the same package.\n\nThis functionality of this class will be exposed as an api endpoint\nin a follow-on commit.", "committedDate": "2020-03-09T18:18:36Z", "type": "commit"}, {"oid": "2aec23deb736b71b80caf2c119ca1ae5dd276dd6", "url": "https://github.com/hortonworks/cloudbreak/commit/2aec23deb736b71b80caf2c119ca1ae5dd276dd6", "message": "CDPCP-1291. Update UMS client to include workload username in actor workload credentials\n\nThis will make it easier to generate keytab from actor workload credentials.", "committedDate": "2020-03-09T18:18:36Z", "type": "commit"}, {"oid": "9854b39fed1500670ec79362d22084e72c8a6b6a", "url": "https://github.com/hortonworks/cloudbreak/commit/9854b39fed1500670ec79362d22084e72c8a6b6a", "message": "CDPCP-1539. Expose api endpoint to retrieve / generate keys for an actor\n\nThis exposes a new endpoint in FreeIPA service to retrieve a keytab\nfor an actor under an environment.", "committedDate": "2020-03-09T22:37:46Z", "type": "forcePushed"}, {"oid": "cc7f766029d25bd7a7cce8c87f067d5dbf44c8c7", "url": "https://github.com/hortonworks/cloudbreak/commit/cc7f766029d25bd7a7cce8c87f067d5dbf44c8c7", "message": "CDPCP-1539. Expose api endpoint to retrieve / generate keys for an actor\n\nThis exposes a new endpoint in FreeIPA service to retrieve a keytab\nfor an actor under an environment.", "committedDate": "2020-03-09T23:24:33Z", "type": "commit"}, {"oid": "cc7f766029d25bd7a7cce8c87f067d5dbf44c8c7", "url": "https://github.com/hortonworks/cloudbreak/commit/cc7f766029d25bd7a7cce8c87f067d5dbf44c8c7", "message": "CDPCP-1539. Expose api endpoint to retrieve / generate keys for an actor\n\nThis exposes a new endpoint in FreeIPA service to retrieve a keytab\nfor an actor under an environment.", "committedDate": "2020-03-09T23:24:33Z", "type": "forcePushed"}]}