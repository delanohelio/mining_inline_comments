{"pr_number": 8200, "pr_title": "CB-6637 Internal API for Salt upgrade testing", "pr_createdAt": "2020-06-03T15:11:53Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/8200", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4ODM2NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#discussion_r435788365", "bodyText": "the component creation is duplicated for save and update", "author": "keyki", "createdAt": "2020-06-05T09:03:40Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/bootstrap/service/ClusterBootstrapper.java", "diffHunk": "@@ -106,21 +103,117 @@\n \n     public void bootstrapMachines(Long stackId) throws CloudbreakException {\n         Stack stack = stackService.getByIdWithListsInTransaction(stackId);\n-        String stackOrchestratorType = stack.getOrchestrator().getType();\n-        OrchestratorType orchestratorType = orchestratorTypeResolver.resolveType(stackOrchestratorType);\n+        bootstrapOnHost(stack);\n+    }\n \n-        if (orchestratorType.hostOrchestrator()) {\n-            bootstrapOnHost(stack);\n-        } else if (orchestratorType.containerOrchestrator()) {\n-            LOGGER.debug(\"Skipping bootstrap of the machines because the stack's orchestrator type is '{}'.\", stackOrchestratorType);\n-        } else {\n-            LOGGER.error(\"Orchestrator not found: {}\", stackOrchestratorType);\n-            throw new CloudbreakException(\"HostOrchestrator not found: \" + stackOrchestratorType);\n-        }\n+    public void reBootstrapMachines(Long stackId) throws CloudbreakException {\n+        Stack stack = stackService.getByIdWithListsInTransaction(stackId);\n+        LOGGER.info(\"ReBootstrapMachines for stack [{}] [{}]\", stack.getName(), stack.getResourceCrn());\n+        reBootstrapOnHost(stack);\n     }\n \n     @SuppressFBWarnings(\"REC_CATCH_EXCEPTION\")\n     public void bootstrapOnHost(Stack stack) throws CloudbreakException {\n+        Set<Node> nodes = collectNodesForBootstrap(stack);\n+        try {\n+            List<GatewayConfig> allGatewayConfig = collectAndCheckGateways(stack);\n+\n+            saveSaltComponent(stack);\n+\n+            BootstrapParams params = createBootstrapParams(stack);\n+            hostOrchestrator.bootstrap(allGatewayConfig, nodes, params, clusterDeletionBasedModel(stack.getId(), null));\n+\n+            InstanceMetaData primaryGateway = stack.getPrimaryGatewayInstance();\n+            saveOrchestrator(stack, primaryGateway);\n+            checkIfAllNodesAvailable(stack, nodes, primaryGateway);\n+        } catch (Exception e) {\n+            throw new CloudbreakException(e);\n+        }\n+    }\n+\n+    public void reBootstrapOnHost(Stack stack) throws CloudbreakException {\n+        Set<Node> nodes = collectNodesForBootstrap(stack);\n+        try {\n+            List<GatewayConfig> allGatewayConfig = collectAndCheckGateways(stack);\n+\n+            updateSaltComponent(stack);\n+\n+            BootstrapParams params = createBootstrapParams(stack);\n+            hostOrchestrator.bootstrap(allGatewayConfig, nodes, params, clusterDeletionBasedModel(stack.getId(), null));\n+\n+            InstanceMetaData primaryGateway = stack.getPrimaryGatewayInstance();\n+            checkIfAllNodesAvailable(stack, nodes, primaryGateway);\n+        } catch (Exception e) {\n+            throw new CloudbreakException(e);\n+        }\n+    }\n+\n+    private void checkIfAllNodesAvailable(Stack stack, Set<Node> nodes, InstanceMetaData primaryGateway) throws CloudbreakOrchestratorFailedException {\n+        GatewayConfig gatewayConfig = gatewayConfigService.getGatewayConfig(stack, primaryGateway, isKnoxEnabled(stack));\n+        PollingResult allNodesAvailabilityPolling = hostClusterAvailabilityPollingService.pollWithTimeoutSingleFailure(\n+                hostClusterAvailabilityCheckerTask, new HostOrchestratorClusterContext(stack, hostOrchestrator, gatewayConfig, nodes),\n+                POLL_INTERVAL, MAX_POLLING_ATTEMPTS);\n+        validatePollingResultForCancellation(allNodesAvailabilityPolling, \"Polling of all nodes availability was cancelled.\");\n+        if (TIMEOUT.equals(allNodesAvailabilityPolling)) {\n+            clusterBootstrapperErrorHandler.terminateFailedNodes(hostOrchestrator, null, stack, gatewayConfig, nodes);\n+        }\n+    }\n+\n+    private void saveSaltComponent(Stack stack) throws IOException {\n+        ClusterComponent saltComponent = clusterComponentProvider.getComponent(stack.getCluster().getId(), ComponentType.SALT_STATE);\n+        if (saltComponent == null) {\n+            byte[] stateConfigZip = hostOrchestrator.getStateConfigZip();\n+            saltComponent = new ClusterComponent(ComponentType.SALT_STATE,\n+                    new Json(singletonMap(ComponentType.SALT_STATE.name(), Base64.encodeBase64String(stateConfigZip))), stack.getCluster());\n+            clusterComponentProvider.store(saltComponent);\n+        }\n+    }\n+\n+    private void updateSaltComponent(Stack stack) throws IOException {\n+        ClusterComponent saltComponent = clusterComponentProvider.getComponent(stack.getCluster().getId(), ComponentType.SALT_STATE);\n+        byte[] stateConfigZip = hostOrchestrator.getStateConfigZip();\n+        if (saltComponent == null) {\n+            saltComponent = new ClusterComponent(ComponentType.SALT_STATE,", "originalCommit": "0b841b27b9ef62246c17d217b595605cfc92f35f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc4OTczNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#discussion_r435789734", "bodyText": "bootstrap and reBootstrap are almost the same except for the save and update. Can this be refactored  to a common method?", "author": "keyki", "createdAt": "2020-06-05T09:06:12Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/bootstrap/service/ClusterBootstrapper.java", "diffHunk": "@@ -106,21 +103,117 @@\n \n     public void bootstrapMachines(Long stackId) throws CloudbreakException {\n         Stack stack = stackService.getByIdWithListsInTransaction(stackId);\n-        String stackOrchestratorType = stack.getOrchestrator().getType();\n-        OrchestratorType orchestratorType = orchestratorTypeResolver.resolveType(stackOrchestratorType);\n+        bootstrapOnHost(stack);\n+    }\n \n-        if (orchestratorType.hostOrchestrator()) {\n-            bootstrapOnHost(stack);\n-        } else if (orchestratorType.containerOrchestrator()) {\n-            LOGGER.debug(\"Skipping bootstrap of the machines because the stack's orchestrator type is '{}'.\", stackOrchestratorType);\n-        } else {\n-            LOGGER.error(\"Orchestrator not found: {}\", stackOrchestratorType);\n-            throw new CloudbreakException(\"HostOrchestrator not found: \" + stackOrchestratorType);\n-        }\n+    public void reBootstrapMachines(Long stackId) throws CloudbreakException {\n+        Stack stack = stackService.getByIdWithListsInTransaction(stackId);\n+        LOGGER.info(\"ReBootstrapMachines for stack [{}] [{}]\", stack.getName(), stack.getResourceCrn());\n+        reBootstrapOnHost(stack);\n     }\n \n     @SuppressFBWarnings(\"REC_CATCH_EXCEPTION\")\n     public void bootstrapOnHost(Stack stack) throws CloudbreakException {\n+        Set<Node> nodes = collectNodesForBootstrap(stack);\n+        try {", "originalCommit": "0b841b27b9ef62246c17d217b595605cfc92f35f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc5NjI2MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#discussion_r435796261", "bodyText": "Can you add Deprecated or some comment/doc to explain why it is still there? Otherwise, someone might delete it as it's not doing anything.", "author": "keyki", "createdAt": "2020-06-05T09:18:03Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/reactor/handler/orchestration/ClusterTerminationHandler.java", "diffHunk": "@@ -35,8 +31,7 @@ public void accept(Event<ClusterTerminationRequest> event) {\n         ClusterTerminationRequest request = event.getData();\n         ClusterTerminationResult result;\n         try {\n-            Boolean allowed = clusterTerminationService.deleteClusterComponents(request.getClusterId());\n-            result = new ClusterTerminationResult(request, allowed);\n+            result = new ClusterTerminationResult(request, Boolean.TRUE);", "originalCommit": "0b841b27b9ef62246c17d217b595605cfc92f35f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgzNjkzMw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#discussion_r435836933", "bodyText": "I'm dropping the field", "author": "lacikaaa", "createdAt": "2020-06-05T10:35:52Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTc5NjI2MQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwMTY2MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#discussion_r435801661", "bodyText": "SaltUpdateEvent not needed", "author": "keyki", "createdAt": "2020-06-05T09:27:40Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/salt/update/SaltUpdateFlowConfig.java", "diffHunk": "@@ -0,0 +1,75 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update;\n+\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.BOOTSTRAP_MACHINES_FAILED_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.BOOTSTRAP_MACHINES_FINISHED_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.CONFIGURE_KEYTABS_FAILED_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.CONFIGURE_KEYTABS_FINISHED_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.SALT_UPDATE_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.SALT_UPDATE_FAILED_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.SALT_UPDATE_FAILURE_HANDLED_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.SALT_UPDATE_FINISHED_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.START_AMBARI_SERVICES_FAILED_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.START_AMBARI_SERVICES_FINISHED_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.UPLOAD_RECIPES_FAILED_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateEvent.UPLOAD_RECIPES_FINISHED_EVENT;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateState.RECONFIGURE_KEYTABS_FOR_SU_STATE;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateState.FINAL_STATE;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateState.INIT_STATE;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateState.RUN_HIGHSTATE_STATE;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateState.SALT_UPDATE_FAILED_STATE;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateState.SALT_UPDATE_FINISHED_STATE;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateState.UPDATE_SALT_STATE_FILES_STATE;\n+import static com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update.SaltUpdateState.UPLOAD_RECIPES_FOR_SU_STATE;\n+\n+import java.util.List;\n+\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.flow.core.config.AbstractFlowConfiguration;\n+import com.sequenceiq.flow.core.config.AbstractFlowConfiguration.Transition.Builder;\n+\n+@Component\n+public class SaltUpdateFlowConfig extends AbstractFlowConfiguration<SaltUpdateState, SaltUpdateEvent> {\n+\n+    private static final List<Transition<SaltUpdateState, SaltUpdateEvent>> TRANSITIONS =\n+            new Builder<SaltUpdateState, SaltUpdateEvent>().defaultFailureEvent(SALT_UPDATE_FAILED_EVENT)\n+            .from(INIT_STATE).to(UPDATE_SALT_STATE_FILES_STATE).event(SALT_UPDATE_EVENT).defaultFailureEvent()\n+            .from(UPDATE_SALT_STATE_FILES_STATE).to(UPLOAD_RECIPES_FOR_SU_STATE).event(BOOTSTRAP_MACHINES_FINISHED_EVENT)\n+                    .failureEvent(BOOTSTRAP_MACHINES_FAILED_EVENT)\n+            .from(UPLOAD_RECIPES_FOR_SU_STATE).to(RECONFIGURE_KEYTABS_FOR_SU_STATE).event(UPLOAD_RECIPES_FINISHED_EVENT)\n+                    .failureEvent(UPLOAD_RECIPES_FAILED_EVENT)\n+            .from(RECONFIGURE_KEYTABS_FOR_SU_STATE).to(RUN_HIGHSTATE_STATE).event(CONFIGURE_KEYTABS_FINISHED_EVENT).failureEvent(CONFIGURE_KEYTABS_FAILED_EVENT)\n+            .from(RUN_HIGHSTATE_STATE).to(SALT_UPDATE_FINISHED_STATE).event(START_AMBARI_SERVICES_FINISHED_EVENT)\n+                    .failureEvent(START_AMBARI_SERVICES_FAILED_EVENT)\n+            .from(SALT_UPDATE_FINISHED_STATE).to(FINAL_STATE).event(SALT_UPDATE_FINISHED_EVENT).noFailureEvent()\n+            .build();\n+\n+    public SaltUpdateFlowConfig() {\n+        super(SaltUpdateState.class, SaltUpdateEvent.class);\n+    }\n+\n+    @Override\n+    protected List<Transition<SaltUpdateState, SaltUpdateEvent>> getTransitions() {\n+        return TRANSITIONS;\n+    }\n+\n+    @Override\n+    protected FlowEdgeConfig<SaltUpdateState, SaltUpdateEvent> getEdgeConfig() {\n+        return new FlowEdgeConfig<>(INIT_STATE, FINAL_STATE, SALT_UPDATE_FAILED_STATE, SALT_UPDATE_FAILURE_HANDLED_EVENT);\n+    }\n+\n+    @Override\n+    public SaltUpdateEvent[] getEvents() {\n+        return SaltUpdateEvent.values();\n+    }\n+\n+    @Override\n+    public SaltUpdateEvent[] getInitEvents() {\n+        return new SaltUpdateEvent[]{SaltUpdateEvent.SALT_UPDATE_EVENT};", "originalCommit": "0b841b27b9ef62246c17d217b595605cfc92f35f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwMjkzNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#discussion_r435802934", "bodyText": "Duplication from ClusterCreationService", "author": "keyki", "createdAt": "2020-06-05T09:30:06Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/salt/update/SaltUpdateService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update;\n+\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.AVAILABLE;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.CREATE_FAILED;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.UPDATE_IN_PROGRESS;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_BUILT;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_CREATE_FAILED;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_RUN_SERVICES;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.STACK_INFRASTRUCTURE_BOOTSTRAP;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService.TransactionExecutionException;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService.TransactionRuntimeExecutionException;\n+import com.sequenceiq.cloudbreak.core.flow2.stack.CloudbreakFlowMessageService;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.view.StackView;\n+import com.sequenceiq.cloudbreak.service.CloudbreakException;\n+import com.sequenceiq.cloudbreak.service.StackUpdater;\n+import com.sequenceiq.cloudbreak.service.cluster.ClusterService;\n+\n+@Component\n+public class SaltUpdateService {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SaltUpdateService.class);\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    @Inject\n+    private CloudbreakFlowMessageService flowMessageService;\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private TransactionService transactionService;\n+\n+    public void bootstrappingMachines(Stack stack) {\n+        stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.BOOTSTRAPPING_MACHINES);\n+        flowMessageService.fireEventAndLog(stack.getId(), UPDATE_IN_PROGRESS.name(), STACK_INFRASTRUCTURE_BOOTSTRAP);\n+    }\n+\n+    public void startingClusterServices(StackView stack) {\n+        stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.STARTING_CLUSTER_MANAGER_SERVICES, \"Running cluster services.\");\n+        flowMessageService.fireEventAndLog(stack.getId(), UPDATE_IN_PROGRESS.name(), CLUSTER_RUN_SERVICES);\n+    }\n+\n+    public void clusterInstallationFinished(StackView stackView) {\n+        try {", "originalCommit": "0b841b27b9ef62246c17d217b595605cfc92f35f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2MjgxOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#discussion_r435862818", "bodyText": "I'm updating messages to reflect it's not cluster creation", "author": "lacikaaa", "createdAt": "2020-06-05T11:35:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwMjkzNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwMzEzOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#discussion_r435803139", "bodyText": "Duplication from ClusterCreationService", "author": "keyki", "createdAt": "2020-06-05T09:30:29Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/salt/update/SaltUpdateService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update;\n+\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.AVAILABLE;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.CREATE_FAILED;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.UPDATE_IN_PROGRESS;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_BUILT;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_CREATE_FAILED;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_RUN_SERVICES;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.STACK_INFRASTRUCTURE_BOOTSTRAP;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService.TransactionExecutionException;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService.TransactionRuntimeExecutionException;\n+import com.sequenceiq.cloudbreak.core.flow2.stack.CloudbreakFlowMessageService;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.view.StackView;\n+import com.sequenceiq.cloudbreak.service.CloudbreakException;\n+import com.sequenceiq.cloudbreak.service.StackUpdater;\n+import com.sequenceiq.cloudbreak.service.cluster.ClusterService;\n+\n+@Component\n+public class SaltUpdateService {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SaltUpdateService.class);\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    @Inject\n+    private CloudbreakFlowMessageService flowMessageService;\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private TransactionService transactionService;\n+\n+    public void bootstrappingMachines(Stack stack) {\n+        stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.BOOTSTRAPPING_MACHINES);\n+        flowMessageService.fireEventAndLog(stack.getId(), UPDATE_IN_PROGRESS.name(), STACK_INFRASTRUCTURE_BOOTSTRAP);\n+    }\n+\n+    public void startingClusterServices(StackView stack) {\n+        stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.STARTING_CLUSTER_MANAGER_SERVICES, \"Running cluster services.\");\n+        flowMessageService.fireEventAndLog(stack.getId(), UPDATE_IN_PROGRESS.name(), CLUSTER_RUN_SERVICES);\n+    }\n+\n+    public void clusterInstallationFinished(StackView stackView) {\n+        try {\n+            transactionService.required(() -> {\n+                clusterService.updateClusterStatusByStackId(stackView.getId(), AVAILABLE);\n+                stackUpdater.updateStackStatus(stackView.getId(), DetailedStackStatus.AVAILABLE, \"Cluster creation finished.\");\n+                flowMessageService.fireEventAndLog(stackView.getId(), AVAILABLE.name(), CLUSTER_BUILT);\n+            });\n+        } catch (TransactionExecutionException e) {\n+            throw new TransactionRuntimeExecutionException(e);\n+        }\n+    }\n+\n+    public void handleClusterCreationFailure(StackView stackView, Exception exception) {\n+        if (stackView.getClusterView() != null) {", "originalCommit": "0b841b27b9ef62246c17d217b595605cfc92f35f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTg2MjYzOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#discussion_r435862639", "bodyText": "I'm updating messages to reflect it's not cluster creation", "author": "lacikaaa", "createdAt": "2020-06-05T11:35:14Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwMzEzOQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNTgwMzcwMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8200#discussion_r435803700", "bodyText": "Same duplication.", "author": "keyki", "createdAt": "2020-06-05T09:31:26Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/cluster/salt/update/SaltUpdateService.java", "diffHunk": "@@ -0,0 +1,85 @@\n+package com.sequenceiq.cloudbreak.core.flow2.cluster.salt.update;\n+\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.AVAILABLE;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.CREATE_FAILED;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.UPDATE_IN_PROGRESS;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_BUILT;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_CREATE_FAILED;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.CLUSTER_RUN_SERVICES;\n+import static com.sequenceiq.cloudbreak.event.ResourceEvent.STACK_INFRASTRUCTURE_BOOTSTRAP;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.DetailedStackStatus;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService.TransactionExecutionException;\n+import com.sequenceiq.cloudbreak.common.service.TransactionService.TransactionRuntimeExecutionException;\n+import com.sequenceiq.cloudbreak.core.flow2.stack.CloudbreakFlowMessageService;\n+import com.sequenceiq.cloudbreak.domain.stack.Stack;\n+import com.sequenceiq.cloudbreak.domain.view.StackView;\n+import com.sequenceiq.cloudbreak.service.CloudbreakException;\n+import com.sequenceiq.cloudbreak.service.StackUpdater;\n+import com.sequenceiq.cloudbreak.service.cluster.ClusterService;\n+\n+@Component\n+public class SaltUpdateService {\n+    private static final Logger LOGGER = LoggerFactory.getLogger(SaltUpdateService.class);\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    @Inject\n+    private CloudbreakFlowMessageService flowMessageService;\n+\n+    @Inject\n+    private ClusterService clusterService;\n+\n+    @Inject\n+    private TransactionService transactionService;\n+\n+    public void bootstrappingMachines(Stack stack) {\n+        stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.BOOTSTRAPPING_MACHINES);\n+        flowMessageService.fireEventAndLog(stack.getId(), UPDATE_IN_PROGRESS.name(), STACK_INFRASTRUCTURE_BOOTSTRAP);\n+    }\n+\n+    public void startingClusterServices(StackView stack) {\n+        stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.STARTING_CLUSTER_MANAGER_SERVICES, \"Running cluster services.\");\n+        flowMessageService.fireEventAndLog(stack.getId(), UPDATE_IN_PROGRESS.name(), CLUSTER_RUN_SERVICES);\n+    }\n+\n+    public void clusterInstallationFinished(StackView stackView) {\n+        try {\n+            transactionService.required(() -> {\n+                clusterService.updateClusterStatusByStackId(stackView.getId(), AVAILABLE);\n+                stackUpdater.updateStackStatus(stackView.getId(), DetailedStackStatus.AVAILABLE, \"Cluster creation finished.\");\n+                flowMessageService.fireEventAndLog(stackView.getId(), AVAILABLE.name(), CLUSTER_BUILT);\n+            });\n+        } catch (TransactionExecutionException e) {\n+            throw new TransactionRuntimeExecutionException(e);\n+        }\n+    }\n+\n+    public void handleClusterCreationFailure(StackView stackView, Exception exception) {\n+        if (stackView.getClusterView() != null) {\n+            String errorMessage = getErrorMessageFromException(exception);\n+            clusterService.updateClusterStatusByStackId(stackView.getId(), CREATE_FAILED, errorMessage);\n+            stackUpdater.updateStackStatus(stackView.getId(), DetailedStackStatus.AVAILABLE);\n+            flowMessageService.fireEventAndLog(stackView.getId(), CREATE_FAILED.name(), CLUSTER_CREATE_FAILED, errorMessage);\n+        } else {\n+            LOGGER.info(\"Cluster was null. Flow action was not required.\");\n+        }\n+    }\n+\n+    private String getErrorMessageFromException(Exception exception) {\n+        if (exception instanceof TransactionRuntimeExecutionException && exception.getCause() != null && exception.getCause().getCause() != null) {", "originalCommit": "0b841b27b9ef62246c17d217b595605cfc92f35f", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "9fbc475871c79efa8d75d34a6afe33a88df8c200", "url": "https://github.com/hortonworks/cloudbreak/commit/9fbc475871c79efa8d75d34a6afe33a88df8c200", "message": "CB-6637 Internal API for Salt upgrade testing", "committedDate": "2020-06-05T14:04:14Z", "type": "forcePushed"}, {"oid": "eecfac40a3fb2fa13bb4616b3ee2c6d8a09cd5f8", "url": "https://github.com/hortonworks/cloudbreak/commit/eecfac40a3fb2fa13bb4616b3ee2c6d8a09cd5f8", "message": "CB-6637 Internal API for Salt upgrade testing", "committedDate": "2020-06-05T14:50:33Z", "type": "commit"}, {"oid": "eecfac40a3fb2fa13bb4616b3ee2c6d8a09cd5f8", "url": "https://github.com/hortonworks/cloudbreak/commit/eecfac40a3fb2fa13bb4616b3ee2c6d8a09cd5f8", "message": "CB-6637 Internal API for Salt upgrade testing", "committedDate": "2020-06-05T14:50:33Z", "type": "forcePushed"}]}