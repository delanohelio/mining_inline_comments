{"pr_number": 8033, "pr_title": "CB-6751 WaitUtil and WaitForMultipleStatuses overall refactor part 2", "pr_createdAt": "2020-05-13T09:50:27Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/8033", "timeline": [{"oid": "3b71198fbc7f1b1792eb1b581811858800e420c5", "url": "https://github.com/hortonworks/cloudbreak/commit/3b71198fbc7f1b1792eb1b581811858800e420c5", "message": "CB-6751 WaitUtil and WaitForMultipleStatuses overall refactor part 2", "committedDate": "2020-05-13T11:38:07Z", "type": "forcePushed"}, {"oid": "82af64fc2a68355e70ef67cf00b32343bbce8e38", "url": "https://github.com/hortonworks/cloudbreak/commit/82af64fc2a68355e70ef67cf00b32343bbce8e38", "message": "CB-6751 WaitUtil and WaitForMultipleStatuses overall refactor part 2", "committedDate": "2020-05-13T12:36:37Z", "type": "forcePushed"}, {"oid": "6751b0cad450205dcef310d42f56db019ce993fd", "url": "https://github.com/hortonworks/cloudbreak/commit/6751b0cad450205dcef310d42f56db019ce993fd", "message": "CB-6751 WaitUtil and WaitForMultipleStatuses overall refactor part 2", "committedDate": "2020-05-13T14:39:42Z", "type": "forcePushed"}, {"oid": "e4a34c9e02a70b5bdfa29c258c81356c5babb2d3", "url": "https://github.com/hortonworks/cloudbreak/commit/e4a34c9e02a70b5bdfa29c258c81356c5babb2d3", "message": "CB-6751 WaitUtil and WaitForMultipleStatuses overall refactor part 2", "committedDate": "2020-05-14T15:19:38Z", "type": "forcePushed"}, {"oid": "98b9b37cec300fcb7a587786e82a21a58aeb2263", "url": "https://github.com/hortonworks/cloudbreak/commit/98b9b37cec300fcb7a587786e82a21a58aeb2263", "message": "OOM Kill is disabled for Test", "committedDate": "2020-05-14T16:46:42Z", "type": "forcePushed"}, {"oid": "e4a34c9e02a70b5bdfa29c258c81356c5babb2d3", "url": "https://github.com/hortonworks/cloudbreak/commit/e4a34c9e02a70b5bdfa29c258c81356c5babb2d3", "message": "CB-6751 WaitUtil and WaitForMultipleStatuses overall refactor part 2", "committedDate": "2020-05-14T15:19:38Z", "type": "forcePushed"}, {"oid": "526f2b9cbe5c349587ba2a0c872c782341132b27", "url": "https://github.com/hortonworks/cloudbreak/commit/526f2b9cbe5c349587ba2a0c872c782341132b27", "message": "Introduce heap dump", "committedDate": "2020-05-15T11:24:49Z", "type": "forcePushed"}, {"oid": "521652cf950837661ab50d19bbb30412e0d1d2f3", "url": "https://github.com/hortonworks/cloudbreak/commit/521652cf950837661ab50d19bbb30412e0d1d2f3", "message": "Replace Await interface", "committedDate": "2020-05-17T08:10:51Z", "type": "forcePushed"}, {"oid": "30c179cc7508160452aa887be022b48dcb6798cc", "url": "https://github.com/hortonworks/cloudbreak/commit/30c179cc7508160452aa887be022b48dcb6798cc", "message": "Replace Await interface", "committedDate": "2020-05-17T09:29:42Z", "type": "forcePushed"}, {"oid": "0f9b7c0945bd56defed6f9bde1424e524c0057a7", "url": "https://github.com/hortonworks/cloudbreak/commit/0f9b7c0945bd56defed6f9bde1424e524c0057a7", "message": "Replace Await interface", "committedDate": "2020-05-19T06:58:57Z", "type": "forcePushed"}, {"oid": "2fa44c1e3d7c9d8d494f2c0d53953b129062cc57", "url": "https://github.com/hortonworks/cloudbreak/commit/2fa44c1e3d7c9d8d494f2c0d53953b129062cc57", "message": "CB-6751 WaitUtil and WaitForMultipleStatuses overall refactor part 2", "committedDate": "2020-05-19T07:04:58Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc2MDk0Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8033#discussion_r427760942", "bodyText": "Why are we refreshing with null?", "author": "lnardai", "createdAt": "2020-05-20T06:05:37Z", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/database/DatabaseAwait.java", "diffHunk": "@@ -0,0 +1,72 @@\n+package com.sequenceiq.it.cloudbreak.util.wait.service.database;\n+\n+import static com.sequenceiq.redbeams.api.model.common.Status.DELETE_COMPLETED;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.it.cloudbreak.RedbeamsClient;\n+import com.sequenceiq.it.cloudbreak.context.RunningParameter;\n+import com.sequenceiq.it.cloudbreak.context.TestContext;\n+import com.sequenceiq.it.cloudbreak.dto.database.RedbeamsDatabaseServerTestDto;\n+import com.sequenceiq.it.cloudbreak.log.Log;\n+import com.sequenceiq.it.cloudbreak.util.ResponseUtil;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.Await;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.ExceptionChecker;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.Result;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.WaitResult;\n+import com.sequenceiq.redbeams.api.model.common.Status;\n+\n+@Component\n+public class DatabaseAwait extends Await<RedbeamsDatabaseServerTestDto, Status> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DatabaseAwait.class);\n+\n+    @Override\n+    public RedbeamsDatabaseServerTestDto await(RedbeamsDatabaseServerTestDto entity, Status desiredStatus, TestContext testContext,\n+            RunningParameter runningParameter, long pollingInterval, int maxRetry) {\n+        try {\n+            if (entity == null) {\n+                throw new RuntimeException(\"Database key has been provided but no result in resource map!\");\n+            }\n+            Log.await(LOGGER, String.format(\"%s for %s\", entity.getResponse().getName(), desiredStatus));\n+            RedbeamsClient client = testContext.getMicroserviceClient(RedbeamsClient.class, testContext.getWho(runningParameter)\n+                    .getAccessKey());\n+            String crn = entity.getResponse().getResourceCrn();\n+            switch (desiredStatus) {\n+                case AVAILABLE:\n+                case STOPPED:\n+                    waitForDatabaseStatus(new DatabaseOperationChecker<>(), client, crn, testContext, desiredStatus,\n+                            pollingInterval, maxRetry);\n+                    break;\n+                case DELETE_COMPLETED:\n+                    waitForDatabaseStatus(new DatabaseTerminationChecker<>(), client, crn, testContext, desiredStatus,\n+                            pollingInterval, maxRetry);\n+                    break;\n+                default:\n+                    LOGGER.warn(\"Wait checker is not implemented yet for the desired database state '{}' \", desiredStatus);\n+                    break;\n+            }\n+            if (!desiredStatus.equals(DELETE_COMPLETED)) {\n+                entity.refresh(testContext, null);", "originalCommit": "2fa44c1e3d7c9d8d494f2c0d53953b129062cc57", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzkzNjkwMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8033#discussion_r427936901", "bodyText": "Here is the CloudbreakClient should be passed.\nawaitEntity.refresh(getTestContext(), (CloudbreakClient) null);}\nHowever that is not defined in RedbeamsDatabaseServerTestDto await.\nAnyway we can remove this from Redbeams Await, because of Redbeams is\n\n\"not refreshable resource\"\n\nindeed", "author": "aszegedi", "createdAt": "2020-05-20T11:30:19Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQyNzc2MDk0Mg=="}], "type": "inlineReview"}, {"oid": "193c714b6463b0533b7fca5bfc14f83eb66b7c5f", "url": "https://github.com/hortonworks/cloudbreak/commit/193c714b6463b0533b7fca5bfc14f83eb66b7c5f", "message": "CB-6751 WaitUtil and WaitForMultipleStatuses overall refactor part 2", "committedDate": "2020-05-22T07:42:35Z", "type": "forcePushed"}, {"oid": "859316b8eb81bfe4c26ae80eb408e5a88952dabc", "url": "https://github.com/hortonworks/cloudbreak/commit/859316b8eb81bfe4c26ae80eb408e5a88952dabc", "message": "CB-6751 WaitUtil and WaitForMultipleStatuses overall refactor part 2", "committedDate": "2020-05-22T07:43:22Z", "type": "forcePushed"}, {"oid": "a2ca16e6416cfa400aa9890f6facc836c2cf1492", "url": "https://github.com/hortonworks/cloudbreak/commit/a2ca16e6416cfa400aa9890f6facc836c2cf1492", "message": "CB-6751 WaitUtil and WaitForMultipleStatuses overall refactor part 2", "committedDate": "2020-05-22T09:07:42Z", "type": "forcePushed"}, {"oid": "278a17ff62aef2cc3371296778f539072a947958", "url": "https://github.com/hortonworks/cloudbreak/commit/278a17ff62aef2cc3371296778f539072a947958", "message": "CB-6751 WaitUtil and WaitForMultipleStatuses overall refactor part 2", "committedDate": "2020-05-22T18:54:04Z", "type": "forcePushed"}, {"oid": "3a1bfcc858e8d358a29bff1ca1e5cf67b65d1dfc", "url": "https://github.com/hortonworks/cloudbreak/commit/3a1bfcc858e8d358a29bff1ca1e5cf67b65d1dfc", "message": "CB-6751 WaitUtil and WaitForMultipleStatuses overall refactor part 2", "committedDate": "2020-05-23T16:21:24Z", "type": "forcePushed"}, {"oid": "feb111972b75811cb6f6b71d187f78111cd40cf5", "url": "https://github.com/hortonworks/cloudbreak/commit/feb111972b75811cb6f6b71d187f78111cd40cf5", "message": "CB-6751 WaitUtil and WaitForMultipleStatuses overall refactor part 2", "committedDate": "2020-05-23T18:49:38Z", "type": "forcePushed"}, {"oid": "c4492a300357bb0068805091911643075df7dfcf", "url": "https://github.com/hortonworks/cloudbreak/commit/c4492a300357bb0068805091911643075df7dfcf", "message": "CB-6751 WaitUtil and WaitForMultipleStatuses overall refactor part 2", "committedDate": "2020-05-24T19:28:06Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNjExMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8033#discussion_r432306112", "bodyText": "I think the below alternative is more efficient.\n        Set<Status> failedStatuses = Set.of(UPDATE_FAILED, CREATE_FAILED, ENABLE_SECURITY_FAILED, DELETE_FAILED, START_FAILED, STOP_FAILED,\n                EXTERNAL_DATABASE_CREATION_FAILED, EXTERNAL_DATABASE_DELETION_FAILED);\n        return !Sets.intersection(failedStatuses, Set.copyOf(distroxStatuses.values())).isEmpty();", "author": "foldik", "createdAt": "2020-05-29T07:33:37Z", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/cloudbreak/CloudbreakWaitObject.java", "diffHunk": "@@ -0,0 +1,64 @@\n+package com.sequenceiq.it.cloudbreak.util.wait.service.cloudbreak;\n+\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.CREATE_FAILED;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.DELETE_FAILED;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.ENABLE_SECURITY_FAILED;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.EXTERNAL_DATABASE_CREATION_FAILED;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.EXTERNAL_DATABASE_DELETION_FAILED;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.START_FAILED;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.STOP_FAILED;\n+import static com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status.UPDATE_FAILED;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.commons.collections.CollectionUtils;\n+\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.common.Status;\n+import com.sequenceiq.cloudbreak.api.endpoint.v4.stacks.StackV4Endpoint;\n+import com.sequenceiq.distrox.api.v1.distrox.endpoint.DistroXV1Endpoint;\n+import com.sequenceiq.it.cloudbreak.CloudbreakClient;\n+\n+public class CloudbreakWaitObject {\n+\n+    private final CloudbreakClient client;\n+\n+    private final String name;\n+\n+    private final Map<String, Status> desiredStatuses;\n+\n+    public CloudbreakWaitObject(CloudbreakClient client, String name, Map<String, Status> desiredStatuses) {\n+        this.client = client;\n+        this.name = name;\n+        this.desiredStatuses = desiredStatuses;\n+    }\n+\n+    public DistroXV1Endpoint getDistroxEndpoint() {\n+        return client.getCloudbreakClient().distroXV1Endpoint();\n+    }\n+\n+    public StackV4Endpoint getStackEndpoint() {\n+        return client.getCloudbreakClient().stackV4Endpoint();\n+    }\n+\n+    public Long getWorkspaceId() {\n+        return client.getWorkspaceId();\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public Map<String, Status> getDesiredStatuses() {\n+        return desiredStatuses;\n+    }\n+\n+    public boolean isFailed(Map<String, Status> distroxStatuses) {", "originalCommit": "c4492a300357bb0068805091911643075df7dfcf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwNzY3OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8033#discussion_r432307678", "bodyText": "Why call it twice? I guess the compiler will optimize it anyway but still strange a bit. I saw it earlier as well in other files. Can you please introduce a message variable?", "author": "foldik", "createdAt": "2020-05-29T07:37:05Z", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/database/DatabaseOperationChecker.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package com.sequenceiq.it.cloudbreak.util.wait.service.database;\n+\n+import static com.sequenceiq.redbeams.api.model.common.Status.CREATE_FAILED;\n+import static com.sequenceiq.redbeams.api.model.common.Status.DELETE_COMPLETED;\n+import static com.sequenceiq.redbeams.api.model.common.Status.DELETE_IN_PROGRESS;\n+import static com.sequenceiq.redbeams.api.model.common.Status.DELETE_REQUESTED;\n+import static com.sequenceiq.redbeams.api.model.common.Status.PRE_DELETE_IN_PROGRESS;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.ws.rs.ProcessingException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.sequenceiq.it.cloudbreak.exception.TestFailException;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.ExceptionChecker;\n+import com.sequenceiq.redbeams.api.endpoint.v4.databaseserver.responses.DatabaseServerV4Response;\n+import com.sequenceiq.redbeams.api.model.common.Status;\n+\n+public class DatabaseOperationChecker<T extends DatabaseWaitObject> extends ExceptionChecker<T> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DatabaseOperationChecker.class);\n+\n+    @Override\n+    public boolean checkStatus(T waitObject) {\n+        String crn = waitObject.getCrn();\n+        Status desiredStatus = waitObject.getDesiredStatus();\n+        try {\n+            DatabaseServerV4Response database = waitObject.getEndpoint().getByCrn(crn);\n+            if (database == null) {\n+                throw new TestFailException(String.format(\"'%s' database was not found.\", crn));\n+            }\n+            String name = database.getName();\n+            Status status = database.getStatus();\n+            LOGGER.info(\"Waiting for the '{}' state of '{}' '{}' database. Actual state is: '{}'\", desiredStatus, name, crn, status);\n+            if (isDeletionInProgress(status) || status == DELETE_COMPLETED) {\n+                LOGGER.error(\"Database '{}' '{}' has been getting terminated (status:'{}'), waiting is cancelled.\", name, crn, status);\n+                throw new TestFailException(String.format(\"Database '%s' '%s' has been getting terminated (status:'%s'), waiting is cancelled.\", name, crn,\n+                        status));\n+            }\n+            if (waitObject.isFailed(status)) {\n+                LOGGER.error(\"Database '{}' '{}' is in failed state (status:'{}'), waiting is cancelled.\", name, crn, status);\n+                throw new TestFailException(String.format(\"Database '%s' '%s' is in failed state. Status: '%s' statusReason: '%s'\",\n+                        name, crn, status, database.getStatusReason()));\n+            }\n+            if (desiredStatus.equals(status)) {\n+                return true;\n+            }\n+        } catch (Exception e) {\n+            StringBuilder builder = new StringBuilder(\"Database has been failed. Also failed to get database status: \")\n+                    .append(System.lineSeparator())\n+                    .append(e.getMessage())\n+                    .append(System.lineSeparator())\n+                    .append(e);\n+            LOGGER.error(builder.toString());", "originalCommit": "c4492a300357bb0068805091911643075df7dfcf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwODY3MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8033#discussion_r432308670", "bodyText": "For pure logging please use the LOGGER.error(\"message {} {}\", arg1,, arg2) format. I saw it other places as well. Please avoid manual string concatenation when possible.", "author": "foldik", "createdAt": "2020-05-29T07:39:13Z", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/database/DatabaseOperationChecker.java", "diffHunk": "@@ -0,0 +1,135 @@\n+package com.sequenceiq.it.cloudbreak.util.wait.service.database;\n+\n+import static com.sequenceiq.redbeams.api.model.common.Status.CREATE_FAILED;\n+import static com.sequenceiq.redbeams.api.model.common.Status.DELETE_COMPLETED;\n+import static com.sequenceiq.redbeams.api.model.common.Status.DELETE_IN_PROGRESS;\n+import static com.sequenceiq.redbeams.api.model.common.Status.DELETE_REQUESTED;\n+import static com.sequenceiq.redbeams.api.model.common.Status.PRE_DELETE_IN_PROGRESS;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+\n+import javax.ws.rs.ProcessingException;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import com.sequenceiq.it.cloudbreak.exception.TestFailException;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.ExceptionChecker;\n+import com.sequenceiq.redbeams.api.endpoint.v4.databaseserver.responses.DatabaseServerV4Response;\n+import com.sequenceiq.redbeams.api.model.common.Status;\n+\n+public class DatabaseOperationChecker<T extends DatabaseWaitObject> extends ExceptionChecker<T> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DatabaseOperationChecker.class);\n+\n+    @Override\n+    public boolean checkStatus(T waitObject) {\n+        String crn = waitObject.getCrn();\n+        Status desiredStatus = waitObject.getDesiredStatus();\n+        try {\n+            DatabaseServerV4Response database = waitObject.getEndpoint().getByCrn(crn);\n+            if (database == null) {\n+                throw new TestFailException(String.format(\"'%s' database was not found.\", crn));\n+            }\n+            String name = database.getName();\n+            Status status = database.getStatus();\n+            LOGGER.info(\"Waiting for the '{}' state of '{}' '{}' database. Actual state is: '{}'\", desiredStatus, name, crn, status);\n+            if (isDeletionInProgress(status) || status == DELETE_COMPLETED) {\n+                LOGGER.error(\"Database '{}' '{}' has been getting terminated (status:'{}'), waiting is cancelled.\", name, crn, status);\n+                throw new TestFailException(String.format(\"Database '%s' '%s' has been getting terminated (status:'%s'), waiting is cancelled.\", name, crn,\n+                        status));\n+            }\n+            if (waitObject.isFailed(status)) {\n+                LOGGER.error(\"Database '{}' '{}' is in failed state (status:'{}'), waiting is cancelled.\", name, crn, status);\n+                throw new TestFailException(String.format(\"Database '%s' '%s' is in failed state. Status: '%s' statusReason: '%s'\",\n+                        name, crn, status, database.getStatusReason()));\n+            }\n+            if (desiredStatus.equals(status)) {\n+                return true;\n+            }\n+        } catch (Exception e) {\n+            StringBuilder builder = new StringBuilder(\"Database has been failed. Also failed to get database status: \")\n+                    .append(System.lineSeparator())\n+                    .append(e.getMessage())\n+                    .append(System.lineSeparator())\n+                    .append(e);\n+            LOGGER.error(builder.toString());\n+            throw new TestFailException(builder.toString());\n+        }\n+        return false;\n+    }\n+\n+    @Override\n+    public void handleTimeout(T waitObject) {\n+        String crn = waitObject.getCrn();\n+        try {\n+            DatabaseServerV4Response database = waitObject.getEndpoint().getByCrn(crn);\n+            if (database == null) {\n+                throw new TestFailException(String.format(\"'%s' database was not found.\", crn));\n+            }\n+            String name = database.getName();\n+            Status status = database.getStatus();\n+            throw new TestFailException(String.format(\"Wait operation timed out, database '%s' '%s' has been failed. Database status: '%s' \"\n+                    + \"statusReason: '%s'\", name, crn, status, database.getStatusReason()));\n+        } catch (Exception e) {\n+            StringBuilder builder = new StringBuilder(\"Wait operation timed out, database has been failed. Also failed to get database status: \")\n+                    .append(System.lineSeparator())\n+                    .append(e.getMessage())\n+                    .append(System.lineSeparator())\n+                    .append(e);\n+            LOGGER.error(builder.toString());", "originalCommit": "c4492a300357bb0068805091911643075df7dfcf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMwOTY5OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8033#discussion_r432309698", "bodyText": "Please use a Set instead.", "author": "foldik", "createdAt": "2020-05-29T07:41:14Z", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/database/DatabaseWaitObject.java", "diffHunk": "@@ -0,0 +1,47 @@\n+package com.sequenceiq.it.cloudbreak.util.wait.service.database;\n+\n+import static com.sequenceiq.redbeams.api.model.common.Status.CREATE_FAILED;\n+import static com.sequenceiq.redbeams.api.model.common.Status.DELETE_FAILED;\n+import static com.sequenceiq.redbeams.api.model.common.Status.ENABLE_SECURITY_FAILED;\n+import static com.sequenceiq.redbeams.api.model.common.Status.START_FAILED;\n+import static com.sequenceiq.redbeams.api.model.common.Status.STOP_FAILED;\n+import static com.sequenceiq.redbeams.api.model.common.Status.UPDATE_FAILED;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import com.sequenceiq.it.cloudbreak.RedbeamsClient;\n+import com.sequenceiq.redbeams.api.endpoint.v4.databaseserver.DatabaseServerV4Endpoint;\n+import com.sequenceiq.redbeams.api.model.common.Status;\n+\n+public class DatabaseWaitObject {\n+\n+    private final RedbeamsClient client;\n+\n+    private final String crn;\n+\n+    private final Status desiredStatus;\n+\n+    public DatabaseWaitObject(RedbeamsClient client, String crn, Status desiredStatus) {\n+        this.client = client;\n+        this.crn = crn;\n+        this.desiredStatus = desiredStatus;\n+    }\n+\n+    public DatabaseServerV4Endpoint getEndpoint() {\n+        return client.getEndpoints().databaseServerV4Endpoint();\n+    }\n+\n+    public String getCrn() {\n+        return crn;\n+    }\n+\n+    public Status getDesiredStatus() {\n+        return desiredStatus;\n+    }\n+\n+    public boolean isFailed(Status databaseStatus) {\n+        Collection<Status> failedStatuses = List.of(UPDATE_FAILED, CREATE_FAILED, ENABLE_SECURITY_FAILED, DELETE_FAILED, START_FAILED, STOP_FAILED);", "originalCommit": "c4492a300357bb0068805091911643075df7dfcf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxMDI4OA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8033#discussion_r432310288", "bodyText": "Please use a Set.", "author": "foldik", "createdAt": "2020-05-29T07:42:22Z", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/datalake/DatalakeWaitObject.java", "diffHunk": "@@ -0,0 +1,50 @@\n+package com.sequenceiq.it.cloudbreak.util.wait.service.datalake;\n+\n+import static com.sequenceiq.sdx.api.model.SdxClusterStatusResponse.DATALAKE_UPGRADE_FAILED;\n+import static com.sequenceiq.sdx.api.model.SdxClusterStatusResponse.DELETE_FAILED;\n+import static com.sequenceiq.sdx.api.model.SdxClusterStatusResponse.PROVISIONING_FAILED;\n+import static com.sequenceiq.sdx.api.model.SdxClusterStatusResponse.REPAIR_FAILED;\n+import static com.sequenceiq.sdx.api.model.SdxClusterStatusResponse.START_FAILED;\n+import static com.sequenceiq.sdx.api.model.SdxClusterStatusResponse.STOP_FAILED;\n+import static com.sequenceiq.sdx.api.model.SdxClusterStatusResponse.SYNC_FAILED;\n+import static com.sequenceiq.sdx.api.model.SdxClusterStatusResponse.UPGRADE_FAILED;\n+\n+import java.util.Collection;\n+import java.util.List;\n+\n+import com.sequenceiq.it.cloudbreak.SdxClient;\n+import com.sequenceiq.sdx.api.endpoint.SdxEndpoint;\n+import com.sequenceiq.sdx.api.model.SdxClusterStatusResponse;\n+\n+public class DatalakeWaitObject {\n+\n+    private final SdxClient client;\n+\n+    private final String name;\n+\n+    private final SdxClusterStatusResponse desiredStatus;\n+\n+    public DatalakeWaitObject(SdxClient client, String name, SdxClusterStatusResponse desiredStatus) {\n+        this.client = client;\n+        this.name = name;\n+        this.desiredStatus = desiredStatus;\n+    }\n+\n+    public SdxEndpoint getEndpoint() {\n+        return client.getSdxClient().sdxEndpoint();\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public SdxClusterStatusResponse getDesiredStatus() {\n+        return desiredStatus;\n+    }\n+\n+    public boolean isFailed(SdxClusterStatusResponse datalakeStatus) {\n+        Collection<SdxClusterStatusResponse> failedStatuses = List.of(PROVISIONING_FAILED, REPAIR_FAILED, UPGRADE_FAILED, DATALAKE_UPGRADE_FAILED,", "originalCommit": "c4492a300357bb0068805091911643075df7dfcf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMjMxMDgyOQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8033#discussion_r432310829", "bodyText": "Please use a set.", "author": "foldik", "createdAt": "2020-05-29T07:43:16Z", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/environment/EnvironmentOperationChecker.java", "diffHunk": "@@ -112,24 +113,29 @@ public boolean exitWaiting(T waitObject) {\n             }\n             return status.isFailed();\n         } catch (ProcessingException clientException) {\n-            StringBuilder builder = new StringBuilder(\"Exit waiting! Failed to get environment due to API client exception: \")\n-                    .append(System.lineSeparator())\n-                    .append(clientException.getMessage())\n-                    .append(System.lineSeparator())\n-                    .append(clientException);\n-            LOGGER.error(builder.toString());\n+            String builder = \"Exit waiting! Failed to get environment due to API client exception: \" +\n+                    System.lineSeparator() +\n+                    clientException.getMessage() +\n+                    System.lineSeparator() +\n+                    clientException;\n+            LOGGER.error(builder);\n         } catch (Exception e) {\n-            StringBuilder builder = new StringBuilder(\"Exit waiting! Failed to get environment, because of: \")\n-                    .append(System.lineSeparator())\n-                    .append(e.getMessage())\n-                    .append(System.lineSeparator())\n-                    .append(e);\n-            LOGGER.error(builder.toString());\n+            String builder = \"Exit waiting! Failed to get environment, because of: \" +\n+                    System.lineSeparator() +\n+                    e.getMessage() +\n+                    System.lineSeparator() +\n+                    e;\n+            LOGGER.error(builder);\n             return true;\n         }\n         return false;\n     }\n \n+    @Override\n+    public Map<String, String> getStatuses(T waitObject) {\n+        return Map.of(\"status\", waitObject.getEndpoint().getByCrn(waitObject.getCrn()).getEnvironmentStatus().name());\n+    }\n+\n     private boolean isDeletionInProgress(EnvironmentStatus environmentStatus) {\n         Collection<EnvironmentStatus> deleteInProgressStatuses = List.of(DELETE_INITIATED, NETWORK_DELETE_IN_PROGRESS, RDBMS_DELETE_IN_PROGRESS,", "originalCommit": "c4492a300357bb0068805091911643075df7dfcf", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "7a477a27dc7441d01edc5effc0a1b890f0b27b55", "url": "https://github.com/hortonworks/cloudbreak/commit/7a477a27dc7441d01edc5effc0a1b890f0b27b55", "message": "CB-6751 WaitUtil and WaitForMultipleStatuses overall refactor part 2", "committedDate": "2020-05-29T12:31:18Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY1NTE2MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8033#discussion_r433655161", "bodyText": "I would rename t to WaitObject or something similar", "author": "gergopapi2", "createdAt": "2020-06-02T06:47:51Z", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/WaitService.java", "diffHunk": "@@ -1,27 +1,33 @@\n package com.sequenceiq.it.cloudbreak.util.wait.service;\n \n+import java.util.Map;\n+\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n import org.springframework.stereotype.Component;\n \n+import com.sequenceiq.it.cloudbreak.context.TestContext;\n+\n @Component\n public class WaitService<T> {\n     private static final Logger LOGGER = LoggerFactory.getLogger(WaitService.class);\n \n-    public Result<WaitResult, Exception> waitWithTimeout(StatusChecker<T> statusChecker, T t, long interval, int maxAttempts, int maxFailure) {\n-        return waitWithTimeout(statusChecker, t, interval, new TimeoutChecker(maxAttempts), maxFailure);\n+    public Result<WaitResult, Exception> waitWithTimeout(StatusChecker<T> statusChecker, T t, TestContext testContext, long interval, int maxAttempts,\n+            int maxFailure) {\n+        return waitWithTimeout(statusChecker, t, testContext, interval, new TimeoutChecker(maxAttempts), maxFailure);", "originalCommit": "7a477a27dc7441d01edc5effc0a1b890f0b27b55", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY1ODU5Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8033#discussion_r433658593", "bodyText": "In general I would use type Duration for a time duration, that has also a unit included. This might mean passing a type Duration and at the sleep step using Duration.toMillis() method.\nIf that is too big of a change, I would 1) extract this to a constant with name including the unit, and 2) rename the variables interval to intervalMillis.", "author": "gergopapi2", "createdAt": "2020-06-02T06:55:41Z", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/testcase/mock/clouderamanager/CMUpscaleWithHttp500ResponsesTest.java", "diffHunk": "@@ -131,7 +131,7 @@ public void testUpscale(MockedTestContext testContext) {\n                 .when(stackTestClient.createV4())\n                 .await(STACK_AVAILABLE)\n                 .when(StackScalePostAction.valid().withDesiredCount(desiredWorkerCount).withForced(Boolean.FALSE))\n-                .await(StackTestDto.class, STACK_AVAILABLE)\n+                .await(StackTestDto.class, STACK_AVAILABLE, 3000)", "originalCommit": "7a477a27dc7441d01edc5effc0a1b890f0b27b55", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY2MzEyMg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8033#discussion_r433663122", "bodyText": "I would rename Database* to Redbeams*, to avoid confusion with the existing Database endpoints on cloudbreak.\nOr, if you want to keep the database name, then I would rename it to DatabaseServer*, to avoid confusion with Database endpoints on redbeams.", "author": "gergopapi2", "createdAt": "2020-06-02T07:06:00Z", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/database/DatabaseAwait.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package com.sequenceiq.it.cloudbreak.util.wait.service.database;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.it.cloudbreak.RedbeamsClient;\n+import com.sequenceiq.it.cloudbreak.context.RunningParameter;\n+import com.sequenceiq.it.cloudbreak.context.TestContext;\n+import com.sequenceiq.it.cloudbreak.dto.database.RedbeamsDatabaseServerTestDto;\n+import com.sequenceiq.it.cloudbreak.log.Log;\n+import com.sequenceiq.it.cloudbreak.util.ResponseUtil;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.Await;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.ExceptionChecker;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.Result;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.WaitResult;\n+import com.sequenceiq.redbeams.api.model.common.Status;\n+\n+@Component\n+public class DatabaseAwait extends Await<RedbeamsDatabaseServerTestDto, Status> {", "originalCommit": "7a477a27dc7441d01edc5effc0a1b890f0b27b55", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzMzY4MzM3Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8033#discussion_r433683377", "bodyText": "I put this question here but relates to all Await implementations: if waiting for a given status is not implemented but a test developer wants to wait for it in his test, how will he be notified?\n@aszegedi, you suggested in personal communications, that switch-case could be converted to plain if-else, distinguishing between delete and non-delete operations, could make sense.", "author": "gergopapi2", "createdAt": "2020-06-02T07:46:43Z", "path": "integration-test/src/main/java/com/sequenceiq/it/cloudbreak/util/wait/service/database/DatabaseAwait.java", "diffHunk": "@@ -0,0 +1,67 @@\n+package com.sequenceiq.it.cloudbreak.util.wait.service.database;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.it.cloudbreak.RedbeamsClient;\n+import com.sequenceiq.it.cloudbreak.context.RunningParameter;\n+import com.sequenceiq.it.cloudbreak.context.TestContext;\n+import com.sequenceiq.it.cloudbreak.dto.database.RedbeamsDatabaseServerTestDto;\n+import com.sequenceiq.it.cloudbreak.log.Log;\n+import com.sequenceiq.it.cloudbreak.util.ResponseUtil;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.Await;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.ExceptionChecker;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.Result;\n+import com.sequenceiq.it.cloudbreak.util.wait.service.WaitResult;\n+import com.sequenceiq.redbeams.api.model.common.Status;\n+\n+@Component\n+public class DatabaseAwait extends Await<RedbeamsDatabaseServerTestDto, Status> {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(DatabaseAwait.class);\n+\n+    @Override\n+    public RedbeamsDatabaseServerTestDto await(RedbeamsDatabaseServerTestDto entity, Status desiredStatus, TestContext testContext,\n+            RunningParameter runningParameter, long pollingInterval, int maxRetry) {\n+        try {\n+            if (entity == null) {\n+                throw new RuntimeException(\"Database key has been provided but no result in resource map!\");\n+            }\n+            Log.await(LOGGER, String.format(\"%s for %s\", entity.getResponse().getName(), desiredStatus));\n+            RedbeamsClient client = testContext.getMicroserviceClient(RedbeamsClient.class, testContext.getWho(runningParameter)\n+                    .getAccessKey());\n+            String crn = entity.getResponse().getResourceCrn();\n+            switch (desiredStatus) {\n+                case AVAILABLE:\n+                case STOPPED:\n+                    waitForDatabaseStatus(new DatabaseOperationChecker<>(), client, crn, testContext, desiredStatus,\n+                            pollingInterval, maxRetry);\n+                    break;\n+                case DELETE_COMPLETED:\n+                    waitForDatabaseStatus(new DatabaseTerminationChecker<>(), client, crn, testContext, desiredStatus,\n+                            pollingInterval, maxRetry);\n+                    break;\n+                default:\n+                    LOGGER.warn(\"Wait checker is not implemented yet for the desired database state '{}' \", desiredStatus);", "originalCommit": "7a477a27dc7441d01edc5effc0a1b890f0b27b55", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "8a08f841353f365e7eabcafc74dddb89c966863b", "url": "https://github.com/hortonworks/cloudbreak/commit/8a08f841353f365e7eabcafc74dddb89c966863b", "message": "CB-6751 WaitUtil and WaitForMultipleStatuses overall refactor part 2 vv", "committedDate": "2020-06-02T20:26:06Z", "type": "forcePushed"}, {"oid": "9e8b0a2aa6e24479e8f92dc17dad0b314c88875e", "url": "https://github.com/hortonworks/cloudbreak/commit/9e8b0a2aa6e24479e8f92dc17dad0b314c88875e", "message": "CB-6751 WaitUtil and WaitForMultipleStatuses overall refactor part 2 vv", "committedDate": "2020-06-02T20:58:09Z", "type": "forcePushed"}, {"oid": "73522823558c65e5081f2fb6292e44c71041dad8", "url": "https://github.com/hortonworks/cloudbreak/commit/73522823558c65e5081f2fb6292e44c71041dad8", "message": "CB-6751 WaitUtil and WaitForMultipleStatuses overall refactor part 2 vv", "committedDate": "2020-06-03T09:44:53Z", "type": "forcePushed"}, {"oid": "e1b37ab086f6a19c531b032a2c9db79a1a851cd1", "url": "https://github.com/hortonworks/cloudbreak/commit/e1b37ab086f6a19c531b032a2c9db79a1a851cd1", "message": "CB-6751 WaitUtil and WaitForMultipleStatuses overall refactor part 2 vv", "committedDate": "2020-06-03T13:33:39Z", "type": "forcePushed"}, {"oid": "2729c4d246971a7ecccd587f0de1136ac5711edb", "url": "https://github.com/hortonworks/cloudbreak/commit/2729c4d246971a7ecccd587f0de1136ac5711edb", "message": "CB-6751 WaitUtil and WaitForMultipleStatuses overall refactor part 2", "committedDate": "2020-06-03T16:37:19Z", "type": "commit"}, {"oid": "2729c4d246971a7ecccd587f0de1136ac5711edb", "url": "https://github.com/hortonworks/cloudbreak/commit/2729c4d246971a7ecccd587f0de1136ac5711edb", "message": "CB-6751 WaitUtil and WaitForMultipleStatuses overall refactor part 2", "committedDate": "2020-06-03T16:37:19Z", "type": "forcePushed"}]}