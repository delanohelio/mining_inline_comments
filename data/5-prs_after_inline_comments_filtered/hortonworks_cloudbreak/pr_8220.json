{"pr_number": 8220, "pr_title": "CB-7336: Add upscaling FreeIPA for recovery of non-CRL master nodes", "pr_createdAt": "2020-06-05T10:51:08Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/8220", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI2Njc2Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r437266763", "bodyText": "it's a bit odd and confusing for me. So with repair endpoint/request will we be able to scale the size of the FreeIPA cluster? Is it really a repair functionality? also the naming, instanceCountByGroup a bit odd, as we don't really specify any group in the request", "author": "lacikaaa", "createdAt": "2020-06-09T09:22:35Z", "path": "freeipa-api/src/main/java/com/sequenceiq/freeipa/api/v1/freeipa/stack/model/repair/RepairInstancesRequest.java", "diffHunk": "@@ -25,6 +25,9 @@\n     @ApiModelProperty(ModelDescriptions.INSTANCE_ID)\n     private List<String> instanceIds;\n \n+    @ApiModelProperty(ModelDescriptions.FREEIPA_INSTANCE_COUNT_BY_GROUP)\n+    private Integer instanceCountByGroup;", "originalCommit": "693db1151dfb450ab9c365ba675720c20200a5d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQzOTE2NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r438439164", "bodyText": "I removed the instance count by group from the repair event but it is still in the downscale/upscale. Downscale/upscale adjust the instance count only when not doing a repair (which will be used in the future but its not used now).", "author": "jamisonbennett", "createdAt": "2020-06-10T22:19:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI2Njc2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3NzExNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r437277117", "bodyText": "so I see you reused this in AbstractUpscaleActions, but I think it's not best way to go. I would either duplicate this method, or introduce an AbstractScaleActions (or similar) class to have the common part instead of making these into public static", "author": "lacikaaa", "createdAt": "2020-06-09T09:36:50Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/downscale/action/AbstractDownscaleAction.java", "diffHunk": "@@ -107,10 +109,18 @@ protected void setHosts(Map<Object, Object> variables, List<String> hosts) {\n         variables.put(HOSTS, hosts);\n     }\n \n-    protected List<String> getHosts(Map<Object, Object> variables) {\n+    public static List<String> getHosts(Map<Object, Object> variables) {", "originalCommit": "693db1151dfb450ab9c365ba675720c20200a5d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQzOTM4Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r438439386", "bodyText": "I created the AbstractScaleActions.", "author": "jamisonbennett", "createdAt": "2020-06-10T22:20:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3NzExNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3OTIxOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r437279218", "bodyText": "so I don't understand this. Why do we set it to DOWNSCALE_IN_PROGRESS when it's finished?", "author": "lacikaaa", "createdAt": "2020-06-09T09:40:14Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/downscale/action/FreeIpaDownscaleActions.java", "diffHunk": "@@ -238,8 +239,12 @@ protected void doExecute(StackContext context, StackEvent payload, Map<Object, O\n                 Stack stack = context.getStack();\n                 SuccessDetails successDetails = new SuccessDetails(stack.getEnvironmentCrn());\n                 successDetails.getAdditionalDetails().put(\"Hosts\", getHosts(variables));\n-                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.DOWNSCALE_COMPLETED, \"Downscale complete\");\n-                operationService.completeOperation(stack.getAccountId(), getOperationId(variables), List.of(successDetails), Collections.emptyList());\n+                if (isRepair(variables)) {\n+                    stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.DOWNSCALE_IN_PROGRESS, \"Downscale complete\");", "originalCommit": "693db1151dfb450ab9c365ba675720c20200a5d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0MTM3MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r438441371", "bodyText": "A repair operation will consist of a downscale followed by an upscale. If I mark the status as DOWNSCALE_COMPLETE then the cluster will temporarily report a status of available instead of \"update in progress\". I think this will be a misleading race condition for external consumers of the FreeIPA APIs. When upscale is finished, then it will report a status of UPSCALE_COMPLETE which will map to available.", "author": "jamisonbennett", "createdAt": "2020-06-10T22:26:03Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3OTIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQyNDIzNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r439424237", "bodyText": "I think we should still replace this with something more appropriate. I'm open for ideas. My first thoughts are REPAIR_IN_PROGRESS or WAITING_FOR_UPSCALE", "author": "lacikaaa", "createdAt": "2020-06-12T13:40:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3OTIxOA=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTU5OTE5Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r439599197", "bodyText": "I updated downscale/upscale to set the status to REPAIR_IN_PROGRESS when its a repair operation. It will mark it as complete when upscale finishes.", "author": "jamisonbennett", "createdAt": "2020-06-12T19:13:47Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzI3OTIxOA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM0MTE2Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r437341163", "bodyText": "is it called DOWNSCALE_HOSTS on purpose?", "author": "lacikaaa", "createdAt": "2020-06-09T11:37:37Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/upscale/action/AbstractUpscaleAction.java", "diffHunk": "@@ -0,0 +1,129 @@\n+package com.sequenceiq.freeipa.flow.freeipa.upscale.action;\n+\n+import static com.sequenceiq.cloudbreak.cloud.model.Location.location;\n+import static com.sequenceiq.cloudbreak.cloud.model.Region.region;\n+\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Optional;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.statemachine.StateContext;\n+\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudCredential;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n+import com.sequenceiq.cloudbreak.cloud.model.Location;\n+import com.sequenceiq.cloudbreak.common.event.Payload;\n+import com.sequenceiq.cloudbreak.logger.MDCBuilder;\n+import com.sequenceiq.flow.core.FlowParameters;\n+import com.sequenceiq.freeipa.converter.cloud.CredentialToCloudCredentialConverter;\n+import com.sequenceiq.freeipa.converter.cloud.StackToCloudStackConverter;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleState;\n+import com.sequenceiq.freeipa.flow.stack.AbstractStackAction;\n+import com.sequenceiq.freeipa.flow.stack.StackContext;\n+import com.sequenceiq.freeipa.flow.stack.StackFailureEvent;\n+import com.sequenceiq.freeipa.service.CredentialService;\n+import com.sequenceiq.freeipa.service.stack.StackService;\n+\n+public abstract class AbstractUpscaleAction<P extends Payload> extends AbstractStackAction<UpscaleState, UpscaleFlowEvent, StackContext, P> {\n+\n+    protected static final String REPAIR = \"REPAIR\";\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(AbstractUpscaleAction.class);\n+\n+    private static final String INSTANCE_IDS = \"INSTANCE_IDS\";\n+\n+    private static final String OPERATION_ID = \"OPERATION_ID\";\n+\n+    private static final String INSTANCE_COUNT_BY_GROUP = \"INSTANCE_COUNT_BY_GROUP\";\n+\n+    private static final String HOSTS = \"DOWNSCALE_HOSTS\";", "originalCommit": "693db1151dfb450ab9c365ba675720c20200a5d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQzOTUwNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r438439506", "bodyText": "Thanks for catching this.", "author": "jamisonbennett", "createdAt": "2020-06-10T22:20:41Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM0MTE2Mw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM0NzEzNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r437347137", "bodyText": "it would be a bit more compact with streams:\nOptional<Long> max = instanceGroups.stream()\n                        .flatMap(ig -> ig.getAllInstanceMetaData().stream())\n                        .filter(im -> im.getPrivateId() != null)\n                        .max(Comparator.comparing(InstanceMetaData::getPrivateId))\n                        .map(InstanceMetaData::getPrivateId);", "author": "lacikaaa", "createdAt": "2020-06-09T11:49:18Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/upscale/action/FreeIpaUpscaleActions.java", "diffHunk": "@@ -0,0 +1,482 @@\n+package com.sequenceiq.freeipa.flow.freeipa.upscale.action;\n+\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.FAIL_HANDLED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_RECORD_HOSTNAMES_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_SAVE_METADATA_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_STARTING_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_VALIDATE_INSTANCES_FAILED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_VALIDATE_INSTANCES_FINISHED_EVENT;\n+import static java.lang.String.format;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.action.Action;\n+\n+import com.sequenceiq.cloudbreak.cloud.event.instance.CollectMetadataRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.instance.CollectMetadataResult;\n+import com.sequenceiq.cloudbreak.cloud.event.resource.UpscaleStackRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.resource.UpscaleStackResult;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudInstance;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudVmInstanceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudVmMetaDataStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.InstanceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.ResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.transform.ResourceLists;\n+import com.sequenceiq.cloudbreak.service.OperationException;\n+import com.sequenceiq.common.api.type.CommonResourceType;\n+import com.sequenceiq.flow.core.PayloadConverter;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.DetailedStackStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.FailureDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.SuccessDetails;\n+import com.sequenceiq.freeipa.converter.cloud.ResourceToCloudResourceConverter;\n+import com.sequenceiq.freeipa.converter.cloud.StackToCloudStackConverter;\n+import com.sequenceiq.freeipa.entity.InstanceGroup;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Resource;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.action.AbstractDownscaleAction;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.bootstrap.BootstrapMachinesRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.bootstrap.BootstrapMachinesSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.hostmetadatasetup.HostMetadataSetupRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.hostmetadatasetup.HostMetadataSetupSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.postinstall.PostInstallFreeIpaRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.postinstall.PostInstallFreeIpaSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.services.InstallFreeIpaServicesRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.services.InstallFreeIpaServicesSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.event.UpscaleEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.event.UpscaleFailureEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.BootstrapMachinesFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.ClusterProxyUpdateRegistrationFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.CollectMetadataResultToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.HostMetadataSetupFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.InstallFreeIpaServicesFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.PostInstallFreeIpaFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.UpscaleStackResultToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.stack.StackContext;\n+import com.sequenceiq.freeipa.flow.stack.StackEvent;\n+import com.sequenceiq.freeipa.service.TlsSetupService;\n+import com.sequenceiq.freeipa.service.operation.OperationService;\n+import com.sequenceiq.freeipa.service.resource.ResourceService;\n+import com.sequenceiq.freeipa.service.stack.StackUpdater;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+import com.sequenceiq.freeipa.service.stack.instance.MetadataSetupService;\n+\n+@Configuration\n+public class FreeIpaUpscaleActions {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FreeIpaUpscaleActions.class);\n+\n+    @Inject\n+    private ResourceService resourceService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    @Inject\n+    private StackToCloudStackConverter cloudStackConverter;\n+\n+    @Inject\n+    private ResourceToCloudResourceConverter resourceConverter;\n+\n+    @Inject\n+    private MetadataSetupService metadataSetupService;\n+\n+    @Inject\n+    private TlsSetupService tlsSetupService;\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    @Bean(name = \"UPSCALE_STARTING_STATE\")\n+    public Action<?, ?> startingAction() {\n+        return new AbstractUpscaleAction<>(UpscaleEvent.class) {\n+            @Override\n+            protected void doExecute(StackContext context, UpscaleEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                String operationId = payload.getOperationId();\n+                setOperationId(variables, operationId);\n+                setInstanceCountByGroup(variables, payload.getInstanceCountByGroup());\n+                setRepair(variables, payload.isRepair());\n+                LOGGER.info(\"Starting upscale of stack {}\", stack.getId());\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.UPSCALE_IN_PROGRESS, \"Starting upscale\");\n+                sendEvent(context, UPSCALE_STARTING_FINISHED_EVENT.selector(), new StackEvent(stack.getId()));\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"UPSCALE_ADD_INSTANCES_STATE\")\n+    public Action<?, ?> addInstancesAction() {\n+        return new AbstractUpscaleAction<>(StackEvent.class) {\n+            @Override\n+            protected void doExecute(StackContext context, StackEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.UPSCALE_IN_PROGRESS, \"Adding instances\");\n+\n+                List<CloudInstance> newInstances = buildNewInstances(context.getStack(), getInstanceCountByGroup(variables));\n+                if (newInstances.isEmpty()) {\n+                    List<CloudResourceStatus> list = resourceService.getAllAsCloudResourceStatus(payload.getResourceId());\n+                    UpscaleStackRequest<UpscaleStackResult> request = new UpscaleStackRequest<>(\n+                            context.getCloudContext(), context.getCloudCredential(), context.getCloudStack(), ResourceLists.transform(list));\n+                    UpscaleStackResult result = new UpscaleStackResult(request.getResourceId(), ResourceStatus.CREATED, list);\n+                    sendEvent(context, result.selector(), result);\n+                } else {\n+                    Stack updatedStack = instanceMetaDataService.saveInstanceAndGetUpdatedStack(context.getStack(), newInstances);\n+                    List<CloudResource> cloudResources = resourceService.findAllByStackId(stack.getId()).stream()\n+                            .map(resource -> resourceConverter.convert(resource))\n+                            .collect(Collectors.toList());\n+                    CloudStack updatedCloudStack = cloudStackConverter.convert(updatedStack);\n+                    UpscaleStackRequest request = new UpscaleStackRequest<UpscaleStackResult>(\n+                            context.getCloudContext(), context.getCloudCredential(), updatedCloudStack, cloudResources);\n+                    sendEvent(context, request.selector(), request);\n+                }\n+            }\n+\n+            private List<CloudInstance> buildNewInstances(Stack stack, int instanceCountByGroup) {\n+                long privateId = getFirstValidPrivateId(stack.getInstanceGroups());\n+                List<CloudInstance> newInstances = new ArrayList<>();\n+                for (InstanceGroup instanceGroup : stack.getInstanceGroups()) {\n+                    int remainingInstances = instanceCountByGroup - instanceGroup.getNotDeletedInstanceMetaDataSet().size();\n+                    for (long i = 0; i < remainingInstances; ++i) {\n+                        newInstances.add(cloudStackConverter.buildInstance(stack, null, instanceGroup,\n+                                stack.getStackAuthentication(), privateId++, InstanceStatus.CREATE_REQUESTED));\n+                    }\n+                }\n+                return newInstances;\n+            }\n+\n+            private Long getFirstValidPrivateId(Set<InstanceGroup> instanceGroups) {\n+                LOGGER.debug(\"Get first valid PrivateId of instanceGroups\");\n+                long highest = 0;\n+                for (InstanceGroup instanceGroup : instanceGroups) {\n+                    LOGGER.debug(\"Checking of instanceGroup: {}\", instanceGroup.getGroupName());\n+                    for (InstanceMetaData metaData : instanceGroup.getAllInstanceMetaData()) {\n+                        Long privateId = metaData.getPrivateId();\n+                        LOGGER.debug(\"InstanceMetaData metaData: privateId: {}, instanceId: {}, status: {}\",\n+                                privateId, metaData.getInstanceId(), metaData.getInstanceStatus());\n+                        if (privateId == null) {\n+                            continue;\n+                        }\n+                        if (privateId > highest) {\n+                            highest = privateId;\n+                        }\n+                    }\n+                }\n+                LOGGER.debug(\"Highest privateId: {}\", highest);", "originalCommit": "693db1151dfb450ab9c365ba675720c20200a5d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM1OTA5NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r437359094", "bodyText": "should be: UpscaleStackRequest<UpscaleStackResult> request = new UpscaleStackRequest<>(", "author": "lacikaaa", "createdAt": "2020-06-09T12:11:42Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/upscale/action/FreeIpaUpscaleActions.java", "diffHunk": "@@ -0,0 +1,482 @@\n+package com.sequenceiq.freeipa.flow.freeipa.upscale.action;\n+\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.FAIL_HANDLED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_RECORD_HOSTNAMES_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_SAVE_METADATA_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_STARTING_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_VALIDATE_INSTANCES_FAILED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_VALIDATE_INSTANCES_FINISHED_EVENT;\n+import static java.lang.String.format;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.action.Action;\n+\n+import com.sequenceiq.cloudbreak.cloud.event.instance.CollectMetadataRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.instance.CollectMetadataResult;\n+import com.sequenceiq.cloudbreak.cloud.event.resource.UpscaleStackRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.resource.UpscaleStackResult;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudInstance;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudVmInstanceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudVmMetaDataStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.InstanceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.ResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.transform.ResourceLists;\n+import com.sequenceiq.cloudbreak.service.OperationException;\n+import com.sequenceiq.common.api.type.CommonResourceType;\n+import com.sequenceiq.flow.core.PayloadConverter;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.DetailedStackStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.FailureDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.SuccessDetails;\n+import com.sequenceiq.freeipa.converter.cloud.ResourceToCloudResourceConverter;\n+import com.sequenceiq.freeipa.converter.cloud.StackToCloudStackConverter;\n+import com.sequenceiq.freeipa.entity.InstanceGroup;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Resource;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.action.AbstractDownscaleAction;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.bootstrap.BootstrapMachinesRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.bootstrap.BootstrapMachinesSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.hostmetadatasetup.HostMetadataSetupRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.hostmetadatasetup.HostMetadataSetupSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.postinstall.PostInstallFreeIpaRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.postinstall.PostInstallFreeIpaSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.services.InstallFreeIpaServicesRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.services.InstallFreeIpaServicesSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.event.UpscaleEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.event.UpscaleFailureEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.BootstrapMachinesFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.ClusterProxyUpdateRegistrationFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.CollectMetadataResultToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.HostMetadataSetupFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.InstallFreeIpaServicesFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.PostInstallFreeIpaFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.UpscaleStackResultToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.stack.StackContext;\n+import com.sequenceiq.freeipa.flow.stack.StackEvent;\n+import com.sequenceiq.freeipa.service.TlsSetupService;\n+import com.sequenceiq.freeipa.service.operation.OperationService;\n+import com.sequenceiq.freeipa.service.resource.ResourceService;\n+import com.sequenceiq.freeipa.service.stack.StackUpdater;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+import com.sequenceiq.freeipa.service.stack.instance.MetadataSetupService;\n+\n+@Configuration\n+public class FreeIpaUpscaleActions {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FreeIpaUpscaleActions.class);\n+\n+    @Inject\n+    private ResourceService resourceService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    @Inject\n+    private StackToCloudStackConverter cloudStackConverter;\n+\n+    @Inject\n+    private ResourceToCloudResourceConverter resourceConverter;\n+\n+    @Inject\n+    private MetadataSetupService metadataSetupService;\n+\n+    @Inject\n+    private TlsSetupService tlsSetupService;\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    @Bean(name = \"UPSCALE_STARTING_STATE\")\n+    public Action<?, ?> startingAction() {\n+        return new AbstractUpscaleAction<>(UpscaleEvent.class) {\n+            @Override\n+            protected void doExecute(StackContext context, UpscaleEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                String operationId = payload.getOperationId();\n+                setOperationId(variables, operationId);\n+                setInstanceCountByGroup(variables, payload.getInstanceCountByGroup());\n+                setRepair(variables, payload.isRepair());\n+                LOGGER.info(\"Starting upscale of stack {}\", stack.getId());\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.UPSCALE_IN_PROGRESS, \"Starting upscale\");\n+                sendEvent(context, UPSCALE_STARTING_FINISHED_EVENT.selector(), new StackEvent(stack.getId()));\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"UPSCALE_ADD_INSTANCES_STATE\")\n+    public Action<?, ?> addInstancesAction() {\n+        return new AbstractUpscaleAction<>(StackEvent.class) {\n+            @Override\n+            protected void doExecute(StackContext context, StackEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.UPSCALE_IN_PROGRESS, \"Adding instances\");\n+\n+                List<CloudInstance> newInstances = buildNewInstances(context.getStack(), getInstanceCountByGroup(variables));\n+                if (newInstances.isEmpty()) {\n+                    List<CloudResourceStatus> list = resourceService.getAllAsCloudResourceStatus(payload.getResourceId());\n+                    UpscaleStackRequest<UpscaleStackResult> request = new UpscaleStackRequest<>(\n+                            context.getCloudContext(), context.getCloudCredential(), context.getCloudStack(), ResourceLists.transform(list));\n+                    UpscaleStackResult result = new UpscaleStackResult(request.getResourceId(), ResourceStatus.CREATED, list);\n+                    sendEvent(context, result.selector(), result);\n+                } else {\n+                    Stack updatedStack = instanceMetaDataService.saveInstanceAndGetUpdatedStack(context.getStack(), newInstances);\n+                    List<CloudResource> cloudResources = resourceService.findAllByStackId(stack.getId()).stream()\n+                            .map(resource -> resourceConverter.convert(resource))\n+                            .collect(Collectors.toList());\n+                    CloudStack updatedCloudStack = cloudStackConverter.convert(updatedStack);\n+                    UpscaleStackRequest request = new UpscaleStackRequest<UpscaleStackResult>(", "originalCommit": "693db1151dfb450ab9c365ba675720c20200a5d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2MTE4OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r437361189", "bodyText": "could you refactor the if-else branches to methods?", "author": "lacikaaa", "createdAt": "2020-06-09T12:15:24Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/upscale/action/FreeIpaUpscaleActions.java", "diffHunk": "@@ -0,0 +1,482 @@\n+package com.sequenceiq.freeipa.flow.freeipa.upscale.action;\n+\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.FAIL_HANDLED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_RECORD_HOSTNAMES_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_SAVE_METADATA_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_STARTING_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_VALIDATE_INSTANCES_FAILED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_VALIDATE_INSTANCES_FINISHED_EVENT;\n+import static java.lang.String.format;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.action.Action;\n+\n+import com.sequenceiq.cloudbreak.cloud.event.instance.CollectMetadataRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.instance.CollectMetadataResult;\n+import com.sequenceiq.cloudbreak.cloud.event.resource.UpscaleStackRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.resource.UpscaleStackResult;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudInstance;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudVmInstanceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudVmMetaDataStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.InstanceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.ResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.transform.ResourceLists;\n+import com.sequenceiq.cloudbreak.service.OperationException;\n+import com.sequenceiq.common.api.type.CommonResourceType;\n+import com.sequenceiq.flow.core.PayloadConverter;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.DetailedStackStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.FailureDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.SuccessDetails;\n+import com.sequenceiq.freeipa.converter.cloud.ResourceToCloudResourceConverter;\n+import com.sequenceiq.freeipa.converter.cloud.StackToCloudStackConverter;\n+import com.sequenceiq.freeipa.entity.InstanceGroup;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Resource;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.action.AbstractDownscaleAction;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.bootstrap.BootstrapMachinesRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.bootstrap.BootstrapMachinesSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.hostmetadatasetup.HostMetadataSetupRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.hostmetadatasetup.HostMetadataSetupSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.postinstall.PostInstallFreeIpaRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.postinstall.PostInstallFreeIpaSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.services.InstallFreeIpaServicesRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.services.InstallFreeIpaServicesSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.event.UpscaleEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.event.UpscaleFailureEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.BootstrapMachinesFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.ClusterProxyUpdateRegistrationFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.CollectMetadataResultToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.HostMetadataSetupFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.InstallFreeIpaServicesFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.PostInstallFreeIpaFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.UpscaleStackResultToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.stack.StackContext;\n+import com.sequenceiq.freeipa.flow.stack.StackEvent;\n+import com.sequenceiq.freeipa.service.TlsSetupService;\n+import com.sequenceiq.freeipa.service.operation.OperationService;\n+import com.sequenceiq.freeipa.service.resource.ResourceService;\n+import com.sequenceiq.freeipa.service.stack.StackUpdater;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+import com.sequenceiq.freeipa.service.stack.instance.MetadataSetupService;\n+\n+@Configuration\n+public class FreeIpaUpscaleActions {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FreeIpaUpscaleActions.class);\n+\n+    @Inject\n+    private ResourceService resourceService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    @Inject\n+    private StackToCloudStackConverter cloudStackConverter;\n+\n+    @Inject\n+    private ResourceToCloudResourceConverter resourceConverter;\n+\n+    @Inject\n+    private MetadataSetupService metadataSetupService;\n+\n+    @Inject\n+    private TlsSetupService tlsSetupService;\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    @Bean(name = \"UPSCALE_STARTING_STATE\")\n+    public Action<?, ?> startingAction() {\n+        return new AbstractUpscaleAction<>(UpscaleEvent.class) {\n+            @Override\n+            protected void doExecute(StackContext context, UpscaleEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                String operationId = payload.getOperationId();\n+                setOperationId(variables, operationId);\n+                setInstanceCountByGroup(variables, payload.getInstanceCountByGroup());\n+                setRepair(variables, payload.isRepair());\n+                LOGGER.info(\"Starting upscale of stack {}\", stack.getId());\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.UPSCALE_IN_PROGRESS, \"Starting upscale\");\n+                sendEvent(context, UPSCALE_STARTING_FINISHED_EVENT.selector(), new StackEvent(stack.getId()));\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"UPSCALE_ADD_INSTANCES_STATE\")\n+    public Action<?, ?> addInstancesAction() {\n+        return new AbstractUpscaleAction<>(StackEvent.class) {\n+            @Override\n+            protected void doExecute(StackContext context, StackEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.UPSCALE_IN_PROGRESS, \"Adding instances\");\n+\n+                List<CloudInstance> newInstances = buildNewInstances(context.getStack(), getInstanceCountByGroup(variables));\n+                if (newInstances.isEmpty()) {", "originalCommit": "693db1151dfb450ab9c365ba675720c20200a5d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM2NDg2NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r437364864", "bodyText": "nit: you could use stack instead of context.getStack()", "author": "lacikaaa", "createdAt": "2020-06-09T12:20:56Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/upscale/action/FreeIpaUpscaleActions.java", "diffHunk": "@@ -0,0 +1,482 @@\n+package com.sequenceiq.freeipa.flow.freeipa.upscale.action;\n+\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.FAIL_HANDLED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_RECORD_HOSTNAMES_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_SAVE_METADATA_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_STARTING_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_VALIDATE_INSTANCES_FAILED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_VALIDATE_INSTANCES_FINISHED_EVENT;\n+import static java.lang.String.format;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.action.Action;\n+\n+import com.sequenceiq.cloudbreak.cloud.event.instance.CollectMetadataRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.instance.CollectMetadataResult;\n+import com.sequenceiq.cloudbreak.cloud.event.resource.UpscaleStackRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.resource.UpscaleStackResult;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudInstance;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudVmInstanceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudVmMetaDataStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.InstanceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.ResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.transform.ResourceLists;\n+import com.sequenceiq.cloudbreak.service.OperationException;\n+import com.sequenceiq.common.api.type.CommonResourceType;\n+import com.sequenceiq.flow.core.PayloadConverter;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.DetailedStackStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.FailureDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.SuccessDetails;\n+import com.sequenceiq.freeipa.converter.cloud.ResourceToCloudResourceConverter;\n+import com.sequenceiq.freeipa.converter.cloud.StackToCloudStackConverter;\n+import com.sequenceiq.freeipa.entity.InstanceGroup;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Resource;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.freeipa.downscale.action.AbstractDownscaleAction;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.bootstrap.BootstrapMachinesRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.bootstrap.BootstrapMachinesSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.hostmetadatasetup.HostMetadataSetupRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.hostmetadatasetup.HostMetadataSetupSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.postinstall.PostInstallFreeIpaRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.postinstall.PostInstallFreeIpaSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.services.InstallFreeIpaServicesRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.services.InstallFreeIpaServicesSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.event.UpscaleEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.event.UpscaleFailureEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.BootstrapMachinesFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.ClusterProxyUpdateRegistrationFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.CollectMetadataResultToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.HostMetadataSetupFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.InstallFreeIpaServicesFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.PostInstallFreeIpaFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.UpscaleStackResultToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.stack.StackContext;\n+import com.sequenceiq.freeipa.flow.stack.StackEvent;\n+import com.sequenceiq.freeipa.service.TlsSetupService;\n+import com.sequenceiq.freeipa.service.operation.OperationService;\n+import com.sequenceiq.freeipa.service.resource.ResourceService;\n+import com.sequenceiq.freeipa.service.stack.StackUpdater;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+import com.sequenceiq.freeipa.service.stack.instance.MetadataSetupService;\n+\n+@Configuration\n+public class FreeIpaUpscaleActions {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FreeIpaUpscaleActions.class);\n+\n+    @Inject\n+    private ResourceService resourceService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    @Inject\n+    private StackToCloudStackConverter cloudStackConverter;\n+\n+    @Inject\n+    private ResourceToCloudResourceConverter resourceConverter;\n+\n+    @Inject\n+    private MetadataSetupService metadataSetupService;\n+\n+    @Inject\n+    private TlsSetupService tlsSetupService;\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    @Bean(name = \"UPSCALE_STARTING_STATE\")\n+    public Action<?, ?> startingAction() {\n+        return new AbstractUpscaleAction<>(UpscaleEvent.class) {\n+            @Override\n+            protected void doExecute(StackContext context, UpscaleEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                String operationId = payload.getOperationId();\n+                setOperationId(variables, operationId);\n+                setInstanceCountByGroup(variables, payload.getInstanceCountByGroup());\n+                setRepair(variables, payload.isRepair());\n+                LOGGER.info(\"Starting upscale of stack {}\", stack.getId());\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.UPSCALE_IN_PROGRESS, \"Starting upscale\");\n+                sendEvent(context, UPSCALE_STARTING_FINISHED_EVENT.selector(), new StackEvent(stack.getId()));\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"UPSCALE_ADD_INSTANCES_STATE\")\n+    public Action<?, ?> addInstancesAction() {\n+        return new AbstractUpscaleAction<>(StackEvent.class) {\n+            @Override\n+            protected void doExecute(StackContext context, StackEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.UPSCALE_IN_PROGRESS, \"Adding instances\");\n+\n+                List<CloudInstance> newInstances = buildNewInstances(context.getStack(), getInstanceCountByGroup(variables));\n+                if (newInstances.isEmpty()) {\n+                    List<CloudResourceStatus> list = resourceService.getAllAsCloudResourceStatus(payload.getResourceId());\n+                    UpscaleStackRequest<UpscaleStackResult> request = new UpscaleStackRequest<>(\n+                            context.getCloudContext(), context.getCloudCredential(), context.getCloudStack(), ResourceLists.transform(list));\n+                    UpscaleStackResult result = new UpscaleStackResult(request.getResourceId(), ResourceStatus.CREATED, list);\n+                    sendEvent(context, result.selector(), result);\n+                } else {\n+                    Stack updatedStack = instanceMetaDataService.saveInstanceAndGetUpdatedStack(context.getStack(), newInstances);\n+                    List<CloudResource> cloudResources = resourceService.findAllByStackId(stack.getId()).stream()\n+                            .map(resource -> resourceConverter.convert(resource))\n+                            .collect(Collectors.toList());\n+                    CloudStack updatedCloudStack = cloudStackConverter.convert(updatedStack);\n+                    UpscaleStackRequest request = new UpscaleStackRequest<UpscaleStackResult>(\n+                            context.getCloudContext(), context.getCloudCredential(), updatedCloudStack, cloudResources);\n+                    sendEvent(context, request.selector(), request);\n+                }\n+            }\n+\n+            private List<CloudInstance> buildNewInstances(Stack stack, int instanceCountByGroup) {\n+                long privateId = getFirstValidPrivateId(stack.getInstanceGroups());\n+                List<CloudInstance> newInstances = new ArrayList<>();\n+                for (InstanceGroup instanceGroup : stack.getInstanceGroups()) {\n+                    int remainingInstances = instanceCountByGroup - instanceGroup.getNotDeletedInstanceMetaDataSet().size();\n+                    for (long i = 0; i < remainingInstances; ++i) {\n+                        newInstances.add(cloudStackConverter.buildInstance(stack, null, instanceGroup,\n+                                stack.getStackAuthentication(), privateId++, InstanceStatus.CREATE_REQUESTED));\n+                    }\n+                }\n+                return newInstances;\n+            }\n+\n+            private Long getFirstValidPrivateId(Set<InstanceGroup> instanceGroups) {\n+                LOGGER.debug(\"Get first valid PrivateId of instanceGroups\");\n+                long highest = 0;\n+                for (InstanceGroup instanceGroup : instanceGroups) {\n+                    LOGGER.debug(\"Checking of instanceGroup: {}\", instanceGroup.getGroupName());\n+                    for (InstanceMetaData metaData : instanceGroup.getAllInstanceMetaData()) {\n+                        Long privateId = metaData.getPrivateId();\n+                        LOGGER.debug(\"InstanceMetaData metaData: privateId: {}, instanceId: {}, status: {}\",\n+                                privateId, metaData.getInstanceId(), metaData.getInstanceStatus());\n+                        if (privateId == null) {\n+                            continue;\n+                        }\n+                        if (privateId > highest) {\n+                            highest = privateId;\n+                        }\n+                    }\n+                }\n+                LOGGER.debug(\"Highest privateId: {}\", highest);\n+                return highest == 0 ? 0 : highest + 1;\n+            }\n+\n+        };\n+    }\n+\n+    @Bean(name = \"UPSCALE_VALIDATE_INSTANCES_STATE\")\n+    public Action<?, ?> validateInstancesAction() {\n+        return new AbstractUpscaleAction<>(UpscaleStackResult.class) {\n+            @Override\n+            protected void doExecute(StackContext context, UpscaleStackResult payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.UPSCALE_IN_PROGRESS, \"Validating new instances\");\n+                try {\n+                    finishAddInstances(context, payload);\n+                    sendEvent(context, UPSCALE_VALIDATE_INSTANCES_FINISHED_EVENT.selector(), new StackEvent(stack.getId()));\n+                } catch (Exception e) {\n+                    sendEvent(context, UPSCALE_VALIDATE_INSTANCES_FAILED_EVENT.selector(),\n+                            new UpscaleFailureEvent(stack.getId(), \"Validating new instances\", Set.of(), Map.of(), e));\n+                }\n+            }\n+\n+            private void finishAddInstances(StackContext context, UpscaleStackResult payload) {\n+                LOGGER.debug(\"Upscale stack result: {}\", payload);\n+                List<CloudResourceStatus> results = payload.getResults();\n+                validateResourceResults(context, payload.getErrorDetails(), results);\n+                Set<Resource> resourceSet = transformResults(results, context.getStack());\n+                if (resourceSet.isEmpty()) {\n+                    metadataSetupService.cleanupRequestedInstances(context.getStack());\n+                    throw new OperationException(\"Failed to upscale the cluster since all create request failed. Resource set is empty\");\n+                }\n+                LOGGER.debug(\"Adding new instances to the stack is DONE\");\n+            }\n+\n+            private void validateResourceResults(StackContext context, Exception exception, List<CloudResourceStatus> results) {\n+                if (exception != null) {\n+                    LOGGER.info(format(\"Failed to upscale stack: %s\", context.getCloudContext()), exception);\n+                    throw new OperationException(exception);\n+                }\n+                List<CloudResourceStatus> templates = results.stream().filter(result -> CommonResourceType.TEMPLATE == result.getCloudResource().getType()\n+                        .getCommonResourceType()).collect(Collectors.toList());\n+                if (!templates.isEmpty() && (templates.get(0).isFailed() || templates.get(0).isDeleted())) {\n+                    throw new OperationException(format(\"Failed to upscale the stack for %s due to: %s\",\n+                            context.getCloudContext(), templates.get(0).getStatusReason()));\n+                }\n+            }\n+\n+            private Set<Resource> transformResults(Iterable<CloudResourceStatus> cloudResourceStatuses, Stack stack) {\n+                Set<Resource> retSet = new HashSet<>();\n+                for (CloudResourceStatus cloudResourceStatus : cloudResourceStatuses) {\n+                    if (!cloudResourceStatus.isFailed()) {\n+                        CloudResource cloudResource = cloudResourceStatus.getCloudResource();\n+                        Resource resource = new Resource(\n+                                cloudResource.getType(), cloudResource.getName(), cloudResource.getReference(), cloudResource.getStatus(), stack, null);\n+                        retSet.add(resource);\n+                    }\n+                }\n+                return retSet;\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"UPSCALE_EXTEND_METADATA_STATE\")\n+    public Action<?, ?> extendMetadataAction() {\n+        return new AbstractUpscaleAction<>(StackEvent.class) {\n+\n+            private final Set<InstanceStatus> unusedInstanceStatuses = Set.of(InstanceStatus.CREATE_REQUESTED, InstanceStatus.CREATED);\n+\n+            @Override\n+            protected void doExecute(StackContext context, StackEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.UPSCALE_IN_PROGRESS, \"Extending metadata\");\n+\n+                List<CloudInstance> allKnownInstances = cloudStackConverter.buildInstances(context.getStack());\n+                List<Resource> resources = resourceService.findAllByStackId(context.getStack().getId());", "originalCommit": "693db1151dfb450ab9c365ba675720c20200a5d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3NDc3Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r437374777", "bodyText": "could you refactor this? like move the rest of the method to a separate one, and put that call in the if.", "author": "lacikaaa", "createdAt": "2020-06-09T12:31:56Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/freeipa/flow/FreeIpaPostInstallService.java", "diffHunk": "@@ -65,11 +65,14 @@\n     @Inject\n     private FreeIpaService freeIpaService;\n \n-    public void postInstallFreeIpa(Long stackId) throws Exception {\n-        LOGGER.debug(\"Performing post-install configuration for stack {}\", stackId);\n+    public void postInstallFreeIpa(Long stackId, boolean fullPostInstall) throws Exception {\n+        LOGGER.debug(\"Performing post-install configuration for stack {}. {}.\", stackId, fullPostInstall ? \"Full post install\" : \"Partial post install\");\n         Stack stack = stackService.getStackById(stackId);\n         FreeIpaClient freeIpaClient = freeIpaClientFactory.getFreeIpaClientForStack(stack);\n         freeIpaTopologyService.updateReplicationTopology(stackId, freeIpaClient);\n+        if (!fullPostInstall) {\n+            return;\n+        }", "originalCommit": "693db1151dfb450ab9c365ba675720c20200a5d9", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3NzUwNg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r437377506", "bodyText": "this might worth to be refactored into it's own method", "author": "lacikaaa", "createdAt": "2020-06-09T12:35:28Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/RepairInstancesService.java", "diffHunk": "@@ -65,6 +70,49 @@\n     @Inject\n     private OperationToOperationStatusConverter operationToOperationStatusConverter;\n \n+    @Inject\n+    private EntitlementService entitlementService;\n+\n+    @Value(\"${freeipa.max.instances}\")\n+    private int maxInstances;\n+\n+    private void validate(String accountId, Stack stack, Set<InstanceMetaData> remainingInstances, Collection<InstanceMetaData> instancesToRepair,\n+            Integer instanceCountByGroup) {\n+        if (!entitlementService.freeIpaHaEnabled(INTERNAL_ACTOR_CRN, accountId)) {\n+            throw new BadRequestException(\"The FreeIPA HA capability is disabled.\");\n+        }\n+        if (null == instanceCountByGroup) {\n+            throw new BadRequestException(\"Instance count by group is required.\");\n+        }\n+        int requestedNumberOfNodes = instanceCountByGroup * stack.getInstanceGroups().size();\n+        if (instancesToRepair.isEmpty()) {\n+            throw new NotFoundException(\"No unhealthy instances to repair.  Maybe use the force option.\");\n+        }\n+        if (remainingInstances.isEmpty()) {\n+            throw new BadRequestException(\"At least one instance must remain running during a repair.\");\n+        }\n+        if (requestedNumberOfNodes <= 1) {\n+            throw new BadRequestException(\"After repairing FreeIPA there must be at least 2 instances of FreeIPA\");\n+        }\n+        if (requestedNumberOfNodes > maxInstances) {\n+            throw new BadRequestException(String.format(\"After repairing FreeIPA there must be at most %d instances.\", maxInstances));\n+        }\n+        Set<String> remainingInstanceIds = remainingInstances.stream()\n+                .map(InstanceMetaData::getInstanceId)\n+                .collect(Collectors.toSet());\n+        long numInstanceGroupsWithTooMandNodes = stack.getInstanceGroups().stream()\n+                .map(instanceGroup ->\n+                    instanceGroup.getInstanceMetaData().stream()\n+                            .map(InstanceMetaData::getInstanceId)\n+                            .filter(instanceId -> remainingInstanceIds.contains(instanceId))\n+                            .count())\n+                .filter(count -> count > instanceCountByGroup)\n+                .count();\n+        if (numInstanceGroupsWithTooMandNodes > 0) {\n+            throw new BadRequestException(\"The instance count by group cannot be reduced during a repair.\");\n+        }", "originalCommit": "693db1151dfb450ab9c365ba675720c20200a5d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0MDM2MQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r438440361", "bodyText": "This is not longer applicable since repair cannot change the total number of instances per instance group.", "author": "jamisonbennett", "createdAt": "2020-06-10T22:23:11Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3NzUwNg=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3NzY5Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r437377692", "bodyText": "typo: Mand -> Many", "author": "lacikaaa", "createdAt": "2020-06-09T12:35:48Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/service/stack/RepairInstancesService.java", "diffHunk": "@@ -65,6 +70,49 @@\n     @Inject\n     private OperationToOperationStatusConverter operationToOperationStatusConverter;\n \n+    @Inject\n+    private EntitlementService entitlementService;\n+\n+    @Value(\"${freeipa.max.instances}\")\n+    private int maxInstances;\n+\n+    private void validate(String accountId, Stack stack, Set<InstanceMetaData> remainingInstances, Collection<InstanceMetaData> instancesToRepair,\n+            Integer instanceCountByGroup) {\n+        if (!entitlementService.freeIpaHaEnabled(INTERNAL_ACTOR_CRN, accountId)) {\n+            throw new BadRequestException(\"The FreeIPA HA capability is disabled.\");\n+        }\n+        if (null == instanceCountByGroup) {\n+            throw new BadRequestException(\"Instance count by group is required.\");\n+        }\n+        int requestedNumberOfNodes = instanceCountByGroup * stack.getInstanceGroups().size();\n+        if (instancesToRepair.isEmpty()) {\n+            throw new NotFoundException(\"No unhealthy instances to repair.  Maybe use the force option.\");\n+        }\n+        if (remainingInstances.isEmpty()) {\n+            throw new BadRequestException(\"At least one instance must remain running during a repair.\");\n+        }\n+        if (requestedNumberOfNodes <= 1) {\n+            throw new BadRequestException(\"After repairing FreeIPA there must be at least 2 instances of FreeIPA\");\n+        }\n+        if (requestedNumberOfNodes > maxInstances) {\n+            throw new BadRequestException(String.format(\"After repairing FreeIPA there must be at most %d instances.\", maxInstances));\n+        }\n+        Set<String> remainingInstanceIds = remainingInstances.stream()\n+                .map(InstanceMetaData::getInstanceId)\n+                .collect(Collectors.toSet());\n+        long numInstanceGroupsWithTooMandNodes = stack.getInstanceGroups().stream()\n+                .map(instanceGroup ->\n+                    instanceGroup.getInstanceMetaData().stream()\n+                            .map(InstanceMetaData::getInstanceId)\n+                            .filter(instanceId -> remainingInstanceIds.contains(instanceId))\n+                            .count())\n+                .filter(count -> count > instanceCountByGroup)\n+                .count();\n+        if (numInstanceGroupsWithTooMandNodes > 0) {", "originalCommit": "693db1151dfb450ab9c365ba675720c20200a5d9", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzODQ0MDQxMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r438440410", "bodyText": "This is not longer applicable since repair cannot change the total number of instances per instance group.", "author": "jamisonbennett", "createdAt": "2020-06-10T22:23:21Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzNzM3NzY5Mg=="}], "type": "inlineReview"}, {"oid": "5ad1816a0508b559927e3c1178960fa4ed1cf513", "url": "https://github.com/hortonworks/cloudbreak/commit/5ad1816a0508b559927e3c1178960fa4ed1cf513", "message": "CB-7336: Add upscaling FreeIPA for recovery of non-CRL master nodes\n\nWhen a non-CRL master fails, the recovery should perform a downscale\nfollowed by an upscale.\nThe upscale process includes:\n  * Adding the new cloud instances\n  * Validating the cloud instances\n  * Retrieving the metadata for the new instances\n  * Saving the metadata for the new instances\n  * Setting up TLS\n  * Bootstrapping salt on the new instances\n  * Collecting the new hostnames using salt\n  * Saving the new hostnames in the database\n  * Installing FreeIPA and replicating from an existing node\n  * Updating cluster proxy registration\n  * Post installation steps for FreeIPA to update the replication\n    topology\n\nRepair was tested with the added tests and it was also tested manually\nby repairing a 2 node FreeIPA cluster. The primary gateway was the CA\nmaster & CRL master and that node was kept.", "committedDate": "2020-06-10T22:16:43Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQyNjA0NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r439426044", "bodyText": "so this will produce invalid output. if we have highest ID 0 then we will return 0 as first valid id. this should be an Optional<Long> and the return look like:\nreturn highest.isPresent() ? highest.get() + 1 : 0;\n\nalso we might have a test for this method to be sure we don't break it in the future", "author": "lacikaaa", "createdAt": "2020-06-12T13:43:21Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/core/flow2/stack/upscale/StackUpscaleService.java", "diffHunk": "@@ -206,21 +206,12 @@ private void validateResourceResults(StackScalingFlowContext context, Exception\n \n     private Long getFirstValidPrivateId(List<InstanceGroup> instanceGroups) {\n         LOGGER.debug(\"Get first valid PrivateId of instanceGroups\");\n-        long highest = 0;\n-        for (InstanceGroup instanceGroup : instanceGroups) {\n-            LOGGER.debug(\"Checking of instanceGroup: {}\", instanceGroup.getGroupName());\n-            for (InstanceMetaData metaData : instanceGroup.getAllInstanceMetaData()) {\n-                Long privateId = metaData.getPrivateId();\n-                LOGGER.debug(\"InstanceMetaData metaData: privateId: {}, instanceGroupName: {}, instanceId: {}, status: {}\",\n-                        privateId, metaData.getInstanceGroupName(), metaData.getInstanceId(), metaData.getInstanceStatus());\n-                if (privateId == null) {\n-                    continue;\n-                }\n-                if (privateId > highest) {\n-                    highest = privateId;\n-                }\n-            }\n-        }\n+        long highest = instanceGroups.stream()", "originalCommit": "5ad1816a0508b559927e3c1178960fa4ed1cf513", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQyOTAyOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r439429028", "bodyText": "this seems to me to be a duplicate. we might move this method to a separate class. it would make testing easier", "author": "lacikaaa", "createdAt": "2020-06-12T13:48:23Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/flow/freeipa/upscale/action/FreeIpaUpscaleActions.java", "diffHunk": "@@ -0,0 +1,507 @@\n+package com.sequenceiq.freeipa.flow.freeipa.upscale.action;\n+\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.FAIL_HANDLED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_RECORD_HOSTNAMES_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_SAVE_METADATA_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_STARTING_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_UPDATE_METADATA_FINISHED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_VALIDATE_INSTANCES_FAILED_EVENT;\n+import static com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent.UPSCALE_VALIDATE_INSTANCES_FINISHED_EVENT;\n+import static java.lang.String.format;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Optional;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.context.annotation.Bean;\n+import org.springframework.context.annotation.Configuration;\n+import org.springframework.statemachine.action.Action;\n+\n+import com.sequenceiq.cloudbreak.cloud.event.instance.CollectMetadataRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.instance.CollectMetadataResult;\n+import com.sequenceiq.cloudbreak.cloud.event.resource.UpscaleStackRequest;\n+import com.sequenceiq.cloudbreak.cloud.event.resource.UpscaleStackResult;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudInstance;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudStack;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudVmInstanceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudVmMetaDataStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.InstanceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.ResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.transform.ResourceLists;\n+import com.sequenceiq.cloudbreak.service.OperationException;\n+import com.sequenceiq.common.api.type.CommonResourceType;\n+import com.sequenceiq.flow.core.PayloadConverter;\n+import com.sequenceiq.freeipa.api.v1.freeipa.stack.model.common.DetailedStackStatus;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.FailureDetails;\n+import com.sequenceiq.freeipa.api.v1.freeipa.user.model.SuccessDetails;\n+import com.sequenceiq.freeipa.converter.cloud.ResourceToCloudResourceConverter;\n+import com.sequenceiq.freeipa.converter.cloud.StackToCloudStackConverter;\n+import com.sequenceiq.freeipa.entity.InstanceGroup;\n+import com.sequenceiq.freeipa.entity.InstanceMetaData;\n+import com.sequenceiq.freeipa.entity.Resource;\n+import com.sequenceiq.freeipa.entity.Stack;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.bootstrap.BootstrapMachinesRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.bootstrap.BootstrapMachinesSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.clusterproxy.ClusterProxyUpdateRegistrationSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.hostmetadatasetup.HostMetadataSetupRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.hostmetadatasetup.HostMetadataSetupSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.postinstall.PostInstallFreeIpaRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.postinstall.PostInstallFreeIpaSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.services.InstallFreeIpaServicesRequest;\n+import com.sequenceiq.freeipa.flow.freeipa.provision.event.services.InstallFreeIpaServicesSuccess;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.UpscaleFlowEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.event.UpscaleEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.event.UpscaleFailureEvent;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.BootstrapMachinesFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.ClusterProxyUpdateRegistrationFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.CollectMetadataResultToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.HostMetadataSetupFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.InstallFreeIpaServicesFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.PostInstallFreeIpaFailedToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.freeipa.upscale.failure.UpscaleStackResultToUpscaleFailureEventConverter;\n+import com.sequenceiq.freeipa.flow.stack.StackContext;\n+import com.sequenceiq.freeipa.flow.stack.StackEvent;\n+import com.sequenceiq.freeipa.service.TlsSetupService;\n+import com.sequenceiq.freeipa.service.operation.OperationService;\n+import com.sequenceiq.freeipa.service.resource.ResourceService;\n+import com.sequenceiq.freeipa.service.stack.StackUpdater;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceGroupService;\n+import com.sequenceiq.freeipa.service.stack.instance.InstanceMetaDataService;\n+import com.sequenceiq.freeipa.service.stack.instance.MetadataSetupService;\n+\n+@Configuration\n+public class FreeIpaUpscaleActions {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(FreeIpaUpscaleActions.class);\n+\n+    @Inject\n+    private ResourceService resourceService;\n+\n+    @Inject\n+    private InstanceMetaDataService instanceMetaDataService;\n+\n+    @Inject\n+    private StackToCloudStackConverter cloudStackConverter;\n+\n+    @Inject\n+    private ResourceToCloudResourceConverter resourceConverter;\n+\n+    @Inject\n+    private MetadataSetupService metadataSetupService;\n+\n+    @Inject\n+    private TlsSetupService tlsSetupService;\n+\n+    @Inject\n+    private StackUpdater stackUpdater;\n+\n+    @Inject\n+    private InstanceGroupService instanceGroupService;\n+\n+    @Bean(name = \"UPSCALE_STARTING_STATE\")\n+    public Action<?, ?> startingAction() {\n+        return new AbstractUpscaleAction<>(UpscaleEvent.class) {\n+            @Override\n+            protected void doExecute(StackContext context, UpscaleEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                String operationId = payload.getOperationId();\n+                setOperationId(variables, operationId);\n+                setInstanceCountByGroup(variables, payload.getInstanceCountByGroup());\n+                setRepair(variables, payload.isRepair());\n+                LOGGER.info(\"Starting upscale of stack {}\", stack.getId());\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.UPSCALE_IN_PROGRESS, \"Starting upscale\");\n+                sendEvent(context, UPSCALE_STARTING_FINISHED_EVENT.selector(), new StackEvent(stack.getId()));\n+            }\n+        };\n+    }\n+\n+    @Bean(name = \"UPSCALE_ADD_INSTANCES_STATE\")\n+    public Action<?, ?> addInstancesAction() {\n+        return new AbstractUpscaleAction<>(StackEvent.class) {\n+            @Override\n+            protected void doExecute(StackContext context, StackEvent payload, Map<Object, Object> variables) {\n+                Stack stack = context.getStack();\n+                stackUpdater.updateStackStatus(stack.getId(), DetailedStackStatus.UPSCALE_IN_PROGRESS, \"Adding instances\");\n+\n+                List<CloudInstance> newInstances = buildNewInstances(context.getStack(), getInstanceCountByGroup(variables));\n+                if (newInstances.isEmpty()) {\n+                    skipAddingNewInstances(context, stack);\n+                } else {\n+                    addNewInstances(context, stack, newInstances);\n+                }\n+            }\n+\n+            private void skipAddingNewInstances(StackContext context, Stack stack) {\n+                List<CloudResourceStatus> list = resourceService.getAllAsCloudResourceStatus(stack.getId());\n+                UpscaleStackRequest<UpscaleStackResult> request = new UpscaleStackRequest<>(\n+                        context.getCloudContext(), context.getCloudCredential(), context.getCloudStack(), ResourceLists.transform(list));\n+                UpscaleStackResult result = new UpscaleStackResult(request.getResourceId(), ResourceStatus.CREATED, list);\n+                sendEvent(context, result.selector(), result);\n+            }\n+\n+            private void addNewInstances(StackContext context, Stack stack, List<CloudInstance> newInstances) {\n+                Stack updatedStack = instanceMetaDataService.saveInstanceAndGetUpdatedStack(stack, newInstances);\n+                List<CloudResource> cloudResources = resourceService.findAllByStackId(stack.getId()).stream()\n+                        .map(resource -> resourceConverter.convert(resource))\n+                        .collect(Collectors.toList());\n+                CloudStack updatedCloudStack = cloudStackConverter.convert(updatedStack);\n+                UpscaleStackRequest<UpscaleStackResult> request = new UpscaleStackRequest<>(\n+                        context.getCloudContext(), context.getCloudCredential(), updatedCloudStack, cloudResources);\n+                sendEvent(context, request.selector(), request);\n+            }\n+\n+            private List<CloudInstance> buildNewInstances(Stack stack, int instanceCountByGroup) {\n+                long privateId = getFirstValidPrivateId(stack.getInstanceGroups());\n+                List<CloudInstance> newInstances = new ArrayList<>();\n+                for (InstanceGroup instanceGroup : stack.getInstanceGroups()) {\n+                    int remainingInstances = instanceCountByGroup - instanceGroup.getNotDeletedInstanceMetaDataSet().size();\n+                    for (long i = 0; i < remainingInstances; ++i) {\n+                        newInstances.add(cloudStackConverter.buildInstance(stack, null, instanceGroup,\n+                                stack.getStackAuthentication(), privateId++, InstanceStatus.CREATE_REQUESTED));\n+                    }\n+                }\n+                return newInstances;\n+            }\n+\n+            private Long getFirstValidPrivateId(Set<InstanceGroup> instanceGroups) {", "originalCommit": "5ad1816a0508b559927e3c1178960fa4ed1cf513", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTYwMTE0Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8220#discussion_r439601146", "bodyText": "I agree its a duplicate. Right now, we have cloudbreak core and freeipa versions of InstanceGroup. They don't share common interfaces. This is the same for a bunch of other classes. While it would be nice to refactor this with a shared API, a shared private instance probably isn't too valuable by itself.", "author": "jamisonbennett", "createdAt": "2020-06-12T19:18:44Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQzOTQyOTAyOA=="}], "type": "inlineReview"}, {"oid": "c7a071b8ecf462190a9553cf42d38f152bf411dd", "url": "https://github.com/hortonworks/cloudbreak/commit/c7a071b8ecf462190a9553cf42d38f152bf411dd", "message": "CB-7336: Add upscaling FreeIPA for recovery of non-CRL master nodes\n\nWhen a non-CRL master fails, the recovery should perform a downscale\nfollowed by an upscale.\nThe upscale process includes:\n  * Adding the new cloud instances\n  * Validating the cloud instances\n  * Retrieving the metadata for the new instances\n  * Saving the metadata for the new instances\n  * Setting up TLS\n  * Bootstrapping salt on the new instances\n  * Collecting the new hostnames using salt\n  * Saving the new hostnames in the database\n  * Installing FreeIPA and replicating from an existing node\n  * Updating cluster proxy registration\n  * Post installation steps for FreeIPA to update the replication\n    topology\n\nRepair was tested with the added tests and it was also tested manually\nby repairing a 2 node FreeIPA cluster. The primary gateway was the CA\nmaster & CRL master and that node was kept.", "committedDate": "2020-06-12T19:04:05Z", "type": "commit"}, {"oid": "c7a071b8ecf462190a9553cf42d38f152bf411dd", "url": "https://github.com/hortonworks/cloudbreak/commit/c7a071b8ecf462190a9553cf42d38f152bf411dd", "message": "CB-7336: Add upscaling FreeIPA for recovery of non-CRL master nodes\n\nWhen a non-CRL master fails, the recovery should perform a downscale\nfollowed by an upscale.\nThe upscale process includes:\n  * Adding the new cloud instances\n  * Validating the cloud instances\n  * Retrieving the metadata for the new instances\n  * Saving the metadata for the new instances\n  * Setting up TLS\n  * Bootstrapping salt on the new instances\n  * Collecting the new hostnames using salt\n  * Saving the new hostnames in the database\n  * Installing FreeIPA and replicating from an existing node\n  * Updating cluster proxy registration\n  * Post installation steps for FreeIPA to update the replication\n    topology\n\nRepair was tested with the added tests and it was also tested manually\nby repairing a 2 node FreeIPA cluster. The primary gateway was the CA\nmaster & CRL master and that node was kept.", "committedDate": "2020-06-12T19:04:05Z", "type": "forcePushed"}]}