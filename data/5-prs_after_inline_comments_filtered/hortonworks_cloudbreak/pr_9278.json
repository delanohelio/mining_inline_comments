{"pr_number": 9278, "pr_title": "CB-9298: Instance status is incorrect on UI", "pr_createdAt": "2020-10-23T00:04:50Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/9278", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk0Nzg3Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/9278#discussion_r510947876", "bodyText": "I think this might only work for cases where the status is unreachable. For example, if the instance health is unhealthy I suspect the UI will report \"running\" since it will rely on the VM status which will be started which means the instance status will be created which means the UI will report \"running\".", "author": "jamisonbennett", "createdAt": "2020-10-23T15:03:57Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/sync/ProviderChecker.java", "diffHunk": "@@ -74,33 +77,39 @@\n         }, LOGGER, \":::Auto sync::: provider is checked in {}ms\");\n     }\n \n-    private InstanceStatus updateStatuses(CloudVmInstanceStatus vmInstanceStatus, InstanceMetaData instanceMetaData) {\n+    private InstanceStatus updateStatuses(CloudVmInstanceStatus vmInstanceStatus, InstanceMetaData instanceMetaData,\n+        Map<InstanceMetaData, DetailedStackStatus> instanceHealthStatusMap) {\n         LOGGER.info(\":::Auto sync::: {} instance metadata status update in progress, new status: {}\",\n                 instanceMetaData.getShortHostname(), vmInstanceStatus);\n         InstanceStatus status = null;\n-        switch (vmInstanceStatus.getStatus()) {\n-            case STARTED:\n-                setStatusIfNotTheSame(instanceMetaData, InstanceStatus.CREATED);\n-                status = InstanceStatus.CREATED;\n-                break;\n-            case STOPPED:\n-                setStatusIfNotTheSame(instanceMetaData, InstanceStatus.STOPPED);\n-                status = InstanceStatus.STOPPED;\n-                break;\n-            case FAILED:\n-                setStatusIfNotTheSame(instanceMetaData, InstanceStatus.FAILED);\n-                status = InstanceStatus.FAILED;\n-                break;\n-            case TERMINATED:\n-                setStatusIfNotTheSame(instanceMetaData, InstanceStatus.DELETED_ON_PROVIDER_SIDE);\n-                status = InstanceStatus.DELETED_ON_PROVIDER_SIDE;\n-                break;\n-            case TERMINATED_BY_PROVIDER:\n-                setStatusIfNotTheSame(instanceMetaData, InstanceStatus.DELETED_BY_PROVIDER);\n-                status = InstanceStatus.DELETED_BY_PROVIDER;\n-                break;\n-            default:\n-                LOGGER.info(\":::Auto sync::: the '{}' status is not converted\", vmInstanceStatus.getStatus());\n+        if (DetailedStackStatus.UNREACHABLE == instanceHealthStatusMap.get(instanceMetaData)) {", "originalCommit": "4f942f3c0aa971233e555bfbf5a058e33c93eb4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyNjM5OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9278#discussion_r512026399", "bodyText": "Thanks for the suggestion! I added an UNHEALTHY status to the instancestatus enum to catch UNHEALTHY separately. If this is merged, I will also add the UNHEALTHY to cloudbreak-cloud UI repository to be able to display UNHEALTHY in UI (https://github.com/hortonworks/hortonworks-cloud/blob/master/web/cloudbreak-ui/src/app/helpers/freeipa.helpers.ts).", "author": "christmasferret", "createdAt": "2020-10-26T14:58:12Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk0Nzg3Ng=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk1NTIxNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9278#discussion_r510955215", "bodyText": "Since the unreachable's logic above is the highest precedence, it appears that unhealthy overrides stopped, failed, terminated, and terminated by the provider (all of which will report an unreachable status). I think the instance's health status should only be considered if the VM is in the running state.", "author": "jamisonbennett", "createdAt": "2020-10-23T15:15:22Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/sync/ProviderChecker.java", "diffHunk": "@@ -74,33 +77,39 @@\n         }, LOGGER, \":::Auto sync::: provider is checked in {}ms\");\n     }\n \n-    private InstanceStatus updateStatuses(CloudVmInstanceStatus vmInstanceStatus, InstanceMetaData instanceMetaData) {\n+    private InstanceStatus updateStatuses(CloudVmInstanceStatus vmInstanceStatus, InstanceMetaData instanceMetaData,\n+        Map<InstanceMetaData, DetailedStackStatus> instanceHealthStatusMap) {\n         LOGGER.info(\":::Auto sync::: {} instance metadata status update in progress, new status: {}\",\n                 instanceMetaData.getShortHostname(), vmInstanceStatus);\n         InstanceStatus status = null;\n-        switch (vmInstanceStatus.getStatus()) {\n-            case STARTED:\n-                setStatusIfNotTheSame(instanceMetaData, InstanceStatus.CREATED);\n-                status = InstanceStatus.CREATED;\n-                break;\n-            case STOPPED:\n-                setStatusIfNotTheSame(instanceMetaData, InstanceStatus.STOPPED);\n-                status = InstanceStatus.STOPPED;\n-                break;\n-            case FAILED:\n-                setStatusIfNotTheSame(instanceMetaData, InstanceStatus.FAILED);\n-                status = InstanceStatus.FAILED;\n-                break;\n-            case TERMINATED:\n-                setStatusIfNotTheSame(instanceMetaData, InstanceStatus.DELETED_ON_PROVIDER_SIDE);\n-                status = InstanceStatus.DELETED_ON_PROVIDER_SIDE;\n-                break;\n-            case TERMINATED_BY_PROVIDER:\n-                setStatusIfNotTheSame(instanceMetaData, InstanceStatus.DELETED_BY_PROVIDER);\n-                status = InstanceStatus.DELETED_BY_PROVIDER;\n-                break;\n-            default:\n-                LOGGER.info(\":::Auto sync::: the '{}' status is not converted\", vmInstanceStatus.getStatus());\n+        if (DetailedStackStatus.UNREACHABLE == instanceHealthStatusMap.get(instanceMetaData)) {\n+            setStatusIfNotTheSame(instanceMetaData, InstanceStatus.UNREACHABLE);\n+            status = InstanceStatus.UNREACHABLE;\n+        } else {\n+            switch (vmInstanceStatus.getStatus()) {\n+                case STARTED:\n+                    setStatusIfNotTheSame(instanceMetaData, InstanceStatus.CREATED);\n+                    status = InstanceStatus.CREATED;\n+                    break;\n+                case STOPPED:\n+                    setStatusIfNotTheSame(instanceMetaData, InstanceStatus.STOPPED);\n+                    status = InstanceStatus.STOPPED;\n+                    break;\n+                case FAILED:\n+                    setStatusIfNotTheSame(instanceMetaData, InstanceStatus.FAILED);\n+                    status = InstanceStatus.FAILED;\n+                    break;\n+                case TERMINATED:\n+                    setStatusIfNotTheSame(instanceMetaData, InstanceStatus.DELETED_ON_PROVIDER_SIDE);\n+                    status = InstanceStatus.DELETED_ON_PROVIDER_SIDE;\n+                    break;\n+                case TERMINATED_BY_PROVIDER:\n+                    setStatusIfNotTheSame(instanceMetaData, InstanceStatus.DELETED_BY_PROVIDER);\n+                    status = InstanceStatus.DELETED_BY_PROVIDER;\n+                    break;", "originalCommit": "4f942f3c0aa971233e555bfbf5a058e33c93eb4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyODU1Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/9278#discussion_r512028557", "bodyText": "You are absolutely right. I made the change so it will not overwrite the failed and terminated status. Now only running instances that are unreachable or unhealthy are reported as it is.\nTested again below,", "author": "christmasferret", "createdAt": "2020-10-26T15:00:40Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk1NTIxNQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk2NzUyOA==", "url": "https://github.com/hortonworks/cloudbreak/pull/9278#discussion_r510967528", "bodyText": "Instead of using an outbound parameter instanceHealthStatusMap, would it be better to include that as a part of the SyncResult?", "author": "jamisonbennett", "createdAt": "2020-10-23T15:31:51Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/sync/FreeipaChecker.java", "diffHunk": "@@ -29,31 +32,31 @@\n     @Inject\n     private FreeIpaHealthDetailsService freeIpaHealthDetailsService;\n \n-    private Pair<List<DetailedStackStatus>, String> checkStatus(Stack stack, Set<InstanceMetaData> checkableInstances) throws Exception {\n+    private Pair<Map<InstanceMetaData, DetailedStackStatus>, String> checkStatus(Stack stack, Set<InstanceMetaData> checkableInstances) throws Exception {\n         return checkedMeasure(() -> {\n-            List<DetailedStackStatus> statuses = new LinkedList<>();\n+            Map<InstanceMetaData, DetailedStackStatus> statuses = new HashMap<>();\n             List<RPCResponse<Boolean>> responses = new LinkedList<>();\n             for (InstanceMetaData instanceMetaData : checkableInstances) {\n                 try {\n                     RPCResponse<Boolean> response = checkedMeasure(() -> freeIpaHealthDetailsService.checkFreeIpaHealth(stack, instanceMetaData), LOGGER,\n                             \":::Auto sync::: FreeIPA health check ran in {}ms\");\n                     responses.add(response);\n                     if (response.getResult()) {\n-                        statuses.add(DetailedStackStatus.AVAILABLE);\n+                        statuses.put(instanceMetaData, DetailedStackStatus.AVAILABLE);\n                     } else {\n-                        statuses.add(DetailedStackStatus.UNHEALTHY);\n+                        statuses.put(instanceMetaData, DetailedStackStatus.UNHEALTHY);\n                     }\n                 } catch (Exception e) {\n                     LOGGER.info(\"FreeIpaClientException occurred during status fetch: \" + e.getMessage(), e);\n-                    statuses.add(DetailedStackStatus.UNREACHABLE);\n+                    statuses.put(instanceMetaData, DetailedStackStatus.UNREACHABLE);\n                 }\n             }\n             String message = getMessages(responses);\n             return Pair.of(statuses, message);\n         }, LOGGER, \":::Auto sync::: freeipa server status is checked in {}ms\");\n     }\n \n-    public SyncResult getStatus(Stack stack, Set<InstanceMetaData> checkableInstances) {\n+    public SyncResult getStatus(Stack stack, Set<InstanceMetaData> checkableInstances, Map<InstanceMetaData, DetailedStackStatus> instanceHealthStatusMap) {", "originalCommit": "4f942f3c0aa971233e555bfbf5a058e33c93eb4f", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMjAyOTUwNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9278#discussion_r512029505", "bodyText": "This is great suggestion. I returned instanceHealthStatusMap in SyncResult now. It will make the code less coupled and more readable. I removed the carrier parameter.", "author": "christmasferret", "createdAt": "2020-10-26T15:01:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMDk2NzUyOA=="}], "type": "inlineReview"}, {"oid": "3971d03fdd7d980b6cf290acbde5deb22f392b8a", "url": "https://github.com/hortonworks/cloudbreak/commit/3971d03fdd7d980b6cf290acbde5deb22f392b8a", "message": "CB-9298: Instance status is incorrect on UI\n\nIntegrated freeipa health check and platform instance check results to show actual instance statuses on UI. Currently instance status is incorrect on UI when the instances are unreachable because only platform instance check is used. The platform instance check doesn't check if the instance is reachable. If instances are not available, the UI will show incorrect running status. With this fix, the UI will show the instance as unreachable.", "committedDate": "2020-10-26T01:28:53Z", "type": "forcePushed"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczODMwNQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9278#discussion_r513738305", "bodyText": "I think I know the answer to this but I wanted to check. Is the reason that DetailedStackStatus.UNHEALTHTY can't bypass the cloud provider check because we need to catch the case where 1 VM is running and 1 VM is either stopped, deleted, etc?", "author": "jamisonbennett", "createdAt": "2020-10-28T20:26:27Z", "path": "freeipa/src/main/java/com/sequenceiq/freeipa/sync/StackStatusCheckerJob.java", "diffHunk": "@@ -100,11 +100,16 @@ public void syncAStack(Stack stack) {\n                     }\n                     if (!checkableInstances.isEmpty()) {\n                         SyncResult syncResult = freeipaChecker.getStatus(stack, checkableInstances);\n-                        List<ProviderSyncResult> results = providerChecker.updateAndGetStatuses(stack, checkableInstances, syncResult.getInstanceStatusMap());\n-                        if (!results.isEmpty()) {\n-                            updateStackStatus(stack, syncResult, results, alreadyDeletedCount);\n+                        if (DetailedStackStatus.AVAILABLE == syncResult.getStatus()) {", "originalCommit": "85ca87fd33ec0f33c10648f5c29ee0e421760d31", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzc2ODI4NQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/9278#discussion_r513768285", "bodyText": "DetailedStackStatus.AVAILABLE happens only when freeipa in all instances are available. That is skipped by this change.", "author": "christmasferret", "createdAt": "2020-10-28T21:20:48Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDUxMzczODMwNQ=="}], "type": "inlineReview"}, {"oid": "2c6bca900d8d552b05851b701e96bb068e1f0392", "url": "https://github.com/hortonworks/cloudbreak/commit/2c6bca900d8d552b05851b701e96bb068e1f0392", "message": "CB-9298: Instance status is incorrect on UI\n\nIntegrated freeipa health check and platform instance check results to show actual instance statuses on UI. Currently instance status is incorrect on UI when the instances are unreachable because only platform instance check is used. The platform instance check doesn't check if the instance is reachable. If instances are not available, the UI will show incorrect running status. With this fix, the UI will show the instance as unreachable.", "committedDate": "2020-10-29T18:31:08Z", "type": "forcePushed"}, {"oid": "23f2ba23e654b73475124537e105a5b16c0dd7b6", "url": "https://github.com/hortonworks/cloudbreak/commit/23f2ba23e654b73475124537e105a5b16c0dd7b6", "message": "CB-9298: Instance status is incorrect on UI\n\nIntegrated freeipa health check and platform instance check results to show actual instance statuses on UI. Currently instance status is incorrect on UI when the instances are unreachable because only platform instance check is used. The platform instance check doesn't check if the instance is reachable. If instances are not available, the UI will show incorrect running status. With this fix, the UI will show the instance as unreachable.", "committedDate": "2020-10-29T18:37:17Z", "type": "commit"}, {"oid": "23f2ba23e654b73475124537e105a5b16c0dd7b6", "url": "https://github.com/hortonworks/cloudbreak/commit/23f2ba23e654b73475124537e105a5b16c0dd7b6", "message": "CB-9298: Instance status is incorrect on UI\n\nIntegrated freeipa health check and platform instance check results to show actual instance statuses on UI. Currently instance status is incorrect on UI when the instances are unreachable because only platform instance check is used. The platform instance check doesn't check if the instance is reachable. If instances are not available, the UI will show incorrect running status. With this fix, the UI will show the instance as unreachable.", "committedDate": "2020-10-29T18:37:17Z", "type": "forcePushed"}]}