{"pr_number": 8918, "pr_title": "Initial GCP PR for adding Request response pairs", "pr_createdAt": "2020-09-03T11:42:55Z", "pr_url": "https://github.com/hortonworks/cloudbreak/pull/8918", "timeline": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI2ODM2Ng==", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483268366", "bodyText": "Not pressing, but something we have to look out for. GCP subnets span across all the AZs in that region, and the user can not control it. So giving a subnet is enough in GCP.", "author": "cegganesh84", "createdAt": "2020-09-03T21:39:15Z", "path": "cloud-api/src/main/java/com/sequenceiq/cloudbreak/cloud/DefaultNetworkConnector.java", "diffHunk": "@@ -17,14 +17,14 @@\n import com.sequenceiq.cloudbreak.cloud.model.SubnetSelectionParameters;\n import com.sequenceiq.cloudbreak.cloud.model.SubnetSelectionResult;\n \n-public abstract class DefaultNetworkConnector implements NetworkConnector {\n+public interface DefaultNetworkConnector extends NetworkConnector {\n \n-    private static final Logger LOGGER = LoggerFactory.getLogger(DefaultNetworkConnector.class);\n+    Logger LOGGER = LoggerFactory.getLogger(DefaultNetworkConnector.class);\n \n-    private static final String NOT_ENOUGH_AZ = \"Acceptable subnets are in %d different AZs, but subnets in %d different AZs required.\";\n+    String NOT_ENOUGH_AZ = \"Acceptable subnets are in %d different AZs, but subnets in %d different AZs required.\";", "originalCommit": "b25ea7e13e0f9bab1103c27aafd7ba1538e59c7b", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI3MTgyMA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483271820", "bodyText": "I have changed the error message to  \"Provisioning in \" + creationDto.getCloudPlatform() + \" is not enabled for this account.\" locally.", "author": "cegganesh84", "createdAt": "2020-09-03T21:47:40Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/service/EnvironmentCreationService.java", "diffHunk": "@@ -136,6 +137,7 @@ private void validateCreation(EnvironmentCreationDto creationDto, Environment en\n     }", "originalCommit": "b25ea7e13e0f9bab1103c27aafd7ba1538e59c7b", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzQxMjY5Mg==", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483412692", "bodyText": "\ud83d\udc4d", "author": "doktoric", "createdAt": "2020-09-04T06:26:04Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzI3MTgyMA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5MTk5OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483591999", "bodyText": "creation -> deletion", "author": "jamisonbennett", "createdAt": "2020-09-04T12:44:56Z", "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/GcpNetworkConnector.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package com.sequenceiq.cloudbreak.cloud.gcp;\n+\n+import static com.sequenceiq.cloudbreak.cloud.model.Location.location;\n+import static com.sequenceiq.cloudbreak.cloud.model.Region.region;\n+import static com.sequenceiq.common.api.type.ResourceType.GCP_NETWORK;\n+import static com.sequenceiq.common.api.type.ResourceType.GCP_SUBNET;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.api.client.googleapis.json.GoogleJsonResponseException;\n+import com.google.api.services.compute.Compute;\n+import com.sequenceiq.cloudbreak.cloud.DefaultNetworkConnector;\n+import com.sequenceiq.cloudbreak.cloud.NetworkConnector;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.gcp.context.GcpContext;\n+import com.sequenceiq.cloudbreak.cloud.gcp.context.GcpContextBuilder;\n+import com.sequenceiq.cloudbreak.cloud.gcp.network.GcpNetworkResourceBuilder;\n+import com.sequenceiq.cloudbreak.cloud.gcp.network.GcpSubnetResourceBuilder;\n+import com.sequenceiq.cloudbreak.cloud.gcp.service.GcpSubnetSelectorService;\n+import com.sequenceiq.cloudbreak.cloud.gcp.util.GcpStackUtil;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudCredential;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudSubnet;\n+import com.sequenceiq.cloudbreak.cloud.model.Network;\n+import com.sequenceiq.cloudbreak.cloud.model.Platform;\n+import com.sequenceiq.cloudbreak.cloud.model.Subnet;\n+import com.sequenceiq.cloudbreak.cloud.model.SubnetSelectionParameters;\n+import com.sequenceiq.cloudbreak.cloud.model.SubnetSelectionResult;\n+import com.sequenceiq.cloudbreak.cloud.model.Variant;\n+import com.sequenceiq.cloudbreak.cloud.model.network.CreatedCloudNetwork;\n+import com.sequenceiq.cloudbreak.cloud.model.network.CreatedSubnet;\n+import com.sequenceiq.cloudbreak.cloud.model.network.NetworkCreationRequest;\n+import com.sequenceiq.cloudbreak.cloud.model.network.NetworkDeletionRequest;\n+import com.sequenceiq.cloudbreak.cloud.network.NetworkCidr;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.SyncPollingScheduler;\n+import com.sequenceiq.cloudbreak.cloud.task.PollTask;\n+import com.sequenceiq.cloudbreak.cloud.template.task.ResourcePollTaskFactory;\n+import com.sequenceiq.cloudbreak.common.mappable.CloudPlatform;\n+import com.sequenceiq.common.api.type.ResourceType;\n+\n+@Component\n+public class GcpNetworkConnector extends AbstractGcpResourceBuilder implements NetworkConnector, DefaultNetworkConnector {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GcpNetworkConnector.class);\n+\n+    @Value(\"${cb.gcp.subnet.ha.different.az.min:1}\")\n+    private int minSubnetCountInDifferentAz;\n+\n+    @Value(\"${cb.gcp.subnet.ha.different.az.max:3}\")\n+    private int maxSubnetCountInDifferentAz;\n+\n+    @Inject\n+    private GcpCloudSubnetProvider gcpCloudSubnetProvider;\n+\n+    @Inject\n+    private GcpNetworkResourceBuilder gcpNetworkResourceBuilder;\n+\n+    @Inject\n+    private GcpSubnetResourceBuilder gcpSubnetResourceBuilder;\n+\n+    @Inject\n+    private GcpContextBuilder contextBuilders;\n+\n+    @Inject\n+    private SyncPollingScheduler<List<CloudResourceStatus>> syncPollingScheduler;\n+\n+    @Inject\n+    private ResourcePollTaskFactory statusCheckFactory;\n+\n+    @Inject\n+    private GcpSubnetSelectorService gcpSubnetSelectorService;\n+\n+    @Override\n+    public CreatedCloudNetwork createNetworkWithSubnets(NetworkCreationRequest networkCreationRequest) {\n+        CloudContext cloudContext = getCloudContext(networkCreationRequest);\n+        AuthenticatedContext auth = new AuthenticatedContext(cloudContext, networkCreationRequest.getCloudCredential());\n+        Network network = buildNetworkForCreation(networkCreationRequest);\n+        GcpContext context = contextBuilders.contextInit(cloudContext, auth, network, null, true);\n+\n+        try {\n+            CloudResource networkResource = createNetwork(context, auth, network);\n+            List<CreatedSubnet> subnetList = getCloudSubNets(networkCreationRequest);\n+            for (CreatedSubnet createdSubnet : subnetList) {\n+                createSubnet(context, auth, buildSubnetForCreation(networkCreationRequest, createdSubnet.getCidr()), createdSubnet);\n+            }\n+            return new CreatedCloudNetwork(networkCreationRequest.getEnvName(), networkResource.getName(), getCreatedSubnets(subnetList));\n+        } catch (GoogleJsonResponseException e) {\n+            throw new GcpResourceException(checkException(e), GCP_NETWORK, networkCreationRequest.getEnvName());\n+        } catch (IOException e) {\n+            throw new GcpResourceException(\"Network creation failed due to IO exception\", GCP_NETWORK, networkCreationRequest.getEnvName());\n+        }\n+    }\n+\n+    @Override\n+    public void deleteNetworkWithSubnets(NetworkDeletionRequest networkDeletionRequest) {\n+        CloudContext cloudContext = getCloudContext(networkDeletionRequest);\n+        AuthenticatedContext auth = new AuthenticatedContext(cloudContext, networkDeletionRequest.getCloudCredential());\n+        Network network = buildNetworkForDeletion(networkDeletionRequest);\n+        GcpContext context = contextBuilders.contextInit(cloudContext, auth, network, null, true);\n+\n+        try {\n+            for (String subnetId : networkDeletionRequest.getSubnetIds()) {\n+                deleteSubnet(context, auth, network, subnetId);\n+            }\n+            deleteNetwork(context, auth, network, networkDeletionRequest.getNetworkId());\n+        } catch (GoogleJsonResponseException e) {\n+            exceptionHandler(e, networkDeletionRequest.getStackName(), GCP_NETWORK);\n+        } catch (IOException e) {\n+            throw new GcpResourceException(\"Network deletion failed due to IO exception\", GCP_NETWORK, networkDeletionRequest.getStackName());\n+        }\n+    }\n+\n+    @Override\n+    public NetworkCidr getNetworkCidr(Network network, CloudCredential credential) {\n+        String subnetId = network.getStringParameter(GcpStackUtil.SUBNET_ID);\n+        String region = network.getStringParameter(GcpStackUtil.REGION);\n+        LOGGER.debug(\"Getting network cidrs for subnet {} in region {}\", subnetId, region);\n+        Compute compute = GcpStackUtil.buildCompute(credential);\n+        String projectId = GcpStackUtil.getProjectId(credential);\n+        try {\n+            String ipCidrRange = compute.subnetworks().get(projectId, region, subnetId).execute().getIpCidrRange();\n+            return new NetworkCidr(ipCidrRange, Collections.singletonList(ipCidrRange));\n+        } catch (IOException e) {\n+            throw new GcpResourceException(\"Describe subnets failed due to IO exception\", GCP_NETWORK, subnetId);\n+        }\n+    }\n+\n+    @Override\n+    public SubnetSelectionResult filterSubnets(Collection<CloudSubnet> subnetMetas, SubnetSelectionParameters subnetSelectionParameters) {\n+        return gcpSubnetSelectorService.select(subnetMetas, subnetSelectionParameters);\n+    }\n+\n+    @Override\n+    public int subnetCountInDifferentAzMin() {\n+        return minSubnetCountInDifferentAz;\n+    }\n+\n+    @Override\n+    public int subnetCountInDifferentAzMax() {\n+        return maxSubnetCountInDifferentAz;\n+    }\n+\n+    private CloudContext getCloudContext(NetworkCreationRequest networkRequest) {\n+        return new CloudContext(\n+                networkRequest.getEnvId(),\n+                networkRequest.getEnvName(),\n+                CloudPlatform.GCP.name(),\n+                CloudPlatform.GCP.name(),\n+                location(networkRequest.getRegion()),\n+                networkRequest.getCreatorCrn(),\n+                networkRequest.getAccountId());\n+    }\n+\n+    private CloudContext getCloudContext(NetworkDeletionRequest networkRequest) {\n+        return new CloudContext(\n+                networkRequest.getEnvId(),\n+                networkRequest.getEnvName(),\n+                CloudPlatform.GCP.name(),\n+                CloudPlatform.GCP.name(),\n+                location(region(networkRequest.getRegion())),\n+                networkRequest.getUserId(),\n+                networkRequest.getAccountId());\n+    }\n+\n+    private Network buildNetworkForCreation(NetworkCreationRequest networkRequest) {\n+        Subnet subnet = new Subnet(networkRequest.getNetworkCidr());\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(GcpStackUtil.NETWORK_IP_RANGE, networkRequest.getNetworkCidr());\n+        return new Network(subnet, params);\n+    }\n+\n+    private Network buildNetworkForDeletion(NetworkDeletionRequest networkRequest) {\n+        return new Network(null);\n+    }\n+\n+    private Network buildSubnetForCreation(NetworkCreationRequest networkRequest, String cidr) {\n+        Network network = buildNetworkForCreation(networkRequest);\n+        Subnet subnet = new Subnet(cidr);\n+        network = new Network(subnet, network.getParameters());\n+        return network;\n+    }\n+\n+    private CloudResource createSubnet(GcpContext context, AuthenticatedContext auth, Network network, CreatedSubnet subnet) {\n+        CloudResource cloudResource = gcpSubnetResourceBuilder.create(context, auth, network);\n+        try {\n+            cloudResource = gcpSubnetResourceBuilder.build(context, auth, network, null, cloudResource);\n+            PollTask<List<CloudResourceStatus>> task = statusCheckFactory.newPollResourceTask(gcpSubnetResourceBuilder,\n+                    auth, Collections.singletonList(cloudResource), context, true);\n+            subnet.setSubnetId(cloudResource.getName());\n+            syncPollingScheduler.schedule(task);\n+        } catch (Exception e) {\n+            LOGGER.debug(\"Skipping resource creation: {}\", e.getMessage());\n+        }\n+        return cloudResource;\n+    }\n+\n+    private CloudResource createNetwork(GcpContext context, AuthenticatedContext auth, Network network) {\n+        CloudResource cloudResource = gcpNetworkResourceBuilder.create(context, auth, network);\n+        try {\n+            cloudResource = gcpNetworkResourceBuilder.build(context, auth, network, null, cloudResource);\n+            PollTask<List<CloudResourceStatus>> task = statusCheckFactory.newPollResourceTask(gcpNetworkResourceBuilder,\n+                    auth, Collections.singletonList(cloudResource), context, true);\n+            syncPollingScheduler.schedule(task);\n+        } catch (Exception e) {\n+            LOGGER.debug(\"Skipping resource creation: {}\", e.getMessage());\n+        }\n+        return cloudResource;\n+    }\n+\n+    private void deleteNetwork(GcpContext context, AuthenticatedContext auth, Network network, String networkId) throws IOException {\n+        CloudResource networkResource = createNamedResource(GCP_NETWORK, networkId);\n+        try {\n+            CloudResource deletedResource = gcpNetworkResourceBuilder.delete(context, auth, networkResource, network);\n+            if (deletedResource != null) {\n+                PollTask<List<CloudResourceStatus>> task = statusCheckFactory.newPollResourceTask(\n+                        gcpSubnetResourceBuilder, auth, Collections.singletonList(deletedResource), context, true);\n+                syncPollingScheduler.schedule(task);\n+            }\n+        } catch (Exception e) {\n+            LOGGER.debug(\"Skipping resource creation: {}\", e.getMessage());", "originalCommit": "7d71a0504ea930a18fdbed61035ac88137d56213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5MjQ2Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483592467", "bodyText": "creation -> deletion", "author": "jamisonbennett", "createdAt": "2020-09-04T12:45:59Z", "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/GcpNetworkConnector.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package com.sequenceiq.cloudbreak.cloud.gcp;\n+\n+import static com.sequenceiq.cloudbreak.cloud.model.Location.location;\n+import static com.sequenceiq.cloudbreak.cloud.model.Region.region;\n+import static com.sequenceiq.common.api.type.ResourceType.GCP_NETWORK;\n+import static com.sequenceiq.common.api.type.ResourceType.GCP_SUBNET;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.api.client.googleapis.json.GoogleJsonResponseException;\n+import com.google.api.services.compute.Compute;\n+import com.sequenceiq.cloudbreak.cloud.DefaultNetworkConnector;\n+import com.sequenceiq.cloudbreak.cloud.NetworkConnector;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.gcp.context.GcpContext;\n+import com.sequenceiq.cloudbreak.cloud.gcp.context.GcpContextBuilder;\n+import com.sequenceiq.cloudbreak.cloud.gcp.network.GcpNetworkResourceBuilder;\n+import com.sequenceiq.cloudbreak.cloud.gcp.network.GcpSubnetResourceBuilder;\n+import com.sequenceiq.cloudbreak.cloud.gcp.service.GcpSubnetSelectorService;\n+import com.sequenceiq.cloudbreak.cloud.gcp.util.GcpStackUtil;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudCredential;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudSubnet;\n+import com.sequenceiq.cloudbreak.cloud.model.Network;\n+import com.sequenceiq.cloudbreak.cloud.model.Platform;\n+import com.sequenceiq.cloudbreak.cloud.model.Subnet;\n+import com.sequenceiq.cloudbreak.cloud.model.SubnetSelectionParameters;\n+import com.sequenceiq.cloudbreak.cloud.model.SubnetSelectionResult;\n+import com.sequenceiq.cloudbreak.cloud.model.Variant;\n+import com.sequenceiq.cloudbreak.cloud.model.network.CreatedCloudNetwork;\n+import com.sequenceiq.cloudbreak.cloud.model.network.CreatedSubnet;\n+import com.sequenceiq.cloudbreak.cloud.model.network.NetworkCreationRequest;\n+import com.sequenceiq.cloudbreak.cloud.model.network.NetworkDeletionRequest;\n+import com.sequenceiq.cloudbreak.cloud.network.NetworkCidr;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.SyncPollingScheduler;\n+import com.sequenceiq.cloudbreak.cloud.task.PollTask;\n+import com.sequenceiq.cloudbreak.cloud.template.task.ResourcePollTaskFactory;\n+import com.sequenceiq.cloudbreak.common.mappable.CloudPlatform;\n+import com.sequenceiq.common.api.type.ResourceType;\n+\n+@Component\n+public class GcpNetworkConnector extends AbstractGcpResourceBuilder implements NetworkConnector, DefaultNetworkConnector {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GcpNetworkConnector.class);\n+\n+    @Value(\"${cb.gcp.subnet.ha.different.az.min:1}\")\n+    private int minSubnetCountInDifferentAz;\n+\n+    @Value(\"${cb.gcp.subnet.ha.different.az.max:3}\")\n+    private int maxSubnetCountInDifferentAz;\n+\n+    @Inject\n+    private GcpCloudSubnetProvider gcpCloudSubnetProvider;\n+\n+    @Inject\n+    private GcpNetworkResourceBuilder gcpNetworkResourceBuilder;\n+\n+    @Inject\n+    private GcpSubnetResourceBuilder gcpSubnetResourceBuilder;\n+\n+    @Inject\n+    private GcpContextBuilder contextBuilders;\n+\n+    @Inject\n+    private SyncPollingScheduler<List<CloudResourceStatus>> syncPollingScheduler;\n+\n+    @Inject\n+    private ResourcePollTaskFactory statusCheckFactory;\n+\n+    @Inject\n+    private GcpSubnetSelectorService gcpSubnetSelectorService;\n+\n+    @Override\n+    public CreatedCloudNetwork createNetworkWithSubnets(NetworkCreationRequest networkCreationRequest) {\n+        CloudContext cloudContext = getCloudContext(networkCreationRequest);\n+        AuthenticatedContext auth = new AuthenticatedContext(cloudContext, networkCreationRequest.getCloudCredential());\n+        Network network = buildNetworkForCreation(networkCreationRequest);\n+        GcpContext context = contextBuilders.contextInit(cloudContext, auth, network, null, true);\n+\n+        try {\n+            CloudResource networkResource = createNetwork(context, auth, network);\n+            List<CreatedSubnet> subnetList = getCloudSubNets(networkCreationRequest);\n+            for (CreatedSubnet createdSubnet : subnetList) {\n+                createSubnet(context, auth, buildSubnetForCreation(networkCreationRequest, createdSubnet.getCidr()), createdSubnet);\n+            }\n+            return new CreatedCloudNetwork(networkCreationRequest.getEnvName(), networkResource.getName(), getCreatedSubnets(subnetList));\n+        } catch (GoogleJsonResponseException e) {\n+            throw new GcpResourceException(checkException(e), GCP_NETWORK, networkCreationRequest.getEnvName());\n+        } catch (IOException e) {\n+            throw new GcpResourceException(\"Network creation failed due to IO exception\", GCP_NETWORK, networkCreationRequest.getEnvName());\n+        }\n+    }\n+\n+    @Override\n+    public void deleteNetworkWithSubnets(NetworkDeletionRequest networkDeletionRequest) {\n+        CloudContext cloudContext = getCloudContext(networkDeletionRequest);\n+        AuthenticatedContext auth = new AuthenticatedContext(cloudContext, networkDeletionRequest.getCloudCredential());\n+        Network network = buildNetworkForDeletion(networkDeletionRequest);\n+        GcpContext context = contextBuilders.contextInit(cloudContext, auth, network, null, true);\n+\n+        try {\n+            for (String subnetId : networkDeletionRequest.getSubnetIds()) {\n+                deleteSubnet(context, auth, network, subnetId);\n+            }\n+            deleteNetwork(context, auth, network, networkDeletionRequest.getNetworkId());\n+        } catch (GoogleJsonResponseException e) {\n+            exceptionHandler(e, networkDeletionRequest.getStackName(), GCP_NETWORK);\n+        } catch (IOException e) {\n+            throw new GcpResourceException(\"Network deletion failed due to IO exception\", GCP_NETWORK, networkDeletionRequest.getStackName());\n+        }\n+    }\n+\n+    @Override\n+    public NetworkCidr getNetworkCidr(Network network, CloudCredential credential) {\n+        String subnetId = network.getStringParameter(GcpStackUtil.SUBNET_ID);\n+        String region = network.getStringParameter(GcpStackUtil.REGION);\n+        LOGGER.debug(\"Getting network cidrs for subnet {} in region {}\", subnetId, region);\n+        Compute compute = GcpStackUtil.buildCompute(credential);\n+        String projectId = GcpStackUtil.getProjectId(credential);\n+        try {\n+            String ipCidrRange = compute.subnetworks().get(projectId, region, subnetId).execute().getIpCidrRange();\n+            return new NetworkCidr(ipCidrRange, Collections.singletonList(ipCidrRange));\n+        } catch (IOException e) {\n+            throw new GcpResourceException(\"Describe subnets failed due to IO exception\", GCP_NETWORK, subnetId);\n+        }\n+    }\n+\n+    @Override\n+    public SubnetSelectionResult filterSubnets(Collection<CloudSubnet> subnetMetas, SubnetSelectionParameters subnetSelectionParameters) {\n+        return gcpSubnetSelectorService.select(subnetMetas, subnetSelectionParameters);\n+    }\n+\n+    @Override\n+    public int subnetCountInDifferentAzMin() {\n+        return minSubnetCountInDifferentAz;\n+    }\n+\n+    @Override\n+    public int subnetCountInDifferentAzMax() {\n+        return maxSubnetCountInDifferentAz;\n+    }\n+\n+    private CloudContext getCloudContext(NetworkCreationRequest networkRequest) {\n+        return new CloudContext(\n+                networkRequest.getEnvId(),\n+                networkRequest.getEnvName(),\n+                CloudPlatform.GCP.name(),\n+                CloudPlatform.GCP.name(),\n+                location(networkRequest.getRegion()),\n+                networkRequest.getCreatorCrn(),\n+                networkRequest.getAccountId());\n+    }\n+\n+    private CloudContext getCloudContext(NetworkDeletionRequest networkRequest) {\n+        return new CloudContext(\n+                networkRequest.getEnvId(),\n+                networkRequest.getEnvName(),\n+                CloudPlatform.GCP.name(),\n+                CloudPlatform.GCP.name(),\n+                location(region(networkRequest.getRegion())),\n+                networkRequest.getUserId(),\n+                networkRequest.getAccountId());\n+    }\n+\n+    private Network buildNetworkForCreation(NetworkCreationRequest networkRequest) {\n+        Subnet subnet = new Subnet(networkRequest.getNetworkCidr());\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(GcpStackUtil.NETWORK_IP_RANGE, networkRequest.getNetworkCidr());\n+        return new Network(subnet, params);\n+    }\n+\n+    private Network buildNetworkForDeletion(NetworkDeletionRequest networkRequest) {\n+        return new Network(null);\n+    }\n+\n+    private Network buildSubnetForCreation(NetworkCreationRequest networkRequest, String cidr) {\n+        Network network = buildNetworkForCreation(networkRequest);\n+        Subnet subnet = new Subnet(cidr);\n+        network = new Network(subnet, network.getParameters());\n+        return network;\n+    }\n+\n+    private CloudResource createSubnet(GcpContext context, AuthenticatedContext auth, Network network, CreatedSubnet subnet) {\n+        CloudResource cloudResource = gcpSubnetResourceBuilder.create(context, auth, network);\n+        try {\n+            cloudResource = gcpSubnetResourceBuilder.build(context, auth, network, null, cloudResource);\n+            PollTask<List<CloudResourceStatus>> task = statusCheckFactory.newPollResourceTask(gcpSubnetResourceBuilder,\n+                    auth, Collections.singletonList(cloudResource), context, true);\n+            subnet.setSubnetId(cloudResource.getName());\n+            syncPollingScheduler.schedule(task);\n+        } catch (Exception e) {\n+            LOGGER.debug(\"Skipping resource creation: {}\", e.getMessage());\n+        }\n+        return cloudResource;\n+    }\n+\n+    private CloudResource createNetwork(GcpContext context, AuthenticatedContext auth, Network network) {\n+        CloudResource cloudResource = gcpNetworkResourceBuilder.create(context, auth, network);\n+        try {\n+            cloudResource = gcpNetworkResourceBuilder.build(context, auth, network, null, cloudResource);\n+            PollTask<List<CloudResourceStatus>> task = statusCheckFactory.newPollResourceTask(gcpNetworkResourceBuilder,\n+                    auth, Collections.singletonList(cloudResource), context, true);\n+            syncPollingScheduler.schedule(task);\n+        } catch (Exception e) {\n+            LOGGER.debug(\"Skipping resource creation: {}\", e.getMessage());\n+        }\n+        return cloudResource;\n+    }\n+\n+    private void deleteNetwork(GcpContext context, AuthenticatedContext auth, Network network, String networkId) throws IOException {\n+        CloudResource networkResource = createNamedResource(GCP_NETWORK, networkId);\n+        try {\n+            CloudResource deletedResource = gcpNetworkResourceBuilder.delete(context, auth, networkResource, network);\n+            if (deletedResource != null) {\n+                PollTask<List<CloudResourceStatus>> task = statusCheckFactory.newPollResourceTask(\n+                        gcpSubnetResourceBuilder, auth, Collections.singletonList(deletedResource), context, true);\n+                syncPollingScheduler.schedule(task);\n+            }\n+        } catch (Exception e) {\n+            LOGGER.debug(\"Skipping resource creation: {}\", e.getMessage());\n+        }\n+    }\n+\n+    private void deleteSubnet(GcpContext context, AuthenticatedContext auth, Network network, String subnetId) throws IOException {\n+        CloudResource subnetResource = createNamedResource(GCP_SUBNET, subnetId);\n+        try {\n+            CloudResource deletedResource = gcpSubnetResourceBuilder.delete(context, auth, subnetResource, network);\n+            if (deletedResource != null) {\n+                PollTask<List<CloudResourceStatus>> task = statusCheckFactory.newPollResourceTask(\n+                        gcpSubnetResourceBuilder, auth, Collections.singletonList(deletedResource), context, true);\n+                syncPollingScheduler.schedule(task);\n+            }\n+        } catch (Exception e) {\n+            LOGGER.debug(\"Skipping resource creation: {}\", e.getMessage());", "originalCommit": "7d71a0504ea930a18fdbed61035ac88137d56213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5MzYzNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483593637", "bodyText": "For createSubnet(), createNetwork(), deleteNetwork(), and deleteSubnet() is it really a good idea to ignore exceptions. I would think this would lead to the environment not being setup fully and it would lead to lots of strange behavior later on. And I would think these would be at least a warning level log message.", "author": "jamisonbennett", "createdAt": "2020-09-04T12:48:26Z", "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/GcpNetworkConnector.java", "diffHunk": "@@ -0,0 +1,293 @@\n+package com.sequenceiq.cloudbreak.cloud.gcp;\n+\n+import static com.sequenceiq.cloudbreak.cloud.model.Location.location;\n+import static com.sequenceiq.cloudbreak.cloud.model.Region.region;\n+import static com.sequenceiq.common.api.type.ResourceType.GCP_NETWORK;\n+import static com.sequenceiq.common.api.type.ResourceType.GCP_SUBNET;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.stream.Collectors;\n+\n+import javax.inject.Inject;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.beans.factory.annotation.Value;\n+import org.springframework.stereotype.Component;\n+\n+import com.google.api.client.googleapis.json.GoogleJsonResponseException;\n+import com.google.api.services.compute.Compute;\n+import com.sequenceiq.cloudbreak.cloud.DefaultNetworkConnector;\n+import com.sequenceiq.cloudbreak.cloud.NetworkConnector;\n+import com.sequenceiq.cloudbreak.cloud.context.AuthenticatedContext;\n+import com.sequenceiq.cloudbreak.cloud.context.CloudContext;\n+import com.sequenceiq.cloudbreak.cloud.gcp.context.GcpContext;\n+import com.sequenceiq.cloudbreak.cloud.gcp.context.GcpContextBuilder;\n+import com.sequenceiq.cloudbreak.cloud.gcp.network.GcpNetworkResourceBuilder;\n+import com.sequenceiq.cloudbreak.cloud.gcp.network.GcpSubnetResourceBuilder;\n+import com.sequenceiq.cloudbreak.cloud.gcp.service.GcpSubnetSelectorService;\n+import com.sequenceiq.cloudbreak.cloud.gcp.util.GcpStackUtil;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudCredential;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResource;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudResourceStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.CloudSubnet;\n+import com.sequenceiq.cloudbreak.cloud.model.Network;\n+import com.sequenceiq.cloudbreak.cloud.model.Platform;\n+import com.sequenceiq.cloudbreak.cloud.model.Subnet;\n+import com.sequenceiq.cloudbreak.cloud.model.SubnetSelectionParameters;\n+import com.sequenceiq.cloudbreak.cloud.model.SubnetSelectionResult;\n+import com.sequenceiq.cloudbreak.cloud.model.Variant;\n+import com.sequenceiq.cloudbreak.cloud.model.network.CreatedCloudNetwork;\n+import com.sequenceiq.cloudbreak.cloud.model.network.CreatedSubnet;\n+import com.sequenceiq.cloudbreak.cloud.model.network.NetworkCreationRequest;\n+import com.sequenceiq.cloudbreak.cloud.model.network.NetworkDeletionRequest;\n+import com.sequenceiq.cloudbreak.cloud.network.NetworkCidr;\n+import com.sequenceiq.cloudbreak.cloud.scheduler.SyncPollingScheduler;\n+import com.sequenceiq.cloudbreak.cloud.task.PollTask;\n+import com.sequenceiq.cloudbreak.cloud.template.task.ResourcePollTaskFactory;\n+import com.sequenceiq.cloudbreak.common.mappable.CloudPlatform;\n+import com.sequenceiq.common.api.type.ResourceType;\n+\n+@Component\n+public class GcpNetworkConnector extends AbstractGcpResourceBuilder implements NetworkConnector, DefaultNetworkConnector {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GcpNetworkConnector.class);\n+\n+    @Value(\"${cb.gcp.subnet.ha.different.az.min:1}\")\n+    private int minSubnetCountInDifferentAz;\n+\n+    @Value(\"${cb.gcp.subnet.ha.different.az.max:3}\")\n+    private int maxSubnetCountInDifferentAz;\n+\n+    @Inject\n+    private GcpCloudSubnetProvider gcpCloudSubnetProvider;\n+\n+    @Inject\n+    private GcpNetworkResourceBuilder gcpNetworkResourceBuilder;\n+\n+    @Inject\n+    private GcpSubnetResourceBuilder gcpSubnetResourceBuilder;\n+\n+    @Inject\n+    private GcpContextBuilder contextBuilders;\n+\n+    @Inject\n+    private SyncPollingScheduler<List<CloudResourceStatus>> syncPollingScheduler;\n+\n+    @Inject\n+    private ResourcePollTaskFactory statusCheckFactory;\n+\n+    @Inject\n+    private GcpSubnetSelectorService gcpSubnetSelectorService;\n+\n+    @Override\n+    public CreatedCloudNetwork createNetworkWithSubnets(NetworkCreationRequest networkCreationRequest) {\n+        CloudContext cloudContext = getCloudContext(networkCreationRequest);\n+        AuthenticatedContext auth = new AuthenticatedContext(cloudContext, networkCreationRequest.getCloudCredential());\n+        Network network = buildNetworkForCreation(networkCreationRequest);\n+        GcpContext context = contextBuilders.contextInit(cloudContext, auth, network, null, true);\n+\n+        try {\n+            CloudResource networkResource = createNetwork(context, auth, network);\n+            List<CreatedSubnet> subnetList = getCloudSubNets(networkCreationRequest);\n+            for (CreatedSubnet createdSubnet : subnetList) {\n+                createSubnet(context, auth, buildSubnetForCreation(networkCreationRequest, createdSubnet.getCidr()), createdSubnet);\n+            }\n+            return new CreatedCloudNetwork(networkCreationRequest.getEnvName(), networkResource.getName(), getCreatedSubnets(subnetList));\n+        } catch (GoogleJsonResponseException e) {\n+            throw new GcpResourceException(checkException(e), GCP_NETWORK, networkCreationRequest.getEnvName());\n+        } catch (IOException e) {\n+            throw new GcpResourceException(\"Network creation failed due to IO exception\", GCP_NETWORK, networkCreationRequest.getEnvName());\n+        }\n+    }\n+\n+    @Override\n+    public void deleteNetworkWithSubnets(NetworkDeletionRequest networkDeletionRequest) {\n+        CloudContext cloudContext = getCloudContext(networkDeletionRequest);\n+        AuthenticatedContext auth = new AuthenticatedContext(cloudContext, networkDeletionRequest.getCloudCredential());\n+        Network network = buildNetworkForDeletion(networkDeletionRequest);\n+        GcpContext context = contextBuilders.contextInit(cloudContext, auth, network, null, true);\n+\n+        try {\n+            for (String subnetId : networkDeletionRequest.getSubnetIds()) {\n+                deleteSubnet(context, auth, network, subnetId);\n+            }\n+            deleteNetwork(context, auth, network, networkDeletionRequest.getNetworkId());\n+        } catch (GoogleJsonResponseException e) {\n+            exceptionHandler(e, networkDeletionRequest.getStackName(), GCP_NETWORK);\n+        } catch (IOException e) {\n+            throw new GcpResourceException(\"Network deletion failed due to IO exception\", GCP_NETWORK, networkDeletionRequest.getStackName());\n+        }\n+    }\n+\n+    @Override\n+    public NetworkCidr getNetworkCidr(Network network, CloudCredential credential) {\n+        String subnetId = network.getStringParameter(GcpStackUtil.SUBNET_ID);\n+        String region = network.getStringParameter(GcpStackUtil.REGION);\n+        LOGGER.debug(\"Getting network cidrs for subnet {} in region {}\", subnetId, region);\n+        Compute compute = GcpStackUtil.buildCompute(credential);\n+        String projectId = GcpStackUtil.getProjectId(credential);\n+        try {\n+            String ipCidrRange = compute.subnetworks().get(projectId, region, subnetId).execute().getIpCidrRange();\n+            return new NetworkCidr(ipCidrRange, Collections.singletonList(ipCidrRange));\n+        } catch (IOException e) {\n+            throw new GcpResourceException(\"Describe subnets failed due to IO exception\", GCP_NETWORK, subnetId);\n+        }\n+    }\n+\n+    @Override\n+    public SubnetSelectionResult filterSubnets(Collection<CloudSubnet> subnetMetas, SubnetSelectionParameters subnetSelectionParameters) {\n+        return gcpSubnetSelectorService.select(subnetMetas, subnetSelectionParameters);\n+    }\n+\n+    @Override\n+    public int subnetCountInDifferentAzMin() {\n+        return minSubnetCountInDifferentAz;\n+    }\n+\n+    @Override\n+    public int subnetCountInDifferentAzMax() {\n+        return maxSubnetCountInDifferentAz;\n+    }\n+\n+    private CloudContext getCloudContext(NetworkCreationRequest networkRequest) {\n+        return new CloudContext(\n+                networkRequest.getEnvId(),\n+                networkRequest.getEnvName(),\n+                CloudPlatform.GCP.name(),\n+                CloudPlatform.GCP.name(),\n+                location(networkRequest.getRegion()),\n+                networkRequest.getCreatorCrn(),\n+                networkRequest.getAccountId());\n+    }\n+\n+    private CloudContext getCloudContext(NetworkDeletionRequest networkRequest) {\n+        return new CloudContext(\n+                networkRequest.getEnvId(),\n+                networkRequest.getEnvName(),\n+                CloudPlatform.GCP.name(),\n+                CloudPlatform.GCP.name(),\n+                location(region(networkRequest.getRegion())),\n+                networkRequest.getUserId(),\n+                networkRequest.getAccountId());\n+    }\n+\n+    private Network buildNetworkForCreation(NetworkCreationRequest networkRequest) {\n+        Subnet subnet = new Subnet(networkRequest.getNetworkCidr());\n+        Map<String, Object> params = new HashMap<>();\n+        params.put(GcpStackUtil.NETWORK_IP_RANGE, networkRequest.getNetworkCidr());\n+        return new Network(subnet, params);\n+    }\n+\n+    private Network buildNetworkForDeletion(NetworkDeletionRequest networkRequest) {\n+        return new Network(null);\n+    }\n+\n+    private Network buildSubnetForCreation(NetworkCreationRequest networkRequest, String cidr) {\n+        Network network = buildNetworkForCreation(networkRequest);\n+        Subnet subnet = new Subnet(cidr);\n+        network = new Network(subnet, network.getParameters());\n+        return network;\n+    }\n+\n+    private CloudResource createSubnet(GcpContext context, AuthenticatedContext auth, Network network, CreatedSubnet subnet) {\n+        CloudResource cloudResource = gcpSubnetResourceBuilder.create(context, auth, network);\n+        try {\n+            cloudResource = gcpSubnetResourceBuilder.build(context, auth, network, null, cloudResource);\n+            PollTask<List<CloudResourceStatus>> task = statusCheckFactory.newPollResourceTask(gcpSubnetResourceBuilder,\n+                    auth, Collections.singletonList(cloudResource), context, true);\n+            subnet.setSubnetId(cloudResource.getName());\n+            syncPollingScheduler.schedule(task);\n+        } catch (Exception e) {\n+            LOGGER.debug(\"Skipping resource creation: {}\", e.getMessage());", "originalCommit": "7d71a0504ea930a18fdbed61035ac88137d56213", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NTg0OTQwNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r485849404", "bodyText": "this part will be disabled as a first drop", "author": "doktoric", "createdAt": "2020-09-09T19:09:07Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5MzYzNw=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5NDQxNA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483594414", "bodyText": "Can a JIRA be targetted for this and write TODO(CB-XXXX)? That way this isn't forgotten.", "author": "jamisonbennett", "createdAt": "2020-09-04T12:50:02Z", "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/GcpObjectStorageConnector.java", "diffHunk": "@@ -0,0 +1,65 @@\n+package com.sequenceiq.cloudbreak.cloud.gcp;\n+\n+import com.google.api.services.storage.Storage;\n+import com.google.api.services.storage.model.StorageObject;\n+import com.sequenceiq.cloudbreak.cloud.ObjectStorageConnector;\n+import com.sequenceiq.cloudbreak.cloud.gcp.util.GcpStackUtil;\n+import com.sequenceiq.cloudbreak.cloud.model.Platform;\n+import com.sequenceiq.cloudbreak.cloud.model.Variant;\n+import com.sequenceiq.cloudbreak.cloud.model.base.ResponseStatus;\n+import com.sequenceiq.cloudbreak.cloud.model.objectstorage.ObjectStorageMetadataRequest;\n+import com.sequenceiq.cloudbreak.cloud.model.objectstorage.ObjectStorageMetadataResponse;\n+import com.sequenceiq.cloudbreak.cloud.model.objectstorage.ObjectStorageValidateRequest;\n+import com.sequenceiq.cloudbreak.cloud.model.objectstorage.ObjectStorageValidateResponse;\n+import com.sequenceiq.common.api.cloudstorage.StorageLocationBase;\n+import org.springframework.stereotype.Service;\n+\n+@Service\n+public class GcpObjectStorageConnector implements ObjectStorageConnector {\n+\n+    @Override\n+    public ObjectStorageMetadataResponse getObjectStorageMetadata(ObjectStorageMetadataRequest request) {\n+        Storage storage = GcpStackUtil.buildStorage(request.getCredential(), request.getCredential().getName());\n+        try {\n+            StorageObject storageObject = storage.objects().get(GcpStackUtil.getBucketName(request.getObjectStoragePath()),\n+                    GcpStackUtil.getPath(request.getObjectStoragePath())).execute();\n+            return ObjectStorageMetadataResponse.builder()\n+                    .withStatus(ResponseStatus.OK)\n+                    .build();\n+        } catch (Exception e) {\n+            return ObjectStorageMetadataResponse.builder()\n+                    .withStatus(ResponseStatus.RESOURCE_NOT_FOUND)\n+                    .build();\n+        }\n+    }\n+\n+    @Override\n+    public ObjectStorageValidateResponse validateObjectStorage(ObjectStorageValidateRequest request) {\n+        // TODO: The following check is naive, beefup", "originalCommit": "7d71a0504ea930a18fdbed61035ac88137d56213", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4Mzc1NzU1Nw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483757557", "bodyText": "Thanks https://jira.cloudera.com/browse/CB-8678", "author": "cegganesh84", "createdAt": "2020-09-04T17:21:54Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5NDQxNA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5NjE3MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483596170", "bodyText": "String zone = compute.regions().get(projectId, region.value()).execute().getZones().stream()\n.findFirst()\n.map(zone -> zone.substring(zone.lastIndexOf('/') + 1))\n.orElse(null);", "author": "jamisonbennett", "createdAt": "2020-09-04T12:53:32Z", "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/GcpPlatformResources.java", "diffHunk": "@@ -126,9 +128,27 @@ public CloudNetworks networks(CloudCredential cloudCredential, Region region, Ma\n         String projectId = GcpStackUtil.getProjectId(cloudCredential);\n         Map<String, Set<CloudNetwork>> result = new HashMap<>();\n \n+        String networkId = null;\n+        String subnetId = null;\n+        if (filters != null) {\n+            networkId = filters.getOrDefault(\"networkId\", null);\n+            subnetId = filters.getOrDefault(\"subnetId\", null);\n+        }\n+\n+        LOGGER.debug(\"Get subnets with filter values, networkId : {}, subnetId : {}\", networkId, subnetId);\n         Set<CloudNetwork> cloudNetworks = new HashSet<>();\n-        NetworkList networkList = compute.networks().list(projectId).execute();\n-        List<Subnetwork> subnetworkList = compute.subnetworks().list(projectId, region.value()).execute().getItems();\n+        NetworkList networkList = StringUtils.isEmpty(networkId) ?\n+                compute.networks().list(projectId).execute() :\n+                new NetworkList().setItems(Collections.singletonList(compute.networks().get(projectId, networkId).execute()));\n+        SubnetworkList subnetworkList = StringUtils.isEmpty(subnetId) ?\n+                compute.subnetworks().list(projectId, region.value()).execute() :\n+                new SubnetworkList().setItems(Collections.singletonList(compute.subnetworks().get(projectId, region.value(), subnetId).execute()));\n+        // GCP VPCs are global. Subnets have a global scope in region. So picking the first availability zone in the region for subnet.\n+        String zone = compute.regions().get(projectId, region.value()).execute().getZones().stream().findFirst().orElse(null);\n+        if (zone != null) {\n+            zone = zone.substring(zone.lastIndexOf('/') + 1);\n+        }", "originalCommit": "7d71a0504ea930a18fdbed61035ac88137d56213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5ODQ3NA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483598474", "bodyText": "Since this is not sorted, it may produce different results every time its run.", "author": "jamisonbennett", "createdAt": "2020-09-04T12:57:47Z", "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/service/GcpSubnetSelectorService.java", "diffHunk": "@@ -0,0 +1,41 @@\n+package com.sequenceiq.cloudbreak.cloud.gcp.service;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Optional;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Service;\n+\n+import com.sequenceiq.cloudbreak.cloud.model.CloudSubnet;\n+import com.sequenceiq.cloudbreak.cloud.model.SubnetSelectionParameters;\n+import com.sequenceiq.cloudbreak.cloud.model.SubnetSelectionResult;\n+\n+@Service\n+public class GcpSubnetSelectorService {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GcpSubnetSelectorService.class);\n+\n+    public SubnetSelectionResult select(Collection<CloudSubnet> subnetMetas, SubnetSelectionParameters subnetSelectionParameters) {\n+        Optional<String> errorMessage = quickValidate(subnetMetas, subnetSelectionParameters);\n+        if (errorMessage.isPresent()) {\n+            LOGGER.debug(\"{}\", errorMessage.get());\n+            return new SubnetSelectionResult(errorMessage.get());\n+        }\n+        // GCP VPCs are global and different subnets can be in different geographies. So for safety just choosing the first subnet.\n+        CloudSubnet first = subnetMetas.stream().findFirst().get();", "originalCommit": "7d71a0504ea930a18fdbed61035ac88137d56213", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQzMTIzNw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r486431237", "bodyText": "yep and it is not a problem.", "author": "doktoric", "createdAt": "2020-09-10T15:23:17Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzU5ODQ3NA=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYxMDQ4Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483610483", "bodyText": "I would prefer if this was named isCloudEntitlementEnabeldForTheAccount().", "author": "jamisonbennett", "createdAt": "2020-09-04T13:19:58Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/template/ClusterTemplateCloudPlatformValidator.java", "diffHunk": "@@ -24,8 +25,21 @@ public ClusterTemplateCloudPlatformValidator(@Value(\"${cb.enabledplatforms:}\") S\n     }\n \n     public boolean isClusterTemplateCloudPlatformValid(String cloudPlatform, String accountId) {\n-        return (enabledPlatforms.contains(cloudPlatform) || CollectionUtils.isEmpty(enabledPlatforms))\n-                && (!AZURE.name().equalsIgnoreCase(cloudPlatform) || entitlementService.azureEnabled(INTERNAL_ACTOR_CRN, accountId));\n+        return isPlatformEnabled(cloudPlatform)\n+                && (notACloudPlatformWhichIsEntitlementSpecific(cloudPlatform) || isAzureOrGCPEntitlementEnabledForTheAccount(cloudPlatform, accountId));\n+    }\n+\n+    public boolean isPlatformEnabled(String cloudPlatform) {\n+        return enabledPlatforms.contains(cloudPlatform) || CollectionUtils.isEmpty(enabledPlatforms);\n+    }\n+\n+    private boolean notACloudPlatformWhichIsEntitlementSpecific(String cloudPlatform) {\n+        return !AZURE.name().equalsIgnoreCase(cloudPlatform) && !GCP.name().equalsIgnoreCase(cloudPlatform);\n+    }\n+\n+    private boolean isAzureOrGCPEntitlementEnabledForTheAccount(String cloudPlatform, String accountId) {", "originalCommit": "7d71a0504ea930a18fdbed61035ac88137d56213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYxMzI0OQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483613249", "bodyText": "nit: I find the naming with a \"not\" a little confusing.", "author": "jamisonbennett", "createdAt": "2020-09-04T13:24:43Z", "path": "core/src/main/java/com/sequenceiq/cloudbreak/service/template/ClusterTemplateCloudPlatformValidator.java", "diffHunk": "@@ -24,8 +25,21 @@ public ClusterTemplateCloudPlatformValidator(@Value(\"${cb.enabledplatforms:}\") S\n     }\n \n     public boolean isClusterTemplateCloudPlatformValid(String cloudPlatform, String accountId) {\n-        return (enabledPlatforms.contains(cloudPlatform) || CollectionUtils.isEmpty(enabledPlatforms))\n-                && (!AZURE.name().equalsIgnoreCase(cloudPlatform) || entitlementService.azureEnabled(INTERNAL_ACTOR_CRN, accountId));\n+        return isPlatformEnabled(cloudPlatform)\n+                && (notACloudPlatformWhichIsEntitlementSpecific(cloudPlatform) || isAzureOrGCPEntitlementEnabledForTheAccount(cloudPlatform, accountId));\n+    }\n+\n+    public boolean isPlatformEnabled(String cloudPlatform) {\n+        return enabledPlatforms.contains(cloudPlatform) || CollectionUtils.isEmpty(enabledPlatforms);\n+    }\n+\n+    private boolean notACloudPlatformWhichIsEntitlementSpecific(String cloudPlatform) {", "originalCommit": "7d71a0504ea930a18fdbed61035ac88137d56213", "replyToReviewId": null, "replies": [{"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4NjQzMTQ4MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r486431480", "bodyText": "what do you suggest here ?", "author": "doktoric", "createdAt": "2020-09-10T15:23:36Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYxMzI0OQ=="}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4ODkwNDM3MA==", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r488904370", "bodyText": "nit: I would probably word it isCloudEntitlementRequiredPlatform() and then change the above logic to isCloudEntitlementRequiredPlatform(cloudPlatform) && isCloudEntitlementEnabeledForTheAccount(cloudPlatform, accountId)", "author": "jamisonbennett", "createdAt": "2020-09-15T19:10:27Z", "replyToReviewId": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYxMzI0OQ=="}], "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYxODA5Mw==", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483618093", "bodyText": "nit: how about using a named constant for the bucket index and avoiding the magic number?", "author": "jamisonbennett", "createdAt": "2020-09-04T13:33:14Z", "path": "cloud-gcp/src/main/java/com/sequenceiq/cloudbreak/cloud/gcp/util/GcpStackUtil.java", "diffHunk": "@@ -241,6 +256,26 @@ public static String getTarName(String image) {\n         }\n     }\n \n+    public static String getBucketName(String objectStorageLocation) {\n+        String[] parts = createParts(objectStorageLocation);\n+        if (!StringUtils.isEmpty(objectStorageLocation) && parts.length > 1) {", "originalCommit": "7d71a0504ea930a18fdbed61035ac88137d56213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"id": "MDI0OlB1bGxSZXF1ZXN0UmV2aWV3Q29tbWVudDQ4MzYyMzkwMQ==", "url": "https://github.com/hortonworks/cloudbreak/pull/8918#discussion_r483623901", "bodyText": "nit: Can this message be improved to state that one of them is null, how about \"Either EnvironmentDto or NetworkDto is null. Neither them can be null.\"", "author": "jamisonbennett", "createdAt": "2020-09-04T13:43:14Z", "path": "environment/src/main/java/com/sequenceiq/environment/environment/validation/network/gcp/GcpEnvironmentNetworkValidator.java", "diffHunk": "@@ -0,0 +1,119 @@\n+package com.sequenceiq.environment.environment.validation.network.gcp;\n+\n+import static com.sequenceiq.cloudbreak.common.mappable.CloudPlatform.GCP;\n+\n+import java.util.Map;\n+import java.util.stream.Collectors;\n+\n+import org.apache.commons.collections.MapUtils;\n+import org.apache.commons.collections4.CollectionUtils;\n+import org.apache.commons.lang3.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+import org.springframework.stereotype.Component;\n+\n+import com.sequenceiq.cloudbreak.cloud.model.CloudSubnet;\n+import com.sequenceiq.cloudbreak.common.mappable.CloudPlatform;\n+import com.sequenceiq.cloudbreak.validation.ValidationResult;\n+import com.sequenceiq.environment.environment.dto.EnvironmentDto;\n+import com.sequenceiq.environment.environment.validation.network.EnvironmentNetworkValidator;\n+import com.sequenceiq.environment.network.CloudNetworkService;\n+import com.sequenceiq.environment.network.dto.GcpParams;\n+import com.sequenceiq.environment.network.dto.NetworkDto;\n+\n+@Component\n+public class GcpEnvironmentNetworkValidator implements EnvironmentNetworkValidator {\n+\n+    private static final Logger LOGGER = LoggerFactory.getLogger(GcpEnvironmentNetworkValidator.class);\n+\n+    private final CloudNetworkService cloudNetworkService;\n+\n+    public GcpEnvironmentNetworkValidator(CloudNetworkService cloudNetworkService) {\n+        this.cloudNetworkService = cloudNetworkService;\n+    }\n+\n+    @Override\n+    public void validateDuringFlow(EnvironmentDto environmentDto, NetworkDto networkDto, ValidationResult.ValidationResultBuilder resultBuilder) {\n+        if (environmentDto == null || networkDto == null) {\n+            LOGGER.warn(\"EnvironmentDto or NetworkDto. Neither them can be null!\");", "originalCommit": "7d71a0504ea930a18fdbed61035ac88137d56213", "replyToReviewId": null, "replies": null, "type": "inlineReview"}, {"oid": "2cb57ee1b7e075ba0a0cead1a9bae30f02d043aa", "url": "https://github.com/hortonworks/cloudbreak/commit/2cb57ee1b7e075ba0a0cead1a9bae30f02d043aa", "message": "Fixing SDX templates and network injection", "committedDate": "2020-09-09T17:02:06Z", "type": "forcePushed"}, {"oid": "64b9f8d931165e50e15aa5929fe7af092d1171cc", "url": "https://github.com/hortonworks/cloudbreak/commit/64b9f8d931165e50e15aa5929fe7af092d1171cc", "message": "CB-3252 fixing the unit test problem", "committedDate": "2020-09-11T19:16:10Z", "type": "forcePushed"}, {"oid": "eb5ec3524ace7567a4d031281b2113be343180bb", "url": "https://github.com/hortonworks/cloudbreak/commit/eb5ec3524ace7567a4d031281b2113be343180bb", "message": "CB-3252 remove local dev list", "committedDate": "2020-09-15T07:50:26Z", "type": "forcePushed"}, {"oid": "411c3a63fa0314999884ec881fb4c18df3e2b9de", "url": "https://github.com/hortonworks/cloudbreak/commit/411c3a63fa0314999884ec881fb4c18df3e2b9de", "message": "CB-3253 Initial Environment and GCP integration with request response pairs", "committedDate": "2020-09-15T18:27:14Z", "type": "commit"}, {"oid": "808740ae87feed468fe0d3b2783d9671fdfd7fc5", "url": "https://github.com/hortonworks/cloudbreak/commit/808740ae87feed468fe0d3b2783d9671fdfd7fc5", "message": "CB-3253\tGCP support for create environment using cli", "committedDate": "2020-09-15T18:27:14Z", "type": "commit"}, {"oid": "ca925986e1601b4d8f9c8e62d0a01e20e6202427", "url": "https://github.com/hortonworks/cloudbreak/commit/ca925986e1601b4d8f9c8e62d0a01e20e6202427", "message": "CB-3261 Bringup FreeIPA instance in GCP\n\n1. Add ability to get network information from Google cloud.\n2. Overhaul cost tagging service to work with google cloud tags.", "committedDate": "2020-09-15T18:27:14Z", "type": "commit"}, {"oid": "671ac7ece4b3ee51e10ef2e55cd8a1a18804a5cb", "url": "https://github.com/hortonworks/cloudbreak/commit/671ac7ece4b3ee51e10ef2e55cd8a1a18804a5cb", "message": "CB-8542\tTag needs to be transformed in one more place.", "committedDate": "2020-09-15T18:27:14Z", "type": "commit"}, {"oid": "c6fc772c9663e997aa8e15cb88b62a821332c677", "url": "https://github.com/hortonworks/cloudbreak/commit/c6fc772c9663e997aa8e15cb88b62a821332c677", "message": "CB-3253\tFirst GCP env successful with this change.\nThe security group here is the firewall rules target network tag.\nUpdated GCP connector jars", "committedDate": "2020-09-15T18:27:14Z", "type": "commit"}, {"oid": "fd31dd8896e75cab4e88979bc81f81fb18d454b9", "url": "https://github.com/hortonworks/cloudbreak/commit/fd31dd8896e75cab4e88979bc81f81fb18d454b9", "message": "CB-3261 GCP support - support for freeipa telemetry logging.", "committedDate": "2020-09-15T18:27:14Z", "type": "commit"}, {"oid": "acb5c62b3f31987fd631b933e60eb4651fc9eeb3", "url": "https://github.com/hortonworks/cloudbreak/commit/acb5c62b3f31987fd631b933e60eb4651fc9eeb3", "message": "CB-8504 decrease the required subnet for GCloud and fixing the entitlement validation", "committedDate": "2020-09-15T18:27:14Z", "type": "commit"}, {"oid": "b24af59371dfd75df060419c184c8933d2101e6f", "url": "https://github.com/hortonworks/cloudbreak/commit/b24af59371dfd75df060419c184c8933d2101e6f", "message": "CB-8504 For GCP support add the hostname to the instance while bringing it up.\n\n1. Hostname is reset by Google network manager https://groups.google.com/g/gce-discussion/c/fi2j7oP8bGM/m/mRYlt5OkDgAJ if the hostname is not set during creation.\n2. This will break freeipa health agent setup, since it depends on the hostname of the instance having proper domain.\n3. Tested this change in private stack to make sure Google does not reset the hostname that was set by salt.", "committedDate": "2020-09-15T18:27:14Z", "type": "commit"}, {"oid": "b63598a19f9ddb961351718c28447ff824129a29", "url": "https://github.com/hortonworks/cloudbreak/commit/b63598a19f9ddb961351718c28447ff824129a29", "message": "CB-8504 Fixing SDX templates and network injection", "committedDate": "2020-09-15T18:27:15Z", "type": "commit"}, {"oid": "806b82d58febca06fa8db815f49519c9abbca876", "url": "https://github.com/hortonworks/cloudbreak/commit/806b82d58febca06fa8db815f49519c9abbca876", "message": "CB-3252 fixing review comments", "committedDate": "2020-09-15T18:27:15Z", "type": "commit"}, {"oid": "93c6691ba5e73d0afb6b4a4fa86e9c9b6082585f", "url": "https://github.com/hortonworks/cloudbreak/commit/93c6691ba5e73d0afb6b4a4fa86e9c9b6082585f", "message": "CB-8536 added redbeams support to gcp", "committedDate": "2020-09-15T18:27:15Z", "type": "commit"}, {"oid": "878694aaa75ab5330d733e4c5f5918ca6b561a48", "url": "https://github.com/hortonworks/cloudbreak/commit/878694aaa75ab5330d733e4c5f5918ca6b561a48", "message": "CB-3255 Add GCP support in KerberosDetailService\n\n1. Datalake does not come up without this because CM keytab will be missing while starting CM.\n2. I am not sure about the TODO that says remove of FreeIPA registration being ready. It should be ready already, but just trying to keep the change minimal.", "committedDate": "2020-09-15T18:27:15Z", "type": "commit"}, {"oid": "8b824732c33cf78327ed0ee0770179b74d4166b4", "url": "https://github.com/hortonworks/cloudbreak/commit/8b824732c33cf78327ed0ee0770179b74d4166b4", "message": "CB-8504 cbd init for fixing the tests", "committedDate": "2020-09-15T18:27:15Z", "type": "commit"}, {"oid": "d030815a958d485aaf4b5a7507dfdffb325bb442", "url": "https://github.com/hortonworks/cloudbreak/commit/d030815a958d485aaf4b5a7507dfdffb325bb442", "message": "CB-3252 fixing the unit test problem", "committedDate": "2020-09-15T18:27:15Z", "type": "commit"}, {"oid": "99b824d9d3c86ec7b4de0f65f9ed769de1a7a026", "url": "https://github.com/hortonworks/cloudbreak/commit/99b824d9d3c86ec7b4de0f65f9ed769de1a7a026", "message": "CB-3252 fixing the broken integration test", "committedDate": "2020-09-15T18:27:15Z", "type": "commit"}, {"oid": "c14a5c32e2af54db766a30b5acbd550ea7c9d23e", "url": "https://github.com/hortonworks/cloudbreak/commit/c14a5c32e2af54db766a30b5acbd550ea7c9d23e", "message": "CB-3252 remove local dev list", "committedDate": "2020-09-15T18:27:15Z", "type": "commit"}, {"oid": "c14a5c32e2af54db766a30b5acbd550ea7c9d23e", "url": "https://github.com/hortonworks/cloudbreak/commit/c14a5c32e2af54db766a30b5acbd550ea7c9d23e", "message": "CB-3252 remove local dev list", "committedDate": "2020-09-15T18:27:15Z", "type": "forcePushed"}]}